6
1
0
2
 
b
e
F
 
7
1
 
 
]

G
L
.
s
c
[
 
 
1
v
8
6
5
5
0
.
2
0
6
1
:
v
i
X
r
a

Multi-layer Representation Learning
for Medical Concepts

Edward Choi∗ Mohammad Taha Bahadori∗

Elizabeth Searles† Catherine Coﬀey†

Jimeng Sun∗
∗ Georgia Institute of Technology
† Children Healthcare of Atlanta

Abstract

Learning eﬃcient representations for concepts has been proven to be an important basis
for many applications such as machine translation or document classiﬁcation. Proper repre-
sentations of medical concepts such as diagnosis, medication, procedure codes and visits will
have broad applications in healthcare analytics. However, in Electronic Health Records (EHR)
the visit sequences of patients include multiple concepts (diagnosis, procedure, and medication
codes) per visit. This structure provides two types of relational information, namely sequen-
tial order of visits and co-occurrence of the codes within each visit. In this work, we propose
Med2Vec, which not only learns distributed representations for both medical codes and visits
from a large EHR dataset with over 3 million visits, but also allows us to interpret the learned
representations conﬁrmed positively by clinical experts. In the experiments, Med2Vec displays
signiﬁcant improvement in key medical applications compared to popular baselines such as Skip-
gram, GloVe and stacked autoencoder, while providing clinically meaningful interpretation.

1

Introduction

Discovering eﬃcient representations of discrete high dimensional concepts has been a key challenge
in a variety of applications recently [3]. Using various types of neural networks, high-dimensional
raw data can be transformed to continuous real-valued concept vectors that eﬃciently capture
their latent relationship from data. Such succinct representations have been shown to improve the
performance of various complex tasks across domains spanning from image processing [22, 17, 34],
language modeling [4, 24], word embedding [25, 29], music information retrieval [30], sentiment
analysis [31], and more recently multi-modal learning of images and text [18].

Eﬃcient representations for concepts is an important, if not essential, element in healthcare as
well. Healthcare concepts contain rich latent relationships that cannot be represented by simple
one-hot coding [28, Chapter 2.3.2]. For example, pneumonia and bronchitis are clearly more related
than pneumonia and obesity. In one-hot coding, such relationship between diﬀerent codes are not
represented. Despite its limitation, many healthcare applications [7, 1] still use the simple sum
over one-hot vectors to derive patient feature vectors. To overcome this limitation, it is common in
healthcare applications, to rely on carefully designed feature representations [32, 16, 36]. However,
this process often involves supervision information and ad-hoc feature engineering that requires
considerable expert medical knowledge and is not scalable in general.

Recently, studies have shown that it is possible to learn eﬃcient representations of health-
care concepts without medical expertise and still signiﬁcantly improve the performance of various

1

[9] learned distributed representations of medical codes (e.g.
healthcare applications. Choi et al.
diagnosis, medication, procedure codes) using Skip-gram [25] and applied them to heart failure
prediction. Choi et al.
[10] also learned the representations for medical concepts from a medical
claims dataset and compared the learned representations to existing medical ontologies and code
groupers. Despite these progress, learning eﬃcient representations of healthcare concepts, however,
is still an open challenge. The diﬃculty stems from several aspects:

1. Healthcare data have a unique structure where the visits are temporally ordered but the
medical codes within a visit form an unordered set. A sequence of visits possesses sequential
relationship among them which cannot be captured by simply aggregating code-level repre-
sentations. Moreover, given the demographic information for patients, the structure becomes
more complex.

2. Learned representations should be interpretable. While the interpretability of the model in
the clinical domain is considered to be an essential requirement, some of the state-of-the art
representation learning methods such as recurrent neural networks (RNN) are diﬃcult to
interpret.

3. The algorithm should be scalable enough to handle real-world healthcare datasets with mil-

lions of patients and hundred millions of visits.

To address such challenges in healthcare concept representation learning, we propose Med2Vec and
make the following contributions.

• We propose Med2Vec, a simple and robust algorithm to eﬃciently learn succinct code-, and
visit-level representations by using real-world electronic health record (EHR) datasets, with-
out depending on expert medical knowledge.

• Med2Vec learns interpretable representations and enables clinical applications to oﬀer more
than just improved performances. We conducted detailed user study with clinical experts to
validate the interpretability of the resulting representation.

• We conduct experiments to demonstrate the scalability of Med2Vec, and show that our model
can be readily applied to near 30K medical codes over two large datasets with 3 million and
5.5 million visits, respectively.

• We apply the learned representations to various real-world health problems and demonstrate

the improved performance enabled by Med2Vec compared to popular baselines.

In the following section, we discuss related works, then describe our method in section 3. In
section 4, we explain experiment design and interpretation method in detail. We present the results
and discussion in section 5. Then we conclude this paper with future work in section 6.

2 Preliminaries and Related Work

In this section, we ﬁrst describe the preliminary ideas used in learning representation for words.
Then, we review the algorithms developed for representing healthcare data.

2

Figure 1: Skip-gram model architecture: v(wt) is a vector representation for the word wt. The goal
of Skip-gram is to learn vector representations of words that are good at predicting neighboring
words.

2.1 Learning representation for words

Representation learning of words using neural network based methods have been studied since
the early 2000’s [4, 12, 27, 33]. Among these techniques, Skip-gram [25] is the basis of many
concept representation learning methods, including our own. Skip-gram is able to capture the
subtle relationships between words, thus outperforming the previous works in a word analogy
task[23].

Given a sequence of words w1, w2, . . . , wT , Skip-gram learns the word representations based
on the co-occurrence information of words inside a context window of a predeﬁned size. The key
principle of Skip-gram is that a word’s representation should be able to predict the neighboring
words. The objective of Skip-gram is to maximize the following average log probability.

T
(cid:88)

1
T

t=1

−c≤j≤c,j(cid:54)=0

(cid:88)

log p(wt+j|wt)

p(wO|wI ) =

(cid:16)

exp

(cid:17)

vwI

v(cid:48)(cid:62)
wO
(cid:16)

(cid:80)W

w=1 exp

v(cid:48)(cid:62)
w vwI

(cid:17)

where c is the size of the context window. The conditional probability is deﬁned by the softmax
function:

where vw and v(cid:48)
w are the input and output vector representations of word w. W is the number
of words in the vocabulary. Basically, Skip-gram tries to maximize the softmax probability of the
inner product of the center word’s vector and its context word’s vectors.1

Pennington et al. proposed GloVe, [29] which learns another word representations by using a
similar principle as Skip-gram. GloVe uses the global word co-occurrence matrix to learn the word
representations. Since the global co-occurrence matrix is often sparse, GloVe can be computation-
ally less demanding than Skip-gram, which is a neural network model using the sliding context
window. On the other hand, GloVe employs a weighting function that could require a considerable
amount tuning eﬀort.

1Mikolov et al.

[25] also use hierarchical softmax and negative sampling to speed up the learning process. We

focus on the original simple formulation.

3

Beyond one level representation like Skip-gram and GloVe, researchers also proposed hierarchical
learning representations for the text corpus, which has some analogy to our healthcare setting with
two level concepts namely: codes and visits. Le and Mikolov [20] proposes to learn representations
for paragraphs and words simultaneously by treating paragraphs as one of the words. However,
their algorithm assigns a ﬁxed set of vectors for both words and paragraphs in the training data.
Moreover, their approach does not capture the sequential order among paragraphs. Skip-thought
[19] proposes an encoder-decoder structure: an encoder (Gated Recurrent Units (GRU) in their
case) learns a representation for a sentence that is able to regenerate its surrounding sentences
(via GRU again). Skip-thought cannot be applied directly to EHR data because unlike words in
sentences, the codes in a visit are unordered. Also, the interpretation of Skip-thought model is
diﬃcult, as they rely on complex RNNs.

2.2 Representation learning in healthcare

Recently researchers start to explore the possibility of eﬃcient representation learning in the medical
domain.

Medical text analysis Minarro et al.
[26] learns the representations of medical terms by ap-
plying Skip-gram to various medical text collected from PubMed, Merck Manuals, Medscape and
Wikipedia. De Vine et al. [13] learns the representations of UMLS concepts from free-text patient
records and medical journal abstracts. They ﬁrst replaced the words in documents to UMLS con-
cepts, then applied Skip-gram to learn the distributed representations of the concepts. However,
none of them studied longitudinal EHR data with a large number of medical codes.

[9], and Choi et al.

Structured visit records analysis Choi et al.
[10] both learned the dis-
tributed representation of medical codes (e.g. diagnosis, medication, procedure codes) from struc-
tured longitudinal visit records of patients using Skip-gram. In addition, the authors demonstrated
that simply aggregating the learned representation of medical codes to create a visit representation
leads to improved predictive performance. However, simply aggregating the code representations
is not the optimal method to generate a visit representation as it completely ignores the tempo-
ral relations across adjacent visits. We believe that taking advantage of the two-level information
(the co-occurrence of codes within a visit and the sequential nature of visits) and the demographic
information of patients will give us better representation for both medical codes and patient visits.
[8] trained a recurrent neural networks (RNN) model to analyze the longitudinal
patient records in a temporal order, and predict the diagnosis and medication codes the patient
will receive in the future. In [8], the hidden layer of the RNN can be seen as the representation of
the patient status over time. However, despite its outstanding performance, RNNs are diﬃcult to
interpret.

Choi et al.

3 Method

In this section, we describe the proposed algorithm Med2Vec. We start by mathematically for-
mulating the EHR data structure and our goal. Then we describe our approach in a top-down
fashion. We also explain how to interpret the learned representations. We conclude this section
with complexity analysis.

4

Figure 2: Structure of Med2Vec: A visit comprised of several medical codes is converted to a binary
vector xt ∈ {0, 1}|C|. The binary vector is then converted to an intermediate visit representation
ut. ut is concatenated with a vector of demographic information dt, and converted to the ﬁnal visit
representation vt, which is trained to predict its neighboring visits . . . , xt−2, xt−1, xt+1, xt+2, . . .

EHR structure and our notation We denote the set of all medical codes c1, c2, . . . , c|C| in our
EHR dataset by C with size |C|. EHR data for each patient is in the form of a sequence of visits
V1, . . . , VT where each visit contains a subset of medical codes Vt ⊆ C. Without loss of generality, all
algorithms will be presented for a single patient to avoid cluttered notations. The goal of Med2Vec
is to learn two types of representations:

Code representations We aim to learn an embedding function fC : C (cid:55)→ Rm

+ that maps every
code in the set of all medical codes C to non-negative real-valued vectors of dimension m. The
non-negativity constraint is introduced to improve interpretability, as discussed in details in
Section 3.5.

Visit representations Our second task is to learn another embedding function fV : V (cid:55)→ Rn that
maps every visit (a set of medical codes) to a real-valued vector of dimension n. The set V is
the power set of the set of codes C.

3.1 Med2Vec architecture

Figure 2 depicts the architecture of Med2Vec. Given a visit Vt, we use a multi-layer perceptron
(MLP) to to generate the corresponding visit representation vt. First, visit Vt is represented by a
binary vector xt ∈ {0, 1}|C| where the i-th entry is 1 only if ci ∈ Vt. Then xt is converted to an
intermediate visit representation ut ∈ Rm as follows,

ut = ReLU (Wcxt + bc)

(1)

using the code weight matrix Wc ∈ Rm×|C| and the bias vector bc ∈ Rm. The rectiﬁed linear unit
is deﬁnes as ReLU (v) = max(v, 0). Note that max() applies element-wise to vectors. We use

5

the rectiﬁed linear unit (ReLU) as the activation function to enable interpretability, which will be
discussed in section 3.3.

We concatenate the demographic information dt ∈ Rd, where d is the size of the demographic in-
formation vector, to the intermediate visit representation ut and create the ﬁnal visit representation
vt ∈ Rn as follows,

vt = ReLU (Wv[ut, dt] + bv)

using the visit weight matrix Wv ∈ Rn×(m+d) and the bias vector bv ∈ Rn, where n is the predeﬁned
size of the visit representation. We use ReLU once again as the activation function. We discuss
our eﬃcient training procedure of the parameters Wc, bc, Wv and bv in the next subsection.

3.2 Learning from the visit-level information

As mentioned in the introduction, the sequential information of visits can be exploited for learning
eﬃcient representations of visits and potentially codes. We train the MLP using a very straightfor-
ward intuition as follows: a visit describes a state in a continuous process that is a patient’s clinical
experience. Therefore, given a visit representation, we should be able to predict what has happened
in the past, and what will happen in the future. Speciﬁcally, given a visit representation vt, we
train a softmax classiﬁer that predicts the medical codes of the visits within a context window. We
minimize the cross entropy error as follows,

−xt+i

(cid:62) log ˆyt − (1 − xt+i)(cid:62) log(1 − ˆyt),

(2)

T
(cid:88)

(cid:88)

min
Ws,bs

1
T

t=1

−w≤i≤w,i(cid:54)=0

where

ˆyt =

exp(Wsvt + bs)
j=1 exp(Ws[j, :]vt + bs[j])

(cid:80)|C|

where Ws ∈ R|C|×n and bs ∈ R|C| are the weight matrix and bias vector for the softmax classiﬁer,
w the predeﬁned context window size, exp the element-wise exponential function, and 1 denotes
an all one vector. We have used MATLAB’s notation for selecting a row in Ws and a coordinate
of bs.

3.3 Learning from the code-level information

As we described in the introduction, healthcare datasets contain two-level information: visit-level
sequence information and code-level co-occurrence information. Since the loss function in Eq. (2)
can eﬃciently capture the sequence level information, now we need to ﬁnd a way to use the second
source of information, i.e., the intra-visit co-occurrence of the codes.

A natural choice to capture the code co-occurrence information is to use Skip-gram. The main
idea would be that the representations for the codes that occur in the same visit should predict
each other. To embed Skip-gram in Med2Vec, we can train Wc ∈ Rm×|C| (which also produces
intermediate visit level representations) so that the i-th column of Wc will be the representation
for the i-th medical code among total |C| codes. Note that given the unordered nature of the codes
inside a visit, unlike the original Skip-gram, we do not distinguish between the “input” medical
code and the “output” medical code.
In text, it is sensible to assume that a word can serve a
diﬀerent role as a center word and a context word, whereas in EHR datasets, we cannot classify
codes as center or context codes. It is also desirable to learn the representations of diﬀerent types of

6

codes (e.g. diagnosis, medication, procedure code) in the same latent space so that we can capture
the hidden relationships between them.

However, precise interpretation of Skip-gram codes will be diﬃcult as Wc will have positive and
negative values. For intuitive interpretation, we should learn code representations with non-negative
values. Note that in Eq.(1), if the binary vector xt is a one-hot vector, then the intermediate visit
representation ut becomes a code representation. Therefore, using the Skip-gram algorithm, we
train the non-negative weight ReLU (Wc) instead of Wc. This will not only use the intra-visit
co-occurrence information, but also guarantee non-negative code representations. Moreover, ReLU
produces sparse code representations, which further facilitates easier interpretation of the codes.

The code representations to be learned is denoted as a matrix W (cid:48)

c = ReLU (Wc) ∈ Rm×|C|. From
a sequence of visits V1, V2, . . . , VT , the code-level representations can be learned by maximizing the
following log-likelihood,

min
W (cid:48)
c

1
T

T
(cid:88)

t=1

(cid:88)

(cid:88)

log p(cj|ci),

exp

i:ci∈Vt
(cid:16)

j:cj ∈Vt,j(cid:54)=i
W (cid:48)
c[:, j](cid:62)W (cid:48)
(cid:16)

(cid:17)
c[:, i]

(cid:80)|C|

k=1 exp

W (cid:48)

c[:, k](cid:62)W (cid:48)

c[:, i]

(cid:17) .

where p(cj|ci) =

(3)

(4)

3.4 Uniﬁed training

The single uniﬁed framework can be obtained by adding the two objective functions (3) and (2) as
follows,

argmin
W ,b

1
T

T
(cid:88)

(cid:110)

−

t=1

(cid:88)

+

−w≤k≤w,k(cid:54)=0

(cid:88)

(cid:88)

log p(cj|ci)

j:cj ∈Vt,j(cid:54)=i

i:ci∈Vt
(cid:111)
t+k log ˆyt − (1 − xt+k)(cid:62) log(1 − ˆyt)

−x(cid:62)

By combining the two objective functions we learn both code representations and visit repre-
sentations from the same source of patient visit records, exploiting both intra-visit co-occurrence
information as well as inter-visit sequential information at the same time.

3.5 Interpretation of learned representations

While the original Skip-gram learns code representations that have interesting properties such
as additivity, in healthcare we need stronger interpretability. We need to be able to associate
clinical meaning to each dimension of both code and visit representations. Interpreting the learned
representations is based on analyzing each coordinate in both code and visit embedding spaces.

Interpreting code representations
If information is properly embedded into a lower dimen-
sional non-negative space, each coordinate of the lower dimension can be readily interpreted. Non-
negative matrix factorization (NMF) is a good example. Since we trained ReLU (Wc) ∈ Rm×|C|, a
non-negative matrix, to represent the medical codes, we can employ a simple method to interpret

7

the meaning of each coordinate of the m-dimensional code embedding space. We can ﬁnd the top
k codes that have the largest values for the i-th coordinate of the code embedding space as follows,

argsort(Wc[i, :])[1 : k]

where argsort returns the indices of a vector that index its values in a descending order. By studying
the returned medical codes, we can view each coordinate as a disease group. Detailed examples are
given in section 5.1

Interpreting visit representations To interpret the learned visit vectors, we can use the
same principle we used for interpreting the code representation. For the i-th coordinate of the
n-dimensional visit embedding space, we can ﬁnd the top k coordinates of the code embedding
space that have the strongest values as follows,

argsort(Wv[i, :])[1 : k]

where we use the same argsort as before. Once we obtain a set of code coordinates, we can use
the knowledge learned from interpreting the code representations to understand how each visit
coordinate is associated with a group of diseases. This simple interpretation is possible because the
intermediate visit representation ut is a non-negative vector, due to the ReLU activation function.
In the experiments, we also tried to ﬁnd the input vector xt that most activates the target visit
coordinate [14, 21]. However, the results were very sensitive to the initial value of xt, and even
averaging over multiple samples were producing unreliable results.

3.6 Complexity analysis

We ﬁrst analyze the computational complexity of the code-level objective function Eq. (3). Without
loss of generality, we assume the visit records of all patients are concatenated into a single sequence
of visits. Then the complexity for Eq. (3) is as follows,

O(T M 2|C|m)

where T is the number of visits, M 2 is the average of squared number of medical codes within a
visit, |C| the number of unique medical codes, m the size of the code representation. The M 2 factor
comes from iterating over all possible pairs of codes within a visit. The complexity of the visit-level
objective function Eq.(2) is as follows,

O(T w(|C|(m + n) + mn))

where w is the size of the context window, n the size of the visit representation. The added terms
come from generating a visit representation via MLP. Since size of code representation m and size
of visit representation n generally have the same order of magnitude, we can replace n with m.
Furthermore, m is generally smaller than |C| by at least two orders of magnitude. Therefore the
overall complexity of Med2Vec can be simpliﬁed as follows.

Here we notice that M 2 is generally larger than w. In our work, the average number of codes M
per visit for two datasets are 7.88 and 3.19 according to Tables 1, respectively, whereas we select

O(T |C|m(M 2 + w))

8

Table 1: Basic statistics of CHOA and CMS dataset.
CMS
831,210
5,464,950
6.57
21,033
14,111
N/A
6,922
3.19
44

Dataset
# of patients
# of visits
Avg. # of visits per patient
# of unique medical codes
- # of unique diagnosis codes
- # of unique medication codes
- # of unique procedure codes
Avg. # of codes per visit
Max # of codes per visit
(95%, 99%) percentile
# of codes per visit

CHOA
550,339
3,359,240
6.1
28,840
10,414
12,892
5,534
7.88
440

(22, 53)

(9, 13)

the window size w to be at most 5 in our experiments. Therefore the complexity of Med2Vec is
dominated by the code representation learning process, for which we use the Skip-gram algorithm.
This means that exploiting visit-level information to learn eﬃcient representations for both visits
and codes does not incur much additional cost.

4 Experiments

In this section, we evaluate the performance of Med2Vec in both public and proprietary datasets.
First we describe the datasets. Then we describe evaluation strategies for code and visit representa-
tions, along with implementation details. Then we present the experiment results of code and visit
representations with discussion. We conclude with convergence and scalability study. We make the
source code of Med2Vec publicly available at https://github.com/mp2893/med2vec.

4.1 Dataset description

We evaluate performance of Med2Vec on a dataset provided by Children’s Healthcare of Atlanta
(CHOA)2. We extract visit records from the dataset, where each visit contains several medical
codes (e.g. diagnosis, medication, procedure codes). The diagnosis codes follow ICD-9 codes, the
medication codes are denoted by National Drug Codes (NDC), and the procedure codes follow
Category I of Current Procedural Terminology (CPT). We exclude patients who had less that two
visits to showcase Med2Vec’s ability to use sequential information of visits. The basic statistics of
the dataset are summarized in Table 1. The data are fully de-identiﬁed and do not include any
personal health information (PHI).

We divide the dataset into two groups in a 4:1 ratio. The former is used to train Med2Vec. The
latter is held oﬀ for evaluating the visit-level representations, where we train models to predict
visit-related labels. The details of the evaluation will be provided in the following subsections.

We also use CMS dataset, a publicly available3 synthetic EHR dataset. The basic information
of CMS is also given in Table 1. Compared to CHOA dataset, the CMS dataset has more patients

2http://www.choa.org/
3https://www.cms.gov/Medicare/Quality-Initiatives-Patient-Assessment-Instruments/OASIS/DataSet.

html

9

but fewer unique medical codes. The average number of codes per visit is also smaller than that
of CHOA dataset. Since CMS dataset is synthetic, we use it only for testing the scalability of
Med2Vec and baseline models in section 4.7.

4.2 Evaluation Strategy of code representations

Qualitative evaluation by medical experts For a comprehensive qualitative evaluation, we
perform a relatedness test by selecting 100 most frequent diagnosis codes and their 5 closest diag-
noses, medications and procedures in terms of cosine similarity. This allow us to know if the learned
representations eﬀectively capture the latent relationships among them. Two medical experts from
CHOA check each item and assign related, possible and unrelated labels.

Quantitative evaluation with baselines We use medical code groupers to quantitatively eval-
uate the code representations. Code groupers are used to collapse individual medical codes into
clinically meaningful categories. For example, Clinical Classiﬁcations Software (CCS) groups ICD9
diagnosis codes into 283 categories such as tuberculosis, bacterial infection, and viral infection.

We apply K-means clustering to the learned code representations and calculate the normalized
mutual information (NMI) based on the group label of each code. We use the CCS as the ground
truth for evaluating the code representation for diagnosis. For medication code evaluation, we
use American Hospital Formulary Service (AHFS) pharmacologic-therapeutic classiﬁcation, which
groups NDC codes into 165 categories. For procedure code evaluation, we use the second-level
grouping of CPT category I, which groups CPT codes into 115 categories.Thus, we set the number
of clusters k to 283, 165, 115 respectively for the diagnosis, medication, procedure code evaluation,
which matches the numbers of groups from individual groupers.

For baselines, we use popular methods that eﬃciently exploit co-occurrence information. Skip-
gram (which is used in learning representations of medical concepts by [10, 9]) is trained using Eq.
(3). GloVe will be trained on the co-occurrence matrix of medical codes, for which we counted
the codes co-occurring within a visit. Additionally, we also report well-known baselines such as
singular value decomposition on the co-occurrence matrix.

4.3 Evaluation strategy of visit representation

We evaluate the quality of the visit representations by performing two visit-level prediction tasks:
predicting the future visit and predicting the present status. The former will evaluate a visit
representation’s potential eﬀectiveness in predictive healthcare while the latter will evaluate the
how well it captures the information in the given visit. The details of the two tasks are given
below.
Predicting future medical codes: We predict the medical codes that will occur in the next visit
using the visit representations. Speciﬁcally, given two consecutive visits Vi and Vj, the medical
codes c ∈ Vj will be the target y, the medical codes c ∈ Vi will be the input x, and we use softmax
to predict y given x. The predictive performance will be measured by Top-k Recall, which mimics
the diﬀerential diagnosis conducted by doctors. We set k = 30 to cover even the complex cases of
CHOA dataset, as over 167,000 visits are assigned with more than 20 medical codes according to
Table 1. We predict the grouped medical codes, obtained by the medical groupers used in Section
4.2.

10

Predicting Clinical Risk Groups (CRG) level: A patient’s CRG level indicates his severity
level. It ranges from 1 to 9, including 5a and 5b. The CRG levels can be divided into two groups:
non-severe (CRG 1-5a) and severe (CRG 5b-9). Given a visit, we use logistic regression to predict
the binary CRG class associated with the visit. We use Area Under The Curve (AUC) to measure
the classiﬁcation accuracy, as it is more robust to class imbalance in data.

Baselines For baselines, we use the following methods.
Binary vector model (One-hot+): In order to compare with the raw input data, we use the
binary vector xt as the visit representation.
Stacked autoencoder (SA): Stacked autoencoder is one of the most popular unsupervised rep-
resentation learning algorithms [35]. Using the binary vector xt concatenated with patient demo-
graphic information as the input, we train a 3-layer stacked autoencoder (SA) [5] to minimize the
reconstruction error. The trained SA will then be used to generate visit representations.
Sum of Skip-gram vectors (Skip-gram+): We ﬁrst learn the code-level representations with
Skip-gram only (Eq. (3)). Then for the visit-level representation, we simply add the representations
of the codes within the visit. This approach was proven very eﬀective for heart failure prediction
in [9]. We append patient demographic information at the end.
Sum of GloVe vectors (GloVe+): We perform the same process as Skip-gram+, but use GloVe
vectors instead of Skip-gram vectors. We use the recommended hyperparameter setting from [29].

Evaluation details We use the held-oﬀ dataset, which was not used to learn the code and visit
representations, to perform the two prediction tasks. The held-oﬀ dataset contains 672,110 visits
assigned with CRG levels. In order to train the predictors, we divide the held-oﬀ data to training
and testing folds with ration 4:1. Both softmax and logistic regression are trained for 10 epochs
on the training fold. We perform 5-fold cross validation for each task to tune the regularization
parameter. For all baseline models and Med2Vec, we use age, sex and ethnicity as the demographic
information in the input data.

4.4 Implementation and training details

For learning code and visit representations using Med2Vec and all baselines, we use Adadelta [37] in
a mini-batch fashion. For Skip-gram, SA and Med2Vec, we use 1,000 visits4 per batch. For GloVe,
we use 1,000 non-zero entries of the co-occurrence matrix per batch. The optimization terminates
after a ﬁxed number of epochs. In section 4.6, we show the relationship between training epochs
and the performance. We also show the convergence behavior of Med2Vec and the baselines in
section 4.7.

Med2Vec, Skip-gram, GloVe and SA are implemented with Theano 0.7.0 [6]. K-means clustering
for the code-level evaluation and SVD are performed using Scikit-learn 0.14.1. Softmax and logistic
regression models for the visit-level evaluation are implemented with Keras 0.3.1, and trained for 10
epochs. All tasks are executed on a machine equipped with Intel Xeon E5-2697v3, 256GB memory
and two Nvidia K80 Tesla cards.

We train multiple models using various hyperparameter settings. For all models we vary the
size of the code representations m (or the size of the hidden layer for SA), and the number of

4for eﬃcient computation, we preprocessed the EHR dataset so that the visit records of all patients are concate-

nated into a single sequence of visits.

11

Table 2: Average score of the medical codes from the relatedness test. 2 was assigned for related,
1 for possible and 0 for unrelated

Average Diagnosis Medication Procedure

1.34

1.59

0.95

1.47

Table 3: Clustering NMI of the diagnosis, medication and procedure code representations of various
models. All models learned 200 dimensional code vectors. All models except SVD were trained for
10 epochs.

Model
SVD (σV (cid:62))
Skip-gram
GloVe
Med2Vec

Diagnosis Medication Procedure
0.0843
0.1216
0.2163
0.1089

0.1824
0.2251
0.4205
0.2328

0.1781
0.2432
0.3499
0.21

training epochs. Additionally for Med2Vec, we vary the size of the visit representations n, and the
size of the visit context window w.

To alleviate the curse of dimensionality when training the softmax classiﬁer (Eq.(2)) of Med2Vec,
we always use the medical code groupers of section 4.2 so that the softmax classiﬁer is trained to
predict the grouped medical codes instead of the exact medical codes. To conﬁrm the impact of
this strategy, we train an additional Med2Vec without using the medical code groupers.

4.5 Results of the code-level evaluation

Table 2 shows the average score of the medical codes from the qualitative code evaluation. On
average, Med2Vec successfully captures the relationship between medical codes. However, Med2Vec
seems to have a hard time capturing proper representation of medications. This is due to the
precise nature the medication prescription. For example, Med2Vec calculated that Oﬂoxacin, an
antibiotic sometimes used to treat middle-ear infection, was related to sensorineural hearling loss
(SNHL), an inner-ear problem. On the surface level, this is a wrong relationship. But Med2Vec can
be seen as capturing the deeper relationship between medical concepts that is not always clear on
the surface level.

Table 3 shows the clustering NMI of diagnosis, medication and procedure codes, measured for
various models. Med2Vec shows more or less similar conformity to the existing groupers as Skip-
gram. SVD shows the weakest conformity among all models. GloVe exhibits signiﬁcantly stronger
conformity than any other models. Exploiting the global co-occurrence matrix seems to help learn
code representations where similar codes are closer to each other in terms of Euclidean distance.

However, the degree of conformity of the code representations to the groupers does not neces-
sarily indicate how well the code representations capture the hidden relationships. For example,
CCS categorizes ICD9 224.4 Benign neoplasm of cornea as CCS 47 Other and unspeciﬁed benign
neoplasm, and ICD9 370.00 Unspeciﬁed corneal ulcer as CCS 91 Other eye disorders. But the two
diagnosis codes are both eye related problems, and they could be considered related in that sense.
Therefore we recommend the readers use the evaluation results for comparing the performance
between Med2Vec and other baselines, rather than for measuring the absolute performance.

In the following visit-level evaluation, we show that the code representations’ strong conformity

12

Figure 3: The top row and the bottom row respectively show the Recall@30 for predicting the future
medical codes and the AUC for predicting the CRG class when changing diﬀerent hyperparameters.
The basic conﬁguration for Med2Vec is m, n = 200, w = 1, and the training epoch set to 10. The
basic conﬁguration for all baseline models is 200 for code representation size (or hidden layer size)
In each column, we change one hyperparameter while ﬁxing
and training epoch also set to 10.
others to the basic conﬁguration.

Figure 4: The ﬁrst ﬁgure shows the convergence behavior of all models on the CHOA dataset. The
second and third ﬁgures show the relationship between the training time and the dataset size for
all models respectively using the CHOA dataset and the CMS dataset.

13

Table 4: Performance comparison of two Med2Vec models. The top row was trained with the
grouped code as mentioned in section 4.4. The bottom row was trained without using the groupers.
Both models were trained for 10 epochs with m, n = 200, w = 1.

Model
Grouped codes
Exact codes

Future code prediction CRG prediction

0.7605
0.7574

0.9150
0.9155

to the existing groupers alone does not directly transfer to good visit representations.

4.6 Results of the visit-level evaluation

The ﬁrst row of Figure 3 shows the Recall@30 for predicting the future medical codes. First, in all of
the experiments, Med2Vec achieves the highest performance, despite the fact that it is constrained
to be positive and interpretable. The second observation is that Med2Vec’s performance is robust to
choice of the hyperparameters in a wide range of values. Comparing to a more volatile performance
of Skip-gram, we can see that including the visit information in training not only improves the
performance, but also stabilizes it too.

Another fascinating aspect of the results is the overﬁtting pattern in diﬀerent algorithms. In-
creasing the code representation size degrades the performance of all of the algorithms, as it leads
to overﬁtting. Similar behavior can be seen as we train GloVe+ for more epochs which suggests
early stopping technique should be used in representation learning [2]. For Med2Vec, increasing the
visit representation size n seems to have the strongest inﬂuence to its predictive performance.

The bottom row of ﬁgures in Figure 3 shows the AUC for predicting the CRG class of the given
visit. The overﬁtting patterns are not as prominent as the previous task. This is due to the diﬀerent
nature of the two prediction tasks. While the goal of CRG prediction is to predict a value related
to the current visit, predicting the future codes is taking a step away from the current visit. This
diﬀerent nature of the two tasks also contributes to the better performance of One-hot+ on the
CRG prediction. One-hot+ contains the entire information of the given visit, although in a very
high-dimensional space. Therefore predicting the CRG level, which has a tight relationship with
the medical codes within a visit, is an easier task for One-hot+ than predicting the future codes.
Table 4 shows the performance comparison between two diﬀerent Med2Vec models. The top
model is trained with the grouped codes as explained in section 4.4, while the bottom models is
trained with the exact codes. Considering the marginal diﬀerence of the CRG prediction AUC,
it is evident that our strategy to alleviate the curse of dimensionality was beneﬁcial. Moreover,
using the grouped codes will improve the training speed as the softmax function will require less
computation.

4.7 Convergence behavior and scalability

We ﬁrst compare the convergence behavior of Med2Vec with Skip-gram (Eq. (3)), GloVe and SA.
For SA, we measure the convergence behavior of a single-layer. We train the models for 50 epochs
and plot the normalized diﬀerence of the loss value Lt−Lt−1
, where Lt denotes the loss value at
time t. To study the scalability of the models, we use both CHOA dataset and CMS dataset. We
vary the size of the training data and plot the time taken for each model to run one epoch.

Lt

14

The left ﬁgure of Fig 4 shows the convergence behavior of all models when trained on the CHOA
dataset. SA shows the most stable convergence behavior, which is natural given that we used a
single-layer SA, a much less complex model compared to GloVe, Skip-gram and Med2Vec. All
models except SA seem to reach convergence after 10 epochs of training. Note that Med2Vec shows
similar, if not better convergence behavior compared to Skip-gram even with added complexity.

The center ﬁgure of Fig 4 shows the minutes taken to train all models for one epoch using
the CHOA dataset. As we have analzyed in section ssec:complexity, Med2Vec takes essentially the
same time to train for one epoch. Both Skip-gram and Med2Vec, however, takes longer than SA and
GloVe. This is mainly due to having the softmax function for training the code representations.
GloVe, which is trained on the very sparse co-occurrence matrix naturally takes the least time to
train.

The right ﬁgure of Fig 4 shows the training time when using the CMS dataset. Note that
Med2Vec and Skip-gram takes similar time to train as SA. This is due to the smaller number of
codes per visit, which is the computationally dominating factor of both Med2Vec and Skip-gram.
GloVe takes less time as the number of unique codes are smaller in the CMS dataset. SA, on the
other hand, takes more time because the number of visits have doubled while the the number of
unique codes is about 73% of that of the CHOA dataset.

5

Interpretation

Given the importance of interpretability in healthcare, we demonstrate three stages of interpretabil-
ity for our model in collaboration with the medical experts from CHOA. First, to analyze the learned
code representations we show top ﬁve medical codes for each of six coordinates of the code em-
bedding space and explain the characteristic of each coordinate. This way, we show how we can
annotate each dimension of the code embedding space with clinical concepts. The six coordinates
are speciﬁcally chosen so that they can be used in the later stages. Second, we demonstrate the
interpretability of Med2Vec’s visit representations by analyzing the meaning of two coordinates in
the visit embedding space.

Finally, we extend the interpretability of Med2Vec to a real-world task, the CRG prediction,
and analyze the medical codes that have strong inﬂuence on the CRG level. Once we learn the
logistic regression weight wLR for the CRG prediction, we can extract knowledge from the learned
weights by analyzing the visit coordinates to which the weights are strongly connected.

Instead of analyzing the visit coordinates, however, we propose an approximate way of directly
ﬁnding out which code coordinate plays an important role in predicting the CRG class. Our goal
is to ﬁnd ut such that maximizes the output activation as follows5

u(cid:63)

t =

argmax
ut,(cid:107)ut(cid:107)2=1,ut(cid:23)0

[ReLU (Wvut + bv)](cid:62) wLR

(5)

Given the fact that ReLU (·) is an increasing function (not-strictly though), we make an approxi-
mation and ﬁnd the solution without the ReLU (·) term. The approximate solution can be found
in closed form u(cid:63)
t and
max(Wc + bc). This is to take into account the fact that each code coordinate has diﬀerent

v wLR)+. Finally, we calculate the element-wise product of u(cid:63)

t ∝ (W (cid:62)

5As we are interested in inﬂuential codes, we assume the demographic information vector is zero vector and omit

it for ease of notation.

15

Table 5: Medical codes with the strongest value in six diﬀerent coordinates of the 200 dimensional
code embedding space. We choose ten medical codes per coordinate. Shortened descriptions of
diagnosis codes are compensated by their ICD9 codes. Medications and procedures are appended
with (R) and (P) respectively.

Coordinate 112
Kidney replaced by transplant (V42.0)
Hb-SS disease without crisis (282.61)
Heart replaced by transplant (V42.1)
RBC antibody screening (P)
Complications of transplanted
bone marrow (996.85)
Sickle-cell disease (282.60)
Liver replaced by transplant (V42.7)
Hb-SS disease with crisis (282.62)
Prograf PO (R)
Complications of transplanted heart
(996.83)

Coordinate 184

Pain in joint, shoulder region (719.41)
Pain in joint, lower leg (719.46)
Pain in joint, ankle and foot (719.47)
Pain in joint, multiple sites (719.49)
Generalized convulsive epilepsy (345.10)
Pain in joint, upper arm (719.42)
Cerebral artery occlusion (434.91)
MRI, brain (780.59)
Other joint derangement (718.81)
Fecal occult blood (790.6)

Coordinate 152

Coordinate 141

X-ray, knee (P)
X-ray, thoracolumbar (P)
Accidents in public building (E849.6)
Activities involving gymnastics (E005.2)
Struck by objects/persons in sports (E917.0)
Encounter for removal of sutures (V58.32)
Struck by object in sports (E917.5)
Unspeciﬁed fracture of ankle (824.8)
Accidents occurring in place for
recreation and sport (E849.4)
Activities involving basketball (E007.6)

Cystic ﬁbrosis (277.02)
Intracranial injury (854.00)
Persistent mental disorders (294.9)
Subdural hemorrhage (432.1)
Neuroﬁbromatosis (237.71)
Other conditions of brain (348.89)
Conductive hearing loss (389.05)
Unspeciﬁed causes of encephalitis,
myelitis, encephalomyelitis (323.9)
Sensorineural hearing loss (389.15)
Intracerebral hemorrhage (431)

Coordinate 190

Down’s syndrome (758.0)
Congenital anomalies (759.89)
Tuberous sclerosis (759.5)
Anomalies of larynx, trachea,
and bronchus (748.3)
Autosomal deletions (758.39)
Conditions due to anomaly of
unspeciﬁed chromosome (758.9)
Acquired hypothyroidism (244.9)
Conditions due to chromosome
anomalies (758.89)
Anomalies of spleen (759.0)
Conditions due to autosomal
anomalies (758.5)

Coordinate 199

Infantile cerebral palsy (343.9)
Congenital quadriplegia (343.2)
Congenital diplegia (343.0)
Quadriplegia (344.00)
Congenital hemiplegia (343.1)
Baclofen 10mg tablet (R)
Wheelchair management (P)
Tracheostomy status (V44.0)
Paraplegia (344.1)
Baclofen 5mg/ml liquid (R)

maximum value. Therefore, instead of simply selecting the code coordinate with the strongest con-
nection to the CRG level, we consider each coordinate’s maximum ability to activate the positive
CRG prediction.

The resulting vector will show the maximum inﬂuence each code coordinate can have on the

CRG prediction.

5.1 Results

Table 5 shows top ten codes with the largest value in each of the six coordinates of the code
embedding space. The coordinate 112 is clearly related to sickle-cell disease and organ transplant.
The two are closely related in that sickle cell disease can be treated with bone-marrow transplant.
Prograf is a medication used for preventing organ rejection. Coordinate 152 groups medical codes
related to sports-related injuries, speciﬁcally broken bones. Coordinate 141 is related to brain
injuries and hearing loss due to the brain injuries. Neuroﬁbromatosis(NF) is also related to this
coordinate because it can cause tumors along the nerves in the brain. Cystic ﬁbrosis(CF) seems
to be a weak link in this group as it is only related to NF in the sense that both NF and CF are
genetically inherited. Coordinate 184 clearly represents medical codes related to epilepsy. Epilepsy
is often accompanied by convulsions, which can cause joint pain. Cerebral artery occlusion is related
epilepsy in the sense that epileptic seizures can be a manifestation of cerebral arterial occlusive
diseases[11]. Also, both blood in feces and the joint pain can be attributed to Henoch–Sch¨onlein

16

purpura, a disease primarily found in children. Coordinate 190 groups diseases that are caused by
congenital chromosome anomalies, especially the autosome. Acquired hypothyroidism seems to be
an outlier of this coordinate. Coordinate 199 is strongly related to congenital paralysis. Baclofen
is a medication used as a muscle relaxer. Quadraplegia patients can have weakened respiratory
function due to impaired abdominal muscles[15], in which case tracheostomy could be required.

We now analyze two visit coordinates: coordinate 50 and 41. Both visit coordinates have the
strongest connection to the logistic regression learned for the CRG prediction. For visit coordinate
50, the two strongest code coordinates connected to it are code coordinates 112 and 152. Then
naturally, from our analysis above, we can easily see that visit coordinate 50 is strongly activated
by sickle-cell disease and sports-related injuries. For visit coordinate 41, code coordinates 141 and
184 have the strongest connection. Again from the analysis above, we can directly infer that visit
coordinate 41 can be seen as a patient group consisting of brain damage & hearing loss patients
and epilepsy patients. By repeating this process, we can ﬁnd the code coordinates that are likely
to strongly inﬂuence the CRG level.

However, ﬁnding the inﬂuential code coordinates for CRG level can be achieved without ana-
lyzing the visit representation if we use Eq.(5). Applying Eq.(5) to the logistic regression weight of
the CRG prediction, we learned that code coordinates 190 and 199 are the two strongest inﬂuencer
of the CRG level. Using the analysis from above, we can naturally conclude that patients suﬀering
from congenital chromosome anomalies or congenital paralysis are most likely to be considered to
be in severe states, which is obviously true in any clinical setting.

6 Conclusion

In this paper, we proposed Med2Vec, a scalable two layer neural network for learning lower di-
mensional representations for medical concepts. Med2Vec incorporates both code co-occurence
information and visit sequence information of the EHR data which improves the accuracy of both
code and visit representations. Throughout several experiments, we successfully demonstrated the
superior performance of Med2Vec in two predictive tasks and provided clinical interpretation of the
learned representations.

7 Acknowledgments

This work was supported by the National Science Foundation, award IIS- #1418511 and CCF-
#1533768, Children’s Healthcare of Atlanta, CDC I-SMILE project, Google Faculty Award, AWS
Research Award, Microsoft Azure Research Award and UCB.

References

2009.

[1] Predicting changes in hypertension control using electronic health records from a chronic dis-

ease management program. 21.

[2] Y. Bengio. Learning deep architectures for ai. Foundations and Trends R(cid:13) in Machine Learning,

17

[3] Y. Bengio, A. Courville, and P. Vincent. Representation learning: A review and new perspec-

[4] Y. Bengio, R. Ducharme, P. Vincent, and C. Janvin. A neural probabilistic language model.

[5] Y. Bengio, P. Lamblin, D. Popovici, H. Larochelle, et al. Greedy layer-wise training of deep

tives. PAMI, 2013.

JMLR, 2003.

networks. NIPS, 2007.

[6] J. Bergstra, O. Breuleux, F. Bastien, P. Lamblin, R. Pascanu, G. Desjardins, J. Turian,
D. Warde-Farley, and Y. Bengio. Theano: a cpu and gpu math expression compiler.
In
Proceedings of SciPy, 2010.

[7] R. Chen, H. Su, Y. Zhen, M. Khalilia, D. Hirsch, M. Thompson, T. Davis, Y. Peng, S. Lin,
J. Tejedor-Sojo, E. Searles, and J. Sun. Cloud-based predictive modeling system and its
application to asthma readmission prediction. In AMIA. AMIA, 2015.

[8] E. Choi, M. T. Bahadori, and J. Sun. Doctor ai: Predicting clinical events via recurrent neural

networks. arXiv preprint arXiv:1511.05942, 2015.

[9] E. Choi, A. Schuetz, W. F. Stewart, and J. Sun. Medical concept representation learning
from electronic health records and its application on heart failure prediction. arXiv preprint
arXiv:1602.03686, 2016.

[10] Y. Choi, C. Y.-I. Chiu, and D. Sontag. Learning low-dimensional representations of medical

concepts. 2016. To be submitted to AMIA CRI.

[11] L. Cocito, E. Favale, and L. Reni. Epileptic seizures in cerebral arterial occlusive disease.

Stroke, 1982.

[12] R. Collobert and J. Weston. A uniﬁed architecture for natural language processing: Deep

neural networks with multitask learning. In ICML, 2008.

[13] L. De Vine, G. Zuccon, B. Koopman, L. Sitbon, and P. Bruza. Medical semantic similarity

with a neural language model. In KDD, 2014.

[14] D. Erhan, Y. Bengio, A. Courville, and P. Vincent. Visualizing higher-layer features of a deep

network. University of Montreal, 2009.

[15] J. Forner. Lung volumes and mechanics of breathing in tetraplegics. Spinal Cord, 18(4):258–

266, 1980.

[16] M. Ghassemi, T. Naumann, F. Doshi-Velez, N. Brimmer, R. Joshi, A. Rumshisky, and
P. Szolovits. Unfolding physiological state: Mortality modelling in intensive care units. In
KDD, 2014.

[17] G. E. Hinton, S. Osindero, and Y.-W. Teh. A fast learning algorithm for deep belief nets.

Neural computation, 2006.

[18] R. Kiros, R. Zemel, and R. R. Salakhutdinov. A multiplicative model for learning distributed

text-based attribute representations. In NIPS, 2014.

18

[19] R. Kiros, Y. Zhu, R. Salakhutdinov, R. S. Zemel, A. Torralba, R. Urtasun, and S. Fidler.

Skip-thought vectors. In NIPS, 2015.

[20] Q. Le and T. Mikolov. Distributed representations of sentences and documents. In ICML,

[21] Q. V. Le. Building high-level features using large scale unsupervised learning. In ICASSP,

2014.

2013.

[22] Y. LeCun, L. Bottou, Y. Bengio, and P. Haﬀner. Gradient-based learning applied to document

recognition. Proceedings of the IEEE, 1998.

[23] T. Mikolov, K. Chen, G. Corrado, and J. Dean. Eﬃcient estimation of word representations

in vector space. arXiv preprint arXiv:1301.3781, 2013.

[24] T. Mikolov, M. Karaﬁ´at, L. Burget, J. Cernock`y, and S. Khudanpur. Recurrent neural network

based language model. In INTERSPEECH, 2010.

[25] T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, and J. Dean. Distributed representations

of words and phrases and their compositionality. In NIPS, 2013.

[26] J. A. Minarro-Gim´enez, O. Mar´ın-Alonso, and M. Samwald. Exploring the application of deep
learning techniques on medical text corpora. Studies in health technology and informatics,
2013.

[27] A. Mnih and G. E. Hinton. A scalable hierarchical distributed language model. In NIPS, 2009.

[28] K. P. Murphy. Machine learning: a probabilistic perspective. MIT press, 2012.

[29] J. Pennington, R. Socher, and C. D. Manning. Glove: Global vectors for word representation.

EMNLP, 2014.

In ICASSP, 2014.

[30] J. Schluter and S. Bock. Improved musical onset detection with convolutional neural networks.

[31] R. Socher, A. Perelygin, J. Y. Wu, J. Chuang, C. D. Manning, A. Y. Ng, and C. Potts.
Recursive deep models for semantic compositionality over a sentiment treebank. In EMNLP,
2013.

[32] J. Sun, F. Wang, J. Hu, and S. Edabollahi. Supervised patient similarity measure of hetero-

geneous patient records. KDD Explorations, 2012.

[33] J. Turian, L. Ratinov, and Y. Bengio. Word representations: a simple and general method for

semi-supervised learning. In ACL, 2010.

[34] P. Vincent, H. Larochelle, Y. Bengio, and P.-A. Manzagol. Extracting and composing robust

features with denoising autoencoders. In ICML, 2008.

[35] P. Vincent, H. Larochelle, I. Lajoie, Y. Bengio, and P.-A. Manzagol. Stacked denoising au-
toencoders: Learning useful representations in a deep network with a local denoising criterion.
JMLR, 2010.

19

[36] Y. Wang, K. Ng, R. J. Byrd, J. Hu, S. Ebadollahi, Z. Daar, C. deFilippi, S. R. Steinhubl, and
W. F. Stewart. Early detection of heart failure with varying prediction windows by structured
and unstructured data in electronic health records. In EMBC, 2015.

[37] M. D. Zeiler. Adadelta: An adaptive learning rate method. arXiv preprint arXiv:1212.5701,

2012.

20

6
1
0
2
 
b
e
F
 
7
1
 
 
]

G
L
.
s
c
[
 
 
1
v
8
6
5
5
0
.
2
0
6
1
:
v
i
X
r
a

Multi-layer Representation Learning
for Medical Concepts

Edward Choi∗ Mohammad Taha Bahadori∗

Elizabeth Searles† Catherine Coﬀey†

Jimeng Sun∗
∗ Georgia Institute of Technology
† Children Healthcare of Atlanta

Abstract

Learning eﬃcient representations for concepts has been proven to be an important basis
for many applications such as machine translation or document classiﬁcation. Proper repre-
sentations of medical concepts such as diagnosis, medication, procedure codes and visits will
have broad applications in healthcare analytics. However, in Electronic Health Records (EHR)
the visit sequences of patients include multiple concepts (diagnosis, procedure, and medication
codes) per visit. This structure provides two types of relational information, namely sequen-
tial order of visits and co-occurrence of the codes within each visit. In this work, we propose
Med2Vec, which not only learns distributed representations for both medical codes and visits
from a large EHR dataset with over 3 million visits, but also allows us to interpret the learned
representations conﬁrmed positively by clinical experts. In the experiments, Med2Vec displays
signiﬁcant improvement in key medical applications compared to popular baselines such as Skip-
gram, GloVe and stacked autoencoder, while providing clinically meaningful interpretation.

1

Introduction

Discovering eﬃcient representations of discrete high dimensional concepts has been a key challenge
in a variety of applications recently [3]. Using various types of neural networks, high-dimensional
raw data can be transformed to continuous real-valued concept vectors that eﬃciently capture
their latent relationship from data. Such succinct representations have been shown to improve the
performance of various complex tasks across domains spanning from image processing [22, 17, 34],
language modeling [4, 24], word embedding [25, 29], music information retrieval [30], sentiment
analysis [31], and more recently multi-modal learning of images and text [18].

Eﬃcient representations for concepts is an important, if not essential, element in healthcare as
well. Healthcare concepts contain rich latent relationships that cannot be represented by simple
one-hot coding [28, Chapter 2.3.2]. For example, pneumonia and bronchitis are clearly more related
than pneumonia and obesity. In one-hot coding, such relationship between diﬀerent codes are not
represented. Despite its limitation, many healthcare applications [7, 1] still use the simple sum
over one-hot vectors to derive patient feature vectors. To overcome this limitation, it is common in
healthcare applications, to rely on carefully designed feature representations [32, 16, 36]. However,
this process often involves supervision information and ad-hoc feature engineering that requires
considerable expert medical knowledge and is not scalable in general.

Recently, studies have shown that it is possible to learn eﬃcient representations of health-
care concepts without medical expertise and still signiﬁcantly improve the performance of various

1

[9] learned distributed representations of medical codes (e.g.
healthcare applications. Choi et al.
diagnosis, medication, procedure codes) using Skip-gram [25] and applied them to heart failure
prediction. Choi et al.
[10] also learned the representations for medical concepts from a medical
claims dataset and compared the learned representations to existing medical ontologies and code
groupers. Despite these progress, learning eﬃcient representations of healthcare concepts, however,
is still an open challenge. The diﬃculty stems from several aspects:

1. Healthcare data have a unique structure where the visits are temporally ordered but the
medical codes within a visit form an unordered set. A sequence of visits possesses sequential
relationship among them which cannot be captured by simply aggregating code-level repre-
sentations. Moreover, given the demographic information for patients, the structure becomes
more complex.

2. Learned representations should be interpretable. While the interpretability of the model in
the clinical domain is considered to be an essential requirement, some of the state-of-the art
representation learning methods such as recurrent neural networks (RNN) are diﬃcult to
interpret.

3. The algorithm should be scalable enough to handle real-world healthcare datasets with mil-

lions of patients and hundred millions of visits.

To address such challenges in healthcare concept representation learning, we propose Med2Vec and
make the following contributions.

• We propose Med2Vec, a simple and robust algorithm to eﬃciently learn succinct code-, and
visit-level representations by using real-world electronic health record (EHR) datasets, with-
out depending on expert medical knowledge.

• Med2Vec learns interpretable representations and enables clinical applications to oﬀer more
than just improved performances. We conducted detailed user study with clinical experts to
validate the interpretability of the resulting representation.

• We conduct experiments to demonstrate the scalability of Med2Vec, and show that our model
can be readily applied to near 30K medical codes over two large datasets with 3 million and
5.5 million visits, respectively.

• We apply the learned representations to various real-world health problems and demonstrate

the improved performance enabled by Med2Vec compared to popular baselines.

In the following section, we discuss related works, then describe our method in section 3. In
section 4, we explain experiment design and interpretation method in detail. We present the results
and discussion in section 5. Then we conclude this paper with future work in section 6.

2 Preliminaries and Related Work

In this section, we ﬁrst describe the preliminary ideas used in learning representation for words.
Then, we review the algorithms developed for representing healthcare data.

2

Figure 1: Skip-gram model architecture: v(wt) is a vector representation for the word wt. The goal
of Skip-gram is to learn vector representations of words that are good at predicting neighboring
words.

2.1 Learning representation for words

Representation learning of words using neural network based methods have been studied since
the early 2000’s [4, 12, 27, 33]. Among these techniques, Skip-gram [25] is the basis of many
concept representation learning methods, including our own. Skip-gram is able to capture the
subtle relationships between words, thus outperforming the previous works in a word analogy
task[23].

Given a sequence of words w1, w2, . . . , wT , Skip-gram learns the word representations based
on the co-occurrence information of words inside a context window of a predeﬁned size. The key
principle of Skip-gram is that a word’s representation should be able to predict the neighboring
words. The objective of Skip-gram is to maximize the following average log probability.

T
(cid:88)

1
T

t=1

−c≤j≤c,j(cid:54)=0

(cid:88)

log p(wt+j|wt)

p(wO|wI ) =

(cid:16)

exp

(cid:17)

vwI

v(cid:48)(cid:62)
wO
(cid:16)

(cid:80)W

w=1 exp

v(cid:48)(cid:62)
w vwI

(cid:17)

where c is the size of the context window. The conditional probability is deﬁned by the softmax
function:

where vw and v(cid:48)
w are the input and output vector representations of word w. W is the number
of words in the vocabulary. Basically, Skip-gram tries to maximize the softmax probability of the
inner product of the center word’s vector and its context word’s vectors.1

Pennington et al. proposed GloVe, [29] which learns another word representations by using a
similar principle as Skip-gram. GloVe uses the global word co-occurrence matrix to learn the word
representations. Since the global co-occurrence matrix is often sparse, GloVe can be computation-
ally less demanding than Skip-gram, which is a neural network model using the sliding context
window. On the other hand, GloVe employs a weighting function that could require a considerable
amount tuning eﬀort.

1Mikolov et al.

[25] also use hierarchical softmax and negative sampling to speed up the learning process. We

focus on the original simple formulation.

3

Beyond one level representation like Skip-gram and GloVe, researchers also proposed hierarchical
learning representations for the text corpus, which has some analogy to our healthcare setting with
two level concepts namely: codes and visits. Le and Mikolov [20] proposes to learn representations
for paragraphs and words simultaneously by treating paragraphs as one of the words. However,
their algorithm assigns a ﬁxed set of vectors for both words and paragraphs in the training data.
Moreover, their approach does not capture the sequential order among paragraphs. Skip-thought
[19] proposes an encoder-decoder structure: an encoder (Gated Recurrent Units (GRU) in their
case) learns a representation for a sentence that is able to regenerate its surrounding sentences
(via GRU again). Skip-thought cannot be applied directly to EHR data because unlike words in
sentences, the codes in a visit are unordered. Also, the interpretation of Skip-thought model is
diﬃcult, as they rely on complex RNNs.

2.2 Representation learning in healthcare

Recently researchers start to explore the possibility of eﬃcient representation learning in the medical
domain.

Medical text analysis Minarro et al.
[26] learns the representations of medical terms by ap-
plying Skip-gram to various medical text collected from PubMed, Merck Manuals, Medscape and
Wikipedia. De Vine et al. [13] learns the representations of UMLS concepts from free-text patient
records and medical journal abstracts. They ﬁrst replaced the words in documents to UMLS con-
cepts, then applied Skip-gram to learn the distributed representations of the concepts. However,
none of them studied longitudinal EHR data with a large number of medical codes.

[9], and Choi et al.

Structured visit records analysis Choi et al.
[10] both learned the dis-
tributed representation of medical codes (e.g. diagnosis, medication, procedure codes) from struc-
tured longitudinal visit records of patients using Skip-gram. In addition, the authors demonstrated
that simply aggregating the learned representation of medical codes to create a visit representation
leads to improved predictive performance. However, simply aggregating the code representations
is not the optimal method to generate a visit representation as it completely ignores the tempo-
ral relations across adjacent visits. We believe that taking advantage of the two-level information
(the co-occurrence of codes within a visit and the sequential nature of visits) and the demographic
information of patients will give us better representation for both medical codes and patient visits.
[8] trained a recurrent neural networks (RNN) model to analyze the longitudinal
patient records in a temporal order, and predict the diagnosis and medication codes the patient
will receive in the future. In [8], the hidden layer of the RNN can be seen as the representation of
the patient status over time. However, despite its outstanding performance, RNNs are diﬃcult to
interpret.

Choi et al.

3 Method

In this section, we describe the proposed algorithm Med2Vec. We start by mathematically for-
mulating the EHR data structure and our goal. Then we describe our approach in a top-down
fashion. We also explain how to interpret the learned representations. We conclude this section
with complexity analysis.

4

Figure 2: Structure of Med2Vec: A visit comprised of several medical codes is converted to a binary
vector xt ∈ {0, 1}|C|. The binary vector is then converted to an intermediate visit representation
ut. ut is concatenated with a vector of demographic information dt, and converted to the ﬁnal visit
representation vt, which is trained to predict its neighboring visits . . . , xt−2, xt−1, xt+1, xt+2, . . .

EHR structure and our notation We denote the set of all medical codes c1, c2, . . . , c|C| in our
EHR dataset by C with size |C|. EHR data for each patient is in the form of a sequence of visits
V1, . . . , VT where each visit contains a subset of medical codes Vt ⊆ C. Without loss of generality, all
algorithms will be presented for a single patient to avoid cluttered notations. The goal of Med2Vec
is to learn two types of representations:

Code representations We aim to learn an embedding function fC : C (cid:55)→ Rm

+ that maps every
code in the set of all medical codes C to non-negative real-valued vectors of dimension m. The
non-negativity constraint is introduced to improve interpretability, as discussed in details in
Section 3.5.

Visit representations Our second task is to learn another embedding function fV : V (cid:55)→ Rn that
maps every visit (a set of medical codes) to a real-valued vector of dimension n. The set V is
the power set of the set of codes C.

3.1 Med2Vec architecture

Figure 2 depicts the architecture of Med2Vec. Given a visit Vt, we use a multi-layer perceptron
(MLP) to to generate the corresponding visit representation vt. First, visit Vt is represented by a
binary vector xt ∈ {0, 1}|C| where the i-th entry is 1 only if ci ∈ Vt. Then xt is converted to an
intermediate visit representation ut ∈ Rm as follows,

ut = ReLU (Wcxt + bc)

(1)

using the code weight matrix Wc ∈ Rm×|C| and the bias vector bc ∈ Rm. The rectiﬁed linear unit
is deﬁnes as ReLU (v) = max(v, 0). Note that max() applies element-wise to vectors. We use

5

the rectiﬁed linear unit (ReLU) as the activation function to enable interpretability, which will be
discussed in section 3.3.

We concatenate the demographic information dt ∈ Rd, where d is the size of the demographic in-
formation vector, to the intermediate visit representation ut and create the ﬁnal visit representation
vt ∈ Rn as follows,

vt = ReLU (Wv[ut, dt] + bv)

using the visit weight matrix Wv ∈ Rn×(m+d) and the bias vector bv ∈ Rn, where n is the predeﬁned
size of the visit representation. We use ReLU once again as the activation function. We discuss
our eﬃcient training procedure of the parameters Wc, bc, Wv and bv in the next subsection.

3.2 Learning from the visit-level information

As mentioned in the introduction, the sequential information of visits can be exploited for learning
eﬃcient representations of visits and potentially codes. We train the MLP using a very straightfor-
ward intuition as follows: a visit describes a state in a continuous process that is a patient’s clinical
experience. Therefore, given a visit representation, we should be able to predict what has happened
in the past, and what will happen in the future. Speciﬁcally, given a visit representation vt, we
train a softmax classiﬁer that predicts the medical codes of the visits within a context window. We
minimize the cross entropy error as follows,

−xt+i

(cid:62) log ˆyt − (1 − xt+i)(cid:62) log(1 − ˆyt),

(2)

T
(cid:88)

(cid:88)

min
Ws,bs

1
T

t=1

−w≤i≤w,i(cid:54)=0

where

ˆyt =

exp(Wsvt + bs)
j=1 exp(Ws[j, :]vt + bs[j])

(cid:80)|C|

where Ws ∈ R|C|×n and bs ∈ R|C| are the weight matrix and bias vector for the softmax classiﬁer,
w the predeﬁned context window size, exp the element-wise exponential function, and 1 denotes
an all one vector. We have used MATLAB’s notation for selecting a row in Ws and a coordinate
of bs.

3.3 Learning from the code-level information

As we described in the introduction, healthcare datasets contain two-level information: visit-level
sequence information and code-level co-occurrence information. Since the loss function in Eq. (2)
can eﬃciently capture the sequence level information, now we need to ﬁnd a way to use the second
source of information, i.e., the intra-visit co-occurrence of the codes.

A natural choice to capture the code co-occurrence information is to use Skip-gram. The main
idea would be that the representations for the codes that occur in the same visit should predict
each other. To embed Skip-gram in Med2Vec, we can train Wc ∈ Rm×|C| (which also produces
intermediate visit level representations) so that the i-th column of Wc will be the representation
for the i-th medical code among total |C| codes. Note that given the unordered nature of the codes
inside a visit, unlike the original Skip-gram, we do not distinguish between the “input” medical
code and the “output” medical code.
In text, it is sensible to assume that a word can serve a
diﬀerent role as a center word and a context word, whereas in EHR datasets, we cannot classify
codes as center or context codes. It is also desirable to learn the representations of diﬀerent types of

6

codes (e.g. diagnosis, medication, procedure code) in the same latent space so that we can capture
the hidden relationships between them.

However, precise interpretation of Skip-gram codes will be diﬃcult as Wc will have positive and
negative values. For intuitive interpretation, we should learn code representations with non-negative
values. Note that in Eq.(1), if the binary vector xt is a one-hot vector, then the intermediate visit
representation ut becomes a code representation. Therefore, using the Skip-gram algorithm, we
train the non-negative weight ReLU (Wc) instead of Wc. This will not only use the intra-visit
co-occurrence information, but also guarantee non-negative code representations. Moreover, ReLU
produces sparse code representations, which further facilitates easier interpretation of the codes.

The code representations to be learned is denoted as a matrix W (cid:48)

c = ReLU (Wc) ∈ Rm×|C|. From
a sequence of visits V1, V2, . . . , VT , the code-level representations can be learned by maximizing the
following log-likelihood,

min
W (cid:48)
c

1
T

T
(cid:88)

t=1

(cid:88)

(cid:88)

log p(cj|ci),

exp

i:ci∈Vt
(cid:16)

j:cj ∈Vt,j(cid:54)=i
W (cid:48)
c[:, j](cid:62)W (cid:48)
(cid:16)

(cid:17)
c[:, i]

(cid:80)|C|

k=1 exp

W (cid:48)

c[:, k](cid:62)W (cid:48)

c[:, i]

(cid:17) .

where p(cj|ci) =

(3)

(4)

3.4 Uniﬁed training

The single uniﬁed framework can be obtained by adding the two objective functions (3) and (2) as
follows,

argmin
W ,b

1
T

T
(cid:88)

(cid:110)

−

t=1

(cid:88)

+

−w≤k≤w,k(cid:54)=0

(cid:88)

(cid:88)

log p(cj|ci)

j:cj ∈Vt,j(cid:54)=i

i:ci∈Vt
(cid:111)
t+k log ˆyt − (1 − xt+k)(cid:62) log(1 − ˆyt)

−x(cid:62)

By combining the two objective functions we learn both code representations and visit repre-
sentations from the same source of patient visit records, exploiting both intra-visit co-occurrence
information as well as inter-visit sequential information at the same time.

3.5 Interpretation of learned representations

While the original Skip-gram learns code representations that have interesting properties such
as additivity, in healthcare we need stronger interpretability. We need to be able to associate
clinical meaning to each dimension of both code and visit representations. Interpreting the learned
representations is based on analyzing each coordinate in both code and visit embedding spaces.

Interpreting code representations
If information is properly embedded into a lower dimen-
sional non-negative space, each coordinate of the lower dimension can be readily interpreted. Non-
negative matrix factorization (NMF) is a good example. Since we trained ReLU (Wc) ∈ Rm×|C|, a
non-negative matrix, to represent the medical codes, we can employ a simple method to interpret

7

the meaning of each coordinate of the m-dimensional code embedding space. We can ﬁnd the top
k codes that have the largest values for the i-th coordinate of the code embedding space as follows,

argsort(Wc[i, :])[1 : k]

where argsort returns the indices of a vector that index its values in a descending order. By studying
the returned medical codes, we can view each coordinate as a disease group. Detailed examples are
given in section 5.1

Interpreting visit representations To interpret the learned visit vectors, we can use the
same principle we used for interpreting the code representation. For the i-th coordinate of the
n-dimensional visit embedding space, we can ﬁnd the top k coordinates of the code embedding
space that have the strongest values as follows,

argsort(Wv[i, :])[1 : k]

where we use the same argsort as before. Once we obtain a set of code coordinates, we can use
the knowledge learned from interpreting the code representations to understand how each visit
coordinate is associated with a group of diseases. This simple interpretation is possible because the
intermediate visit representation ut is a non-negative vector, due to the ReLU activation function.
In the experiments, we also tried to ﬁnd the input vector xt that most activates the target visit
coordinate [14, 21]. However, the results were very sensitive to the initial value of xt, and even
averaging over multiple samples were producing unreliable results.

3.6 Complexity analysis

We ﬁrst analyze the computational complexity of the code-level objective function Eq. (3). Without
loss of generality, we assume the visit records of all patients are concatenated into a single sequence
of visits. Then the complexity for Eq. (3) is as follows,

O(T M 2|C|m)

where T is the number of visits, M 2 is the average of squared number of medical codes within a
visit, |C| the number of unique medical codes, m the size of the code representation. The M 2 factor
comes from iterating over all possible pairs of codes within a visit. The complexity of the visit-level
objective function Eq.(2) is as follows,

O(T w(|C|(m + n) + mn))

where w is the size of the context window, n the size of the visit representation. The added terms
come from generating a visit representation via MLP. Since size of code representation m and size
of visit representation n generally have the same order of magnitude, we can replace n with m.
Furthermore, m is generally smaller than |C| by at least two orders of magnitude. Therefore the
overall complexity of Med2Vec can be simpliﬁed as follows.

Here we notice that M 2 is generally larger than w. In our work, the average number of codes M
per visit for two datasets are 7.88 and 3.19 according to Tables 1, respectively, whereas we select

O(T |C|m(M 2 + w))

8

Table 1: Basic statistics of CHOA and CMS dataset.
CMS
831,210
5,464,950
6.57
21,033
14,111
N/A
6,922
3.19
44

Dataset
# of patients
# of visits
Avg. # of visits per patient
# of unique medical codes
- # of unique diagnosis codes
- # of unique medication codes
- # of unique procedure codes
Avg. # of codes per visit
Max # of codes per visit
(95%, 99%) percentile
# of codes per visit

CHOA
550,339
3,359,240
6.1
28,840
10,414
12,892
5,534
7.88
440

(22, 53)

(9, 13)

the window size w to be at most 5 in our experiments. Therefore the complexity of Med2Vec is
dominated by the code representation learning process, for which we use the Skip-gram algorithm.
This means that exploiting visit-level information to learn eﬃcient representations for both visits
and codes does not incur much additional cost.

4 Experiments

In this section, we evaluate the performance of Med2Vec in both public and proprietary datasets.
First we describe the datasets. Then we describe evaluation strategies for code and visit representa-
tions, along with implementation details. Then we present the experiment results of code and visit
representations with discussion. We conclude with convergence and scalability study. We make the
source code of Med2Vec publicly available at https://github.com/mp2893/med2vec.

4.1 Dataset description

We evaluate performance of Med2Vec on a dataset provided by Children’s Healthcare of Atlanta
(CHOA)2. We extract visit records from the dataset, where each visit contains several medical
codes (e.g. diagnosis, medication, procedure codes). The diagnosis codes follow ICD-9 codes, the
medication codes are denoted by National Drug Codes (NDC), and the procedure codes follow
Category I of Current Procedural Terminology (CPT). We exclude patients who had less that two
visits to showcase Med2Vec’s ability to use sequential information of visits. The basic statistics of
the dataset are summarized in Table 1. The data are fully de-identiﬁed and do not include any
personal health information (PHI).

We divide the dataset into two groups in a 4:1 ratio. The former is used to train Med2Vec. The
latter is held oﬀ for evaluating the visit-level representations, where we train models to predict
visit-related labels. The details of the evaluation will be provided in the following subsections.

We also use CMS dataset, a publicly available3 synthetic EHR dataset. The basic information
of CMS is also given in Table 1. Compared to CHOA dataset, the CMS dataset has more patients

2http://www.choa.org/
3https://www.cms.gov/Medicare/Quality-Initiatives-Patient-Assessment-Instruments/OASIS/DataSet.

html

9

but fewer unique medical codes. The average number of codes per visit is also smaller than that
of CHOA dataset. Since CMS dataset is synthetic, we use it only for testing the scalability of
Med2Vec and baseline models in section 4.7.

4.2 Evaluation Strategy of code representations

Qualitative evaluation by medical experts For a comprehensive qualitative evaluation, we
perform a relatedness test by selecting 100 most frequent diagnosis codes and their 5 closest diag-
noses, medications and procedures in terms of cosine similarity. This allow us to know if the learned
representations eﬀectively capture the latent relationships among them. Two medical experts from
CHOA check each item and assign related, possible and unrelated labels.

Quantitative evaluation with baselines We use medical code groupers to quantitatively eval-
uate the code representations. Code groupers are used to collapse individual medical codes into
clinically meaningful categories. For example, Clinical Classiﬁcations Software (CCS) groups ICD9
diagnosis codes into 283 categories such as tuberculosis, bacterial infection, and viral infection.

We apply K-means clustering to the learned code representations and calculate the normalized
mutual information (NMI) based on the group label of each code. We use the CCS as the ground
truth for evaluating the code representation for diagnosis. For medication code evaluation, we
use American Hospital Formulary Service (AHFS) pharmacologic-therapeutic classiﬁcation, which
groups NDC codes into 165 categories. For procedure code evaluation, we use the second-level
grouping of CPT category I, which groups CPT codes into 115 categories.Thus, we set the number
of clusters k to 283, 165, 115 respectively for the diagnosis, medication, procedure code evaluation,
which matches the numbers of groups from individual groupers.

For baselines, we use popular methods that eﬃciently exploit co-occurrence information. Skip-
gram (which is used in learning representations of medical concepts by [10, 9]) is trained using Eq.
(3). GloVe will be trained on the co-occurrence matrix of medical codes, for which we counted
the codes co-occurring within a visit. Additionally, we also report well-known baselines such as
singular value decomposition on the co-occurrence matrix.

4.3 Evaluation strategy of visit representation

We evaluate the quality of the visit representations by performing two visit-level prediction tasks:
predicting the future visit and predicting the present status. The former will evaluate a visit
representation’s potential eﬀectiveness in predictive healthcare while the latter will evaluate the
how well it captures the information in the given visit. The details of the two tasks are given
below.
Predicting future medical codes: We predict the medical codes that will occur in the next visit
using the visit representations. Speciﬁcally, given two consecutive visits Vi and Vj, the medical
codes c ∈ Vj will be the target y, the medical codes c ∈ Vi will be the input x, and we use softmax
to predict y given x. The predictive performance will be measured by Top-k Recall, which mimics
the diﬀerential diagnosis conducted by doctors. We set k = 30 to cover even the complex cases of
CHOA dataset, as over 167,000 visits are assigned with more than 20 medical codes according to
Table 1. We predict the grouped medical codes, obtained by the medical groupers used in Section
4.2.

10

Predicting Clinical Risk Groups (CRG) level: A patient’s CRG level indicates his severity
level. It ranges from 1 to 9, including 5a and 5b. The CRG levels can be divided into two groups:
non-severe (CRG 1-5a) and severe (CRG 5b-9). Given a visit, we use logistic regression to predict
the binary CRG class associated with the visit. We use Area Under The Curve (AUC) to measure
the classiﬁcation accuracy, as it is more robust to class imbalance in data.

Baselines For baselines, we use the following methods.
Binary vector model (One-hot+): In order to compare with the raw input data, we use the
binary vector xt as the visit representation.
Stacked autoencoder (SA): Stacked autoencoder is one of the most popular unsupervised rep-
resentation learning algorithms [35]. Using the binary vector xt concatenated with patient demo-
graphic information as the input, we train a 3-layer stacked autoencoder (SA) [5] to minimize the
reconstruction error. The trained SA will then be used to generate visit representations.
Sum of Skip-gram vectors (Skip-gram+): We ﬁrst learn the code-level representations with
Skip-gram only (Eq. (3)). Then for the visit-level representation, we simply add the representations
of the codes within the visit. This approach was proven very eﬀective for heart failure prediction
in [9]. We append patient demographic information at the end.
Sum of GloVe vectors (GloVe+): We perform the same process as Skip-gram+, but use GloVe
vectors instead of Skip-gram vectors. We use the recommended hyperparameter setting from [29].

Evaluation details We use the held-oﬀ dataset, which was not used to learn the code and visit
representations, to perform the two prediction tasks. The held-oﬀ dataset contains 672,110 visits
assigned with CRG levels. In order to train the predictors, we divide the held-oﬀ data to training
and testing folds with ration 4:1. Both softmax and logistic regression are trained for 10 epochs
on the training fold. We perform 5-fold cross validation for each task to tune the regularization
parameter. For all baseline models and Med2Vec, we use age, sex and ethnicity as the demographic
information in the input data.

4.4 Implementation and training details

For learning code and visit representations using Med2Vec and all baselines, we use Adadelta [37] in
a mini-batch fashion. For Skip-gram, SA and Med2Vec, we use 1,000 visits4 per batch. For GloVe,
we use 1,000 non-zero entries of the co-occurrence matrix per batch. The optimization terminates
after a ﬁxed number of epochs. In section 4.6, we show the relationship between training epochs
and the performance. We also show the convergence behavior of Med2Vec and the baselines in
section 4.7.

Med2Vec, Skip-gram, GloVe and SA are implemented with Theano 0.7.0 [6]. K-means clustering
for the code-level evaluation and SVD are performed using Scikit-learn 0.14.1. Softmax and logistic
regression models for the visit-level evaluation are implemented with Keras 0.3.1, and trained for 10
epochs. All tasks are executed on a machine equipped with Intel Xeon E5-2697v3, 256GB memory
and two Nvidia K80 Tesla cards.

We train multiple models using various hyperparameter settings. For all models we vary the
size of the code representations m (or the size of the hidden layer for SA), and the number of

4for eﬃcient computation, we preprocessed the EHR dataset so that the visit records of all patients are concate-

nated into a single sequence of visits.

11

Table 2: Average score of the medical codes from the relatedness test. 2 was assigned for related,
1 for possible and 0 for unrelated

Average Diagnosis Medication Procedure

1.34

1.59

0.95

1.47

Table 3: Clustering NMI of the diagnosis, medication and procedure code representations of various
models. All models learned 200 dimensional code vectors. All models except SVD were trained for
10 epochs.

Model
SVD (σV (cid:62))
Skip-gram
GloVe
Med2Vec

Diagnosis Medication Procedure
0.0843
0.1216
0.2163
0.1089

0.1781
0.2432
0.3499
0.21

0.1824
0.2251
0.4205
0.2328

training epochs. Additionally for Med2Vec, we vary the size of the visit representations n, and the
size of the visit context window w.

To alleviate the curse of dimensionality when training the softmax classiﬁer (Eq.(2)) of Med2Vec,
we always use the medical code groupers of section 4.2 so that the softmax classiﬁer is trained to
predict the grouped medical codes instead of the exact medical codes. To conﬁrm the impact of
this strategy, we train an additional Med2Vec without using the medical code groupers.

4.5 Results of the code-level evaluation

Table 2 shows the average score of the medical codes from the qualitative code evaluation. On
average, Med2Vec successfully captures the relationship between medical codes. However, Med2Vec
seems to have a hard time capturing proper representation of medications. This is due to the
precise nature the medication prescription. For example, Med2Vec calculated that Oﬂoxacin, an
antibiotic sometimes used to treat middle-ear infection, was related to sensorineural hearling loss
(SNHL), an inner-ear problem. On the surface level, this is a wrong relationship. But Med2Vec can
be seen as capturing the deeper relationship between medical concepts that is not always clear on
the surface level.

Table 3 shows the clustering NMI of diagnosis, medication and procedure codes, measured for
various models. Med2Vec shows more or less similar conformity to the existing groupers as Skip-
gram. SVD shows the weakest conformity among all models. GloVe exhibits signiﬁcantly stronger
conformity than any other models. Exploiting the global co-occurrence matrix seems to help learn
code representations where similar codes are closer to each other in terms of Euclidean distance.

However, the degree of conformity of the code representations to the groupers does not neces-
sarily indicate how well the code representations capture the hidden relationships. For example,
CCS categorizes ICD9 224.4 Benign neoplasm of cornea as CCS 47 Other and unspeciﬁed benign
neoplasm, and ICD9 370.00 Unspeciﬁed corneal ulcer as CCS 91 Other eye disorders. But the two
diagnosis codes are both eye related problems, and they could be considered related in that sense.
Therefore we recommend the readers use the evaluation results for comparing the performance
between Med2Vec and other baselines, rather than for measuring the absolute performance.

In the following visit-level evaluation, we show that the code representations’ strong conformity

12

Figure 3: The top row and the bottom row respectively show the Recall@30 for predicting the future
medical codes and the AUC for predicting the CRG class when changing diﬀerent hyperparameters.
The basic conﬁguration for Med2Vec is m, n = 200, w = 1, and the training epoch set to 10. The
basic conﬁguration for all baseline models is 200 for code representation size (or hidden layer size)
In each column, we change one hyperparameter while ﬁxing
and training epoch also set to 10.
others to the basic conﬁguration.

Figure 4: The ﬁrst ﬁgure shows the convergence behavior of all models on the CHOA dataset. The
second and third ﬁgures show the relationship between the training time and the dataset size for
all models respectively using the CHOA dataset and the CMS dataset.

13

Table 4: Performance comparison of two Med2Vec models. The top row was trained with the
grouped code as mentioned in section 4.4. The bottom row was trained without using the groupers.
Both models were trained for 10 epochs with m, n = 200, w = 1.

Model
Grouped codes
Exact codes

Future code prediction CRG prediction

0.7605
0.7574

0.9150
0.9155

to the existing groupers alone does not directly transfer to good visit representations.

4.6 Results of the visit-level evaluation

The ﬁrst row of Figure 3 shows the Recall@30 for predicting the future medical codes. First, in all of
the experiments, Med2Vec achieves the highest performance, despite the fact that it is constrained
to be positive and interpretable. The second observation is that Med2Vec’s performance is robust to
choice of the hyperparameters in a wide range of values. Comparing to a more volatile performance
of Skip-gram, we can see that including the visit information in training not only improves the
performance, but also stabilizes it too.

Another fascinating aspect of the results is the overﬁtting pattern in diﬀerent algorithms. In-
creasing the code representation size degrades the performance of all of the algorithms, as it leads
to overﬁtting. Similar behavior can be seen as we train GloVe+ for more epochs which suggests
early stopping technique should be used in representation learning [2]. For Med2Vec, increasing the
visit representation size n seems to have the strongest inﬂuence to its predictive performance.

The bottom row of ﬁgures in Figure 3 shows the AUC for predicting the CRG class of the given
visit. The overﬁtting patterns are not as prominent as the previous task. This is due to the diﬀerent
nature of the two prediction tasks. While the goal of CRG prediction is to predict a value related
to the current visit, predicting the future codes is taking a step away from the current visit. This
diﬀerent nature of the two tasks also contributes to the better performance of One-hot+ on the
CRG prediction. One-hot+ contains the entire information of the given visit, although in a very
high-dimensional space. Therefore predicting the CRG level, which has a tight relationship with
the medical codes within a visit, is an easier task for One-hot+ than predicting the future codes.
Table 4 shows the performance comparison between two diﬀerent Med2Vec models. The top
model is trained with the grouped codes as explained in section 4.4, while the bottom models is
trained with the exact codes. Considering the marginal diﬀerence of the CRG prediction AUC,
it is evident that our strategy to alleviate the curse of dimensionality was beneﬁcial. Moreover,
using the grouped codes will improve the training speed as the softmax function will require less
computation.

4.7 Convergence behavior and scalability

We ﬁrst compare the convergence behavior of Med2Vec with Skip-gram (Eq. (3)), GloVe and SA.
For SA, we measure the convergence behavior of a single-layer. We train the models for 50 epochs
and plot the normalized diﬀerence of the loss value Lt−Lt−1
, where Lt denotes the loss value at
time t. To study the scalability of the models, we use both CHOA dataset and CMS dataset. We
vary the size of the training data and plot the time taken for each model to run one epoch.

Lt

14

The left ﬁgure of Fig 4 shows the convergence behavior of all models when trained on the CHOA
dataset. SA shows the most stable convergence behavior, which is natural given that we used a
single-layer SA, a much less complex model compared to GloVe, Skip-gram and Med2Vec. All
models except SA seem to reach convergence after 10 epochs of training. Note that Med2Vec shows
similar, if not better convergence behavior compared to Skip-gram even with added complexity.

The center ﬁgure of Fig 4 shows the minutes taken to train all models for one epoch using
the CHOA dataset. As we have analzyed in section ssec:complexity, Med2Vec takes essentially the
same time to train for one epoch. Both Skip-gram and Med2Vec, however, takes longer than SA and
GloVe. This is mainly due to having the softmax function for training the code representations.
GloVe, which is trained on the very sparse co-occurrence matrix naturally takes the least time to
train.

The right ﬁgure of Fig 4 shows the training time when using the CMS dataset. Note that
Med2Vec and Skip-gram takes similar time to train as SA. This is due to the smaller number of
codes per visit, which is the computationally dominating factor of both Med2Vec and Skip-gram.
GloVe takes less time as the number of unique codes are smaller in the CMS dataset. SA, on the
other hand, takes more time because the number of visits have doubled while the the number of
unique codes is about 73% of that of the CHOA dataset.

5

Interpretation

Given the importance of interpretability in healthcare, we demonstrate three stages of interpretabil-
ity for our model in collaboration with the medical experts from CHOA. First, to analyze the learned
code representations we show top ﬁve medical codes for each of six coordinates of the code em-
bedding space and explain the characteristic of each coordinate. This way, we show how we can
annotate each dimension of the code embedding space with clinical concepts. The six coordinates
are speciﬁcally chosen so that they can be used in the later stages. Second, we demonstrate the
interpretability of Med2Vec’s visit representations by analyzing the meaning of two coordinates in
the visit embedding space.

Finally, we extend the interpretability of Med2Vec to a real-world task, the CRG prediction,
and analyze the medical codes that have strong inﬂuence on the CRG level. Once we learn the
logistic regression weight wLR for the CRG prediction, we can extract knowledge from the learned
weights by analyzing the visit coordinates to which the weights are strongly connected.

Instead of analyzing the visit coordinates, however, we propose an approximate way of directly
ﬁnding out which code coordinate plays an important role in predicting the CRG class. Our goal
is to ﬁnd ut such that maximizes the output activation as follows5

u(cid:63)

t =

argmax
ut,(cid:107)ut(cid:107)2=1,ut(cid:23)0

[ReLU (Wvut + bv)](cid:62) wLR

(5)

Given the fact that ReLU (·) is an increasing function (not-strictly though), we make an approxi-
mation and ﬁnd the solution without the ReLU (·) term. The approximate solution can be found
in closed form u(cid:63)
t and
max(Wc + bc). This is to take into account the fact that each code coordinate has diﬀerent

v wLR)+. Finally, we calculate the element-wise product of u(cid:63)

t ∝ (W (cid:62)

5As we are interested in inﬂuential codes, we assume the demographic information vector is zero vector and omit

it for ease of notation.

15

Table 5: Medical codes with the strongest value in six diﬀerent coordinates of the 200 dimensional
code embedding space. We choose ten medical codes per coordinate. Shortened descriptions of
diagnosis codes are compensated by their ICD9 codes. Medications and procedures are appended
with (R) and (P) respectively.

Coordinate 112
Kidney replaced by transplant (V42.0)
Hb-SS disease without crisis (282.61)
Heart replaced by transplant (V42.1)
RBC antibody screening (P)
Complications of transplanted
bone marrow (996.85)
Sickle-cell disease (282.60)
Liver replaced by transplant (V42.7)
Hb-SS disease with crisis (282.62)
Prograf PO (R)
Complications of transplanted heart
(996.83)

Coordinate 184

Pain in joint, shoulder region (719.41)
Pain in joint, lower leg (719.46)
Pain in joint, ankle and foot (719.47)
Pain in joint, multiple sites (719.49)
Generalized convulsive epilepsy (345.10)
Pain in joint, upper arm (719.42)
Cerebral artery occlusion (434.91)
MRI, brain (780.59)
Other joint derangement (718.81)
Fecal occult blood (790.6)

Coordinate 152

Coordinate 141

X-ray, knee (P)
X-ray, thoracolumbar (P)
Accidents in public building (E849.6)
Activities involving gymnastics (E005.2)
Struck by objects/persons in sports (E917.0)
Encounter for removal of sutures (V58.32)
Struck by object in sports (E917.5)
Unspeciﬁed fracture of ankle (824.8)
Accidents occurring in place for
recreation and sport (E849.4)
Activities involving basketball (E007.6)

Cystic ﬁbrosis (277.02)
Intracranial injury (854.00)
Persistent mental disorders (294.9)
Subdural hemorrhage (432.1)
Neuroﬁbromatosis (237.71)
Other conditions of brain (348.89)
Conductive hearing loss (389.05)
Unspeciﬁed causes of encephalitis,
myelitis, encephalomyelitis (323.9)
Sensorineural hearing loss (389.15)
Intracerebral hemorrhage (431)

Coordinate 190

Down’s syndrome (758.0)
Congenital anomalies (759.89)
Tuberous sclerosis (759.5)
Anomalies of larynx, trachea,
and bronchus (748.3)
Autosomal deletions (758.39)
Conditions due to anomaly of
unspeciﬁed chromosome (758.9)
Acquired hypothyroidism (244.9)
Conditions due to chromosome
anomalies (758.89)
Anomalies of spleen (759.0)
Conditions due to autosomal
anomalies (758.5)

Coordinate 199

Infantile cerebral palsy (343.9)
Congenital quadriplegia (343.2)
Congenital diplegia (343.0)
Quadriplegia (344.00)
Congenital hemiplegia (343.1)
Baclofen 10mg tablet (R)
Wheelchair management (P)
Tracheostomy status (V44.0)
Paraplegia (344.1)
Baclofen 5mg/ml liquid (R)

maximum value. Therefore, instead of simply selecting the code coordinate with the strongest con-
nection to the CRG level, we consider each coordinate’s maximum ability to activate the positive
CRG prediction.

The resulting vector will show the maximum inﬂuence each code coordinate can have on the

CRG prediction.

5.1 Results

Table 5 shows top ten codes with the largest value in each of the six coordinates of the code
embedding space. The coordinate 112 is clearly related to sickle-cell disease and organ transplant.
The two are closely related in that sickle cell disease can be treated with bone-marrow transplant.
Prograf is a medication used for preventing organ rejection. Coordinate 152 groups medical codes
related to sports-related injuries, speciﬁcally broken bones. Coordinate 141 is related to brain
injuries and hearing loss due to the brain injuries. Neuroﬁbromatosis(NF) is also related to this
coordinate because it can cause tumors along the nerves in the brain. Cystic ﬁbrosis(CF) seems
to be a weak link in this group as it is only related to NF in the sense that both NF and CF are
genetically inherited. Coordinate 184 clearly represents medical codes related to epilepsy. Epilepsy
is often accompanied by convulsions, which can cause joint pain. Cerebral artery occlusion is related
epilepsy in the sense that epileptic seizures can be a manifestation of cerebral arterial occlusive
diseases[11]. Also, both blood in feces and the joint pain can be attributed to Henoch–Sch¨onlein

16

purpura, a disease primarily found in children. Coordinate 190 groups diseases that are caused by
congenital chromosome anomalies, especially the autosome. Acquired hypothyroidism seems to be
an outlier of this coordinate. Coordinate 199 is strongly related to congenital paralysis. Baclofen
is a medication used as a muscle relaxer. Quadraplegia patients can have weakened respiratory
function due to impaired abdominal muscles[15], in which case tracheostomy could be required.

We now analyze two visit coordinates: coordinate 50 and 41. Both visit coordinates have the
strongest connection to the logistic regression learned for the CRG prediction. For visit coordinate
50, the two strongest code coordinates connected to it are code coordinates 112 and 152. Then
naturally, from our analysis above, we can easily see that visit coordinate 50 is strongly activated
by sickle-cell disease and sports-related injuries. For visit coordinate 41, code coordinates 141 and
184 have the strongest connection. Again from the analysis above, we can directly infer that visit
coordinate 41 can be seen as a patient group consisting of brain damage & hearing loss patients
and epilepsy patients. By repeating this process, we can ﬁnd the code coordinates that are likely
to strongly inﬂuence the CRG level.

However, ﬁnding the inﬂuential code coordinates for CRG level can be achieved without ana-
lyzing the visit representation if we use Eq.(5). Applying Eq.(5) to the logistic regression weight of
the CRG prediction, we learned that code coordinates 190 and 199 are the two strongest inﬂuencer
of the CRG level. Using the analysis from above, we can naturally conclude that patients suﬀering
from congenital chromosome anomalies or congenital paralysis are most likely to be considered to
be in severe states, which is obviously true in any clinical setting.

6 Conclusion

In this paper, we proposed Med2Vec, a scalable two layer neural network for learning lower di-
mensional representations for medical concepts. Med2Vec incorporates both code co-occurence
information and visit sequence information of the EHR data which improves the accuracy of both
code and visit representations. Throughout several experiments, we successfully demonstrated the
superior performance of Med2Vec in two predictive tasks and provided clinical interpretation of the
learned representations.

7 Acknowledgments

This work was supported by the National Science Foundation, award IIS- #1418511 and CCF-
#1533768, Children’s Healthcare of Atlanta, CDC I-SMILE project, Google Faculty Award, AWS
Research Award, Microsoft Azure Research Award and UCB.

References

2009.

[1] Predicting changes in hypertension control using electronic health records from a chronic dis-

ease management program. 21.

[2] Y. Bengio. Learning deep architectures for ai. Foundations and Trends R(cid:13) in Machine Learning,

17

[3] Y. Bengio, A. Courville, and P. Vincent. Representation learning: A review and new perspec-

[4] Y. Bengio, R. Ducharme, P. Vincent, and C. Janvin. A neural probabilistic language model.

[5] Y. Bengio, P. Lamblin, D. Popovici, H. Larochelle, et al. Greedy layer-wise training of deep

tives. PAMI, 2013.

JMLR, 2003.

networks. NIPS, 2007.

[6] J. Bergstra, O. Breuleux, F. Bastien, P. Lamblin, R. Pascanu, G. Desjardins, J. Turian,
D. Warde-Farley, and Y. Bengio. Theano: a cpu and gpu math expression compiler.
In
Proceedings of SciPy, 2010.

[7] R. Chen, H. Su, Y. Zhen, M. Khalilia, D. Hirsch, M. Thompson, T. Davis, Y. Peng, S. Lin,
J. Tejedor-Sojo, E. Searles, and J. Sun. Cloud-based predictive modeling system and its
application to asthma readmission prediction. In AMIA. AMIA, 2015.

[8] E. Choi, M. T. Bahadori, and J. Sun. Doctor ai: Predicting clinical events via recurrent neural

networks. arXiv preprint arXiv:1511.05942, 2015.

[9] E. Choi, A. Schuetz, W. F. Stewart, and J. Sun. Medical concept representation learning
from electronic health records and its application on heart failure prediction. arXiv preprint
arXiv:1602.03686, 2016.

[10] Y. Choi, C. Y.-I. Chiu, and D. Sontag. Learning low-dimensional representations of medical

concepts. 2016. To be submitted to AMIA CRI.

[11] L. Cocito, E. Favale, and L. Reni. Epileptic seizures in cerebral arterial occlusive disease.

Stroke, 1982.

[12] R. Collobert and J. Weston. A uniﬁed architecture for natural language processing: Deep

neural networks with multitask learning. In ICML, 2008.

[13] L. De Vine, G. Zuccon, B. Koopman, L. Sitbon, and P. Bruza. Medical semantic similarity

with a neural language model. In KDD, 2014.

[14] D. Erhan, Y. Bengio, A. Courville, and P. Vincent. Visualizing higher-layer features of a deep

network. University of Montreal, 2009.

[15] J. Forner. Lung volumes and mechanics of breathing in tetraplegics. Spinal Cord, 18(4):258–

266, 1980.

[16] M. Ghassemi, T. Naumann, F. Doshi-Velez, N. Brimmer, R. Joshi, A. Rumshisky, and
P. Szolovits. Unfolding physiological state: Mortality modelling in intensive care units. In
KDD, 2014.

[17] G. E. Hinton, S. Osindero, and Y.-W. Teh. A fast learning algorithm for deep belief nets.

Neural computation, 2006.

[18] R. Kiros, R. Zemel, and R. R. Salakhutdinov. A multiplicative model for learning distributed

text-based attribute representations. In NIPS, 2014.

18

[19] R. Kiros, Y. Zhu, R. Salakhutdinov, R. S. Zemel, A. Torralba, R. Urtasun, and S. Fidler.

Skip-thought vectors. In NIPS, 2015.

[20] Q. Le and T. Mikolov. Distributed representations of sentences and documents. In ICML,

[21] Q. V. Le. Building high-level features using large scale unsupervised learning. In ICASSP,

2014.

2013.

[22] Y. LeCun, L. Bottou, Y. Bengio, and P. Haﬀner. Gradient-based learning applied to document

recognition. Proceedings of the IEEE, 1998.

[23] T. Mikolov, K. Chen, G. Corrado, and J. Dean. Eﬃcient estimation of word representations

in vector space. arXiv preprint arXiv:1301.3781, 2013.

[24] T. Mikolov, M. Karaﬁ´at, L. Burget, J. Cernock`y, and S. Khudanpur. Recurrent neural network

based language model. In INTERSPEECH, 2010.

[25] T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, and J. Dean. Distributed representations

of words and phrases and their compositionality. In NIPS, 2013.

[26] J. A. Minarro-Gim´enez, O. Mar´ın-Alonso, and M. Samwald. Exploring the application of deep
learning techniques on medical text corpora. Studies in health technology and informatics,
2013.

[27] A. Mnih and G. E. Hinton. A scalable hierarchical distributed language model. In NIPS, 2009.

[28] K. P. Murphy. Machine learning: a probabilistic perspective. MIT press, 2012.

[29] J. Pennington, R. Socher, and C. D. Manning. Glove: Global vectors for word representation.

EMNLP, 2014.

In ICASSP, 2014.

[30] J. Schluter and S. Bock. Improved musical onset detection with convolutional neural networks.

[31] R. Socher, A. Perelygin, J. Y. Wu, J. Chuang, C. D. Manning, A. Y. Ng, and C. Potts.
Recursive deep models for semantic compositionality over a sentiment treebank. In EMNLP,
2013.

[32] J. Sun, F. Wang, J. Hu, and S. Edabollahi. Supervised patient similarity measure of hetero-

geneous patient records. KDD Explorations, 2012.

[33] J. Turian, L. Ratinov, and Y. Bengio. Word representations: a simple and general method for

semi-supervised learning. In ACL, 2010.

[34] P. Vincent, H. Larochelle, Y. Bengio, and P.-A. Manzagol. Extracting and composing robust

features with denoising autoencoders. In ICML, 2008.

[35] P. Vincent, H. Larochelle, I. Lajoie, Y. Bengio, and P.-A. Manzagol. Stacked denoising au-
toencoders: Learning useful representations in a deep network with a local denoising criterion.
JMLR, 2010.

19

[36] Y. Wang, K. Ng, R. J. Byrd, J. Hu, S. Ebadollahi, Z. Daar, C. deFilippi, S. R. Steinhubl, and
W. F. Stewart. Early detection of heart failure with varying prediction windows by structured
and unstructured data in electronic health records. In EMBC, 2015.

[37] M. D. Zeiler. Adadelta: An adaptive learning rate method. arXiv preprint arXiv:1212.5701,

2012.

20

