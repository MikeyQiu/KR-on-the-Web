Deep Rotation Equivariant Network

Junying Lia, Zichen Yangb, Haifeng Liub, Deng Caia,∗

aThe State Key Laboratory of CAD&CG, College of Computer Science, Zhejiang University, China
bCollege of Computer Science, Zhejiang University, China

8
1
0
2
 
b
e
F
 
8
2
 
 
]

V
C
.
s
c
[
 
 
2
v
3
2
6
8
0
.
5
0
7
1
:
v
i
X
r
a

Abstract

introduce four op-
Recently, learning equivariant representations has attracted considerable research attention. Dieleman et al.
erations which can be inserted into convolutional neural network to learn deep representations equivariant to rotation. However,
feature maps should be copied and rotated four times in each layer in their approach, which causes much running time and memory
overhead. In order to address this problem, we propose Deep Rotation Equivariant Network consisting of cycle layers, isotonic
layers and decycle layers. Our proposed layers apply rotation transformation on ﬁlters rather than feature maps, achieving a speed
up of more than 2 times with even less memory overhead. We evaluate DRENs on Rotated MNIST and CIFAR-10 datasets and
demonstrate that it can improve the performance of state-of-the-art architectures.

Keywords: Neural network, Rotation equivariance, Deep learning

1. Introduction

Convolutional neural networks(CNNs) recently have made
great success in computer vision tasks[1–5]. One of the rea-
sons to its success is that weight sharing of convolution layers
ensures the learnt representations are translation equivariant[6],
i.e., shifting an image and then feeding it through the network
is the same as feeding the original image and then shifting the
resulting representations.

However, CNNs fail to exploit rotation equivariance to tackle
vision problems on datasets with rotation symmetry in nature,
especially microscopic images or aerial images, which can be
photographed from any angle. Thus, current studies focus on
dealing with this issue.

One widely used method to achieve rotation equivariance is
to constrain the ﬁlters of the ﬁrst convolutional layer to be ro-
tated copies of each other, and then apply cross-channel pooling
immediately after the ﬁrst layer[7–9]. However, only shallow
representations equivariant to rotation can be learnt by apply-
ing one convolutional layer. In addition, such representations
are nearly trivial, since pooling rotated copies is approximately
equivalent to convolving non-rotated inputs with highly sym-
metric ﬁlters.

To solve this problem, [10] introduces four operations which
can be combined to make these models able to learn deep repre-
sentations equivariant to rotation. However, every feature map
should be copied and rotated by these operations four times,
which causes high memory and running time overhead.

In this paper, we give a comprehensive theoretical study
on approaches to rotation equivariance with CNNs. We pro-

∗Corresponding author
Email addresses: microljy@zju.edu.cn (Junying Li),

zichenyang.math@gmail.com (Zichen Yang), haifengliu@zju.edu.cn
(Haifeng Liu), dengcai@gmail.com (Deng Cai)

pose a novel CNN framework, Deep Rotation Equivariant Net-
work(DREN) to obtain deep equivariance representations. We
prove that DREN can achieve the identical output to that of [10]
with much less running time and memory requirements.

We evaluate our framework on two datasets, Rotated MNIST
and CIFAR-10. On Rotated MNIST, it can outperform the ex-
isting methods with less number of parameters. On CIFAR-
10, it can improve the results of state-of-the-art models with
the same number of parameters. Moreover, our implementation
achieves a speed up of more than 2 times as that of [10], with
even less memory overhead.

2. Related Works

Learning invariant representations by neural networks has
been studied for over a decade. Early works focus on reﬁne-
ment of restricted Boltzmann machines(RBMs) and deep belief
nets(DBNs).
[11] gives an approach to automatically gener-
ate topographic maps of similar ﬁlters in an unsupervised man-
ner and these ﬁlters can produce local invariance when being
pooled together.
[12] develops convolutional RBM(c-RBM),
using weight sharing to achieve shift-invariance. Later, a fol-
lowing work by [13] incorporates linear transformation invari-
ance into c-RBMs, yielding features that have a notion of trans-
formation performed. The model proposed by [14] uses a prob-
abilistic max-pooling layer to support eﬃcient probabilistic in-
ference, which also shows the property of translation invari-
ance.

Recently, convolutional neural networks have become the
most popular models in various computer vision tasks[15–18].
One of the advantages of CNNs is its translation equivariant
property provided by weight sharing[6]. However, it cannot
deal with rotation transformation of input images. Thus, many
variants of CNNs have been proposed to settle these problems.

Preprint submitted to Elsevier

March 1, 2018

Basically, the idea of most of the related works[9; 19; 20] is
to stack rotated copies of images or features to obtain rotation
equivariance.

There are also other methods. [21] propose deep symmetry
networks that can form feature maps over arbitrary transforma-
tion groups approximately. Methods proposed by [7; 8] show
that rotation convolution layers followed by a cross-channel
pooling over rotations could achieve rotation equivariance. In
fact, none of the directional features could be extracted by these
methods, since pooling is applied right after one rotation con-
volution.
[6] propose a group action equivariant framework
by stacking group acted convolution and provide a theoreti-
cally grounded formalism to exploit symmetries of CNNs. [22]
present harmonic networks, a CNN structure exhibits equivari-
ance to patch-wise translation and 360-rotation. Recently, the
vector ﬁeld network proposed by [23] applies interpolation to
deal with rotation of general degrees.

[10] introduces four operations to encode rotation symmetry
into feature maps to build a rotation equivariant neural network.
However, feature maps should be rotated each time to ensure
equivariance, which obviously costs much time and memory.
Our approach presents a diﬀerent way to overcome this issue
by rotating ﬁlters, which brings about exactly the same results,
but in a more eﬃcient way.

3. Equivariance and invariance

In this section, we brieﬂy discuss the notions of equivariance
and invariance of image representations. Formally, a represen-
tation of a CNN can be regarded as a function f mapping from
image spaces to feature spaces.

We say, a representation f is equivariant to a family T of
transformations on image spaces, if for any transformation T ∈
T, there exists a corresponding transformation T (cid:48) on feature
spaces, such that

f (T x) = T (cid:48) f (x),

(1)

for any input images x. Intuitively, this means that the learnt
representation f of CNNs changes in an expected way, when
the input image is transformed.

There is another stronger case when T (cid:48) is the identity map,
i.e., the map ﬁxing the inputs, for all T ∈ T. This indicates that
the representations remain unchanged no matter how the input
data is transformed by transformations in T, i.e., the represen-
tation is invariant. Invariance is an ideal property of represen-
tation, because a good object classiﬁer must output an invariant
class label no matter what location of the object lies in.

The goal of this paper is to present a novel convolutional neu-
ral network framework, which learns representations that are
equivariant to rotation transformations R, s. t. R(cid:48) = R, that is

f (Rx) = R f (x),

(2)

for any input image x. Figure 1 gives an example of rotation
equivalent representations learnt by DREN, comparing to a tra-
ditional CNN. The reason that we do not directly work on rota-
tion invariant representations is that this kind of rotation equiv-
ariance can be easily lifted to rotation invariance, for instance,

Figure 1: Latent representations learnt by a CNN and a DREN(Proposed),
where R stands for clockwise rotation. The left part is the result of a typical
CNN while the right one is that of a DREN. In both parts, the outer cycles
consist of the rotated images while the inner cycles consist of the learnt repre-
sentations. Features produced by a DREN is equivariant to rotation while that
produced by a typical CNN is not.

by a global pooling operation[24], i.e., the kernel size of this
pooling layer is equal to the size of feature maps.

Since these are the only four kinds of possible rotation of an
image that can be performed without interpolations, we mainly
deal with the rotation transformation family R = {Rθ|θ =
kπ/2, k ∈ Z}. However, our experimental results show that our
framework can achieve good performance when dealing with
rotation for general degrees.

4. Rotation equivariant convolution

In this section, we deﬁne three novel types of convolutional
layers, which are combined to learn rotation equivariant fea-
tures.

4.1. Preliminaries

For the sake of simplicity, we omit bias terms, activation
functions and other structures, concentrating on convolution. In
addition, we set the stride of any convolution layer be 1. The
general case will be discussed in Section 4.5.

First, we vectorize convolution operation formally to sim-
plify our derivation. Shortly, we shall use matrix multiplication
to describe multi-channel convolution. Let us assume that the
input of a convolutional layer contains n feature maps(images)
{x j}n
j=1. This layer has mn ﬁlters, denoted by Wi j with 1 ≤ i ≤
m, 1 ≤ j ≤ n. These can be organized as a matrix(vector) x of
size n and a matrix W of size m, n in which entries are ﬁlters
or feature maps. We refer to such a matrix(vector) a hyper-
matrix(hyper-vector). Then, the convolution W ∗ x is deﬁned to
be a hyper-vector of size m whose i-th entry is,

(cid:88)

1≤ j≤n

Wi j ∗ x j,

(3)

for each 1 ≤ i ≤ m. One can verify that this is actually equiva-
lent to ordinary multi-channel convolution.

Next, we introduce the rotation operator R, rotating a ﬁlter
or a feature map by a degree of π/2 counterclockwise. We also

2

Figure 2: The framework of Deep Rotation Equivariant Network. The gray panels represent input, feature maps and output. Each square represents a weight
kernel. The letter ’T’ is utilized for distinguishing orientation clearly. The diﬀerent colors of kernel background indicate that the kernel are not qualitatively
equivalent. Although this ﬁgure seems similar to that one in [10], there are 3 critical diﬀerences: 1. We apply rotation on the ﬁlters rather than the feature maps. 2.
The matrix in an isotonic layer is diﬀerent in order from the matrix of cyclic rolling operation in [10]. 3. The decycle layer is a special convolution layer, diﬀerent
from the cyclic pooling applied in [10].

deﬁne the action of R on a hyper-matrix W. R(W) is deﬁned to
be entrywise rotation. There are three obvious facts about the
rotation operator that are frequently used in the sequel.

1. Convolutionally distributive law: R(W ∗ x) = R(W) ∗ R(x).
This indicates that rotating ﬁlters and feature maps simu-
taneously before convolution yields rotated outputs.
2. Additively distributive law: R(X1 + X2) = R(X1) + R(X2).

Note that + is entrywise addition of matrices.

3. Cyclic law: R4 is equal to the identity transformation.

In our framework, we propose three new types of convolu-
tion layers to implement rotation equivariance. Given an im-
age, a cycle layer transforms this image into n0 groups, each
containing 4 feature maps. Then, one can apply k isotonic lay-
ers consecutively to learn deeper representations. Suppose that
the output of the i-th isotonic layer consists of ni groups with
1 ≤ i ≤ k, each containing 4 feature maps as well. Finally,
a decycle layer applies a convolution to merge feature maps,
resulting in nk+1 rotation equivariant feature maps.

Informally, the utility of the cycle layers is to transform rota-
tion of images into cyclic permutations of feature maps in each
group. Then, the isotonic layers are used to preserve the or-
der of permutations in each group. Finally, the decycle layer
decodes permutations in each group to produce rotation equiv-
ariant representations.

In the following discussion, assume that the number of
groups ni = 1 for any 0 ≤ i ≤ k + 1 . The general case will
be discuss in Section 4.5

4.2. Cycle layers

The basic idea of cycle layers is to stack rotated copies of
the ﬁlters. By assumption, the hyper-matrix of the ﬁlters Win in
a cycle layer contains 4 ﬁlters, say Win = [w, Rw, R2w, R3w]T .
Given an input image x, by the deﬁnition of convolution, the
output is

fin(x) = Win ∗ x

= [w ∗ x, Rw ∗ x, R2w ∗ x, R3w ∗ x]T .

Next, we shall derive the relation between cycle layers and rota-
tion operators. Before it, we have to deﬁne a cyclic permutation
operator P acting on a hyper-vector, adding the index of each
entry by 1. Note that if the added index is 4, we reset it to
1. For instance, P(x2) = x3, P(x4) = x1. This description is
similar to the modular operation, thus we refer this operation
addition modulo 4, denoted by x + 1 (mod 4).

When a rotated image Rx is fed into a cycle layer, the output

becomes

fin(Rx) = Win ∗ Rx

= [w ∗ Rx, Rw ∗ Rx, R2w ∗ Rx, R3w ∗ Rx]T
= R[R3w ∗ x, w ∗ x, Rw ∗ x, R2w ∗ x]T
= R ◦ P(Win ∗ x) = R ◦ P fin(x),

(4)

where the third equality follows from the cyclic law and the
convolutional distributive law. This indicates that given a ro-
tated image, the output fin(Rx) of a cycle layer is the same as
fin(x) up to a permutation and a rotation. Hence, the rotation of
images is transformed into the order of cyclic permutation.

Although, cycle layers cannot produce rotation equivariance,
one can immediately obtain it by a following cross-channel
pooling operation. In this case, this operation produces a fea-
ture map by taking average or pixelwise maximum of the four
rotated feature maps. But this is equivalent to use a highly sym-
metric ﬁlter, which generates nearly trivial features. Hence, we
propose isotonic layers to replace it.

4.3. Isotonic layers

To produce non-trivial feature maps, a straightforward way is
stacking more convolutional layers. However, one sees that an
ordinary convolution operation will destroy the order of cyclic
permutations produced by the cyclic layer. Consequently, we
have to study that under what conditions, convolution can pre-
serve the order of cyclic permutations. Mathematically, we can
formulate this idea by the following equation,
fhide(R ◦ Px) = R ◦ P fhide(x),

(5)

3

where fhide stands for the convolution performed by an isotonic
layer. Intuitively, this means that feeding permuted rotated in-
puts, an isotonic layers yields the equivariant permuted rotated
feature maps, hence preserving the order of cyclic permutation.
By induction, one sees that a stacking of h isotonic layers share
the same property, where h is any non-negative integer.

To derive equivalent conditions to Equation (5), we de-
ﬁne diagonally permutation operator D acting on a two-
dimensional hyper-matrix(not a hyper-vector), adding two in-
dices of each entry by 1 modulo 4, for example, D(Wi j) =
Wi+1 (mod 4), j+1 (mod 4). With this, we can show that how the
cyclic permutation operator P interacts with convolution.

Lemma 1. Given an input hyper-vector x of size 4 and a square
hyper-matrix W of size 4, we have, P(W ∗ x) = DW ∗ Px.

Proof. For any 1 ≤ j ≤ 4, let y j be the j-th column hyper-vector
of W ∗ x and y(cid:48)
j be the j-th column hyper-vector of DW ∗ Px.
By the deﬁnition of convolution, one has,

P(y j) = y j+1(mod 4)
4(cid:88)

Wi, j+1(mod 4) ∗ xi

Thus, we restrict the hyper-matrix of the ﬁlters in isotonic
layers to be the form in previous theorem. Therefore, an iso-
tonic layers has the desired property, i.e., Equation (5). This
can be easily extended to general cases.

4.4. Decycle layers

After a stacking of isotonic layers, we have learnt a very deep
representation, with the order of cyclic permutations. Thus, the
task of decycle layers is to transform cyclic permutation infor-
mation into rotation equivariant representations. Formally, we
require the following property,

fout(R ◦ Px) = R fout(x),

(7)

where fout is the convolution of a decycle layer. The meaning is
obvious. The cyclic permutation operator is removed, reducing
to rotation equivariance. Similarly, we can derive an equivalent
condition for Wout, the weight of decycle layer. This requires
two fact that, if Wout is a hyper-vector, one has Wout ∗ Px =
P−1Wout ∗ x and R ◦ P = P ◦ R. Thus, the derivation is shown
below,

=

=

=

i=1
4(cid:88)

i=1
4(cid:88)

i=1
= y(cid:48)
j.

Wi+1(mod 4), j+1(mod 4) ∗ xi+1(mod 4)

DWi j ∗ Pxi

Thus, P(W ∗ x) = DW ∗ Px;

By Lemma 1, suppose Whide as the weight of isotonic layer,

one can show that,

fhide(R ◦ Px) = R ◦ P fhide(x)

⇔ Whide ∗ R ◦ Px = R ◦ P(Whide ∗ x)
⇔ Whide ∗ R ◦ Px = R(DWhide ∗ Px)
⇔ Whide ∗ R ◦ Px = D ◦ RWhide ∗ R ◦ Px.

fout(R ◦ Px) = R fout(x)

⇔ Wout ∗ (R ◦ Px) = R(Wout ∗ x)
⇔ Wout ∗ (P ◦ Rx) = RWout ∗ Rx
⇔ P−1Wout ∗ Rx = RWout ∗ Rx.

Since x can be an arbitrary image, one has

Wout = P ◦ RWout.

(8)

is

equivalent

to say that W is of

This
form
[w, Rw, R2w, R3w]. Although it looks similar to that one
in cycle layers, one see that they actually diﬀer by a transpose
operation.

the

Thus, a decycle layer applies ﬁlters of this form, decoding
permutation information into our desired rotation equivariance,
i.e., fout(R ◦ Px) = R fout(x).

Since x can be an arbitrary image, one has,

Whide = D ◦ RWhide.

(6)

tecture and rotation equivariance of DREN, in detail.

In this subsection, we make a careful discussion on the archi-

4.5. Architecture of DREN

By straightforward calculation, we ﬁnd a special class of hyper-
matrices satisfying Equation (6), which yields the following
theorem.

Theorem 1. A hyper-matrix Whide satisﬁes Equation (6), if and
only if it is of the form





C
RB

D
A
B
RD RA
RC
R2C R2D R2A R2B
R3B R3C R3D R3A





,

where A, B, C, D are square ﬁlters of the same size.

4

4.5.1. Framework

In the architecture of DREN, the ﬁrst layer must be a cycle
layer. It is followed by k ≥ 0 consecutive isotonic layers and
one more decycle layer. Then, we claim that the output repre-
sentation of the decycle layer is rotation equivariant, which can
be easily proved by using the Equation (4), (5) and (7) repeatly.
For notational simplicity, we reuse fhide for diﬀerent isotonic
layers. Indeed, one has,

fout f k

hide fin(Rx) = fout f k

hide(R ◦ P fin(x))
hide fin(x))

= fout(R ◦ P f k
= R fout f k

hide fin(x),

(9)

where if we view fout f k
hide fin the representation f , the equality
of two sides is exactly our desired property, i.e., Equation (2).
Note that, at the end of Section 4.1, we have assumed that ni = 1
for 0 ≤ i ≤ k + 1. In fact, this property can be proved for the
general case similarly.

4.5.2. Compatibility

Moreover, adding bias term is allowable, if any channel in a
group share the shared bias value. So do batch normalization
layers with the shared scale and bias parameters. Since ReLU
activation functions are channel indenpendent operation, they
do not have any impact on rotation equivariance, thus compat-
ible with our architecture. So do dropout layers. Moreover,
one can also apply fully connected layers following the decycle
layer.

In addition, we should discuss convolution and pooling lay-
ers with stride > 1. When stride is more than 1, one can observe
that the ﬁlter may not convolve marginal pixels in an image,
thus destroying rotation equivariance. Indeed, suppose the size
of the image is n by n, rotation equivariance can be preserved
iﬀ. n = k · stride + kernelsize for some k ∈ N. The proof is
trivial.

4.5.3. Invariance

Furthermore, the equivariance property can be lifted to in-
variant property in our framework. Simply applying a global
pooling layer[24] in the end of our framework can make output
rotation invariant.

4.6. Memory consumption analysis

Some previous work[10; 20; 25] rotate feature maps to obtain
rotation equivariance. Indeed, one can show that rotating fea-
ture maps correspondingly can yield equivalent results. How-
ever, rotating and buﬀering ﬁlters are more eﬃcient, because
feature maps have much larger size than ﬁlters at most of the
time.

The theoretical analysis of memory usage is based on the
fact that most of popular deep learning frameworks use GEMM
algorithm[26] to compute image convolution. Precisely, feature
maps should be copied k2 times, merged into a single matrix,
then multiplied by weight matrix. Therefore, the total size of
feature maps is clearly much larger than the size of ﬁlters at
most of the time. This indicates that rotating the feature maps
lead to about 4 times more memory cost than rotating the ﬁlters.
The detail memory costs are listed in Table 1.

On the other side, rotating feature maps also costs more time
in rotation operation and copy operation. In Section 5, we give a
detailed comparison on our approach and an architecture using
the strategy of rotating feature maps, proposed by [10].

4.7. Relations to other methods

Since DREN is a general framework, it can be shown that
several existing networks become special cases of our frame-
work.

For instance, if we set all element of the hyper-matrix of a de-
cycle layer to be the identity matrix times a normalizing factor,

Table 1: Memory cost of rotating ﬁlters and feature maps

Method

Mem. cost

Rotate
ﬁlters
4cincoutk2
ncinwh
ncinwhk2

Rotate feature
map
cincoutk2
4ncinwh
4ncinwhk2

Filters
Feature map
Feature map(GPU)
1 Here n, cin, cout, w, h, k denote batch size, input channels, output chan-

nels, width of input, height of input and kernel size, respectively.

the decycle layer becomes cross-channel mean pooling layer
that is used by most of work[6–8].

For isotonic layers, we can set Whide to a diagonal form, i.e.,
all of ﬁlters other than those on the diagonal of hyper-matrix to
be zero matrices. In other words, this means that all of feature
maps would be convolved by rotated copies of a single ﬁlter,
which is utilized by [10; 19; 25].

Moreover, the last decycle layer can be replaced by a cross-
channel max pooling layer. Although it is not a decycle layer
in nature, the cross-channel max pooling layer satisﬁes Equa-
tion (7) as well. Actually other layers that satisfy Equation (7),
such as cross-channel root-mean-square(RMS) layer, can also
be applied to replace the decycle layer and to preserve rotation
equivariance as well.

Finally, we claim that our approach yields the equivalent re-
sult to that of [10] when the proposed layers are carefully used.
Note that, by convolutional distributive law, for any ﬁlter W
and any feature map x, R(W ∗ x) = R(W) ∗ R(x). Then we can
derive that the cyclic slice layer[10] followed by an ordinary
convolutional layer equals to the cycle layer; the cyclic roll
layer[10] followed by an ordinary convolutional layer equals
to the isotonic layer; the cyclic pooling[10] is actually cross-
channel pooling which is a special case of the decycle layer;
the cyclic stack layer[10] followed by an ordinary convolutional
layer equals to the isotonic layer whose weight hyper-matrix
Whide is a diagonal matrix. In fact, DREN operates on ﬁlters
rather than feature maps, reducing about half of running time
with less memory overhead compared with that of [10]

5. Experiments

In this section, we evaluate our framework on two datasets,
Rotated MNIST and CIFAR-10. All of the experiments are pub-
lished on GitHub1.

5.1. Rotated MNIST

First, we evaluate on Rotated MNIST dataset[27]. It is the
rotated version of MNIST dataset[28], with digits being rotated
for a degree uniformly drawn from [0, 2π]. In total, it contains
62000 handwritting digit images, among which there are 10000
images for training, 2000 for validating and 50000 for testing.
We choose the Z2CNN(refer to [6]) as our baseline, which
consists of 7 convolutional layers of kernel size 3×3(4×4 in the

1https://github.com/microljy/DREN_Tensorflow

5

last layer). Each layer of Z2CNN has 20 channels, followed by
a ReLU activation layer, a dropout layer, a batch normalization
layer. Besides, a max pooling layer is applied right after the
second layer.

We replace the ﬁrst layer and the last layer of the baseline
network by a cycle layer and a decycle layer, respectively. Be-
sides, the intermediate layers are replaced by isotonic layers.
Moreover, since that our proposed layers can reduce the num-
ber of parameters fourfold, we double the number of channels
in each layers to keep the number of parameters approximately
ﬁxed.

Table 2 lists our results. This architecture(DREN) is found
to achieve high accuracy with a small number of params. We
also try to replace the decycle layer in DREN with a isotonic
layer followed by a cross-channel max pooling layer. This net-
work(DRENMaxPoolling) have 25k params., which is 24% less
than that of H-Net[22], and equal to that of P4CNN[6] and
Dieleman et al.[10]. DRENMaxPoolling outperforms all the
previous models without more params.. In addition, our archi-
tecture can reduce about half of running time with less memory
overhead compared with Dieleman et al.[10], this would be fur-
ther discussed in Section 5.4.

Table 2: Performance of various models on Rotated MNIST.

Model
SVM[27]
Transformation RBM[29]
Conv-RBM[13]
Z2CNN[6]
P4CNN[6]
H-Net[22]
Dieleman et al.[10]
DREN
DRENMaxPoolling

Error
11.11%
4.2%
3.98%
5.03%
2.28%
1.69%
1.78%
1.78%
1.56%

Param.
-
-
-
22k
25k
33k
25k
22k
25k

5.2. CIFAR-10

We also evaluate our framework on CIFAR-10[30], a real-
world dataset that does not have rotational symmetry in na-
ture.
It consists of 50000 training and 10000 testing images
uniformly drawn from 10 classes. Each one has RGB chan-
nels of size 32 × 32. For this dataset, we apply global contrast
normalization to preprocess the data, as was used by [31].

We test our framework on Network in Network(NIN)[24]
and Resnet-20[5]. First, we replace the ordinary convolu-
tional layers of these models by our proposed layers, see r-
NIN(conv1-4), r-Resnet-20(conv1-13), where conv1-k means
that the ﬁrst k layers are replaced by our proposed layers. Since
our proposed layers only need a quarter of the number of pa-
rameters in each layer, we also evaluate r-NIN(conv1-4)×4 and
r-Resnet-20(conv1-13)×4, where the number of channels of the
ﬁrst 4 layers are doubled to keep the total number of parameters

6

Table 3: Performance of various models on CIFAR-10.

Error
10.41%
9.4%
9.8%
9.0%
9.00%
8.51%
7.17%

Model
NIN[24]
NIN*
r-NIN(conv1-4)
r-NIN(conv1-4)×4
Resnet-20[5]
r-Resnet-20(conv1-13)
r-Resnet-20(conv1-13)×4
1 * means our implementation.
2 conv1-k means 1-k layers are replaced by our proposed layers
3 r− means the model utilizes rotation equivariant layers.
4 ×4 means the number of channels of proposed layers are doubled.

Params.
967k
967k
576k
958k
297k
245k
297k

Rotated MNIST

CIFAR-10

r-Z2CNN
r-Z2CNN×4

r-NIN
r-NIN×4

)

%

(
r
o
r
r
e

t
s
e
T

6

5

4

3

2

)

%

(
r
o
r
r
e

t
s
e
T

16

14

12

10

8

base 1-2

1-3

1-4

1-5

1-6

1-7

base 1-2

1-3

1-4

1-5

1-6

1-7

Figure 3: Classiﬁcation error of models with diﬀerent numbers of our pro-
posed layers: The left one is the results on Rotated MNIST and the right one
is that on CIFAR-10. The horizontal axis shows the number of our proposed
layers applied. It turns out that, for datasets which has rotation symmetry in na-
ture(Rotated MNIST), applying more isotonic layers yields better classiﬁcation
accuracy. We argue that higher level rotation equivariant representations learnt
by stacking more isotonic layers improves the classiﬁcation accuracy on such
dataset. However, for CIFAR-10, the circumstance changes. Applying 4 or 5
isotonic layers achieves the best performance. We argue that higher level rota-
tion equivariant representations are not helpful on such dataset without rotation
symmetry, and applying more isotonic layers reduces the number of parame-
ters(model complexity) fourfold, therefore leading to severe underﬁtting. ×4
means the model with doubled number of channels.

unchanged. The results are shown in Table 3. It shows that our
model(r-NIN(conv1-4)×4 and r-Resnet-20(conv1-13)×4) can
outperform the baseline with roughly the same number of pa-
rameters. In this experiment, we do not replace all of the con-
volution layers with our proposed layers, since we observe that
simply replacing all layers cannot achieve the best performance.
This would be discussed in the next subsection.

5.3. How many isotonic layers should be applied?

The only hyperparameter of our framework is the number
of isotonic layers used. Thus, in this subsection, we study the
performance of DRENs with diﬀerent numbers of isotonic lay-
ers in the following experiments. We also choose two base-
lines above, evaluate them on Rotated MNIST and CIFAR-10
respectively, and gradually integrate more isotonic layers into
baselines(e. g., conv1-2, conv1-3, conv1-4, etc.).

The results are shown in Figure 3. We observe two quite dis-
tinct trends in the two datasets. For Rotated MNIST which has
rotation symmetry in nature, the more isotonic layers we use,
the better performance the model achieves, even with less and
less number of parameters. However, for CIFAR-10, r-NINs

Figure 4: The representations in the last convolutional layer learnt by NIN[24], H-Net[22], P4-ALL-CNN-C[6] and DREN. The two columns correspond
to the representations of an image of automobile(left) and an image of truck(right). Inside one of the 8 pictures, the leftmost column contains the rotated input
images while the remaining 10 columns contain the 10 feature maps in the last convolutional layers, which corresponds to the 10 classes of CIFAR-10. We slightly
modify the architecture of H-Net to ensure that a global average pooling layer is used right after the last convolutional layer. The other three networks also apply
this structure. Thus, the predictions of the networks are exactly the class whose related representation attains maximum density. We mark the maximal one(the
prediction) with a red square. It turns out that when the input is rotated, NIN yields entirely diﬀerent representations, leading to wrong predictions. For H-Net and
P4-ALL-CNN-C, the representations are partly equivariant to rotation. However, H-Net still predicts incorrectly, when the image of automobile is rotated. In fact,
only the representations of DREN are exactly equivariant to rotation, and thus the predictions of DREN are consistent, when the input is rotated. Moreover, we ﬁnd
our leanrt representations for automobile and for truck are very similar while that of other models are not. This shows that the representations learnt by DREN are
similar for semantically similar objects, which indicates the reasonability of adding rotation equivariant constraint.

7

achieve best performance when using two isotonic layers(i.e.,
replace 4 convolutional layers).

running time of the ordinary CNN, since the ﬁlters can be ro-
tated and stored before running.

Because CIFAR-10 does not have deep rotation symmetry,
intuitively, most eﬀective latent representations maybe be not
rotation equivariant. Thus, using too much isotonic layers pre-
vents the network from learning such representations. This is
one of the reason why our framework cannot achieve better
performance with more isotonic layers. Another cause may
be that the number of parameters(i.e., model complexity) de-
creases with more isotonic layers used, thus leading to a under-
ﬁtting model.

The other extreme case that very a few isotonic layers are ap-
plied, also results in bad results. According to Figure 3, our
models(r-Z2CNN,r-NIN,r-NIN×4) underperform the baseline
when less than two isotonic layers are applied. This observa-
tion actually meets with the argument we pose in Section 1,
that the networks with a few or none isotonic layer can only
learn shallow and trivial rotation equivariant representations.

5.4. Running time of rotating ﬁlters and feature maps

In order to compare the running time costs between rotating
feature maps and rotating ﬁlters, we evaluate both methods on
Rotated MNIST dataset. We take the implementation presented
by [10] as the representative of the methods that rotate feature
maps. Since there are some diﬀerence between their framework
and ours, we make minor modiﬁcation on both frameworks to
ensure that the comparison is a fair play. The decycle layer is
replaced with a cross-channel mean-pooling layer in our frame-
work, and the cyclic roll operation is applied before every con-
volution layer except the ﬁrst one in their frameworks.

The running time of rotating ﬁlters and feature maps are
shown in Table 4. Both implementations run on Intel core
i7-5930K processors(3.50GHz) and GeForce GTX 1080 with
NVIDIA CUDA 8.0 and cuDNN 5. Since all models are im-
plemented with Theano that automatically free memory using a
reference count system, we cannot exactly determine memory
consumption. Thus, only running time is listed.

Table 4: Running time of two implementations.

Implementation

Setting

Rotate ﬁlters

Rotate feature maps[10]

Model

Z2CNN

NIN

Z2CNN

NIN

Batch size
64
128
64
128
64
128
64
128

Time

1.97s
1.44s
11.00s
9.52s
4.15s
3.74s
22.13s
18.73s

1 The time cost is the testing time of testing 50k images.
Table 4 shows that our implementation based on rotating ﬁl-
ters are twice as fast as the implementation based on rotating
feature maps[10; 20; 25]. In fact, the running time of the im-
plementation based on rotating ﬁlters can be the same as the

8

5.5. Visualization of DREN

Since deep rotation equivariant representations can be learnt
from our framework, we are concerned with how such represen-
tations diﬀer from ordinary representation of a typical CNN and
other rotation equivariance structures. To this end, we visual-
ized the representations produced by NIN[24], P4-ALL-CNN-
C[6], H-Net[22] and DREN trained on CIFAR-10. We slight
modify the architecture of H-Net to a global average pooling
manner that are used by the other three models in order for fair
comparison and clear visualization. In detail, we apply global
average pooling layer rather than fully connected layer in above
models. This indicates that the feature maps in the last convo-
lutional layers are the conﬁdence maps of the categories in fact.
Such feature maps of four models are shown in Figure 4. In
each picture, there are 11 columns. The leftmost one is the in-
put image while the remaining ones are the feature maps in the
last convolutional layer, each one corresponding to a class of
CIFAR-10. In each row, we mark the predictions of the net-
works(i.e., the one with maximal density) with red squares.

It turns out that when the input is rotated, NIN yields entirely
diﬀerent representations, leading to wrong predictions. For H-
Net and P4-ALL-CNN-C, the representations are partly equiv-
ariant to rotation. However, H-Net still predicts incorrectly,
when the image of automobile is rotated. In fact, only the rep-
resentations of DREN are exactly equivariant to rotation, and
thus the predictions of DREN are consistent when the input is
rotated.

Moreover, we ﬁnd our leanrt representations for automobile
and for truck are very similar while that of other models are not.
This shows that the representations learnt by DREN are similar
for semantically similar objects, which indicates the reasonabil-
ity of adding rotation equivariant constraint.

6. Conclusion & Discussion

We propose a novel CNN framework, DREN, which can
learn deep rotation equivariant representations from images.
Theoretical guarantee is provided that the features are rota-
tion equivariant to rotation of degree kπ/2 for k ∈ Z and ex-
periment results show that our framework can also deal with
other degrees. We evaluate our framework on Rotated MNIST
and CIFAR-10 datasets, outperforming several state-of-the-art
CNN architectures. In addition, our implementation of rotating
ﬁlters costs only a half time of feeding forward comparing to
the methods which rotate feature maps.

As a future direction, we suggest to settle the cases of rotation
of general degree. Although our framework mainly deals with
rotation of degree kπ/2 for k ∈ Z, it can be easily generalized
to any ﬁnte group of rotation transformations, if there is an eﬃ-
cient way to perform rotations of any degree on ﬁlters. In short,
our approach is a tradeoﬀ between eﬃciency and performance.
For another direction, we would like to design new types
of convolutional layers to implement equivariance with respect

[20] S. Dieleman, K. W. Willett, J. Dambre, Rotation-invariant convolutional
neural networks for galaxy morphology prediction, Monthly notices of
the royal astronomical society 450 (2) (2015) 1441–1459.

[21] R. Gens, P. M. Domingos, Deep symmetry networks, in: Advances in

neural information processing systems, 2014, pp. 2537–2545.

[22] D. E. Worrall, S. J. Garbin, D. Turmukhambetov, G. J. Brostow, Harmonic
networks: Deep translation and rotation equivariance, arXiv preprint
arXiv:1612.04642.

[23] D. M. Gonzalez, M. Volpi, D. Tuia, Learning rotation invariant convolu-

tional ﬁlters for texture classiﬁcation, CoRR abs/1604.06720.

[24] M. Lin, Q. Chen, S. Yan, Network in network, in: In Proc. ICLR, 2014.
[25] D. Laptev, N. Savinov, J. M. Buhmann, M. Pollefeys, Ti-pooling:
transformation-invariant pooling for feature learning in convolutional
neural networks, arXiv preprint arXiv:1604.06318.

[26] V. Volkov, J. W. Demmel, Benchmarking gpus to tune dense linear alge-
bra, in: High Performance Computing, Networking, Storage and Analy-
sis, 2008. SC 2008. International Conference for, IEEE, 2008, pp. 1–11.
[27] H. Larochelle, D. Erhan, A. Courville, J. Bergstra, Y. Bengio, An em-
pirical evaluation of deep architectures on problems with many factors
of variation, in: Proceedings of the 24th international conference on Ma-
chine learning, ACM, 2007, pp. 473–480.

[28] Y. LeCun, L. Bottou, Y. Bengio, P. Haﬀner, Gradient-based learning ap-
plied to document recognition, Proceedings of the IEEE 86 (11) (1998)
2278–2324.

[29] K. Sohn, H. Lee, Learning invariant representations with local transfor-

mations, arXiv preprint arXiv:1206.6418.

[30] A. Krizhevsky, G. Hinton, Learning multiple layers of features from tiny

images.

[31] I. Goodfellow, D. Warde-Farley, M. Mirza, A. Courville, Y. Bengio, Max-
out networks, in: Proceedings of The 30th International Conference on
Machine Learning, 2013, pp. 1319–1327.

to scale transformations and more generally, aﬃne transforma-
tions. These may improve the performance of CNNs further.

References

References

[1] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan,
V. Vanhoucke, A. Rabinovich, Going deeper with convolutions, in: Pro-
ceedings of the IEEE Conference on Computer Vision and Pattern Recog-
nition, 2015, pp. 1–9.

[2] R. Girshick, J. Donahue, T. Darrell, J. Malik, Rich feature hierarchies for
accurate object detection and semantic segmentation, in: Proceedings of
the IEEE conference on computer vision and pattern recognition, 2014,
pp. 580–587.

[3] A. Krizhevsky, I. Sutskever, G. E. Hinton, Imagenet classiﬁcation with
deep convolutional neural networks, in: Advances in neural information
processing systems, 2012, pp. 1097–1105.

[4] K. Simonyan, A. Zisserman, Very deep convolutional networks for large-

scale image recognition, arXiv preprint arXiv:1409.1556.

[5] K. He, X. Zhang, S. Ren, J. Sun, Deep residual learning for image recog-
nition, in: Proceedings of the IEEE conference on computer vision and
pattern recognition, 2016, pp. 770–778.

[6] T. Cohen, M. Welling, Group equivariant convolutional networks, in:
Proceedings of the 33nd International Conference on Machine Learn-
ing, ICML 2016, New York City, NY, USA, June 19-24, 2016, 2016,
pp. 2990–2999.

[7] F. Wu, P. Hu, D. Kong, Flip-rotate-pooling convolution and split dropout
on convolution neural networks for image classiﬁcation, arXiv preprint
arXiv:1507.08754.

[8] D. Marcos, M. Volpi, D. Tuia, Learning rotation invariant convolutional
ﬁlters for texture classiﬁcation, in: Pattern Recognition (ICPR), 2016
23rd International Conference on, IEEE, 2016, pp. 2012–2017.

[9] D. Teney, M. Hebert, Learning to extract motion from videos in convolu-

tional neural networks, arXiv preprint arXiv:1601.07532.

[10] S. Dieleman, J. D. Fauw, K. Kavukcuoglu, Exploiting cyclic symmetry in
convolutional neural networks, in: Proceedings of the 33nd International
Conference on Machine Learning, ICML 2016, New York City, NY, USA,
June 19-24, 2016, 2016, pp. 1889–1898.

[11] K. Kavukcuoglu, R. Fergus, Y. LeCun, et al., Learning invariant features
through topographic ﬁlter maps, in: Computer Vision and Pattern Recog-
nition, 2009. CVPR 2009. IEEE Conference on, IEEE, 2009, pp. 1605–
1612.

[12] M. Norouzi, M. Ranjbar, G. Mori, Stacks of convolutional restricted
boltzmann machines for shift-invariant feature learning, in: Computer Vi-
sion and Pattern Recognition, 2009. CVPR 2009. IEEE Conference on,
IEEE, 2009, pp. 2735–2742.

[13] U. Schmidt, S. Roth, Learning rotation-aware features: From invariant
priors to equivariant descriptors, in: Computer Vision and Pattern Recog-
nition (CVPR), 2012 IEEE Conference on, IEEE, 2012, pp. 2050–2057.
[14] H. Lee, R. Grosse, R. Ranganath, A. Y. Ng, Convolutional deep belief net-
works for scalable unsupervised learning of hierarchical representations,
in: Proceedings of the 26th annual international conference on machine
learning, ACM, 2009, pp. 609–616.

[15] J. Yu, C. Hong, Y. Rui, D. Tao, Multi-task autoencoder model for recov-
ering human poses, IEEE Transactions on Industrial Electronics PP (99)
(2017) 1–1.

[16] J. Yu, B. Zhang, Z. Kuang, D. Lin, J. Fan, iprivacy: image privacy pro-
tection by identifying sensitive objects via deep multi-task learning, IEEE
Transactions on Information Forensics and Security 12 (5) (2017) 1005–
1016.

[17] J. Zhang, K. Li, Y. Liang, N. Li, Learning 3d faces from 2d images via

stacked contractive autoencoder , Neurocomputing 257 (2017) 67–78.

[18] K. Grzegorczyk, M. Kurdziel, P. I. W´ojcik, Encouraging orthogonality
between weight vectors in pretrained deep neural networks, Neurocom-
puting 202 (2016) 84–90.

[19] B. Fasel, D. Gatica-Perez, Rotation-invariant neoperceptron, in: 18th In-
ternational Conference on Pattern Recognition (ICPR’06), Vol. 3, IEEE,
2006, pp. 336–339.

9

Deep Rotation Equivariant Network

Junying Lia, Zichen Yangb, Haifeng Liub, Deng Caia,∗

aThe State Key Laboratory of CAD&CG, College of Computer Science, Zhejiang University, China
bCollege of Computer Science, Zhejiang University, China

8
1
0
2
 
b
e
F
 
8
2
 
 
]

V
C
.
s
c
[
 
 
2
v
3
2
6
8
0
.
5
0
7
1
:
v
i
X
r
a

Abstract

introduce four op-
Recently, learning equivariant representations has attracted considerable research attention. Dieleman et al.
erations which can be inserted into convolutional neural network to learn deep representations equivariant to rotation. However,
feature maps should be copied and rotated four times in each layer in their approach, which causes much running time and memory
overhead. In order to address this problem, we propose Deep Rotation Equivariant Network consisting of cycle layers, isotonic
layers and decycle layers. Our proposed layers apply rotation transformation on ﬁlters rather than feature maps, achieving a speed
up of more than 2 times with even less memory overhead. We evaluate DRENs on Rotated MNIST and CIFAR-10 datasets and
demonstrate that it can improve the performance of state-of-the-art architectures.

Keywords: Neural network, Rotation equivariance, Deep learning

1. Introduction

Convolutional neural networks(CNNs) recently have made
great success in computer vision tasks[1–5]. One of the rea-
sons to its success is that weight sharing of convolution layers
ensures the learnt representations are translation equivariant[6],
i.e., shifting an image and then feeding it through the network
is the same as feeding the original image and then shifting the
resulting representations.

However, CNNs fail to exploit rotation equivariance to tackle
vision problems on datasets with rotation symmetry in nature,
especially microscopic images or aerial images, which can be
photographed from any angle. Thus, current studies focus on
dealing with this issue.

One widely used method to achieve rotation equivariance is
to constrain the ﬁlters of the ﬁrst convolutional layer to be ro-
tated copies of each other, and then apply cross-channel pooling
immediately after the ﬁrst layer[7–9]. However, only shallow
representations equivariant to rotation can be learnt by apply-
ing one convolutional layer. In addition, such representations
are nearly trivial, since pooling rotated copies is approximately
equivalent to convolving non-rotated inputs with highly sym-
metric ﬁlters.

To solve this problem, [10] introduces four operations which
can be combined to make these models able to learn deep repre-
sentations equivariant to rotation. However, every feature map
should be copied and rotated by these operations four times,
which causes high memory and running time overhead.

In this paper, we give a comprehensive theoretical study
on approaches to rotation equivariance with CNNs. We pro-

∗Corresponding author
Email addresses: microljy@zju.edu.cn (Junying Li),

zichenyang.math@gmail.com (Zichen Yang), haifengliu@zju.edu.cn
(Haifeng Liu), dengcai@gmail.com (Deng Cai)

pose a novel CNN framework, Deep Rotation Equivariant Net-
work(DREN) to obtain deep equivariance representations. We
prove that DREN can achieve the identical output to that of [10]
with much less running time and memory requirements.

We evaluate our framework on two datasets, Rotated MNIST
and CIFAR-10. On Rotated MNIST, it can outperform the ex-
isting methods with less number of parameters. On CIFAR-
10, it can improve the results of state-of-the-art models with
the same number of parameters. Moreover, our implementation
achieves a speed up of more than 2 times as that of [10], with
even less memory overhead.

2. Related Works

Learning invariant representations by neural networks has
been studied for over a decade. Early works focus on reﬁne-
ment of restricted Boltzmann machines(RBMs) and deep belief
nets(DBNs).
[11] gives an approach to automatically gener-
ate topographic maps of similar ﬁlters in an unsupervised man-
ner and these ﬁlters can produce local invariance when being
pooled together.
[12] develops convolutional RBM(c-RBM),
using weight sharing to achieve shift-invariance. Later, a fol-
lowing work by [13] incorporates linear transformation invari-
ance into c-RBMs, yielding features that have a notion of trans-
formation performed. The model proposed by [14] uses a prob-
abilistic max-pooling layer to support eﬃcient probabilistic in-
ference, which also shows the property of translation invari-
ance.

Recently, convolutional neural networks have become the
most popular models in various computer vision tasks[15–18].
One of the advantages of CNNs is its translation equivariant
property provided by weight sharing[6]. However, it cannot
deal with rotation transformation of input images. Thus, many
variants of CNNs have been proposed to settle these problems.

Preprint submitted to Elsevier

March 1, 2018

Basically, the idea of most of the related works[9; 19; 20] is
to stack rotated copies of images or features to obtain rotation
equivariance.

There are also other methods. [21] propose deep symmetry
networks that can form feature maps over arbitrary transforma-
tion groups approximately. Methods proposed by [7; 8] show
that rotation convolution layers followed by a cross-channel
pooling over rotations could achieve rotation equivariance. In
fact, none of the directional features could be extracted by these
methods, since pooling is applied right after one rotation con-
volution.
[6] propose a group action equivariant framework
by stacking group acted convolution and provide a theoreti-
cally grounded formalism to exploit symmetries of CNNs. [22]
present harmonic networks, a CNN structure exhibits equivari-
ance to patch-wise translation and 360-rotation. Recently, the
vector ﬁeld network proposed by [23] applies interpolation to
deal with rotation of general degrees.

[10] introduces four operations to encode rotation symmetry
into feature maps to build a rotation equivariant neural network.
However, feature maps should be rotated each time to ensure
equivariance, which obviously costs much time and memory.
Our approach presents a diﬀerent way to overcome this issue
by rotating ﬁlters, which brings about exactly the same results,
but in a more eﬃcient way.

3. Equivariance and invariance

In this section, we brieﬂy discuss the notions of equivariance
and invariance of image representations. Formally, a represen-
tation of a CNN can be regarded as a function f mapping from
image spaces to feature spaces.

We say, a representation f is equivariant to a family T of
transformations on image spaces, if for any transformation T ∈
T, there exists a corresponding transformation T (cid:48) on feature
spaces, such that

f (T x) = T (cid:48) f (x),

(1)

for any input images x. Intuitively, this means that the learnt
representation f of CNNs changes in an expected way, when
the input image is transformed.

There is another stronger case when T (cid:48) is the identity map,
i.e., the map ﬁxing the inputs, for all T ∈ T. This indicates that
the representations remain unchanged no matter how the input
data is transformed by transformations in T, i.e., the represen-
tation is invariant. Invariance is an ideal property of represen-
tation, because a good object classiﬁer must output an invariant
class label no matter what location of the object lies in.

The goal of this paper is to present a novel convolutional neu-
ral network framework, which learns representations that are
equivariant to rotation transformations R, s. t. R(cid:48) = R, that is

f (Rx) = R f (x),

(2)

for any input image x. Figure 1 gives an example of rotation
equivalent representations learnt by DREN, comparing to a tra-
ditional CNN. The reason that we do not directly work on rota-
tion invariant representations is that this kind of rotation equiv-
ariance can be easily lifted to rotation invariance, for instance,

Figure 1: Latent representations learnt by a CNN and a DREN(Proposed),
where R stands for clockwise rotation. The left part is the result of a typical
CNN while the right one is that of a DREN. In both parts, the outer cycles
consist of the rotated images while the inner cycles consist of the learnt repre-
sentations. Features produced by a DREN is equivariant to rotation while that
produced by a typical CNN is not.

by a global pooling operation[24], i.e., the kernel size of this
pooling layer is equal to the size of feature maps.

Since these are the only four kinds of possible rotation of an
image that can be performed without interpolations, we mainly
deal with the rotation transformation family R = {Rθ|θ =
kπ/2, k ∈ Z}. However, our experimental results show that our
framework can achieve good performance when dealing with
rotation for general degrees.

4. Rotation equivariant convolution

In this section, we deﬁne three novel types of convolutional
layers, which are combined to learn rotation equivariant fea-
tures.

4.1. Preliminaries

For the sake of simplicity, we omit bias terms, activation
functions and other structures, concentrating on convolution. In
addition, we set the stride of any convolution layer be 1. The
general case will be discussed in Section 4.5.

First, we vectorize convolution operation formally to sim-
plify our derivation. Shortly, we shall use matrix multiplication
to describe multi-channel convolution. Let us assume that the
input of a convolutional layer contains n feature maps(images)
{x j}n
j=1. This layer has mn ﬁlters, denoted by Wi j with 1 ≤ i ≤
m, 1 ≤ j ≤ n. These can be organized as a matrix(vector) x of
size n and a matrix W of size m, n in which entries are ﬁlters
or feature maps. We refer to such a matrix(vector) a hyper-
matrix(hyper-vector). Then, the convolution W ∗ x is deﬁned to
be a hyper-vector of size m whose i-th entry is,

(cid:88)

1≤ j≤n

Wi j ∗ x j,

(3)

for each 1 ≤ i ≤ m. One can verify that this is actually equiva-
lent to ordinary multi-channel convolution.

Next, we introduce the rotation operator R, rotating a ﬁlter
or a feature map by a degree of π/2 counterclockwise. We also

2

Figure 2: The framework of Deep Rotation Equivariant Network. The gray panels represent input, feature maps and output. Each square represents a weight
kernel. The letter ’T’ is utilized for distinguishing orientation clearly. The diﬀerent colors of kernel background indicate that the kernel are not qualitatively
equivalent. Although this ﬁgure seems similar to that one in [10], there are 3 critical diﬀerences: 1. We apply rotation on the ﬁlters rather than the feature maps. 2.
The matrix in an isotonic layer is diﬀerent in order from the matrix of cyclic rolling operation in [10]. 3. The decycle layer is a special convolution layer, diﬀerent
from the cyclic pooling applied in [10].

deﬁne the action of R on a hyper-matrix W. R(W) is deﬁned to
be entrywise rotation. There are three obvious facts about the
rotation operator that are frequently used in the sequel.

1. Convolutionally distributive law: R(W ∗ x) = R(W) ∗ R(x).
This indicates that rotating ﬁlters and feature maps simu-
taneously before convolution yields rotated outputs.
2. Additively distributive law: R(X1 + X2) = R(X1) + R(X2).

Note that + is entrywise addition of matrices.

3. Cyclic law: R4 is equal to the identity transformation.

In our framework, we propose three new types of convolu-
tion layers to implement rotation equivariance. Given an im-
age, a cycle layer transforms this image into n0 groups, each
containing 4 feature maps. Then, one can apply k isotonic lay-
ers consecutively to learn deeper representations. Suppose that
the output of the i-th isotonic layer consists of ni groups with
1 ≤ i ≤ k, each containing 4 feature maps as well. Finally,
a decycle layer applies a convolution to merge feature maps,
resulting in nk+1 rotation equivariant feature maps.

Informally, the utility of the cycle layers is to transform rota-
tion of images into cyclic permutations of feature maps in each
group. Then, the isotonic layers are used to preserve the or-
der of permutations in each group. Finally, the decycle layer
decodes permutations in each group to produce rotation equiv-
ariant representations.

In the following discussion, assume that the number of
groups ni = 1 for any 0 ≤ i ≤ k + 1 . The general case will
be discuss in Section 4.5

4.2. Cycle layers

The basic idea of cycle layers is to stack rotated copies of
the ﬁlters. By assumption, the hyper-matrix of the ﬁlters Win in
a cycle layer contains 4 ﬁlters, say Win = [w, Rw, R2w, R3w]T .
Given an input image x, by the deﬁnition of convolution, the
output is

fin(x) = Win ∗ x

= [w ∗ x, Rw ∗ x, R2w ∗ x, R3w ∗ x]T .

Next, we shall derive the relation between cycle layers and rota-
tion operators. Before it, we have to deﬁne a cyclic permutation
operator P acting on a hyper-vector, adding the index of each
entry by 1. Note that if the added index is 4, we reset it to
1. For instance, P(x2) = x3, P(x4) = x1. This description is
similar to the modular operation, thus we refer this operation
addition modulo 4, denoted by x + 1 (mod 4).

When a rotated image Rx is fed into a cycle layer, the output

becomes

fin(Rx) = Win ∗ Rx

= [w ∗ Rx, Rw ∗ Rx, R2w ∗ Rx, R3w ∗ Rx]T
= R[R3w ∗ x, w ∗ x, Rw ∗ x, R2w ∗ x]T
= R ◦ P(Win ∗ x) = R ◦ P fin(x),

(4)

where the third equality follows from the cyclic law and the
convolutional distributive law. This indicates that given a ro-
tated image, the output fin(Rx) of a cycle layer is the same as
fin(x) up to a permutation and a rotation. Hence, the rotation of
images is transformed into the order of cyclic permutation.

Although, cycle layers cannot produce rotation equivariance,
one can immediately obtain it by a following cross-channel
pooling operation. In this case, this operation produces a fea-
ture map by taking average or pixelwise maximum of the four
rotated feature maps. But this is equivalent to use a highly sym-
metric ﬁlter, which generates nearly trivial features. Hence, we
propose isotonic layers to replace it.

4.3. Isotonic layers

To produce non-trivial feature maps, a straightforward way is
stacking more convolutional layers. However, one sees that an
ordinary convolution operation will destroy the order of cyclic
permutations produced by the cyclic layer. Consequently, we
have to study that under what conditions, convolution can pre-
serve the order of cyclic permutations. Mathematically, we can
formulate this idea by the following equation,
fhide(R ◦ Px) = R ◦ P fhide(x),

(5)

3

where fhide stands for the convolution performed by an isotonic
layer. Intuitively, this means that feeding permuted rotated in-
puts, an isotonic layers yields the equivariant permuted rotated
feature maps, hence preserving the order of cyclic permutation.
By induction, one sees that a stacking of h isotonic layers share
the same property, where h is any non-negative integer.

To derive equivalent conditions to Equation (5), we de-
ﬁne diagonally permutation operator D acting on a two-
dimensional hyper-matrix(not a hyper-vector), adding two in-
dices of each entry by 1 modulo 4, for example, D(Wi j) =
Wi+1 (mod 4), j+1 (mod 4). With this, we can show that how the
cyclic permutation operator P interacts with convolution.

Lemma 1. Given an input hyper-vector x of size 4 and a square
hyper-matrix W of size 4, we have, P(W ∗ x) = DW ∗ Px.

Proof. For any 1 ≤ j ≤ 4, let y j be the j-th column hyper-vector
of W ∗ x and y(cid:48)
j be the j-th column hyper-vector of DW ∗ Px.
By the deﬁnition of convolution, one has,

P(y j) = y j+1(mod 4)
4(cid:88)

Wi, j+1(mod 4) ∗ xi

Thus, we restrict the hyper-matrix of the ﬁlters in isotonic
layers to be the form in previous theorem. Therefore, an iso-
tonic layers has the desired property, i.e., Equation (5). This
can be easily extended to general cases.

4.4. Decycle layers

After a stacking of isotonic layers, we have learnt a very deep
representation, with the order of cyclic permutations. Thus, the
task of decycle layers is to transform cyclic permutation infor-
mation into rotation equivariant representations. Formally, we
require the following property,

fout(R ◦ Px) = R fout(x),

(7)

where fout is the convolution of a decycle layer. The meaning is
obvious. The cyclic permutation operator is removed, reducing
to rotation equivariance. Similarly, we can derive an equivalent
condition for Wout, the weight of decycle layer. This requires
two fact that, if Wout is a hyper-vector, one has Wout ∗ Px =
P−1Wout ∗ x and R ◦ P = P ◦ R. Thus, the derivation is shown
below,

=

=

=

i=1
4(cid:88)

i=1
4(cid:88)

i=1
= y(cid:48)
j.

Wi+1(mod 4), j+1(mod 4) ∗ xi+1(mod 4)

DWi j ∗ Pxi

Thus, P(W ∗ x) = DW ∗ Px;

By Lemma 1, suppose Whide as the weight of isotonic layer,

one can show that,

fhide(R ◦ Px) = R ◦ P fhide(x)

⇔ Whide ∗ R ◦ Px = R ◦ P(Whide ∗ x)
⇔ Whide ∗ R ◦ Px = R(DWhide ∗ Px)
⇔ Whide ∗ R ◦ Px = D ◦ RWhide ∗ R ◦ Px.

fout(R ◦ Px) = R fout(x)

⇔ Wout ∗ (R ◦ Px) = R(Wout ∗ x)
⇔ Wout ∗ (P ◦ Rx) = RWout ∗ Rx
⇔ P−1Wout ∗ Rx = RWout ∗ Rx.

Since x can be an arbitrary image, one has

Wout = P ◦ RWout.

(8)

is

equivalent

to say that W is of

This
form
[w, Rw, R2w, R3w]. Although it looks similar to that one
in cycle layers, one see that they actually diﬀer by a transpose
operation.

the

Thus, a decycle layer applies ﬁlters of this form, decoding
permutation information into our desired rotation equivariance,
i.e., fout(R ◦ Px) = R fout(x).

Since x can be an arbitrary image, one has,

Whide = D ◦ RWhide.

(6)

tecture and rotation equivariance of DREN, in detail.

In this subsection, we make a careful discussion on the archi-

4.5. Architecture of DREN

By straightforward calculation, we ﬁnd a special class of hyper-
matrices satisfying Equation (6), which yields the following
theorem.

Theorem 1. A hyper-matrix Whide satisﬁes Equation (6), if and
only if it is of the form





C
RB

D
A
B
RD RA
RC
R2C R2D R2A R2B
R3B R3C R3D R3A





,

where A, B, C, D are square ﬁlters of the same size.

4

4.5.1. Framework

In the architecture of DREN, the ﬁrst layer must be a cycle
layer. It is followed by k ≥ 0 consecutive isotonic layers and
one more decycle layer. Then, we claim that the output repre-
sentation of the decycle layer is rotation equivariant, which can
be easily proved by using the Equation (4), (5) and (7) repeatly.
For notational simplicity, we reuse fhide for diﬀerent isotonic
layers. Indeed, one has,

fout f k

hide fin(Rx) = fout f k

hide(R ◦ P fin(x))
hide fin(x))

= fout(R ◦ P f k
= R fout f k

hide fin(x),

(9)

where if we view fout f k
hide fin the representation f , the equality
of two sides is exactly our desired property, i.e., Equation (2).
Note that, at the end of Section 4.1, we have assumed that ni = 1
for 0 ≤ i ≤ k + 1. In fact, this property can be proved for the
general case similarly.

4.5.2. Compatibility

Moreover, adding bias term is allowable, if any channel in a
group share the shared bias value. So do batch normalization
layers with the shared scale and bias parameters. Since ReLU
activation functions are channel indenpendent operation, they
do not have any impact on rotation equivariance, thus compat-
ible with our architecture. So do dropout layers. Moreover,
one can also apply fully connected layers following the decycle
layer.

In addition, we should discuss convolution and pooling lay-
ers with stride > 1. When stride is more than 1, one can observe
that the ﬁlter may not convolve marginal pixels in an image,
thus destroying rotation equivariance. Indeed, suppose the size
of the image is n by n, rotation equivariance can be preserved
iﬀ. n = k · stride + kernelsize for some k ∈ N. The proof is
trivial.

4.5.3. Invariance

Furthermore, the equivariance property can be lifted to in-
variant property in our framework. Simply applying a global
pooling layer[24] in the end of our framework can make output
rotation invariant.

4.6. Memory consumption analysis

Some previous work[10; 20; 25] rotate feature maps to obtain
rotation equivariance. Indeed, one can show that rotating fea-
ture maps correspondingly can yield equivalent results. How-
ever, rotating and buﬀering ﬁlters are more eﬃcient, because
feature maps have much larger size than ﬁlters at most of the
time.

The theoretical analysis of memory usage is based on the
fact that most of popular deep learning frameworks use GEMM
algorithm[26] to compute image convolution. Precisely, feature
maps should be copied k2 times, merged into a single matrix,
then multiplied by weight matrix. Therefore, the total size of
feature maps is clearly much larger than the size of ﬁlters at
most of the time. This indicates that rotating the feature maps
lead to about 4 times more memory cost than rotating the ﬁlters.
The detail memory costs are listed in Table 1.

On the other side, rotating feature maps also costs more time
in rotation operation and copy operation. In Section 5, we give a
detailed comparison on our approach and an architecture using
the strategy of rotating feature maps, proposed by [10].

4.7. Relations to other methods

Since DREN is a general framework, it can be shown that
several existing networks become special cases of our frame-
work.

For instance, if we set all element of the hyper-matrix of a de-
cycle layer to be the identity matrix times a normalizing factor,

Table 1: Memory cost of rotating ﬁlters and feature maps

Method

Mem. cost

Rotate
ﬁlters
4cincoutk2
ncinwh
ncinwhk2

Rotate feature
map
cincoutk2
4ncinwh
4ncinwhk2

Filters
Feature map
Feature map(GPU)
1 Here n, cin, cout, w, h, k denote batch size, input channels, output chan-

nels, width of input, height of input and kernel size, respectively.

the decycle layer becomes cross-channel mean pooling layer
that is used by most of work[6–8].

For isotonic layers, we can set Whide to a diagonal form, i.e.,
all of ﬁlters other than those on the diagonal of hyper-matrix to
be zero matrices. In other words, this means that all of feature
maps would be convolved by rotated copies of a single ﬁlter,
which is utilized by [10; 19; 25].

Moreover, the last decycle layer can be replaced by a cross-
channel max pooling layer. Although it is not a decycle layer
in nature, the cross-channel max pooling layer satisﬁes Equa-
tion (7) as well. Actually other layers that satisfy Equation (7),
such as cross-channel root-mean-square(RMS) layer, can also
be applied to replace the decycle layer and to preserve rotation
equivariance as well.

Finally, we claim that our approach yields the equivalent re-
sult to that of [10] when the proposed layers are carefully used.
Note that, by convolutional distributive law, for any ﬁlter W
and any feature map x, R(W ∗ x) = R(W) ∗ R(x). Then we can
derive that the cyclic slice layer[10] followed by an ordinary
convolutional layer equals to the cycle layer; the cyclic roll
layer[10] followed by an ordinary convolutional layer equals
to the isotonic layer; the cyclic pooling[10] is actually cross-
channel pooling which is a special case of the decycle layer;
the cyclic stack layer[10] followed by an ordinary convolutional
layer equals to the isotonic layer whose weight hyper-matrix
Whide is a diagonal matrix. In fact, DREN operates on ﬁlters
rather than feature maps, reducing about half of running time
with less memory overhead compared with that of [10]

5. Experiments

In this section, we evaluate our framework on two datasets,
Rotated MNIST and CIFAR-10. All of the experiments are pub-
lished on GitHub1.

5.1. Rotated MNIST

First, we evaluate on Rotated MNIST dataset[27]. It is the
rotated version of MNIST dataset[28], with digits being rotated
for a degree uniformly drawn from [0, 2π]. In total, it contains
62000 handwritting digit images, among which there are 10000
images for training, 2000 for validating and 50000 for testing.
We choose the Z2CNN(refer to [6]) as our baseline, which
consists of 7 convolutional layers of kernel size 3×3(4×4 in the

1https://github.com/microljy/DREN_Tensorflow

5

last layer). Each layer of Z2CNN has 20 channels, followed by
a ReLU activation layer, a dropout layer, a batch normalization
layer. Besides, a max pooling layer is applied right after the
second layer.

We replace the ﬁrst layer and the last layer of the baseline
network by a cycle layer and a decycle layer, respectively. Be-
sides, the intermediate layers are replaced by isotonic layers.
Moreover, since that our proposed layers can reduce the num-
ber of parameters fourfold, we double the number of channels
in each layers to keep the number of parameters approximately
ﬁxed.

Table 2 lists our results. This architecture(DREN) is found
to achieve high accuracy with a small number of params. We
also try to replace the decycle layer in DREN with a isotonic
layer followed by a cross-channel max pooling layer. This net-
work(DRENMaxPoolling) have 25k params., which is 24% less
than that of H-Net[22], and equal to that of P4CNN[6] and
Dieleman et al.[10]. DRENMaxPoolling outperforms all the
previous models without more params.. In addition, our archi-
tecture can reduce about half of running time with less memory
overhead compared with Dieleman et al.[10], this would be fur-
ther discussed in Section 5.4.

Table 2: Performance of various models on Rotated MNIST.

Model
SVM[27]
Transformation RBM[29]
Conv-RBM[13]
Z2CNN[6]
P4CNN[6]
H-Net[22]
Dieleman et al.[10]
DREN
DRENMaxPoolling

Error
11.11%
4.2%
3.98%
5.03%
2.28%
1.69%
1.78%
1.78%
1.56%

Param.
-
-
-
22k
25k
33k
25k
22k
25k

5.2. CIFAR-10

We also evaluate our framework on CIFAR-10[30], a real-
world dataset that does not have rotational symmetry in na-
ture.
It consists of 50000 training and 10000 testing images
uniformly drawn from 10 classes. Each one has RGB chan-
nels of size 32 × 32. For this dataset, we apply global contrast
normalization to preprocess the data, as was used by [31].

We test our framework on Network in Network(NIN)[24]
and Resnet-20[5]. First, we replace the ordinary convolu-
tional layers of these models by our proposed layers, see r-
NIN(conv1-4), r-Resnet-20(conv1-13), where conv1-k means
that the ﬁrst k layers are replaced by our proposed layers. Since
our proposed layers only need a quarter of the number of pa-
rameters in each layer, we also evaluate r-NIN(conv1-4)×4 and
r-Resnet-20(conv1-13)×4, where the number of channels of the
ﬁrst 4 layers are doubled to keep the total number of parameters

6

Table 3: Performance of various models on CIFAR-10.

Error
10.41%
9.4%
9.8%
9.0%
9.00%
8.51%
7.17%

Model
NIN[24]
NIN*
r-NIN(conv1-4)
r-NIN(conv1-4)×4
Resnet-20[5]
r-Resnet-20(conv1-13)
r-Resnet-20(conv1-13)×4
1 * means our implementation.
2 conv1-k means 1-k layers are replaced by our proposed layers
3 r− means the model utilizes rotation equivariant layers.
4 ×4 means the number of channels of proposed layers are doubled.

Params.
967k
967k
576k
958k
297k
245k
297k

Rotated MNIST

CIFAR-10

r-Z2CNN
r-Z2CNN×4

r-NIN
r-NIN×4

)

%

(
r
o
r
r
e

t
s
e
T

6

5

4

3

2

)

%

(
r
o
r
r
e

t
s
e
T

16

14

12

10

8

base 1-2

1-3

1-4

1-5

1-6

1-7

base 1-2

1-3

1-4

1-5

1-6

1-7

Figure 3: Classiﬁcation error of models with diﬀerent numbers of our pro-
posed layers: The left one is the results on Rotated MNIST and the right one
is that on CIFAR-10. The horizontal axis shows the number of our proposed
layers applied. It turns out that, for datasets which has rotation symmetry in na-
ture(Rotated MNIST), applying more isotonic layers yields better classiﬁcation
accuracy. We argue that higher level rotation equivariant representations learnt
by stacking more isotonic layers improves the classiﬁcation accuracy on such
dataset. However, for CIFAR-10, the circumstance changes. Applying 4 or 5
isotonic layers achieves the best performance. We argue that higher level rota-
tion equivariant representations are not helpful on such dataset without rotation
symmetry, and applying more isotonic layers reduces the number of parame-
ters(model complexity) fourfold, therefore leading to severe underﬁtting. ×4
means the model with doubled number of channels.

unchanged. The results are shown in Table 3. It shows that our
model(r-NIN(conv1-4)×4 and r-Resnet-20(conv1-13)×4) can
outperform the baseline with roughly the same number of pa-
rameters. In this experiment, we do not replace all of the con-
volution layers with our proposed layers, since we observe that
simply replacing all layers cannot achieve the best performance.
This would be discussed in the next subsection.

5.3. How many isotonic layers should be applied?

The only hyperparameter of our framework is the number
of isotonic layers used. Thus, in this subsection, we study the
performance of DRENs with diﬀerent numbers of isotonic lay-
ers in the following experiments. We also choose two base-
lines above, evaluate them on Rotated MNIST and CIFAR-10
respectively, and gradually integrate more isotonic layers into
baselines(e. g., conv1-2, conv1-3, conv1-4, etc.).

The results are shown in Figure 3. We observe two quite dis-
tinct trends in the two datasets. For Rotated MNIST which has
rotation symmetry in nature, the more isotonic layers we use,
the better performance the model achieves, even with less and
less number of parameters. However, for CIFAR-10, r-NINs

Figure 4: The representations in the last convolutional layer learnt by NIN[24], H-Net[22], P4-ALL-CNN-C[6] and DREN. The two columns correspond
to the representations of an image of automobile(left) and an image of truck(right). Inside one of the 8 pictures, the leftmost column contains the rotated input
images while the remaining 10 columns contain the 10 feature maps in the last convolutional layers, which corresponds to the 10 classes of CIFAR-10. We slightly
modify the architecture of H-Net to ensure that a global average pooling layer is used right after the last convolutional layer. The other three networks also apply
this structure. Thus, the predictions of the networks are exactly the class whose related representation attains maximum density. We mark the maximal one(the
prediction) with a red square. It turns out that when the input is rotated, NIN yields entirely diﬀerent representations, leading to wrong predictions. For H-Net and
P4-ALL-CNN-C, the representations are partly equivariant to rotation. However, H-Net still predicts incorrectly, when the image of automobile is rotated. In fact,
only the representations of DREN are exactly equivariant to rotation, and thus the predictions of DREN are consistent, when the input is rotated. Moreover, we ﬁnd
our leanrt representations for automobile and for truck are very similar while that of other models are not. This shows that the representations learnt by DREN are
similar for semantically similar objects, which indicates the reasonability of adding rotation equivariant constraint.

7

achieve best performance when using two isotonic layers(i.e.,
replace 4 convolutional layers).

running time of the ordinary CNN, since the ﬁlters can be ro-
tated and stored before running.

Because CIFAR-10 does not have deep rotation symmetry,
intuitively, most eﬀective latent representations maybe be not
rotation equivariant. Thus, using too much isotonic layers pre-
vents the network from learning such representations. This is
one of the reason why our framework cannot achieve better
performance with more isotonic layers. Another cause may
be that the number of parameters(i.e., model complexity) de-
creases with more isotonic layers used, thus leading to a under-
ﬁtting model.

The other extreme case that very a few isotonic layers are ap-
plied, also results in bad results. According to Figure 3, our
models(r-Z2CNN,r-NIN,r-NIN×4) underperform the baseline
when less than two isotonic layers are applied. This observa-
tion actually meets with the argument we pose in Section 1,
that the networks with a few or none isotonic layer can only
learn shallow and trivial rotation equivariant representations.

5.4. Running time of rotating ﬁlters and feature maps

In order to compare the running time costs between rotating
feature maps and rotating ﬁlters, we evaluate both methods on
Rotated MNIST dataset. We take the implementation presented
by [10] as the representative of the methods that rotate feature
maps. Since there are some diﬀerence between their framework
and ours, we make minor modiﬁcation on both frameworks to
ensure that the comparison is a fair play. The decycle layer is
replaced with a cross-channel mean-pooling layer in our frame-
work, and the cyclic roll operation is applied before every con-
volution layer except the ﬁrst one in their frameworks.

The running time of rotating ﬁlters and feature maps are
shown in Table 4. Both implementations run on Intel core
i7-5930K processors(3.50GHz) and GeForce GTX 1080 with
NVIDIA CUDA 8.0 and cuDNN 5. Since all models are im-
plemented with Theano that automatically free memory using a
reference count system, we cannot exactly determine memory
consumption. Thus, only running time is listed.

Table 4: Running time of two implementations.

Implementation

Setting

Rotate ﬁlters

Rotate feature maps[10]

Model

Z2CNN

NIN

Z2CNN

NIN

Batch size
64
128
64
128
64
128
64
128

Time

1.97s
1.44s
11.00s
9.52s
4.15s
3.74s
22.13s
18.73s

1 The time cost is the testing time of testing 50k images.
Table 4 shows that our implementation based on rotating ﬁl-
ters are twice as fast as the implementation based on rotating
feature maps[10; 20; 25]. In fact, the running time of the im-
plementation based on rotating ﬁlters can be the same as the

8

5.5. Visualization of DREN

Since deep rotation equivariant representations can be learnt
from our framework, we are concerned with how such represen-
tations diﬀer from ordinary representation of a typical CNN and
other rotation equivariance structures. To this end, we visual-
ized the representations produced by NIN[24], P4-ALL-CNN-
C[6], H-Net[22] and DREN trained on CIFAR-10. We slight
modify the architecture of H-Net to a global average pooling
manner that are used by the other three models in order for fair
comparison and clear visualization. In detail, we apply global
average pooling layer rather than fully connected layer in above
models. This indicates that the feature maps in the last convo-
lutional layers are the conﬁdence maps of the categories in fact.
Such feature maps of four models are shown in Figure 4. In
each picture, there are 11 columns. The leftmost one is the in-
put image while the remaining ones are the feature maps in the
last convolutional layer, each one corresponding to a class of
CIFAR-10. In each row, we mark the predictions of the net-
works(i.e., the one with maximal density) with red squares.

It turns out that when the input is rotated, NIN yields entirely
diﬀerent representations, leading to wrong predictions. For H-
Net and P4-ALL-CNN-C, the representations are partly equiv-
ariant to rotation. However, H-Net still predicts incorrectly,
when the image of automobile is rotated. In fact, only the rep-
resentations of DREN are exactly equivariant to rotation, and
thus the predictions of DREN are consistent when the input is
rotated.

Moreover, we ﬁnd our leanrt representations for automobile
and for truck are very similar while that of other models are not.
This shows that the representations learnt by DREN are similar
for semantically similar objects, which indicates the reasonabil-
ity of adding rotation equivariant constraint.

6. Conclusion & Discussion

We propose a novel CNN framework, DREN, which can
learn deep rotation equivariant representations from images.
Theoretical guarantee is provided that the features are rota-
tion equivariant to rotation of degree kπ/2 for k ∈ Z and ex-
periment results show that our framework can also deal with
other degrees. We evaluate our framework on Rotated MNIST
and CIFAR-10 datasets, outperforming several state-of-the-art
CNN architectures. In addition, our implementation of rotating
ﬁlters costs only a half time of feeding forward comparing to
the methods which rotate feature maps.

As a future direction, we suggest to settle the cases of rotation
of general degree. Although our framework mainly deals with
rotation of degree kπ/2 for k ∈ Z, it can be easily generalized
to any ﬁnte group of rotation transformations, if there is an eﬃ-
cient way to perform rotations of any degree on ﬁlters. In short,
our approach is a tradeoﬀ between eﬃciency and performance.
For another direction, we would like to design new types
of convolutional layers to implement equivariance with respect

[20] S. Dieleman, K. W. Willett, J. Dambre, Rotation-invariant convolutional
neural networks for galaxy morphology prediction, Monthly notices of
the royal astronomical society 450 (2) (2015) 1441–1459.

[21] R. Gens, P. M. Domingos, Deep symmetry networks, in: Advances in

neural information processing systems, 2014, pp. 2537–2545.

[22] D. E. Worrall, S. J. Garbin, D. Turmukhambetov, G. J. Brostow, Harmonic
networks: Deep translation and rotation equivariance, arXiv preprint
arXiv:1612.04642.

[23] D. M. Gonzalez, M. Volpi, D. Tuia, Learning rotation invariant convolu-

tional ﬁlters for texture classiﬁcation, CoRR abs/1604.06720.

[24] M. Lin, Q. Chen, S. Yan, Network in network, in: In Proc. ICLR, 2014.
[25] D. Laptev, N. Savinov, J. M. Buhmann, M. Pollefeys, Ti-pooling:
transformation-invariant pooling for feature learning in convolutional
neural networks, arXiv preprint arXiv:1604.06318.

[26] V. Volkov, J. W. Demmel, Benchmarking gpus to tune dense linear alge-
bra, in: High Performance Computing, Networking, Storage and Analy-
sis, 2008. SC 2008. International Conference for, IEEE, 2008, pp. 1–11.
[27] H. Larochelle, D. Erhan, A. Courville, J. Bergstra, Y. Bengio, An em-
pirical evaluation of deep architectures on problems with many factors
of variation, in: Proceedings of the 24th international conference on Ma-
chine learning, ACM, 2007, pp. 473–480.

[28] Y. LeCun, L. Bottou, Y. Bengio, P. Haﬀner, Gradient-based learning ap-
plied to document recognition, Proceedings of the IEEE 86 (11) (1998)
2278–2324.

[29] K. Sohn, H. Lee, Learning invariant representations with local transfor-

mations, arXiv preprint arXiv:1206.6418.

[30] A. Krizhevsky, G. Hinton, Learning multiple layers of features from tiny

images.

[31] I. Goodfellow, D. Warde-Farley, M. Mirza, A. Courville, Y. Bengio, Max-
out networks, in: Proceedings of The 30th International Conference on
Machine Learning, 2013, pp. 1319–1327.

to scale transformations and more generally, aﬃne transforma-
tions. These may improve the performance of CNNs further.

References

References

[1] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan,
V. Vanhoucke, A. Rabinovich, Going deeper with convolutions, in: Pro-
ceedings of the IEEE Conference on Computer Vision and Pattern Recog-
nition, 2015, pp. 1–9.

[2] R. Girshick, J. Donahue, T. Darrell, J. Malik, Rich feature hierarchies for
accurate object detection and semantic segmentation, in: Proceedings of
the IEEE conference on computer vision and pattern recognition, 2014,
pp. 580–587.

[3] A. Krizhevsky, I. Sutskever, G. E. Hinton, Imagenet classiﬁcation with
deep convolutional neural networks, in: Advances in neural information
processing systems, 2012, pp. 1097–1105.

[4] K. Simonyan, A. Zisserman, Very deep convolutional networks for large-

scale image recognition, arXiv preprint arXiv:1409.1556.

[5] K. He, X. Zhang, S. Ren, J. Sun, Deep residual learning for image recog-
nition, in: Proceedings of the IEEE conference on computer vision and
pattern recognition, 2016, pp. 770–778.

[6] T. Cohen, M. Welling, Group equivariant convolutional networks, in:
Proceedings of the 33nd International Conference on Machine Learn-
ing, ICML 2016, New York City, NY, USA, June 19-24, 2016, 2016,
pp. 2990–2999.

[7] F. Wu, P. Hu, D. Kong, Flip-rotate-pooling convolution and split dropout
on convolution neural networks for image classiﬁcation, arXiv preprint
arXiv:1507.08754.

[8] D. Marcos, M. Volpi, D. Tuia, Learning rotation invariant convolutional
ﬁlters for texture classiﬁcation, in: Pattern Recognition (ICPR), 2016
23rd International Conference on, IEEE, 2016, pp. 2012–2017.

[9] D. Teney, M. Hebert, Learning to extract motion from videos in convolu-

tional neural networks, arXiv preprint arXiv:1601.07532.

[10] S. Dieleman, J. D. Fauw, K. Kavukcuoglu, Exploiting cyclic symmetry in
convolutional neural networks, in: Proceedings of the 33nd International
Conference on Machine Learning, ICML 2016, New York City, NY, USA,
June 19-24, 2016, 2016, pp. 1889–1898.

[11] K. Kavukcuoglu, R. Fergus, Y. LeCun, et al., Learning invariant features
through topographic ﬁlter maps, in: Computer Vision and Pattern Recog-
nition, 2009. CVPR 2009. IEEE Conference on, IEEE, 2009, pp. 1605–
1612.

[12] M. Norouzi, M. Ranjbar, G. Mori, Stacks of convolutional restricted
boltzmann machines for shift-invariant feature learning, in: Computer Vi-
sion and Pattern Recognition, 2009. CVPR 2009. IEEE Conference on,
IEEE, 2009, pp. 2735–2742.

[13] U. Schmidt, S. Roth, Learning rotation-aware features: From invariant
priors to equivariant descriptors, in: Computer Vision and Pattern Recog-
nition (CVPR), 2012 IEEE Conference on, IEEE, 2012, pp. 2050–2057.
[14] H. Lee, R. Grosse, R. Ranganath, A. Y. Ng, Convolutional deep belief net-
works for scalable unsupervised learning of hierarchical representations,
in: Proceedings of the 26th annual international conference on machine
learning, ACM, 2009, pp. 609–616.

[15] J. Yu, C. Hong, Y. Rui, D. Tao, Multi-task autoencoder model for recov-
ering human poses, IEEE Transactions on Industrial Electronics PP (99)
(2017) 1–1.

[16] J. Yu, B. Zhang, Z. Kuang, D. Lin, J. Fan, iprivacy: image privacy pro-
tection by identifying sensitive objects via deep multi-task learning, IEEE
Transactions on Information Forensics and Security 12 (5) (2017) 1005–
1016.

[17] J. Zhang, K. Li, Y. Liang, N. Li, Learning 3d faces from 2d images via

stacked contractive autoencoder , Neurocomputing 257 (2017) 67–78.

[18] K. Grzegorczyk, M. Kurdziel, P. I. W´ojcik, Encouraging orthogonality
between weight vectors in pretrained deep neural networks, Neurocom-
puting 202 (2016) 84–90.

[19] B. Fasel, D. Gatica-Perez, Rotation-invariant neoperceptron, in: 18th In-
ternational Conference on Pattern Recognition (ICPR’06), Vol. 3, IEEE,
2006, pp. 336–339.

9

Deep Rotation Equivariant Network

Junying Lia, Zichen Yangb, Haifeng Liub, Deng Caia,∗

aThe State Key Laboratory of CAD&CG, College of Computer Science, Zhejiang University, China
bCollege of Computer Science, Zhejiang University, China

8
1
0
2
 
b
e
F
 
8
2
 
 
]

V
C
.
s
c
[
 
 
2
v
3
2
6
8
0
.
5
0
7
1
:
v
i
X
r
a

Abstract

introduce four op-
Recently, learning equivariant representations has attracted considerable research attention. Dieleman et al.
erations which can be inserted into convolutional neural network to learn deep representations equivariant to rotation. However,
feature maps should be copied and rotated four times in each layer in their approach, which causes much running time and memory
overhead. In order to address this problem, we propose Deep Rotation Equivariant Network consisting of cycle layers, isotonic
layers and decycle layers. Our proposed layers apply rotation transformation on ﬁlters rather than feature maps, achieving a speed
up of more than 2 times with even less memory overhead. We evaluate DRENs on Rotated MNIST and CIFAR-10 datasets and
demonstrate that it can improve the performance of state-of-the-art architectures.

Keywords: Neural network, Rotation equivariance, Deep learning

1. Introduction

Convolutional neural networks(CNNs) recently have made
great success in computer vision tasks[1–5]. One of the rea-
sons to its success is that weight sharing of convolution layers
ensures the learnt representations are translation equivariant[6],
i.e., shifting an image and then feeding it through the network
is the same as feeding the original image and then shifting the
resulting representations.

However, CNNs fail to exploit rotation equivariance to tackle
vision problems on datasets with rotation symmetry in nature,
especially microscopic images or aerial images, which can be
photographed from any angle. Thus, current studies focus on
dealing with this issue.

One widely used method to achieve rotation equivariance is
to constrain the ﬁlters of the ﬁrst convolutional layer to be ro-
tated copies of each other, and then apply cross-channel pooling
immediately after the ﬁrst layer[7–9]. However, only shallow
representations equivariant to rotation can be learnt by apply-
ing one convolutional layer. In addition, such representations
are nearly trivial, since pooling rotated copies is approximately
equivalent to convolving non-rotated inputs with highly sym-
metric ﬁlters.

To solve this problem, [10] introduces four operations which
can be combined to make these models able to learn deep repre-
sentations equivariant to rotation. However, every feature map
should be copied and rotated by these operations four times,
which causes high memory and running time overhead.

In this paper, we give a comprehensive theoretical study
on approaches to rotation equivariance with CNNs. We pro-

∗Corresponding author
Email addresses: microljy@zju.edu.cn (Junying Li),

zichenyang.math@gmail.com (Zichen Yang), haifengliu@zju.edu.cn
(Haifeng Liu), dengcai@gmail.com (Deng Cai)

pose a novel CNN framework, Deep Rotation Equivariant Net-
work(DREN) to obtain deep equivariance representations. We
prove that DREN can achieve the identical output to that of [10]
with much less running time and memory requirements.

We evaluate our framework on two datasets, Rotated MNIST
and CIFAR-10. On Rotated MNIST, it can outperform the ex-
isting methods with less number of parameters. On CIFAR-
10, it can improve the results of state-of-the-art models with
the same number of parameters. Moreover, our implementation
achieves a speed up of more than 2 times as that of [10], with
even less memory overhead.

2. Related Works

Learning invariant representations by neural networks has
been studied for over a decade. Early works focus on reﬁne-
ment of restricted Boltzmann machines(RBMs) and deep belief
nets(DBNs).
[11] gives an approach to automatically gener-
ate topographic maps of similar ﬁlters in an unsupervised man-
ner and these ﬁlters can produce local invariance when being
pooled together.
[12] develops convolutional RBM(c-RBM),
using weight sharing to achieve shift-invariance. Later, a fol-
lowing work by [13] incorporates linear transformation invari-
ance into c-RBMs, yielding features that have a notion of trans-
formation performed. The model proposed by [14] uses a prob-
abilistic max-pooling layer to support eﬃcient probabilistic in-
ference, which also shows the property of translation invari-
ance.

Recently, convolutional neural networks have become the
most popular models in various computer vision tasks[15–18].
One of the advantages of CNNs is its translation equivariant
property provided by weight sharing[6]. However, it cannot
deal with rotation transformation of input images. Thus, many
variants of CNNs have been proposed to settle these problems.

Preprint submitted to Elsevier

March 1, 2018

Basically, the idea of most of the related works[9; 19; 20] is
to stack rotated copies of images or features to obtain rotation
equivariance.

There are also other methods. [21] propose deep symmetry
networks that can form feature maps over arbitrary transforma-
tion groups approximately. Methods proposed by [7; 8] show
that rotation convolution layers followed by a cross-channel
pooling over rotations could achieve rotation equivariance. In
fact, none of the directional features could be extracted by these
methods, since pooling is applied right after one rotation con-
volution.
[6] propose a group action equivariant framework
by stacking group acted convolution and provide a theoreti-
cally grounded formalism to exploit symmetries of CNNs. [22]
present harmonic networks, a CNN structure exhibits equivari-
ance to patch-wise translation and 360-rotation. Recently, the
vector ﬁeld network proposed by [23] applies interpolation to
deal with rotation of general degrees.

[10] introduces four operations to encode rotation symmetry
into feature maps to build a rotation equivariant neural network.
However, feature maps should be rotated each time to ensure
equivariance, which obviously costs much time and memory.
Our approach presents a diﬀerent way to overcome this issue
by rotating ﬁlters, which brings about exactly the same results,
but in a more eﬃcient way.

3. Equivariance and invariance

In this section, we brieﬂy discuss the notions of equivariance
and invariance of image representations. Formally, a represen-
tation of a CNN can be regarded as a function f mapping from
image spaces to feature spaces.

We say, a representation f is equivariant to a family T of
transformations on image spaces, if for any transformation T ∈
T, there exists a corresponding transformation T (cid:48) on feature
spaces, such that

f (T x) = T (cid:48) f (x),

(1)

for any input images x. Intuitively, this means that the learnt
representation f of CNNs changes in an expected way, when
the input image is transformed.

There is another stronger case when T (cid:48) is the identity map,
i.e., the map ﬁxing the inputs, for all T ∈ T. This indicates that
the representations remain unchanged no matter how the input
data is transformed by transformations in T, i.e., the represen-
tation is invariant. Invariance is an ideal property of represen-
tation, because a good object classiﬁer must output an invariant
class label no matter what location of the object lies in.

The goal of this paper is to present a novel convolutional neu-
ral network framework, which learns representations that are
equivariant to rotation transformations R, s. t. R(cid:48) = R, that is

f (Rx) = R f (x),

(2)

for any input image x. Figure 1 gives an example of rotation
equivalent representations learnt by DREN, comparing to a tra-
ditional CNN. The reason that we do not directly work on rota-
tion invariant representations is that this kind of rotation equiv-
ariance can be easily lifted to rotation invariance, for instance,

Figure 1: Latent representations learnt by a CNN and a DREN(Proposed),
where R stands for clockwise rotation. The left part is the result of a typical
CNN while the right one is that of a DREN. In both parts, the outer cycles
consist of the rotated images while the inner cycles consist of the learnt repre-
sentations. Features produced by a DREN is equivariant to rotation while that
produced by a typical CNN is not.

by a global pooling operation[24], i.e., the kernel size of this
pooling layer is equal to the size of feature maps.

Since these are the only four kinds of possible rotation of an
image that can be performed without interpolations, we mainly
deal with the rotation transformation family R = {Rθ|θ =
kπ/2, k ∈ Z}. However, our experimental results show that our
framework can achieve good performance when dealing with
rotation for general degrees.

4. Rotation equivariant convolution

In this section, we deﬁne three novel types of convolutional
layers, which are combined to learn rotation equivariant fea-
tures.

4.1. Preliminaries

For the sake of simplicity, we omit bias terms, activation
functions and other structures, concentrating on convolution. In
addition, we set the stride of any convolution layer be 1. The
general case will be discussed in Section 4.5.

First, we vectorize convolution operation formally to sim-
plify our derivation. Shortly, we shall use matrix multiplication
to describe multi-channel convolution. Let us assume that the
input of a convolutional layer contains n feature maps(images)
{x j}n
j=1. This layer has mn ﬁlters, denoted by Wi j with 1 ≤ i ≤
m, 1 ≤ j ≤ n. These can be organized as a matrix(vector) x of
size n and a matrix W of size m, n in which entries are ﬁlters
or feature maps. We refer to such a matrix(vector) a hyper-
matrix(hyper-vector). Then, the convolution W ∗ x is deﬁned to
be a hyper-vector of size m whose i-th entry is,

(cid:88)

1≤ j≤n

Wi j ∗ x j,

(3)

for each 1 ≤ i ≤ m. One can verify that this is actually equiva-
lent to ordinary multi-channel convolution.

Next, we introduce the rotation operator R, rotating a ﬁlter
or a feature map by a degree of π/2 counterclockwise. We also

2

Figure 2: The framework of Deep Rotation Equivariant Network. The gray panels represent input, feature maps and output. Each square represents a weight
kernel. The letter ’T’ is utilized for distinguishing orientation clearly. The diﬀerent colors of kernel background indicate that the kernel are not qualitatively
equivalent. Although this ﬁgure seems similar to that one in [10], there are 3 critical diﬀerences: 1. We apply rotation on the ﬁlters rather than the feature maps. 2.
The matrix in an isotonic layer is diﬀerent in order from the matrix of cyclic rolling operation in [10]. 3. The decycle layer is a special convolution layer, diﬀerent
from the cyclic pooling applied in [10].

deﬁne the action of R on a hyper-matrix W. R(W) is deﬁned to
be entrywise rotation. There are three obvious facts about the
rotation operator that are frequently used in the sequel.

1. Convolutionally distributive law: R(W ∗ x) = R(W) ∗ R(x).
This indicates that rotating ﬁlters and feature maps simu-
taneously before convolution yields rotated outputs.
2. Additively distributive law: R(X1 + X2) = R(X1) + R(X2).

Note that + is entrywise addition of matrices.

3. Cyclic law: R4 is equal to the identity transformation.

In our framework, we propose three new types of convolu-
tion layers to implement rotation equivariance. Given an im-
age, a cycle layer transforms this image into n0 groups, each
containing 4 feature maps. Then, one can apply k isotonic lay-
ers consecutively to learn deeper representations. Suppose that
the output of the i-th isotonic layer consists of ni groups with
1 ≤ i ≤ k, each containing 4 feature maps as well. Finally,
a decycle layer applies a convolution to merge feature maps,
resulting in nk+1 rotation equivariant feature maps.

Informally, the utility of the cycle layers is to transform rota-
tion of images into cyclic permutations of feature maps in each
group. Then, the isotonic layers are used to preserve the or-
der of permutations in each group. Finally, the decycle layer
decodes permutations in each group to produce rotation equiv-
ariant representations.

In the following discussion, assume that the number of
groups ni = 1 for any 0 ≤ i ≤ k + 1 . The general case will
be discuss in Section 4.5

4.2. Cycle layers

The basic idea of cycle layers is to stack rotated copies of
the ﬁlters. By assumption, the hyper-matrix of the ﬁlters Win in
a cycle layer contains 4 ﬁlters, say Win = [w, Rw, R2w, R3w]T .
Given an input image x, by the deﬁnition of convolution, the
output is

fin(x) = Win ∗ x

= [w ∗ x, Rw ∗ x, R2w ∗ x, R3w ∗ x]T .

Next, we shall derive the relation between cycle layers and rota-
tion operators. Before it, we have to deﬁne a cyclic permutation
operator P acting on a hyper-vector, adding the index of each
entry by 1. Note that if the added index is 4, we reset it to
1. For instance, P(x2) = x3, P(x4) = x1. This description is
similar to the modular operation, thus we refer this operation
addition modulo 4, denoted by x + 1 (mod 4).

When a rotated image Rx is fed into a cycle layer, the output

becomes

fin(Rx) = Win ∗ Rx

= [w ∗ Rx, Rw ∗ Rx, R2w ∗ Rx, R3w ∗ Rx]T
= R[R3w ∗ x, w ∗ x, Rw ∗ x, R2w ∗ x]T
= R ◦ P(Win ∗ x) = R ◦ P fin(x),

(4)

where the third equality follows from the cyclic law and the
convolutional distributive law. This indicates that given a ro-
tated image, the output fin(Rx) of a cycle layer is the same as
fin(x) up to a permutation and a rotation. Hence, the rotation of
images is transformed into the order of cyclic permutation.

Although, cycle layers cannot produce rotation equivariance,
one can immediately obtain it by a following cross-channel
pooling operation. In this case, this operation produces a fea-
ture map by taking average or pixelwise maximum of the four
rotated feature maps. But this is equivalent to use a highly sym-
metric ﬁlter, which generates nearly trivial features. Hence, we
propose isotonic layers to replace it.

4.3. Isotonic layers

To produce non-trivial feature maps, a straightforward way is
stacking more convolutional layers. However, one sees that an
ordinary convolution operation will destroy the order of cyclic
permutations produced by the cyclic layer. Consequently, we
have to study that under what conditions, convolution can pre-
serve the order of cyclic permutations. Mathematically, we can
formulate this idea by the following equation,
fhide(R ◦ Px) = R ◦ P fhide(x),

(5)

3

where fhide stands for the convolution performed by an isotonic
layer. Intuitively, this means that feeding permuted rotated in-
puts, an isotonic layers yields the equivariant permuted rotated
feature maps, hence preserving the order of cyclic permutation.
By induction, one sees that a stacking of h isotonic layers share
the same property, where h is any non-negative integer.

To derive equivalent conditions to Equation (5), we de-
ﬁne diagonally permutation operator D acting on a two-
dimensional hyper-matrix(not a hyper-vector), adding two in-
dices of each entry by 1 modulo 4, for example, D(Wi j) =
Wi+1 (mod 4), j+1 (mod 4). With this, we can show that how the
cyclic permutation operator P interacts with convolution.

Lemma 1. Given an input hyper-vector x of size 4 and a square
hyper-matrix W of size 4, we have, P(W ∗ x) = DW ∗ Px.

Proof. For any 1 ≤ j ≤ 4, let y j be the j-th column hyper-vector
of W ∗ x and y(cid:48)
j be the j-th column hyper-vector of DW ∗ Px.
By the deﬁnition of convolution, one has,

P(y j) = y j+1(mod 4)
4(cid:88)

Wi, j+1(mod 4) ∗ xi

Thus, we restrict the hyper-matrix of the ﬁlters in isotonic
layers to be the form in previous theorem. Therefore, an iso-
tonic layers has the desired property, i.e., Equation (5). This
can be easily extended to general cases.

4.4. Decycle layers

After a stacking of isotonic layers, we have learnt a very deep
representation, with the order of cyclic permutations. Thus, the
task of decycle layers is to transform cyclic permutation infor-
mation into rotation equivariant representations. Formally, we
require the following property,

fout(R ◦ Px) = R fout(x),

(7)

where fout is the convolution of a decycle layer. The meaning is
obvious. The cyclic permutation operator is removed, reducing
to rotation equivariance. Similarly, we can derive an equivalent
condition for Wout, the weight of decycle layer. This requires
two fact that, if Wout is a hyper-vector, one has Wout ∗ Px =
P−1Wout ∗ x and R ◦ P = P ◦ R. Thus, the derivation is shown
below,

=

=

=

i=1
4(cid:88)

i=1
4(cid:88)

i=1
= y(cid:48)
j.

Wi+1(mod 4), j+1(mod 4) ∗ xi+1(mod 4)

DWi j ∗ Pxi

Thus, P(W ∗ x) = DW ∗ Px;

By Lemma 1, suppose Whide as the weight of isotonic layer,

one can show that,

fhide(R ◦ Px) = R ◦ P fhide(x)

⇔ Whide ∗ R ◦ Px = R ◦ P(Whide ∗ x)
⇔ Whide ∗ R ◦ Px = R(DWhide ∗ Px)
⇔ Whide ∗ R ◦ Px = D ◦ RWhide ∗ R ◦ Px.

fout(R ◦ Px) = R fout(x)

⇔ Wout ∗ (R ◦ Px) = R(Wout ∗ x)
⇔ Wout ∗ (P ◦ Rx) = RWout ∗ Rx
⇔ P−1Wout ∗ Rx = RWout ∗ Rx.

Since x can be an arbitrary image, one has

Wout = P ◦ RWout.

(8)

is

equivalent

to say that W is of

This
form
[w, Rw, R2w, R3w]. Although it looks similar to that one
in cycle layers, one see that they actually diﬀer by a transpose
operation.

the

Thus, a decycle layer applies ﬁlters of this form, decoding
permutation information into our desired rotation equivariance,
i.e., fout(R ◦ Px) = R fout(x).

Since x can be an arbitrary image, one has,

Whide = D ◦ RWhide.

(6)

tecture and rotation equivariance of DREN, in detail.

In this subsection, we make a careful discussion on the archi-

4.5. Architecture of DREN

By straightforward calculation, we ﬁnd a special class of hyper-
matrices satisfying Equation (6), which yields the following
theorem.

Theorem 1. A hyper-matrix Whide satisﬁes Equation (6), if and
only if it is of the form





C
RB

D
A
B
RD RA
RC
R2C R2D R2A R2B
R3B R3C R3D R3A





,

where A, B, C, D are square ﬁlters of the same size.

4

4.5.1. Framework

In the architecture of DREN, the ﬁrst layer must be a cycle
layer. It is followed by k ≥ 0 consecutive isotonic layers and
one more decycle layer. Then, we claim that the output repre-
sentation of the decycle layer is rotation equivariant, which can
be easily proved by using the Equation (4), (5) and (7) repeatly.
For notational simplicity, we reuse fhide for diﬀerent isotonic
layers. Indeed, one has,

fout f k

hide fin(Rx) = fout f k

hide(R ◦ P fin(x))
hide fin(x))

= fout(R ◦ P f k
= R fout f k

hide fin(x),

(9)

where if we view fout f k
hide fin the representation f , the equality
of two sides is exactly our desired property, i.e., Equation (2).
Note that, at the end of Section 4.1, we have assumed that ni = 1
for 0 ≤ i ≤ k + 1. In fact, this property can be proved for the
general case similarly.

4.5.2. Compatibility

Moreover, adding bias term is allowable, if any channel in a
group share the shared bias value. So do batch normalization
layers with the shared scale and bias parameters. Since ReLU
activation functions are channel indenpendent operation, they
do not have any impact on rotation equivariance, thus compat-
ible with our architecture. So do dropout layers. Moreover,
one can also apply fully connected layers following the decycle
layer.

In addition, we should discuss convolution and pooling lay-
ers with stride > 1. When stride is more than 1, one can observe
that the ﬁlter may not convolve marginal pixels in an image,
thus destroying rotation equivariance. Indeed, suppose the size
of the image is n by n, rotation equivariance can be preserved
iﬀ. n = k · stride + kernelsize for some k ∈ N. The proof is
trivial.

4.5.3. Invariance

Furthermore, the equivariance property can be lifted to in-
variant property in our framework. Simply applying a global
pooling layer[24] in the end of our framework can make output
rotation invariant.

4.6. Memory consumption analysis

Some previous work[10; 20; 25] rotate feature maps to obtain
rotation equivariance. Indeed, one can show that rotating fea-
ture maps correspondingly can yield equivalent results. How-
ever, rotating and buﬀering ﬁlters are more eﬃcient, because
feature maps have much larger size than ﬁlters at most of the
time.

The theoretical analysis of memory usage is based on the
fact that most of popular deep learning frameworks use GEMM
algorithm[26] to compute image convolution. Precisely, feature
maps should be copied k2 times, merged into a single matrix,
then multiplied by weight matrix. Therefore, the total size of
feature maps is clearly much larger than the size of ﬁlters at
most of the time. This indicates that rotating the feature maps
lead to about 4 times more memory cost than rotating the ﬁlters.
The detail memory costs are listed in Table 1.

On the other side, rotating feature maps also costs more time
in rotation operation and copy operation. In Section 5, we give a
detailed comparison on our approach and an architecture using
the strategy of rotating feature maps, proposed by [10].

4.7. Relations to other methods

Since DREN is a general framework, it can be shown that
several existing networks become special cases of our frame-
work.

For instance, if we set all element of the hyper-matrix of a de-
cycle layer to be the identity matrix times a normalizing factor,

Table 1: Memory cost of rotating ﬁlters and feature maps

Method

Mem. cost

Rotate
ﬁlters
4cincoutk2
ncinwh
ncinwhk2

Rotate feature
map
cincoutk2
4ncinwh
4ncinwhk2

Filters
Feature map
Feature map(GPU)
1 Here n, cin, cout, w, h, k denote batch size, input channels, output chan-

nels, width of input, height of input and kernel size, respectively.

the decycle layer becomes cross-channel mean pooling layer
that is used by most of work[6–8].

For isotonic layers, we can set Whide to a diagonal form, i.e.,
all of ﬁlters other than those on the diagonal of hyper-matrix to
be zero matrices. In other words, this means that all of feature
maps would be convolved by rotated copies of a single ﬁlter,
which is utilized by [10; 19; 25].

Moreover, the last decycle layer can be replaced by a cross-
channel max pooling layer. Although it is not a decycle layer
in nature, the cross-channel max pooling layer satisﬁes Equa-
tion (7) as well. Actually other layers that satisfy Equation (7),
such as cross-channel root-mean-square(RMS) layer, can also
be applied to replace the decycle layer and to preserve rotation
equivariance as well.

Finally, we claim that our approach yields the equivalent re-
sult to that of [10] when the proposed layers are carefully used.
Note that, by convolutional distributive law, for any ﬁlter W
and any feature map x, R(W ∗ x) = R(W) ∗ R(x). Then we can
derive that the cyclic slice layer[10] followed by an ordinary
convolutional layer equals to the cycle layer; the cyclic roll
layer[10] followed by an ordinary convolutional layer equals
to the isotonic layer; the cyclic pooling[10] is actually cross-
channel pooling which is a special case of the decycle layer;
the cyclic stack layer[10] followed by an ordinary convolutional
layer equals to the isotonic layer whose weight hyper-matrix
Whide is a diagonal matrix. In fact, DREN operates on ﬁlters
rather than feature maps, reducing about half of running time
with less memory overhead compared with that of [10]

5. Experiments

In this section, we evaluate our framework on two datasets,
Rotated MNIST and CIFAR-10. All of the experiments are pub-
lished on GitHub1.

5.1. Rotated MNIST

First, we evaluate on Rotated MNIST dataset[27]. It is the
rotated version of MNIST dataset[28], with digits being rotated
for a degree uniformly drawn from [0, 2π]. In total, it contains
62000 handwritting digit images, among which there are 10000
images for training, 2000 for validating and 50000 for testing.
We choose the Z2CNN(refer to [6]) as our baseline, which
consists of 7 convolutional layers of kernel size 3×3(4×4 in the

1https://github.com/microljy/DREN_Tensorflow

5

last layer). Each layer of Z2CNN has 20 channels, followed by
a ReLU activation layer, a dropout layer, a batch normalization
layer. Besides, a max pooling layer is applied right after the
second layer.

We replace the ﬁrst layer and the last layer of the baseline
network by a cycle layer and a decycle layer, respectively. Be-
sides, the intermediate layers are replaced by isotonic layers.
Moreover, since that our proposed layers can reduce the num-
ber of parameters fourfold, we double the number of channels
in each layers to keep the number of parameters approximately
ﬁxed.

Table 2 lists our results. This architecture(DREN) is found
to achieve high accuracy with a small number of params. We
also try to replace the decycle layer in DREN with a isotonic
layer followed by a cross-channel max pooling layer. This net-
work(DRENMaxPoolling) have 25k params., which is 24% less
than that of H-Net[22], and equal to that of P4CNN[6] and
Dieleman et al.[10]. DRENMaxPoolling outperforms all the
previous models without more params.. In addition, our archi-
tecture can reduce about half of running time with less memory
overhead compared with Dieleman et al.[10], this would be fur-
ther discussed in Section 5.4.

Table 2: Performance of various models on Rotated MNIST.

Model
SVM[27]
Transformation RBM[29]
Conv-RBM[13]
Z2CNN[6]
P4CNN[6]
H-Net[22]
Dieleman et al.[10]
DREN
DRENMaxPoolling

Error
11.11%
4.2%
3.98%
5.03%
2.28%
1.69%
1.78%
1.78%
1.56%

Param.
-
-
-
22k
25k
33k
25k
22k
25k

5.2. CIFAR-10

We also evaluate our framework on CIFAR-10[30], a real-
world dataset that does not have rotational symmetry in na-
ture.
It consists of 50000 training and 10000 testing images
uniformly drawn from 10 classes. Each one has RGB chan-
nels of size 32 × 32. For this dataset, we apply global contrast
normalization to preprocess the data, as was used by [31].

We test our framework on Network in Network(NIN)[24]
and Resnet-20[5]. First, we replace the ordinary convolu-
tional layers of these models by our proposed layers, see r-
NIN(conv1-4), r-Resnet-20(conv1-13), where conv1-k means
that the ﬁrst k layers are replaced by our proposed layers. Since
our proposed layers only need a quarter of the number of pa-
rameters in each layer, we also evaluate r-NIN(conv1-4)×4 and
r-Resnet-20(conv1-13)×4, where the number of channels of the
ﬁrst 4 layers are doubled to keep the total number of parameters

6

Table 3: Performance of various models on CIFAR-10.

Error
10.41%
9.4%
9.8%
9.0%
9.00%
8.51%
7.17%

Model
NIN[24]
NIN*
r-NIN(conv1-4)
r-NIN(conv1-4)×4
Resnet-20[5]
r-Resnet-20(conv1-13)
r-Resnet-20(conv1-13)×4
1 * means our implementation.
2 conv1-k means 1-k layers are replaced by our proposed layers
3 r− means the model utilizes rotation equivariant layers.
4 ×4 means the number of channels of proposed layers are doubled.

Params.
967k
967k
576k
958k
297k
245k
297k

Rotated MNIST

CIFAR-10

r-Z2CNN
r-Z2CNN×4

r-NIN
r-NIN×4

)

%

(
r
o
r
r
e

t
s
e
T

6

5

4

3

2

)

%

(
r
o
r
r
e

t
s
e
T

16

14

12

10

8

base 1-2

1-3

1-4

1-5

1-6

1-7

base 1-2

1-3

1-4

1-5

1-6

1-7

Figure 3: Classiﬁcation error of models with diﬀerent numbers of our pro-
posed layers: The left one is the results on Rotated MNIST and the right one
is that on CIFAR-10. The horizontal axis shows the number of our proposed
layers applied. It turns out that, for datasets which has rotation symmetry in na-
ture(Rotated MNIST), applying more isotonic layers yields better classiﬁcation
accuracy. We argue that higher level rotation equivariant representations learnt
by stacking more isotonic layers improves the classiﬁcation accuracy on such
dataset. However, for CIFAR-10, the circumstance changes. Applying 4 or 5
isotonic layers achieves the best performance. We argue that higher level rota-
tion equivariant representations are not helpful on such dataset without rotation
symmetry, and applying more isotonic layers reduces the number of parame-
ters(model complexity) fourfold, therefore leading to severe underﬁtting. ×4
means the model with doubled number of channels.

unchanged. The results are shown in Table 3. It shows that our
model(r-NIN(conv1-4)×4 and r-Resnet-20(conv1-13)×4) can
outperform the baseline with roughly the same number of pa-
rameters. In this experiment, we do not replace all of the con-
volution layers with our proposed layers, since we observe that
simply replacing all layers cannot achieve the best performance.
This would be discussed in the next subsection.

5.3. How many isotonic layers should be applied?

The only hyperparameter of our framework is the number
of isotonic layers used. Thus, in this subsection, we study the
performance of DRENs with diﬀerent numbers of isotonic lay-
ers in the following experiments. We also choose two base-
lines above, evaluate them on Rotated MNIST and CIFAR-10
respectively, and gradually integrate more isotonic layers into
baselines(e. g., conv1-2, conv1-3, conv1-4, etc.).

The results are shown in Figure 3. We observe two quite dis-
tinct trends in the two datasets. For Rotated MNIST which has
rotation symmetry in nature, the more isotonic layers we use,
the better performance the model achieves, even with less and
less number of parameters. However, for CIFAR-10, r-NINs

Figure 4: The representations in the last convolutional layer learnt by NIN[24], H-Net[22], P4-ALL-CNN-C[6] and DREN. The two columns correspond
to the representations of an image of automobile(left) and an image of truck(right). Inside one of the 8 pictures, the leftmost column contains the rotated input
images while the remaining 10 columns contain the 10 feature maps in the last convolutional layers, which corresponds to the 10 classes of CIFAR-10. We slightly
modify the architecture of H-Net to ensure that a global average pooling layer is used right after the last convolutional layer. The other three networks also apply
this structure. Thus, the predictions of the networks are exactly the class whose related representation attains maximum density. We mark the maximal one(the
prediction) with a red square. It turns out that when the input is rotated, NIN yields entirely diﬀerent representations, leading to wrong predictions. For H-Net and
P4-ALL-CNN-C, the representations are partly equivariant to rotation. However, H-Net still predicts incorrectly, when the image of automobile is rotated. In fact,
only the representations of DREN are exactly equivariant to rotation, and thus the predictions of DREN are consistent, when the input is rotated. Moreover, we ﬁnd
our leanrt representations for automobile and for truck are very similar while that of other models are not. This shows that the representations learnt by DREN are
similar for semantically similar objects, which indicates the reasonability of adding rotation equivariant constraint.

7

achieve best performance when using two isotonic layers(i.e.,
replace 4 convolutional layers).

running time of the ordinary CNN, since the ﬁlters can be ro-
tated and stored before running.

Because CIFAR-10 does not have deep rotation symmetry,
intuitively, most eﬀective latent representations maybe be not
rotation equivariant. Thus, using too much isotonic layers pre-
vents the network from learning such representations. This is
one of the reason why our framework cannot achieve better
performance with more isotonic layers. Another cause may
be that the number of parameters(i.e., model complexity) de-
creases with more isotonic layers used, thus leading to a under-
ﬁtting model.

The other extreme case that very a few isotonic layers are ap-
plied, also results in bad results. According to Figure 3, our
models(r-Z2CNN,r-NIN,r-NIN×4) underperform the baseline
when less than two isotonic layers are applied. This observa-
tion actually meets with the argument we pose in Section 1,
that the networks with a few or none isotonic layer can only
learn shallow and trivial rotation equivariant representations.

5.4. Running time of rotating ﬁlters and feature maps

In order to compare the running time costs between rotating
feature maps and rotating ﬁlters, we evaluate both methods on
Rotated MNIST dataset. We take the implementation presented
by [10] as the representative of the methods that rotate feature
maps. Since there are some diﬀerence between their framework
and ours, we make minor modiﬁcation on both frameworks to
ensure that the comparison is a fair play. The decycle layer is
replaced with a cross-channel mean-pooling layer in our frame-
work, and the cyclic roll operation is applied before every con-
volution layer except the ﬁrst one in their frameworks.

The running time of rotating ﬁlters and feature maps are
shown in Table 4. Both implementations run on Intel core
i7-5930K processors(3.50GHz) and GeForce GTX 1080 with
NVIDIA CUDA 8.0 and cuDNN 5. Since all models are im-
plemented with Theano that automatically free memory using a
reference count system, we cannot exactly determine memory
consumption. Thus, only running time is listed.

Table 4: Running time of two implementations.

Implementation

Setting

Rotate ﬁlters

Rotate feature maps[10]

Model

Z2CNN

NIN

Z2CNN

NIN

Batch size
64
128
64
128
64
128
64
128

Time

1.97s
1.44s
11.00s
9.52s
4.15s
3.74s
22.13s
18.73s

1 The time cost is the testing time of testing 50k images.
Table 4 shows that our implementation based on rotating ﬁl-
ters are twice as fast as the implementation based on rotating
feature maps[10; 20; 25]. In fact, the running time of the im-
plementation based on rotating ﬁlters can be the same as the

8

5.5. Visualization of DREN

Since deep rotation equivariant representations can be learnt
from our framework, we are concerned with how such represen-
tations diﬀer from ordinary representation of a typical CNN and
other rotation equivariance structures. To this end, we visual-
ized the representations produced by NIN[24], P4-ALL-CNN-
C[6], H-Net[22] and DREN trained on CIFAR-10. We slight
modify the architecture of H-Net to a global average pooling
manner that are used by the other three models in order for fair
comparison and clear visualization. In detail, we apply global
average pooling layer rather than fully connected layer in above
models. This indicates that the feature maps in the last convo-
lutional layers are the conﬁdence maps of the categories in fact.
Such feature maps of four models are shown in Figure 4. In
each picture, there are 11 columns. The leftmost one is the in-
put image while the remaining ones are the feature maps in the
last convolutional layer, each one corresponding to a class of
CIFAR-10. In each row, we mark the predictions of the net-
works(i.e., the one with maximal density) with red squares.

It turns out that when the input is rotated, NIN yields entirely
diﬀerent representations, leading to wrong predictions. For H-
Net and P4-ALL-CNN-C, the representations are partly equiv-
ariant to rotation. However, H-Net still predicts incorrectly,
when the image of automobile is rotated. In fact, only the rep-
resentations of DREN are exactly equivariant to rotation, and
thus the predictions of DREN are consistent when the input is
rotated.

Moreover, we ﬁnd our leanrt representations for automobile
and for truck are very similar while that of other models are not.
This shows that the representations learnt by DREN are similar
for semantically similar objects, which indicates the reasonabil-
ity of adding rotation equivariant constraint.

6. Conclusion & Discussion

We propose a novel CNN framework, DREN, which can
learn deep rotation equivariant representations from images.
Theoretical guarantee is provided that the features are rota-
tion equivariant to rotation of degree kπ/2 for k ∈ Z and ex-
periment results show that our framework can also deal with
other degrees. We evaluate our framework on Rotated MNIST
and CIFAR-10 datasets, outperforming several state-of-the-art
CNN architectures. In addition, our implementation of rotating
ﬁlters costs only a half time of feeding forward comparing to
the methods which rotate feature maps.

As a future direction, we suggest to settle the cases of rotation
of general degree. Although our framework mainly deals with
rotation of degree kπ/2 for k ∈ Z, it can be easily generalized
to any ﬁnte group of rotation transformations, if there is an eﬃ-
cient way to perform rotations of any degree on ﬁlters. In short,
our approach is a tradeoﬀ between eﬃciency and performance.
For another direction, we would like to design new types
of convolutional layers to implement equivariance with respect

[20] S. Dieleman, K. W. Willett, J. Dambre, Rotation-invariant convolutional
neural networks for galaxy morphology prediction, Monthly notices of
the royal astronomical society 450 (2) (2015) 1441–1459.

[21] R. Gens, P. M. Domingos, Deep symmetry networks, in: Advances in

neural information processing systems, 2014, pp. 2537–2545.

[22] D. E. Worrall, S. J. Garbin, D. Turmukhambetov, G. J. Brostow, Harmonic
networks: Deep translation and rotation equivariance, arXiv preprint
arXiv:1612.04642.

[23] D. M. Gonzalez, M. Volpi, D. Tuia, Learning rotation invariant convolu-

tional ﬁlters for texture classiﬁcation, CoRR abs/1604.06720.

[24] M. Lin, Q. Chen, S. Yan, Network in network, in: In Proc. ICLR, 2014.
[25] D. Laptev, N. Savinov, J. M. Buhmann, M. Pollefeys, Ti-pooling:
transformation-invariant pooling for feature learning in convolutional
neural networks, arXiv preprint arXiv:1604.06318.

[26] V. Volkov, J. W. Demmel, Benchmarking gpus to tune dense linear alge-
bra, in: High Performance Computing, Networking, Storage and Analy-
sis, 2008. SC 2008. International Conference for, IEEE, 2008, pp. 1–11.
[27] H. Larochelle, D. Erhan, A. Courville, J. Bergstra, Y. Bengio, An em-
pirical evaluation of deep architectures on problems with many factors
of variation, in: Proceedings of the 24th international conference on Ma-
chine learning, ACM, 2007, pp. 473–480.

[28] Y. LeCun, L. Bottou, Y. Bengio, P. Haﬀner, Gradient-based learning ap-
plied to document recognition, Proceedings of the IEEE 86 (11) (1998)
2278–2324.

[29] K. Sohn, H. Lee, Learning invariant representations with local transfor-

mations, arXiv preprint arXiv:1206.6418.

[30] A. Krizhevsky, G. Hinton, Learning multiple layers of features from tiny

images.

[31] I. Goodfellow, D. Warde-Farley, M. Mirza, A. Courville, Y. Bengio, Max-
out networks, in: Proceedings of The 30th International Conference on
Machine Learning, 2013, pp. 1319–1327.

to scale transformations and more generally, aﬃne transforma-
tions. These may improve the performance of CNNs further.

References

References

[1] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan,
V. Vanhoucke, A. Rabinovich, Going deeper with convolutions, in: Pro-
ceedings of the IEEE Conference on Computer Vision and Pattern Recog-
nition, 2015, pp. 1–9.

[2] R. Girshick, J. Donahue, T. Darrell, J. Malik, Rich feature hierarchies for
accurate object detection and semantic segmentation, in: Proceedings of
the IEEE conference on computer vision and pattern recognition, 2014,
pp. 580–587.

[3] A. Krizhevsky, I. Sutskever, G. E. Hinton, Imagenet classiﬁcation with
deep convolutional neural networks, in: Advances in neural information
processing systems, 2012, pp. 1097–1105.

[4] K. Simonyan, A. Zisserman, Very deep convolutional networks for large-

scale image recognition, arXiv preprint arXiv:1409.1556.

[5] K. He, X. Zhang, S. Ren, J. Sun, Deep residual learning for image recog-
nition, in: Proceedings of the IEEE conference on computer vision and
pattern recognition, 2016, pp. 770–778.

[6] T. Cohen, M. Welling, Group equivariant convolutional networks, in:
Proceedings of the 33nd International Conference on Machine Learn-
ing, ICML 2016, New York City, NY, USA, June 19-24, 2016, 2016,
pp. 2990–2999.

[7] F. Wu, P. Hu, D. Kong, Flip-rotate-pooling convolution and split dropout
on convolution neural networks for image classiﬁcation, arXiv preprint
arXiv:1507.08754.

[8] D. Marcos, M. Volpi, D. Tuia, Learning rotation invariant convolutional
ﬁlters for texture classiﬁcation, in: Pattern Recognition (ICPR), 2016
23rd International Conference on, IEEE, 2016, pp. 2012–2017.

[9] D. Teney, M. Hebert, Learning to extract motion from videos in convolu-

tional neural networks, arXiv preprint arXiv:1601.07532.

[10] S. Dieleman, J. D. Fauw, K. Kavukcuoglu, Exploiting cyclic symmetry in
convolutional neural networks, in: Proceedings of the 33nd International
Conference on Machine Learning, ICML 2016, New York City, NY, USA,
June 19-24, 2016, 2016, pp. 1889–1898.

[11] K. Kavukcuoglu, R. Fergus, Y. LeCun, et al., Learning invariant features
through topographic ﬁlter maps, in: Computer Vision and Pattern Recog-
nition, 2009. CVPR 2009. IEEE Conference on, IEEE, 2009, pp. 1605–
1612.

[12] M. Norouzi, M. Ranjbar, G. Mori, Stacks of convolutional restricted
boltzmann machines for shift-invariant feature learning, in: Computer Vi-
sion and Pattern Recognition, 2009. CVPR 2009. IEEE Conference on,
IEEE, 2009, pp. 2735–2742.

[13] U. Schmidt, S. Roth, Learning rotation-aware features: From invariant
priors to equivariant descriptors, in: Computer Vision and Pattern Recog-
nition (CVPR), 2012 IEEE Conference on, IEEE, 2012, pp. 2050–2057.
[14] H. Lee, R. Grosse, R. Ranganath, A. Y. Ng, Convolutional deep belief net-
works for scalable unsupervised learning of hierarchical representations,
in: Proceedings of the 26th annual international conference on machine
learning, ACM, 2009, pp. 609–616.

[15] J. Yu, C. Hong, Y. Rui, D. Tao, Multi-task autoencoder model for recov-
ering human poses, IEEE Transactions on Industrial Electronics PP (99)
(2017) 1–1.

[16] J. Yu, B. Zhang, Z. Kuang, D. Lin, J. Fan, iprivacy: image privacy pro-
tection by identifying sensitive objects via deep multi-task learning, IEEE
Transactions on Information Forensics and Security 12 (5) (2017) 1005–
1016.

[17] J. Zhang, K. Li, Y. Liang, N. Li, Learning 3d faces from 2d images via

stacked contractive autoencoder , Neurocomputing 257 (2017) 67–78.

[18] K. Grzegorczyk, M. Kurdziel, P. I. W´ojcik, Encouraging orthogonality
between weight vectors in pretrained deep neural networks, Neurocom-
puting 202 (2016) 84–90.

[19] B. Fasel, D. Gatica-Perez, Rotation-invariant neoperceptron, in: 18th In-
ternational Conference on Pattern Recognition (ICPR’06), Vol. 3, IEEE,
2006, pp. 336–339.

9

