Semantic Drift Compensation for Class-Incremental Learning

Lu Yu1,2, Bartomiej Twardowski2, Xialei Liu2, Luis Herranz2, Kai Wang2,
Yongmei Cheng1, Shangling Jui3, Joost van de Weijer2
1 School of Automation, Northwestern Polytechnical University, Xi’an, China
2 Computer Vision Center, Universitat Autonoma de Barcelona, Barcelona, Spain
3 Huawei Kirin Solution, Shanghai, China
{luyu,btwardowski,xialei,lherranz,kwang,joost}@cvc.uab.es,
chengym@nwpu.edu.cn, jui.shangling@huawei.com

0
2
0
2
 
r
p
A
 
1
 
 
]

V
C
.
s
c
[
 
 
1
v
0
4
4
0
0
.
4
0
0
2
:
v
i
X
r
a

Abstract

Class-incremental learning of deep networks sequen-
tially increases the number of classes to be classiﬁed. Dur-
ing training, the network has only access to data of one task
at a time, where each task contains several classes. In this
setting, networks suffer from catastrophic forgetting which
refers to the drastic drop in performance on previous tasks.
The vast majority of methods have studied this scenario for
classiﬁcation networks, where for each new task the clas-
siﬁcation layer of the network must be augmented with ad-
ditional weights to make room for the newly added classes.
Embedding networks have the advantage that new classes
can be naturally included into the network without adding
new weights. Therefore, we study incremental learning for
embedding networks. In addition, we propose a new method
to estimate the drift, called semantic drift, of features and
compensate for it without the need of any exemplars. We
approximate the drift of previous tasks based on the drift
that is experienced by current task data. We perform exper-
iments on ﬁne-grained datasets, CIFAR100 and ImageNet-
Subset. We demonstrate that embedding networks suffer
signiﬁcantly less from catastrophic forgetting. We outper-
form existing methods which do not require exemplars and
obtain competitive results compared to methods which store
exemplars. Furthermore, we show that our proposed SDC
when combined with existing methods to prevent forgetting
consistently improves results. 1

1. Introduction

Future learning machines should be able to adapt to an
ever-changing world. They should continuously learn new
tasks without forgetting previously learned tasks. Other
than the generally applied setup, where training data for all

1Code available at https://github.com/yulu0724/SDC-IL.

Figure 1: T-SNE visualization of embedding space after
ﬁnetuning. A, B, C indicate prototypes of task 1 after train-
ing task 1; A’,B’,C’ and D,E,F respectively for task 1 and
2 after training for task 2. The semantic drift (indicating
forgetting) from task 1 is given by red vectors. Our method
estimates this and compensates the prototypes accordingly.

tasks is simultaneously available, in continual learning tasks
are learned in a consecutive manner. At each moment the al-
gorithm has only access to the data of a single task. For deep
neural networks, one could ﬁnetune the network on the data
of the latest task. However, in the absence of training data
of previous tasks, the network suffers from catastrophic for-
getting [27]. This refers to a drastic drop in performance on
previous tasks. Continual learning studies strategies to mit-
igate the impact of catastrophic forgetting [17, 20, 31].

Continual learning has explored a variety of strategies to
prevent networks from forgetting previously learned tasks.
Li et al. [20] propose a method called learning without for-
getting (LwF). They use the same data to supervise learning

1

of the new tasks and to provide unsupervised output guid-
ance on the old tasks to prevent forgetting. Elastic weight
consolidation (EWC) [17] estimates the Fisher matrix to
weight a regularization term favouring changes to neurons
which were found to be less important in previous tasks, and
which prevents the relevant neurons from adapting to the
new task. Further research on continual learning includes
regularization terms [1, 21], sub-network selection by mask
learning [23, 24, 36], and the use of exemplars [22, 31].

Many of the early works in continual learning consid-
ered a task-incremental learning (task-IL) scenario [40],
in which the network has access to the task-ID at infer-
ence time [1, 17, 20, 26, 36]. Recently, more works con-
sider the more difﬁcult class-incremental learning (class-
IL) [2, 10, 15, 21], where no task-ID is available at infer-
ence. The main additional challenge for class-IL is the class
imbalance between old versus new tasks. This is addressed
by storing data of previous tasks [5, 15, 46]. In this paper,
we propose a new method for class-incremental learning.
We consider the difﬁcult scenario where no data of previous
tasks can be stored. The importance of continual learning
algorithms which do not require any storage is growing in a
world where data privacy and security are fundamental for
many users, and are controlled by government legislation.

The discussed previous works all study continual learn-
ing in classiﬁcation networks. For these networks, new
weights have to be added to accommodate for the newly
added classes. Instead, we perform class-incremental learn-
ing for embedding networks which naturally allow for
the inclusion of new classes, and do not require network
changes for new classes. Embedding networks map data to
embedding spaces in which distances correspond to seman-
tic dissimilarities between data points [8]. They are typi-
cally used for image retrieval [42], face recognition [34],etc.
However, they can also be used for classiﬁcation when com-
bined with, for example, a nearest class mean classiﬁer [28].
In this paper, we show that embedding networks suffer
signiﬁcantly less from catastrophic forgetting than classi-
ﬁcation networks. We also propose a new method called
semantic drift compensation.
Instead of preventing drift,
which most existing methods do, our method estimates the
drift of previous tasks during the training of new tasks (see
Fig. 1). We show that an estimate of the semantic drift in
previous tasks can be used to compensate for it, thereby im-
proving performance. We evaluate embedding networks for
image classiﬁcation by using the nearest class mean (NCM)
classiﬁer [28]. We will refer to the class embedding mean
with the term prototype. We will show how the drift of
prototypes learned in previous tasks can be approximated
while only having access to data of the current task. Fur-
thermore, the proposed method can easily be combined with
existing methods that prevent forgetting, such as EWC [17],
LwF [20], or MAS [1], to further improve results.

2. Related Work

Continual Learning. Regularization-based methods op-
timize network parameters on the current task while pre-
venting the drift of already consolidated weights. Learn-
ing without forgetting (LwF) [20] adapts a learned model
to new tasks while retaining the knowledge gained earlier
with a regularization term on probabilities. EWC [17] and
a variant R-EWC [21] include a regularization term on the
weights that forces parameters of the current network to re-
main close to the parameters trained for the previous tasks.
Zenke et al. [49] propose to compute the consolidation
strength of synapses (represented by the network weights)
in an online manner, and extends them with a memory to ac-
cumulate task-relevant information. Aljundi et al. [1] com-
pute the weight importance in a unsupervised manner.

Rehearsal-based methods store a small subset of train-
ing data from previous tasks in order to prevent catastrophic
forgetting. These exemplars are combined (i.e. rehearsed)
with the current task data so that the network parameters
are jointly optimized. Some existing works use a distil-
In [46],
lation loss to prevent forgetting [6, 22, 31, 15].
bias correction is proposed to solve the problem of the data
imbalance between the old and new classes especially for
large scale datasets. Another alternative is to learn a genera-
tive model of previous tasks, and generate synthetic samples
(i.e. pseudo-rehearsal) that are combined as usual [45, 37].

We consider continual learning in the challenging class-
incremental learning (class-IL) scenario. Some aforemen-
tioned methods can be applied directly to class-IL by ad-
justing the network architecture, e.g. [2, 33]. However,
they do not scale with the number of classes—as the net-
work requires constant expansion.
In [10] the presented
approach uses an attention distillation loss to penalize the
changes on attention maps, which helps to retain infor-
mation of the previous classes, whenever new classes are
added. Three strategies to prevent forgetting: cross normal-
ization, less-forgetting constrain and inter-class separation
with saved exemplars from previous tasks are introduced
in [15]. A method applicable for a class-incremental prob-
lem was presented in [21], where EWC is combined with
a reparametrization of the network in form of a factorized
rotation what results in a better performance on previous
tasks. The authors of work [46] discussed the problems
of large number of classes and visual similarities between
new versus old classes. They proposed a bias correction of
network’s outputs for new classes by a linear models. A
distillation loss was used in [5] with an additional exem-
plars set in order to prevent forgetting for class-incremental
learning. Finally, [3] exploits a dual memory to reduce the
negative effect of catastrophic forgetting in image recogni-
tion. A model integrates knowledge distillation and retro-
spection along with the path selection strategy is proposed

to overcome catastrophic forgetting in [30].

3.1. Embedding Networks

Our method differs with previous work in two principal
aspects. To train new tasks, we use an embedding network
with a metric learning loss rather than a classiﬁcation loss.
And secondly, all of the methods discussed above focus on
preventing forgetting during the learning of new tasks. Our
method does not focus on preventing forgetting, but instead
proposes to estimate the drift of features that happens due to
the learning of new tasks. Having an approximation of the
drift, we can compensate the prototypes of previous tasks.

Deep Metric Learning. Siamese networks [8] were ﬁrst
proposed to learn embeddings for face veriﬁcation. Initially,
they used contrastive loss, which ensures that pairs from the
same category are close and pairs from different categories
are far. Triplet networks [13, 41] were proposed to address
the limitations of contrastive loss. The inputs are an anchor
image, a positive and a negative image. The aim of a triplet
network is to learn embeddings for which the distance be-
tween the similar pairs is smaller than the distance between
the dissimilar pairs. A direct extension to this method is a
quadruplet network [7], where the number of points is ex-
tended to four and three pairs are used at once in a loss func-
tion. Further improvements to the embedding learning in-
clude: constraining the angle at the negative point of triplet
triangles [42] and exploiting all selected pairs information
in a multi-similarity loss function proposed in [43].

The advantages of embedding networks, when compared
to classiﬁcation networks, is an ongoing discussion. Re-
cent works have pointed out serious shortcomings of clas-
siﬁcation networks, mostly attributed to the cross-entropy
loss (which is based on a softmax operation). Embedding
networks were found to be more robust to the exposure of
adversarial examples, and better in the detection of out-of-
distribution examples [25, 32]. Furthermore, deep embed-
dings were reported to be superior to classiﬁcation networks
for transfer learning [35] and preliminary results suggest
that they might be less prone to catastrophic forgetting [47].

3. Continual Learning for Embeddings

We consider a class-incremental learning setup where a
network learns several tasks, each task containing a number
of new classes. During the training of task t we only have
access to data Dt which contains pairs (xi, yi), where xi is
an image of class yi ∈ C t. For each task we consider that
there is data of a limited set of classes C t = {ct
mt},
where mt is the number of classes in task t. We consider the
generally studied case where there is no overlap between the
classes of different tasks: C t ∩ C s = ∅ for t (cid:54)= s. After
training all n tasks we evaluate the learned embedding on
all classes C = (cid:84)
i C i. As other class-incremental methods,
we consider a task-agnostic setting where the algorithm has
no access to the task label at test time.

2..., ct

1, ct

We start by explaining the training of an embedding net-
work for a single task. Embedding networks map data into
a low-dimensional output where distance represents the se-
mantic dissimilarity between the images [4, 8]. They si-
multaneously perform feature extraction as well as metric
learning. In the learned embedding space it is possible to
apply a simple metric, such as L2-distance, to determine
the similarity between the original images.

Chopra et al. [8] proposed to use Siamese networks with
the contrastive loss as an objective function. This loss needs
related and unrelated pairs of images, and ensures that the
distance between related pairs will be low, and the distance
between unrelated pairs larger than a margin. For some em-
beddings it was found that the contrastive loss is hard to
train, and other losses have been proposed. The triplet loss
is proposed by Hoffer et al. [13] based on the work of Wang
et al. [41]. The objective function forces the negative in-
stance to be further away from the anchor than the positive
ones (plus a margin m). The triplet loss is given by:

LT = max(0, d+ − d− + m),

(1)

where d+ and d− are the Euclidean distances between the
embeddings of the anchor za and the positive instance zp
and the negative instance zn respectively. Here zi = F (xi)
is the output embedding for image xi.

Having trained an embedding network we can use the
embedding space for classiﬁcation. We will use nearest
class mean (NCM) classiﬁer which is deﬁned as:

c∗
j = argmin

dist(zj, µc)

c∈C

1
nc

(cid:88)

i

µc =

[yi = c] zi

(2)

(3)

where nc is the number of training images for class c and
[P ] = 1 if P is true, and 0 otherwise. We will refer to µc
as the prototype of class c. The terminology of prototypes
was also used in several works [39, 47] to refer to class rep-
resentative points in an embedding space.

3.2. Softmax Classiﬁer versus Embedding Learning

The conventional approach to image classiﬁcation is a
softmax classiﬁer trained with a cross-entropy loss. Due to
its success, it has been the natural starting point for methods
studying continual learning for image classiﬁcation. How-
ever, there are several fundamental drawbacks of the soft-
max classiﬁer which might limit its application to continual
learning. First, network outputs are tightly coupled with
prediction classes. Whenever new object classes are added,
structural changes to the architecture are required, i.e. new
In
neurons added to accommodate for the new classes.

Figure 2: Average incremental accuracy for ﬁnetuning trained and evaluated with softmax (FT) , ﬁnetuning trained with
softmax but classiﬁed with NCM (FT*), and trained with metric learning loss and classiﬁed with NCM (E-FT). In addition,
we report joint training (Joint). The results show that continual learning with embedding networks suffers from signiﬁcantly
less forgetting.

a class-incremental setting, this results in creating a new
output layer (head) for each task [5]. Second, in order
to acquire a ﬁnal prediction from a multi-head network,
outputs need to be aggregated. Third, the updated model
is expected to be biased in the predictions that favor new
classes [15, 46]. All of the aforementioned issues can be
mitigated to some extent. However, an adaptation process
of softmax-based classiﬁers for class-incremental learning
is challenging and harder for longer task sequences. Using
embedding networks for continual learning has advantages.
New classes can be naturally added without any architec-
tural changes. While learning new tasks, the network gets
ﬁne-tuned to the new data distribution. However, metric
learning methods do not require information about classes
directly. This is used only to make a proper preparation of
the input data, i.e. pairs of positive and negative examples,
and thus, the architecture stays intact.

In order to compare classiﬁcation and embedding net-
works in a continual learning setting, we compare both
when applying ﬁnetuning to adjust to new tasks; a setting
which is known to lead to catastrophic forgetting for classi-
ﬁcation networks. The softmax classiﬁer uses new heads for
the incremental classiﬁcation. During testing we compute
the probability of each head and take the maximum as the
true prediction (called FT). As a second option, we consider
performing NCM on the average-pooled output of block 5
of the trained ResNet network, which has the same dimen-
sionality as our embedding network (denoted by FT*). This
technique was also used in iCaRL [31]. The embedding
network (trained with triplet loss [13]) represents classes
with a prototype and performs NCM for classiﬁcation, and
is denoted by E-FT. After convergence on a task is reached,
we continue training on a new task with standard stochastic
gradient descent, and repeat this until all tasks are learned.

The results of the comparison on three datasets are pre-
sented in Fig. 2. Let ak,j ∈ [0, 1] be the accuracy of the
j-th task (j ≤ k) after training the network sequentially

(cid:80)k

for k tasks. Then, the average incremental accuracy at task
k is deﬁned as Ak = 1
j=1 ak,j [2]. We observe that
k
the softmax leads to better classiﬁcation performance for
the ﬁrst task, as mentioned in [13, 14]. However, the av-
erage incremental accuracy of softmax drops signiﬁcantly
when continually adding tasks. This is especially evident
for the CIFAR100 and ImageNet-Subset datasets. Using the
softmax and classiﬁcation with NCM on embedding (FT*)
suffers similarly from catastrophic forgetting. The ﬁnetun-
ing with metric loss (E-FT) signiﬁcantly better results are
obtained, with absolute gains of 23.9% on CUB-200-2011,
with 32.6% on CIFAR100, and 42.9% on ImageNet-Subset.
In conclusion, a well-established method for a single-task
learning (i.e. softmax) is not optimal when it is used in
a continual learning setting. Classiﬁcation with NMC and
embeddings learned with metric losses suffer signiﬁcantly
less from catastrophic forgetting as we observed. Therefore,
we propose to use them for continual learning. In the fol-
lowing, we will develop additional methods to further im-
prove continual learning for embedding networks.

3.3. Regularizing Embedding Networks

The problem of catastrophic forgetting in continual
learning has been extensively studied for classiﬁcation net-
works [6, 17, 20, 21, 31, 37, 45]. To our knowledge, there
is no prior work to prevent forgetting the knowledge from
the previous tasks on embedding networks. In the follow-
ing, we adapt several existing techniques to embeddings.
We will indicate the variant for embeddings the following
notation convention: we append an E (for embedding) to
the name of the original method designed for a classiﬁca-
tion network, e,g, E-LwF would be LwF (Learning without
Forgetting) adapted for an embedding network.
Finetuning (E-FT) Described in Sec. 3.2 and used as a
baseline. For all experiments triplet loss [13] is used.
Alignment Loss (E-LwF) [20] This method was proposed
It aims to match the softmax
on classiﬁcation networks.

Figure 3: Illustration of semantic drift compensation. (a) Data and prototypes of three classes of task 1 after training task 1.
(b) Data of task 2 after training task 1. (c) Drift of data of task 2 while training task 2. This results in a sparse vector ﬁeld of
drift vectors. (d) This vector ﬁeld is used to approximate the drift of the prototypes of task 1.

output of the network of previous models on current data.
Instead, on embedding networks, we constrain the parame-
ters drift by minimizing the distance between the output em-
beddings of image xi during training the current task (zt
i)
with respect to its embedding in the previous task (zt−1
),
similar as [48]. This leads to the following loss:

i

LLwF = (cid:13)

(cid:13)zt

i − zt−1
i

(cid:13)
(cid:13) ,

(4)

where (cid:107).(cid:107) refers to the Frobenius norm.

E-EWC [17] This method was proposed on classiﬁcation
networks to keep the network parameters close to the opti-
mal parameters for the previous task while training the cur-
rent task. This can also be leveraged on embedding net-
works. The function that we minimize in EWC is:

LEW C =

F t−1
p

(θt

p − θt−1
p

)2,

(5)

(cid:88)

p

1
2

where F t−1 is the Fisher information matrix computed after
the previous task t−1 was learned, and the summation goes
over all parameters θp of the network.
E-MAS [1]
This method was proposed to accumulate
an importance measure for each parameter of the network
based on how sensitive the predicted output function is to a
change in this parameter, which can be directly applied to
embeddings. The function that we minimize in MAS is:

LM AS =

Ωp(θt

p − θt−1
p

)2,

(6)

(cid:88)

p

1
2

where Ωp is estimated by the sensitivity of the squared l2
norm of the function output to their changes.

These losses can be added to the metric learning loss to

prevent forgetting while training embeddings continually:

L = LM L + γLC,

(7)

where C ∈ {LwF, EW C, M AS}, γ is trade-off between
the metric learning loss and the other losses.

4. Semantic Drift Compensation

Embeddings suffer from drift when learned in a sequen-
tial manner. When data from previous tasks is not available,
using the original prototype in the NCM usually results in
a performance drop. We aim at reducing the error that drift
causes and propose a drift compensation to update previ-
ously computed prototypes. The main idea is to estimate
the unknown drift according to the known drift of the cur-
rent data during the training of the current task.

4.1. Computation of the Semantic Drift

In Sec. 3.1, we discussed how prototypes of the classes
can be computed for a single task. Here we extend this the-
ory to the continual learning setting. We refer to the pro-
totype mean as µt
cs which is the mean for class cs after
learning task t computed with Eq. 3. Class cs is learned
during task s (we removed the sub-index i from cs
i for con-
ciseness). When t > s we have no access to data of task
s and we cannot compute the true prototype mean (by ap-
plying Eq. 3 again). We call the difference between the true
class mean and the estimate of the class mean the semantic
drift:

(cid:52)s→t

cs = µt

cs − µs

cs,

(8)

Since we cannot compute µt
cs directly we have to ﬁnd al-
ternative ways to approximate the semantic drift (cid:52)s→t
.
cs
We start by proposing a method to compute (cid:52)t−1→t
from
which we can then derive (cid:52)s→t

cs

.

cs

When training task t we do not have access to the data of
task s and therefore we cannot observe how the embeddings
zi, for which yi ∈ C s, drift during training of task t. How-
ever, we can measure the drift of the current data during the
training of task t.

δt−1→t
i

= zt

i − zt−1
i

, yi ∈ C t,

(9)

here we use the notation zt
i to refer to the embedding of
point i after training task t. At the start of training task t we
have access to zt−1
i which is the embedding of data point i
after training task t − 1.

We propose to approximate the semantic drift (cid:52)t−1→t
. We do this by interpo-
cs using:

from the sparse vector ﬁeld δt−1→t
lating this vector ﬁeld at the prototype location µt−1
(cid:80)

cs

i

ˆ(cid:52)t−1→t
cs

=

i [yi ∈ C t] wiδt−1→t
(cid:80)
i [yi ∈ C t] wi

i

,

with

wi = e−

(cid:107)z
t−1
i

t−1

cs (cid:107)2

−µ
2σ2

,

(10)

(11)

where σ is the standard deviation of the Gaussian kernel.

In summary, as shown in Fig. 3, for all data points in task
t we can monitor the semantic drift during the training of
task t. This results in a set of drift vectors δt−1→t
which are
used to compute the semantic drift of all previously learned
prototypes ˆµt−1
. This is done by assigning a weight to the
drift vectors according to their distance to the prototypes,
and computing the prototype drift as a weighted mean of
the nearby drift vectors (with Eq. 10).

cs

i

We can apply the semantic drift compensation (SDC):

ˆµt

cs = µs

cs + ˆ(cid:52)s→s+1
cs

+ ... + ˆ(cid:52)t−1→t

cs

(12)

where total compensation is the sum of the compensations
which where measured during all previous steps. Normally
a recursive scheme would be applied where you update all
previously learned prototypes at each new task:
cs = ˆµt−1

cs + ˆ(cid:52)t−1→t

(13)

ˆµt

cs

.

4.2. Regularized Semantic Drift Compensation

Many approaches to continual learning have focused on
preventing the network from using parameters which were
found to be relevant for previous tasks [1, 17, 20]. Our
method is based on an entirely different approach where
we accept the fact that if we share parameters between the
tasks, and we want all tasks to be able to improve (i.e. back-
propagate) to all these parameters, this will result in a drift
for the previously learned tasks. Approximating this drift
allows us then to compensate for it. Since our approach
applies a different methodology to prevent forgetting, it is
interesting to see if it is complementary to these other meth-
ods. We therefore propose to combine existing methods (E-
LwF, E-EWC and E-MAS) with semantic drift compensa-
tion and will evaluate this in the experimental results.

To provide an illustration of SDC, we conduct experi-
ments on MNIST with a 2-dimensional embedding. We di-
vide the ten classes into two disjoint tasks randomly.
In
Fig. 4 we show examples of the drift vectors which are esti-
mated by SDC in the case of E-FT and E-EWC2. We can see
that the approximated drift vectors improve the locations of
the prototypes to be closer to the correct positions. As a
result, the accuracy of the overall method remains higher
while training new tasks.

2Examples of the other two methods are in the supplemental material

as well as all implementation details and results in tabular form.

Figure 4: Visualization of SDC with E-FT (left) and E-
EWC (right). Top ﬁgures represent the embedding of 5
classes of task 1 after training task 1; middle ones represent
the embedding of another 5 classes of task 2 after training
task 1; bottom ones show the embeddings of both tasks after
training task 2. The saved prototypes of the previous task
(indicated by circle) are corrected by SDC to new positions
(indicated by triangle). Note that the corrected prototypes
are closer to the real mean (indicated by star). The dotted
arrows are the SDC vectors.

5. Experiments

In this section, we follow the protocol for evaluating in-
cremental learning [1, 21, 31]. For the multi-class datasets,
the classes are arranged in a ﬁxed random order. Each
method is trained in a class-incremental way on the avail-
able data and evaluated on the test set. For the evaluation
metric we report: average incremental accuracy [2] which
is the average accuracy of only those classes that have al-
ready been trained. We also report average forgetting [6]
on CIFAR100 and ImageNet-Subset dataset.

Datasets. We have used the following datasets: CUB-
200-2011 [44], Flowers-102 [29], Caltech-101 [11], CI-
FAR100 [19], and ImageNet-Subset containing 100 ran-
domly chosen classes from ImageNet [9]. All are divided by
classes into tasks randomly. CUB-200-2011 has 200 classes
of birds with 11, 788 images in total. Flowers-102 consists

Table 1: Average incremental accuracy for ﬁne-grained
datasets.

CUB-200-2011

Flowers-102

T4

T3

T1

T4

T3

T2

T2

T6

T5

T5

E-Pre
E-Fix

LwF
E-LwF

FT
E-FT
E-FT+SDC

T1
T6
78.5 69.1 62.1 58.1 54.7 52.1 90.9 77.5 77.7 76.1 75.2 73.6
84.1 70.6 61.7 56.9 53.5 50.3 98.2 83.6 82.8 80.1 78.4 76.9
79.7 34.7 23.3 17.5 12.6 11.4 99.1 43.9 32.2 24.2 18.8 15.3
84.1 73.6 62.5 54.2 43.0 37.4 98.2 76.0 59.3 50.2 42.4 29.1
84.1 75.5 69.5 63.6 57.5 49.3 98.2 85.5 74.1 61.9 49.8 35.3
79.7 54.8 40.8 33.7 27.0 23.6 99.1 69.7 67.4 60.0 49.9 46.6
84.1 74.0 64.8 60.0 55.5 51.4 98.2 85.3 81.6 77.2 69.3 63.5
E-LwF+SDC 84.1 74.4 65.9 61.3 57.3 52.7 98.2 86.1 82.2 79.6 74.7 69.7
79.7 43.4 26.6 20.0 15.5 12.6 99.1 65.2 40.9 33.8 23.7 22.1
84.1 73.6 65.0 61.6 55.0 54.2 98.2 86.2 84.9 82.9 80.9 79.6
E-EWC+SDC 84.1 74.8 67.4 62.8 58.2 56.4 98.2 87.6 86.9 86.0 84.2 83.9
79.7 49.4 37.8 31.4 25.0 22.3 99.1 71.1 61.3 57.9 52.1 44.8
84.1 72.5 65.1 60.4 54.7 51.9 98.2 82.9 79.1 76.6 73.9 70.9
E-MAS+SDC 84.1 71.9 65.3 61.1 57.3 54.4 98.2 83.1 80.7 78.8 76.8 76.0

EWC
E-EWC

MAS
E-MAS

of 102 ﬂower categories of which we randomly choose 100
with 8189 images in total. CIFAR100 contains 600 images
for each class. ImageNet-Subset has 129, 156 images in to-
tal. Caltech-101 composes of images of objects belonging
to 101 widely varied categories.
Implementation Details.
All models are implemented
with Pytorch. Adam [16] is used for the optimization.
ResNet-18 [12] is adopted as the backbone network pre-
trained from ImageNet for CUB-200-20113 and Flowers-
102.
For CIFAR100 and ImageNet-Subset version of
ResNet-32 and ResNet-18 were used respectively, as in
[15], but without pre-training. A triplet loss [13] is used in
all reported experiments4. The training images (all resized
to 256 × 256, except for CIFAR100 to 32 × 32) are ran-
domly cropped and ﬂipped. We use a mini-batch size of 32.
We train our models with learning rate 1e−5 for 50 epochs
on CUB-200-2011, 1e−4 for 20 on Flowers-102, and 1e−6
for 50 on CIFAR100 and ImageNet-Subset. The ﬁnal em-
beddings of 512 dimensions are normalized. The trade-off
between the E-LwF, E-EWC, E-MAS and triplet loss is 1,
1e7 and 1e6 respectively. We choose a ﬁxed σ = 0.3 to
compute the weights of the SDC vectors for all datasets,
except for CIFAR100 we choose σ = 0.2.

5.1. Classiﬁcation with Embedding Networks

To evaluate the effectiveness of our method, we con-
duct experiments on two ﬁne-grained datasets: CUB-200-
2011 and Flowers-1025 on the six-task scenario. Results
are shown in Table 1. Here we analyze the average results
after training the last task (T6).

When comparing the various methods to prevent forget-
ting trained with softmax (LwF/EWC/MAS) to those ap-
plied on embedding network (E-LwF/E-EWC/E-MAS), we

Figure 5: Impact of SDC on the distance between real-mean
and prototypes for CUB-200-2011 dataset over tasks. Each
line represents a single class. Bold lines represent the mean
value of all classes. The graph conﬁrms that SDC correctly
compensates for part of the drift of the prototypes.

Figure 6: Average incremental accuracy. Comparison of
ten-task on CUB-200-2011 (100 classes) and Caltech-101.

observe an enormous gain in performance, showing that
embedding networks are less prone to catastrophic forget-
ting. We also add results for NME on the pre-trained Im-
ageNet model (E-Pre) and the model ﬁxed after training
the ﬁrst task (E-Fix). We can see the best overall accuracy
with SDC on two datasets all outperform these two base-
lines. Furthermore, it can be seen that E-LwF, E-EWC and
E-MAS outperform E-FT on both datasets. For example E-
EWC obtains a gain of 16.8% on birds and of 50.5% on
ﬂowers. The performance of all three methods to prevent
forgetting is comparable. Next, we can observe that SDC
improves the results of all methods even further, especially
for E-FT with 11.9% on birds and 6.2% on ﬂowers. Fi-
nally, it is interesting to observe that simple ﬁnetuning on
embedding networks (E-FT) obtains superior results than
LwF, EWC and MAS on birds. When further combined
with semantic drift compensation, it further improves over
these methods.

3Results on CUB-200-2011 pretrained from ImageNet without birds do

not change much, as shown in the supplemental material.

4The results of using Multi-similarity [43] and Angular [42] loss func-
tions are in the supplementary material. Multi-similarity loss improves per-
formance on the ﬁrst task, but obtain similar results for longer sequences.

5Results on Cars-196 are shown in the supplemental material.

To further analyze if SDC prevents the drift of proto-
types, we measure the average distance between the real
class-mean and the prototypes (before and after application
of SDC). The results are provided in Fig. 5. We observe that
SDC reduces the drift of the prototypes.

Figure 7: Comparison of average incremental accuracy and average forgetting with eleven-task setting on CIFAR100 and
ImageNet-Subset dataset. Solid lines present non-exemplar based methods, dash lines present exemplar based methods.

5.2. Comparison to State-of-the-Art Methods

Ten-task IL on CUB-200 and Caltech-101
To eval-
uate SDC for longer sequences and compare to Learn-
ing without Memorization (LwM), we follow the setting
from [10] and conducted experiments on CUB-200 (100
classes) and Caltech-101, where classes are divided ran-
domly into ten equal tasks. Fig. 6 shows the comparison
with FT(softmax), LwM [10], Expert Gate [2], the upper
bound of joint training, and our best overall methods E-
MAS and E-MAS+SDC. We obtain a clear superiority on
both datasets. Interestingly, E-MAS already obtains 21.2%
and 29.0% higher than the recent LwM method respectively
on these two datasets after training 10 tasks. Applying our
SDC method further improves the gain further with 6.4%
on CUB-200-2011 and 1.4% on Caltech-101.

Experiments on CIFAR100 and ImageNet-Subset
the eleven-task evaluation protocol for class-
In [15],
incremental learning was used, where the ﬁrst task consists
of half of the available classes and the rest is split in 10 tasks
equally. Average forgetting is deﬁned in [6] to estimate
the forgetting of previous tasks. They quantify forgetting
for the j−th task f k
(al,j − ak,j), ∀j < k,

j = max

l∈1,...,k−1

where anm is the accuracy of task n after training task
m. The average forgetting at k−th task is written as
Fk = 1
k−1

j=1 f k
j .

(cid:80)k−1

For the CIFAR100 results of average incremental accu-
racy and average forgetting are presented in Fig.7. Three
groups of methods are shown: non-exemplar based (FT,
LwF, EWC, MAS, E-MAS+SDC), exemplar based (iCaRL-
CNN [31], iCaRL-NME [31], Rebalance [15]), and joint
training. From the average incremental accuracy, we can
see that our overall best method E-EWC+SDC beats all the
other non-exemplar based methods by a large margin, with
a minimal gap of 27.6% compared to EWC. It also sur-
passes two exemplar based methods, namely iCaRL-CNN
and iCaRL-NME [31], by 7.1% and 1.1%. To compare the
preventing forgetting capability, we show the performance
of our method and exemplar based methods in terms of av-
erage forgetting metric in Fig.7. Our method (in red) suf-
fers from less forgetting than all the exemplar based meth-

ods, obtaining a 13.9% gain over the best exemplar method
(Rebalance [15]). Experiments on ImageNet-Subset outper-
form all the non-exemplar based methods and two exemplar
based methods as well in Fig.7. The conclusion is consistent
with CIFAR100 on average incremental accuracy, 35.0%
higher than LwF and 15.5% higher than iCaRL-CNN and
2.5% higher than iCaRL-NME. For average forgetting, our
method has 3.5% less forgetting than Rebalance method.

Finally, we also ran ﬁxing the network after ﬁnetun-
ing on task one for both datasets. The results are 46.3%
for CIF AR100 and 50.5% on ImageN et − Sub. This
shows that currently for these difﬁcult multitask settings,
methods without exemplars do not signiﬁcantly outperform
this baseline; even some methods with exemplars such as
iCaRL-CNN and iCaRL-NME fail on that. This is partially
due to the large number of classes in task 1, if we would
focus on the performance on the continually learned tasks
(2-end) these methods would still report a clear advantage
(also see supplementary materials).

6. Conclusions

The dramatic effect of forgetting when applying ﬁnetun-
ing, as observed on classiﬁcation networks, is much less
pronounced for embedding networks. This suggest that the
current dominance of softmax based methods in continual
learning needs to be revisited and our results advocate the
usage of embedding networks instead. Furthermore, we
proposed a method to approximate the semantic drift of pro-
totypes during training of new tasks. The method is comple-
mentary to several existing methods for incremental learn-
ing originally designed for classiﬁcation networks. Exper-
iments show that our method consistently improves results
when combined with existing approaches.
Acknowledgement We acknowledge the support from
Huawei Kirin Solution, the Industrial Doctorate Grant 2016
DI 039 of the Generalitat de Catalunya, the EU Project
CybSpeed MSCA-RISE-2017-777720, EU’s Horizon
2020 programme under
the Marie Sklodowska-Curie
grant agreement No.6655919 and the Spanish project
RTI2018-102285-A-I00, National Key Laboratory on
Blind Signal Processing under grant No.61424131903.

References

[1] R. Aljundi, F. Babiloni, M. Elhoseiny, M. Rohrbach, and
T. Tuytelaars. Memory aware synapses: Learning what (not)
to forget. In ECCV, pages 139–154, 2018. 2, 5, 6

[2] R. Aljundi, P. Chakravarty, and T. Tuytelaars. Expert gate:
Lifelong learning with a network of experts. In CVPR, pages
3366–3375, 2017. 2, 4, 6, 8
[3] E. Belouadah and A. Popescu.

Il2m: Class incremental
learning with dual memory. In Proceedings of the IEEE In-
ternational Conference on Computer Vision, pages 583–592,
2019. 2

[4] J. Bromley, I. Guyon, Y. LeCun, E. S¨ackinger, and R. Shah.
Signature veriﬁcation using a ”siamese” time delay neural
network. In NIPS, pages 737–744, 1994. 3

[5] F. M. Castro, M. J. Mar´ın-Jim´enez, N. Guil, C. Schmid, and
K. Alahari. End-to-end incremental learning. Lecture Notes
in Computer Science (including subseries Lecture Notes in
Artiﬁcial Intelligence and Lecture Notes in Bioinformatics),
11216 LNCS:241–257, 2018. 2, 4

[6] A. Chaudhry, P. K. Dokania, T. Ajanthan, and P. H. Torr. Rie-
mannian walk for incremental learning: Understanding for-
getting and intransigence. In ECCV, pages 532–547, 2018.
2, 4, 6, 8

[7] W. Chen, X. Chen, J. Zhang, and K. Huang. Beyond triplet
loss: a deep quadruplet network for person re-identiﬁcation.
In CVPR, pages 403–412, 2017. 3

[8] S. Chopra, R. Hadsell, and Y. LeCun. Learning a similarity
metric discriminatively, with application to face veriﬁcation.
In CVPR, volume 1, pages 539–546. IEEE, 2005. 2, 3
[9] J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei-
Fei. Imagenet: A large-scale hierarchical image database. In
CVPR, pages 248–255. Ieee, 2009. 6

[10] P. Dhar, R. V. Singh, K.-C. Peng, Z. Wu, and R. Chellappa.
Learning without memorizing. In CVPR, pages 5138–5146,
2019. 2, 8

[11] L. Fei-Fei, R. Fergus, and P. Perona. Learning generative
visual models from few training examples: An incremental
bayesian approach tested on 101 object categories. In CVPR
workshop, pages 178–178. IEEE, 2004. 6

[12] K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learning
for image recognition. In CVPR, pages 770–778, 2016. 7,
11

[13] E. Hoffer and N. Ailon. Deep metric learning using triplet
In International Workshop on Similarity-Based

network.
Pattern Recognition, pages 84–92. Springer, 2015. 3, 4, 7

[14] S. Horiguchi, D. Ikami, and K. Aizawa. Signiﬁcance of
softmax-based features in comparison to distance metric
learning-based features. IEEE Trans. on PAMI, 2019. 4
[15] S. Hou, X. Pan, C. C. Loy, Z. Wang, and D. Lin. Learning
a uniﬁed classiﬁer incrementally via rebalancing. In CVPR,
pages 831–839, 2019. 2, 4, 7, 8, 11

[16] D. P. Kingma and J. Ba. Adam: A method for stochastic

optimization. ICLR, 2014. 7

[17] J. Kirkpatrick, R. Pascanu, N. Rabinowitz, J. Veness, G. Des-
jardins, A. A. Rusu, K. Milan, J. Quan, T. Ramalho,
A. Grabska-Barwinska, et al. Overcoming catastrophic for-
getting in neural networks. Proc. Nat. Acad. Sci. USA, page
201611835, 2017. 1, 2, 4, 5, 6, 11

[18] J. Krause, M. Stark, J. Deng, and L. Fei-Fei. 3d object rep-
resentations for ﬁne-grained categorization. In IEEE Inter-
national Conference on Computer Vision Workshops, pages
554–561, 2013. 11

[19] A. Krizhevsky, G. Hinton, et al. Learning multiple layers of
features from tiny images. Technical report, Citeseer, 2009.
6

[20] Z. Li and D. Hoiem. Learning without forgetting.
Trans. on PAMI, 40(12):2935–2947, 2018. 1, 2, 4, 6

IEEE

[21] X. Liu, M. Masana, L. Herranz, J. Van de Weijer, A. M.
Lopez, and A. D. Bagdanov. Rotate your networks: Bet-
ter weight consolidation and less catastrophic forgetting. In
Proc. ICPR, 2018. 2, 4, 6, 11

[22] D. Lopez-Paz and M. Ranzato. Gradient episodic memory

for continual learning. In NIPS, pages 6467–6476, 2017. 2

[23] A. Mallya, D. Davis, and S. Lazebnik. Piggyback: Adapt-
ing a single network to multiple tasks by learning to mask
weights. In ECCV, pages 67–82, 2018. 2

[24] A. Mallya and S. Lazebnik. Packnet: Adding multiple tasks
In CVPR, pages

to a single network by iterative pruning.
7765–7773, 2018. 2

[25] M. Masana, I. Ruiz, J. Serrat, J. van de Weijer, and A. M.
Lopez. Metric learning for novelty and anomaly detection.
In BMVC, 2018. 3

[26] M. Masana, T. Tuytelaars, and J. van de Weijer. Ternary fea-
ture masks: continual learning without any forgetting. arXiv
preprint arXiv:2001.08714, 2020. 2

[27] M. McCloskey and N. J. Cohen. Catastrophic interference
in connectionist networks: The sequential learning problem.
In Psychology of learning and motivation, volume 24, pages
109–165. Elsevier, 1989. 1

[28] T. Mensink, J. Verbeek, F. Perronnin, and G. Csurka.
Distance-based image classiﬁcation: Generalizing to new
IEEE Trans. on PAMI,
classes at near-zero cost.
35(11):2624–2637, 2013. 2

[29] M.-E. Nilsback and A. Zisserman. Automated ﬂower clas-
siﬁcation over a large number of classes. In Computer Vi-
sion, Graphics and Image Processing, pages 722–729. IEEE,
2008. 6

[30] J. Rajasegaran, M. Hayat, S. H. Khan, F. S. Khan, and
L. Shao. Random path selection for continual learning. In
Advances in Neural Information Processing Systems, pages
12648–12658, 2019. 3

[31] S.-A. Rebufﬁ, A. Kolesnikov, G. Sperl, and C. H. Lampert.
icarl: Incremental classiﬁer and representation learning. In
CVPR, pages 5533–5542. IEEE, 2017. 1, 2, 4, 6, 8

[32] O. Rippel, M. Paluri, P. Dollar, and L. Bourdev. Metric learn-

ing with adaptive density discrimination. In ICLR, 2016. 3

[33] A. A. Rusu, N. C. Rabinowitz, G. Desjardins, H. Soyer,
J. Kirkpatrick, K. Kavukcuoglu, R. Pascanu, and R. Had-
arXiv preprint
sell.
arXiv:1606.04671, 2016. 2

Progressive neural networks.

[34] F. Schroff, D. Kalenichenko, and J. Philbin. Facenet: A uni-
ﬁed embedding for face recognition and clustering. In CVPR,
pages 815–823, 2015. 2

[35] T. Scott, K. Ridgeway, and M. C. Mozer. Adapted deep em-
beddings: A synthesis of methods for k-shot inductive trans-
fer learning. In NIPS, pages 76–85, 2018. 3

[36] J. Serra, D. Suris, M. Miron, and A. Karatzoglou. Overcom-
ing catastrophic forgetting with hard attention to the task. In
ICML, pages 4555–4564, 2018. 2

[37] H. Shin, J. K. Lee, J. Kim, and J. Kim. Continual learn-
ing with deep generative replay. In NIPS, pages 2990–2999,
2017. 2, 4

[38] K. Simonyan and A. Zisserman. Very deep convolutional
networks for large-scale image recognition. arXiv preprint
arXiv:1409.1556, 2014. 11

[39] J. Snell, K. Swersky, and R. Zemel. Prototypical networks

for few-shot learning. In NIPS, pages 4077–4087, 2017. 3

[40] G. M. van de Ven and A. S. Tolias. Three scenarios for con-

tinual learning. arXiv preprint arXiv:1904.07734, 2019. 2

[41] J. Wang, Y. Song, T. Leung, C. Rosenberg, J. Wang,
J. Philbin, B. Chen, and Y. Wu. Learning ﬁne-grained image
similarity with deep ranking. In CVPR, pages 1386–1393,
2014. 3

[42] J. Wang, F. Zhou, S. Wen, X. Liu, and Y. Lin. Deep met-
ric learning with angular loss. In ICCV, pages 2612–2620.
IEEE, 2017. 2, 3, 7, 11

[43] X. Wang, X. Han, W. Huang, D. Dong, and M. R. Scott.
Multi-similarity loss with general pair weighting for deep
In CVPR, pages 5022–5030, 2019. 3, 7,
metric learning.
11

[44] P. Welinder, S. Branson, T. Mita, C. Wah, F. Schroff, S. Be-
longie, and P. Perona. Caltech-UCSD Birds 200. Technical
Report CNS-TR-2010-001, California Institute of Technol-
ogy, 2010. 6

[45] C. Wu, L. Herranz, X. Liu, Y. Wang, J. van de Weijer, and
B. Raducanu. Memory replay gans: learning to generate im-
ages from new categories without forgetting. In NIPS, 2018.
2, 4

[46] Y. Wu, Y. Chen, L. Wang, Y. Ye, Z. Liu, Y. Guo, and Y. Fu.
Large scale incremental learning. In CVPR, 2019. 2, 4
[47] H.-M. Yang, X.-Y. Zhang, F. Yin, and C.-L. Liu. Robust clas-
siﬁcation with convolutional prototype learning. In CVPR,
pages 3474–3482, 2018. 3

[48] L. Yu, V. O. Yazici, X. Liu, J. Van de Weijer, Y. Cheng, and
A. Ramisa. Learning metrics from teachers: Compact net-
In Proceedings of the IEEE
works for image embedding.
Conference on Computer Vision and Pattern Recognition,
pages 2907–2916, 2019. 5

[49] F. Zenke, B. Poole, and S. Ganguli. Continual learning
through synaptic intelligence. In ICML, pages 3987–3995.
JMLR. org, 2017. 2

Appendices

A. Visualization of E-LwF and E-MAS

In Fig. 8 we show examples of the drift vectors which
are estimated by SDC in the case of E-LwF and E-MAS to
supplement Fig. 4 in the main paper.

B. Pre-trained Model without Birds

The results presented in Table. 1 in the main paper are
based on ResNet18 pre-trained from the ImageNet dataset.
As some of the categories of birds are present in the Ima-
geNet, we conducted additional experiments. We removed
59 classes in total form the original dataset, including birds
(e.g. macaw, ﬂamingo, black swan) and similar species
(e.g. cock, hen, king penguin), and then trained ResNet18
network on the constrained dataset. Table. 2 shows the aver-
age incremental accuracy results pre-trained from ImageNet
without birds. It can be seen that there is no signiﬁcant dif-
ference with ﬁne-tuning, while slightly worse with the other
three methods compared to Table. 1, where bird categories
were used in the pre-trained network.

C. Results with Multi-similarity Loss and An-

gular Loss

A triplet loss is used in the main paper as a default met-
ric loss function. Additionally, we investigated two newer
versions of metric losses: Multi-similarity [43] and Angu-
lar loss [42] on CUB-200-2011 with a class-IL setting. The
results are shown in Table. 3. We can see that the accuracy
for the ﬁrst task with the angular loss is 5.0% lower than for
the triplet loss, while the multi-similarity starts with 4.0%
higher accuracy. For E-FT method, a multi-similarity loss
can achieve much better average incremental accuracy after
training six tasks with a 13.3% improvement compared to
the triplet loss. It is interesting to note that after adding our
SDC, it achieves 56.1% after the ﬁnal task, which is even
better than other methods with regularization and SDC ex-
cept for E-EWC+SDC. For the angular loss E-FT and E-
FT+SDC present slightly lower results in comparison to the
others regularized and regularized with SDC methods. De-
spite addressing some of the triplet loss function shortcom-
ings, both of new losses obtain similar results for class-IL
to the triplet loss used for all experiments in the main paper.

D. Confusion Matrix

We show confusion matrix of CUB-200-2011 and
Flowers-102 dataset with Fine-tuning respectively in Fig. 9,
for further insight of our SDC method. The left ﬁgures are
the confusion matrices before applying SDC, the right ones
are after applying SDC. We can see that our SDC method

Table 2: Average incremental accuracy for CUB-200-2011
datasets with constrained pre-trained ImageNet.

Pre-trained ImageNet
(w/o birds)
FT
E-FT
LwF
E-LwF
EWC
E-EWC
MAS
E-MAS

T1

T2

T3

T4

T5

T6

79.1
86.3
79.1
86.3
79.1
86.3
79.1
86.3

33.5
74.6
51.7
76.4
37.8
73.9
44.5
73.2

23.2
63.2
37.0
67.7
27.3
63.2
32.1
61.1

17.3
54.8
28.7
60.1
18.0
59.0
27.2
55.9

14.3
43.8
24.8
55.7
14.6
53.4
23.2
51.1

10.0
37.5
19.5
50.8
10.2
50.7
19.4
48.6

is able to compensate the forgetting of the previous tasks to
some extent.

E. Experiments on VGG

To be able to compare our method to R-EWC and vali-
date its generalization ability, we follow the protocol of Liu
et al. [21] and implement our method on a VGG16 [38]. The
CUB-200 dataset is divided into four equal tasks; the same
setting as in Table.1. The comparison of different methods
is shown in Fig. 10. We can see that our E-EWC surpasses
EWC [17] and R-EWC [21] with clear superiority, improv-
ing with 30.1% and 22.1% respectively. SDC contributes
an additional 1.6% gain.

F. Classiﬁcation with Embedding Networks on

Cars-196 Dataset

Cars-196 dataset [18] contains 16, 185 images of 196
cars classes. ResNet-18 [12] is adopted as the backbone
network pretrained from ImageNet for Cars-196 dataset as
well. We train our model with learning rate 1e−5 for 100
epochs on cars, the other settings are the same as birds and
ﬂowers. Results are shown in Table. 4 after training the last
task (T6). The conclusion is consistent with the CUB-200
and Flowers-102 datasets.

G. Experiments on CIFAR100 and ImageNet-

Subset

We show the details of the average accuracy of our
methods on CIFAR100 and ImageNet-Subset followed by
the eleven-task evaluation protocol [15] in Table 5 (E-
EWC+SDC is shown in Fig. 7 in the main paper). Batch
nomalization is ﬁxed after training the ﬁrst task. It can be
seen that E-LwF, E-EWC and E-MAS outperform E-FT on
both datasets. Also we can observe that SDC improves the
results of all methods even further except for E-LwF, es-
pecially for E-FT with 7.4% on CIFAR100, and 3.5% on
ImageNet-Subset. Essentially, E-EWC and E-MAS indi-
rectly limit the drift of the embedding by constraining the

(a)

(b)

(c)

(d)

(e)

(f)

Figure 8: Examples of the drift vectors in the cases of E-LWF (top) and E-MAS (bottom). (a) and (d) represent the embedding
of 5 classes of task 1 after training task 1; (b) and (e) represent the embedding of another 5 classes of task 2 after training task
1; (c) and (f) show the embeddings of 10 classes of two tasks together. The saved prototypes of the previous task(indicated
by round) are estimated to new positions (indicated by triangle) by our proposed SDC in the new model which is observed to
be closer to the real mean (indicated by star). The dotted arrows are the SDC vectors.

Table 3: Average incremental accuracy for CUB-200-2011 datasets with Multi-similarity and Angular loss loss.

Multi-similarity

E-FT
E-FT+SDC
E-LwF
E-LwF+SDC
E-EWC

T1
88.1
88.1
88.1
88.1
88.1
E-EWC+SDC 88.1
88.1
E-MAS+SDC 88.1

E-MAS

T2
74.4
76.4
74.3
74.7
75.2
76.5
74.9
76.1

T3
65.5
69.9
66.5
66.9
66.3
67.9
64.9
66.8

T4
59.8
63.0
61.6
61.3
62.0
64.0
59.9
63.0

T5
52.2
59.5
56.6
57.4
55.2
60.4
54.1
58.6

T6
50.7
56.1
50.9
51.5
52.9
57.7
51.2
55.7

T1
79.1
79.1
79.1
79.1
79.1
79.1
79.1
79.1

T2
61.7
65.8
70.8
69.6
66.3
67.7
68.0
67.9

Angular
T4
T3
48.1
50.9
53.4
57.6
56.0
61.9
55.5
60.6
53.4
57.5
55.5
59.9
54.1
59.1
56.5
60.8

T5
40.9
49.6
50.9
51.2
48.3
51.2
46.4
52.0

T6
40.5
45.5
45.4
46.6
44.6
48.6
46.4
49.0

important weights, whereas E-LwF is directly constraining
the embedding, which in the end results in less drift.

As discussed in the main paper, the good results of E-
Fix for these more difﬁcult datasets shows that continual

learning methods without exemplars have difﬁculty outper-
forming this baseline (and even some methods which use
exemplars like iCaRL). In Fig. 11 we also show the accu-
racy of each task after training the eleven tasks for E-Fix

(a)

(b)

(c)

(d)

Figure 9: Confusion matrix of CUB-200-2011 and Flowers-102 with Fine-tuning method before applying SDC (a, c) and
after applying SDC (b, d).

(in cyan) and E-EWC (in red). We can see that E-EWC al-
ways outperforms E-Fix except for the ﬁrst task. It means
even though the average accuracy of the eleven tasks with
E-Fix and E-EWC is similar, freezing the ﬁrst model does
not have any positive forward transfer.

Figure 10: Comparison of four-task with VGG16 network.

Table 4: Average incremental accuracy for Cars-196
dataset.

E-Pre
E-Fix

FT
E-FT
E-FT+SDC

LwF
E-LwF
E-LwF+SDC

EWC
E-EWC
E-EWC+SDC

MAS
E-MAS
E-MAS+SDC

T1
44.0
58.2
67.5
58.2
58.2
67.5
58.2
58.2
67.5
58.2
58.2
67.5
58.2
58.2

T2
34.5
45.9
33.0
44.8
50.3
40.3
48.2
47.2
30.8
47.0
48.1
37.1
46.3
46.3

Cars-196
T4
T3
24.8
27.4
33.8
38.6
19.6
24.2
30.2
34.7
34.0
41.8
30.1
33.3
36.2
40.9
36.8
41.8
19.9
25.8
35.1
39.6
36.4
40.9
22.9
27.7
33.6
38.3
34.0
39.0

T5
23.5
32.1
15.0
23.6
25.4
26.7
34.2
35.4
16.5
32.9
34.0
20.2
31.4
31.8

T6
22.3
30.5
13.6
17.3
18.2
21.9
32.0
33.9
15.6
30.7
32.2
17.0
28.8
30.7

CIFAR100
T11
46.3
37.4
44.8
46.1
46.1
40.8
46.1
43.1
46.3

ImageNet-Subset
T11
50.5
47.4
50.9
51.5
50.5
49.5
51.5
50.8
51.2

E-Fix
E-FT
E-FT+SDC
E-LwF
E-LwF+SDC
E-EWC
E-EWC+SDC
E-MAS
E-MAS+SDC

Table 5: Average incremental accuracy for CIFAR100 and
ImageNet-Subset.

Figure 11: Accuracy of each of the eleven tasks with E-Fix
and after training all tasks with E-EWC on CIFAR100 and
ImageNet-Subset dataset.

