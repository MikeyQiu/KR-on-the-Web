Translations as Additional Contexts for Sentence Classiﬁcation

Reinald Kim Amplayo†, Kyungjae Lee†, Jinyeong Yeo‡ and Seung-won Hwang†
†Yonsei University, Seoul, South Korea
‡Pohang University of Science and Technology, Pohang, South Korea
{rktamplayo, lkj0509, seungwonh}@yonsei.ac.kr jinyeo@postech.edu

8
1
0
2
 
n
u
J
 
4
1
 
 
]
L
C
.
s
c
[
 
 
1
v
6
1
5
5
0
.
6
0
8
1
:
v
i
X
r
a

Abstract

In sentence classiﬁcation tasks, additional contexts,
such as the neighboring sentences, may improve
the accuracy of the classiﬁer. However, such con-
texts are domain-dependent and thus cannot be
used for another classiﬁcation task with an inappro-
priate domain. In contrast, we propose the use of
translated sentences as domain-free context that is
always available regardless of the domain. We ﬁnd
that naive feature expansion of translations gains
only marginal improvements and may decrease the
performance of the classiﬁer, due to possible inac-
curate translations thus producing noisy sentence
vectors. To this end, we present multiple context
ﬁxing attachment (MCFA), a series of modules at-
tached to multiple sentence vectors to ﬁx the noise
in the vectors using the other sentence vectors as
context. We show that our method performs com-
petitively compared to previous models, achiev-
ing best classiﬁcation performance on multiple data
sets. We are the ﬁrst to use translations as domain-
free contexts for sentence classiﬁcation.

1 Introduction
One of the primary tasks in natural language processing
(NLP) is sentence classiﬁcation, where given a sentence (e.g.
a sentence of a review) as input, we are tasked to classify it
into positive or negative).
into one of multiple classes (e.g.
This task is important as it is widely used in almost all sub-
areas of NLP such as sentiment classiﬁcation for sentiment
analysis [Pang and Lee, 2007] and question type classiﬁcation
for question answering [Li and Roth, 2002], to name a few.
While past methods require feature engineering, recent meth-
ods enjoy neural-based methods to automatically encode the
sentences into low-dimensional dense vectors [Kim, 2014;
Joulin et al., 2017]. Despite the success of these methods, the
major challenge in this task is that extracting features from a
single sentence limits the performance.

To overcome this limitation, recent works attempted to
augment different kinds of features to the sentence, such as
the neighboring sentences [Lin et al., 2015] and the topics
of the sentences [Zhao et al., 2017]. However, these meth-
ods used domain-dependent contexts that are only effective

Figure 1: PCA visualizations of unaltered sentence vectors on TREC
data set, where each language is effective for a speciﬁc class, high-
lighted using a yellow circle.

when the domain of the task is appropriate. For one thing,
neighboring sentences may not be available in some tasks
such as question type classiﬁcation. Moreover, topics inferred
using topic models may produce less useful topics when the
data set is domain-speciﬁc such as movie review sentiment
classiﬁcation [Mimno et al., 2011].

In this paper, we propose the usage of translations as com-
pelling and effective domain-free contexts, or contexts that
are always available no matter what the task domain is. We
observe two opportunities when using translations.

First, each language has its own linguistic and cultural
characteristics that may contain different signals to effec-
tively classify a speciﬁc class. Figure 1 contrasts the sentence
vectors of the original English sentences and their Arabic-
translated sentences in the question type classiﬁcation task. A
yellow circle signiﬁes a clear separation of a class. For exam-
ple, the green class, or the numeric question type, is circled in
the Arabic space as it is clearly separated from other classes,
while such separation cannot be observed in English. Mean-
while, location type questions (in orange) are better classiﬁed
in English.
Second,

the original sentences may include language-
speciﬁc ambiguity, which may be resolved when presented
with its translations. Consider the example English sentence
“The movie is terribly amazing” for the sentiment classiﬁca-
tion task. In this case, terribly can be used in both positive
and negative sense, thus introduces ambiguity in the sentence.
When translated to Korean, it becomes “영화는 대단히 훌
륭합니다” which means “The movie is greatly magniﬁcent”,
removing the ambiguity.

The above two observations hold only when translations
are supported for (nearly) arbitrary language pairs with suf-
ﬁciently high quality. Thankfully, translation services (e.g.

Figure 2: PCA visualizations of unaltered sentence vectors (left) and
the corresponding MCFA-altered vectors (right) on the MR data set.
d is the Mahalanobis distance between the two class clusters.

Google Translate) Moreover, recent research on neural ma-
chine translation (NMT) [Bahdanau et al., 2014] improved
the efﬁciency and even enabled zero-shot translation [John-
son et al., 2016] of models for languages with no parallel
data. This provides an opportunity to leverage on as many
languages as possible to any domain, providing a much wider
context compared to the limited contexts provided by past
studies.

However, despite the maturity of translation, naively con-
catenating their vectors to the original sentence vector may
introduce more noise than signals. The unaltered translation
space on the left of Figure 2 shows an example where trans-
lation noises make the two classes indistinguishable.

In this paper, we propose a method to mitigate the possible
problems when using translated sentences as context based on
the following observations. Suppose there are two translated
sentences a and b with slight errors. We posit that a can be
used to ﬁx b when a is used as a context of b, and vice versa1.
Revisiting the example above, to ﬁx the vector of the English
sentence “The movie is terribly amazing”, we use the Korean
translation to move the vector towards the location where the
vector “The movie is greatly magniﬁcent” is.

Based on these observations, we present a neural attention-
based multiple context ﬁxing attachment (MCFA). MCFA is a
series of modules that uses all the sentence vectors (e.g. Ara-
bic, English, Korean, etc.) as context to ﬁx a sentence vector
(e.g. Korean). Fixing the vectors is done by selectively mov-
ing the vectors to a location in the same vector space that
better separates the class, as shown in Figure 2. Noises from
translation may cause adverse effects to the vector itself (e.g.
when a noisy vector is directly used for the task) and rela-
tively to other vectors (e.g. when a noisy vector is used to
ﬁx another noisy vector). MCFA computes two sentence us-
ability metrics to control the noise when ﬁxing vectors: (a)
self usability ρi(a) weighs the conﬁdence of using sentence
a in solving the task. (b) relative usability ρr(a, b) weighs
the conﬁdence of using sentence a in ﬁxing sentence b.

Listed below are the three main strengths of the MCFA
attachment.
(1) MCFA is attached after encoding the sen-
tence, which makes it widely adaptable to other models. (2)
MCFA is extensible and improves the accuracy as the num-
ber of translated sentences increases. (3) MCFA moves the
vectors inside the same space, thus preserves the meaning of
vector dimensions. Results show that a convolutional neural
network (CNN) attached with MCFA signiﬁcantly improves
the classiﬁcation performance of CNN, achieving state of the

1Hereon, we mean to “ﬁx” as to “correct, repair, or alter.”

art performance over multiple data sets.

2 Preliminaries

2.1 Problem: Translated Sentences as Context

In this paper, the ultimate task that we solve is the sentence
classiﬁcation task where given a sentence and a list of classes,
one is task to classify which class (e.g. positive or negative
sentiment) among the list of classes does the sentence belong.
However, the main challenge that we tackle is the task on how
to utilize translated sentences as additional context in order
to improve the performance of the classiﬁer. Speciﬁcally, the
problem states: given the original sentence s, the goal is to
use t1, t2, ..., tn, or sentences in other languages which are
translated from s, as additional context.
Base Model: Convolutional Neural Network. The base
model used is the convolutional neural network (CNN) for
sentences [Kim, 2014]. It is a simple variation of the origi-
nal CNN for texts [Collobert et al., 2011] to be used on sen-
tences. Let xi ∈ Rd be the d-dimensional word vector of
the i-th word in a sentence of length n. A convolution oper-
ation involves applying a ﬁlter matrix W ∈ Rh×d to a win-
dow of h words and producing a new feature vector ci using
the equation ci = f ([xi; ...; xi+h−1](cid:62)W + b), where b is a
bias vector and f (.) is a non-linear function. By doing this
on all possible windows of words we produce a feature map
c = [c1, c2, ...]. We then apply a max-over-time pooling op-
eration [Collobert et al., 2011] over the feature map and take
the maximum value as the feature vector of the ﬁlter. We
do this on all feature vectors and concatenate all the feature
vectors to obtain the ﬁnal feature vector v. We can then use
this vector as input features to train a classiﬁer such as lo-
gistic regression. We use CNN to create sentence vectors for
all sentences s, t1, t2, ..., tn. From here on, we refer to these
vectors as vs, vt1, vt2, ..., vtn, respectively. We refer to them
collectively as V.
Baseline 1: Naive Concatenation. A simple method in or-
der to use the translated sentences as additional context is
to naively concatenate their vectors with the vector of the
original sentence. That is, we create a wide vector ˆv =
[vs; vt1; ...; vtn ], and use this as the input feature vector of the
sentence to the classiﬁer. This method works ﬁne if the trans-
lated sentences are translated properly. However, sentences
translated using machine translation models usually contain
incorrect translation. In effect, this method will have adverse
effects on the overall performance of the classiﬁer. This will
especially be very evident if the number of additional sen-
tences increases.
Baseline 2: L2 Regularization.
In order to alleviate the
problems above, we can use L2 regularization to automat-
ically select useful features by weakening the appropriate
weights. The main problem of this method occurs when al-
most all of the weights coming from the vectors of the trans-
lated sentence are weakened. This leads to making the addi-
tional context vectors useless and to having a similar perfor-
mance when there are no additional context. Ultimately, this
method does not make use of the full potential of the addi-
tional context.

(a) Self and relative usability modules

(b) Vector ﬁxing module

Figure 3: Full architecture of the MCFA attachment. An arrow marked with a variable is a matrix multiplication of the vector and the variable.
An arrow without a variable simply carries the previous element to the next element.

3 Model
To solve the problems of the baselines discussed above, we
introduce an attention-based neural multiple context ﬁxing at-
tachment (MCFA)2, a series of modules attached to the sen-
tence vectors V. MCFA attachment is used to ﬁx the sentence
vectors, by slightly modifying the per-dimension values of
the vector, before concatenating them into the ﬁnal feature
vector. The sentence vectors are altered using other sentence
vectors as context (e.g. vt1 is altered using vs, vt2 , ..., vtn ).
This results to moving the vectors in the same vector space.
The full architecture is shown in Figure 3.

3.1 Self Usability Module
To ﬁx a source sentence vector3, we use the other sentence
vectors as guide to know which dimensions to ﬁx and to
what extent do we need to ﬁx them. However, other vectors
might also contain errors which may reﬂect to the ﬁxing of the
source sentence vector. In order to cope with this, we intro-
duce self usability modules. A self usability module contains
the self usability of the vector ρi(a), which measures how
conﬁdent sentence a is for the task at hand. For example, an
ambiguous sentence (e.g. “The movie is terribly amazing”)
may receive a low self usability, while a clear and deﬁnite
sentence (e.g. “The movie is very good”) may receive a high
self usability.

Mathematically, we calculate the self usability of the vec-
tor vi of sentence i, denoted as ρi(vi), using the equation
i Ti), where Ti ∈ Rd×1 is a matrix to be
ρi(vi) = σ(v(cid:62)
learned. The produced value is a single real number from
0 to 1. We pre-calculate the self usability of all sentence vec-
tors vi ∈ V. These are used in the next module, the relative
usability module.

3.2 Relative Usability Module
Relative usability ρr(a, b) measures how useful a can be
when ﬁxing b, relative to other sentences. There are two main
differences between ρi(a) and ρr(a, b). First, ρi(a) is cal-
culated before a knows about b while ρr(a, b) is calculated

2The code we use in this paper is publicly shared: https:

//github.com/rktamplayo/MCFA

3Hereon, we say that vk is a source sentence vector if vk

is the current vector to be altered.

(cid:80)

(1)

αi =

when a knows about b. Second, ρr(a, b) can be low even
though ρi(a) is not. This means that a is not able to help in
ﬁxing the wrong information in b. Here, we extend the addi-
tive attention module [Bahdanau et al., 2014] and use it as a
method to calculate the relative usability of two sentences of
different languages. To better visualize the original attention
mechanism, we present the equations below.
i U)

ei = u(cid:62)tanh(s(cid:62)W + t(cid:62)
exp(ei)
j∈T exp(ej)
One major challenge in using the attention mechanism in our
problem is that the sentence vectors do not belong to the same
vector space. Moreover, one characteristic of our problem is
that the sentence vectors can be both a source and a context
vector (e.g. vs can be both s and ti in Equation 1). Because
of these, we cannot directly use the additive attention module.
We extend the module such that (1) each sentence vector vk
has its own projection matrix Xk ∈ Rd×d, and (2) each pro-
jection matrix Xk can be used as projection matrix of both
the source (e.g. when sentence k is the current source) and
the context vectors. Finally, we incorporate the self usability
function ρi(vk) to reﬂect the self usability of a sentence. Ul-
timately, the relative usability denoted as ρr(vi, vj) is calcu-
lated using the equations below, where × is the multiplication
of a vector and a scalar through broadcasting.

(2)

e(vi, vj) = x(cid:62)tanh(v(cid:62)

i Xi + v(cid:62)

j Xj × ρi(vj))

ρr(vi, vj) =

exp(e(vi, vj))
vk∈V exp(e(vi, vk))

(cid:80)

3.3 Vector Fixing Module

(3)

(4)

The vector ﬁxing module applies the attention weights to the
sentence vectors and creates an integrated context vector. We
then use this vector alongside with the source sentence vector
to create a weighted gate vector. The weighted gate vector is
used to determine to what extent should a dimension of the
source sentence vector be altered.

The common way to apply the attention weights to the
context vectors and create an integrated context vector ci
is to directly do weighted sum of all the context vectors.
However, this is not possible because the context vectors
are not on the same space. Thus, we use a projection ma-
trix Uk ∈ Rd×d to linearly project the sentence vector

Data set
MR
SUBJ
CR
TREC

c
2
2
2
6

|w|
20
19
23
10

M
10662
10000
3775
5952

Test
CV
CV
CV
500

Table 1: Statistics of the four data sets used in this paper. c: number
|w|: average number of words. M : number of
of target classes.
data instances. Test: size of the test data, if available. If not, we use
10-fold cross validation (marked as CV) with random split.

k Uk.

vk to transform the sentence vectors into a common vector
space. The integrated context vector ci is then calculated as
ci = (cid:80)

vk∈V ρr(vi, vk)v(cid:62)

Finally, we construct a weighted gate vector wk and use
it to ﬁx the source sentence vectors using the equations be-
low, where Vk ∈ R2d×d is a trainable parameter and ⊗ is the
element-wise multiplication procedure. The weighted gate
vector is a vector of real numbers between 0 and 1 to modify
the intensity of per-dimension values of the sentence vector.
This causes the vector to move in the same vector space to-
wards the correct direction.

wk = σ([vk; ck](cid:62)Vk)
(5)
ˆvk = vk ⊗ wk
(6)
An alternative approach to do vector correction is using a
residual-style correction, where instead of multiplying a gate
vector, a residual vector [He et al., 2016] is added to the orig-
inal vector. However, this approach makes the correction not
interpretable; it is hard to explain what does adding a value to
a speciﬁc dimension mean. One major advantage of MCFA
is that the corrections in the vectors are interpretable; the
weights in the gate vector correspond to the importance of
the per-dimension features of the vector. The altered vectors
ˆvs, ..., ˆvtn are then concatenated and fed directly as an input
vector to the logistic regression classiﬁer for training.

4 Experiments

4.1 Experimental Setting

We test our model on four different data sets as listed below
and summarized in Table 1. (a) MR4 [Pang and Lee, 2005]:
Movie reviews data where the task is to classify whether the
review sentence has positive or negative sentiment. (b) SUBJ
[Pang and Lee, 2004]: Subjectivity data where the task is to
classify whether the sentence is subjective or objective. (c)
CR5 [Hu and Liu, 2004]: Customer reviews where The task is
to classify whether the review sentence is positive or negative.
(d) TREC6 [Li and Roth, 2002]: TREC question data set the
task is to classify the type of question.

All our data sets are in English. For the additional contexts,
we use ten other languages, selected based on their diversity
and their performance on prior experiments: Arabic, Finnish,
French, Italian, Korean, Mongolian, Norwegian, Polish, Rus-
sian, and Ukranian. We translate the data sets using Google

4https://www.cs.cornell.edu/people/pabo/

movie-review-data/

5http://www.cs.uic.edu/∼liub/FBS/sentiment-analysis.

html

Translate. Tokenization is done using the polyglot library7.
We experiment on using only one additional context (N = 1)
and using all ten languages at once (N = 10). For N = 1, we
only show the accuracy of the best classiﬁer for conciseness.
For our CNN, we use rectiﬁed linear units and three ﬁl-
ters with different window sizes h = 3, 4, 5 with 100 feature
maps each, following [Kim, 2014]. For the ﬁnal sentence vec-
tor, we concatenate the feature maps to get a 300-dimension
vector. We use dropout [Srivastava et al., 2014] on all non-
linear connections with a dropout rate of 0.5. We also use an
l2 constraint of 3, following [Kim, 2014] for accurate com-
parisons. We use FastText pre-trained vectors8 [Bojanowski
et al., 2016] for all our data sets and their corresponding ad-
ditional context. During training, we use mini-batch size of
50. Training is done via stochastic gradient descent over shuf-
ﬂed mini-batches with the Adadelta update rule. We perform
early stopping using a random 10% of the training set as the
development set.

We present several competing models, listed below to com-
pare the performance of our model. (A) Aside from the base
model (CNN) [Kim, 2014], we use Dependency-based CNN
(Dep-CNN) [Ma et al., 2015], which parses the sentences
ﬁrst and does convolution on ancestor paths and Dependency-
sensitivity CNN (DSCNN) [Zhang et al., 2016], which uses
LSTM to capture dependency information within each sen-
tence; (B) AdaSent [Zhao et al., 2015] adopts a hierarchi-
cal structure, where consecutive levels are connected through
gated recursive composition of adjacent segments, and feeds
the hierarchy as a multi-scale representation through a gat-
ing network; (C) Topic-aware Convolutional Neural Network
(TopCNN) [Zhao et al., 2017] uses topics as additional con-
texts and changes the CNN architecture. TopCNN uses two
types of topics: word-speciﬁc topic and sentence-speciﬁc
topic; and (D) CNN+B1 and CNN+B2 are the two baselines
presented in this paper.

We do not show results from RNN models because they
were shown to be less effective in sentence classiﬁcation
in our prior experiments. For models with additional con-
text, we further use an ensemble classiﬁcation model using
a commonly used method by averaging the class probability
scores generated by the multiple variants (in our model’s case,
N = 1 and N = 10 models), following [Zhao et al., 2017].

4.2 Results and Discussion
We report the classiﬁcation accuracy of the competing mod-
els in Table 2. We show that CNN+MCFA achieves state of
the art performance on three of the four data sets and performs
competitively on one data set. When N = 1, MCFA increases
the performance of a normal CNN from 85.0 to 87.6, beating
the current state of the art on the CR data set. When N = 10,
MCFA additionally beats the state of the art on the TREC data
set. Finally, our ensemble classiﬁer additionally outperforms
all competing models on the MR data set. We emphasize
that we only use the basic CNN as our sentence encoder for
our experiments, yet still achieve state of the art performance

7https://pypi.python.org/pypi/polyglot
8https://github.com/facebookresearch/fastText/blob/

6http://cogcomp.cs.illinois.edu/Data/QA/QC/

master/pretrained-vectors.md

Model
CNN
Dep-CNN
DSCNN
AdaSent

C = Topic

TopCNN

C = Trans

CNN+B1

CNN+B2

CNN+MCFA

MR
81.5
81.9
82.2
83.1

sent
81.3
(-0.2)

N=10
81.4
(-0.1)
82.1
(+0.6)
82.7
(+1.2)

word
81.7
(+0.2)

N=1
81.9
(+0.4)
82.1
(+0.6)
82.3
(+0.8)

ens
83.0
(+1.5)

ens
82.6
(+1.1)
82.2
(+0.7)
83.2
(+1.7)

word
93.4
(+0.0)

N=1
94.6
(+1.2)
94.6
(+1.2)
94.7
(+1.3)

ens
95.0
(+1.6)

ens
94.9
(+1.5)
94.8
(+1.4)
95.2
(+1.8)

word
84.9
(-0.1)

N=1
86.2
(+1.2)
86.1
(+1.1)
87.6
(+2.6)

ens
86.4
(+1.4)

ens
86.7
(+1.7)
86.6
(+1.6)
89.4
(+4.4)

word
92.5
(-1.1)

N=1
95.4
(+1.8)
95.4
(+1.8)
95.4
(+1.8)

CR
85.0
-
-
86.3

sent
84.8
(-0.2)

N=10
85.9
(+0.9)
86.3
(+1.3)
88.6
(+3.6)

SUBJ
93.4
-
93.2
95.5

sent
93.4
(+0.0)

N=10
93.8
(+0.4)
94.0
(+0.6)
94.8
(+1.4)

TREC
93.6
95.4
95.6
92.4

sent
92.0
(-1.6)

N=10
95.0
(+1.4)
95.2
(+1.6)
96.0
(+2.4)

ens
94.0
(+0.4)

ens
96.4
(+3.0)
96.4
(+3.0)
96.8
(+3.4)

Table 2: Classiﬁcation accuracies of competing models. C refers to the additional context, N refers to the number of translations. In TopCNN,
word refers to using word-speciﬁc topic while sentence refers to using sentence-speciﬁc topic. Accuracies colored red are accuracies that
perform worse than CNN. Previous state of the art results and the results of our best model are bold-faced. The winning result is underlined.
The number inside the parenthesis indicates the increase from the base model, CNN.

Model
CNN
CNN+B1
CNN+B2
CNN+MCFA

MR
81.5
81.4
81.7
81.8

SUBJ
93.4
94.2
94.2
94.4

CR
85.0
83.8
84.0
85.8

TREC
93.6
93.0
93.2
94.2

Table 3: Accuracies of the worst CNN+translation classiﬁers when
N = 1. Accuracies less than CNN accuracies are highlighted in red.

on most data sets. Hence, MCFA is successful in effectively
using translations as additional context to improve the perfor-
mance of the classiﬁer.

We compare our model (CNN+MCFA) and the baselines
discussed above (CNN+B1, CNN+B2). On all settings, our
model outperforms the baselines. When N = 10, the per-
formance of our model increases over the performance when
N = 1, however the performance of CNN+B1 decreases
when compared to the performance when N = 1. We also
show the accuracies of the worst classiﬁers when N = 1
in Table 3. On all data sets except SUBJ, the accuracy of
CNN+B1 decreases from the base CNN accuracy, while the
accuracy of our model always improves from the base CNN
accuracy. This is resolved by CNN+B2 by applying L2 regu-
larization, however the increase in performance is marginal.
We also compare two different kinds of additional con-
text: topics (TopCNN) and translations (CNN+B1, CNN+B2,
CNN+MCFA). Overall, we conclude that translations are bet-
ter additional contexts than topics. When using a single con-
text (i.e. TopCNNword, TopCNNsent, and our models when
N = 1), translations always outperform topics even when us-
ing the baseline methods. Using topics as additional context
also decreases the performance of the CNN classiﬁer on most
data sets, giving an adverse effect to the CNN classiﬁer.

(a) Example where English attention weight is larger

(b) Example where Korean attention weight is larger

Figure 4: Attention weights of example Korean sentences from the
MR data set. The red color ﬁll represents the attention weights given
to each sentence. The darker the ﬁll, the larger the attention weight.

5 Model Interpretation

We ﬁrst provide examples shown in Table 4 on how the self
usability module determines the score of sentences.
In the
ﬁrst example, it is hard to classify whether the translated sen-
tence is positive or negative, thus it is given a low self us-
ability score. In the second example, although the sentence
contains mistranslations, these are minimal and may actually
help the classiﬁer by telling it that thirst for violence is not a

Figure 5: PCA visualization of unaltered (left) and altered (right)
vectors of the MR data set. d is the Mahalanobis distance between
two class clusters.

negative phrase. Thus, it is given a high self usability score.

Figure 4 shows two data instance examples where we show
the attention weights given to the other contexts when ﬁxing
a Korean sentence. The larger the attention weight is, the
more the context is used to ﬁx the Korean sentence. In the

Original sentence:
skip this turd and pick your nose instead because you’re sure to get more out of
the latter experience .
Korean translation:
후자의 경험에서 더 많은 것을 얻으려면 이 웅덩이를 건너 뛰고 코를 골라
야합니다 .
Human re-translation:
In order to get more from the latter experience , you need to skip this puddle and
choose your nose .
Self Usability: 0.3958

(a) Low self usability example

Original sentence:
michael moore’s latest documentary about america’s thirst for violence is his best
ﬁlm yet . . .
Korean translation:
마이클 무어 ( Michael Moore ) 의 최근 미국 다큐멘터리 “ 폭력 장면 ” 은 그
의 최고의 영화 다 . . .
Human re-translation:
Michael Moore’s latest American documentary “ Violent Scene ” is his best ﬁlm
yet . . .
Self Usability: 1.0000

(b) High self usability example

Table 4: Two examples of self usability of Korean sentences from
the MR data set. Texts colored in red are mistranslated texts.

Sentence

NN
(Unaltered)

NN
(altered)

Sentence

NN
(Unaltered)

NN
(altered)

may take its sweet time to get wherever it’s going, but if you have
the patience for it, you won’t feel like it’s wasted yours.
you know that ten bucks you’d spend on a ticket? just send it to
cranky. we don’t get paid enough to sit through crap like this.
what might have been readily dismissed as the tiresome rant of
an aging ﬁlmmaker still thumbing his nose at convention takes a
surprising, subtle turn at the midway point.

every nanosecond of the new guy reminds that you could be do-
ing something else more pleasurable.
like scrubbing the toilet.
emptying rat traps. or doing last year’s taxes with your ex-wife.
in the new release of cinema paradiso, the tale has turned from
sweet to bittersweet, and when the tears come during that ﬁnal,
beautiful scene, they ﬁnally feel absolutely earned.
after scenes of nonsense, you’ll be wistful for the testosterone-
charged wizardry of jerry bruckheimer productions, especially
because half past dead is like the rock on walmart budget.

Table 5: Two example sentences, from English (ﬁrst) and Korean
(second) vector spaces, and their nearest neighbors (NN) on both
the unaltered and altered vector spaces. We only show the original
English sentences for the Korean example for conciseness.

ﬁrst example, the Korean sentence contains translation errors;
especially, the words bore and climactic setpiece were not
translated and were only spelled using the Korean alphabet.
In this example, the English attention weight is larger than the
Korean attention weight. In the second example, the Korean
sentence correctly translates all parts of the English sentence,
except for the phrase as it does in trouble. However, this
phrase is not necessary to classify the sentence correctly, and
may induce possible vagueness because of the word trouble.
Thus, the Korean attention weight is larger.

Figure 5 shows the PCA visualization of the unaltered and
the altered vectors of four different languages. In the ﬁrst ex-
ample, the unaltered sentence vectors are mostly in the mid-
dle of the vector space, making it hard to draw a boundary
between the two examples. After the ﬁxing, the boundary is
much clearer. We also show the English sentence vectors in
the second example. Even without ﬁxing the unaltered En-
glish sentence vectors, it is easy to distinguish both classes.
After the ﬁx, the sentence vectors in the middle of the space
are moved, making the distinction more obvious and clearer.

We also provide quantitative evidence by showing that the
Mahalanobis distance between the two classes in the altered
vectors are signiﬁcantly farther than that of the unaltered vec-
tors.

We also show two examples sentences from English and
Korean vector spaces and their corresponding nearest neigh-
bors on both the unaltered and altered vector spaces in Ta-
ble 5. In the ﬁrst example, the unaltered vector focuses on
the meaning of “wasted yours” in the sentence, which puts
it near sentences regarding wasted time or money. After ﬁx-
ing, the sentence vector focuses its meaning on the slow yet
worth-the-wait pace of the movie, thus moving it closer to the
correct vectors. In the second example, all three sentences
have highly descriptive tones, however, the nearest neighbor
on the altered space is hyperbolically negative, comparing the
movie to a description unrelated to the movie itself.

6 Related Work
One way to improve the performance of a sentence classiﬁer
is to introduce new context. Common and obvious kinds of
context are the neighboring sentences of the sentence [Lin
et al., 2015], and the document where the sentence belongs
[Huang et al., 2012]. Topics of the words in the sentence
induced by a topic model were also used as contexts [Zhao
et al., 2017]. In this paper, we introduce yet another type of
additional context, sentence translations, which to the best of
our knowledge have not been used previously.

Sentence encoders trained from neural machine translation
(NMT) systems were also used for transfer learning [Hill et
al., 2016]. [Hill et al., 2017] demonstrated that altered-length
sentence vectors from NMT encoders outperform sentence
vectors from monolingual encoders on semantic similarity
tasks. Recent work used representation of each word in the
sentence to create a sentence representation suitable for mul-
tiple NLP tasks [McCann et al., 2017]. Our work shares the
commonality of using NMT for another task, but instead of
using NMT to encode our sentences, we use it to translate the
sentences into new contexts.

Increasing the number of data instances of the training set
has also been explored to improve the performance of a clas-
siﬁer. Recent methods include the usage of thesaurus [Zhang
et al., 2015], paraphrases [Fu et al., 2014], among others.
These simple variation techniques are preferred because they
are found to be very effective despite their simplicity. Our
work similarly augments training data, not by adding data in-
stances (vertical augmentation), but rather by adding more
context (horizontal augmentation). Though the paraphrase
of p can be alternatively used as an augmented context, this
could not leverage the added semantics coming from another
language, as discussed in Section 1.

7 Conclusion
This paper investigates the use of translations as better ad-
ditional contexts for sentence classiﬁcation. To answer the
problem on mistranslations, we propose multiple context ﬁx-
ing attachment (MCFA) to ﬁx the context vectors using other
context vectors. We show that our method improves the clas-
siﬁcation performance and achieves state-of-the-art perfor-

mance on multiple data sets.
to use and extend our model to other complex NLP tasks.

In our future work, we plan

[Kim, 2014] Yoon Kim. Convolutional neural networks for

sentence classiﬁcation. In EMNLP, 2014.

Acknowledgements
This work was supported by Microsoft Research Asia and the
ICT R&D program of MSIT/IITP. [2017-0-01778, Develop-
ment of Explainable Human-level Deep Machine Learning
Inference Framework]

References
[Bahdanau et al., 2014] Dzmitry Bahdanau, Kyunghyun
Cho, and Yoshua Bengio. Neural machine translation
by jointly learning to align and translate. arXiv preprint
arXiv:1409.0473, 2014.

[Bojanowski et al., 2016] Piotr Bojanowski, Edouard Grave,
Armand Joulin, and Tomas Mikolov. Enriching word
arXiv preprint
vectors with subword information.
arXiv:1607.04606, 2016.

[Collobert et al., 2011] Ronan Collobert,

Jason Weston,
L´eon Bottou, Michael Karlen, Koray Kavukcuoglu, and
Pavel Kuksa.
language processing (almost)
Journal of Machine Learning Research,
from scratch.
12(Aug):2493–2537, 2011.

Natural

[Fu et al., 2014] Guohong Fu, Yu He, Jiaying Song, and
Chaoyue Wang. Improving chinese sentence polarity clas-
siﬁcation via opinion paraphrasing. CLP 2014, page 35,
2014.

[He et al., 2016] Kaiming He, Xiangyu Zhang, Shaoqing
Ren, and Jian Sun. Deep residual learning for image recog-
nition. In CVPR, pages 770–778, 2016.

[Hill et al., 2016] Felix Hill, Kyunghyun Cho, and Anna Ko-
rhonen. Learning distributed representations of sentences
from unlabelled data. arXiv preprint arXiv:1602.03483,
2016.

[Hill et al., 2017] Felix Hill, Kyunghyun Cho, S´ebastien
Jean, and Yoshua Bengio. The representational geometry
of word meanings acquired by neural machine translation
models. Machine Translation, pages 1–16, 2017.

[Hu and Liu, 2004] Minqing Hu and Bing Liu. Mining and
summarizing customer reviews. In SIGKDD, pages 168–
177. ACM, 2004.

[Huang et al., 2012] Eric H Huang, Richard Socher, Christo-
pher D Manning, and Andrew Y Ng. Improving word rep-
resentations via global context and multiple word proto-
types. In ACL, pages 873–882. Association for Computa-
tional Linguistics, 2012.

[Johnson et al., 2016] Melvin Johnson, Mike Schuster,
Quoc V Le, Maxim Krikun, Yonghui Wu, Zhifeng Chen,
Nikhil Thorat, Fernanda Vi´egas, Martin Wattenberg, Greg
Corrado, et al. Google’s multilingual neural machine
translation system: enabling zero-shot translation. arXiv
preprint arXiv:1611.04558, 2016.

[Joulin et al., 2017] Armand Joulin, Edouard Grave, Piotr
Bojanowski, and Tomas Mikolov. Bag of tricks for efﬁ-
cient text classiﬁcation. In EACL, 2017.

[Li and Roth, 2002] Xin Li and Dan Roth. Learning ques-
In COLING, pages 1–7. Association for

tion classiﬁers.
Computational Linguistics, 2002.

[Lin et al., 2015] Rui Lin, Shujie Liu, Muyun Yang, Mu Li,
Ming Zhou, and Sheng Li. Hierarchical recurrent neural
network for document modeling. In EMNLP, pages 899–
907, 2015.

[Ma et al., 2015] Mingbo Ma, Liang Huang, Bing Xiang,
and Bowen Zhou. Dependency-based convolutional neu-
arXiv preprint
ral networks for sentence embedding.
arXiv:1507.01839, 2015.

[McCann et al., 2017] Bryan McCann,

James Bradbury,
Caiming Xiong, and Richard Socher. Learned in trans-
arXiv preprint
lation: Contextualized word vectors.
arXiv:1708.00107, 2017.

[Mimno et al., 2011] David Mimno, Hanna M Wallach, Ed-
mund Talley, Miriam Leenders, and Andrew McCallum.
Optimizing semantic coherence in topic models.
In
EMNLP, pages 262–272. Association for Computational
Linguistics, 2011.

[Pang and Lee, 2004] Bo Pang and Lillian Lee. A sentimen-
tal education: Sentiment analysis using subjectivity sum-
In ACL, page 271.
marization based on minimum cuts.
Association for Computational Linguistics, 2004.

[Pang and Lee, 2005] Bo Pang and Lillian Lee. Seeing stars:
Exploiting class relationships for sentiment categorization
with respect to rating scales. In ACL, pages 115–124. As-
sociation for Computational Linguistics, 2005.

[Pang and Lee, 2007] Bo Pang and Lillian Lee. Opinion
mining and sentiment analysis. Foundations and Trends
in Information Retrieval, 2:1–135, 2007.

[Srivastava et al., 2014] Nitish Srivastava, Geoffrey E Hin-
ton, Alex Krizhevsky,
and Ruslan
Salakhutdinov. Dropout: a simple way to prevent neural
networks from overﬁtting. Journal of machine learning
research, 15(1):1929–1958, 2014.

Ilya Sutskever,

[Zhang et al., 2015] Xiang Zhang, Junbo Zhao, and Yann
LeCun. Character-level convolutional networks for text
classiﬁcation. In NIPS, pages 649–657, 2015.

[Zhang et al., 2016] Rui Zhang, Honglak Lee, and Dragomir
Radev. Dependency sensitive convolutional neural net-
arXiv
works for modeling sentences and documents.
preprint arXiv:1611.02361, 2016.

[Zhao et al., 2015] Han Zhao, Zhengdong Lu, and Pascal
Poupart. Self-adaptive hierarchical sentence model.
In
IJCAI, pages 4069–4076, 2015.

[Zhao et al., 2017] Rui Zhao, Kezhi Mao, Rui Zhao, and
Kezhi Mao. Topic-aware deep compositional models for
sentence classiﬁcation. IEEE/ACM Transactions on Audio,
Speech and Language Processing, 25(2):248–260, 2017.

