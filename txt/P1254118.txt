MIHash: Online Hashing with Mutual Information

Fatih Cakir∗ Kun He∗

Sarah Adel Bargal

Stan Sclaroff

Department of Computer Science
Boston University, Boston, MA
{fcakir,hekun,sbargal,sclaroff}@cs.bu.edu

7
1
0
2
 
l
u
J
 
9
2
 
 
]

V
C
.
s
c
[
 
 
2
v
9
1
9
8
0
.
3
0
7
1
:
v
i
X
r
a

Abstract

Learning-based hashing methods are widely used for
nearest neighbor retrieval, and recently, online hashing
methods have demonstrated good performance-complexity
trade-offs by learning hash functions from streaming data.
In this paper, we ﬁrst address a key challenge for online
hashing:
the binary codes for indexed data must be re-
computed to keep pace with updates to the hash functions.
We propose an efﬁcient quality measure for hash functions,
based on an information-theoretic quantity, mutual infor-
mation, and use it successfully as a criterion to eliminate
unnecessary hash table updates. Next, we also show how to
optimize the mutual information objective using stochastic
gradient descent. We thus develop a novel hashing method,
MIHash, that can be used in both online and batch settings.
Experiments on image retrieval benchmarks (including a
2.5M image dataset) conﬁrm the effectiveness of our for-
mulation, both in reducing hash table recomputations and
in learning high-quality hash functions.

1. Introduction

Hashing is a widely used approach for practical nearest
neighbor search in many computer vision applications. It
has been observed that adaptive hashing methods that learn
to hash from data generally outperform data-independent
hashing methods such as Locality Sensitive Hashing [4]. In
this paper, we focus on a relatively new family of adaptive
hashing methods, namely online adaptive hashing methods
[1, 2, 6, 11]. These techniques employ online learning in the
presence of streaming data, and are appealing due to their
low computational complexity and their ability to adapt to
changes in the data distribution.

Despite recent progress, a key challenge has not been
addressed in online hashing, which motivates this work:
the computed binary representations, or the “hash table”,
may become outdated after a change in the hash mapping.
To reﬂect the updates in the hash mapping, the hash table

∗First two authors contributed equally.

ˆx and non-neighbors in

Figure 1: We study online hashing for efﬁcient nearest
neighbor retrieval. Given a hash mapping Φ, an image ˆx,
ˆx,
along with its neighbors in
(cid:22)
are mapped to binary codes, yielding two distributions of
Hamming distances. In this example, Φ1 has higher quality
than Φ2 since it induces more separable distributions. The
information-theoretic quantity Mutual Information can be
used to capture the separability, which gives a good quality
indicator and learning objective for online hashing.

(cid:23)

may need to be recomputed frequently, causing inefﬁcien-
cies in the system such as successive disk I/O, especially
when dealing with large datasets. We thus identify an im-
portant question for online adaptive hashing systems: when
to update the hash table? Previous online hashing solutions
do not address this question, as they usually update both the
hash mapping and hash table concurrently.

We make the observation that achieving high quality
nearest neighbor search is an ultimate goal in hashing sys-
tems, and therefore any effort to limit computational com-
plexity should preserve, if not improve, that quality. There-
fore, another important question is: how to quantify qual-
ity? Here, we brieﬂy describe our answer to this question,
but ﬁrst introduce some necessary notation. We would like
to learn a hash mapping Φ from feature space X to the b-
dimensional Hamming space Hb, whose outputs are b-bit

(cid:22)

(cid:23)

ˆx, and a set of non-neighbors

binary codes. The goal of hashing is to preserve a neighbor-
hood structure in X after the mapping to Hb. Given ˆx ∈ X ,
the neighborhood structure is usually given in terms of a set
of its neighbors
ˆx. We
discuss how to derive the neighborhood structure in Sec. 3.
As shown in Fig. 1, the distributions of the Hamming
distances from ˆx to its neighbors and non-neighbors are his-
tograms over {0, 1, . . . , b}. Ideally, if there is no overlap
between these two distributions, we can recover
ˆx
by simply thresholding the Hamming distance. A nonzero
overlap results in ambiguity, as observing the Hamming dis-
tance is no longer sufﬁcient to determine neighbor relation-
ships. Our discovery is that this overlap can be quanti-
ﬁed using an information-theoretic quantity, mutual infor-
mation, between two random variables induced by Φ. We
then use mutual information to deﬁne a novel measure to
quantify quality for hash functions in general.

ˆx and

(cid:23)

(cid:22)

With a quality measure deﬁned, we answer the motivat-
ing question of when to update the hash table. We propose
a simple solution by restricting updates to times when there
is an estimated improvement in hashing quality, based on
an efﬁcient estimation method in the presence of streaming
data. Notably, since mutual information is a good general-
purpose quality measure for hashing, this results in a gen-
eral plug-in module for online hashing that does not require
knowledge of the learning method.

Inspired by this strong result, we next ask, can we opti-
mize mutual information as an objective to learn hash func-
tions? We propose a novel hashing method, MIHash, by
deriving gradient descent rules on the mutual information
objective, which can be applied in online stochastic opti-
mization, as well as on deep architectures. The mutual in-
formation objective is free of tuning parameters, unlike oth-
ers that may require thresholds, margins, etc.

We conduct experiments on three image retrieval bench-
marks, including the Places205 dataset [32] with 2.5M im-
ages. For four recent online hashing methods, our mu-
tual information based update criterion consistently leads to
over an order of magnitude reduction in hash table recom-
putations, while maintaining retrieval accuracy. Moreover,
our novel MIHash method achieves state-of-the-art retrieval
results, in both online and batch learning settings.

2. Related Work

In this section, we mainly review hashing methods that
adaptively update the hash mapping with incoming data,
given that our focus is on online adaptive hashing. For a
more general survey on hashing, please refer to [25].

Huang et al. [6] propose Online Kernel Hashing, where
a stochastic environment is considered with pairs of points
arriving sequentially. At each step, a number of hash func-
tions are selected based on a Hamming loss measure and pa-
rameters are updated via stochastic gradient descent (SGD).

Cakir and Sclaroff [1] argue that, in a stochastic setting,
it is difﬁcult to determine which hash functions to update as
it is the collective effort of all the hash functions that yields
a good hash mapping. Hamming loss is considered to infer
the hash functions to be updated at each step and a squared
error loss is minimized via SGD.

In [2], binary Error Correcting Output Codes (ECOCs)
are employed in learning the hash functions. This work
follows a more general two-step hashing framework [14],
where the set of ECOCs are generated beforehand and are
assigned to labeled data as they appear, allowing the label
space to grow with incoming data. Then, hash functions are
learned to ﬁt the binary ECOCs using Online Boosting.

Inspired by the idea of “data sketching”, Leng et al. in-
troduce Online Sketching Hashing [11] where a small ﬁxed-
size sketch of the incoming data is maintained in an online
fashion. The sketch retains the Frobenius norm of the full
data matrix, which offers space savings, and allows to ap-
ply certain batch-based hashing methods. A PCA-based
batch learning method is applied on the sketch to obtain
hash functions.

None of the above online hashing methods offer a solu-
tion to decide whether or not the hash table shall be updated
given a new hash mapping. However, such a solution is
crucial in practice, as limiting the frequency of updates will
alleviate the computational burden of keeping the hash ta-
ble up-to-date. Although [2] and [6] include strategies to
select individual hash functions to recompute, they still re-
quire computing on all indexed data instances.

Recently, some methods employ deep neural networks
to learn hash mappings, e.g. [12, 15, 27, 30] and others.
These methods use minibatch-based stochastic optimiza-
tion, however, they usually require multiple passes over a
given dataset to learn the hash mapping, and the hash table
is only computed when the hash mapping has been learned.
Therefore, current deep learning based hashing methods are
essentially batch learning methods, which differ from the
online hashing methods that we consider, i.e. methods that
process streaming data to learn and update the hash map-
pings on-the-ﬂy while continuously updating the hash ta-
ble. Nevertheless, when evaluating our mutual information
based hashing objective, we compare against state-of-the-
art batch hashing formulations as well, by contrasting dif-
ferent objective functions on the same model architecture.

Lastly, Ustinova et al. [23] recently proposed a method
to derive differentiation rules for objective functions that re-
quire histogram binning, and apply it in learning deep em-
beddings. When optimizing our mutual information objec-
tive, we utilize their differentiable histogram binning tech-
nique for deriving gradient-based optimization rules. Note
that both our problem setup and objective function are quite
different from [23].

3. Online Hashing with Mutual Information

As mentioned in Sec. 1, the goal of hashing is to learn a
hash mapping Φ : X → Hb such that a desired neighbor-
hood structure is preserved. We consider an online learning
setup where Φ is continuously updated from input stream-
ing data, and at time t, the current mapping Φt is learned
from {x1, . . . , xt}. We follow the standard setup of learn-
ing Φ from pairs of instances with similar/dissimilar labels
[9, 6, 1, 12]. These labels, along with the neighborhood
structure, can be derived from a metric, e.g. two instances
are labeled similar (i.e. neighbors of each other) if their Eu-
clidean distance in X is below a threshold. Such a setting
is often called unsupervised hashing. On the other hand, in
supervised hashing with labeled data, pair labels are derived
from individual class labels: instances are similar if they are
from the same class, and dissimilar otherwise.

Below, we ﬁrst derive the mutual information quality
measure and discuss its use in determining when to update
the hash table in Sec. 3.1. We then describe a gradient-based
approach for optimizing the same quality measure, as an ob-
jective for learning hash mappings, in Sec. 3.2. Finally, we
discuss the beneﬁts of using mutual information in Sec. 3.3.

3.1. MI as Update Criterion

We revisit our motivating question: When to update the
hash table in online hashing? During the online learn-
ing of Φt, we assume a retrieval set S ⊆ X , which may
include the streaming data after they are received. We
deﬁne the hash table as the set of hashed binary codes:
T (S, Φ) = {Φ(x)|x ∈ S}. Given the adaptive nature of
online hashing, T may need to be recomputed often to keep
pace with Φt; however, this is undesirable if S is large or the
change in Φt’s quality does not justify the cost of an update.
We propose to view the learning of Φt and computa-
tion of T as separate events, which may happen at different
rates. To this end, we introduce the notion of a snapshot,
denoted Φs, which is occasionally taken of Φt and used
to recompute T . Importantly, this happens only when the
nearest neighbor retrieval quality of Φt has improved, and
we now deﬁne the quality measure.

Given hash mapping Φ : X → {−1, +1}b, Φ induces

Hamming distance dΦ : X × X → {0, 1, . . . , b} as

dΦ(x, ˆx) =

(cid:0)b − Φ(x)(cid:62)Φ(ˆx)(cid:1) .

(1)

1
2

Consider some instance ˆx ∈ X , and the sets contain-
ˆx. Φ induces
ing neighbors and non-neighbors,
two conditional distributions, P (dΦ(x, ˆx)|x ∈
ˆx) and
P (dΦ(x, ˆx)|x ∈
ˆx) as seen in Fig. 1, and it is desir-
able to have low overlap between them. To formulate the
idea, for Φ and ˆx, deﬁne random variable Dˆx,Φ : X →
{0, 1, . . . , b}, x (cid:55)→ dΦ(x, ˆx), and let Cˆx : X → {0, 1} be

ˆx and

(cid:22)

(cid:23)

(cid:22)

(cid:23)

ˆx. The two conditional dis-
the membership indicator for
(cid:22)
tributions can now be expressed as P (Dˆx,Φ|Cˆx = 1) and
P (Dˆx,Φ|Cˆx = 0), and we can write the mutual information
between Dˆx,Φ and Cˆx as

I(Dˆx,Φ; Cˆx) = H(Cˆx) − H(Cˆx|Dˆx,Φ)

= H(Dˆx,Φ) − H(Dˆx,Φ|Cˆx)

(2)

(3)

D, and pD, respectively.

where H denotes (conditional) entropy. In the following,
for brevity we will drop subscripts Φ and ˆx, and denote the
two conditional distributions and the marginal P (Dˆx,Φ) as
p+
D, p−
By deﬁnition, I(D; C) measures the decrease in uncer-
tainty in the neighborhood information C when observing
the Hamming distances D. We claim that I(D; C) also cap-
tures how well Φ preserves the neighborhood structure of ˆx.
If I(D; C) attains a high value, which means C can be de-
termined with low uncertainty by observing D, then Φ must
have achieved good separation (i.e. low overlap) between
p+
D and p−
D. I is maximized when there is no overlap, and
minimized when p+
D are exactly identical. Recall,
however, that I is deﬁned with respect to a single instance
ˆx; therefore, for a general quality measure, we integrate I
over the feature space:

D and p−

Q(Φ) =

I(Dˆx,Φ; Cˆx)p(ˆx)dˆx.

(4)

(cid:90)

X

Q(Φ) captures the expected amount of separation between
D and p−
p+
D achieved by Φ, over all instances in X .
In the online setting, given the current hash mapping Φt
and previous snapshot Φs, it is then straightforward to pose
the update criterion as

Q(Φt) − Q(Φs) > θ,

(5)

where θ is a threshold; a straightforward choice is θ = 0.
However, Eq. 4 is generally difﬁcult to evaluate due to the
intractable integral; in practice, we resort to Monte-Carlo
approximations to this integral, as we describe next.

Monte-Carlo Approximation by Reservoir Sampling
We give a Monte-Carlo approximation of Eq. 4. Since we
work with streaming data, we employ the Reservoir Sam-
pling algorithm [24], which enables sampling from a stream
or sets of large/unknown cardinality. With reservoir sam-
pling, we obtain a reservoir set R (cid:44) {xr
K} from
the stream, which can be regarded as a ﬁnite sample from
p(x). We estimate the value of Q on R as:

1, . . . , xr

QR(Φ) =

IR(Dxr,Φ; Cxr ).

(6)

1
|R|

(cid:88)

xr∈R

We use subscript R to indicate that when computing the
mutual information I, the p+
D for a reservoir in-
stance xr are estimated from R. This can be done in O(|R|)

D and p−

Figure 2: We present the general plug-in module for on-
line hashing methods: Trigger Update (TU). We sample a
reservoir R from the input stream, and estimate the mutual
information criterion QR. Based on its value, TU decides
whether a hash table update should be executed.

time for each xr, as the discrete distributions can be esti-
mated via histogram binning.

Fig. 2 summarizes our approach. We use the reservoir
set to estimate the quality QR, and “trigger” an update to
the hash table only when QR improves over a threshold.
Notably, our approach provides a general plug-in module
for online hashing techniques, in that it only needs access
to streaming data and the hash mapping itself, independent
of the hashing method’s inner workings.

3.2. MI as Learning Objective

Having shown that mutual information is a suitable mea-
sure of neighborhood quality, we consider its use as a
learning objective for hashing. Following the notation in
Sec. 3.1, we deﬁne a loss L with respect to ˆx ∈ X and Φ as

L(ˆx, Φ) = −I(Dˆx,Φ; Cˆx).

(7)

We model Φ as a collection of parameterized hash func-
tions, each responsible for generating a single bit: Φ(x) =
[φ1(x; W ), ..., φb(x; W )], where φi : X → {−1, +1}, ∀i,
and W represents the model parameters. For example, lin-
ear hash functions can be written as φi(x) = sgn(w(cid:62)
i x),
and for deep neural networks the bits are generated by
thresholding the activations of the output layer.

Inspired by the online nature of the problem and recent
advances in stochastic optimization, we derive gradient de-
scent rules for L. The entropy-based mutual information
is differentiable with respect to the entries of pD, p+
D and
p−
D, and, as mentioned before, these discrete distributions
can be estimated via histogram binning. However, it is not
clear how to differentiate histogram binning to generate gra-
dients for model parameters. We describe a differentiable
histogram binning technique next.

Differentiable Histogram Binning
We borrow ideas from [23] and estimate p+
D and pD us-
ing a differentiable histogram binning technique. For b-bit
Hamming distances, we use (K + 1)-bin normalized his-
tograms with bin centers v0 = 0, ..., vK = b and uniform
bin width ∆ = b/K, where K = b by default. Consider,

D, p−

for example, the k-th entry in p+
be estimated as

D, denoted as p+

D,k. It can

p+
D,k =

1

(cid:88)

|

|

x∈

δx,k,

(cid:22)
where δx,k records the contribution of x to bin k. It is ob-
tained by interpolating dΦ(x, ˆx) using a triangular kernel:

(cid:22)

δx,k =






(dΦ(x, ˆx) − vk−1)/∆, dΦ(x, ˆx) ∈ [vk−1, vk],
(vk+1 − dΦ(x, ˆx))/∆, dΦ(x, ˆx) ∈ [vk, vk+1],
0,

otherwise.

This binning process admits subgradients:

∂δx,k
∂dΦ(x, ˆx)

=






dΦ(x, ˆx) ∈ [vk−1, vk],
1/∆,
−1/∆, dΦ(x, ˆx) ∈ [vk, vk+1],
0,
otherwise.

Gradients of MI
We now derive the gradient of I with respect to the output
of the hash mapping, Φ(ˆx). Using standard chain rule, we
can ﬁrst write

∂I
∂Φ(ˆx)

=

(cid:34)

K
(cid:88)

k=0

∂I
∂p+

D,k

∂p+
D,k
∂Φ(ˆx)

+

∂I
∂p−

D,k

(cid:35)

∂p−
D,k
∂Φ(ˆx)

.

(11)

We focus on terms involving p+

D,k, and omit derivations

for p−

D,k due to symmetry. For k = 0, . . . , K, we have
∂I
∂p+

∂H(D|C)
∂p+

∂H(D)
∂p+

= −

+

D,k

D,k

D,k

= p+(log p+

D,k + 1) − (log pD,k + 1)

∂pD,k
∂p+

D,k

= p+(log p+

D,k − log pD,k),

where we used the fact that pD,k = p+p+
D,k, with
p+ and p− being shorthands for the priors P (C = 1) and
P (C = 0). We next tackle the term ∂p+
D,k/∂Φ(ˆx) in Eq. 11.
From the deﬁnition of p+

D,k + p−p−

D,k in Eq.8, we have

∂p+
D,k
∂Φ(ˆx)

∂δx,k
∂Φ(ˆx)

=

=

=

1

(cid:22)
1

(cid:22)
1

(cid:22)

|

|

|

|

|

|

(cid:88)

x∈

(cid:22)
(cid:88)

x∈

(cid:22)
(cid:88)

x∈

(cid:22)

∂δx,k
∂dΦ(x, ˆx)

∂dΦ(x, ˆx)
∂Φ(ˆx)

∂δx,k
∂dΦ(x, ˆx)

−Φ(x)
2

.

Note that ∂δx,k/∂dΦ(x, ˆx) is already given in Eq. 10. For
the last step, we used the deﬁnition of dΦ in Eq. 1.

Lastly, to back-propagate gradients to Φ’s inputs and ul-
timately model parameters, we approximate the discontin-
uous sign function with sigmoid, which is a standard tech-
nique in hashing, e.g. [1, 12, 16].

(8)

(9)

(10)

(12)

(13)

(14)

(15)

(16)

(17)

Figure 3: We show Pearson correlation coefﬁcients between mutual information (MI) and AP, DCG, and NDCG, evaluated
on the CIFAR-10, LabelMe, and Places205 datasets. We sample 100 instances to form the query set, and use the rest to
populate the hash table. The hash mapping parameters are randomly sampled from a Gaussian, similar to LSH [4]. Each
experiment is conducted 50 times. There exist strong correlations between MI and the standard metrics.

3.3. Beneﬁts of MI

For monitoring the performance of hashing algorithms,
it appears that one could directly use standard ranking met-
rics, such as Average Precision (AP), Discounted Cumu-
lative Gain (DCG), and Normalized DCG (NDCG) [17].
Here, we discuss the beneﬁts of instead using mutual in-
formation. First, we note that there exist strong correlations
between mutual information and standard ranking metrics.
Fig. 3 demonstrates the Pearson correlation coefﬁcients be-
tween MI and AP, DCG, and NDCG, on three benchmarks.
Although a theoretical analysis is beyond the scope of this
work, empirically we ﬁnd that MI serves as an efﬁcient and
general-purpose ranking surrogate.

We also point out the lower computational complexity of
mutual information. Let n be the reservoir set size. Com-
puting Eq. 6 involves estimating discrete distributions via
histogram binning, and takes O(n) time for each reservoir
item, since D only takes discrete values from {0, 1, . . . , b},
In contrast, ranking measures such as AP and NDCG have
O(n log n) complexity due to sorting, which render them
disadvantageous.

Finally, Sec. 3.2 showed that the mutual information ob-
jective is suitable for direct, gradient-based optimization. In
contrast, optimizing metrics like AP and NDCG is much
more challenging as they are non-differentiable, and ex-
isting works usually resort to optimizing their surrogates
[13, 26, 29] rather than gradient-based optimization. Fur-
thermore, mutual information itself is essentially parameter-
free, whereas many other hashing formulations require (and
can be sensitive to) tuning parameters, such as thresholds or
margins [18, 27], quantization strength [12, 15, 20], etc.

4. Experiments

We evaluate our approach on three widely used image
benchmarks. We ﬁrst describe the datasets and experimen-
tal setup in Sec. 4.1. We evaluate the mutual informa-
tion update criterion in Sec. 4.2 and the mutual informa-

tion based objective function for learning hash mappings
in Sec. 4.3. Our implementation is publicly available at
https://github.com/fcakir/mihash.

4.1. Datasets and Experimental Setup

CIFAR-10 is a widely-used dataset for image classiﬁca-
tion and retrieval, containing 60K images from 10 different
categories [7]. For feature representation, we use CNN fea-
tures extracted from the f c7 layer of a VGG-16 network
[21] pre-trained on ImageNet.

Places205 is a subset of the large-scale Places dataset
[32] for scene recognition. Places205 contains 2.5M im-
ages from 205 scene categories. This is a very challeng-
ing dataset due to its large size and number of categories,
and it has not been studied in the hashing literature to our
knowledge. We extract CNN features from the f c7 layer
of an AlexNet [8] pre-trained on ImageNet, and reduce the
dimensionality to 128 using PCA.

LabelMe. The 22K LabelMe dataset [19, 22] has 22,019
images represented as 512-dimensional GIST descriptors.
This is an unsupervised dataset without labels, and standard
practice uses the Euclidean distance to determine neighbor
relationships. Speciﬁcally, xi and xj are considered neigh-
bor pairs if their Euclidean distance is within the smallest
5% in the training set. For a query, the closest 5% examples
are considered true neighbors.

All datasets are randomly split into a retrieval set and a
test set, and a subset from the retrieval set is used for learn-
ing hash functions. Speciﬁcally, for CIFAR-10, the test set
has 1K images and the retrieval set has 59K. A random sub-
set of 20K images from the retrieval set is used for learning,
and the size of the reservoir is set to 1K. For Places205, we
sample 20 images from each class to construct a test set of
4.1K images, and use the rest as the retrieval set. A random
subset of 100K images is used to for learning, and the reser-
voir size is 5K. For LabelMe, the dataset is split into re-
trieval and test sets with 20K and 2K samples, respectively.
Similar to CIFAR-10, we use a reservoir of size 1K.

Figure 4: Retrieval mAP vs. number of processed training examples for four hashing methods on the three datasets, with
and without Trigger Update (TU). We use default threshold θ = 0 for TU. Circles indicate hash table updates, and the ratio
of reduction in the number of updates is shown in the titles. TU substantially reduces the number of updates while having
a stabilizing effect on the retrieval performance. Note: since OSH [2] assumes supervision in terms of class labels, it is not
applicable to the unsupervised LabelMe dataset.

For online hashing experiments, we run three random-
ized trials for each experiment and report averaged results.
To evaluate retrieval performances, we adopt the widely-
used mean Average Precision (mAP). Due to the large size
of Places205, mAP is very time-consuming to compute,
and we compute mAP on the top 1000 retrieved examples
(mAP@1000), as done in [15].

4.2. Evaluation: Update Criterion

We evaluate our mutual information based update crite-
rion, the Trigger Update module (TU). We apply TU to all
existing online hashing methods known to us: Online Ker-
nel Hashing (OKH) [6], Online Supervised Hashing (OSH)
[2], Adaptive Hashing (AdaptHash) [1] and Online Sketch-
ing Hashing (SketchHash) [11]. We use publicly available
implementations of all methods. The hash code length is
ﬁxed at 32 bits.

As our work is the ﬁrst in addressing the hash table up-
date criterion for online hashing, we compare to a data-
agnostic baseline, which updates the hash table at a ﬁxed
rate. The rate is controlled by a parameter U , referred to

as the “update interval”: after processing every U exam-
ples, the baseline unconditionally triggers an update, while
TU makes a decision using the mutual information criterion.
For each dataset, U is set such that the baseline updates 201
times in total. This ensures that the baseline is never too
outdated, but updates are still fairly infrequent: in all cases,
the smallest U is 100.

Results for the Trigger Update module. Fig. 4 de-
picts the retrieval mAP over time for all four online hash-
ing methods considered, on three datasets, with and without
incorporating TU. We can clearly observe a signiﬁcant re-
duction in the number of hash table updates, between one
and two orders of magnitude in all cases. For example, the
number of hash table updates is reduced by a factor of 67
for the OKH method on LabelMe.

The quality-based update criterion is particularly im-
portant for hashing methods that may yield inferior hash
mappings due to noisy data and/or imperfect learning tech-
niques. In other words, TU can be used to ﬁlter updates to
the hash mapping with negative or small improvement. This
has a stabilizing effect on the mAP curve, notably for OKH

Figure 5: Online hashing performance comparison on three datasets, where all methods use the Trigger Update module (TU)
with default threshold θ = 0. MIHash clearly outperforms other competing methods. OSH, AdaptHash, and SketchHash
perform very similarly on Places205, thus their curves overlap.

and AdaptHash. For OSH, which appears to stably improve
over time, TU nevertheless signiﬁcantly reduces revisits to
the hash table while maintaining its performance.

All results in Fig. 4 are obtained using the default thresh-
old parameter θ = 0, deﬁned in Eq. 5. We do not tune θ in
order to show general applicability. We also discuss the im-
pact of the reservoir set R. There is a trade-off regarding
the size of R: a larger R leads to better approximation but
increases the overhead. Nevertheless, we observed robust
and consistent results with |R| not exceeding 5% of the size
of the training stream.

4.3. Evaluation: Learning Objective

We evaluate the mutual information based hashing ob-
jective. We name our method MIHash, and train it using
stochastic gradient descent (SGD). This allows it to be ap-
plied to both the online setting and batch setting in learning
hash functions.

(cid:23)

During minibatch-based SGD, to compute the mutual in-
formation objective in Eq. 7 and its gradients, we need ac-
ˆx for each considered ˆx, in order to
ˆx,
cess to the sets
(cid:22)
estimate p+
D and p−
D. For the online setting in Sec. 4.3.1,
a standalone reservoir set R is assumed as in the previous
experiment, and we partition R into {
ˆx} with respect
to each incoming ˆx. In this case, even a batch size of 1 can
be used. For the batch setting in Sec. 4.3.2, {
ˆx} are
deﬁned within the same minibatch as ˆx.

ˆx,

ˆx,

(cid:23)

(cid:22)

(cid:23)

(cid:22)

4.3.1 Online Setting

We ﬁrst consider an online setting that is the same as in
Sec. 4.2. We compare against other online hashing meth-
ods: OKH, OSH, AdaptHash and SketchHash. All methods
are equipped with the TU module with the default threshold
θ = 0, which has been demonstrated to work well.

Results for Online Setting. We ﬁrst show the mAP
curve comparisons in Fig. 5. For competing online hash-
ing methods, the curves are the same as the ones with
TU in Fig. 4, and we remove markers to avoid clutter.
MIHash clearly outperforms other online hashing methods

on all three datasets, and shows potential for further im-
provement with more training data. The combination of TU
and MIHash gives a complete online hashing system that
enjoys a superior learning objective with a plug-in update
criterion that improves efﬁciency.

D and p−

We next give insights into the distribution-separating ef-
fect from optimizing mutual information. In Fig. 6, we plot
the conditional distributions p+
D averaged on the
CIFAR-10 test set, before and after learning MIHash with
the 20K training examples. Before learning, with a ran-
domly initialized hash mapping, p+
D exhibit high
overlap. After learning, MIHash achieves good separation
between p+
D: the overlap reduces signiﬁcantly, and
the mass of p+
D is pushed towards 0. This separation is re-
ﬂected in the large improvement in mAP (0.68 vs. 0.22).

D and p−

D and p−

In contrast with the other methods, the mutual informa-
tion formulation is parameter-free. For instance, there is no
threshold parameter that requires separating p+
D at
a certain distance value. Likewise, there is no margin pa-
rameter that dictates the amount of separation in absolute
terms. Such parameters usually need to be tuned to ﬁt to
data, whereas the optimization of mutual information is au-
tomatically guided by the data itself.

D and p−

4.3.2 Batch Setting

To further demonstrate the potential of MIHash, we con-
sider the batch learning setting, where the entire training
set is available at once. We compare against state-of-the-
art batch formulations, including: Supervised Hashing with
Kernels (SHK) [16], Fast Supervised Hashing with Deci-
sion Trees (FastHash) [14], Supervised Discrete Hashing
(SDH) [20], Efﬁcient Training of Very Deep Neural Net-
works (VDSH) [30], Deep Supervised Hashing with Pair-
wise Labels (DPSH) [12] and Deep Supervised Hashing
with Triplet Labels (DTSH) [27]. These competing meth-
ods have shown to outperform earlier and other work such
as [5, 9, 18, 28, 10, 31]. We focus on comparisons on the
CIFAR-10 dataset, which is the canonical benchmark for
supervised hashing. Similar to [27], we consider two exper-

1

g
n
i
t
t
e
S

Method
SHK
SDH
VDSH
DPSH
DTSH
FastHash
MIHash1
MIHash
Method
DPSH2
DTSH2
DPSH
DTSH
MIHash

Code Length
32
24
0.645
0.615
0.589
0.576
0.537
0.546
0.538
0.518
0.689
0.659
0.724
0.700
0.597
0.563
0.727
0.720
32
24
0.795
0.781
0.925
0.923
0.917
0.909
0.927
0.924
0.933
0.938
1 Results after a single training epoch.
2 Results as reported in DPSH [12] and DTSH [27].

12
0.497
0.521
0.523
0.420
0.617
0.632
0.524
0.683
16
0.763
0.915
0.908
0.916
0.929

2

g
n
i
t
t
e
S

48
0.682
0.592
0.554
0.553
0.702
0.738
0.609
0.746
48
0.807
0.926
0.932
0.934
0.942

Table 1: Comparison against state-of-the-art hashing meth-
ods on CIFAR-10. We report mean Average Precision
(mAP) on the test set, with best results in bold. See text
for the details of the two experimental settings.

can learn non-linear hash functions: for instance, the closest
competitor, FastHash, is a two-step hashing method based
on sophisticated binary code inference and boosted trees.

In Setting 2, with end-to-end ﬁnetuning, MIHash signif-
icantly outperforms DPSH and DTSH, the two most com-
petitive deep hashing methods, and sets the current state-
of-the-art for CIFAR-10. Again, note that MIHash has no
tuning parameters in its objective function. In contrast, both
DPSH and DTSH have parameters to control the quantiza-
tion strength that need to be tuned.

5. Conclusion

We advance the state-of-the-art for online hashing in two
aspects. In order to resolve the issue of hash table updates
in online hashing, we deﬁne a quality measure using the
mutual information between variables induced by the hash
mapping. This measure is efﬁciently computable, corre-
lates well with standard evaluation metrics, and leads to
consistent computational savings for existing online hash-
ing methods while maintaining their retrieval accuracy. In-
spired by these strong results, we further propose a hashing
method MIHash, by optimizing mutual information as an
objective with stochastic gradient descent. In both online
and batch settings, MIHash achieves superior performance
compared to state-of-the-art hashing techniques.

Acknowledgements

This research was supported in part by a BU IGNITION

award, US NSF grant 1029430, and gifts from NVIDIA.

D and p−

Figure 6: We plot the distributions p+
D, aver-
aged on the CIFAR-10 test set, before and after learning
MIHash with 20K training examples. Optimizing the mu-
tual information objective substantially reduces the overlap
between them, resulting in state-of-the-art mAP for the on-
line setting, as shown in Fig. 5.

imental settings, which we detail below.

Setting 1: 5K training examples are sampled for learn-
ing hash mappings, and 1K examples are used as the test
set. All methods learn shallow models on top of fc7 fea-
tures from a VGG-16 network [21] pretrained on Ima-
geNet. For three gradient-based methods (DPSH, DTSH,
and MIHash), this means learning linear hash functions.
Note that VDSH uses customized architectures consisting
of only fully-connected layers, and it is unclear how to adapt
it to use standard architectures; we used its full model with
16 layers and 1024 nodes per layer.

Setting 2: We use the full training set of size 50K and
test set of size 10K. We focus on comparing the end-to-end
performance of MIHash against two recent leading meth-
ods: DPSH and DTSH, using the same VGG-F network
architecture [3] that they are trained on. We use pub-
licly available implementations for the compared methods,
and exhaustively search parameter settings for them. For
MIHash, the minibatch size is set to 100 and 250 in Settings
1 and 2, respectively. We use SGD with momentum, and
decrease the learning rate when the training loss saturates.
See supplementary material for more details.

Results for Batch Setting.

In Table 1, we list batch
learning results for all methods. In Setting 1, MIHash out-
performs all competing methods in terms of mAP, in some
cases with only a single training epoch (e.g. against VDSH,
DPSH). This suggests that mutual information is a more ef-
fective learning objective for hashing. MIHash learns a lin-
ear layer on the input features, while some other methods

[18] M. Norouzi and D. J. Fleet. Minimal loss hashing for com-
pact binary codes. In Proc. International Conf. on Machine
Learning (ICML), 2011.

[19] B. C. Russell, A. Torralba, K. P. Murphy, and W. T. Freeman.
Labelme: a database and web-based tool for image annota-
tion. International journal of computer vision, 2008.
[20] F. Shen, C. S. Wei, L. Heng, and T. Shen. Supervised dis-
crete hashing. In Proc. IEEE Conf. on Computer Vision and
Pattern Recognition (CVPR), 2015.

[21] K. Simonyan and A. Zisserman. Very deep convolutional
networks for large-scale image recognition. ICLR, 2015.
[22] A. Torralba, R. Fergus, and Y. Weiss. Small codes and large
In Proc. IEEE Conf. on
image databases for recognition.
Computer Vision and Pattern Recognition (CVPR). IEEE,
2008.

[23] E. Ustinova and V. Lempitsky. Learning deep embeddings
with histogram loss. In Proc. Advances in Neural Informa-
tion Processing Systems (NIPS), pages 4170–4178, 2016.
[24] J. S. Vitter. Random sampling with a reservoir. ACM
Transactions on Mathematical Software (TOMS), 11(1):37–
57, 1985.

[25] J. Wang, H. T. Shen, J. Song, and J. Ji. Hashing for similarity

search: A survey. CoRR.

[26] Q. Wang, Z. Zhang, and L. Si. Ranking preserving hashing
for fast similarity search. In Proc. International Joint Conf.
on Artiﬁcial Intelligence (IJCAI), 2015.

[27] Y. Wang, Xiaofang Shi and K. M. Kitani. Deep supervised
hashing with triplet labels. In Proc. Asian Conf. on Computer
Vision (ACCV), 2016.

[28] R. Xia, Y. Pan, H. Lai, C. Liu, and S. Yan. Supervised hash-
ing for image retrieval via image representation learning. In
Proc. AAAI Conf. on Artiﬁcial Intelligence (AAAI), volume 1,
page 2, 2014.

[29] Y. Yue, T. Finley, F. Radlinski, and T. Joachims. A support
In Proc.
vector method for optimizing average precision.
ACM Conf. on Research & Development in Information Re-
trieval (SIGIR), pages 271–278. ACM, 2007.

[30] Z. Zhang, Y. Chen, and V. Saligrama. Efﬁcient training of
very deep neural networks for supervised hashing. In Proc.
IEEE Conf. on Computer Vision and Pattern Recognition
(CVPR), 2016.

[31] F. Zhao, Y. Huang, L. Wang, and T. Tan. Deep semantic
ranking based hashing for multi-label image retrieval.
In
Proc. IEEE Conf. on Computer Vision and Pattern Recog-
nition (CVPR), 2015.

[32] B. Zhou, A. Lapedriza, J. Xiao, A. Torralba, and A. Oliva.
Learning deep features for scene recognition using places
database. In Proc. Advances in Neural Information Process-
ing Systems (NIPS), 2014.

References

[1] F. Cakir and S. Sclaroff. Adaptive hashing for fast similar-
ity search. In Proc. IEEE International Conf. on Computer
Vision (ICCV), 2015.

[2] F. Cakir and S. Sclaroff. Online supervised hashing. In Proc.
IEEE International Conf. on Image Processing (ICIP), 2015.
[3] K. Chatﬁeld, K. Simonyan, A. Vedaldi, and A. Zisserman.
Return of the devil in the details: Delving deep into convolu-
tional nets. In British Machine Vision Conference (BMVC),
2014.

[4] A. Gionis, P. Indyk, and R. Motwani. Similarity search in
In Proc. International Conf.

high dimensions via hashing.
on Very Large Data Bases (VLDB), 1999.

[5] Y. Gong and S. Lazebnik.

Iterative quantization: A pro-
crustean approach to learning binary codes. In Proc. IEEE
Conf. on Computer Vision and Pattern Recognition (CVPR),
2011.

[6] L.-K. Huang, Q. Y. Yang, and W.-S. Zheng. Online hashing.
In Proc. International Joint Conf. on Artiﬁcial Intelligence
(IJCAI), 2013.

[7] A. Krizhevsky and G. Hinton. Learning multiple layers of

features from tiny images, 2009.

[8] A. Krizhevsky, I. Sutskever, and G. E. Hinton.

Imagenet
classiﬁcation with deep convolutional neural networks.
In
Proc. Advances in Neural Information Processing Systems
(NIPS), 2012.

[9] B. Kulis and T. Darrell. Learning to hash with binary recon-
structive embeddings. In Proc. Advances in Neural Informa-
tion Processing Systems (NIPS), 2009.

[10] H. Lai, Y. Pan, Y. Liu, and S. Yan. Simultaneous feature
learning and hash coding with deep neural networks.
In
Proc. IEEE Conf. on Computer Vision and Pattern Recog-
nition (CVPR), 2015.

[11] C. Leng, J. Wu, J. Cheng, X. Bai, and H. Lu. Online sketch-
ing hashing. In Proc. IEEE Conf. on Computer Vision and
Pattern Recognition (CVPR), 2015.

[12] W.-J. Li, S. Wang, and W.-C. Kang. Feature learning based
deep supervised hashing with pairwise labels. In Proc. Inter-
national Joint Conf. on Artiﬁcial Intelligence (IJCAI), 2016.
[13] G. Lin, F. Liu, C. Shen, J. Wu, and H. T. Shen. Structured
learning of binary codes with column generation for optimiz-
International Journal of Computer
ing ranking measures.
Vision (IJCV), pages 1–22, 2016.

[14] G. Lin, C. Shen, Q. Shi, A. van den Hengel, and D. Suter.
Fast supervised hashing with decision trees for high-
dimensional data. In Proc. IEEE Conf. on Computer Vision
and Pattern Recognition (CVPR), 2014.

[15] K. Lin, J. Lu, C.-S. Chen, and J. Zhou. Learning compact
binary descriptors with unsupervised deep neural networks.
In Proc. IEEE Conf. on Computer Vision and Pattern Recog-
nition (CVPR), 2016.

[16] J. W. Liu, Wei and, R. Ji, Y.-G. Jiang, and S.-F. Chang. Su-
pervised hashing with kernels. In Proc. IEEE Conf. on Com-
puter Vision and Pattern Recognition (CVPR), 2012.
[17] C. D. Manning, P. Raghavan, and H. Sch¨utze. Introduction

to information retrieval. 2008.

Appendix

A. Implementation Details of MIHash

We discuss the implementation details of MIHash.
In
the online hashing experiments, for simplicity we model
MIHash using linear hash functions, in the form of φi(x) =
sgn(w(cid:62)
i x) ∈ {−1, +1}, i = 1, . . . , b. The learning capac-
ity of such a model is lower than the kernel-based OKH, and
is the same as OSH, AdaptHash, and SketchHash, which
use linear hash functions as well.

For the batch hashing experiments, as mentioned in the
paper, we similarly model MIHash using linear hash func-
tions in the ﬁrst setting, but perform end-to-end learning
with the VGG-F network in the second setting.
In this
case, the hash functions become φi(x) = sgn(fi(x; w)) ∈
{−1, +1}, i = 1, . . . , b, where fi are the logits produced by
the previous layer in the network.

We train MIHash using stochastic gradient descent. In
Eq. 11 in the paper, we gave the gradients of the mutual in-
formation objective I with respect to the outputs of the hash
mapping, Φ(x). Both I and ∂I/∂Φ(x) are parameter-free.
In order to further back-propagate gradients to the inputs of
Φ(x) and model parameters {wi}, we approximate the sgn
function using the sigmoid function σ:

φi(x) ≈ 2σ(Aw(cid:62)

i x) − 1,

(18)

where A > 1 is a scaling parameter, used to increase the
“sharpness” of the approximation. We ﬁnd A from the set
{10, 20, 30, 40, 50} in our experiments.

We note that A is not a tuning parameter of the mutual
information objective, but rather a parameter of the under-
lying hash functions. The design of the hash functions is
not coupled with the mutual information objective, thus can
be separated. It will be an interesting topic to explore other
methods of constructing hash functions, potentially in ways
that are free of tuning parameters.

B. Experimental Details

B.1. The streaming scenario

We set up a streaming scenario in our online hashing ex-
periments. We run three randomized trials for each experi-
ment. In each trial, we ﬁrst randomly split the dataset into
a retrieval set and a test set as described in Sec. 4.1 in the
paper, and randomly sample the training subset from the re-
trieval set. The ordering of the training set is also randomly
permuted. The random seeds are ﬁxed, so the baselines and
methods with the Trigger Update module observe the same
training sequences.

In a streaming setting, we also measure the cumulative
retrieval performance during online hashing, as opposed to
only the ﬁnal results. To mimic real retrieval systems where

queries arrive randomly, we set 50 randomized checkpoints
during the online process. We ﬁrst place the checkpoints
with equal spacing, then add small random perturbations
to their locations. We measure the instantaneous retrieval
mAP at these checkpoints to get mAP vs. time curves (e.g.
curves shown in Fig. 5 in the paper), and compute the area
under curve (AUC). AUC gives a summary of the entire on-
line learning process, which cannot be reﬂected by the ﬁnal
performance at the end.

B.2. Parameters for online hashing methods

We describe parameters used for online hashing methods
in the online experiments. Some of the competing methods
require parameter tuning, therefore we sample a validation
set from the training data and ﬁnd the best performing pa-
rameters for each method. The size of the validation sets are
2K, 2K and 10K for CIFAR-10, LabelMe and Places205,
respectively. Please refer to the respective papers for the
descriptions of the parameters.

• OSH: η is set to 0.1 for all datasets. The ECOC code-

book C is populated the same way as in OSH.

• AdaptHash:

to
tuple
(0.9, 0.01, 0.1), (0.1, 0.01, 0.001) and (0.9, 0.01, 0.1)
for CIFAR-10, LabelMe and Places205, respectively.

(α, λ, η)

the

set

is

• OKH:

the tuple (C, α)

to (0.001, 0.3),
(0.001, 0.3) and (0.0001, 0.7) for CIFAR-10, LabelMe
and Places205, respectively.

set

is

• SketchHash: the pair (sketch size, batch size) is set to
(200, 50), (100, 50) and (100, 50) for CIFAR-10, La-
belMe and Places205, respectively.

B.3. Parameters for batch hashing methods

We use the publicly available implementations for the
compared methods, and exhaustively search parameter set-
tings, including the default parameters as provided by the
authors. For DPSH and DTSH we found a combination that
worked well for the ﬁrst setting: the mini-batch size is set to
the default value of 128, and the learning rate is initialized
to 1 and decayed by a factor of 0.9 after every 20 epochs.
Additionally, for DTSH, the margin parameter is set to b/4
where b is the hash code length. VDSH uses a heavily cus-
tomized architecture with only fully-connected layers, and
it is unclear how to adapt it to work with standard CNN ar-
chitectures. In this sense, VDSH is more akin to nonlinear
hashing methods such as FastHash and SHK. We used the
full VDSH model with 16 layers and 1024 nodes per layer,
and found the default parameters to perform the best, ex-
cept that we increased the number of training iterations by
an order of magnitude during ﬁnetuning.

For MIHash, in the ﬁrst setting we use a batch size of
100, and run SGD with initial learning rate of 0.1 and a

Method

Training Time (s)

Training Time (s)

OKH
OKH + TU
OSH
OSH + TU
AdaptHash
AdaptHash + TU
SketchHash
SketchHash + TU

10.8
23.6
97.6
175.8
47.8
94.8
68.8
80.0

Method

SHK
SDH
FastHash
VDSH*
DPSH
DTSH
MIHash, 1ep
MIHash

mAP

0.682
0.592
0.738
0.554
0.553
0.702
0.609
0.746

180
4.8
140
206
450
1728
1.9
190

Table 2: Online hashing: running times on the CIFAR-10
20k training set, with 32-bit hash codes. For methods with
the TU plugin, the added time is due to maintaining the
reservoir set and computing the mutual information update
criterion, and is dominated by the maintaining of the reser-
voir set.

decay factor of 0.5 every 10 epochs, for 100 epochs. For
the second setting where we ﬁnetune the pretrained VGG-F
network, batch size is 250, learning rate is initially set to
0.001 and decayed by half every 50 epochs.

C. Running Time

C.1. Online Setting: Trigger Update Module

In Table 2 we report running time for all methods on
the CIFAR-10 dataset with 20k training examples, includ-
ing time spent in learning hash functions and the added pro-
cessing time for maintaining the reservoir set and comput-
ing TU. Numbers are recorded on a 2.3GHz Intel Xeon E5-
2650 CPU workstation with 128GB of DDR3 RAM. Most
of the added time is due to maintaining the reservoir set,
which is invoked in each training iteration; the mutual in-
formation update criterion is only checked after processing
every U = 100 examples. Methods with small batch sizes
(e.g. OSH, batch size 1) therefore incur more overhead than
methods with larger batches (e.g. SketchHash, batch size
50). Results for other datasets are similar.

We note that in a real retrieval system with large-scale
data, the bottleneck likely lies in recomputing the hash ta-
bles for indexed data, due to various factors such as schedul-
ing and disk I/O. We reduce this bottleneck signiﬁcantly by
using TU. Compared to this bottleneck, the increase in train-
ing time is not signiﬁcant.

C.2. Batch Setting

Table 3 reports CPU times for learning 48-bit hash map-
pings in the ﬁrst experimental setting on CIFAR-10 (5K
training set). Retrieval mAP are replicated from Table 1
in the paper. For learning a single layer, our Matlab im-
plementation of MIHash achieves 1.9 seconds per epoch
on CPU. MIHash achieves competitive performance with
a single epoch, and has a total training time on par with

Table 3: Batch hashing: test performance and training time
for 48-bit codes on the CIFAR-10, using the 5k training set.
*VDSH is trained with the full model as detailed in B.3.
1ep stands for training for one epoch only.

FastHash, while yielding superior performance.

D. Additional Experimental Results

D.1. Online Hashing: Other Code Lengths

In the online hashing experiments we reported in the pa-
per, all online hashing methods are compared in the same
setup with 32-bit hash codes. Additionally, we also present
results using 64-bit hash codes on all three datasets. The
parameters for all methods are found through validation as
described in B.2.

Similar to Sec 4.2 in the paper, we show the comparisons
with and without TU for existing online hashing methods in
Fig. 7, and plot the mAP curves for all methods, includ-
ing MIHash, in Fig. 8. The 64-bit results are uniformly
better than 32-bit results for all methods in terms of mAP,
but still follow the same patterns. Again, we can see that
MIHash clearly outperforms all competing online hashing
methods, and shows potential for improvement given more
training data.

D.2. Parameter Study: θ

We present a parameter study on the parameter θ, the im-
provement threshold on the mutual information criterion in
TU. In our previous experiments, we found the default θ = 0
to work well, and did not speciﬁcally tune θ. However, tun-
ing for a larger θ could lead to better trade-offs, since small
improvements in the quality of the hash mapping may not
justify the cost of a full hash table update.

For this study, we vary parameter θ from −∞ to ∞ for
all methods (with 32-bit hash codes). θ = −∞ reduces to
the baseline. On the other hand, θ = ∞ prevents any up-
dates to the initial hash mapping and hash table, and results
in only one hash table update (for the initial mapping) and
typically low performance. The performance metric we fo-
cus on in this study is the cumulative metric, AUC, since
it better summarizes the entire online learning process than
the ﬁnal performance alone.

Figure 7: 64-bit experiments: Retrieval mAP vs. number of training examples for four existing online hashing methods on
the three datasets, with and without Trigger Update (TU). We use default threshold θ = 0 for TU. Circles indicate hash table
updates, and the ratio of reduction in the number of updates is marked for each graph. TU substantially reduces the number
of updates while having a stabilizing effect on the retrieval performance. Note: since the OSH method assumes supervision
in terms of class labels, it is not applicable to the unsupervised LabelMe dataset.

Figure 8: 64-bit experiments: Online hashing performance (mAP) comparison on three datasets, where all methods use
the Trigger Update module (TU) with θ = 0. Using the mutual information objective, MIHash clearly outperforms other
methods. OKH, AdaptHash, ad SketchHash perform very similarly on CIFAR-10. OSH, AdaptHash, ad SketchHash perform
very similarly on Places205. Again, the OSH method is not applicable to the unsupervised LabelMe dataset.

We use a custom update schedule for SketchHash: we
enforce hash table updates in the early iterations regard-
less of other criteria, until the number of observed exam-
ples reaches the speciﬁed size of the “data sketch”, which
SketchHash uses to perform a batch hashing algorithm.
This was observed to be critical for the performance of
SketchHash. Therefore, the number of hash table updates
for SketchHash can be greater than 1 even for θ = ∞.

We present full results in Tables 4, 5, 6. In all cases, we
observe a substantial decrease in the number of hash table
updates as θ increases. With reasonable θ values (typically
around 0), the number of hash table updates can be reduced
by over an order of magnitude with no loss in AUC. Note
that the computation-performance trade-off achieved by the
default θ = 0 is always among the best, thereby in practice
it can be used without tuning.

D.3. Parameter Study: U

We simulate a data-agnostic baseline that updates hash
tables at a constant rate, using the update interval param-
eter U .
In the paper, U is set such that the baseline up-
dates a total of 201 times for all datasets. This ensures that
the baseline is never too outdated (compared to 50 check-
points at which performance is evaluated), but is still fairly
infrequent: the smallest U in this case is 100, which means
the baselines process at least 100 training examples before
recomputing the hash table. For completeness, here we
present the results using different values of U , where all
methods again use 32-bit hash codes and the default θ = 0.
We used a simple rule that avoids unnecessary hash table
updates if the hash mapping itself does not change. Specif-
ically, we do not update if (cid:107)Φt − Φs(cid:107) < 10−6, where Φs
is the current snapshot and Φt is the new candidate. Some
baseline entries have fewer updates because of this rule (e.g.
AdaptHash on Places205). And as explained before, due to
the custom update schedule, SketchHash may have more
hash table updates than what is suggested by U .

Please see Tables 7, 8, 9 for the full results. In all experi-
ments, we run three random trials and average the results as
mentioned before, and the standard deviation of mAP and
AUC scores are less than 0.01. Generally, using smaller
U leads to more updates by both the baselines and methods
with TU; recall that U is also a parameter of TU which spec-
iﬁes the frequency of checking the update criterion. How-
ever, methods with the TU module appear to be quite in-
sensitive to the choice of U , e.g. the number of updates
for SketchHash with TU on CIFAR-10 only increases by 2x
while U is reduced by 20x, from 1000 to 50. We attribute
this to the ability of TU to ﬁlter out unnecessary updates.
Across different values of U , TU consistently brings compu-
tational savings while preserving/improving online hashing
performance, as indicated by ﬁnal mAP and AUC.

CIFAR-10, 32 bits
HT Updates
201
190 (5.8x)
8.0 (25.1x)
8.0 (25.1x)
7.7 (26.1x)
3.3 (91.2x)
1.0 (201x)
HT Updates
201
39.0 (5.2x)
36.7 (5.5x)
35.7 (5.6x)
6.7 (30x)
2.0 (100x)
1.0 (201x)
AdaptHash HT Updates

OKH
≤ −0.1
−0.01
−10−4
0
10−4
0.01
≥ 0.2
OSH
≤ −0.01
−10−4
0
10−4
0.01
0.1
≥ 0.3

≤ −0.1
−0.01
−10−4
0
10−4
0.01
≥ 0.1

201
68.3 (2.9x)
10.3 (19.5x)
10.0 (20.1x)
10.0 (20.1x)
3.3 (60.9x)
1.0 (201x)
SketchHash HT updates

≤ −0.01
−10−4
−10−6
0
10−4
0.01
≥ 0.1

201
9.0 (22.3x)
7.3 (27.5x)
7.3 (27.5x)
7.3 (27.5x)
4.3 (46.7x)
4.0 (50.3x)

–

–

AUC ∆AUC
0.259
0.260 +0.4%
0.287 +10.8%
0.287 +10.8%
0.287 +10.8%
+8.1%
0.280
0.134 −48.3%
AUC ∆AUC
0.463
0.466 +0.6%
0.466 +0.6%
0.466 +0.6%
0.453 −2.1%
−16%
0.386
−55%
0.207
AUC ∆AUC
0.218
0.238 +9.2%
0.250 +14.7%
0.250 +14.7%
0.250 +14.7%
0.244 +11.9%
0.211 −3.3%
AUC ∆AUC
0.304
0.318 +4.6%
0.319 +4.9%
0.319 +4.9%
0.319 +4.9%
0.318 +4.6%
0.314 +3.3%

–

–

Table 4: Parameter study on the threshold value θ for on-
line hashing methods on CIFAR-10 (32 bits). We report
the number of hash table updates, where 100x indicates a
100 times reduction with respect to the baseline. We also
report the area under the mAP curve (AUC) and compare to
baseline.

OKH
≤ −0.01
−10−4
−10−6
0
10−6
10−4
0.01
≥ 0.1
OSH
≤ −0.001
−20−4
−10−4
0
10−4
10−3
≥ 0.1

Places205, 32 bits
HT Updates
201
8.3 (24.2x)
7.0 (28.7x)
7.0 (28.7x)
7.0 (28.7x)
5.7 (35.3x)
2.0 (100x)
1.0 (201x)
HT Updates
201
101 (2.0x)
9.3 (21.6x)
7.0 (28.7x)
5.7 (35.3x)
2.7 (74.4x)
1.0 (201x)
AdaptHash HT Updates
≤ −0.01
−10−4
−10−6
0
10−6
10−4
≥ 0.01

199.7
199 (1.0x)
9.7 (20.6x)
8.7 (23.0x)
8.7 (23.0x)
3.0 (66.6x)
1.0 (201x)
SketchHash HT Updates

≤ −0.01
−10−4
−10−6
0
10−6
10−4
≥ 0.01

201
52.3 (3.8x)
15.3 (12.6x)
12.7 (15.8x)
15.3 (13.1x)
7.0 (28.7x)
2.0 (101x)

–

–
0%

AUC ∆AUC
0.163
0.161 −1.2%
0.161 −1.2%
0.161 −1.2%
0.161 −1.2%
0.161 −1.2%
−25%
0.123
−91%
0.014
AUC ∆AUC
0.246
0.246
0.236 −4.1%
0.236 −4.1%
0.230 −6.5%
0.224 −8.9%
0.226 −8.1%
AUC ∆AUC
0.237
0.237
0.236 −0.4%
0.236 −0.4%
0.235 −0.8%
0.235 −0.8%
0.227 −3.4%
AUC ∆AUC
0.237
0.238 +0.4%
0.238 +0.4%
0.236 −0.4%
0.238 +0.4%
0.239 +0.8%
0.223 −5.9%

–
0%

–

LabelMe, 32 bits
HT Updates
201
196 (1.0x)
2.7 (74.4x)
2.3 (87.4x)
2.3 (87.4x)
2.3 (87.4x)
2.0 (101x)
1.0 (201x)
AdaptHash HT Updates

OKH
≤ −0.2
−0.1
−0.01
−10−6
0
10−6
0.01
≥ 0.6

≤ −0.1
−10−6
−10−4
−10−2
0
10−6
10−4
10−2
≥ 0.1

≤ −0.1
−10−2
−10−4
0
10−4
10−2
≥ 0.1

201
149 (1.3x)
9.3 (21.6x)
8.7 (23.1x)
5.3 (37.9x)
8.7 (23.1x)
8.3 (24.2x)
2.7 (74.4x)
1 (201x)

201
195 (1.0x)
9.3 (21.6x)
8.7 (23.1x)
10 (20.1x)
4.7 (42.8x)
4.0 (50.3x)

SketchHash HT Updates

–

–

AUC ∆AUC
0.198
0.199 +0.5%
+88%
0.373
+89%
0.374
+89%
0.374
+89%
0.374
+88%
0.372
−44%
0.111
AUC ∆AUC
0.333
0.330 −0.9%
0.365 +9.6%
0.365 +9.6%
+11%
0.369
0.365 +9.6%
0.358 +7.5%
0.351 +5.4%
−11%
0.296
AUC ∆AUC
0.446
0.446
0.460 +3.1%
0.460 +3.1%
0.459 +2.9%
0.446
0.439 −1.6%

–
0%

0%

Table 5: Parameter study on the threshold value θ for on-
line hashing methods on Places205 (32 bits). We report the
number of hash table updates, where 100x indicates a 100
times reduction with respect to the baseline. We also re-
port the area under the mAP curve (AUC) and compare to
baseline.

Table 6: Parameter study on the threshold value θ for online
hashing methods on LabelMe (32 bits). We report the num-
ber of hash table updates, where 100x indicates a 100 times
reduction with respect to the baseline. We also report the
area under the mAP curve (AUC) and compare to baseline.
Note: OSH is not applicable to this unlabeled dataset since
it needs supervision in terms of class labels.

CIFAR-10, 32 bits

Final mAP AUC (mAP)

Method

OKH, U = 10

OKH, U = 100

OKH, U = 1000

OSH, U = 10

OSH, U = 100

OSH, U = 1000

AdaptHash, U = 10

AdaptHash, U = 100

AdaptHash, U = 1000

SketchHash, U = 50

SketchHash, U = 100

SketchHash, U = 1000

1870

201
8 (25.1x)
21
2.6 (8x)
2001
110.7 (18x)
201
36.7 (5.4x)
21
11.3 (1.9x)
2001

TU HT Updates
×
(cid:88) 15.6 (119.3x)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88) 19.6 (101.7x)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)

201
10.0 (10.1x)
21
5 (4.2x)
400
9 (44.4x)
202
7.3 (27.5x)
24
4.6 (5.2x)

0.238
0.297
0.238
0.291
0.238
0.282
0.480
0.483
0.480
0.483
0.480
0.479
0.244
0.267
0.244
0.255
0.244
0.252
0.306
0.318
0.306
0.320
0.306
0.317

0.259
0.293 (+13%)
0.259
0.287 (+10.8%)
0.255
0.273 (+7%)
0.463
0.466 (+0.6%)
0.463
0.466 (+0.6%)
0.454
0.454
0.224
0.261 (+16%)
0.224
0.250 (+11.6%)
0.222
0.234 (+5%)
0.303
0.318 (+5%)
0.304
0.319 (+4.9%)
0.305
0.314 (+2.9%)

Table 7: Online hashing results (32 bits) with different update interval parameters (U ) on the CIFAR-10 dataset. All results
are averaged from 3 random trials. For the number of hash table updates, we report the reduction ratio (e.g. 8x) for TU. For
AUC, we report the relative change compared to baseline. Note: SketchHash uses a batch size of 50, therefore the smallest
U is set to 50.

LabelMe, 32 bits

Final mAP AUC (mAP)

Method

OKH, U = 10

OKH, U = 100

OKH, U = 1000

AdaptHash, U = 10

AdaptHash, U = 100

AdaptHash, U = 1000

SketchHash, U = 50

SketchHash, U = 100

SketchHash, U = 1000

2001
8 (250x)
201
2.3 (86.2x)
21
2 (10.5x)
2001

TU HT Updates
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88) 12.6 (157.9x)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)

201
8.6 (23.1x)
21
5 (4.2x)
400
9.6 (41.6x)
202
8.67 (23.2x)
24
8.3 (2.8x)

0.119
0.382
0.119
0.380
0.119
0.373
0.318
0.380
0.318
0.379
0.318
0.343
0.445
0.461
0.445
0.462
0.445
0.456

0.200
0.377 (+88.5%)
0.200
0.374 (+87%)
0.193
0.357 (+85%)
0.319
0.371 (+16.3%)
0.318
0.365 (+14.7%)
0.317
0.337 (+6.3%)
0.447
0.460 (+2%)
0.446
0.460 (+3.1%)
0.445
0.455 (+2%)

Table 8: Online hashing results (32 bits) with different update interval parameters (U ) on the LabelMe dataset. All results
are averaged from 3 random trials. For the number of hash table updates, we report the reduction ratio (e.g. 8x) for TU. For
AUC, we report the relative change compared to baseline. Note: since LabelMe is an unsupervised dataset, the OSH method
is not applicable since it requires supervision in the form of class labels.

Places205, 32 bits

Final mAP AUC (mAP)

Method

OKH, U = 50

OKH, U = 500

OKH, U = 5000

OSH, U = 50

OSH, U = 500

OSH, U = 5000

AdaptHash, U = 50

AdaptHash, U = 500

AdaptHash, U = 5000

SketchHash, U = 50

SketchHash, U = 500

SketchHash, U = 5000

2001
8 (250.1x)
201
7 (28.7x)
21
2 (10.5x)
2001
25 (80x)
201
7 (28.7x)
21
2 (10.5x)
823.7
26.6 (30.8x)
200
8.6 (23.0x)
21
3 (7x)
2000

TU HT Updates
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88) 19.3 (103.4x)
×
(cid:88)
×
(cid:88)

202
15.3 (13.1x)
22
6.6 (3.2x)

0.182
0.173
0.182
0.165
0.182
0.157
0.248
0.239
0.248
0.236
0.248
0.234
0.238
0.236
0.238
0.236
0.238
0.236
0.238
0.236
0.237
0.240
0.235
0.239

0.163
0.169 (+3.7%)
0.163
0.161 (-1.2%)
0.156
0.148 (-5.1%)
0.246
0.238 (-3%)
0.246
0.236 (-4.0%)
0.245
0.233 (-4%)
0.237
0.236 (-0.4%)
0.237
0.236 (-0.4%)
0.237
0.236 (-0.4%)
0.235
0.235 (0%)
0.235
0.238 (+1.2%)
0.235
0.238 (+1.2%)

Table 9: Online hashing results (32 bits) with different update interval parameters (U ) on the Places205 dataset. All results
are averaged from 3 random trials. For the number of hash table updates, we report the reduction ratio (e.g. 8x) for TU. For
and AUC, we report the relative change compared to baseline.

MIHash: Online Hashing with Mutual Information

Fatih Cakir∗ Kun He∗

Sarah Adel Bargal

Stan Sclaroff

Department of Computer Science
Boston University, Boston, MA
{fcakir,hekun,sbargal,sclaroff}@cs.bu.edu

7
1
0
2
 
l
u
J
 
9
2
 
 
]

V
C
.
s
c
[
 
 
2
v
9
1
9
8
0
.
3
0
7
1
:
v
i
X
r
a

Abstract

Learning-based hashing methods are widely used for
nearest neighbor retrieval, and recently, online hashing
methods have demonstrated good performance-complexity
trade-offs by learning hash functions from streaming data.
In this paper, we ﬁrst address a key challenge for online
hashing:
the binary codes for indexed data must be re-
computed to keep pace with updates to the hash functions.
We propose an efﬁcient quality measure for hash functions,
based on an information-theoretic quantity, mutual infor-
mation, and use it successfully as a criterion to eliminate
unnecessary hash table updates. Next, we also show how to
optimize the mutual information objective using stochastic
gradient descent. We thus develop a novel hashing method,
MIHash, that can be used in both online and batch settings.
Experiments on image retrieval benchmarks (including a
2.5M image dataset) conﬁrm the effectiveness of our for-
mulation, both in reducing hash table recomputations and
in learning high-quality hash functions.

1. Introduction

Hashing is a widely used approach for practical nearest
neighbor search in many computer vision applications. It
has been observed that adaptive hashing methods that learn
to hash from data generally outperform data-independent
hashing methods such as Locality Sensitive Hashing [4]. In
this paper, we focus on a relatively new family of adaptive
hashing methods, namely online adaptive hashing methods
[1, 2, 6, 11]. These techniques employ online learning in the
presence of streaming data, and are appealing due to their
low computational complexity and their ability to adapt to
changes in the data distribution.

Despite recent progress, a key challenge has not been
addressed in online hashing, which motivates this work:
the computed binary representations, or the “hash table”,
may become outdated after a change in the hash mapping.
To reﬂect the updates in the hash mapping, the hash table

∗First two authors contributed equally.

ˆx and non-neighbors in

Figure 1: We study online hashing for efﬁcient nearest
neighbor retrieval. Given a hash mapping Φ, an image ˆx,
ˆx,
along with its neighbors in
(cid:22)
are mapped to binary codes, yielding two distributions of
Hamming distances. In this example, Φ1 has higher quality
than Φ2 since it induces more separable distributions. The
information-theoretic quantity Mutual Information can be
used to capture the separability, which gives a good quality
indicator and learning objective for online hashing.

(cid:23)

may need to be recomputed frequently, causing inefﬁcien-
cies in the system such as successive disk I/O, especially
when dealing with large datasets. We thus identify an im-
portant question for online adaptive hashing systems: when
to update the hash table? Previous online hashing solutions
do not address this question, as they usually update both the
hash mapping and hash table concurrently.

We make the observation that achieving high quality
nearest neighbor search is an ultimate goal in hashing sys-
tems, and therefore any effort to limit computational com-
plexity should preserve, if not improve, that quality. There-
fore, another important question is: how to quantify qual-
ity? Here, we brieﬂy describe our answer to this question,
but ﬁrst introduce some necessary notation. We would like
to learn a hash mapping Φ from feature space X to the b-
dimensional Hamming space Hb, whose outputs are b-bit

(cid:22)

(cid:23)

ˆx, and a set of non-neighbors

binary codes. The goal of hashing is to preserve a neighbor-
hood structure in X after the mapping to Hb. Given ˆx ∈ X ,
the neighborhood structure is usually given in terms of a set
of its neighbors
ˆx. We
discuss how to derive the neighborhood structure in Sec. 3.
As shown in Fig. 1, the distributions of the Hamming
distances from ˆx to its neighbors and non-neighbors are his-
tograms over {0, 1, . . . , b}. Ideally, if there is no overlap
between these two distributions, we can recover
ˆx
by simply thresholding the Hamming distance. A nonzero
overlap results in ambiguity, as observing the Hamming dis-
tance is no longer sufﬁcient to determine neighbor relation-
ships. Our discovery is that this overlap can be quanti-
ﬁed using an information-theoretic quantity, mutual infor-
mation, between two random variables induced by Φ. We
then use mutual information to deﬁne a novel measure to
quantify quality for hash functions in general.

ˆx and

(cid:23)

(cid:22)

With a quality measure deﬁned, we answer the motivat-
ing question of when to update the hash table. We propose
a simple solution by restricting updates to times when there
is an estimated improvement in hashing quality, based on
an efﬁcient estimation method in the presence of streaming
data. Notably, since mutual information is a good general-
purpose quality measure for hashing, this results in a gen-
eral plug-in module for online hashing that does not require
knowledge of the learning method.

Inspired by this strong result, we next ask, can we opti-
mize mutual information as an objective to learn hash func-
tions? We propose a novel hashing method, MIHash, by
deriving gradient descent rules on the mutual information
objective, which can be applied in online stochastic opti-
mization, as well as on deep architectures. The mutual in-
formation objective is free of tuning parameters, unlike oth-
ers that may require thresholds, margins, etc.

We conduct experiments on three image retrieval bench-
marks, including the Places205 dataset [32] with 2.5M im-
ages. For four recent online hashing methods, our mu-
tual information based update criterion consistently leads to
over an order of magnitude reduction in hash table recom-
putations, while maintaining retrieval accuracy. Moreover,
our novel MIHash method achieves state-of-the-art retrieval
results, in both online and batch learning settings.

2. Related Work

In this section, we mainly review hashing methods that
adaptively update the hash mapping with incoming data,
given that our focus is on online adaptive hashing. For a
more general survey on hashing, please refer to [25].

Huang et al. [6] propose Online Kernel Hashing, where
a stochastic environment is considered with pairs of points
arriving sequentially. At each step, a number of hash func-
tions are selected based on a Hamming loss measure and pa-
rameters are updated via stochastic gradient descent (SGD).

Cakir and Sclaroff [1] argue that, in a stochastic setting,
it is difﬁcult to determine which hash functions to update as
it is the collective effort of all the hash functions that yields
a good hash mapping. Hamming loss is considered to infer
the hash functions to be updated at each step and a squared
error loss is minimized via SGD.

In [2], binary Error Correcting Output Codes (ECOCs)
are employed in learning the hash functions. This work
follows a more general two-step hashing framework [14],
where the set of ECOCs are generated beforehand and are
assigned to labeled data as they appear, allowing the label
space to grow with incoming data. Then, hash functions are
learned to ﬁt the binary ECOCs using Online Boosting.

Inspired by the idea of “data sketching”, Leng et al. in-
troduce Online Sketching Hashing [11] where a small ﬁxed-
size sketch of the incoming data is maintained in an online
fashion. The sketch retains the Frobenius norm of the full
data matrix, which offers space savings, and allows to ap-
ply certain batch-based hashing methods. A PCA-based
batch learning method is applied on the sketch to obtain
hash functions.

None of the above online hashing methods offer a solu-
tion to decide whether or not the hash table shall be updated
given a new hash mapping. However, such a solution is
crucial in practice, as limiting the frequency of updates will
alleviate the computational burden of keeping the hash ta-
ble up-to-date. Although [2] and [6] include strategies to
select individual hash functions to recompute, they still re-
quire computing on all indexed data instances.

Recently, some methods employ deep neural networks
to learn hash mappings, e.g. [12, 15, 27, 30] and others.
These methods use minibatch-based stochastic optimiza-
tion, however, they usually require multiple passes over a
given dataset to learn the hash mapping, and the hash table
is only computed when the hash mapping has been learned.
Therefore, current deep learning based hashing methods are
essentially batch learning methods, which differ from the
online hashing methods that we consider, i.e. methods that
process streaming data to learn and update the hash map-
pings on-the-ﬂy while continuously updating the hash ta-
ble. Nevertheless, when evaluating our mutual information
based hashing objective, we compare against state-of-the-
art batch hashing formulations as well, by contrasting dif-
ferent objective functions on the same model architecture.

Lastly, Ustinova et al. [23] recently proposed a method
to derive differentiation rules for objective functions that re-
quire histogram binning, and apply it in learning deep em-
beddings. When optimizing our mutual information objec-
tive, we utilize their differentiable histogram binning tech-
nique for deriving gradient-based optimization rules. Note
that both our problem setup and objective function are quite
different from [23].

3. Online Hashing with Mutual Information

As mentioned in Sec. 1, the goal of hashing is to learn a
hash mapping Φ : X → Hb such that a desired neighbor-
hood structure is preserved. We consider an online learning
setup where Φ is continuously updated from input stream-
ing data, and at time t, the current mapping Φt is learned
from {x1, . . . , xt}. We follow the standard setup of learn-
ing Φ from pairs of instances with similar/dissimilar labels
[9, 6, 1, 12]. These labels, along with the neighborhood
structure, can be derived from a metric, e.g. two instances
are labeled similar (i.e. neighbors of each other) if their Eu-
clidean distance in X is below a threshold. Such a setting
is often called unsupervised hashing. On the other hand, in
supervised hashing with labeled data, pair labels are derived
from individual class labels: instances are similar if they are
from the same class, and dissimilar otherwise.

Below, we ﬁrst derive the mutual information quality
measure and discuss its use in determining when to update
the hash table in Sec. 3.1. We then describe a gradient-based
approach for optimizing the same quality measure, as an ob-
jective for learning hash mappings, in Sec. 3.2. Finally, we
discuss the beneﬁts of using mutual information in Sec. 3.3.

3.1. MI as Update Criterion

We revisit our motivating question: When to update the
hash table in online hashing? During the online learn-
ing of Φt, we assume a retrieval set S ⊆ X , which may
include the streaming data after they are received. We
deﬁne the hash table as the set of hashed binary codes:
T (S, Φ) = {Φ(x)|x ∈ S}. Given the adaptive nature of
online hashing, T may need to be recomputed often to keep
pace with Φt; however, this is undesirable if S is large or the
change in Φt’s quality does not justify the cost of an update.
We propose to view the learning of Φt and computa-
tion of T as separate events, which may happen at different
rates. To this end, we introduce the notion of a snapshot,
denoted Φs, which is occasionally taken of Φt and used
to recompute T . Importantly, this happens only when the
nearest neighbor retrieval quality of Φt has improved, and
we now deﬁne the quality measure.

Given hash mapping Φ : X → {−1, +1}b, Φ induces

Hamming distance dΦ : X × X → {0, 1, . . . , b} as

dΦ(x, ˆx) =

(cid:0)b − Φ(x)(cid:62)Φ(ˆx)(cid:1) .

(1)

1
2

Consider some instance ˆx ∈ X , and the sets contain-
ˆx. Φ induces
ing neighbors and non-neighbors,
two conditional distributions, P (dΦ(x, ˆx)|x ∈
ˆx) and
P (dΦ(x, ˆx)|x ∈
ˆx) as seen in Fig. 1, and it is desir-
able to have low overlap between them. To formulate the
idea, for Φ and ˆx, deﬁne random variable Dˆx,Φ : X →
{0, 1, . . . , b}, x (cid:55)→ dΦ(x, ˆx), and let Cˆx : X → {0, 1} be

ˆx and

(cid:22)

(cid:23)

(cid:22)

(cid:23)

ˆx. The two conditional dis-
the membership indicator for
(cid:22)
tributions can now be expressed as P (Dˆx,Φ|Cˆx = 1) and
P (Dˆx,Φ|Cˆx = 0), and we can write the mutual information
between Dˆx,Φ and Cˆx as

I(Dˆx,Φ; Cˆx) = H(Cˆx) − H(Cˆx|Dˆx,Φ)

= H(Dˆx,Φ) − H(Dˆx,Φ|Cˆx)

(2)

(3)

D, and pD, respectively.

where H denotes (conditional) entropy. In the following,
for brevity we will drop subscripts Φ and ˆx, and denote the
two conditional distributions and the marginal P (Dˆx,Φ) as
p+
D, p−
By deﬁnition, I(D; C) measures the decrease in uncer-
tainty in the neighborhood information C when observing
the Hamming distances D. We claim that I(D; C) also cap-
tures how well Φ preserves the neighborhood structure of ˆx.
If I(D; C) attains a high value, which means C can be de-
termined with low uncertainty by observing D, then Φ must
have achieved good separation (i.e. low overlap) between
p+
D and p−
D. I is maximized when there is no overlap, and
minimized when p+
D are exactly identical. Recall,
however, that I is deﬁned with respect to a single instance
ˆx; therefore, for a general quality measure, we integrate I
over the feature space:

D and p−

Q(Φ) =

I(Dˆx,Φ; Cˆx)p(ˆx)dˆx.

(4)

(cid:90)

X

Q(Φ) captures the expected amount of separation between
D and p−
p+
D achieved by Φ, over all instances in X .
In the online setting, given the current hash mapping Φt
and previous snapshot Φs, it is then straightforward to pose
the update criterion as

Q(Φt) − Q(Φs) > θ,

(5)

where θ is a threshold; a straightforward choice is θ = 0.
However, Eq. 4 is generally difﬁcult to evaluate due to the
intractable integral; in practice, we resort to Monte-Carlo
approximations to this integral, as we describe next.

Monte-Carlo Approximation by Reservoir Sampling
We give a Monte-Carlo approximation of Eq. 4. Since we
work with streaming data, we employ the Reservoir Sam-
pling algorithm [24], which enables sampling from a stream
or sets of large/unknown cardinality. With reservoir sam-
pling, we obtain a reservoir set R (cid:44) {xr
K} from
the stream, which can be regarded as a ﬁnite sample from
p(x). We estimate the value of Q on R as:

1, . . . , xr

QR(Φ) =

IR(Dxr,Φ; Cxr ).

(6)

1
|R|

(cid:88)

xr∈R

We use subscript R to indicate that when computing the
mutual information I, the p+
D for a reservoir in-
stance xr are estimated from R. This can be done in O(|R|)

D and p−

Figure 2: We present the general plug-in module for on-
line hashing methods: Trigger Update (TU). We sample a
reservoir R from the input stream, and estimate the mutual
information criterion QR. Based on its value, TU decides
whether a hash table update should be executed.

time for each xr, as the discrete distributions can be esti-
mated via histogram binning.

Fig. 2 summarizes our approach. We use the reservoir
set to estimate the quality QR, and “trigger” an update to
the hash table only when QR improves over a threshold.
Notably, our approach provides a general plug-in module
for online hashing techniques, in that it only needs access
to streaming data and the hash mapping itself, independent
of the hashing method’s inner workings.

3.2. MI as Learning Objective

Having shown that mutual information is a suitable mea-
sure of neighborhood quality, we consider its use as a
learning objective for hashing. Following the notation in
Sec. 3.1, we deﬁne a loss L with respect to ˆx ∈ X and Φ as

L(ˆx, Φ) = −I(Dˆx,Φ; Cˆx).

(7)

We model Φ as a collection of parameterized hash func-
tions, each responsible for generating a single bit: Φ(x) =
[φ1(x; W ), ..., φb(x; W )], where φi : X → {−1, +1}, ∀i,
and W represents the model parameters. For example, lin-
ear hash functions can be written as φi(x) = sgn(w(cid:62)
i x),
and for deep neural networks the bits are generated by
thresholding the activations of the output layer.

Inspired by the online nature of the problem and recent
advances in stochastic optimization, we derive gradient de-
scent rules for L. The entropy-based mutual information
is differentiable with respect to the entries of pD, p+
D and
p−
D, and, as mentioned before, these discrete distributions
can be estimated via histogram binning. However, it is not
clear how to differentiate histogram binning to generate gra-
dients for model parameters. We describe a differentiable
histogram binning technique next.

Differentiable Histogram Binning
We borrow ideas from [23] and estimate p+
D and pD us-
ing a differentiable histogram binning technique. For b-bit
Hamming distances, we use (K + 1)-bin normalized his-
tograms with bin centers v0 = 0, ..., vK = b and uniform
bin width ∆ = b/K, where K = b by default. Consider,

D, p−

for example, the k-th entry in p+
be estimated as

D, denoted as p+

D,k. It can

p+
D,k =

1

(cid:88)

|

|

x∈

δx,k,

(cid:22)
where δx,k records the contribution of x to bin k. It is ob-
tained by interpolating dΦ(x, ˆx) using a triangular kernel:

(cid:22)

δx,k =






(dΦ(x, ˆx) − vk−1)/∆, dΦ(x, ˆx) ∈ [vk−1, vk],
(vk+1 − dΦ(x, ˆx))/∆, dΦ(x, ˆx) ∈ [vk, vk+1],
0,

otherwise.

This binning process admits subgradients:

∂δx,k
∂dΦ(x, ˆx)

=






dΦ(x, ˆx) ∈ [vk−1, vk],
1/∆,
−1/∆, dΦ(x, ˆx) ∈ [vk, vk+1],
0,
otherwise.

Gradients of MI
We now derive the gradient of I with respect to the output
of the hash mapping, Φ(ˆx). Using standard chain rule, we
can ﬁrst write

∂I
∂Φ(ˆx)

=

(cid:34)

K
(cid:88)

k=0

∂I
∂p+

D,k

∂p+
D,k
∂Φ(ˆx)

+

∂I
∂p−

D,k

(cid:35)

∂p−
D,k
∂Φ(ˆx)

.

(11)

We focus on terms involving p+

D,k, and omit derivations

for p−

D,k due to symmetry. For k = 0, . . . , K, we have
∂I
∂p+

∂H(D|C)
∂p+

∂H(D)
∂p+

= −

+

D,k

D,k

D,k

= p+(log p+

D,k + 1) − (log pD,k + 1)

∂pD,k
∂p+

D,k

= p+(log p+

D,k − log pD,k),

where we used the fact that pD,k = p+p+
D,k, with
p+ and p− being shorthands for the priors P (C = 1) and
P (C = 0). We next tackle the term ∂p+
D,k/∂Φ(ˆx) in Eq. 11.
From the deﬁnition of p+

D,k + p−p−

D,k in Eq.8, we have

∂p+
D,k
∂Φ(ˆx)

∂δx,k
∂Φ(ˆx)

=

=

=

1

(cid:22)
1

(cid:22)
1

(cid:22)

|

|

|

|

|

|

(cid:88)

x∈

(cid:22)
(cid:88)

x∈

(cid:22)
(cid:88)

x∈

(cid:22)

∂δx,k
∂dΦ(x, ˆx)

∂dΦ(x, ˆx)
∂Φ(ˆx)

∂δx,k
∂dΦ(x, ˆx)

−Φ(x)
2

.

Note that ∂δx,k/∂dΦ(x, ˆx) is already given in Eq. 10. For
the last step, we used the deﬁnition of dΦ in Eq. 1.

Lastly, to back-propagate gradients to Φ’s inputs and ul-
timately model parameters, we approximate the discontin-
uous sign function with sigmoid, which is a standard tech-
nique in hashing, e.g. [1, 12, 16].

(8)

(9)

(10)

(12)

(13)

(14)

(15)

(16)

(17)

Figure 3: We show Pearson correlation coefﬁcients between mutual information (MI) and AP, DCG, and NDCG, evaluated
on the CIFAR-10, LabelMe, and Places205 datasets. We sample 100 instances to form the query set, and use the rest to
populate the hash table. The hash mapping parameters are randomly sampled from a Gaussian, similar to LSH [4]. Each
experiment is conducted 50 times. There exist strong correlations between MI and the standard metrics.

3.3. Beneﬁts of MI

For monitoring the performance of hashing algorithms,
it appears that one could directly use standard ranking met-
rics, such as Average Precision (AP), Discounted Cumu-
lative Gain (DCG), and Normalized DCG (NDCG) [17].
Here, we discuss the beneﬁts of instead using mutual in-
formation. First, we note that there exist strong correlations
between mutual information and standard ranking metrics.
Fig. 3 demonstrates the Pearson correlation coefﬁcients be-
tween MI and AP, DCG, and NDCG, on three benchmarks.
Although a theoretical analysis is beyond the scope of this
work, empirically we ﬁnd that MI serves as an efﬁcient and
general-purpose ranking surrogate.

We also point out the lower computational complexity of
mutual information. Let n be the reservoir set size. Com-
puting Eq. 6 involves estimating discrete distributions via
histogram binning, and takes O(n) time for each reservoir
item, since D only takes discrete values from {0, 1, . . . , b},
In contrast, ranking measures such as AP and NDCG have
O(n log n) complexity due to sorting, which render them
disadvantageous.

Finally, Sec. 3.2 showed that the mutual information ob-
jective is suitable for direct, gradient-based optimization. In
contrast, optimizing metrics like AP and NDCG is much
more challenging as they are non-differentiable, and ex-
isting works usually resort to optimizing their surrogates
[13, 26, 29] rather than gradient-based optimization. Fur-
thermore, mutual information itself is essentially parameter-
free, whereas many other hashing formulations require (and
can be sensitive to) tuning parameters, such as thresholds or
margins [18, 27], quantization strength [12, 15, 20], etc.

4. Experiments

We evaluate our approach on three widely used image
benchmarks. We ﬁrst describe the datasets and experimen-
tal setup in Sec. 4.1. We evaluate the mutual informa-
tion update criterion in Sec. 4.2 and the mutual informa-

tion based objective function for learning hash mappings
in Sec. 4.3. Our implementation is publicly available at
https://github.com/fcakir/mihash.

4.1. Datasets and Experimental Setup

CIFAR-10 is a widely-used dataset for image classiﬁca-
tion and retrieval, containing 60K images from 10 different
categories [7]. For feature representation, we use CNN fea-
tures extracted from the f c7 layer of a VGG-16 network
[21] pre-trained on ImageNet.

Places205 is a subset of the large-scale Places dataset
[32] for scene recognition. Places205 contains 2.5M im-
ages from 205 scene categories. This is a very challeng-
ing dataset due to its large size and number of categories,
and it has not been studied in the hashing literature to our
knowledge. We extract CNN features from the f c7 layer
of an AlexNet [8] pre-trained on ImageNet, and reduce the
dimensionality to 128 using PCA.

LabelMe. The 22K LabelMe dataset [19, 22] has 22,019
images represented as 512-dimensional GIST descriptors.
This is an unsupervised dataset without labels, and standard
practice uses the Euclidean distance to determine neighbor
relationships. Speciﬁcally, xi and xj are considered neigh-
bor pairs if their Euclidean distance is within the smallest
5% in the training set. For a query, the closest 5% examples
are considered true neighbors.

All datasets are randomly split into a retrieval set and a
test set, and a subset from the retrieval set is used for learn-
ing hash functions. Speciﬁcally, for CIFAR-10, the test set
has 1K images and the retrieval set has 59K. A random sub-
set of 20K images from the retrieval set is used for learning,
and the size of the reservoir is set to 1K. For Places205, we
sample 20 images from each class to construct a test set of
4.1K images, and use the rest as the retrieval set. A random
subset of 100K images is used to for learning, and the reser-
voir size is 5K. For LabelMe, the dataset is split into re-
trieval and test sets with 20K and 2K samples, respectively.
Similar to CIFAR-10, we use a reservoir of size 1K.

Figure 4: Retrieval mAP vs. number of processed training examples for four hashing methods on the three datasets, with
and without Trigger Update (TU). We use default threshold θ = 0 for TU. Circles indicate hash table updates, and the ratio
of reduction in the number of updates is shown in the titles. TU substantially reduces the number of updates while having
a stabilizing effect on the retrieval performance. Note: since OSH [2] assumes supervision in terms of class labels, it is not
applicable to the unsupervised LabelMe dataset.

For online hashing experiments, we run three random-
ized trials for each experiment and report averaged results.
To evaluate retrieval performances, we adopt the widely-
used mean Average Precision (mAP). Due to the large size
of Places205, mAP is very time-consuming to compute,
and we compute mAP on the top 1000 retrieved examples
(mAP@1000), as done in [15].

4.2. Evaluation: Update Criterion

We evaluate our mutual information based update crite-
rion, the Trigger Update module (TU). We apply TU to all
existing online hashing methods known to us: Online Ker-
nel Hashing (OKH) [6], Online Supervised Hashing (OSH)
[2], Adaptive Hashing (AdaptHash) [1] and Online Sketch-
ing Hashing (SketchHash) [11]. We use publicly available
implementations of all methods. The hash code length is
ﬁxed at 32 bits.

As our work is the ﬁrst in addressing the hash table up-
date criterion for online hashing, we compare to a data-
agnostic baseline, which updates the hash table at a ﬁxed
rate. The rate is controlled by a parameter U , referred to

as the “update interval”: after processing every U exam-
ples, the baseline unconditionally triggers an update, while
TU makes a decision using the mutual information criterion.
For each dataset, U is set such that the baseline updates 201
times in total. This ensures that the baseline is never too
outdated, but updates are still fairly infrequent: in all cases,
the smallest U is 100.

Results for the Trigger Update module. Fig. 4 de-
picts the retrieval mAP over time for all four online hash-
ing methods considered, on three datasets, with and without
incorporating TU. We can clearly observe a signiﬁcant re-
duction in the number of hash table updates, between one
and two orders of magnitude in all cases. For example, the
number of hash table updates is reduced by a factor of 67
for the OKH method on LabelMe.

The quality-based update criterion is particularly im-
portant for hashing methods that may yield inferior hash
mappings due to noisy data and/or imperfect learning tech-
niques. In other words, TU can be used to ﬁlter updates to
the hash mapping with negative or small improvement. This
has a stabilizing effect on the mAP curve, notably for OKH

Figure 5: Online hashing performance comparison on three datasets, where all methods use the Trigger Update module (TU)
with default threshold θ = 0. MIHash clearly outperforms other competing methods. OSH, AdaptHash, and SketchHash
perform very similarly on Places205, thus their curves overlap.

and AdaptHash. For OSH, which appears to stably improve
over time, TU nevertheless signiﬁcantly reduces revisits to
the hash table while maintaining its performance.

All results in Fig. 4 are obtained using the default thresh-
old parameter θ = 0, deﬁned in Eq. 5. We do not tune θ in
order to show general applicability. We also discuss the im-
pact of the reservoir set R. There is a trade-off regarding
the size of R: a larger R leads to better approximation but
increases the overhead. Nevertheless, we observed robust
and consistent results with |R| not exceeding 5% of the size
of the training stream.

4.3. Evaluation: Learning Objective

We evaluate the mutual information based hashing ob-
jective. We name our method MIHash, and train it using
stochastic gradient descent (SGD). This allows it to be ap-
plied to both the online setting and batch setting in learning
hash functions.

(cid:23)

During minibatch-based SGD, to compute the mutual in-
formation objective in Eq. 7 and its gradients, we need ac-
ˆx for each considered ˆx, in order to
ˆx,
cess to the sets
(cid:22)
estimate p+
D and p−
D. For the online setting in Sec. 4.3.1,
a standalone reservoir set R is assumed as in the previous
experiment, and we partition R into {
ˆx} with respect
to each incoming ˆx. In this case, even a batch size of 1 can
be used. For the batch setting in Sec. 4.3.2, {
ˆx} are
deﬁned within the same minibatch as ˆx.

ˆx,

ˆx,

(cid:23)

(cid:23)

(cid:22)

(cid:22)

4.3.1 Online Setting

We ﬁrst consider an online setting that is the same as in
Sec. 4.2. We compare against other online hashing meth-
ods: OKH, OSH, AdaptHash and SketchHash. All methods
are equipped with the TU module with the default threshold
θ = 0, which has been demonstrated to work well.

Results for Online Setting. We ﬁrst show the mAP
curve comparisons in Fig. 5. For competing online hash-
ing methods, the curves are the same as the ones with
TU in Fig. 4, and we remove markers to avoid clutter.
MIHash clearly outperforms other online hashing methods

on all three datasets, and shows potential for further im-
provement with more training data. The combination of TU
and MIHash gives a complete online hashing system that
enjoys a superior learning objective with a plug-in update
criterion that improves efﬁciency.

D and p−

We next give insights into the distribution-separating ef-
fect from optimizing mutual information. In Fig. 6, we plot
the conditional distributions p+
D averaged on the
CIFAR-10 test set, before and after learning MIHash with
the 20K training examples. Before learning, with a ran-
domly initialized hash mapping, p+
D exhibit high
overlap. After learning, MIHash achieves good separation
between p+
D: the overlap reduces signiﬁcantly, and
the mass of p+
D is pushed towards 0. This separation is re-
ﬂected in the large improvement in mAP (0.68 vs. 0.22).

D and p−

D and p−

In contrast with the other methods, the mutual informa-
tion formulation is parameter-free. For instance, there is no
threshold parameter that requires separating p+
D at
a certain distance value. Likewise, there is no margin pa-
rameter that dictates the amount of separation in absolute
terms. Such parameters usually need to be tuned to ﬁt to
data, whereas the optimization of mutual information is au-
tomatically guided by the data itself.

D and p−

4.3.2 Batch Setting

To further demonstrate the potential of MIHash, we con-
sider the batch learning setting, where the entire training
set is available at once. We compare against state-of-the-
art batch formulations, including: Supervised Hashing with
Kernels (SHK) [16], Fast Supervised Hashing with Deci-
sion Trees (FastHash) [14], Supervised Discrete Hashing
(SDH) [20], Efﬁcient Training of Very Deep Neural Net-
works (VDSH) [30], Deep Supervised Hashing with Pair-
wise Labels (DPSH) [12] and Deep Supervised Hashing
with Triplet Labels (DTSH) [27]. These competing meth-
ods have shown to outperform earlier and other work such
as [5, 9, 18, 28, 10, 31]. We focus on comparisons on the
CIFAR-10 dataset, which is the canonical benchmark for
supervised hashing. Similar to [27], we consider two exper-

1

g
n
i
t
t
e
S

Method
SHK
SDH
VDSH
DPSH
DTSH
FastHash
MIHash1
MIHash
Method
DPSH2
DTSH2
DPSH
DTSH
MIHash

Code Length
32
24
0.645
0.615
0.589
0.576
0.537
0.546
0.538
0.518
0.689
0.659
0.724
0.700
0.597
0.563
0.727
0.720
32
24
0.795
0.781
0.925
0.923
0.917
0.909
0.927
0.924
0.933
0.938
1 Results after a single training epoch.
2 Results as reported in DPSH [12] and DTSH [27].

12
0.497
0.521
0.523
0.420
0.617
0.632
0.524
0.683
16
0.763
0.915
0.908
0.916
0.929

2

g
n
i
t
t
e
S

48
0.682
0.592
0.554
0.553
0.702
0.738
0.609
0.746
48
0.807
0.926
0.932
0.934
0.942

Table 1: Comparison against state-of-the-art hashing meth-
ods on CIFAR-10. We report mean Average Precision
(mAP) on the test set, with best results in bold. See text
for the details of the two experimental settings.

can learn non-linear hash functions: for instance, the closest
competitor, FastHash, is a two-step hashing method based
on sophisticated binary code inference and boosted trees.

In Setting 2, with end-to-end ﬁnetuning, MIHash signif-
icantly outperforms DPSH and DTSH, the two most com-
petitive deep hashing methods, and sets the current state-
of-the-art for CIFAR-10. Again, note that MIHash has no
tuning parameters in its objective function. In contrast, both
DPSH and DTSH have parameters to control the quantiza-
tion strength that need to be tuned.

5. Conclusion

We advance the state-of-the-art for online hashing in two
aspects. In order to resolve the issue of hash table updates
in online hashing, we deﬁne a quality measure using the
mutual information between variables induced by the hash
mapping. This measure is efﬁciently computable, corre-
lates well with standard evaluation metrics, and leads to
consistent computational savings for existing online hash-
ing methods while maintaining their retrieval accuracy. In-
spired by these strong results, we further propose a hashing
method MIHash, by optimizing mutual information as an
objective with stochastic gradient descent. In both online
and batch settings, MIHash achieves superior performance
compared to state-of-the-art hashing techniques.

Acknowledgements

This research was supported in part by a BU IGNITION

award, US NSF grant 1029430, and gifts from NVIDIA.

D and p−

Figure 6: We plot the distributions p+
D, aver-
aged on the CIFAR-10 test set, before and after learning
MIHash with 20K training examples. Optimizing the mu-
tual information objective substantially reduces the overlap
between them, resulting in state-of-the-art mAP for the on-
line setting, as shown in Fig. 5.

imental settings, which we detail below.

Setting 1: 5K training examples are sampled for learn-
ing hash mappings, and 1K examples are used as the test
set. All methods learn shallow models on top of fc7 fea-
tures from a VGG-16 network [21] pretrained on Ima-
geNet. For three gradient-based methods (DPSH, DTSH,
and MIHash), this means learning linear hash functions.
Note that VDSH uses customized architectures consisting
of only fully-connected layers, and it is unclear how to adapt
it to use standard architectures; we used its full model with
16 layers and 1024 nodes per layer.

Setting 2: We use the full training set of size 50K and
test set of size 10K. We focus on comparing the end-to-end
performance of MIHash against two recent leading meth-
ods: DPSH and DTSH, using the same VGG-F network
architecture [3] that they are trained on. We use pub-
licly available implementations for the compared methods,
and exhaustively search parameter settings for them. For
MIHash, the minibatch size is set to 100 and 250 in Settings
1 and 2, respectively. We use SGD with momentum, and
decrease the learning rate when the training loss saturates.
See supplementary material for more details.

Results for Batch Setting.

In Table 1, we list batch
learning results for all methods. In Setting 1, MIHash out-
performs all competing methods in terms of mAP, in some
cases with only a single training epoch (e.g. against VDSH,
DPSH). This suggests that mutual information is a more ef-
fective learning objective for hashing. MIHash learns a lin-
ear layer on the input features, while some other methods

[18] M. Norouzi and D. J. Fleet. Minimal loss hashing for com-
pact binary codes. In Proc. International Conf. on Machine
Learning (ICML), 2011.

[19] B. C. Russell, A. Torralba, K. P. Murphy, and W. T. Freeman.
Labelme: a database and web-based tool for image annota-
tion. International journal of computer vision, 2008.
[20] F. Shen, C. S. Wei, L. Heng, and T. Shen. Supervised dis-
crete hashing. In Proc. IEEE Conf. on Computer Vision and
Pattern Recognition (CVPR), 2015.

[21] K. Simonyan and A. Zisserman. Very deep convolutional
networks for large-scale image recognition. ICLR, 2015.
[22] A. Torralba, R. Fergus, and Y. Weiss. Small codes and large
In Proc. IEEE Conf. on
image databases for recognition.
Computer Vision and Pattern Recognition (CVPR). IEEE,
2008.

[23] E. Ustinova and V. Lempitsky. Learning deep embeddings
with histogram loss. In Proc. Advances in Neural Informa-
tion Processing Systems (NIPS), pages 4170–4178, 2016.
[24] J. S. Vitter. Random sampling with a reservoir. ACM
Transactions on Mathematical Software (TOMS), 11(1):37–
57, 1985.

[25] J. Wang, H. T. Shen, J. Song, and J. Ji. Hashing for similarity

search: A survey. CoRR.

[26] Q. Wang, Z. Zhang, and L. Si. Ranking preserving hashing
for fast similarity search. In Proc. International Joint Conf.
on Artiﬁcial Intelligence (IJCAI), 2015.

[27] Y. Wang, Xiaofang Shi and K. M. Kitani. Deep supervised
hashing with triplet labels. In Proc. Asian Conf. on Computer
Vision (ACCV), 2016.

[28] R. Xia, Y. Pan, H. Lai, C. Liu, and S. Yan. Supervised hash-
ing for image retrieval via image representation learning. In
Proc. AAAI Conf. on Artiﬁcial Intelligence (AAAI), volume 1,
page 2, 2014.

[29] Y. Yue, T. Finley, F. Radlinski, and T. Joachims. A support
In Proc.
vector method for optimizing average precision.
ACM Conf. on Research & Development in Information Re-
trieval (SIGIR), pages 271–278. ACM, 2007.

[30] Z. Zhang, Y. Chen, and V. Saligrama. Efﬁcient training of
very deep neural networks for supervised hashing. In Proc.
IEEE Conf. on Computer Vision and Pattern Recognition
(CVPR), 2016.

[31] F. Zhao, Y. Huang, L. Wang, and T. Tan. Deep semantic
ranking based hashing for multi-label image retrieval.
In
Proc. IEEE Conf. on Computer Vision and Pattern Recog-
nition (CVPR), 2015.

[32] B. Zhou, A. Lapedriza, J. Xiao, A. Torralba, and A. Oliva.
Learning deep features for scene recognition using places
database. In Proc. Advances in Neural Information Process-
ing Systems (NIPS), 2014.

References

[1] F. Cakir and S. Sclaroff. Adaptive hashing for fast similar-
ity search. In Proc. IEEE International Conf. on Computer
Vision (ICCV), 2015.

[2] F. Cakir and S. Sclaroff. Online supervised hashing. In Proc.
IEEE International Conf. on Image Processing (ICIP), 2015.
[3] K. Chatﬁeld, K. Simonyan, A. Vedaldi, and A. Zisserman.
Return of the devil in the details: Delving deep into convolu-
tional nets. In British Machine Vision Conference (BMVC),
2014.

[4] A. Gionis, P. Indyk, and R. Motwani. Similarity search in
In Proc. International Conf.

high dimensions via hashing.
on Very Large Data Bases (VLDB), 1999.

[5] Y. Gong and S. Lazebnik.

Iterative quantization: A pro-
crustean approach to learning binary codes. In Proc. IEEE
Conf. on Computer Vision and Pattern Recognition (CVPR),
2011.

[6] L.-K. Huang, Q. Y. Yang, and W.-S. Zheng. Online hashing.
In Proc. International Joint Conf. on Artiﬁcial Intelligence
(IJCAI), 2013.

[7] A. Krizhevsky and G. Hinton. Learning multiple layers of

features from tiny images, 2009.

[8] A. Krizhevsky, I. Sutskever, and G. E. Hinton.

Imagenet
classiﬁcation with deep convolutional neural networks.
In
Proc. Advances in Neural Information Processing Systems
(NIPS), 2012.

[9] B. Kulis and T. Darrell. Learning to hash with binary recon-
structive embeddings. In Proc. Advances in Neural Informa-
tion Processing Systems (NIPS), 2009.

[10] H. Lai, Y. Pan, Y. Liu, and S. Yan. Simultaneous feature
learning and hash coding with deep neural networks.
In
Proc. IEEE Conf. on Computer Vision and Pattern Recog-
nition (CVPR), 2015.

[11] C. Leng, J. Wu, J. Cheng, X. Bai, and H. Lu. Online sketch-
ing hashing. In Proc. IEEE Conf. on Computer Vision and
Pattern Recognition (CVPR), 2015.

[12] W.-J. Li, S. Wang, and W.-C. Kang. Feature learning based
deep supervised hashing with pairwise labels. In Proc. Inter-
national Joint Conf. on Artiﬁcial Intelligence (IJCAI), 2016.
[13] G. Lin, F. Liu, C. Shen, J. Wu, and H. T. Shen. Structured
learning of binary codes with column generation for optimiz-
International Journal of Computer
ing ranking measures.
Vision (IJCV), pages 1–22, 2016.

[14] G. Lin, C. Shen, Q. Shi, A. van den Hengel, and D. Suter.
Fast supervised hashing with decision trees for high-
dimensional data. In Proc. IEEE Conf. on Computer Vision
and Pattern Recognition (CVPR), 2014.

[15] K. Lin, J. Lu, C.-S. Chen, and J. Zhou. Learning compact
binary descriptors with unsupervised deep neural networks.
In Proc. IEEE Conf. on Computer Vision and Pattern Recog-
nition (CVPR), 2016.

[16] J. W. Liu, Wei and, R. Ji, Y.-G. Jiang, and S.-F. Chang. Su-
pervised hashing with kernels. In Proc. IEEE Conf. on Com-
puter Vision and Pattern Recognition (CVPR), 2012.
[17] C. D. Manning, P. Raghavan, and H. Sch¨utze. Introduction

to information retrieval. 2008.

Appendix

A. Implementation Details of MIHash

We discuss the implementation details of MIHash.
In
the online hashing experiments, for simplicity we model
MIHash using linear hash functions, in the form of φi(x) =
sgn(w(cid:62)
i x) ∈ {−1, +1}, i = 1, . . . , b. The learning capac-
ity of such a model is lower than the kernel-based OKH, and
is the same as OSH, AdaptHash, and SketchHash, which
use linear hash functions as well.

For the batch hashing experiments, as mentioned in the
paper, we similarly model MIHash using linear hash func-
tions in the ﬁrst setting, but perform end-to-end learning
with the VGG-F network in the second setting.
In this
case, the hash functions become φi(x) = sgn(fi(x; w)) ∈
{−1, +1}, i = 1, . . . , b, where fi are the logits produced by
the previous layer in the network.

We train MIHash using stochastic gradient descent. In
Eq. 11 in the paper, we gave the gradients of the mutual in-
formation objective I with respect to the outputs of the hash
mapping, Φ(x). Both I and ∂I/∂Φ(x) are parameter-free.
In order to further back-propagate gradients to the inputs of
Φ(x) and model parameters {wi}, we approximate the sgn
function using the sigmoid function σ:

φi(x) ≈ 2σ(Aw(cid:62)

i x) − 1,

(18)

where A > 1 is a scaling parameter, used to increase the
“sharpness” of the approximation. We ﬁnd A from the set
{10, 20, 30, 40, 50} in our experiments.

We note that A is not a tuning parameter of the mutual
information objective, but rather a parameter of the under-
lying hash functions. The design of the hash functions is
not coupled with the mutual information objective, thus can
be separated. It will be an interesting topic to explore other
methods of constructing hash functions, potentially in ways
that are free of tuning parameters.

B. Experimental Details

B.1. The streaming scenario

We set up a streaming scenario in our online hashing ex-
periments. We run three randomized trials for each experi-
ment. In each trial, we ﬁrst randomly split the dataset into
a retrieval set and a test set as described in Sec. 4.1 in the
paper, and randomly sample the training subset from the re-
trieval set. The ordering of the training set is also randomly
permuted. The random seeds are ﬁxed, so the baselines and
methods with the Trigger Update module observe the same
training sequences.

In a streaming setting, we also measure the cumulative
retrieval performance during online hashing, as opposed to
only the ﬁnal results. To mimic real retrieval systems where

queries arrive randomly, we set 50 randomized checkpoints
during the online process. We ﬁrst place the checkpoints
with equal spacing, then add small random perturbations
to their locations. We measure the instantaneous retrieval
mAP at these checkpoints to get mAP vs. time curves (e.g.
curves shown in Fig. 5 in the paper), and compute the area
under curve (AUC). AUC gives a summary of the entire on-
line learning process, which cannot be reﬂected by the ﬁnal
performance at the end.

B.2. Parameters for online hashing methods

We describe parameters used for online hashing methods
in the online experiments. Some of the competing methods
require parameter tuning, therefore we sample a validation
set from the training data and ﬁnd the best performing pa-
rameters for each method. The size of the validation sets are
2K, 2K and 10K for CIFAR-10, LabelMe and Places205,
respectively. Please refer to the respective papers for the
descriptions of the parameters.

• OSH: η is set to 0.1 for all datasets. The ECOC code-

book C is populated the same way as in OSH.

• AdaptHash:

to
tuple
(0.9, 0.01, 0.1), (0.1, 0.01, 0.001) and (0.9, 0.01, 0.1)
for CIFAR-10, LabelMe and Places205, respectively.

(α, λ, η)

the

set

is

• OKH:

the tuple (C, α)

to (0.001, 0.3),
(0.001, 0.3) and (0.0001, 0.7) for CIFAR-10, LabelMe
and Places205, respectively.

set

is

• SketchHash: the pair (sketch size, batch size) is set to
(200, 50), (100, 50) and (100, 50) for CIFAR-10, La-
belMe and Places205, respectively.

B.3. Parameters for batch hashing methods

We use the publicly available implementations for the
compared methods, and exhaustively search parameter set-
tings, including the default parameters as provided by the
authors. For DPSH and DTSH we found a combination that
worked well for the ﬁrst setting: the mini-batch size is set to
the default value of 128, and the learning rate is initialized
to 1 and decayed by a factor of 0.9 after every 20 epochs.
Additionally, for DTSH, the margin parameter is set to b/4
where b is the hash code length. VDSH uses a heavily cus-
tomized architecture with only fully-connected layers, and
it is unclear how to adapt it to work with standard CNN ar-
chitectures. In this sense, VDSH is more akin to nonlinear
hashing methods such as FastHash and SHK. We used the
full VDSH model with 16 layers and 1024 nodes per layer,
and found the default parameters to perform the best, ex-
cept that we increased the number of training iterations by
an order of magnitude during ﬁnetuning.

For MIHash, in the ﬁrst setting we use a batch size of
100, and run SGD with initial learning rate of 0.1 and a

Method

Training Time (s)

Training Time (s)

OKH
OKH + TU
OSH
OSH + TU
AdaptHash
AdaptHash + TU
SketchHash
SketchHash + TU

10.8
23.6
97.6
175.8
47.8
94.8
68.8
80.0

Method

SHK
SDH
FastHash
VDSH*
DPSH
DTSH
MIHash, 1ep
MIHash

mAP

0.682
0.592
0.738
0.554
0.553
0.702
0.609
0.746

180
4.8
140
206
450
1728
1.9
190

Table 2: Online hashing: running times on the CIFAR-10
20k training set, with 32-bit hash codes. For methods with
the TU plugin, the added time is due to maintaining the
reservoir set and computing the mutual information update
criterion, and is dominated by the maintaining of the reser-
voir set.

decay factor of 0.5 every 10 epochs, for 100 epochs. For
the second setting where we ﬁnetune the pretrained VGG-F
network, batch size is 250, learning rate is initially set to
0.001 and decayed by half every 50 epochs.

C. Running Time

C.1. Online Setting: Trigger Update Module

In Table 2 we report running time for all methods on
the CIFAR-10 dataset with 20k training examples, includ-
ing time spent in learning hash functions and the added pro-
cessing time for maintaining the reservoir set and comput-
ing TU. Numbers are recorded on a 2.3GHz Intel Xeon E5-
2650 CPU workstation with 128GB of DDR3 RAM. Most
of the added time is due to maintaining the reservoir set,
which is invoked in each training iteration; the mutual in-
formation update criterion is only checked after processing
every U = 100 examples. Methods with small batch sizes
(e.g. OSH, batch size 1) therefore incur more overhead than
methods with larger batches (e.g. SketchHash, batch size
50). Results for other datasets are similar.

We note that in a real retrieval system with large-scale
data, the bottleneck likely lies in recomputing the hash ta-
bles for indexed data, due to various factors such as schedul-
ing and disk I/O. We reduce this bottleneck signiﬁcantly by
using TU. Compared to this bottleneck, the increase in train-
ing time is not signiﬁcant.

C.2. Batch Setting

Table 3 reports CPU times for learning 48-bit hash map-
pings in the ﬁrst experimental setting on CIFAR-10 (5K
training set). Retrieval mAP are replicated from Table 1
in the paper. For learning a single layer, our Matlab im-
plementation of MIHash achieves 1.9 seconds per epoch
on CPU. MIHash achieves competitive performance with
a single epoch, and has a total training time on par with

Table 3: Batch hashing: test performance and training time
for 48-bit codes on the CIFAR-10, using the 5k training set.
*VDSH is trained with the full model as detailed in B.3.
1ep stands for training for one epoch only.

FastHash, while yielding superior performance.

D. Additional Experimental Results

D.1. Online Hashing: Other Code Lengths

In the online hashing experiments we reported in the pa-
per, all online hashing methods are compared in the same
setup with 32-bit hash codes. Additionally, we also present
results using 64-bit hash codes on all three datasets. The
parameters for all methods are found through validation as
described in B.2.

Similar to Sec 4.2 in the paper, we show the comparisons
with and without TU for existing online hashing methods in
Fig. 7, and plot the mAP curves for all methods, includ-
ing MIHash, in Fig. 8. The 64-bit results are uniformly
better than 32-bit results for all methods in terms of mAP,
but still follow the same patterns. Again, we can see that
MIHash clearly outperforms all competing online hashing
methods, and shows potential for improvement given more
training data.

D.2. Parameter Study: θ

We present a parameter study on the parameter θ, the im-
provement threshold on the mutual information criterion in
TU. In our previous experiments, we found the default θ = 0
to work well, and did not speciﬁcally tune θ. However, tun-
ing for a larger θ could lead to better trade-offs, since small
improvements in the quality of the hash mapping may not
justify the cost of a full hash table update.

For this study, we vary parameter θ from −∞ to ∞ for
all methods (with 32-bit hash codes). θ = −∞ reduces to
the baseline. On the other hand, θ = ∞ prevents any up-
dates to the initial hash mapping and hash table, and results
in only one hash table update (for the initial mapping) and
typically low performance. The performance metric we fo-
cus on in this study is the cumulative metric, AUC, since
it better summarizes the entire online learning process than
the ﬁnal performance alone.

Figure 7: 64-bit experiments: Retrieval mAP vs. number of training examples for four existing online hashing methods on
the three datasets, with and without Trigger Update (TU). We use default threshold θ = 0 for TU. Circles indicate hash table
updates, and the ratio of reduction in the number of updates is marked for each graph. TU substantially reduces the number
of updates while having a stabilizing effect on the retrieval performance. Note: since the OSH method assumes supervision
in terms of class labels, it is not applicable to the unsupervised LabelMe dataset.

Figure 8: 64-bit experiments: Online hashing performance (mAP) comparison on three datasets, where all methods use
the Trigger Update module (TU) with θ = 0. Using the mutual information objective, MIHash clearly outperforms other
methods. OKH, AdaptHash, ad SketchHash perform very similarly on CIFAR-10. OSH, AdaptHash, ad SketchHash perform
very similarly on Places205. Again, the OSH method is not applicable to the unsupervised LabelMe dataset.

We use a custom update schedule for SketchHash: we
enforce hash table updates in the early iterations regard-
less of other criteria, until the number of observed exam-
ples reaches the speciﬁed size of the “data sketch”, which
SketchHash uses to perform a batch hashing algorithm.
This was observed to be critical for the performance of
SketchHash. Therefore, the number of hash table updates
for SketchHash can be greater than 1 even for θ = ∞.

We present full results in Tables 4, 5, 6. In all cases, we
observe a substantial decrease in the number of hash table
updates as θ increases. With reasonable θ values (typically
around 0), the number of hash table updates can be reduced
by over an order of magnitude with no loss in AUC. Note
that the computation-performance trade-off achieved by the
default θ = 0 is always among the best, thereby in practice
it can be used without tuning.

D.3. Parameter Study: U

We simulate a data-agnostic baseline that updates hash
tables at a constant rate, using the update interval param-
eter U .
In the paper, U is set such that the baseline up-
dates a total of 201 times for all datasets. This ensures that
the baseline is never too outdated (compared to 50 check-
points at which performance is evaluated), but is still fairly
infrequent: the smallest U in this case is 100, which means
the baselines process at least 100 training examples before
recomputing the hash table. For completeness, here we
present the results using different values of U , where all
methods again use 32-bit hash codes and the default θ = 0.
We used a simple rule that avoids unnecessary hash table
updates if the hash mapping itself does not change. Specif-
ically, we do not update if (cid:107)Φt − Φs(cid:107) < 10−6, where Φs
is the current snapshot and Φt is the new candidate. Some
baseline entries have fewer updates because of this rule (e.g.
AdaptHash on Places205). And as explained before, due to
the custom update schedule, SketchHash may have more
hash table updates than what is suggested by U .

Please see Tables 7, 8, 9 for the full results. In all experi-
ments, we run three random trials and average the results as
mentioned before, and the standard deviation of mAP and
AUC scores are less than 0.01. Generally, using smaller
U leads to more updates by both the baselines and methods
with TU; recall that U is also a parameter of TU which spec-
iﬁes the frequency of checking the update criterion. How-
ever, methods with the TU module appear to be quite in-
sensitive to the choice of U , e.g. the number of updates
for SketchHash with TU on CIFAR-10 only increases by 2x
while U is reduced by 20x, from 1000 to 50. We attribute
this to the ability of TU to ﬁlter out unnecessary updates.
Across different values of U , TU consistently brings compu-
tational savings while preserving/improving online hashing
performance, as indicated by ﬁnal mAP and AUC.

CIFAR-10, 32 bits
HT Updates
201
190 (5.8x)
8.0 (25.1x)
8.0 (25.1x)
7.7 (26.1x)
3.3 (91.2x)
1.0 (201x)
HT Updates
201
39.0 (5.2x)
36.7 (5.5x)
35.7 (5.6x)
6.7 (30x)
2.0 (100x)
1.0 (201x)
AdaptHash HT Updates

OKH
≤ −0.1
−0.01
−10−4
0
10−4
0.01
≥ 0.2
OSH
≤ −0.01
−10−4
0
10−4
0.01
0.1
≥ 0.3

≤ −0.1
−0.01
−10−4
0
10−4
0.01
≥ 0.1

201
68.3 (2.9x)
10.3 (19.5x)
10.0 (20.1x)
10.0 (20.1x)
3.3 (60.9x)
1.0 (201x)
SketchHash HT updates

≤ −0.01
−10−4
−10−6
0
10−4
0.01
≥ 0.1

201
9.0 (22.3x)
7.3 (27.5x)
7.3 (27.5x)
7.3 (27.5x)
4.3 (46.7x)
4.0 (50.3x)

–

–

AUC ∆AUC
0.259
0.260 +0.4%
0.287 +10.8%
0.287 +10.8%
0.287 +10.8%
+8.1%
0.280
0.134 −48.3%
AUC ∆AUC
0.463
0.466 +0.6%
0.466 +0.6%
0.466 +0.6%
0.453 −2.1%
−16%
0.386
−55%
0.207
AUC ∆AUC
0.218
0.238 +9.2%
0.250 +14.7%
0.250 +14.7%
0.250 +14.7%
0.244 +11.9%
0.211 −3.3%
AUC ∆AUC
0.304
0.318 +4.6%
0.319 +4.9%
0.319 +4.9%
0.319 +4.9%
0.318 +4.6%
0.314 +3.3%

–

–

Table 4: Parameter study on the threshold value θ for on-
line hashing methods on CIFAR-10 (32 bits). We report
the number of hash table updates, where 100x indicates a
100 times reduction with respect to the baseline. We also
report the area under the mAP curve (AUC) and compare to
baseline.

OKH
≤ −0.01
−10−4
−10−6
0
10−6
10−4
0.01
≥ 0.1
OSH
≤ −0.001
−20−4
−10−4
0
10−4
10−3
≥ 0.1

Places205, 32 bits
HT Updates
201
8.3 (24.2x)
7.0 (28.7x)
7.0 (28.7x)
7.0 (28.7x)
5.7 (35.3x)
2.0 (100x)
1.0 (201x)
HT Updates
201
101 (2.0x)
9.3 (21.6x)
7.0 (28.7x)
5.7 (35.3x)
2.7 (74.4x)
1.0 (201x)
AdaptHash HT Updates
≤ −0.01
−10−4
−10−6
0
10−6
10−4
≥ 0.01

199.7
199 (1.0x)
9.7 (20.6x)
8.7 (23.0x)
8.7 (23.0x)
3.0 (66.6x)
1.0 (201x)
SketchHash HT Updates

≤ −0.01
−10−4
−10−6
0
10−6
10−4
≥ 0.01

201
52.3 (3.8x)
15.3 (12.6x)
12.7 (15.8x)
15.3 (13.1x)
7.0 (28.7x)
2.0 (101x)

–

–
0%

AUC ∆AUC
0.163
0.161 −1.2%
0.161 −1.2%
0.161 −1.2%
0.161 −1.2%
0.161 −1.2%
−25%
0.123
−91%
0.014
AUC ∆AUC
0.246
0.246
0.236 −4.1%
0.236 −4.1%
0.230 −6.5%
0.224 −8.9%
0.226 −8.1%
AUC ∆AUC
0.237
0.237
0.236 −0.4%
0.236 −0.4%
0.235 −0.8%
0.235 −0.8%
0.227 −3.4%
AUC ∆AUC
0.237
0.238 +0.4%
0.238 +0.4%
0.236 −0.4%
0.238 +0.4%
0.239 +0.8%
0.223 −5.9%

–
0%

–

LabelMe, 32 bits
HT Updates
201
196 (1.0x)
2.7 (74.4x)
2.3 (87.4x)
2.3 (87.4x)
2.3 (87.4x)
2.0 (101x)
1.0 (201x)
AdaptHash HT Updates

OKH
≤ −0.2
−0.1
−0.01
−10−6
0
10−6
0.01
≥ 0.6

≤ −0.1
−10−6
−10−4
−10−2
0
10−6
10−4
10−2
≥ 0.1

≤ −0.1
−10−2
−10−4
0
10−4
10−2
≥ 0.1

201
149 (1.3x)
9.3 (21.6x)
8.7 (23.1x)
5.3 (37.9x)
8.7 (23.1x)
8.3 (24.2x)
2.7 (74.4x)
1 (201x)

201
195 (1.0x)
9.3 (21.6x)
8.7 (23.1x)
10 (20.1x)
4.7 (42.8x)
4.0 (50.3x)

SketchHash HT Updates

–

–

AUC ∆AUC
0.198
0.199 +0.5%
+88%
0.373
+89%
0.374
+89%
0.374
+89%
0.374
+88%
0.372
−44%
0.111
AUC ∆AUC
0.333
0.330 −0.9%
0.365 +9.6%
0.365 +9.6%
+11%
0.369
0.365 +9.6%
0.358 +7.5%
0.351 +5.4%
−11%
0.296
AUC ∆AUC
0.446
0.446
0.460 +3.1%
0.460 +3.1%
0.459 +2.9%
0.446
0.439 −1.6%

–
0%

0%

Table 5: Parameter study on the threshold value θ for on-
line hashing methods on Places205 (32 bits). We report the
number of hash table updates, where 100x indicates a 100
times reduction with respect to the baseline. We also re-
port the area under the mAP curve (AUC) and compare to
baseline.

Table 6: Parameter study on the threshold value θ for online
hashing methods on LabelMe (32 bits). We report the num-
ber of hash table updates, where 100x indicates a 100 times
reduction with respect to the baseline. We also report the
area under the mAP curve (AUC) and compare to baseline.
Note: OSH is not applicable to this unlabeled dataset since
it needs supervision in terms of class labels.

CIFAR-10, 32 bits

Final mAP AUC (mAP)

Method

OKH, U = 10

OKH, U = 100

OKH, U = 1000

OSH, U = 10

OSH, U = 100

OSH, U = 1000

AdaptHash, U = 10

AdaptHash, U = 100

AdaptHash, U = 1000

SketchHash, U = 50

SketchHash, U = 100

SketchHash, U = 1000

1870

201
8 (25.1x)
21
2.6 (8x)
2001
110.7 (18x)
201
36.7 (5.4x)
21
11.3 (1.9x)
2001

TU HT Updates
×
(cid:88) 15.6 (119.3x)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88) 19.6 (101.7x)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)

201
10.0 (10.1x)
21
5 (4.2x)
400
9 (44.4x)
202
7.3 (27.5x)
24
4.6 (5.2x)

0.238
0.297
0.238
0.291
0.238
0.282
0.480
0.483
0.480
0.483
0.480
0.479
0.244
0.267
0.244
0.255
0.244
0.252
0.306
0.318
0.306
0.320
0.306
0.317

0.259
0.293 (+13%)
0.259
0.287 (+10.8%)
0.255
0.273 (+7%)
0.463
0.466 (+0.6%)
0.463
0.466 (+0.6%)
0.454
0.454
0.224
0.261 (+16%)
0.224
0.250 (+11.6%)
0.222
0.234 (+5%)
0.303
0.318 (+5%)
0.304
0.319 (+4.9%)
0.305
0.314 (+2.9%)

Table 7: Online hashing results (32 bits) with different update interval parameters (U ) on the CIFAR-10 dataset. All results
are averaged from 3 random trials. For the number of hash table updates, we report the reduction ratio (e.g. 8x) for TU. For
AUC, we report the relative change compared to baseline. Note: SketchHash uses a batch size of 50, therefore the smallest
U is set to 50.

LabelMe, 32 bits

Final mAP AUC (mAP)

Method

OKH, U = 10

OKH, U = 100

OKH, U = 1000

AdaptHash, U = 10

AdaptHash, U = 100

AdaptHash, U = 1000

SketchHash, U = 50

SketchHash, U = 100

SketchHash, U = 1000

2001
8 (250x)
201
2.3 (86.2x)
21
2 (10.5x)
2001

TU HT Updates
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88) 12.6 (157.9x)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)

201
8.6 (23.1x)
21
5 (4.2x)
400
9.6 (41.6x)
202
8.67 (23.2x)
24
8.3 (2.8x)

0.119
0.382
0.119
0.380
0.119
0.373
0.318
0.380
0.318
0.379
0.318
0.343
0.445
0.461
0.445
0.462
0.445
0.456

0.200
0.377 (+88.5%)
0.200
0.374 (+87%)
0.193
0.357 (+85%)
0.319
0.371 (+16.3%)
0.318
0.365 (+14.7%)
0.317
0.337 (+6.3%)
0.447
0.460 (+2%)
0.446
0.460 (+3.1%)
0.445
0.455 (+2%)

Table 8: Online hashing results (32 bits) with different update interval parameters (U ) on the LabelMe dataset. All results
are averaged from 3 random trials. For the number of hash table updates, we report the reduction ratio (e.g. 8x) for TU. For
AUC, we report the relative change compared to baseline. Note: since LabelMe is an unsupervised dataset, the OSH method
is not applicable since it requires supervision in the form of class labels.

Places205, 32 bits

Final mAP AUC (mAP)

Method

OKH, U = 50

OKH, U = 500

OKH, U = 5000

OSH, U = 50

OSH, U = 500

OSH, U = 5000

AdaptHash, U = 50

AdaptHash, U = 500

AdaptHash, U = 5000

SketchHash, U = 50

SketchHash, U = 500

SketchHash, U = 5000

2001
8 (250.1x)
201
7 (28.7x)
21
2 (10.5x)
2001
25 (80x)
201
7 (28.7x)
21
2 (10.5x)
823.7
26.6 (30.8x)
200
8.6 (23.0x)
21
3 (7x)
2000

TU HT Updates
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88) 19.3 (103.4x)
×
(cid:88)
×
(cid:88)

202
15.3 (13.1x)
22
6.6 (3.2x)

0.182
0.173
0.182
0.165
0.182
0.157
0.248
0.239
0.248
0.236
0.248
0.234
0.238
0.236
0.238
0.236
0.238
0.236
0.238
0.236
0.237
0.240
0.235
0.239

0.163
0.169 (+3.7%)
0.163
0.161 (-1.2%)
0.156
0.148 (-5.1%)
0.246
0.238 (-3%)
0.246
0.236 (-4.0%)
0.245
0.233 (-4%)
0.237
0.236 (-0.4%)
0.237
0.236 (-0.4%)
0.237
0.236 (-0.4%)
0.235
0.235 (0%)
0.235
0.238 (+1.2%)
0.235
0.238 (+1.2%)

Table 9: Online hashing results (32 bits) with different update interval parameters (U ) on the Places205 dataset. All results
are averaged from 3 random trials. For the number of hash table updates, we report the reduction ratio (e.g. 8x) for TU. For
and AUC, we report the relative change compared to baseline.

MIHash: Online Hashing with Mutual Information

Fatih Cakir∗ Kun He∗

Sarah Adel Bargal

Stan Sclaroff

Department of Computer Science
Boston University, Boston, MA
{fcakir,hekun,sbargal,sclaroff}@cs.bu.edu

7
1
0
2
 
l
u
J
 
9
2
 
 
]

V
C
.
s
c
[
 
 
2
v
9
1
9
8
0
.
3
0
7
1
:
v
i
X
r
a

Abstract

Learning-based hashing methods are widely used for
nearest neighbor retrieval, and recently, online hashing
methods have demonstrated good performance-complexity
trade-offs by learning hash functions from streaming data.
In this paper, we ﬁrst address a key challenge for online
hashing:
the binary codes for indexed data must be re-
computed to keep pace with updates to the hash functions.
We propose an efﬁcient quality measure for hash functions,
based on an information-theoretic quantity, mutual infor-
mation, and use it successfully as a criterion to eliminate
unnecessary hash table updates. Next, we also show how to
optimize the mutual information objective using stochastic
gradient descent. We thus develop a novel hashing method,
MIHash, that can be used in both online and batch settings.
Experiments on image retrieval benchmarks (including a
2.5M image dataset) conﬁrm the effectiveness of our for-
mulation, both in reducing hash table recomputations and
in learning high-quality hash functions.

1. Introduction

Hashing is a widely used approach for practical nearest
neighbor search in many computer vision applications. It
has been observed that adaptive hashing methods that learn
to hash from data generally outperform data-independent
hashing methods such as Locality Sensitive Hashing [4]. In
this paper, we focus on a relatively new family of adaptive
hashing methods, namely online adaptive hashing methods
[1, 2, 6, 11]. These techniques employ online learning in the
presence of streaming data, and are appealing due to their
low computational complexity and their ability to adapt to
changes in the data distribution.

Despite recent progress, a key challenge has not been
addressed in online hashing, which motivates this work:
the computed binary representations, or the “hash table”,
may become outdated after a change in the hash mapping.
To reﬂect the updates in the hash mapping, the hash table

∗First two authors contributed equally.

ˆx and non-neighbors in

Figure 1: We study online hashing for efﬁcient nearest
neighbor retrieval. Given a hash mapping Φ, an image ˆx,
ˆx,
along with its neighbors in
(cid:22)
are mapped to binary codes, yielding two distributions of
Hamming distances. In this example, Φ1 has higher quality
than Φ2 since it induces more separable distributions. The
information-theoretic quantity Mutual Information can be
used to capture the separability, which gives a good quality
indicator and learning objective for online hashing.

(cid:23)

may need to be recomputed frequently, causing inefﬁcien-
cies in the system such as successive disk I/O, especially
when dealing with large datasets. We thus identify an im-
portant question for online adaptive hashing systems: when
to update the hash table? Previous online hashing solutions
do not address this question, as they usually update both the
hash mapping and hash table concurrently.

We make the observation that achieving high quality
nearest neighbor search is an ultimate goal in hashing sys-
tems, and therefore any effort to limit computational com-
plexity should preserve, if not improve, that quality. There-
fore, another important question is: how to quantify qual-
ity? Here, we brieﬂy describe our answer to this question,
but ﬁrst introduce some necessary notation. We would like
to learn a hash mapping Φ from feature space X to the b-
dimensional Hamming space Hb, whose outputs are b-bit

(cid:22)

(cid:23)

ˆx, and a set of non-neighbors

binary codes. The goal of hashing is to preserve a neighbor-
hood structure in X after the mapping to Hb. Given ˆx ∈ X ,
the neighborhood structure is usually given in terms of a set
of its neighbors
ˆx. We
discuss how to derive the neighborhood structure in Sec. 3.
As shown in Fig. 1, the distributions of the Hamming
distances from ˆx to its neighbors and non-neighbors are his-
tograms over {0, 1, . . . , b}. Ideally, if there is no overlap
between these two distributions, we can recover
ˆx
by simply thresholding the Hamming distance. A nonzero
overlap results in ambiguity, as observing the Hamming dis-
tance is no longer sufﬁcient to determine neighbor relation-
ships. Our discovery is that this overlap can be quanti-
ﬁed using an information-theoretic quantity, mutual infor-
mation, between two random variables induced by Φ. We
then use mutual information to deﬁne a novel measure to
quantify quality for hash functions in general.

ˆx and

(cid:23)

(cid:22)

With a quality measure deﬁned, we answer the motivat-
ing question of when to update the hash table. We propose
a simple solution by restricting updates to times when there
is an estimated improvement in hashing quality, based on
an efﬁcient estimation method in the presence of streaming
data. Notably, since mutual information is a good general-
purpose quality measure for hashing, this results in a gen-
eral plug-in module for online hashing that does not require
knowledge of the learning method.

Inspired by this strong result, we next ask, can we opti-
mize mutual information as an objective to learn hash func-
tions? We propose a novel hashing method, MIHash, by
deriving gradient descent rules on the mutual information
objective, which can be applied in online stochastic opti-
mization, as well as on deep architectures. The mutual in-
formation objective is free of tuning parameters, unlike oth-
ers that may require thresholds, margins, etc.

We conduct experiments on three image retrieval bench-
marks, including the Places205 dataset [32] with 2.5M im-
ages. For four recent online hashing methods, our mu-
tual information based update criterion consistently leads to
over an order of magnitude reduction in hash table recom-
putations, while maintaining retrieval accuracy. Moreover,
our novel MIHash method achieves state-of-the-art retrieval
results, in both online and batch learning settings.

2. Related Work

In this section, we mainly review hashing methods that
adaptively update the hash mapping with incoming data,
given that our focus is on online adaptive hashing. For a
more general survey on hashing, please refer to [25].

Huang et al. [6] propose Online Kernel Hashing, where
a stochastic environment is considered with pairs of points
arriving sequentially. At each step, a number of hash func-
tions are selected based on a Hamming loss measure and pa-
rameters are updated via stochastic gradient descent (SGD).

Cakir and Sclaroff [1] argue that, in a stochastic setting,
it is difﬁcult to determine which hash functions to update as
it is the collective effort of all the hash functions that yields
a good hash mapping. Hamming loss is considered to infer
the hash functions to be updated at each step and a squared
error loss is minimized via SGD.

In [2], binary Error Correcting Output Codes (ECOCs)
are employed in learning the hash functions. This work
follows a more general two-step hashing framework [14],
where the set of ECOCs are generated beforehand and are
assigned to labeled data as they appear, allowing the label
space to grow with incoming data. Then, hash functions are
learned to ﬁt the binary ECOCs using Online Boosting.

Inspired by the idea of “data sketching”, Leng et al. in-
troduce Online Sketching Hashing [11] where a small ﬁxed-
size sketch of the incoming data is maintained in an online
fashion. The sketch retains the Frobenius norm of the full
data matrix, which offers space savings, and allows to ap-
ply certain batch-based hashing methods. A PCA-based
batch learning method is applied on the sketch to obtain
hash functions.

None of the above online hashing methods offer a solu-
tion to decide whether or not the hash table shall be updated
given a new hash mapping. However, such a solution is
crucial in practice, as limiting the frequency of updates will
alleviate the computational burden of keeping the hash ta-
ble up-to-date. Although [2] and [6] include strategies to
select individual hash functions to recompute, they still re-
quire computing on all indexed data instances.

Recently, some methods employ deep neural networks
to learn hash mappings, e.g. [12, 15, 27, 30] and others.
These methods use minibatch-based stochastic optimiza-
tion, however, they usually require multiple passes over a
given dataset to learn the hash mapping, and the hash table
is only computed when the hash mapping has been learned.
Therefore, current deep learning based hashing methods are
essentially batch learning methods, which differ from the
online hashing methods that we consider, i.e. methods that
process streaming data to learn and update the hash map-
pings on-the-ﬂy while continuously updating the hash ta-
ble. Nevertheless, when evaluating our mutual information
based hashing objective, we compare against state-of-the-
art batch hashing formulations as well, by contrasting dif-
ferent objective functions on the same model architecture.

Lastly, Ustinova et al. [23] recently proposed a method
to derive differentiation rules for objective functions that re-
quire histogram binning, and apply it in learning deep em-
beddings. When optimizing our mutual information objec-
tive, we utilize their differentiable histogram binning tech-
nique for deriving gradient-based optimization rules. Note
that both our problem setup and objective function are quite
different from [23].

3. Online Hashing with Mutual Information

As mentioned in Sec. 1, the goal of hashing is to learn a
hash mapping Φ : X → Hb such that a desired neighbor-
hood structure is preserved. We consider an online learning
setup where Φ is continuously updated from input stream-
ing data, and at time t, the current mapping Φt is learned
from {x1, . . . , xt}. We follow the standard setup of learn-
ing Φ from pairs of instances with similar/dissimilar labels
[9, 6, 1, 12]. These labels, along with the neighborhood
structure, can be derived from a metric, e.g. two instances
are labeled similar (i.e. neighbors of each other) if their Eu-
clidean distance in X is below a threshold. Such a setting
is often called unsupervised hashing. On the other hand, in
supervised hashing with labeled data, pair labels are derived
from individual class labels: instances are similar if they are
from the same class, and dissimilar otherwise.

Below, we ﬁrst derive the mutual information quality
measure and discuss its use in determining when to update
the hash table in Sec. 3.1. We then describe a gradient-based
approach for optimizing the same quality measure, as an ob-
jective for learning hash mappings, in Sec. 3.2. Finally, we
discuss the beneﬁts of using mutual information in Sec. 3.3.

3.1. MI as Update Criterion

We revisit our motivating question: When to update the
hash table in online hashing? During the online learn-
ing of Φt, we assume a retrieval set S ⊆ X , which may
include the streaming data after they are received. We
deﬁne the hash table as the set of hashed binary codes:
T (S, Φ) = {Φ(x)|x ∈ S}. Given the adaptive nature of
online hashing, T may need to be recomputed often to keep
pace with Φt; however, this is undesirable if S is large or the
change in Φt’s quality does not justify the cost of an update.
We propose to view the learning of Φt and computa-
tion of T as separate events, which may happen at different
rates. To this end, we introduce the notion of a snapshot,
denoted Φs, which is occasionally taken of Φt and used
to recompute T . Importantly, this happens only when the
nearest neighbor retrieval quality of Φt has improved, and
we now deﬁne the quality measure.

Given hash mapping Φ : X → {−1, +1}b, Φ induces

Hamming distance dΦ : X × X → {0, 1, . . . , b} as

dΦ(x, ˆx) =

(cid:0)b − Φ(x)(cid:62)Φ(ˆx)(cid:1) .

(1)

1
2

Consider some instance ˆx ∈ X , and the sets contain-
ˆx. Φ induces
ing neighbors and non-neighbors,
two conditional distributions, P (dΦ(x, ˆx)|x ∈
ˆx) and
P (dΦ(x, ˆx)|x ∈
ˆx) as seen in Fig. 1, and it is desir-
able to have low overlap between them. To formulate the
idea, for Φ and ˆx, deﬁne random variable Dˆx,Φ : X →
{0, 1, . . . , b}, x (cid:55)→ dΦ(x, ˆx), and let Cˆx : X → {0, 1} be

ˆx and

(cid:22)

(cid:23)

(cid:22)

(cid:23)

ˆx. The two conditional dis-
the membership indicator for
(cid:22)
tributions can now be expressed as P (Dˆx,Φ|Cˆx = 1) and
P (Dˆx,Φ|Cˆx = 0), and we can write the mutual information
between Dˆx,Φ and Cˆx as

I(Dˆx,Φ; Cˆx) = H(Cˆx) − H(Cˆx|Dˆx,Φ)

= H(Dˆx,Φ) − H(Dˆx,Φ|Cˆx)

(2)

(3)

D, and pD, respectively.

where H denotes (conditional) entropy. In the following,
for brevity we will drop subscripts Φ and ˆx, and denote the
two conditional distributions and the marginal P (Dˆx,Φ) as
p+
D, p−
By deﬁnition, I(D; C) measures the decrease in uncer-
tainty in the neighborhood information C when observing
the Hamming distances D. We claim that I(D; C) also cap-
tures how well Φ preserves the neighborhood structure of ˆx.
If I(D; C) attains a high value, which means C can be de-
termined with low uncertainty by observing D, then Φ must
have achieved good separation (i.e. low overlap) between
p+
D and p−
D. I is maximized when there is no overlap, and
minimized when p+
D are exactly identical. Recall,
however, that I is deﬁned with respect to a single instance
ˆx; therefore, for a general quality measure, we integrate I
over the feature space:

D and p−

Q(Φ) =

I(Dˆx,Φ; Cˆx)p(ˆx)dˆx.

(4)

(cid:90)

X

Q(Φ) captures the expected amount of separation between
D and p−
p+
D achieved by Φ, over all instances in X .
In the online setting, given the current hash mapping Φt
and previous snapshot Φs, it is then straightforward to pose
the update criterion as

Q(Φt) − Q(Φs) > θ,

(5)

where θ is a threshold; a straightforward choice is θ = 0.
However, Eq. 4 is generally difﬁcult to evaluate due to the
intractable integral; in practice, we resort to Monte-Carlo
approximations to this integral, as we describe next.

Monte-Carlo Approximation by Reservoir Sampling
We give a Monte-Carlo approximation of Eq. 4. Since we
work with streaming data, we employ the Reservoir Sam-
pling algorithm [24], which enables sampling from a stream
or sets of large/unknown cardinality. With reservoir sam-
pling, we obtain a reservoir set R (cid:44) {xr
K} from
the stream, which can be regarded as a ﬁnite sample from
p(x). We estimate the value of Q on R as:

1, . . . , xr

QR(Φ) =

IR(Dxr,Φ; Cxr ).

(6)

1
|R|

(cid:88)

xr∈R

We use subscript R to indicate that when computing the
mutual information I, the p+
D for a reservoir in-
stance xr are estimated from R. This can be done in O(|R|)

D and p−

Figure 2: We present the general plug-in module for on-
line hashing methods: Trigger Update (TU). We sample a
reservoir R from the input stream, and estimate the mutual
information criterion QR. Based on its value, TU decides
whether a hash table update should be executed.

time for each xr, as the discrete distributions can be esti-
mated via histogram binning.

Fig. 2 summarizes our approach. We use the reservoir
set to estimate the quality QR, and “trigger” an update to
the hash table only when QR improves over a threshold.
Notably, our approach provides a general plug-in module
for online hashing techniques, in that it only needs access
to streaming data and the hash mapping itself, independent
of the hashing method’s inner workings.

3.2. MI as Learning Objective

Having shown that mutual information is a suitable mea-
sure of neighborhood quality, we consider its use as a
learning objective for hashing. Following the notation in
Sec. 3.1, we deﬁne a loss L with respect to ˆx ∈ X and Φ as

L(ˆx, Φ) = −I(Dˆx,Φ; Cˆx).

(7)

We model Φ as a collection of parameterized hash func-
tions, each responsible for generating a single bit: Φ(x) =
[φ1(x; W ), ..., φb(x; W )], where φi : X → {−1, +1}, ∀i,
and W represents the model parameters. For example, lin-
ear hash functions can be written as φi(x) = sgn(w(cid:62)
i x),
and for deep neural networks the bits are generated by
thresholding the activations of the output layer.

Inspired by the online nature of the problem and recent
advances in stochastic optimization, we derive gradient de-
scent rules for L. The entropy-based mutual information
is differentiable with respect to the entries of pD, p+
D and
p−
D, and, as mentioned before, these discrete distributions
can be estimated via histogram binning. However, it is not
clear how to differentiate histogram binning to generate gra-
dients for model parameters. We describe a differentiable
histogram binning technique next.

Differentiable Histogram Binning
We borrow ideas from [23] and estimate p+
D and pD us-
ing a differentiable histogram binning technique. For b-bit
Hamming distances, we use (K + 1)-bin normalized his-
tograms with bin centers v0 = 0, ..., vK = b and uniform
bin width ∆ = b/K, where K = b by default. Consider,

D, p−

for example, the k-th entry in p+
be estimated as

D, denoted as p+

D,k. It can

p+
D,k =

1

(cid:88)

|

|

x∈

δx,k,

(cid:22)
where δx,k records the contribution of x to bin k. It is ob-
tained by interpolating dΦ(x, ˆx) using a triangular kernel:

(cid:22)

δx,k =






(dΦ(x, ˆx) − vk−1)/∆, dΦ(x, ˆx) ∈ [vk−1, vk],
(vk+1 − dΦ(x, ˆx))/∆, dΦ(x, ˆx) ∈ [vk, vk+1],
0,

otherwise.

This binning process admits subgradients:

∂δx,k
∂dΦ(x, ˆx)

=






dΦ(x, ˆx) ∈ [vk−1, vk],
1/∆,
−1/∆, dΦ(x, ˆx) ∈ [vk, vk+1],
0,
otherwise.

Gradients of MI
We now derive the gradient of I with respect to the output
of the hash mapping, Φ(ˆx). Using standard chain rule, we
can ﬁrst write

∂I
∂Φ(ˆx)

=

(cid:34)

K
(cid:88)

k=0

∂I
∂p+

D,k

∂p+
D,k
∂Φ(ˆx)

+

∂I
∂p−

D,k

(cid:35)

∂p−
D,k
∂Φ(ˆx)

.

(11)

We focus on terms involving p+

D,k, and omit derivations

for p−

D,k due to symmetry. For k = 0, . . . , K, we have
∂I
∂p+

∂H(D|C)
∂p+

∂H(D)
∂p+

= −

+

D,k

D,k

D,k

= p+(log p+

D,k + 1) − (log pD,k + 1)

∂pD,k
∂p+

D,k

= p+(log p+

D,k − log pD,k),

where we used the fact that pD,k = p+p+
D,k, with
p+ and p− being shorthands for the priors P (C = 1) and
P (C = 0). We next tackle the term ∂p+
D,k/∂Φ(ˆx) in Eq. 11.
From the deﬁnition of p+

D,k + p−p−

D,k in Eq.8, we have

∂p+
D,k
∂Φ(ˆx)

∂δx,k
∂Φ(ˆx)

=

=

=

1

(cid:22)
1

(cid:22)
1

(cid:22)

|

|

|

|

|

|

(cid:88)

x∈

(cid:22)
(cid:88)

x∈

(cid:22)
(cid:88)

x∈

(cid:22)

∂δx,k
∂dΦ(x, ˆx)

∂dΦ(x, ˆx)
∂Φ(ˆx)

∂δx,k
∂dΦ(x, ˆx)

−Φ(x)
2

.

Note that ∂δx,k/∂dΦ(x, ˆx) is already given in Eq. 10. For
the last step, we used the deﬁnition of dΦ in Eq. 1.

Lastly, to back-propagate gradients to Φ’s inputs and ul-
timately model parameters, we approximate the discontin-
uous sign function with sigmoid, which is a standard tech-
nique in hashing, e.g. [1, 12, 16].

(8)

(9)

(10)

(12)

(13)

(14)

(15)

(16)

(17)

Figure 3: We show Pearson correlation coefﬁcients between mutual information (MI) and AP, DCG, and NDCG, evaluated
on the CIFAR-10, LabelMe, and Places205 datasets. We sample 100 instances to form the query set, and use the rest to
populate the hash table. The hash mapping parameters are randomly sampled from a Gaussian, similar to LSH [4]. Each
experiment is conducted 50 times. There exist strong correlations between MI and the standard metrics.

3.3. Beneﬁts of MI

For monitoring the performance of hashing algorithms,
it appears that one could directly use standard ranking met-
rics, such as Average Precision (AP), Discounted Cumu-
lative Gain (DCG), and Normalized DCG (NDCG) [17].
Here, we discuss the beneﬁts of instead using mutual in-
formation. First, we note that there exist strong correlations
between mutual information and standard ranking metrics.
Fig. 3 demonstrates the Pearson correlation coefﬁcients be-
tween MI and AP, DCG, and NDCG, on three benchmarks.
Although a theoretical analysis is beyond the scope of this
work, empirically we ﬁnd that MI serves as an efﬁcient and
general-purpose ranking surrogate.

We also point out the lower computational complexity of
mutual information. Let n be the reservoir set size. Com-
puting Eq. 6 involves estimating discrete distributions via
histogram binning, and takes O(n) time for each reservoir
item, since D only takes discrete values from {0, 1, . . . , b},
In contrast, ranking measures such as AP and NDCG have
O(n log n) complexity due to sorting, which render them
disadvantageous.

Finally, Sec. 3.2 showed that the mutual information ob-
jective is suitable for direct, gradient-based optimization. In
contrast, optimizing metrics like AP and NDCG is much
more challenging as they are non-differentiable, and ex-
isting works usually resort to optimizing their surrogates
[13, 26, 29] rather than gradient-based optimization. Fur-
thermore, mutual information itself is essentially parameter-
free, whereas many other hashing formulations require (and
can be sensitive to) tuning parameters, such as thresholds or
margins [18, 27], quantization strength [12, 15, 20], etc.

4. Experiments

We evaluate our approach on three widely used image
benchmarks. We ﬁrst describe the datasets and experimen-
tal setup in Sec. 4.1. We evaluate the mutual informa-
tion update criterion in Sec. 4.2 and the mutual informa-

tion based objective function for learning hash mappings
in Sec. 4.3. Our implementation is publicly available at
https://github.com/fcakir/mihash.

4.1. Datasets and Experimental Setup

CIFAR-10 is a widely-used dataset for image classiﬁca-
tion and retrieval, containing 60K images from 10 different
categories [7]. For feature representation, we use CNN fea-
tures extracted from the f c7 layer of a VGG-16 network
[21] pre-trained on ImageNet.

Places205 is a subset of the large-scale Places dataset
[32] for scene recognition. Places205 contains 2.5M im-
ages from 205 scene categories. This is a very challeng-
ing dataset due to its large size and number of categories,
and it has not been studied in the hashing literature to our
knowledge. We extract CNN features from the f c7 layer
of an AlexNet [8] pre-trained on ImageNet, and reduce the
dimensionality to 128 using PCA.

LabelMe. The 22K LabelMe dataset [19, 22] has 22,019
images represented as 512-dimensional GIST descriptors.
This is an unsupervised dataset without labels, and standard
practice uses the Euclidean distance to determine neighbor
relationships. Speciﬁcally, xi and xj are considered neigh-
bor pairs if their Euclidean distance is within the smallest
5% in the training set. For a query, the closest 5% examples
are considered true neighbors.

All datasets are randomly split into a retrieval set and a
test set, and a subset from the retrieval set is used for learn-
ing hash functions. Speciﬁcally, for CIFAR-10, the test set
has 1K images and the retrieval set has 59K. A random sub-
set of 20K images from the retrieval set is used for learning,
and the size of the reservoir is set to 1K. For Places205, we
sample 20 images from each class to construct a test set of
4.1K images, and use the rest as the retrieval set. A random
subset of 100K images is used to for learning, and the reser-
voir size is 5K. For LabelMe, the dataset is split into re-
trieval and test sets with 20K and 2K samples, respectively.
Similar to CIFAR-10, we use a reservoir of size 1K.

Figure 4: Retrieval mAP vs. number of processed training examples for four hashing methods on the three datasets, with
and without Trigger Update (TU). We use default threshold θ = 0 for TU. Circles indicate hash table updates, and the ratio
of reduction in the number of updates is shown in the titles. TU substantially reduces the number of updates while having
a stabilizing effect on the retrieval performance. Note: since OSH [2] assumes supervision in terms of class labels, it is not
applicable to the unsupervised LabelMe dataset.

For online hashing experiments, we run three random-
ized trials for each experiment and report averaged results.
To evaluate retrieval performances, we adopt the widely-
used mean Average Precision (mAP). Due to the large size
of Places205, mAP is very time-consuming to compute,
and we compute mAP on the top 1000 retrieved examples
(mAP@1000), as done in [15].

4.2. Evaluation: Update Criterion

We evaluate our mutual information based update crite-
rion, the Trigger Update module (TU). We apply TU to all
existing online hashing methods known to us: Online Ker-
nel Hashing (OKH) [6], Online Supervised Hashing (OSH)
[2], Adaptive Hashing (AdaptHash) [1] and Online Sketch-
ing Hashing (SketchHash) [11]. We use publicly available
implementations of all methods. The hash code length is
ﬁxed at 32 bits.

As our work is the ﬁrst in addressing the hash table up-
date criterion for online hashing, we compare to a data-
agnostic baseline, which updates the hash table at a ﬁxed
rate. The rate is controlled by a parameter U , referred to

as the “update interval”: after processing every U exam-
ples, the baseline unconditionally triggers an update, while
TU makes a decision using the mutual information criterion.
For each dataset, U is set such that the baseline updates 201
times in total. This ensures that the baseline is never too
outdated, but updates are still fairly infrequent: in all cases,
the smallest U is 100.

Results for the Trigger Update module. Fig. 4 de-
picts the retrieval mAP over time for all four online hash-
ing methods considered, on three datasets, with and without
incorporating TU. We can clearly observe a signiﬁcant re-
duction in the number of hash table updates, between one
and two orders of magnitude in all cases. For example, the
number of hash table updates is reduced by a factor of 67
for the OKH method on LabelMe.

The quality-based update criterion is particularly im-
portant for hashing methods that may yield inferior hash
mappings due to noisy data and/or imperfect learning tech-
niques. In other words, TU can be used to ﬁlter updates to
the hash mapping with negative or small improvement. This
has a stabilizing effect on the mAP curve, notably for OKH

Figure 5: Online hashing performance comparison on three datasets, where all methods use the Trigger Update module (TU)
with default threshold θ = 0. MIHash clearly outperforms other competing methods. OSH, AdaptHash, and SketchHash
perform very similarly on Places205, thus their curves overlap.

and AdaptHash. For OSH, which appears to stably improve
over time, TU nevertheless signiﬁcantly reduces revisits to
the hash table while maintaining its performance.

All results in Fig. 4 are obtained using the default thresh-
old parameter θ = 0, deﬁned in Eq. 5. We do not tune θ in
order to show general applicability. We also discuss the im-
pact of the reservoir set R. There is a trade-off regarding
the size of R: a larger R leads to better approximation but
increases the overhead. Nevertheless, we observed robust
and consistent results with |R| not exceeding 5% of the size
of the training stream.

4.3. Evaluation: Learning Objective

We evaluate the mutual information based hashing ob-
jective. We name our method MIHash, and train it using
stochastic gradient descent (SGD). This allows it to be ap-
plied to both the online setting and batch setting in learning
hash functions.

(cid:23)

During minibatch-based SGD, to compute the mutual in-
formation objective in Eq. 7 and its gradients, we need ac-
ˆx for each considered ˆx, in order to
ˆx,
cess to the sets
(cid:22)
estimate p+
D and p−
D. For the online setting in Sec. 4.3.1,
a standalone reservoir set R is assumed as in the previous
experiment, and we partition R into {
ˆx} with respect
to each incoming ˆx. In this case, even a batch size of 1 can
be used. For the batch setting in Sec. 4.3.2, {
ˆx} are
deﬁned within the same minibatch as ˆx.

ˆx,

ˆx,

(cid:23)

(cid:22)

(cid:23)

(cid:22)

4.3.1 Online Setting

We ﬁrst consider an online setting that is the same as in
Sec. 4.2. We compare against other online hashing meth-
ods: OKH, OSH, AdaptHash and SketchHash. All methods
are equipped with the TU module with the default threshold
θ = 0, which has been demonstrated to work well.

Results for Online Setting. We ﬁrst show the mAP
curve comparisons in Fig. 5. For competing online hash-
ing methods, the curves are the same as the ones with
TU in Fig. 4, and we remove markers to avoid clutter.
MIHash clearly outperforms other online hashing methods

on all three datasets, and shows potential for further im-
provement with more training data. The combination of TU
and MIHash gives a complete online hashing system that
enjoys a superior learning objective with a plug-in update
criterion that improves efﬁciency.

D and p−

We next give insights into the distribution-separating ef-
fect from optimizing mutual information. In Fig. 6, we plot
the conditional distributions p+
D averaged on the
CIFAR-10 test set, before and after learning MIHash with
the 20K training examples. Before learning, with a ran-
domly initialized hash mapping, p+
D exhibit high
overlap. After learning, MIHash achieves good separation
between p+
D: the overlap reduces signiﬁcantly, and
the mass of p+
D is pushed towards 0. This separation is re-
ﬂected in the large improvement in mAP (0.68 vs. 0.22).

D and p−

D and p−

In contrast with the other methods, the mutual informa-
tion formulation is parameter-free. For instance, there is no
threshold parameter that requires separating p+
D at
a certain distance value. Likewise, there is no margin pa-
rameter that dictates the amount of separation in absolute
terms. Such parameters usually need to be tuned to ﬁt to
data, whereas the optimization of mutual information is au-
tomatically guided by the data itself.

D and p−

4.3.2 Batch Setting

To further demonstrate the potential of MIHash, we con-
sider the batch learning setting, where the entire training
set is available at once. We compare against state-of-the-
art batch formulations, including: Supervised Hashing with
Kernels (SHK) [16], Fast Supervised Hashing with Deci-
sion Trees (FastHash) [14], Supervised Discrete Hashing
(SDH) [20], Efﬁcient Training of Very Deep Neural Net-
works (VDSH) [30], Deep Supervised Hashing with Pair-
wise Labels (DPSH) [12] and Deep Supervised Hashing
with Triplet Labels (DTSH) [27]. These competing meth-
ods have shown to outperform earlier and other work such
as [5, 9, 18, 28, 10, 31]. We focus on comparisons on the
CIFAR-10 dataset, which is the canonical benchmark for
supervised hashing. Similar to [27], we consider two exper-

1

g
n
i
t
t
e
S

Method
SHK
SDH
VDSH
DPSH
DTSH
FastHash
MIHash1
MIHash
Method
DPSH2
DTSH2
DPSH
DTSH
MIHash

Code Length
32
24
0.645
0.615
0.589
0.576
0.537
0.546
0.538
0.518
0.689
0.659
0.724
0.700
0.597
0.563
0.727
0.720
32
24
0.795
0.781
0.925
0.923
0.917
0.909
0.927
0.924
0.933
0.938
1 Results after a single training epoch.
2 Results as reported in DPSH [12] and DTSH [27].

12
0.497
0.521
0.523
0.420
0.617
0.632
0.524
0.683
16
0.763
0.915
0.908
0.916
0.929

2

g
n
i
t
t
e
S

48
0.682
0.592
0.554
0.553
0.702
0.738
0.609
0.746
48
0.807
0.926
0.932
0.934
0.942

Table 1: Comparison against state-of-the-art hashing meth-
ods on CIFAR-10. We report mean Average Precision
(mAP) on the test set, with best results in bold. See text
for the details of the two experimental settings.

can learn non-linear hash functions: for instance, the closest
competitor, FastHash, is a two-step hashing method based
on sophisticated binary code inference and boosted trees.

In Setting 2, with end-to-end ﬁnetuning, MIHash signif-
icantly outperforms DPSH and DTSH, the two most com-
petitive deep hashing methods, and sets the current state-
of-the-art for CIFAR-10. Again, note that MIHash has no
tuning parameters in its objective function. In contrast, both
DPSH and DTSH have parameters to control the quantiza-
tion strength that need to be tuned.

5. Conclusion

We advance the state-of-the-art for online hashing in two
aspects. In order to resolve the issue of hash table updates
in online hashing, we deﬁne a quality measure using the
mutual information between variables induced by the hash
mapping. This measure is efﬁciently computable, corre-
lates well with standard evaluation metrics, and leads to
consistent computational savings for existing online hash-
ing methods while maintaining their retrieval accuracy. In-
spired by these strong results, we further propose a hashing
method MIHash, by optimizing mutual information as an
objective with stochastic gradient descent. In both online
and batch settings, MIHash achieves superior performance
compared to state-of-the-art hashing techniques.

Acknowledgements

This research was supported in part by a BU IGNITION

award, US NSF grant 1029430, and gifts from NVIDIA.

D and p−

Figure 6: We plot the distributions p+
D, aver-
aged on the CIFAR-10 test set, before and after learning
MIHash with 20K training examples. Optimizing the mu-
tual information objective substantially reduces the overlap
between them, resulting in state-of-the-art mAP for the on-
line setting, as shown in Fig. 5.

imental settings, which we detail below.

Setting 1: 5K training examples are sampled for learn-
ing hash mappings, and 1K examples are used as the test
set. All methods learn shallow models on top of fc7 fea-
tures from a VGG-16 network [21] pretrained on Ima-
geNet. For three gradient-based methods (DPSH, DTSH,
and MIHash), this means learning linear hash functions.
Note that VDSH uses customized architectures consisting
of only fully-connected layers, and it is unclear how to adapt
it to use standard architectures; we used its full model with
16 layers and 1024 nodes per layer.

Setting 2: We use the full training set of size 50K and
test set of size 10K. We focus on comparing the end-to-end
performance of MIHash against two recent leading meth-
ods: DPSH and DTSH, using the same VGG-F network
architecture [3] that they are trained on. We use pub-
licly available implementations for the compared methods,
and exhaustively search parameter settings for them. For
MIHash, the minibatch size is set to 100 and 250 in Settings
1 and 2, respectively. We use SGD with momentum, and
decrease the learning rate when the training loss saturates.
See supplementary material for more details.

Results for Batch Setting.

In Table 1, we list batch
learning results for all methods. In Setting 1, MIHash out-
performs all competing methods in terms of mAP, in some
cases with only a single training epoch (e.g. against VDSH,
DPSH). This suggests that mutual information is a more ef-
fective learning objective for hashing. MIHash learns a lin-
ear layer on the input features, while some other methods

[18] M. Norouzi and D. J. Fleet. Minimal loss hashing for com-
pact binary codes. In Proc. International Conf. on Machine
Learning (ICML), 2011.

[19] B. C. Russell, A. Torralba, K. P. Murphy, and W. T. Freeman.
Labelme: a database and web-based tool for image annota-
tion. International journal of computer vision, 2008.
[20] F. Shen, C. S. Wei, L. Heng, and T. Shen. Supervised dis-
crete hashing. In Proc. IEEE Conf. on Computer Vision and
Pattern Recognition (CVPR), 2015.

[21] K. Simonyan and A. Zisserman. Very deep convolutional
networks for large-scale image recognition. ICLR, 2015.
[22] A. Torralba, R. Fergus, and Y. Weiss. Small codes and large
In Proc. IEEE Conf. on
image databases for recognition.
Computer Vision and Pattern Recognition (CVPR). IEEE,
2008.

[23] E. Ustinova and V. Lempitsky. Learning deep embeddings
with histogram loss. In Proc. Advances in Neural Informa-
tion Processing Systems (NIPS), pages 4170–4178, 2016.
[24] J. S. Vitter. Random sampling with a reservoir. ACM
Transactions on Mathematical Software (TOMS), 11(1):37–
57, 1985.

[25] J. Wang, H. T. Shen, J. Song, and J. Ji. Hashing for similarity

search: A survey. CoRR.

[26] Q. Wang, Z. Zhang, and L. Si. Ranking preserving hashing
for fast similarity search. In Proc. International Joint Conf.
on Artiﬁcial Intelligence (IJCAI), 2015.

[27] Y. Wang, Xiaofang Shi and K. M. Kitani. Deep supervised
hashing with triplet labels. In Proc. Asian Conf. on Computer
Vision (ACCV), 2016.

[28] R. Xia, Y. Pan, H. Lai, C. Liu, and S. Yan. Supervised hash-
ing for image retrieval via image representation learning. In
Proc. AAAI Conf. on Artiﬁcial Intelligence (AAAI), volume 1,
page 2, 2014.

[29] Y. Yue, T. Finley, F. Radlinski, and T. Joachims. A support
In Proc.
vector method for optimizing average precision.
ACM Conf. on Research & Development in Information Re-
trieval (SIGIR), pages 271–278. ACM, 2007.

[30] Z. Zhang, Y. Chen, and V. Saligrama. Efﬁcient training of
very deep neural networks for supervised hashing. In Proc.
IEEE Conf. on Computer Vision and Pattern Recognition
(CVPR), 2016.

[31] F. Zhao, Y. Huang, L. Wang, and T. Tan. Deep semantic
ranking based hashing for multi-label image retrieval.
In
Proc. IEEE Conf. on Computer Vision and Pattern Recog-
nition (CVPR), 2015.

[32] B. Zhou, A. Lapedriza, J. Xiao, A. Torralba, and A. Oliva.
Learning deep features for scene recognition using places
database. In Proc. Advances in Neural Information Process-
ing Systems (NIPS), 2014.

References

[1] F. Cakir and S. Sclaroff. Adaptive hashing for fast similar-
ity search. In Proc. IEEE International Conf. on Computer
Vision (ICCV), 2015.

[2] F. Cakir and S. Sclaroff. Online supervised hashing. In Proc.
IEEE International Conf. on Image Processing (ICIP), 2015.
[3] K. Chatﬁeld, K. Simonyan, A. Vedaldi, and A. Zisserman.
Return of the devil in the details: Delving deep into convolu-
tional nets. In British Machine Vision Conference (BMVC),
2014.

[4] A. Gionis, P. Indyk, and R. Motwani. Similarity search in
In Proc. International Conf.

high dimensions via hashing.
on Very Large Data Bases (VLDB), 1999.

[5] Y. Gong and S. Lazebnik.

Iterative quantization: A pro-
crustean approach to learning binary codes. In Proc. IEEE
Conf. on Computer Vision and Pattern Recognition (CVPR),
2011.

[6] L.-K. Huang, Q. Y. Yang, and W.-S. Zheng. Online hashing.
In Proc. International Joint Conf. on Artiﬁcial Intelligence
(IJCAI), 2013.

[7] A. Krizhevsky and G. Hinton. Learning multiple layers of

features from tiny images, 2009.

[8] A. Krizhevsky, I. Sutskever, and G. E. Hinton.

Imagenet
classiﬁcation with deep convolutional neural networks.
In
Proc. Advances in Neural Information Processing Systems
(NIPS), 2012.

[9] B. Kulis and T. Darrell. Learning to hash with binary recon-
structive embeddings. In Proc. Advances in Neural Informa-
tion Processing Systems (NIPS), 2009.

[10] H. Lai, Y. Pan, Y. Liu, and S. Yan. Simultaneous feature
learning and hash coding with deep neural networks.
In
Proc. IEEE Conf. on Computer Vision and Pattern Recog-
nition (CVPR), 2015.

[11] C. Leng, J. Wu, J. Cheng, X. Bai, and H. Lu. Online sketch-
ing hashing. In Proc. IEEE Conf. on Computer Vision and
Pattern Recognition (CVPR), 2015.

[12] W.-J. Li, S. Wang, and W.-C. Kang. Feature learning based
deep supervised hashing with pairwise labels. In Proc. Inter-
national Joint Conf. on Artiﬁcial Intelligence (IJCAI), 2016.
[13] G. Lin, F. Liu, C. Shen, J. Wu, and H. T. Shen. Structured
learning of binary codes with column generation for optimiz-
International Journal of Computer
ing ranking measures.
Vision (IJCV), pages 1–22, 2016.

[14] G. Lin, C. Shen, Q. Shi, A. van den Hengel, and D. Suter.
Fast supervised hashing with decision trees for high-
dimensional data. In Proc. IEEE Conf. on Computer Vision
and Pattern Recognition (CVPR), 2014.

[15] K. Lin, J. Lu, C.-S. Chen, and J. Zhou. Learning compact
binary descriptors with unsupervised deep neural networks.
In Proc. IEEE Conf. on Computer Vision and Pattern Recog-
nition (CVPR), 2016.

[16] J. W. Liu, Wei and, R. Ji, Y.-G. Jiang, and S.-F. Chang. Su-
pervised hashing with kernels. In Proc. IEEE Conf. on Com-
puter Vision and Pattern Recognition (CVPR), 2012.
[17] C. D. Manning, P. Raghavan, and H. Sch¨utze. Introduction

to information retrieval. 2008.

Appendix

A. Implementation Details of MIHash

We discuss the implementation details of MIHash.
In
the online hashing experiments, for simplicity we model
MIHash using linear hash functions, in the form of φi(x) =
sgn(w(cid:62)
i x) ∈ {−1, +1}, i = 1, . . . , b. The learning capac-
ity of such a model is lower than the kernel-based OKH, and
is the same as OSH, AdaptHash, and SketchHash, which
use linear hash functions as well.

For the batch hashing experiments, as mentioned in the
paper, we similarly model MIHash using linear hash func-
tions in the ﬁrst setting, but perform end-to-end learning
with the VGG-F network in the second setting.
In this
case, the hash functions become φi(x) = sgn(fi(x; w)) ∈
{−1, +1}, i = 1, . . . , b, where fi are the logits produced by
the previous layer in the network.

We train MIHash using stochastic gradient descent. In
Eq. 11 in the paper, we gave the gradients of the mutual in-
formation objective I with respect to the outputs of the hash
mapping, Φ(x). Both I and ∂I/∂Φ(x) are parameter-free.
In order to further back-propagate gradients to the inputs of
Φ(x) and model parameters {wi}, we approximate the sgn
function using the sigmoid function σ:

φi(x) ≈ 2σ(Aw(cid:62)

i x) − 1,

(18)

where A > 1 is a scaling parameter, used to increase the
“sharpness” of the approximation. We ﬁnd A from the set
{10, 20, 30, 40, 50} in our experiments.

We note that A is not a tuning parameter of the mutual
information objective, but rather a parameter of the under-
lying hash functions. The design of the hash functions is
not coupled with the mutual information objective, thus can
be separated. It will be an interesting topic to explore other
methods of constructing hash functions, potentially in ways
that are free of tuning parameters.

B. Experimental Details

B.1. The streaming scenario

We set up a streaming scenario in our online hashing ex-
periments. We run three randomized trials for each experi-
ment. In each trial, we ﬁrst randomly split the dataset into
a retrieval set and a test set as described in Sec. 4.1 in the
paper, and randomly sample the training subset from the re-
trieval set. The ordering of the training set is also randomly
permuted. The random seeds are ﬁxed, so the baselines and
methods with the Trigger Update module observe the same
training sequences.

In a streaming setting, we also measure the cumulative
retrieval performance during online hashing, as opposed to
only the ﬁnal results. To mimic real retrieval systems where

queries arrive randomly, we set 50 randomized checkpoints
during the online process. We ﬁrst place the checkpoints
with equal spacing, then add small random perturbations
to their locations. We measure the instantaneous retrieval
mAP at these checkpoints to get mAP vs. time curves (e.g.
curves shown in Fig. 5 in the paper), and compute the area
under curve (AUC). AUC gives a summary of the entire on-
line learning process, which cannot be reﬂected by the ﬁnal
performance at the end.

B.2. Parameters for online hashing methods

We describe parameters used for online hashing methods
in the online experiments. Some of the competing methods
require parameter tuning, therefore we sample a validation
set from the training data and ﬁnd the best performing pa-
rameters for each method. The size of the validation sets are
2K, 2K and 10K for CIFAR-10, LabelMe and Places205,
respectively. Please refer to the respective papers for the
descriptions of the parameters.

• OSH: η is set to 0.1 for all datasets. The ECOC code-

book C is populated the same way as in OSH.

• AdaptHash:

to
tuple
(0.9, 0.01, 0.1), (0.1, 0.01, 0.001) and (0.9, 0.01, 0.1)
for CIFAR-10, LabelMe and Places205, respectively.

(α, λ, η)

the

set

is

• OKH:

the tuple (C, α)

to (0.001, 0.3),
(0.001, 0.3) and (0.0001, 0.7) for CIFAR-10, LabelMe
and Places205, respectively.

set

is

• SketchHash: the pair (sketch size, batch size) is set to
(200, 50), (100, 50) and (100, 50) for CIFAR-10, La-
belMe and Places205, respectively.

B.3. Parameters for batch hashing methods

We use the publicly available implementations for the
compared methods, and exhaustively search parameter set-
tings, including the default parameters as provided by the
authors. For DPSH and DTSH we found a combination that
worked well for the ﬁrst setting: the mini-batch size is set to
the default value of 128, and the learning rate is initialized
to 1 and decayed by a factor of 0.9 after every 20 epochs.
Additionally, for DTSH, the margin parameter is set to b/4
where b is the hash code length. VDSH uses a heavily cus-
tomized architecture with only fully-connected layers, and
it is unclear how to adapt it to work with standard CNN ar-
chitectures. In this sense, VDSH is more akin to nonlinear
hashing methods such as FastHash and SHK. We used the
full VDSH model with 16 layers and 1024 nodes per layer,
and found the default parameters to perform the best, ex-
cept that we increased the number of training iterations by
an order of magnitude during ﬁnetuning.

For MIHash, in the ﬁrst setting we use a batch size of
100, and run SGD with initial learning rate of 0.1 and a

Method

Training Time (s)

Training Time (s)

OKH
OKH + TU
OSH
OSH + TU
AdaptHash
AdaptHash + TU
SketchHash
SketchHash + TU

10.8
23.6
97.6
175.8
47.8
94.8
68.8
80.0

Method

SHK
SDH
FastHash
VDSH*
DPSH
DTSH
MIHash, 1ep
MIHash

mAP

0.682
0.592
0.738
0.554
0.553
0.702
0.609
0.746

180
4.8
140
206
450
1728
1.9
190

Table 2: Online hashing: running times on the CIFAR-10
20k training set, with 32-bit hash codes. For methods with
the TU plugin, the added time is due to maintaining the
reservoir set and computing the mutual information update
criterion, and is dominated by the maintaining of the reser-
voir set.

decay factor of 0.5 every 10 epochs, for 100 epochs. For
the second setting where we ﬁnetune the pretrained VGG-F
network, batch size is 250, learning rate is initially set to
0.001 and decayed by half every 50 epochs.

C. Running Time

C.1. Online Setting: Trigger Update Module

In Table 2 we report running time for all methods on
the CIFAR-10 dataset with 20k training examples, includ-
ing time spent in learning hash functions and the added pro-
cessing time for maintaining the reservoir set and comput-
ing TU. Numbers are recorded on a 2.3GHz Intel Xeon E5-
2650 CPU workstation with 128GB of DDR3 RAM. Most
of the added time is due to maintaining the reservoir set,
which is invoked in each training iteration; the mutual in-
formation update criterion is only checked after processing
every U = 100 examples. Methods with small batch sizes
(e.g. OSH, batch size 1) therefore incur more overhead than
methods with larger batches (e.g. SketchHash, batch size
50). Results for other datasets are similar.

We note that in a real retrieval system with large-scale
data, the bottleneck likely lies in recomputing the hash ta-
bles for indexed data, due to various factors such as schedul-
ing and disk I/O. We reduce this bottleneck signiﬁcantly by
using TU. Compared to this bottleneck, the increase in train-
ing time is not signiﬁcant.

C.2. Batch Setting

Table 3 reports CPU times for learning 48-bit hash map-
pings in the ﬁrst experimental setting on CIFAR-10 (5K
training set). Retrieval mAP are replicated from Table 1
in the paper. For learning a single layer, our Matlab im-
plementation of MIHash achieves 1.9 seconds per epoch
on CPU. MIHash achieves competitive performance with
a single epoch, and has a total training time on par with

Table 3: Batch hashing: test performance and training time
for 48-bit codes on the CIFAR-10, using the 5k training set.
*VDSH is trained with the full model as detailed in B.3.
1ep stands for training for one epoch only.

FastHash, while yielding superior performance.

D. Additional Experimental Results

D.1. Online Hashing: Other Code Lengths

In the online hashing experiments we reported in the pa-
per, all online hashing methods are compared in the same
setup with 32-bit hash codes. Additionally, we also present
results using 64-bit hash codes on all three datasets. The
parameters for all methods are found through validation as
described in B.2.

Similar to Sec 4.2 in the paper, we show the comparisons
with and without TU for existing online hashing methods in
Fig. 7, and plot the mAP curves for all methods, includ-
ing MIHash, in Fig. 8. The 64-bit results are uniformly
better than 32-bit results for all methods in terms of mAP,
but still follow the same patterns. Again, we can see that
MIHash clearly outperforms all competing online hashing
methods, and shows potential for improvement given more
training data.

D.2. Parameter Study: θ

We present a parameter study on the parameter θ, the im-
provement threshold on the mutual information criterion in
TU. In our previous experiments, we found the default θ = 0
to work well, and did not speciﬁcally tune θ. However, tun-
ing for a larger θ could lead to better trade-offs, since small
improvements in the quality of the hash mapping may not
justify the cost of a full hash table update.

For this study, we vary parameter θ from −∞ to ∞ for
all methods (with 32-bit hash codes). θ = −∞ reduces to
the baseline. On the other hand, θ = ∞ prevents any up-
dates to the initial hash mapping and hash table, and results
in only one hash table update (for the initial mapping) and
typically low performance. The performance metric we fo-
cus on in this study is the cumulative metric, AUC, since
it better summarizes the entire online learning process than
the ﬁnal performance alone.

Figure 7: 64-bit experiments: Retrieval mAP vs. number of training examples for four existing online hashing methods on
the three datasets, with and without Trigger Update (TU). We use default threshold θ = 0 for TU. Circles indicate hash table
updates, and the ratio of reduction in the number of updates is marked for each graph. TU substantially reduces the number
of updates while having a stabilizing effect on the retrieval performance. Note: since the OSH method assumes supervision
in terms of class labels, it is not applicable to the unsupervised LabelMe dataset.

Figure 8: 64-bit experiments: Online hashing performance (mAP) comparison on three datasets, where all methods use
the Trigger Update module (TU) with θ = 0. Using the mutual information objective, MIHash clearly outperforms other
methods. OKH, AdaptHash, ad SketchHash perform very similarly on CIFAR-10. OSH, AdaptHash, ad SketchHash perform
very similarly on Places205. Again, the OSH method is not applicable to the unsupervised LabelMe dataset.

We use a custom update schedule for SketchHash: we
enforce hash table updates in the early iterations regard-
less of other criteria, until the number of observed exam-
ples reaches the speciﬁed size of the “data sketch”, which
SketchHash uses to perform a batch hashing algorithm.
This was observed to be critical for the performance of
SketchHash. Therefore, the number of hash table updates
for SketchHash can be greater than 1 even for θ = ∞.

We present full results in Tables 4, 5, 6. In all cases, we
observe a substantial decrease in the number of hash table
updates as θ increases. With reasonable θ values (typically
around 0), the number of hash table updates can be reduced
by over an order of magnitude with no loss in AUC. Note
that the computation-performance trade-off achieved by the
default θ = 0 is always among the best, thereby in practice
it can be used without tuning.

D.3. Parameter Study: U

We simulate a data-agnostic baseline that updates hash
tables at a constant rate, using the update interval param-
eter U .
In the paper, U is set such that the baseline up-
dates a total of 201 times for all datasets. This ensures that
the baseline is never too outdated (compared to 50 check-
points at which performance is evaluated), but is still fairly
infrequent: the smallest U in this case is 100, which means
the baselines process at least 100 training examples before
recomputing the hash table. For completeness, here we
present the results using different values of U , where all
methods again use 32-bit hash codes and the default θ = 0.
We used a simple rule that avoids unnecessary hash table
updates if the hash mapping itself does not change. Specif-
ically, we do not update if (cid:107)Φt − Φs(cid:107) < 10−6, where Φs
is the current snapshot and Φt is the new candidate. Some
baseline entries have fewer updates because of this rule (e.g.
AdaptHash on Places205). And as explained before, due to
the custom update schedule, SketchHash may have more
hash table updates than what is suggested by U .

Please see Tables 7, 8, 9 for the full results. In all experi-
ments, we run three random trials and average the results as
mentioned before, and the standard deviation of mAP and
AUC scores are less than 0.01. Generally, using smaller
U leads to more updates by both the baselines and methods
with TU; recall that U is also a parameter of TU which spec-
iﬁes the frequency of checking the update criterion. How-
ever, methods with the TU module appear to be quite in-
sensitive to the choice of U , e.g. the number of updates
for SketchHash with TU on CIFAR-10 only increases by 2x
while U is reduced by 20x, from 1000 to 50. We attribute
this to the ability of TU to ﬁlter out unnecessary updates.
Across different values of U , TU consistently brings compu-
tational savings while preserving/improving online hashing
performance, as indicated by ﬁnal mAP and AUC.

CIFAR-10, 32 bits
HT Updates
201
190 (5.8x)
8.0 (25.1x)
8.0 (25.1x)
7.7 (26.1x)
3.3 (91.2x)
1.0 (201x)
HT Updates
201
39.0 (5.2x)
36.7 (5.5x)
35.7 (5.6x)
6.7 (30x)
2.0 (100x)
1.0 (201x)
AdaptHash HT Updates

OKH
≤ −0.1
−0.01
−10−4
0
10−4
0.01
≥ 0.2
OSH
≤ −0.01
−10−4
0
10−4
0.01
0.1
≥ 0.3

≤ −0.1
−0.01
−10−4
0
10−4
0.01
≥ 0.1

201
68.3 (2.9x)
10.3 (19.5x)
10.0 (20.1x)
10.0 (20.1x)
3.3 (60.9x)
1.0 (201x)
SketchHash HT updates

≤ −0.01
−10−4
−10−6
0
10−4
0.01
≥ 0.1

201
9.0 (22.3x)
7.3 (27.5x)
7.3 (27.5x)
7.3 (27.5x)
4.3 (46.7x)
4.0 (50.3x)

–

–

AUC ∆AUC
0.259
0.260 +0.4%
0.287 +10.8%
0.287 +10.8%
0.287 +10.8%
+8.1%
0.280
0.134 −48.3%
AUC ∆AUC
0.463
0.466 +0.6%
0.466 +0.6%
0.466 +0.6%
0.453 −2.1%
−16%
0.386
−55%
0.207
AUC ∆AUC
0.218
0.238 +9.2%
0.250 +14.7%
0.250 +14.7%
0.250 +14.7%
0.244 +11.9%
0.211 −3.3%
AUC ∆AUC
0.304
0.318 +4.6%
0.319 +4.9%
0.319 +4.9%
0.319 +4.9%
0.318 +4.6%
0.314 +3.3%

–

–

Table 4: Parameter study on the threshold value θ for on-
line hashing methods on CIFAR-10 (32 bits). We report
the number of hash table updates, where 100x indicates a
100 times reduction with respect to the baseline. We also
report the area under the mAP curve (AUC) and compare to
baseline.

OKH
≤ −0.01
−10−4
−10−6
0
10−6
10−4
0.01
≥ 0.1
OSH
≤ −0.001
−20−4
−10−4
0
10−4
10−3
≥ 0.1

Places205, 32 bits
HT Updates
201
8.3 (24.2x)
7.0 (28.7x)
7.0 (28.7x)
7.0 (28.7x)
5.7 (35.3x)
2.0 (100x)
1.0 (201x)
HT Updates
201
101 (2.0x)
9.3 (21.6x)
7.0 (28.7x)
5.7 (35.3x)
2.7 (74.4x)
1.0 (201x)
AdaptHash HT Updates
≤ −0.01
−10−4
−10−6
0
10−6
10−4
≥ 0.01

199.7
199 (1.0x)
9.7 (20.6x)
8.7 (23.0x)
8.7 (23.0x)
3.0 (66.6x)
1.0 (201x)
SketchHash HT Updates

≤ −0.01
−10−4
−10−6
0
10−6
10−4
≥ 0.01

201
52.3 (3.8x)
15.3 (12.6x)
12.7 (15.8x)
15.3 (13.1x)
7.0 (28.7x)
2.0 (101x)

–

–
0%

AUC ∆AUC
0.163
0.161 −1.2%
0.161 −1.2%
0.161 −1.2%
0.161 −1.2%
0.161 −1.2%
−25%
0.123
−91%
0.014
AUC ∆AUC
0.246
0.246
0.236 −4.1%
0.236 −4.1%
0.230 −6.5%
0.224 −8.9%
0.226 −8.1%
AUC ∆AUC
0.237
0.237
0.236 −0.4%
0.236 −0.4%
0.235 −0.8%
0.235 −0.8%
0.227 −3.4%
AUC ∆AUC
0.237
0.238 +0.4%
0.238 +0.4%
0.236 −0.4%
0.238 +0.4%
0.239 +0.8%
0.223 −5.9%

–
0%

–

LabelMe, 32 bits
HT Updates
201
196 (1.0x)
2.7 (74.4x)
2.3 (87.4x)
2.3 (87.4x)
2.3 (87.4x)
2.0 (101x)
1.0 (201x)
AdaptHash HT Updates

OKH
≤ −0.2
−0.1
−0.01
−10−6
0
10−6
0.01
≥ 0.6

≤ −0.1
−10−6
−10−4
−10−2
0
10−6
10−4
10−2
≥ 0.1

≤ −0.1
−10−2
−10−4
0
10−4
10−2
≥ 0.1

201
149 (1.3x)
9.3 (21.6x)
8.7 (23.1x)
5.3 (37.9x)
8.7 (23.1x)
8.3 (24.2x)
2.7 (74.4x)
1 (201x)

201
195 (1.0x)
9.3 (21.6x)
8.7 (23.1x)
10 (20.1x)
4.7 (42.8x)
4.0 (50.3x)

SketchHash HT Updates

–

–

AUC ∆AUC
0.198
0.199 +0.5%
+88%
0.373
+89%
0.374
+89%
0.374
+89%
0.374
+88%
0.372
−44%
0.111
AUC ∆AUC
0.333
0.330 −0.9%
0.365 +9.6%
0.365 +9.6%
+11%
0.369
0.365 +9.6%
0.358 +7.5%
0.351 +5.4%
−11%
0.296
AUC ∆AUC
0.446
0.446
0.460 +3.1%
0.460 +3.1%
0.459 +2.9%
0.446
0.439 −1.6%

–
0%

0%

Table 5: Parameter study on the threshold value θ for on-
line hashing methods on Places205 (32 bits). We report the
number of hash table updates, where 100x indicates a 100
times reduction with respect to the baseline. We also re-
port the area under the mAP curve (AUC) and compare to
baseline.

Table 6: Parameter study on the threshold value θ for online
hashing methods on LabelMe (32 bits). We report the num-
ber of hash table updates, where 100x indicates a 100 times
reduction with respect to the baseline. We also report the
area under the mAP curve (AUC) and compare to baseline.
Note: OSH is not applicable to this unlabeled dataset since
it needs supervision in terms of class labels.

CIFAR-10, 32 bits

Final mAP AUC (mAP)

Method

OKH, U = 10

OKH, U = 100

OKH, U = 1000

OSH, U = 10

OSH, U = 100

OSH, U = 1000

AdaptHash, U = 10

AdaptHash, U = 100

AdaptHash, U = 1000

SketchHash, U = 50

SketchHash, U = 100

SketchHash, U = 1000

1870

201
8 (25.1x)
21
2.6 (8x)
2001
110.7 (18x)
201
36.7 (5.4x)
21
11.3 (1.9x)
2001

TU HT Updates
×
(cid:88) 15.6 (119.3x)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88) 19.6 (101.7x)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)

201
10.0 (10.1x)
21
5 (4.2x)
400
9 (44.4x)
202
7.3 (27.5x)
24
4.6 (5.2x)

0.238
0.297
0.238
0.291
0.238
0.282
0.480
0.483
0.480
0.483
0.480
0.479
0.244
0.267
0.244
0.255
0.244
0.252
0.306
0.318
0.306
0.320
0.306
0.317

0.259
0.293 (+13%)
0.259
0.287 (+10.8%)
0.255
0.273 (+7%)
0.463
0.466 (+0.6%)
0.463
0.466 (+0.6%)
0.454
0.454
0.224
0.261 (+16%)
0.224
0.250 (+11.6%)
0.222
0.234 (+5%)
0.303
0.318 (+5%)
0.304
0.319 (+4.9%)
0.305
0.314 (+2.9%)

Table 7: Online hashing results (32 bits) with different update interval parameters (U ) on the CIFAR-10 dataset. All results
are averaged from 3 random trials. For the number of hash table updates, we report the reduction ratio (e.g. 8x) for TU. For
AUC, we report the relative change compared to baseline. Note: SketchHash uses a batch size of 50, therefore the smallest
U is set to 50.

LabelMe, 32 bits

Final mAP AUC (mAP)

Method

OKH, U = 10

OKH, U = 100

OKH, U = 1000

AdaptHash, U = 10

AdaptHash, U = 100

AdaptHash, U = 1000

SketchHash, U = 50

SketchHash, U = 100

SketchHash, U = 1000

2001
8 (250x)
201
2.3 (86.2x)
21
2 (10.5x)
2001

TU HT Updates
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88) 12.6 (157.9x)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)

201
8.6 (23.1x)
21
5 (4.2x)
400
9.6 (41.6x)
202
8.67 (23.2x)
24
8.3 (2.8x)

0.119
0.382
0.119
0.380
0.119
0.373
0.318
0.380
0.318
0.379
0.318
0.343
0.445
0.461
0.445
0.462
0.445
0.456

0.200
0.377 (+88.5%)
0.200
0.374 (+87%)
0.193
0.357 (+85%)
0.319
0.371 (+16.3%)
0.318
0.365 (+14.7%)
0.317
0.337 (+6.3%)
0.447
0.460 (+2%)
0.446
0.460 (+3.1%)
0.445
0.455 (+2%)

Table 8: Online hashing results (32 bits) with different update interval parameters (U ) on the LabelMe dataset. All results
are averaged from 3 random trials. For the number of hash table updates, we report the reduction ratio (e.g. 8x) for TU. For
AUC, we report the relative change compared to baseline. Note: since LabelMe is an unsupervised dataset, the OSH method
is not applicable since it requires supervision in the form of class labels.

Places205, 32 bits

Final mAP AUC (mAP)

Method

OKH, U = 50

OKH, U = 500

OKH, U = 5000

OSH, U = 50

OSH, U = 500

OSH, U = 5000

AdaptHash, U = 50

AdaptHash, U = 500

AdaptHash, U = 5000

SketchHash, U = 50

SketchHash, U = 500

SketchHash, U = 5000

2001
8 (250.1x)
201
7 (28.7x)
21
2 (10.5x)
2001
25 (80x)
201
7 (28.7x)
21
2 (10.5x)
823.7
26.6 (30.8x)
200
8.6 (23.0x)
21
3 (7x)
2000

TU HT Updates
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88) 19.3 (103.4x)
×
(cid:88)
×
(cid:88)

202
15.3 (13.1x)
22
6.6 (3.2x)

0.182
0.173
0.182
0.165
0.182
0.157
0.248
0.239
0.248
0.236
0.248
0.234
0.238
0.236
0.238
0.236
0.238
0.236
0.238
0.236
0.237
0.240
0.235
0.239

0.163
0.169 (+3.7%)
0.163
0.161 (-1.2%)
0.156
0.148 (-5.1%)
0.246
0.238 (-3%)
0.246
0.236 (-4.0%)
0.245
0.233 (-4%)
0.237
0.236 (-0.4%)
0.237
0.236 (-0.4%)
0.237
0.236 (-0.4%)
0.235
0.235 (0%)
0.235
0.238 (+1.2%)
0.235
0.238 (+1.2%)

Table 9: Online hashing results (32 bits) with different update interval parameters (U ) on the Places205 dataset. All results
are averaged from 3 random trials. For the number of hash table updates, we report the reduction ratio (e.g. 8x) for TU. For
and AUC, we report the relative change compared to baseline.

MIHash: Online Hashing with Mutual Information

Fatih Cakir∗ Kun He∗

Sarah Adel Bargal

Stan Sclaroff

Department of Computer Science
Boston University, Boston, MA
{fcakir,hekun,sbargal,sclaroff}@cs.bu.edu

7
1
0
2
 
l
u
J
 
9
2
 
 
]

V
C
.
s
c
[
 
 
2
v
9
1
9
8
0
.
3
0
7
1
:
v
i
X
r
a

Abstract

Learning-based hashing methods are widely used for
nearest neighbor retrieval, and recently, online hashing
methods have demonstrated good performance-complexity
trade-offs by learning hash functions from streaming data.
In this paper, we ﬁrst address a key challenge for online
hashing:
the binary codes for indexed data must be re-
computed to keep pace with updates to the hash functions.
We propose an efﬁcient quality measure for hash functions,
based on an information-theoretic quantity, mutual infor-
mation, and use it successfully as a criterion to eliminate
unnecessary hash table updates. Next, we also show how to
optimize the mutual information objective using stochastic
gradient descent. We thus develop a novel hashing method,
MIHash, that can be used in both online and batch settings.
Experiments on image retrieval benchmarks (including a
2.5M image dataset) conﬁrm the effectiveness of our for-
mulation, both in reducing hash table recomputations and
in learning high-quality hash functions.

1. Introduction

Hashing is a widely used approach for practical nearest
neighbor search in many computer vision applications. It
has been observed that adaptive hashing methods that learn
to hash from data generally outperform data-independent
hashing methods such as Locality Sensitive Hashing [4]. In
this paper, we focus on a relatively new family of adaptive
hashing methods, namely online adaptive hashing methods
[1, 2, 6, 11]. These techniques employ online learning in the
presence of streaming data, and are appealing due to their
low computational complexity and their ability to adapt to
changes in the data distribution.

Despite recent progress, a key challenge has not been
addressed in online hashing, which motivates this work:
the computed binary representations, or the “hash table”,
may become outdated after a change in the hash mapping.
To reﬂect the updates in the hash mapping, the hash table

∗First two authors contributed equally.

ˆx and non-neighbors in

Figure 1: We study online hashing for efﬁcient nearest
neighbor retrieval. Given a hash mapping Φ, an image ˆx,
ˆx,
along with its neighbors in
(cid:22)
are mapped to binary codes, yielding two distributions of
Hamming distances. In this example, Φ1 has higher quality
than Φ2 since it induces more separable distributions. The
information-theoretic quantity Mutual Information can be
used to capture the separability, which gives a good quality
indicator and learning objective for online hashing.

(cid:23)

may need to be recomputed frequently, causing inefﬁcien-
cies in the system such as successive disk I/O, especially
when dealing with large datasets. We thus identify an im-
portant question for online adaptive hashing systems: when
to update the hash table? Previous online hashing solutions
do not address this question, as they usually update both the
hash mapping and hash table concurrently.

We make the observation that achieving high quality
nearest neighbor search is an ultimate goal in hashing sys-
tems, and therefore any effort to limit computational com-
plexity should preserve, if not improve, that quality. There-
fore, another important question is: how to quantify qual-
ity? Here, we brieﬂy describe our answer to this question,
but ﬁrst introduce some necessary notation. We would like
to learn a hash mapping Φ from feature space X to the b-
dimensional Hamming space Hb, whose outputs are b-bit

(cid:22)

(cid:23)

ˆx, and a set of non-neighbors

binary codes. The goal of hashing is to preserve a neighbor-
hood structure in X after the mapping to Hb. Given ˆx ∈ X ,
the neighborhood structure is usually given in terms of a set
of its neighbors
ˆx. We
discuss how to derive the neighborhood structure in Sec. 3.
As shown in Fig. 1, the distributions of the Hamming
distances from ˆx to its neighbors and non-neighbors are his-
tograms over {0, 1, . . . , b}. Ideally, if there is no overlap
between these two distributions, we can recover
ˆx
by simply thresholding the Hamming distance. A nonzero
overlap results in ambiguity, as observing the Hamming dis-
tance is no longer sufﬁcient to determine neighbor relation-
ships. Our discovery is that this overlap can be quanti-
ﬁed using an information-theoretic quantity, mutual infor-
mation, between two random variables induced by Φ. We
then use mutual information to deﬁne a novel measure to
quantify quality for hash functions in general.

ˆx and

(cid:23)

(cid:22)

With a quality measure deﬁned, we answer the motivat-
ing question of when to update the hash table. We propose
a simple solution by restricting updates to times when there
is an estimated improvement in hashing quality, based on
an efﬁcient estimation method in the presence of streaming
data. Notably, since mutual information is a good general-
purpose quality measure for hashing, this results in a gen-
eral plug-in module for online hashing that does not require
knowledge of the learning method.

Inspired by this strong result, we next ask, can we opti-
mize mutual information as an objective to learn hash func-
tions? We propose a novel hashing method, MIHash, by
deriving gradient descent rules on the mutual information
objective, which can be applied in online stochastic opti-
mization, as well as on deep architectures. The mutual in-
formation objective is free of tuning parameters, unlike oth-
ers that may require thresholds, margins, etc.

We conduct experiments on three image retrieval bench-
marks, including the Places205 dataset [32] with 2.5M im-
ages. For four recent online hashing methods, our mu-
tual information based update criterion consistently leads to
over an order of magnitude reduction in hash table recom-
putations, while maintaining retrieval accuracy. Moreover,
our novel MIHash method achieves state-of-the-art retrieval
results, in both online and batch learning settings.

2. Related Work

In this section, we mainly review hashing methods that
adaptively update the hash mapping with incoming data,
given that our focus is on online adaptive hashing. For a
more general survey on hashing, please refer to [25].

Huang et al. [6] propose Online Kernel Hashing, where
a stochastic environment is considered with pairs of points
arriving sequentially. At each step, a number of hash func-
tions are selected based on a Hamming loss measure and pa-
rameters are updated via stochastic gradient descent (SGD).

Cakir and Sclaroff [1] argue that, in a stochastic setting,
it is difﬁcult to determine which hash functions to update as
it is the collective effort of all the hash functions that yields
a good hash mapping. Hamming loss is considered to infer
the hash functions to be updated at each step and a squared
error loss is minimized via SGD.

In [2], binary Error Correcting Output Codes (ECOCs)
are employed in learning the hash functions. This work
follows a more general two-step hashing framework [14],
where the set of ECOCs are generated beforehand and are
assigned to labeled data as they appear, allowing the label
space to grow with incoming data. Then, hash functions are
learned to ﬁt the binary ECOCs using Online Boosting.

Inspired by the idea of “data sketching”, Leng et al. in-
troduce Online Sketching Hashing [11] where a small ﬁxed-
size sketch of the incoming data is maintained in an online
fashion. The sketch retains the Frobenius norm of the full
data matrix, which offers space savings, and allows to ap-
ply certain batch-based hashing methods. A PCA-based
batch learning method is applied on the sketch to obtain
hash functions.

None of the above online hashing methods offer a solu-
tion to decide whether or not the hash table shall be updated
given a new hash mapping. However, such a solution is
crucial in practice, as limiting the frequency of updates will
alleviate the computational burden of keeping the hash ta-
ble up-to-date. Although [2] and [6] include strategies to
select individual hash functions to recompute, they still re-
quire computing on all indexed data instances.

Recently, some methods employ deep neural networks
to learn hash mappings, e.g. [12, 15, 27, 30] and others.
These methods use minibatch-based stochastic optimiza-
tion, however, they usually require multiple passes over a
given dataset to learn the hash mapping, and the hash table
is only computed when the hash mapping has been learned.
Therefore, current deep learning based hashing methods are
essentially batch learning methods, which differ from the
online hashing methods that we consider, i.e. methods that
process streaming data to learn and update the hash map-
pings on-the-ﬂy while continuously updating the hash ta-
ble. Nevertheless, when evaluating our mutual information
based hashing objective, we compare against state-of-the-
art batch hashing formulations as well, by contrasting dif-
ferent objective functions on the same model architecture.

Lastly, Ustinova et al. [23] recently proposed a method
to derive differentiation rules for objective functions that re-
quire histogram binning, and apply it in learning deep em-
beddings. When optimizing our mutual information objec-
tive, we utilize their differentiable histogram binning tech-
nique for deriving gradient-based optimization rules. Note
that both our problem setup and objective function are quite
different from [23].

3. Online Hashing with Mutual Information

As mentioned in Sec. 1, the goal of hashing is to learn a
hash mapping Φ : X → Hb such that a desired neighbor-
hood structure is preserved. We consider an online learning
setup where Φ is continuously updated from input stream-
ing data, and at time t, the current mapping Φt is learned
from {x1, . . . , xt}. We follow the standard setup of learn-
ing Φ from pairs of instances with similar/dissimilar labels
[9, 6, 1, 12]. These labels, along with the neighborhood
structure, can be derived from a metric, e.g. two instances
are labeled similar (i.e. neighbors of each other) if their Eu-
clidean distance in X is below a threshold. Such a setting
is often called unsupervised hashing. On the other hand, in
supervised hashing with labeled data, pair labels are derived
from individual class labels: instances are similar if they are
from the same class, and dissimilar otherwise.

Below, we ﬁrst derive the mutual information quality
measure and discuss its use in determining when to update
the hash table in Sec. 3.1. We then describe a gradient-based
approach for optimizing the same quality measure, as an ob-
jective for learning hash mappings, in Sec. 3.2. Finally, we
discuss the beneﬁts of using mutual information in Sec. 3.3.

3.1. MI as Update Criterion

We revisit our motivating question: When to update the
hash table in online hashing? During the online learn-
ing of Φt, we assume a retrieval set S ⊆ X , which may
include the streaming data after they are received. We
deﬁne the hash table as the set of hashed binary codes:
T (S, Φ) = {Φ(x)|x ∈ S}. Given the adaptive nature of
online hashing, T may need to be recomputed often to keep
pace with Φt; however, this is undesirable if S is large or the
change in Φt’s quality does not justify the cost of an update.
We propose to view the learning of Φt and computa-
tion of T as separate events, which may happen at different
rates. To this end, we introduce the notion of a snapshot,
denoted Φs, which is occasionally taken of Φt and used
to recompute T . Importantly, this happens only when the
nearest neighbor retrieval quality of Φt has improved, and
we now deﬁne the quality measure.

Given hash mapping Φ : X → {−1, +1}b, Φ induces

Hamming distance dΦ : X × X → {0, 1, . . . , b} as

dΦ(x, ˆx) =

(cid:0)b − Φ(x)(cid:62)Φ(ˆx)(cid:1) .

(1)

1
2

Consider some instance ˆx ∈ X , and the sets contain-
ˆx. Φ induces
ing neighbors and non-neighbors,
two conditional distributions, P (dΦ(x, ˆx)|x ∈
ˆx) and
P (dΦ(x, ˆx)|x ∈
ˆx) as seen in Fig. 1, and it is desir-
able to have low overlap between them. To formulate the
idea, for Φ and ˆx, deﬁne random variable Dˆx,Φ : X →
{0, 1, . . . , b}, x (cid:55)→ dΦ(x, ˆx), and let Cˆx : X → {0, 1} be

ˆx and

(cid:22)

(cid:23)

(cid:22)

(cid:23)

ˆx. The two conditional dis-
the membership indicator for
(cid:22)
tributions can now be expressed as P (Dˆx,Φ|Cˆx = 1) and
P (Dˆx,Φ|Cˆx = 0), and we can write the mutual information
between Dˆx,Φ and Cˆx as

I(Dˆx,Φ; Cˆx) = H(Cˆx) − H(Cˆx|Dˆx,Φ)

= H(Dˆx,Φ) − H(Dˆx,Φ|Cˆx)

(2)

(3)

D, and pD, respectively.

where H denotes (conditional) entropy. In the following,
for brevity we will drop subscripts Φ and ˆx, and denote the
two conditional distributions and the marginal P (Dˆx,Φ) as
p+
D, p−
By deﬁnition, I(D; C) measures the decrease in uncer-
tainty in the neighborhood information C when observing
the Hamming distances D. We claim that I(D; C) also cap-
tures how well Φ preserves the neighborhood structure of ˆx.
If I(D; C) attains a high value, which means C can be de-
termined with low uncertainty by observing D, then Φ must
have achieved good separation (i.e. low overlap) between
p+
D and p−
D. I is maximized when there is no overlap, and
minimized when p+
D are exactly identical. Recall,
however, that I is deﬁned with respect to a single instance
ˆx; therefore, for a general quality measure, we integrate I
over the feature space:

D and p−

Q(Φ) =

I(Dˆx,Φ; Cˆx)p(ˆx)dˆx.

(4)

(cid:90)

X

Q(Φ) captures the expected amount of separation between
D and p−
p+
D achieved by Φ, over all instances in X .
In the online setting, given the current hash mapping Φt
and previous snapshot Φs, it is then straightforward to pose
the update criterion as

Q(Φt) − Q(Φs) > θ,

(5)

where θ is a threshold; a straightforward choice is θ = 0.
However, Eq. 4 is generally difﬁcult to evaluate due to the
intractable integral; in practice, we resort to Monte-Carlo
approximations to this integral, as we describe next.

Monte-Carlo Approximation by Reservoir Sampling
We give a Monte-Carlo approximation of Eq. 4. Since we
work with streaming data, we employ the Reservoir Sam-
pling algorithm [24], which enables sampling from a stream
or sets of large/unknown cardinality. With reservoir sam-
pling, we obtain a reservoir set R (cid:44) {xr
K} from
the stream, which can be regarded as a ﬁnite sample from
p(x). We estimate the value of Q on R as:

1, . . . , xr

QR(Φ) =

IR(Dxr,Φ; Cxr ).

(6)

1
|R|

(cid:88)

xr∈R

We use subscript R to indicate that when computing the
mutual information I, the p+
D for a reservoir in-
stance xr are estimated from R. This can be done in O(|R|)

D and p−

Figure 2: We present the general plug-in module for on-
line hashing methods: Trigger Update (TU). We sample a
reservoir R from the input stream, and estimate the mutual
information criterion QR. Based on its value, TU decides
whether a hash table update should be executed.

time for each xr, as the discrete distributions can be esti-
mated via histogram binning.

Fig. 2 summarizes our approach. We use the reservoir
set to estimate the quality QR, and “trigger” an update to
the hash table only when QR improves over a threshold.
Notably, our approach provides a general plug-in module
for online hashing techniques, in that it only needs access
to streaming data and the hash mapping itself, independent
of the hashing method’s inner workings.

3.2. MI as Learning Objective

Having shown that mutual information is a suitable mea-
sure of neighborhood quality, we consider its use as a
learning objective for hashing. Following the notation in
Sec. 3.1, we deﬁne a loss L with respect to ˆx ∈ X and Φ as

L(ˆx, Φ) = −I(Dˆx,Φ; Cˆx).

(7)

We model Φ as a collection of parameterized hash func-
tions, each responsible for generating a single bit: Φ(x) =
[φ1(x; W ), ..., φb(x; W )], where φi : X → {−1, +1}, ∀i,
and W represents the model parameters. For example, lin-
ear hash functions can be written as φi(x) = sgn(w(cid:62)
i x),
and for deep neural networks the bits are generated by
thresholding the activations of the output layer.

Inspired by the online nature of the problem and recent
advances in stochastic optimization, we derive gradient de-
scent rules for L. The entropy-based mutual information
is differentiable with respect to the entries of pD, p+
D and
p−
D, and, as mentioned before, these discrete distributions
can be estimated via histogram binning. However, it is not
clear how to differentiate histogram binning to generate gra-
dients for model parameters. We describe a differentiable
histogram binning technique next.

Differentiable Histogram Binning
We borrow ideas from [23] and estimate p+
D and pD us-
ing a differentiable histogram binning technique. For b-bit
Hamming distances, we use (K + 1)-bin normalized his-
tograms with bin centers v0 = 0, ..., vK = b and uniform
bin width ∆ = b/K, where K = b by default. Consider,

D, p−

for example, the k-th entry in p+
be estimated as

D, denoted as p+

D,k. It can

p+
D,k =

1

(cid:88)

|

|

x∈

δx,k,

(cid:22)
where δx,k records the contribution of x to bin k. It is ob-
tained by interpolating dΦ(x, ˆx) using a triangular kernel:

(cid:22)

δx,k =






(dΦ(x, ˆx) − vk−1)/∆, dΦ(x, ˆx) ∈ [vk−1, vk],
(vk+1 − dΦ(x, ˆx))/∆, dΦ(x, ˆx) ∈ [vk, vk+1],
0,

otherwise.

This binning process admits subgradients:

∂δx,k
∂dΦ(x, ˆx)

=






dΦ(x, ˆx) ∈ [vk−1, vk],
1/∆,
−1/∆, dΦ(x, ˆx) ∈ [vk, vk+1],
0,
otherwise.

Gradients of MI
We now derive the gradient of I with respect to the output
of the hash mapping, Φ(ˆx). Using standard chain rule, we
can ﬁrst write

∂I
∂Φ(ˆx)

=

(cid:34)

K
(cid:88)

k=0

∂I
∂p+

D,k

∂p+
D,k
∂Φ(ˆx)

+

∂I
∂p−

D,k

(cid:35)

∂p−
D,k
∂Φ(ˆx)

.

(11)

We focus on terms involving p+

D,k, and omit derivations

for p−

D,k due to symmetry. For k = 0, . . . , K, we have
∂I
∂p+

∂H(D|C)
∂p+

∂H(D)
∂p+

= −

+

D,k

D,k

D,k

= p+(log p+

D,k + 1) − (log pD,k + 1)

∂pD,k
∂p+

D,k

= p+(log p+

D,k − log pD,k),

where we used the fact that pD,k = p+p+
D,k, with
p+ and p− being shorthands for the priors P (C = 1) and
P (C = 0). We next tackle the term ∂p+
D,k/∂Φ(ˆx) in Eq. 11.
From the deﬁnition of p+

D,k + p−p−

D,k in Eq.8, we have

∂p+
D,k
∂Φ(ˆx)

∂δx,k
∂Φ(ˆx)

=

=

=

1

(cid:22)
1

(cid:22)
1

(cid:22)

|

|

|

|

|

|

(cid:88)

x∈

(cid:22)
(cid:88)

x∈

(cid:22)
(cid:88)

x∈

(cid:22)

∂δx,k
∂dΦ(x, ˆx)

∂dΦ(x, ˆx)
∂Φ(ˆx)

∂δx,k
∂dΦ(x, ˆx)

−Φ(x)
2

.

Note that ∂δx,k/∂dΦ(x, ˆx) is already given in Eq. 10. For
the last step, we used the deﬁnition of dΦ in Eq. 1.

Lastly, to back-propagate gradients to Φ’s inputs and ul-
timately model parameters, we approximate the discontin-
uous sign function with sigmoid, which is a standard tech-
nique in hashing, e.g. [1, 12, 16].

(8)

(9)

(10)

(12)

(13)

(14)

(15)

(16)

(17)

Figure 3: We show Pearson correlation coefﬁcients between mutual information (MI) and AP, DCG, and NDCG, evaluated
on the CIFAR-10, LabelMe, and Places205 datasets. We sample 100 instances to form the query set, and use the rest to
populate the hash table. The hash mapping parameters are randomly sampled from a Gaussian, similar to LSH [4]. Each
experiment is conducted 50 times. There exist strong correlations between MI and the standard metrics.

3.3. Beneﬁts of MI

For monitoring the performance of hashing algorithms,
it appears that one could directly use standard ranking met-
rics, such as Average Precision (AP), Discounted Cumu-
lative Gain (DCG), and Normalized DCG (NDCG) [17].
Here, we discuss the beneﬁts of instead using mutual in-
formation. First, we note that there exist strong correlations
between mutual information and standard ranking metrics.
Fig. 3 demonstrates the Pearson correlation coefﬁcients be-
tween MI and AP, DCG, and NDCG, on three benchmarks.
Although a theoretical analysis is beyond the scope of this
work, empirically we ﬁnd that MI serves as an efﬁcient and
general-purpose ranking surrogate.

We also point out the lower computational complexity of
mutual information. Let n be the reservoir set size. Com-
puting Eq. 6 involves estimating discrete distributions via
histogram binning, and takes O(n) time for each reservoir
item, since D only takes discrete values from {0, 1, . . . , b},
In contrast, ranking measures such as AP and NDCG have
O(n log n) complexity due to sorting, which render them
disadvantageous.

Finally, Sec. 3.2 showed that the mutual information ob-
jective is suitable for direct, gradient-based optimization. In
contrast, optimizing metrics like AP and NDCG is much
more challenging as they are non-differentiable, and ex-
isting works usually resort to optimizing their surrogates
[13, 26, 29] rather than gradient-based optimization. Fur-
thermore, mutual information itself is essentially parameter-
free, whereas many other hashing formulations require (and
can be sensitive to) tuning parameters, such as thresholds or
margins [18, 27], quantization strength [12, 15, 20], etc.

4. Experiments

We evaluate our approach on three widely used image
benchmarks. We ﬁrst describe the datasets and experimen-
tal setup in Sec. 4.1. We evaluate the mutual informa-
tion update criterion in Sec. 4.2 and the mutual informa-

tion based objective function for learning hash mappings
in Sec. 4.3. Our implementation is publicly available at
https://github.com/fcakir/mihash.

4.1. Datasets and Experimental Setup

CIFAR-10 is a widely-used dataset for image classiﬁca-
tion and retrieval, containing 60K images from 10 different
categories [7]. For feature representation, we use CNN fea-
tures extracted from the f c7 layer of a VGG-16 network
[21] pre-trained on ImageNet.

Places205 is a subset of the large-scale Places dataset
[32] for scene recognition. Places205 contains 2.5M im-
ages from 205 scene categories. This is a very challeng-
ing dataset due to its large size and number of categories,
and it has not been studied in the hashing literature to our
knowledge. We extract CNN features from the f c7 layer
of an AlexNet [8] pre-trained on ImageNet, and reduce the
dimensionality to 128 using PCA.

LabelMe. The 22K LabelMe dataset [19, 22] has 22,019
images represented as 512-dimensional GIST descriptors.
This is an unsupervised dataset without labels, and standard
practice uses the Euclidean distance to determine neighbor
relationships. Speciﬁcally, xi and xj are considered neigh-
bor pairs if their Euclidean distance is within the smallest
5% in the training set. For a query, the closest 5% examples
are considered true neighbors.

All datasets are randomly split into a retrieval set and a
test set, and a subset from the retrieval set is used for learn-
ing hash functions. Speciﬁcally, for CIFAR-10, the test set
has 1K images and the retrieval set has 59K. A random sub-
set of 20K images from the retrieval set is used for learning,
and the size of the reservoir is set to 1K. For Places205, we
sample 20 images from each class to construct a test set of
4.1K images, and use the rest as the retrieval set. A random
subset of 100K images is used to for learning, and the reser-
voir size is 5K. For LabelMe, the dataset is split into re-
trieval and test sets with 20K and 2K samples, respectively.
Similar to CIFAR-10, we use a reservoir of size 1K.

Figure 4: Retrieval mAP vs. number of processed training examples for four hashing methods on the three datasets, with
and without Trigger Update (TU). We use default threshold θ = 0 for TU. Circles indicate hash table updates, and the ratio
of reduction in the number of updates is shown in the titles. TU substantially reduces the number of updates while having
a stabilizing effect on the retrieval performance. Note: since OSH [2] assumes supervision in terms of class labels, it is not
applicable to the unsupervised LabelMe dataset.

For online hashing experiments, we run three random-
ized trials for each experiment and report averaged results.
To evaluate retrieval performances, we adopt the widely-
used mean Average Precision (mAP). Due to the large size
of Places205, mAP is very time-consuming to compute,
and we compute mAP on the top 1000 retrieved examples
(mAP@1000), as done in [15].

4.2. Evaluation: Update Criterion

We evaluate our mutual information based update crite-
rion, the Trigger Update module (TU). We apply TU to all
existing online hashing methods known to us: Online Ker-
nel Hashing (OKH) [6], Online Supervised Hashing (OSH)
[2], Adaptive Hashing (AdaptHash) [1] and Online Sketch-
ing Hashing (SketchHash) [11]. We use publicly available
implementations of all methods. The hash code length is
ﬁxed at 32 bits.

As our work is the ﬁrst in addressing the hash table up-
date criterion for online hashing, we compare to a data-
agnostic baseline, which updates the hash table at a ﬁxed
rate. The rate is controlled by a parameter U , referred to

as the “update interval”: after processing every U exam-
ples, the baseline unconditionally triggers an update, while
TU makes a decision using the mutual information criterion.
For each dataset, U is set such that the baseline updates 201
times in total. This ensures that the baseline is never too
outdated, but updates are still fairly infrequent: in all cases,
the smallest U is 100.

Results for the Trigger Update module. Fig. 4 de-
picts the retrieval mAP over time for all four online hash-
ing methods considered, on three datasets, with and without
incorporating TU. We can clearly observe a signiﬁcant re-
duction in the number of hash table updates, between one
and two orders of magnitude in all cases. For example, the
number of hash table updates is reduced by a factor of 67
for the OKH method on LabelMe.

The quality-based update criterion is particularly im-
portant for hashing methods that may yield inferior hash
mappings due to noisy data and/or imperfect learning tech-
niques. In other words, TU can be used to ﬁlter updates to
the hash mapping with negative or small improvement. This
has a stabilizing effect on the mAP curve, notably for OKH

Figure 5: Online hashing performance comparison on three datasets, where all methods use the Trigger Update module (TU)
with default threshold θ = 0. MIHash clearly outperforms other competing methods. OSH, AdaptHash, and SketchHash
perform very similarly on Places205, thus their curves overlap.

and AdaptHash. For OSH, which appears to stably improve
over time, TU nevertheless signiﬁcantly reduces revisits to
the hash table while maintaining its performance.

All results in Fig. 4 are obtained using the default thresh-
old parameter θ = 0, deﬁned in Eq. 5. We do not tune θ in
order to show general applicability. We also discuss the im-
pact of the reservoir set R. There is a trade-off regarding
the size of R: a larger R leads to better approximation but
increases the overhead. Nevertheless, we observed robust
and consistent results with |R| not exceeding 5% of the size
of the training stream.

4.3. Evaluation: Learning Objective

We evaluate the mutual information based hashing ob-
jective. We name our method MIHash, and train it using
stochastic gradient descent (SGD). This allows it to be ap-
plied to both the online setting and batch setting in learning
hash functions.

(cid:23)

During minibatch-based SGD, to compute the mutual in-
formation objective in Eq. 7 and its gradients, we need ac-
ˆx for each considered ˆx, in order to
ˆx,
cess to the sets
(cid:22)
estimate p+
D and p−
D. For the online setting in Sec. 4.3.1,
a standalone reservoir set R is assumed as in the previous
experiment, and we partition R into {
ˆx} with respect
to each incoming ˆx. In this case, even a batch size of 1 can
be used. For the batch setting in Sec. 4.3.2, {
ˆx} are
deﬁned within the same minibatch as ˆx.

ˆx,

ˆx,

(cid:23)

(cid:22)

(cid:22)

(cid:23)

4.3.1 Online Setting

We ﬁrst consider an online setting that is the same as in
Sec. 4.2. We compare against other online hashing meth-
ods: OKH, OSH, AdaptHash and SketchHash. All methods
are equipped with the TU module with the default threshold
θ = 0, which has been demonstrated to work well.

Results for Online Setting. We ﬁrst show the mAP
curve comparisons in Fig. 5. For competing online hash-
ing methods, the curves are the same as the ones with
TU in Fig. 4, and we remove markers to avoid clutter.
MIHash clearly outperforms other online hashing methods

on all three datasets, and shows potential for further im-
provement with more training data. The combination of TU
and MIHash gives a complete online hashing system that
enjoys a superior learning objective with a plug-in update
criterion that improves efﬁciency.

D and p−

We next give insights into the distribution-separating ef-
fect from optimizing mutual information. In Fig. 6, we plot
the conditional distributions p+
D averaged on the
CIFAR-10 test set, before and after learning MIHash with
the 20K training examples. Before learning, with a ran-
domly initialized hash mapping, p+
D exhibit high
overlap. After learning, MIHash achieves good separation
between p+
D: the overlap reduces signiﬁcantly, and
the mass of p+
D is pushed towards 0. This separation is re-
ﬂected in the large improvement in mAP (0.68 vs. 0.22).

D and p−

D and p−

In contrast with the other methods, the mutual informa-
tion formulation is parameter-free. For instance, there is no
threshold parameter that requires separating p+
D at
a certain distance value. Likewise, there is no margin pa-
rameter that dictates the amount of separation in absolute
terms. Such parameters usually need to be tuned to ﬁt to
data, whereas the optimization of mutual information is au-
tomatically guided by the data itself.

D and p−

4.3.2 Batch Setting

To further demonstrate the potential of MIHash, we con-
sider the batch learning setting, where the entire training
set is available at once. We compare against state-of-the-
art batch formulations, including: Supervised Hashing with
Kernels (SHK) [16], Fast Supervised Hashing with Deci-
sion Trees (FastHash) [14], Supervised Discrete Hashing
(SDH) [20], Efﬁcient Training of Very Deep Neural Net-
works (VDSH) [30], Deep Supervised Hashing with Pair-
wise Labels (DPSH) [12] and Deep Supervised Hashing
with Triplet Labels (DTSH) [27]. These competing meth-
ods have shown to outperform earlier and other work such
as [5, 9, 18, 28, 10, 31]. We focus on comparisons on the
CIFAR-10 dataset, which is the canonical benchmark for
supervised hashing. Similar to [27], we consider two exper-

1

g
n
i
t
t
e
S

Method
SHK
SDH
VDSH
DPSH
DTSH
FastHash
MIHash1
MIHash
Method
DPSH2
DTSH2
DPSH
DTSH
MIHash

Code Length
32
24
0.645
0.615
0.589
0.576
0.537
0.546
0.538
0.518
0.689
0.659
0.724
0.700
0.597
0.563
0.727
0.720
32
24
0.795
0.781
0.925
0.923
0.917
0.909
0.927
0.924
0.933
0.938
1 Results after a single training epoch.
2 Results as reported in DPSH [12] and DTSH [27].

12
0.497
0.521
0.523
0.420
0.617
0.632
0.524
0.683
16
0.763
0.915
0.908
0.916
0.929

2

g
n
i
t
t
e
S

48
0.682
0.592
0.554
0.553
0.702
0.738
0.609
0.746
48
0.807
0.926
0.932
0.934
0.942

Table 1: Comparison against state-of-the-art hashing meth-
ods on CIFAR-10. We report mean Average Precision
(mAP) on the test set, with best results in bold. See text
for the details of the two experimental settings.

can learn non-linear hash functions: for instance, the closest
competitor, FastHash, is a two-step hashing method based
on sophisticated binary code inference and boosted trees.

In Setting 2, with end-to-end ﬁnetuning, MIHash signif-
icantly outperforms DPSH and DTSH, the two most com-
petitive deep hashing methods, and sets the current state-
of-the-art for CIFAR-10. Again, note that MIHash has no
tuning parameters in its objective function. In contrast, both
DPSH and DTSH have parameters to control the quantiza-
tion strength that need to be tuned.

5. Conclusion

We advance the state-of-the-art for online hashing in two
aspects. In order to resolve the issue of hash table updates
in online hashing, we deﬁne a quality measure using the
mutual information between variables induced by the hash
mapping. This measure is efﬁciently computable, corre-
lates well with standard evaluation metrics, and leads to
consistent computational savings for existing online hash-
ing methods while maintaining their retrieval accuracy. In-
spired by these strong results, we further propose a hashing
method MIHash, by optimizing mutual information as an
objective with stochastic gradient descent. In both online
and batch settings, MIHash achieves superior performance
compared to state-of-the-art hashing techniques.

Acknowledgements

This research was supported in part by a BU IGNITION

award, US NSF grant 1029430, and gifts from NVIDIA.

D and p−

Figure 6: We plot the distributions p+
D, aver-
aged on the CIFAR-10 test set, before and after learning
MIHash with 20K training examples. Optimizing the mu-
tual information objective substantially reduces the overlap
between them, resulting in state-of-the-art mAP for the on-
line setting, as shown in Fig. 5.

imental settings, which we detail below.

Setting 1: 5K training examples are sampled for learn-
ing hash mappings, and 1K examples are used as the test
set. All methods learn shallow models on top of fc7 fea-
tures from a VGG-16 network [21] pretrained on Ima-
geNet. For three gradient-based methods (DPSH, DTSH,
and MIHash), this means learning linear hash functions.
Note that VDSH uses customized architectures consisting
of only fully-connected layers, and it is unclear how to adapt
it to use standard architectures; we used its full model with
16 layers and 1024 nodes per layer.

Setting 2: We use the full training set of size 50K and
test set of size 10K. We focus on comparing the end-to-end
performance of MIHash against two recent leading meth-
ods: DPSH and DTSH, using the same VGG-F network
architecture [3] that they are trained on. We use pub-
licly available implementations for the compared methods,
and exhaustively search parameter settings for them. For
MIHash, the minibatch size is set to 100 and 250 in Settings
1 and 2, respectively. We use SGD with momentum, and
decrease the learning rate when the training loss saturates.
See supplementary material for more details.

Results for Batch Setting.

In Table 1, we list batch
learning results for all methods. In Setting 1, MIHash out-
performs all competing methods in terms of mAP, in some
cases with only a single training epoch (e.g. against VDSH,
DPSH). This suggests that mutual information is a more ef-
fective learning objective for hashing. MIHash learns a lin-
ear layer on the input features, while some other methods

[18] M. Norouzi and D. J. Fleet. Minimal loss hashing for com-
pact binary codes. In Proc. International Conf. on Machine
Learning (ICML), 2011.

[19] B. C. Russell, A. Torralba, K. P. Murphy, and W. T. Freeman.
Labelme: a database and web-based tool for image annota-
tion. International journal of computer vision, 2008.
[20] F. Shen, C. S. Wei, L. Heng, and T. Shen. Supervised dis-
crete hashing. In Proc. IEEE Conf. on Computer Vision and
Pattern Recognition (CVPR), 2015.

[21] K. Simonyan and A. Zisserman. Very deep convolutional
networks for large-scale image recognition. ICLR, 2015.
[22] A. Torralba, R. Fergus, and Y. Weiss. Small codes and large
In Proc. IEEE Conf. on
image databases for recognition.
Computer Vision and Pattern Recognition (CVPR). IEEE,
2008.

[23] E. Ustinova and V. Lempitsky. Learning deep embeddings
with histogram loss. In Proc. Advances in Neural Informa-
tion Processing Systems (NIPS), pages 4170–4178, 2016.
[24] J. S. Vitter. Random sampling with a reservoir. ACM
Transactions on Mathematical Software (TOMS), 11(1):37–
57, 1985.

[25] J. Wang, H. T. Shen, J. Song, and J. Ji. Hashing for similarity

search: A survey. CoRR.

[26] Q. Wang, Z. Zhang, and L. Si. Ranking preserving hashing
for fast similarity search. In Proc. International Joint Conf.
on Artiﬁcial Intelligence (IJCAI), 2015.

[27] Y. Wang, Xiaofang Shi and K. M. Kitani. Deep supervised
hashing with triplet labels. In Proc. Asian Conf. on Computer
Vision (ACCV), 2016.

[28] R. Xia, Y. Pan, H. Lai, C. Liu, and S. Yan. Supervised hash-
ing for image retrieval via image representation learning. In
Proc. AAAI Conf. on Artiﬁcial Intelligence (AAAI), volume 1,
page 2, 2014.

[29] Y. Yue, T. Finley, F. Radlinski, and T. Joachims. A support
In Proc.
vector method for optimizing average precision.
ACM Conf. on Research & Development in Information Re-
trieval (SIGIR), pages 271–278. ACM, 2007.

[30] Z. Zhang, Y. Chen, and V. Saligrama. Efﬁcient training of
very deep neural networks for supervised hashing. In Proc.
IEEE Conf. on Computer Vision and Pattern Recognition
(CVPR), 2016.

[31] F. Zhao, Y. Huang, L. Wang, and T. Tan. Deep semantic
ranking based hashing for multi-label image retrieval.
In
Proc. IEEE Conf. on Computer Vision and Pattern Recog-
nition (CVPR), 2015.

[32] B. Zhou, A. Lapedriza, J. Xiao, A. Torralba, and A. Oliva.
Learning deep features for scene recognition using places
database. In Proc. Advances in Neural Information Process-
ing Systems (NIPS), 2014.

References

[1] F. Cakir and S. Sclaroff. Adaptive hashing for fast similar-
ity search. In Proc. IEEE International Conf. on Computer
Vision (ICCV), 2015.

[2] F. Cakir and S. Sclaroff. Online supervised hashing. In Proc.
IEEE International Conf. on Image Processing (ICIP), 2015.
[3] K. Chatﬁeld, K. Simonyan, A. Vedaldi, and A. Zisserman.
Return of the devil in the details: Delving deep into convolu-
tional nets. In British Machine Vision Conference (BMVC),
2014.

[4] A. Gionis, P. Indyk, and R. Motwani. Similarity search in
In Proc. International Conf.

high dimensions via hashing.
on Very Large Data Bases (VLDB), 1999.

[5] Y. Gong and S. Lazebnik.

Iterative quantization: A pro-
crustean approach to learning binary codes. In Proc. IEEE
Conf. on Computer Vision and Pattern Recognition (CVPR),
2011.

[6] L.-K. Huang, Q. Y. Yang, and W.-S. Zheng. Online hashing.
In Proc. International Joint Conf. on Artiﬁcial Intelligence
(IJCAI), 2013.

[7] A. Krizhevsky and G. Hinton. Learning multiple layers of

features from tiny images, 2009.

[8] A. Krizhevsky, I. Sutskever, and G. E. Hinton.

Imagenet
classiﬁcation with deep convolutional neural networks.
In
Proc. Advances in Neural Information Processing Systems
(NIPS), 2012.

[9] B. Kulis and T. Darrell. Learning to hash with binary recon-
structive embeddings. In Proc. Advances in Neural Informa-
tion Processing Systems (NIPS), 2009.

[10] H. Lai, Y. Pan, Y. Liu, and S. Yan. Simultaneous feature
learning and hash coding with deep neural networks.
In
Proc. IEEE Conf. on Computer Vision and Pattern Recog-
nition (CVPR), 2015.

[11] C. Leng, J. Wu, J. Cheng, X. Bai, and H. Lu. Online sketch-
ing hashing. In Proc. IEEE Conf. on Computer Vision and
Pattern Recognition (CVPR), 2015.

[12] W.-J. Li, S. Wang, and W.-C. Kang. Feature learning based
deep supervised hashing with pairwise labels. In Proc. Inter-
national Joint Conf. on Artiﬁcial Intelligence (IJCAI), 2016.
[13] G. Lin, F. Liu, C. Shen, J. Wu, and H. T. Shen. Structured
learning of binary codes with column generation for optimiz-
International Journal of Computer
ing ranking measures.
Vision (IJCV), pages 1–22, 2016.

[14] G. Lin, C. Shen, Q. Shi, A. van den Hengel, and D. Suter.
Fast supervised hashing with decision trees for high-
dimensional data. In Proc. IEEE Conf. on Computer Vision
and Pattern Recognition (CVPR), 2014.

[15] K. Lin, J. Lu, C.-S. Chen, and J. Zhou. Learning compact
binary descriptors with unsupervised deep neural networks.
In Proc. IEEE Conf. on Computer Vision and Pattern Recog-
nition (CVPR), 2016.

[16] J. W. Liu, Wei and, R. Ji, Y.-G. Jiang, and S.-F. Chang. Su-
pervised hashing with kernels. In Proc. IEEE Conf. on Com-
puter Vision and Pattern Recognition (CVPR), 2012.
[17] C. D. Manning, P. Raghavan, and H. Sch¨utze. Introduction

to information retrieval. 2008.

Appendix

A. Implementation Details of MIHash

We discuss the implementation details of MIHash.
In
the online hashing experiments, for simplicity we model
MIHash using linear hash functions, in the form of φi(x) =
sgn(w(cid:62)
i x) ∈ {−1, +1}, i = 1, . . . , b. The learning capac-
ity of such a model is lower than the kernel-based OKH, and
is the same as OSH, AdaptHash, and SketchHash, which
use linear hash functions as well.

For the batch hashing experiments, as mentioned in the
paper, we similarly model MIHash using linear hash func-
tions in the ﬁrst setting, but perform end-to-end learning
with the VGG-F network in the second setting.
In this
case, the hash functions become φi(x) = sgn(fi(x; w)) ∈
{−1, +1}, i = 1, . . . , b, where fi are the logits produced by
the previous layer in the network.

We train MIHash using stochastic gradient descent. In
Eq. 11 in the paper, we gave the gradients of the mutual in-
formation objective I with respect to the outputs of the hash
mapping, Φ(x). Both I and ∂I/∂Φ(x) are parameter-free.
In order to further back-propagate gradients to the inputs of
Φ(x) and model parameters {wi}, we approximate the sgn
function using the sigmoid function σ:

φi(x) ≈ 2σ(Aw(cid:62)

i x) − 1,

(18)

where A > 1 is a scaling parameter, used to increase the
“sharpness” of the approximation. We ﬁnd A from the set
{10, 20, 30, 40, 50} in our experiments.

We note that A is not a tuning parameter of the mutual
information objective, but rather a parameter of the under-
lying hash functions. The design of the hash functions is
not coupled with the mutual information objective, thus can
be separated. It will be an interesting topic to explore other
methods of constructing hash functions, potentially in ways
that are free of tuning parameters.

B. Experimental Details

B.1. The streaming scenario

We set up a streaming scenario in our online hashing ex-
periments. We run three randomized trials for each experi-
ment. In each trial, we ﬁrst randomly split the dataset into
a retrieval set and a test set as described in Sec. 4.1 in the
paper, and randomly sample the training subset from the re-
trieval set. The ordering of the training set is also randomly
permuted. The random seeds are ﬁxed, so the baselines and
methods with the Trigger Update module observe the same
training sequences.

In a streaming setting, we also measure the cumulative
retrieval performance during online hashing, as opposed to
only the ﬁnal results. To mimic real retrieval systems where

queries arrive randomly, we set 50 randomized checkpoints
during the online process. We ﬁrst place the checkpoints
with equal spacing, then add small random perturbations
to their locations. We measure the instantaneous retrieval
mAP at these checkpoints to get mAP vs. time curves (e.g.
curves shown in Fig. 5 in the paper), and compute the area
under curve (AUC). AUC gives a summary of the entire on-
line learning process, which cannot be reﬂected by the ﬁnal
performance at the end.

B.2. Parameters for online hashing methods

We describe parameters used for online hashing methods
in the online experiments. Some of the competing methods
require parameter tuning, therefore we sample a validation
set from the training data and ﬁnd the best performing pa-
rameters for each method. The size of the validation sets are
2K, 2K and 10K for CIFAR-10, LabelMe and Places205,
respectively. Please refer to the respective papers for the
descriptions of the parameters.

• OSH: η is set to 0.1 for all datasets. The ECOC code-

book C is populated the same way as in OSH.

• AdaptHash:

to
tuple
(0.9, 0.01, 0.1), (0.1, 0.01, 0.001) and (0.9, 0.01, 0.1)
for CIFAR-10, LabelMe and Places205, respectively.

(α, λ, η)

the

set

is

• OKH:

the tuple (C, α)

to (0.001, 0.3),
(0.001, 0.3) and (0.0001, 0.7) for CIFAR-10, LabelMe
and Places205, respectively.

set

is

• SketchHash: the pair (sketch size, batch size) is set to
(200, 50), (100, 50) and (100, 50) for CIFAR-10, La-
belMe and Places205, respectively.

B.3. Parameters for batch hashing methods

We use the publicly available implementations for the
compared methods, and exhaustively search parameter set-
tings, including the default parameters as provided by the
authors. For DPSH and DTSH we found a combination that
worked well for the ﬁrst setting: the mini-batch size is set to
the default value of 128, and the learning rate is initialized
to 1 and decayed by a factor of 0.9 after every 20 epochs.
Additionally, for DTSH, the margin parameter is set to b/4
where b is the hash code length. VDSH uses a heavily cus-
tomized architecture with only fully-connected layers, and
it is unclear how to adapt it to work with standard CNN ar-
chitectures. In this sense, VDSH is more akin to nonlinear
hashing methods such as FastHash and SHK. We used the
full VDSH model with 16 layers and 1024 nodes per layer,
and found the default parameters to perform the best, ex-
cept that we increased the number of training iterations by
an order of magnitude during ﬁnetuning.

For MIHash, in the ﬁrst setting we use a batch size of
100, and run SGD with initial learning rate of 0.1 and a

Method

Training Time (s)

Training Time (s)

OKH
OKH + TU
OSH
OSH + TU
AdaptHash
AdaptHash + TU
SketchHash
SketchHash + TU

10.8
23.6
97.6
175.8
47.8
94.8
68.8
80.0

Method

SHK
SDH
FastHash
VDSH*
DPSH
DTSH
MIHash, 1ep
MIHash

mAP

0.682
0.592
0.738
0.554
0.553
0.702
0.609
0.746

180
4.8
140
206
450
1728
1.9
190

Table 2: Online hashing: running times on the CIFAR-10
20k training set, with 32-bit hash codes. For methods with
the TU plugin, the added time is due to maintaining the
reservoir set and computing the mutual information update
criterion, and is dominated by the maintaining of the reser-
voir set.

decay factor of 0.5 every 10 epochs, for 100 epochs. For
the second setting where we ﬁnetune the pretrained VGG-F
network, batch size is 250, learning rate is initially set to
0.001 and decayed by half every 50 epochs.

C. Running Time

C.1. Online Setting: Trigger Update Module

In Table 2 we report running time for all methods on
the CIFAR-10 dataset with 20k training examples, includ-
ing time spent in learning hash functions and the added pro-
cessing time for maintaining the reservoir set and comput-
ing TU. Numbers are recorded on a 2.3GHz Intel Xeon E5-
2650 CPU workstation with 128GB of DDR3 RAM. Most
of the added time is due to maintaining the reservoir set,
which is invoked in each training iteration; the mutual in-
formation update criterion is only checked after processing
every U = 100 examples. Methods with small batch sizes
(e.g. OSH, batch size 1) therefore incur more overhead than
methods with larger batches (e.g. SketchHash, batch size
50). Results for other datasets are similar.

We note that in a real retrieval system with large-scale
data, the bottleneck likely lies in recomputing the hash ta-
bles for indexed data, due to various factors such as schedul-
ing and disk I/O. We reduce this bottleneck signiﬁcantly by
using TU. Compared to this bottleneck, the increase in train-
ing time is not signiﬁcant.

C.2. Batch Setting

Table 3 reports CPU times for learning 48-bit hash map-
pings in the ﬁrst experimental setting on CIFAR-10 (5K
training set). Retrieval mAP are replicated from Table 1
in the paper. For learning a single layer, our Matlab im-
plementation of MIHash achieves 1.9 seconds per epoch
on CPU. MIHash achieves competitive performance with
a single epoch, and has a total training time on par with

Table 3: Batch hashing: test performance and training time
for 48-bit codes on the CIFAR-10, using the 5k training set.
*VDSH is trained with the full model as detailed in B.3.
1ep stands for training for one epoch only.

FastHash, while yielding superior performance.

D. Additional Experimental Results

D.1. Online Hashing: Other Code Lengths

In the online hashing experiments we reported in the pa-
per, all online hashing methods are compared in the same
setup with 32-bit hash codes. Additionally, we also present
results using 64-bit hash codes on all three datasets. The
parameters for all methods are found through validation as
described in B.2.

Similar to Sec 4.2 in the paper, we show the comparisons
with and without TU for existing online hashing methods in
Fig. 7, and plot the mAP curves for all methods, includ-
ing MIHash, in Fig. 8. The 64-bit results are uniformly
better than 32-bit results for all methods in terms of mAP,
but still follow the same patterns. Again, we can see that
MIHash clearly outperforms all competing online hashing
methods, and shows potential for improvement given more
training data.

D.2. Parameter Study: θ

We present a parameter study on the parameter θ, the im-
provement threshold on the mutual information criterion in
TU. In our previous experiments, we found the default θ = 0
to work well, and did not speciﬁcally tune θ. However, tun-
ing for a larger θ could lead to better trade-offs, since small
improvements in the quality of the hash mapping may not
justify the cost of a full hash table update.

For this study, we vary parameter θ from −∞ to ∞ for
all methods (with 32-bit hash codes). θ = −∞ reduces to
the baseline. On the other hand, θ = ∞ prevents any up-
dates to the initial hash mapping and hash table, and results
in only one hash table update (for the initial mapping) and
typically low performance. The performance metric we fo-
cus on in this study is the cumulative metric, AUC, since
it better summarizes the entire online learning process than
the ﬁnal performance alone.

Figure 7: 64-bit experiments: Retrieval mAP vs. number of training examples for four existing online hashing methods on
the three datasets, with and without Trigger Update (TU). We use default threshold θ = 0 for TU. Circles indicate hash table
updates, and the ratio of reduction in the number of updates is marked for each graph. TU substantially reduces the number
of updates while having a stabilizing effect on the retrieval performance. Note: since the OSH method assumes supervision
in terms of class labels, it is not applicable to the unsupervised LabelMe dataset.

Figure 8: 64-bit experiments: Online hashing performance (mAP) comparison on three datasets, where all methods use
the Trigger Update module (TU) with θ = 0. Using the mutual information objective, MIHash clearly outperforms other
methods. OKH, AdaptHash, ad SketchHash perform very similarly on CIFAR-10. OSH, AdaptHash, ad SketchHash perform
very similarly on Places205. Again, the OSH method is not applicable to the unsupervised LabelMe dataset.

We use a custom update schedule for SketchHash: we
enforce hash table updates in the early iterations regard-
less of other criteria, until the number of observed exam-
ples reaches the speciﬁed size of the “data sketch”, which
SketchHash uses to perform a batch hashing algorithm.
This was observed to be critical for the performance of
SketchHash. Therefore, the number of hash table updates
for SketchHash can be greater than 1 even for θ = ∞.

We present full results in Tables 4, 5, 6. In all cases, we
observe a substantial decrease in the number of hash table
updates as θ increases. With reasonable θ values (typically
around 0), the number of hash table updates can be reduced
by over an order of magnitude with no loss in AUC. Note
that the computation-performance trade-off achieved by the
default θ = 0 is always among the best, thereby in practice
it can be used without tuning.

D.3. Parameter Study: U

We simulate a data-agnostic baseline that updates hash
tables at a constant rate, using the update interval param-
eter U .
In the paper, U is set such that the baseline up-
dates a total of 201 times for all datasets. This ensures that
the baseline is never too outdated (compared to 50 check-
points at which performance is evaluated), but is still fairly
infrequent: the smallest U in this case is 100, which means
the baselines process at least 100 training examples before
recomputing the hash table. For completeness, here we
present the results using different values of U , where all
methods again use 32-bit hash codes and the default θ = 0.
We used a simple rule that avoids unnecessary hash table
updates if the hash mapping itself does not change. Specif-
ically, we do not update if (cid:107)Φt − Φs(cid:107) < 10−6, where Φs
is the current snapshot and Φt is the new candidate. Some
baseline entries have fewer updates because of this rule (e.g.
AdaptHash on Places205). And as explained before, due to
the custom update schedule, SketchHash may have more
hash table updates than what is suggested by U .

Please see Tables 7, 8, 9 for the full results. In all experi-
ments, we run three random trials and average the results as
mentioned before, and the standard deviation of mAP and
AUC scores are less than 0.01. Generally, using smaller
U leads to more updates by both the baselines and methods
with TU; recall that U is also a parameter of TU which spec-
iﬁes the frequency of checking the update criterion. How-
ever, methods with the TU module appear to be quite in-
sensitive to the choice of U , e.g. the number of updates
for SketchHash with TU on CIFAR-10 only increases by 2x
while U is reduced by 20x, from 1000 to 50. We attribute
this to the ability of TU to ﬁlter out unnecessary updates.
Across different values of U , TU consistently brings compu-
tational savings while preserving/improving online hashing
performance, as indicated by ﬁnal mAP and AUC.

CIFAR-10, 32 bits
HT Updates
201
190 (5.8x)
8.0 (25.1x)
8.0 (25.1x)
7.7 (26.1x)
3.3 (91.2x)
1.0 (201x)
HT Updates
201
39.0 (5.2x)
36.7 (5.5x)
35.7 (5.6x)
6.7 (30x)
2.0 (100x)
1.0 (201x)
AdaptHash HT Updates

OKH
≤ −0.1
−0.01
−10−4
0
10−4
0.01
≥ 0.2
OSH
≤ −0.01
−10−4
0
10−4
0.01
0.1
≥ 0.3

≤ −0.1
−0.01
−10−4
0
10−4
0.01
≥ 0.1

201
68.3 (2.9x)
10.3 (19.5x)
10.0 (20.1x)
10.0 (20.1x)
3.3 (60.9x)
1.0 (201x)
SketchHash HT updates

≤ −0.01
−10−4
−10−6
0
10−4
0.01
≥ 0.1

201
9.0 (22.3x)
7.3 (27.5x)
7.3 (27.5x)
7.3 (27.5x)
4.3 (46.7x)
4.0 (50.3x)

–

–

AUC ∆AUC
0.259
0.260 +0.4%
0.287 +10.8%
0.287 +10.8%
0.287 +10.8%
+8.1%
0.280
0.134 −48.3%
AUC ∆AUC
0.463
0.466 +0.6%
0.466 +0.6%
0.466 +0.6%
0.453 −2.1%
−16%
0.386
−55%
0.207
AUC ∆AUC
0.218
0.238 +9.2%
0.250 +14.7%
0.250 +14.7%
0.250 +14.7%
0.244 +11.9%
0.211 −3.3%
AUC ∆AUC
0.304
0.318 +4.6%
0.319 +4.9%
0.319 +4.9%
0.319 +4.9%
0.318 +4.6%
0.314 +3.3%

–

–

Table 4: Parameter study on the threshold value θ for on-
line hashing methods on CIFAR-10 (32 bits). We report
the number of hash table updates, where 100x indicates a
100 times reduction with respect to the baseline. We also
report the area under the mAP curve (AUC) and compare to
baseline.

OKH
≤ −0.01
−10−4
−10−6
0
10−6
10−4
0.01
≥ 0.1
OSH
≤ −0.001
−20−4
−10−4
0
10−4
10−3
≥ 0.1

Places205, 32 bits
HT Updates
201
8.3 (24.2x)
7.0 (28.7x)
7.0 (28.7x)
7.0 (28.7x)
5.7 (35.3x)
2.0 (100x)
1.0 (201x)
HT Updates
201
101 (2.0x)
9.3 (21.6x)
7.0 (28.7x)
5.7 (35.3x)
2.7 (74.4x)
1.0 (201x)
AdaptHash HT Updates
≤ −0.01
−10−4
−10−6
0
10−6
10−4
≥ 0.01

199.7
199 (1.0x)
9.7 (20.6x)
8.7 (23.0x)
8.7 (23.0x)
3.0 (66.6x)
1.0 (201x)
SketchHash HT Updates

≤ −0.01
−10−4
−10−6
0
10−6
10−4
≥ 0.01

201
52.3 (3.8x)
15.3 (12.6x)
12.7 (15.8x)
15.3 (13.1x)
7.0 (28.7x)
2.0 (101x)

–

–
0%

AUC ∆AUC
0.163
0.161 −1.2%
0.161 −1.2%
0.161 −1.2%
0.161 −1.2%
0.161 −1.2%
−25%
0.123
−91%
0.014
AUC ∆AUC
0.246
0.246
0.236 −4.1%
0.236 −4.1%
0.230 −6.5%
0.224 −8.9%
0.226 −8.1%
AUC ∆AUC
0.237
0.237
0.236 −0.4%
0.236 −0.4%
0.235 −0.8%
0.235 −0.8%
0.227 −3.4%
AUC ∆AUC
0.237
0.238 +0.4%
0.238 +0.4%
0.236 −0.4%
0.238 +0.4%
0.239 +0.8%
0.223 −5.9%

–
0%

–

LabelMe, 32 bits
HT Updates
201
196 (1.0x)
2.7 (74.4x)
2.3 (87.4x)
2.3 (87.4x)
2.3 (87.4x)
2.0 (101x)
1.0 (201x)
AdaptHash HT Updates

OKH
≤ −0.2
−0.1
−0.01
−10−6
0
10−6
0.01
≥ 0.6

≤ −0.1
−10−6
−10−4
−10−2
0
10−6
10−4
10−2
≥ 0.1

≤ −0.1
−10−2
−10−4
0
10−4
10−2
≥ 0.1

201
149 (1.3x)
9.3 (21.6x)
8.7 (23.1x)
5.3 (37.9x)
8.7 (23.1x)
8.3 (24.2x)
2.7 (74.4x)
1 (201x)

201
195 (1.0x)
9.3 (21.6x)
8.7 (23.1x)
10 (20.1x)
4.7 (42.8x)
4.0 (50.3x)

SketchHash HT Updates

–

–

AUC ∆AUC
0.198
0.199 +0.5%
+88%
0.373
+89%
0.374
+89%
0.374
+89%
0.374
+88%
0.372
−44%
0.111
AUC ∆AUC
0.333
0.330 −0.9%
0.365 +9.6%
0.365 +9.6%
+11%
0.369
0.365 +9.6%
0.358 +7.5%
0.351 +5.4%
−11%
0.296
AUC ∆AUC
0.446
0.446
0.460 +3.1%
0.460 +3.1%
0.459 +2.9%
0.446
0.439 −1.6%

–
0%

0%

Table 5: Parameter study on the threshold value θ for on-
line hashing methods on Places205 (32 bits). We report the
number of hash table updates, where 100x indicates a 100
times reduction with respect to the baseline. We also re-
port the area under the mAP curve (AUC) and compare to
baseline.

Table 6: Parameter study on the threshold value θ for online
hashing methods on LabelMe (32 bits). We report the num-
ber of hash table updates, where 100x indicates a 100 times
reduction with respect to the baseline. We also report the
area under the mAP curve (AUC) and compare to baseline.
Note: OSH is not applicable to this unlabeled dataset since
it needs supervision in terms of class labels.

CIFAR-10, 32 bits

Final mAP AUC (mAP)

Method

OKH, U = 10

OKH, U = 100

OKH, U = 1000

OSH, U = 10

OSH, U = 100

OSH, U = 1000

AdaptHash, U = 10

AdaptHash, U = 100

AdaptHash, U = 1000

SketchHash, U = 50

SketchHash, U = 100

SketchHash, U = 1000

1870

201
8 (25.1x)
21
2.6 (8x)
2001
110.7 (18x)
201
36.7 (5.4x)
21
11.3 (1.9x)
2001

TU HT Updates
×
(cid:88) 15.6 (119.3x)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88) 19.6 (101.7x)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)

201
10.0 (10.1x)
21
5 (4.2x)
400
9 (44.4x)
202
7.3 (27.5x)
24
4.6 (5.2x)

0.238
0.297
0.238
0.291
0.238
0.282
0.480
0.483
0.480
0.483
0.480
0.479
0.244
0.267
0.244
0.255
0.244
0.252
0.306
0.318
0.306
0.320
0.306
0.317

0.259
0.293 (+13%)
0.259
0.287 (+10.8%)
0.255
0.273 (+7%)
0.463
0.466 (+0.6%)
0.463
0.466 (+0.6%)
0.454
0.454
0.224
0.261 (+16%)
0.224
0.250 (+11.6%)
0.222
0.234 (+5%)
0.303
0.318 (+5%)
0.304
0.319 (+4.9%)
0.305
0.314 (+2.9%)

Table 7: Online hashing results (32 bits) with different update interval parameters (U ) on the CIFAR-10 dataset. All results
are averaged from 3 random trials. For the number of hash table updates, we report the reduction ratio (e.g. 8x) for TU. For
AUC, we report the relative change compared to baseline. Note: SketchHash uses a batch size of 50, therefore the smallest
U is set to 50.

LabelMe, 32 bits

Final mAP AUC (mAP)

Method

OKH, U = 10

OKH, U = 100

OKH, U = 1000

AdaptHash, U = 10

AdaptHash, U = 100

AdaptHash, U = 1000

SketchHash, U = 50

SketchHash, U = 100

SketchHash, U = 1000

2001
8 (250x)
201
2.3 (86.2x)
21
2 (10.5x)
2001

TU HT Updates
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88) 12.6 (157.9x)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)

201
8.6 (23.1x)
21
5 (4.2x)
400
9.6 (41.6x)
202
8.67 (23.2x)
24
8.3 (2.8x)

0.119
0.382
0.119
0.380
0.119
0.373
0.318
0.380
0.318
0.379
0.318
0.343
0.445
0.461
0.445
0.462
0.445
0.456

0.200
0.377 (+88.5%)
0.200
0.374 (+87%)
0.193
0.357 (+85%)
0.319
0.371 (+16.3%)
0.318
0.365 (+14.7%)
0.317
0.337 (+6.3%)
0.447
0.460 (+2%)
0.446
0.460 (+3.1%)
0.445
0.455 (+2%)

Table 8: Online hashing results (32 bits) with different update interval parameters (U ) on the LabelMe dataset. All results
are averaged from 3 random trials. For the number of hash table updates, we report the reduction ratio (e.g. 8x) for TU. For
AUC, we report the relative change compared to baseline. Note: since LabelMe is an unsupervised dataset, the OSH method
is not applicable since it requires supervision in the form of class labels.

Places205, 32 bits

Final mAP AUC (mAP)

Method

OKH, U = 50

OKH, U = 500

OKH, U = 5000

OSH, U = 50

OSH, U = 500

OSH, U = 5000

AdaptHash, U = 50

AdaptHash, U = 500

AdaptHash, U = 5000

SketchHash, U = 50

SketchHash, U = 500

SketchHash, U = 5000

2001
8 (250.1x)
201
7 (28.7x)
21
2 (10.5x)
2001
25 (80x)
201
7 (28.7x)
21
2 (10.5x)
823.7
26.6 (30.8x)
200
8.6 (23.0x)
21
3 (7x)
2000

TU HT Updates
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88)
×
(cid:88) 19.3 (103.4x)
×
(cid:88)
×
(cid:88)

202
15.3 (13.1x)
22
6.6 (3.2x)

0.182
0.173
0.182
0.165
0.182
0.157
0.248
0.239
0.248
0.236
0.248
0.234
0.238
0.236
0.238
0.236
0.238
0.236
0.238
0.236
0.237
0.240
0.235
0.239

0.163
0.169 (+3.7%)
0.163
0.161 (-1.2%)
0.156
0.148 (-5.1%)
0.246
0.238 (-3%)
0.246
0.236 (-4.0%)
0.245
0.233 (-4%)
0.237
0.236 (-0.4%)
0.237
0.236 (-0.4%)
0.237
0.236 (-0.4%)
0.235
0.235 (0%)
0.235
0.238 (+1.2%)
0.235
0.238 (+1.2%)

Table 9: Online hashing results (32 bits) with different update interval parameters (U ) on the Places205 dataset. All results
are averaged from 3 random trials. For the number of hash table updates, we report the reduction ratio (e.g. 8x) for TU. For
and AUC, we report the relative change compared to baseline.

