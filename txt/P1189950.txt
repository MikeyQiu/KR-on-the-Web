Addressee and Response Selection in Multi-Party Conversations
with Speaker Interaction RNNs

Rui Zhang
Yale University
r.zhang@yale.edu

Honglak Lee
University of Michigan
honglak@eecs.umich.edu

Lazaros Polymenakos
IBM T. J. Watson Research Center
lcpolyme@us.ibm.com

Dragomir Radev
Yale University
dragomir.radev@yale.edu

7
1
0
2
 
v
o
N
 
8
2
 
 
]
L
C
.
s
c
[
 
 
2
v
5
0
0
4
0
.
9
0
7
1
:
v
i
X
r
a

Abstract

In this paper, we study the problem of addressee and re-
sponse selection in multi-party conversations. Understand-
ing multi-party conversations is challenging because of com-
plex speaker interactions: multiple speakers exchange mes-
sages with each other, playing different roles (sender, ad-
dressee, observer), and these roles vary across turns. To tackle
this challenge, we propose the Speaker Interaction Recur-
rent Neural Network (SI-RNN). Whereas the previous state-
of-the-art system updated speaker embeddings only for the
sender, SI-RNN uses a novel dialog encoder to update speaker
embeddings in a role-sensitive way. Additionally, unlike the
previous work that selected the addressee and response sep-
arately, SI-RNN selects them jointly by viewing the task as
a sequence prediction problem. Experimental results show
that SI-RNN signiﬁcantly improves the accuracy of addressee
and response selection, particularly in complex conversations
with many speakers and responses to distant messages many
turns in the past.

1

Introduction

Real-world conversations often involve more than two
speakers. In the Ubuntu Internet Relay Chat channel (IRC),
for example, one user can initiate a discussion about an
Ubuntu-related technical issue, and many other users can
work together to solve the problem. Dialogs can have com-
plex speaker interactions: at each turn, users play one of
three roles (sender, addressee, observer), and those roles
vary across turns.

In this paper, we study the problem of addressee and re-
sponse selection in multi-party conversations: given a re-
sponding speaker and a dialog context, the task is to select
an addressee and a response from a set of candidates for the
responding speaker. The task requires modeling multi-party
conversations and can be directly used to build retrieval-
based dialog systems (Lu and Li 2013; Hu et al. 2014;
Ji, Lu, and Li 2014; Wang et al. 2015).

The previous state-of-the-art DYNAMIC-RNN model
from Ouchi and Tsuboi (2016) maintains speaker em-
beddings to track each speaker status, which dynamically
changes across time steps. It then produces the context em-
bedding from the speaker embeddings and selects the ad-

Copyright © 2018, Association for the Advancement of Artiﬁcial
Intelligence (www.aaai.org). All rights reserved.

dressee and response based on embedding similarity. How-
ever, this model updates only the sender embedding, not the
embeddings of the addressee or observers, with the corre-
sponding utterance, and it selects the addressee and response
separately. In this way, it only models who says what and
fails to capture addressee information. Experimental results
show that the separate selection process often produces in-
consistent addressee-response pairs.

To solve these issues, we introduce the Speaker Inter-
action Recurrent Neural Network (SI-RNN). SI-RNN re-
designs the dialog encoder by updating speaker embed-
dings in a role-sensitive way. Speaker embeddings are up-
dated in different GRU-based units depending on their roles
(sender, addressee, observer). Furthermore, we note that the
addressee and response are mutually dependent and view
the task as a joint prediction problem. Therefore, SI-RNN
models the conditional probability (of addressee given the
response and vice versa) and selects the addressee and re-
sponse pair by maximizing the joint probability.

On a public standard benchmark data set, SI-RNN sig-
niﬁcantly improves the addressee and response selection
accuracy, particularly in complex conversations with many
speakers and responses to distant messages many turns in
the past. Our code and data set are available online.1

2 Related Work

We follow a data-driven approach to dialog systems. Singh
et al. (1999), Henderson, Lemon, and Georgila (2008), and
Young et al. (2013) optimize the dialog policy using Rein-
forcement Learning or the Partially Observable Markov De-
cision Process framework. In addition, Henderson, Thom-
son, and Williams (2014) propose to use a predeﬁned on-
tology as a logical representation for the information ex-
changed in the conversation. The dialog system can be di-
vided into different modules, such as Natural Language
Understanding (Yao et al. 2014; Mesnil et al. 2015), Dia-
log State Tracking (Henderson, Thomson, and Young 2014;
Williams, Raux, and Henderson 2016), and Natural Lan-
guage Generation (Wen et al. 2015). Furthermore, Wen et
al. (2016) and Bordes and Weston (2017) propose end-to-
end trainable goal-oriented dialog systems.

1The released code: https://github.com/ryanzhumich/sirnn

Recently, short text conversation has been popular. The
system receives a short dialog context and generates a re-
sponse using statistical machine translation or sequence-to-
sequence networks (Ritter, Cherry, and Dolan 2011; Vinyals
and Le 2015; Shang, Lu, and Li 2015; Serban et al. 2016;
Li et al. 2016; Mei, Bansal, and Walter 2017). In con-
trast to response generation, the retrieval-based approach
uses a ranking model
to select the highest scoring re-
sponse from candidates (Lu and Li 2013; Hu et al. 2014;
Ji, Lu, and Li 2014; Wang et al. 2015). However, these
models are single-turn responding machines and thus still
are limited to short contexts with only two speakers. As
for larger context, Lowe et al. (2015) propose the Next Ut-
terance Classiﬁcation (NUC) task for multi-turn two-party
dialogs. Ouchi and Tsuboi (2016) extend NUC to multi-
party conversations by integrating the addressee detection
problem. Since the data is text based, they use only tex-
tual information to predict addressees as opposed to re-
lying on acoustic signals or gaze information in multi-
modal dialog systems (Jovanovi´c, Akker, and Nijholt 2006;
op den Akker and Traum 2009).

Furthermore, several other papers are recently presented
focusing on modeling role-speciﬁc information given the di-
alogue contexts (Meng, Mou, and Jin 2017; Chi et al. 2017;
Chen et al. 2017). For example, Meng, Mou, and Jin (2017)
combine content and temporal information to predict the ut-
terance speaker. By contrast, our SIRNN explicitly utilizes
the speaker interaction to maintain speaker embeddings and
predicts the addressee and response by joint selection.

3 Preliminaries

3.1 Addressee and Response Selection
Ouchi and Tsuboi (2016) propose the addressee and re-
sponse selection task for multi-party conversation. Given a
responding speaker ares and a dialog context C, the task is
to select a response and an addressee. C is a list ordered by
time step:

C = [(a(t)

sender, a(t)
sender says u(t) to a(t)

addressee, u(t))]T

t=1

where a(t)
addressee at time step t, and T
is the total number of time steps before the response and
addressee selection. The set of speakers appearing in C is
denoted A(C). As for the output, the addressee is selected
from A(C), and the response is selected from a set of can-
didates R. Here, R contains the ground-truth response and
one or more false responses. We provide some examples in
Table 4 (Section 6).

3.2 DYNAMIC-RNN Model
In this section, we brieﬂy review the state-of-the-art
DYNAMIC-RNN model (Ouchi and Tsuboi 2016), which
our proposed model is based on. DYNAMIC-RNN solves the
task in two phases: 1) the dialog encoder maintains a set of
speaker embeddings to track each speaker status, which dy-
namically changes with time step t; 2) then DYNAMIC-RNN
produces the context embedding from the speaker embed-
dings and selects the addressee and response based on em-
bedding similarity among context, speaker, and utterance.

Input

Output

Data
Responding Speaker
Context
Candidate Responses
Addressee
Response
Sender ID at time t
Addressee ID at time t
Utterance at time t
Utterance embedding at time t
Speaker embedding of ai at time t

Notation
ares
C
R
a ∈ A(C)
r ∈ R
a(t)
sender
a(t)
addressee
u(t)
u(t)
a(t)
i

Table 1: Notations for the task and model.

Dialog Encoder. Figure 1 (Left) illustrates the dialog en-
coder in DYNAMIC-RNN on an example context. In this ex-
ample, a2 says u(1) to a1, then a1 says u(2) to a3, and ﬁnally
a3 says u(3) to a2. The context C will be:

C = [(a2, a1, u(1)), (a1, a3, u(2)), (a3, a2, u(3))]

(1)

with the set of speakers A(C) = {a1, a2, a3}.
For a speaker ai, the bold letter a(t)

i ∈ Rds denotes its
embedding at time step t. Speaker embeddings are initial-
ized as zero vectors and updated recurrently as hidden states
of GRUs (Cho et al. 2014; Chung et al. 2014). Speciﬁcally,
for each time step t with the sender asdr and the utterance
u(t), the sender embedding asdr is updated recurrently from
the utterance:

sdr = GRU(a(t−1)
a(t)

sdr

, u(t)),

where u(t) ∈ Rdu is the embedding for utterance u(t). Other
speaker embeddings are updated from u(t) = 0. The speaker
embeddings are updated until time step T .

Selection Model. To summarize the whole dialog context
C, the model applies element-wise max pooling over all the
speaker embeddings to get the context embedding hC:

hC =

max
ai=a1,...,a|A(C)|

a(T )
i ∈ Rds

(2)

The probability of an addressee and a response being the
ground truth is calculated based on embedding similarity. To
be speciﬁc, for addressee selection, the model compares the
candidate speaker ap, the dialog context C, and the respond-
ing speaker ares:

(3)

P(ap|C) = σ([ares; hC](cid:62)Waap)
where ares is the ﬁnal speaker embedding for the responding
speaker ares, ap is the ﬁnal speaker embedding for the can-
didate addressee ap, σ is the logistic sigmoid function, [ ; ]
is the row-wise concatenation operator, and Wa ∈ R2ds×ds
is a learnable parameter. Similarly, for response selection,
P(rq|C) = σ([ares; hC](cid:62)Wrrq)
(4)
where rq ∈ Rdu is the embedding for the candidate response
rq, and Wr ∈ R2ds×du is a learnable parameter.

Figure 1: Dialog encoders in DYNAMIC-RNN (Left) and SI-RNN (Right) for an example context at the top. Speaker embed-
dings are initialized as zero vectors and updated recurrently as hidden states along the time step. In SI-RNN, the same speaker
embedding is updated in different units depending on the role (IGRUS for sender, IGRUA for addressee, GRUO for observer).

The model is trained end-to-end to minimize a joint cross-
entropy loss for the addressee selection and the response se-
lection with equal weights. At test time, the addressee and
the response are separately selected to maximize the proba-
bility in Eq 3 and Eq 4.

4 Speaker Interaction RNN
While DYNAMIC-RNN can track the speaker status by cap-
turing who says what in multi-party conversation, there are
still some issues. First, at each time step, only the sender
embedding is updated from the utterance. Therefore, other
speakers are blind to what is being said, and the model
fails to capture addressee information. Second, while the ad-
dressee and response are mutually dependent, DYNAMIC-
RNN selects them independently. Consider a case where
the responding speaker is talking to two other speakers
in separate conversation threads. The choice of addressee
is likely to be either of the two speakers, but the choice
is much less ambiguous if the correct response is given,
and vice versa. DYNAMIC-RNN often produces inconsis-
tent addressee-response pairs due to the separate selection.
See Table 4 for examples.

In contrast to DYNAMIC-RNN, the dialog encoder in SI-
RNN updates embeddings for all the speakers besides the
sender at each time step. Speaker embeddings are updated
depending on their roles: the update of the sender is different
from the addressee, which is different from the observers.
Furthermore, the update of a speaker embedding is not only
from the utterance, but also from other speakers. These are
achieved by designing variations of GRUs for different roles.
Finally, SI-RNN selects the addressee and response jointly
by maximizing the joint probability.

4.1 Utterance Encoder
To encode an utterance u = (w1, w2, ..., wN ) of N words,
we use a RNN with Gated Recurrent Units (Cho et al. 2014;
Chung et al. 2014):

hj = GRU(hj−1, xj)

where xj is the word embedding for wj, and hj is the GRU
hidden state. h0 is initialized as a zero vector, and the utter-
ance embedding is the last hidden state, i.e. u = hN .

4.2 Dialog Encoder

Figure 1 (Right) shows how SI-RNN encodes the example in
Eq 1. Unlike DYNAMIC-RNN, SI-RNN updates all speaker
embeddings in a role-sensitive manner. For example, at the
ﬁrst time step when a2 says u(1) to a1, DYNAMIC-RNN
only updates a2 using u(1), while other speakers are updated
using 0. In contrast, SI-RNN updates each speaker status
with different units: IGRUS updates the sender embedding
a2 from the utterance embedding u(1) and the addressee em-
bedding a1; IGRUA updates the addressee embedding a1
from u(1) and a2; GRUO updates the observer embedding
a3 from u(1).

Algorithm 1 gives a formal deﬁnition of the dialog en-
coder in SI-RNN. The dialog encoder is a function that takes
as input a dialog context C (lines 1-5) and returns speaker
embeddings at the ﬁnal time step (lines 28-30). Speaker
embeddings are initialized as ds-dimensional zero vectors
(lines 6-9). Speaker embeddings are updated by iterating
over each line in the context (lines 10-27).

4.3 Role-Sensitive Update

this

subsection, we

how
detail
In
IGRUS/IGRUA/GRUO
embeddings
update
according to their roles at each time step (Algorithm 1 lines
19-26).

in
speaker

explain

As shown in Figure 2, IGRUS/IGRUA/GRUO are all
GRU-based units. IGRUS updates the sender embedding
from the previous sender embedding a(t−1)
, the previous
addressee embedding a(t−1)
, and the utterance embedding
u(t):

adr

sdr

a(t)
sdr ← IGRUS(a(t−1)

sdr

, a(t−1)
adr

, u(t))

Algorithm 1 Dialog Encoder in SI-RNN

t=1

addressee, u(t))]T

1: Input
2: Dialog context C with speakers A(C):
3: C = [(a(t)
sender, a(t)
4: A(C) = {a1, a2, . . . , a|A(C)|}
sender, a(t)
5: where a(t)
6: // Initialize speaker embeddings
7: for ai = a1, a2, . . . , a|A(C)| do
a(0)
i ← 0 ∈ Rds
8:
9: end for
10: //Update speaker embeddings
11: for t = 1, 2, . . . , T do
12:

addressee ∈ A(C)

13:

14:
15:
16:
17:

18:
19:

20:
21:

sender

// Update sender, addressee, observers
asdr ← a(t)
aadr ← a(t)
addressee
O ← A(C) − {asdr, aadr}
// Compute utterance embedding
u(t) ← UtteranceEncoder(u(t))
u(t) ← Concatenate(a(t−1)
// Update sender embedding
a(t)
, a(t−1)
sdr ← IGRUS(a(t−1)
adr
// Update addressee embedding
, a(t−1)
adr ← IGRUA(a(t−1)
a(t)
sdr
// Update observer embeddings
for aobr in O do

, u(t))

, u(t))

, u(t))

adr

sdr

sdr

obr ← GRUO(a(t−1)
a(t)
end for

22:
23:
24:
25:
26:
27: end for
28: // Return ﬁnal speaker embeddings
29: Output
30: return a(T )

obr

, u(t))

for ai = a1, a2, . . . , a|A(C)|

i

sdr

sdr

adr

The update, as illustrated in the upper part of Figure 2, is
controlled by three gates. The r(t)
S gate controls the previ-
, and p(t)
ous sender embedding a(t−1)
S controls the previous
addressee embedding a(t−1)
. Those two gated interactions
together produce the sender embedding proposal (cid:101)a(t)
sdr. Fi-
S combines the proposal (cid:101)a(t)
nally, the update gate z(t)
sdr and
the previous sender embedding a(t−1)
to update the sender
embedding a(t)
sdr. The computations in IGRUS (including
S , z(t)
S , p(t)
gates r(t)
sdr, and the
ﬁnal updated embedding a(t)
r(t)
Su(t) + Ur
S =σ(Wr
p(t)
Su(t) + Up
S =σ(Wp
z(t)
Su(t) + Uz
S =σ(Wz
sdr = tanh(WSu(t) + US(r(t)
(cid:101)a(t)
S (cid:12) a(t−1)
+ VS(p(t)
))
S ) (cid:12) (cid:101)a(t)
sdr + (1 − z(t)
S (cid:12) a(t−1)

S , the proposal embedding (cid:101)a(t)
sdr) are formulated as:
sdr + Vr
sdr + Vp
sdr + Vz

Sa(t−1)
Sa(t−1)
Sa(t−1)
S (cid:12) a(t−1)
)

Sa(t−1)
Sa(t−1)
Sa(t−1)

sdr = z(t)
a(t)

adr

adr

adr

adr

sdr

sdr

)

)

)

Figure 2: Illustration of IGRUS (upper, blue), IGRUA
(middle, green), and GRUO (lower, yellow). Filled circles
are speaker embeddings, which are recurrently updated. Un-
ﬁlled circles are gates. Filled squares are speaker embedding
proposals.

S, Ur

S, Vr

S, Uz

S, Vz

S, Vp

S, Wz

S, Wp

S, Up
where {Wr
S, WS,
US, VS} are learnable parameters. IGRUA uses the same
formulation with a different set of parameters, as illustrated
in the middle of Figure 2. In addition, we update the observer
embeddings from the utterance. GRUO is implemented
as the traditional GRU unit in the lower part of Figure 2.
Note that the parameters in IGRUS/IGRUA/GRUO are not
shared. This allows SI-RNN to learn role-dependent features
to control speaker embedding updates. The formulations of
IGRUA and GRUO are similar.

Joint Selection

4.4
The dialog encoder takes the dialog context C as input and
returns speaker embeddings at the ﬁnal time step, a(T )
. Re-
call from Section 3.2 that DYNAMIC-RNN produces the
context embedding hC using Eq 2 and then selects the ad-
dressee and response separately using Eq 3 and Eq 4.

i

In contrast, SI-RNN performs addressee and response
selection jointly:
the response is dependent on the ad-
dressee and vice versa. Therefore, we view the task as a se-
quence prediction process: given the context and responding
speaker, we ﬁrst predict the addressee, and then predict the
response given the addressee. (We also use the reversed pre-
diction order as in Eq 7.)

In addition to Eq 3 and Eq 4, SI-RNN is also trained
to model the conditional probability as follows. To predict
the addressee, we calculate the probability of the candidate
speaker ap to be the ground-truth given the ground-truth re-
sponse r (available during training time):

P(ap|C, r) = σ([ares; hC; r](cid:62)Warap)

(5)

The key difference from Eq 3 is that Eq 5 is conditioned on
the correct response r with embedding r. Similarly, for re-
sponse selection, we calculate the probability of a candidate
response rq given the ground-truth addressee aadr:

At

P(rq|C, aadr) = σ([ares; hC; aadr](cid:62)Wrarq)
test

time, SI-RNN selects the addressee-response
pair from A(C) × R to maximize the joint probability
P(rq, ap|C):

(6)

ˆa, ˆr = arg max

P(rq, ap|C)

ap,rq∈A(C)×R

= arg max

ap,rq∈A(C)×R

P(rq|C) · P(ap|C, rq)

(7)

+ P(ap|C) · P(rq|C, ap)

In Eq 7, we decompose the joint probability into two terms:
the ﬁrst term selects the response given the context, and then
selects the addressee given the context and the selected re-
sponse; the second term selects the addressee and response
in the reversed order.2

5 Experimental Setup
Data Set. We use the Ubuntu Multiparty Conversation
Corpus (Ouchi and Tsuboi 2016) and summarize the data
statistics in Table 3. The whole data set (including the
Train/Dev/Test split and the false response candidates) is
publicly available.3 The data set is built from the Ubuntu
IRC chat room where a number of users discuss Ubuntu-
related technical issues. The log is organized as one ﬁle per
day corresponding to a document D. Each document con-
sists of (Time, SenderID, Utterance) lines. If users explicitly
mention addressees at the beginning of the utterance, the ad-
dresseeID is extracted. Then a sample, namely a unit of input
(the dialog context and the current sender) and output (the
addressee and response prediction) for the task, is created
to predict the ground-truth addressee and response of this
line. Note that samples are created only when the addressee
is explicitly mentioned for clear, unambiguous ground-truth
labels. False response candidates are randomly chosen from
all other utterances within the same document. Therefore,
distractors are likely from the same sub-conversation or even
from the same sender but at different time steps. This makes
it harder than Lowe et al. (2015) where distractors are ran-
domly chosen from all documents. If no addressee is explic-
itly mentioned, the addressee is left blank and the line is
marked as a part of the context.
Baselines. Apart from DYNAMIC-RNN, we also include
several other baselines. RECENT+TF-IDF always selects
the most recent speaker (except the responding speaker
ares) as the addressee and chooses the response to maxi-
mize the tf-idf cosine similarity with the context. We im-
prove it by using a slightly different addressee selection

2Detail: We also considered an alternative decomposition of
the joint probability as log P(rq, ap|C) = 1
2 [log P(rq|C) +
log P(ap|C, rq) + log P(ap|C) + log P(rq|C, ap)], but the perfor-
mance was similar to Eq 7.

3https://github.com/hiroki13/response-ranking/tree/master/

data/input

heuristic (DIRECT-RECENT+TF-IDF): select the most re-
cent speaker that directly talks to ares by an explicit ad-
dressee mention. We select from the previous 15 utterances,
which is the longest context among all the experiments.
This works much better when there are multiple concur-
rent sub-conversations, and ares responds to a distant mes-
sage in the context. We also include another GRU-based
model STATIC-RNN from Ouchi and Tsuboi (2016). Unlike
DYNAMIC-RNN, speaker embeddings in STATIC-RNN are
based on the order of speakers and are ﬁxed. Furthermore,
inspired by Zhou et al. (2016) and Serban et al. (2016),
we implement STATIC-HIER-RNN, a hierarchical version
of STATIC-RNN. It ﬁrst builds utterance embeddings from
words and then uses high-level RNNs to process utterance
embeddings.
Implementation Details For a fair comparison, we fol-
low the hyperparameters from Ouchi and Tsuboi (2016),
which are chosen based on the validation data set. We
take a maximum of 20 words for each utterance. We use
300-dimensional GloVe word vectors4, which are ﬁxed dur-
ing training. SI-RNN uses 50-dimensional vectors for both
speaker embeddings and hidden states. Model parameters
are initialized with a uniform distribution between -0.01 and
0.01. We set the mini-batch size to 128. The joint cross-
entropy loss function with 0.001 L2 weight decay is min-
imized by Adam (Kingma and Ba 2015). The training is
stopped early if the validation accuracy is not improved for
5 consecutive epochs. All experiments are performed on a
single GTX Titan X GPU. The maximum number of epochs
is 30, and most models converge within 10 epochs.

6 Results and Discussion
For fair and meaningful quantitative comparisons, we follow
Ouchi and Tsuboi (2016)’s evaluation protocols. SI-RNN
improves the overall accuracy on the addressee and response
selection task. Two ablation experiments further analyze the
contribution of role-sensitive units and joint selection re-
spectively. We then conﬁrm the robustness of SI-RNN with
the number of speakers and distant responses. Finally, in a
case study we discuss how SI-RNN handles complex con-
versations by either engaging in a new sub-conversation or
responding to a distant message.
Overall Result. As shown in Table 2, SI-RNN signiﬁcantly
improves upon the previous state-of-the-art. In particular,
addressee selection (ADR) beneﬁts most, with different num-
ber of candidate responses (denoted as RES-CAND): around
12% in RES-CAND = 2 and more than 10% in RES-CAND
= 10. Response selection (RES) is also improved, suggest-
ing role-sensitive GRUs and joint selection are helpful for
response selection as well. The improvement is more obvi-
ous with more candidate responses (2% in RES-CAND = 2
and 4% in RES-CAND = 10). These together result in sig-
niﬁcantly better accuracy on the ADR-RES metric as well.
Ablation Study. We show an ablation study in the last
rows of Table 2. First, we share the parameters of
IGRUS/IGRUA/GRUO. The accuracy decreases signiﬁ-
cantly, indicating that it is crucial to learn role-sensitive units

4http://nlp.stanford.edu/projects/glove/

Chance
Recent+TF-IDF
Direct-Recent+TF-IDF
Static-RNN
(Ouchi and Tsuboi 2016)

Static-Hier-RNN
(Zhou et al. 2016)
(Serban et al. 2016)
Dynamic-RNN
(Ouchi and Tsuboi 2016)

SI-RNN (Ours)

SI-RNN w/ shared IGRUs
SI-RNN w/o joint selection

DEV

RES-CAND = 2

TEST

ADR-RES ADR-RES ADR
1.24
55.62
67.72
60.39
60.97
61.95
62.20
64.61
65.84
63.19
66.94
68.54
74.08
78.76
80.47
74.20
77.56

0.62
37.11
45.83
47.08
48.52
49.03
49.19
51.37
52.78
49.38
52.76
54.45
60.57
65.34
67.01
59.50
63.13

0.62
37.13
45.76
46.99
48.67
49.27
49.38
51.76
53.04
49.80
53.85
54.88
60.69
65.63
67.30
59.47
63.40

T
-
15
15
5
10
15
5
10
15
5
10
15
5
10
15
15
15

RES
50.00
67.89
67.89
75.07
77.75
78.14
76.70
78.28
79.08
76.07
78.16
78.64
78.14
80.34
80.91
78.08
80.38

DEV

RES-CAND = 10
TEST

ADR-RES ADR-RES ADR
1.24
55.62
67.72
60.26
60.66
60.98
62.24
64.86
65.89
63.28
66.70
68.41
72.59
77.13
78.53
73.35
77.61

0.12
15.44
19.50
21.98
23.31
23.49
23.75
25.83
26.62
23.72
25.95
27.19
30.71
34.09
35.76
28.45
32.53

0.12
14.91
18.94
21.96
22.78
23.73
23.68
25.46
26.31
23.44
25.44
26.73
30.65
34.18
35.50
28.31
32.24

RES
10.00
29.19
29.40
33.27
35.91
36.58
34.51
36.94
37.85
33.62
36.14
36.93
36.45
39.20
40.83
36.00
39.73

Table 2: Addressee and response selection results on the Ubuntu Multiparty Conversation Corpus. Metrics include accuracy
of addressee selection (ADR), response selection (RES), and pair selection (ADR-RES). RES-CAND: the number of candidate
responses. T : the context length.

# Docs
# Utters
# Samples
Adr Mention Freq
# Speakers / Doc
# Utters / Doc
# Words / Utter

Dev
367

Total
Train
6,606
7,355
2.4M 2.1M 132.4k
45.1k
665.6k
0.34
0.32
30.7
26.3
360.8
317.9
11.2
11.1

-
-
26.8
326.3
11.1

Test
382
151.3k
51.9k
0.34
32.1
396.1
11.3

Table 3: Data Statistics. “Adr Mention Freq” is the fre-
quency of explicit addressee mention.

to update speaker embeddings. Second, to examine our joint
selection, we fall back to selecting the addressee and re-
sponse separately, as in DYNAMIC-RNN. We ﬁnd that joint
selection improves ADR and RES individually, and it is par-
ticularly helpful for pair selection ADR-RES.
Number of Speakers. Numerous speakers create com-
plex dialogs and increased candidate addressee, thus the
task becomes more challenging. In Figure 3 (Upper), we
investigate how ADR accuracy changes with the number
of speakers in the context of length 15, corresponding
to the rows with T=15 in Table 2. RECENT+TF-IDF al-
ways chooses the most recent speaker and the accuracy
drops dramatically as the number of speakers increases.
DIRECT-RECENT+TF-IDF shows better performance, and
DYNAMIC-RNNis marginally better. SI-RNN is much more
robust and remains above 70% accuracy across all bins. The
advantage is more obvious for bins with more speakers.
Addressing Distance. Addressing distance is the time dif-
ference from the responding speaker to the ground-truth ad-
dressee. As the histogram in Figure 3 (Lower) shows, while
the majority of responses target the most recent speaker,
many responses go back ﬁve or more time steps. It is im-

Figure 3: Effect of the number of speakers in the context
(Upper) and the addressee distance (Lower). Left axis: the
histogram shows the number of test examples. Right axis:
the curves show ADR accuracy on the test set.

portant to note that for those distant responses, DYNAMIC-
RNN sees a clear performance decrease, even worse than
DIRECT-RECENT+TF-IDF. In contrast, SI-RNN handles
distant responses much more accurately.

1
1
2

3

4
2
4
2
2
5
5
5
3

1
1
1

2
2
2
2
2
2
2
2
2

Sender
codepython
wafﬂejock
wafﬂejock

Addressee
wafﬂejock
codepython
theoletom

codepython

-

Guest54977
theoletom
Guest54977
theoletom
theoletom
releaf
releaf
releaf
codepython

3
5
5

Jordan U
Umeaboy
wafﬂejock
Model Prediction
Direct-Recent+TF-IDF
Dynamic-RNN
SI-RNN

-
wafﬂejock
-
-
-
-
-
-
-

codepython
releaf

Addressee
theoletom
codepython
(cid:63) releaf

Utterance
thanks
yup np
you can use sudo apt-get install packagename – reinstall, to have apt-get install reinstall some
package/metapackage and redo the conﬁguration for the program as well
i installed ubuntu on a separate external drive. now when i boot into mac, the external drive does
not show up as bootable. the blue light is on. any ideas?
hello there. wondering to anyone who knows, where an ubuntu backup can be retrieved from.
it’s not a program. it’s a desktop environment.
did some searching on my system and googling, but couldn’t ﬁnd an answer
be a trace of it left yet there still is.
i think i might just need a fresh install of ubuntu. if there isn’t a way to revert to default settings
what’s your opinion on a $500 laptop that will be a dedicated ubuntu machine?
are any of the pre-loaded ones good deals?
if not, are there any laptops that are known for being oem-heavy or otherwise ubuntu friendly?
my usb stick shows up as bootable (eﬁ) when i boot my mac. but not my external hard drive on
which i just installed ubuntu. how do i make it bootable from mac hardware?
did you install ubuntu to this external drive from a different machine?
what country you from?

Response
ubuntu install fresh
no prime is the replacement
(cid:63) there are a few ubuntu dedicated laptop providers like umeaboy is asking depends on where
you are

(a) SI-RNN chooses to engage in a new sub-conversation by suggesting a solution to “releaf” about Ubuntu dedicated laptops.

Sender
VeryBewitching
nicomachus
VeryBewitching

Addressee
nicomachus
VeryBewitching
nicomachus

TechMonger
TechMonger
Ionic
TechMonger
D33p
BuzzardBuzz
BuzzardBuzz
Ionic
chingao

-
-
-
-
TechMonger
-
-
BuzzardBuzz
TechMonger

Utterance
anything i should be concerned about before i do it?
always back up before partitioning.
i would have assumed that, i was wondering more if this is something that tends to be
touch and go, want to know if i should put coffee on : )
it was hybernating. i can ping it now
why does my router pick up disconnected devices when i reset my device list? or how
because the dhcp refresh interval hasn’t passed yet?
so dhcp refresh is different than device list refresh?
what an enlightenment @techmonger : )
dhcp refresh for all clients is needed when you change your subnet ip
if you want them to work together
uhm, no.
nicomachus asked this way at the beginning: is the machine that you ’re trying to ping
turned on?

1

nicomachus
Model Prediction
Direct-Recent+TF-IDF
Dynamic-RNN

Addressee
(cid:63) VeryBewitching
chingao

SI-RNN

(cid:63) VeryBewitching

Response
i have tried with this program y-ppa manager, yet still doesn’t work.
install the package “linux-generic”, that will install the kernel and the headers if they are
not installed
(cid:63) if it’s the last partition on the disk, it won’t take long. if gparted has to copy data to
move another partition too, it can take a couple hours.

(b) SI-RNN remembers the distant sub-conversation 1 and responds to “VeryBewitching” with a detailed answer.

Table 4: Case Study. (cid:63) denotes the ground-truth. Sub-conversations are coded with different numbers for the purpose of analysis
(sub-conversation labels are not available during training or testing).

Case Study. Examples in Table 4 show how SI-RNN can
handle complex multi-party conversations by selecting from
10 candidate responses. In both examples, the respond-
ing speakers participate in two or more concurrent sub-
conversations with other speakers.

Example (a) demonstrates the ability of SI-RNN to en-
gage in a new sub-conversation. The responding speaker
“wafﬂejock” is originally involved in two sub-conversations:

the sub-conversation 1 with “codepython”, and the ubuntu
installation issue with “theoletom”. While it is reasonable to
address “codepython” and “theoletom”, the responses from
other baselines are not helpful to solve corresponding issues.
TF-IDF prefers the response with the “install” key-word,
yet the response is repetitive and not helpful. DYNAMIC-
RNN selects an irrelevant response to “codepython”. SI-
RNN chooses to engage in a new sub-conversation by sug-

gesting a solution to “releaf” about Ubuntu dedicated lap-
tops.

Example (b) shows the advantage of SI-RNN in respond-
ing to a distant message. The responding speaker “nico-
machus” is actively engaged with “VeryBewitching” in
the sub-conversation 1 and is also loosely involved in the
sub-conversation 2: “chingao” mentions “nicomachus” in
the most recent utterance. SI-RNN remembers the distant
sub-conversation 1 and responds to “VeryBewitching” with
a detailed answer. DIRECT-RECENT+TF-IDF selects the
ground-truth addressee because “VeryBewitching” talks to
“nicomachus”, but the response is not helpful. DYNAMIC-
RNN is biased to the recent speaker “chingao”, yet the re-
sponse is not relevant.

7 Conclusion
SI-RNN jointly models who says what to whom by updat-
ing speaker embeddings in a role-sensitive way. It provides
state-of-the-art addressee and response selection, which can
instantly help retrieval-based dialog systems. In the future,
we also consider using SI-RNN to extract sub-conversations
in the unlabeled conversation corpus and provide a large-
scale disentangled multi-party conversation data set.

8 Acknowledgements
We thank the members of the UMichigan-IBM Sapphire
Project and all the reviewers for their helpful feedback. This
material is based in part upon work supported by IBM under
contract 4915012629. Any opinions, ﬁndings, conclusions
or recommendations expressed above are those of the au-
thors and do not necessarily reﬂect the views of IBM.

References
[2017] Bordes, A., and Weston, J. 2017. Learning end-to-end
goal-oriented dialog. In ICLR.
[2017] Chen, P.-C.; Chi, T.-C.; Su, S.-Y.; and Chen, Y.-N.
2017. Dynamic time-aware attention to speaker roles and
contexts for spoken language understanding. In ASRU.
[2017] Chi, T.-C.; Chen, P.-C.; Su, S.-Y.; and Chen, Y.-N.
2017. Speaker role contextual modeling for language under-
standing and dialogue policy learning. In IJCNLP.
[2014] Cho, K.; van Merrienboer, B.; Gulcehre, C.; Bah-
danau, D.; Bougares, F.; Schwenk, H.; and Bengio, Y. 2014.
Learning phrase representations using rnn encoder–decoder
for statistical machine translation. In EMNLP.
[2014] Chung, J.; Gulcehre, C.; Cho, K.; and Bengio, Y.
2014. Empirical evaluation of gated recurrent neural net-
works on sequence modeling. NIPS 2014 Deep Learning
and Representation Learning Workshop.
[2008] Henderson, J.; Lemon, O.; and Georgila, K. 2008.
Hybrid reinforcement/supervised learning of dialogue poli-
Computational Linguistics
cies from ﬁxed data sets.
34(4):487–511.
[2014] Henderson, M.; Thomson, B.; and Williams, J. 2014.
The second dialog state tracking challenge. In SIGDIAL.

[2014] Henderson, M.; Thomson, B.; and Young, S. 2014.
Word-based dialog state tracking with recurrent neural net-
works. In SIGDIAL.
[2014] Hu, B.; Lu, Z.; Li, H.; and Chen, Q. 2014. Con-
volutional neural network architectures for matching natural
language sentences. In NIPS.
[2014] Ji, Z.; Lu, Z.; and Li, H. 2014. An information re-
trieval approach to short text conversation. arXiv preprint
arXiv:1408.6988.
[2006] Jovanovi´c, N.; Akker, R. o. d.; and Nijholt, A. 2006.
Addressee identiﬁcation in face-to-face meetings. In EACL.
[2015] Kingma, D., and Ba, J. 2015. Adam: A method
International Conference for
for stochastic optimization.
Learning Representations (ICLR).
[2016] Li, J.; Galley, M.; Brockett, C.; Spithourakis, G.; Gao,
J.; and Dolan, B. 2016. A persona-based neural conversation
model. In ACL.
[2015] Lowe, R.; Pow, N.; Serban, I.; and Pineau, J. 2015.
The Ubuntu Dialogue Corpus: A large dataset for research
in unstructured multi-turn dialogue systems. In SIGDIAL.
[2013] Lu, Z., and Li, H. 2013. A deep architecture for
matching short texts. In NIPS.
[2017] Mei, H.; Bansal, M.; and Walter, M. R. 2017. Co-
herent dialogue with attention-based language models.
In
AAAI.
[2017] Meng, Z.; Mou, L.; and Jin, Z. 2017. Towards neu-
ral speaker modeling in multi-party conversation: The task,
dataset, and models. arXiv preprint arXiv:1708.03152.
[2015] Mesnil, G.; Dauphin, Y.; Yao, K.; Bengio, Y.; Deng,
L.; Hakkani-Tur, D.; He, X.; Heck, L.; Tur, G.; Yu, D.; et al.
2015. Using recurrent neural networks for slot ﬁlling in spo-
ken language understanding. Audio, Speech, and Language
Processing, IEEE/ACM Transactions on 23(3):530–539.
[2009] op den Akker, R., and Traum, D. 2009. A compari-
son of addressee detection methods for multiparty conversa-
tions. Workshop on the Semantics and Pragmatics of Dia-
logue.
[2016] Ouchi, H., and Tsuboi, Y. 2016. Addressee and re-
sponse selection for multi-party conversation. In EMNLP.
[2011] Ritter, A.; Cherry, C.; and Dolan, W. B. 2011. Data-
driven response generation in social media. In EMNLP.
[2016] Serban, I. V.; Sordoni, A.; Bengio, Y.; Courville, A.;
and Pineau, J. 2016. Building end-to-end dialogue sys-
tems using generative hierarchical neural network models.
In AAAI.
[2015] Shang, L.; Lu, Z.; and Li, H. 2015. Neural responding
machine for short-text conversation. In ACL.
[1999] Singh, S. P.; Kearns, M. J.; Litman, D. J.; and Walker,
M. A. 1999. Reinforcement learning for spoken dialogue
systems. In NIPS.
[2015] Vinyals, O., and Le, Q. 2015. A neural conversational
model. ICML Deep Learning Workshop.
[2015] Wang, M.; Lu, Z.; Li, H.; and Liu, Q. 2015. Syntax-
based deep matching of short texts. In IJCAI.

[2015] Wen, T.-H.; Gaˇsi´c, M.; Mrkˇsi´c, N.; Su, P.-H.;
Vandyke, D.; and Young, S. 2015. Semantically conditioned
lstm-based natural language generation for spoken dialogue
systems. In EMNLP.
[2016] Wen, T.-H.; Vandyke, D.; Mrksic, N.; Gasic, M.;
Rojas-Barahona, L. M.; Su, P.-H.; Ultes, S.; and Young, S.
2016. A network-based end-to-end trainable task-oriented
dialogue system. arXiv preprint arXiv:1604.04562.
[2016] Williams, J.; Raux, A.; and Henderson, M. 2016. The
dialog state tracking challenge series: A review. Dialogue &
Discourse 7(3):4–33.
[2014] Yao, K.; Peng, B.; Zhang, Y.; Yu, D.; Zweig, G.; and
Shi, Y. 2014. Spoken language understanding using long
short-term memory neural networks. In Spoken Language
Technology Workshop (SLT), 2014 IEEE, 189–194. IEEE.
[2013] Young, S.; Gasic, M.; Thomson, B.; and Williams,
J. D. 2013. Pomdp-based statistical spoken dialog systems:
A review. Proceedings of the IEEE 101(5):1160–1179.
[2016] Zhou, X.; Dong, D.; Wu, H.; Zhao, S.; Yu, D.; Tian,
H.; Liu, X.; and Yan, R. 2016. Multi-view response selection
for human-computer conversation. In EMNLP.

