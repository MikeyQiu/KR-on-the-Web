5
1
0
2
 
v
o
N
 
9
 
 
]

G
L
.
s
c
[
 
 
1
v
0
8
5
2
0
.
1
1
5
1
:
v
i
X
r
a

Under review as a conference paper at ICLR 2016

HOW FAR CAN WE GO WITHOUT CONVOLUTION: IM-
PROVING FULLY-CONNECTED NETWORKS

Zhouhan Lin & Roland Memisevic
Universit´e de Montr´eal
Canada
{zhouhan.lin, roland.memisevic}@umontreal.ca

Kishore Konda
Goethe University Frankfurt
Germany
konda.kishorereddy@gmail.com

ABSTRACT

We propose ways to improve the performance of fully connected networks. We
found that two approaches in particular have a strong effect on performance: lin-
ear bottleneck layers and unsupervised pre-training using autoencoders without
hidden unit biases. We show how both approaches can be related to improving
gradient ﬂow and reducing sparsity in the network. We show that a fully connected
network can yield approximately 70% classiﬁcation accuracy on the permutation-
invariant CIFAR-10 task, which is much higher than the current state-of-the-art.
By adding deformations to the training data, the fully connected network achieves
78% accuracy, which is just 10% short of a decent convolutional network.

1

INTRODUCTION

Convolutional neural networks (CNN) have had huge successes since Krizhevsky et al. (2012), espe-
cially in computer vision applications. The main computational idea behind these, weight sharing,
is unfortunately not biologically plausible, and it does not map nicely to simple, densely parallel
hardware designs, which may one day yield lower-energy, and more efﬁcient ways to run neural
networks. The reason is that weight sharing requires long-range communication, for example, when
distributing derivatives, during learning.

In this paper, we explore the performance that one can possibly achieve with a neural network with-
out convolutions, in other words, a neural network learning on “permutation invariant” classiﬁcation
tasks. We use these as a test-bed for studying alternative architectural design choices beside con-
volution, which are biologically plausible and potentially more hardware friendly. Studying these
design choices is relevant also because many tasks and sub-tasks do not come with any local trans-
lation invariance, making them not amenable to convolution (an example being the hidden layer in
a recurrent neural network).

Two architectural choices we found to have a strong impact on performance are (i) linear bottleneck
layers and (ii) pre-training using autoencoders whose hidden units have no biases. Taken together,
these two approaches allow us a network to achieve state-of-the-art performance on the permutation-
invariant CIFAR-10 task 1, and by adding deformations (thus removing the permutation invariance
requirement) it achieves performance close to the range of that achieved by CNNs.

1.1 SPARSITY IN NEURAL NETWORKS

Both approaches can be viewed from the perspective of sparsity in a neural network. Sparsity is
commonly considered as a desirable property in machine learning models, and it is often encouraged

1An example implementation that generates the state-of-the-art on this task is available at https:

//github.com/hantek/zlinnet

1

Under review as a conference paper at ICLR 2016

explicitly as a regularizer. Unfortunately, in deep, multilayer neural networks sparsity comes at a
price: in common activation functions, such as sigmoid or ReLU, zero (or almost zero) activations
are attained at values where derivatives are zero, too. This prevents derivatives from ﬂowing through
inactive hidden units, and makes the optimization difﬁcult. Stated in terms of the vanishing gradients
problem (e.g., Hochreiter et al. (2001)) this means that for a ReLU activation many Jacobians are
diagonal matrices containing many zeros along the diagonal.

To alleviate this problem, recently several activation functions were proposed, where zero derivatives
do not, or are less likely to, occur. In the PReLU activation function (He et al., 2015), for example,
the zero-derivative regime is replaced by a learned, and typically small-slope, linear activation. An-
other approach is the Maxout activation (Goodfellow et al., 2013), which is deﬁned as the maximum
of several linear activations. Accordingly, preventing zero-derivatives this way was shown to im-
prove the optimization and the performance of multilayer networks. Unfortunately, these methods
solve the problem by giving up on sparsity altogether, which raises the question whether sparsity is
simply not as desirable as widely assumed or whether the beneﬁt of the optimization outweigh any
detrimental effect on sparsity. Sparsity also plays a crucial role in unsupervised learning (which can
also be viewed as a way to help the optimization (Saxe et al., 2013)), where these activations have
accordingly never been successfully applied.

This view of sparsity motivates us to revisit a simple, but as we shall show surprisingly effective,
approach to retaining the beneﬁts of sparsity without preventing gradient-ﬂow. The idea is to inter-
leave linear, low-dimensional layers with the sparse, high-dimensional layers containing ReLU or
sigmoid activations. We show that this approach outperforms equivalent PReLU and Maxout net-
works on the fully supervised, permutation invariant CIFAR-10 task.

A second detrimental side-effect of sparsity, discussed in more detail in Konda et al. (2014), is that
for a ReLU or sigmoid unit to become sparse it typically learns strongly negative bias-terms. In
other words, while sparse activations can be useful in terms of the learning objective (for example,
by allowing the network to carve up space into small regions) it forces the network to utilize bias
terms that are not optimal for the representation encoded in hidden layer activations. Konda et al.
(2014), for example, suggest bias-terms equal to zero to be optimal and propose a way to train an
autoencoder with zero-bias hidden units. We suggest in Section 3 that pre-training a network with
these autoencoders may be viewed as a way to orthogonalize subsets of weights in the network, and
show that this yields an additional strong performance improvement.

We shall discuss the motivation for linear bottleneck layers in the next section and pre-training using
autoencoders in Section 3, followed by experimental results in Section 4.

2 LINEAR BOTTLENECK LAYERS

One drawback of sparsity in a deep network is that it amounts to data scarcity: a weight whose
post-synaptic unit is off 80% of the time will effectively get to see only 20% of the training data.
In lower layers of a convolutional network, this problem is compensated by weight-sharing, which
increases the effective number of training examples (patches in that case) per weight by a factor of
several thousand. In a fully connected layer (more precisely, a layer without weight sharing) such
compensation is not possible and the only way to counter this effect would be by increasing the
training set size.

Sparsity is a common and stable effect in neural networks containing ReLU or sigmoid units, and
it can be related to the fact the biases are driven to zero in response to regularization (eg., Konda
et al. (2014)). Figure 1 (left) shows the sparsity level attained after training ReLU MLPs. 2 The
plots show that the sparsity of the hidden presentation increases with the depth of the network and
increase further in the presence of dropout.

2Two MLPs (1000-2000-3000 units and 2000-2000-2000 units, respectively), trained for 501 epochs on
CIFAR-10. Each network was trained once with dropout and once without. For the experiments with dropout,
an input noise level of 0.2 and hidden noise level of 0.5 was used.

2

Under review as a conference paper at ICLR 2016

Figure 1:
(left) The sparsity in different layers of two MLPs N1(1000-2000-3000 units) and
N2(2000-2000-2000 units) trained with and without dropout on CIFAR-10 dataset. N1 Crpt,
N2 Crpt: Experiments with dropout. (right) Illustration of a network with linear bottleneck lay-
ers.

2.1 LINEAR LAYERS AS DISTRIBUTION RESHAPING

It is well-known that different activation functions work best when the input is in a reasonable
scale, which is the motivation for using pre-processing by mean subtraction and scaling, for ex-
ample. Furthermore, incorporating them into hidden unit activation, can yield further performance
improvements (Ioffe & Szegedy, 2015).

Here, we focus on the distribution over the outputs of a unit. The output of a linear neuron Y with
inputs (cid:126)X = (X1, X2, ..., Xi, XN ) is given by Y = (cid:80)N
i wiXi + b, where wi is the entry in the
weight vector corresponding to input node i, b is the bias of the linear neuron, and N denotes the
input dimension. Assume the data fed into each input node Xi is independent and has a ﬁnite mean
µi and variance σ2
i . In the net input to a neuron, the mean and variance of each wiXi term are tuned
by its corresponding weight values:

(1)
According to the Lyapunov theorem (DeGroot et al., 1986), if a sequence of random variables with
ﬁnite mean and variance are independent but not necessarily identically distributed, the distribution
of the sum:

ˆµi = wiµi;

ˆσi

2 = w2

i σ2
i

(cid:16) N
(cid:88)

N
(cid:88)

(cid:17)(cid:16) N
(cid:88)

S =

wiXi −

ˆµi

− 1
2

2(cid:17)

ˆσi

2

i=1

2(cid:17) 1

i=1
tends to standard Gaussian distribution for N −→ ∞. If we write Y in terms of S, that is, Y =
(cid:16)(cid:80)N

i=1 ˆσi
i=1 ˆµi we see that Y approximates a Gaussian distribution whose mean
is b + (cid:80)N
2, when the input dimension N −→ ∞. For
mean-centered data, we have ˆµi ≈ 0. Thus the actual mean value of Y is merely dominated by b in
which case the p.d.f. of Y is:

i=1 ˆµi and whose variance equals to (cid:80)N

S + b + (cid:80)N

i=1 ˆσi

i=1

pLin (y) ≈

1
2π (cid:80)N
This form of asymptotic distribution holds regardless of the weight wi. That means, no matter how
the network is trained, or even not trained, the asymptotic distribution of output of a linear unit tends
to be Gaussian.

i=1 ˆσi

(3)

(cid:113)

i=1

e

2

− (y−b)2
ˆσ2
2 (cid:80)N
i

Since the pre-hidden activation of ReLU is linear it tends to be Gaussian as well. The ReLU activa-
tion then simply sets all negative values to zero which yields:

(2)

(4)

pReLU (y) =

(cid:40)(cid:82) 0

−∞ pLin (y) dy · δ(0), y ≤ 0
pLin (y) , y > 0

3

Under review as a conference paper at ICLR 2016

where δ(0) is the Dirac delta. The distribution has a delta spike at zero and a Gaussian tail at its
positive end (Figure 2).

Figure 2: P.d.f. of ReLU output (left) and zero-bias ReLU output (right). The arrow at zero indicates
a delta spike, and the dashed part stands for the probability mass absorbed into that delta spike.

Since the bias controls the intensity of the δ(0) spike, it controls the sparsity of output representation
(left plot). The observation that biases tend to zero motivated Konda et al. (2014) to introduce a
“zero-bias” activation function which uses a ﬁxed threshold followed by linear activation. Typically
while using zero-bias ReLU, a threshold of 1 is introduced during pre-training stage, and set back to
zero while training its subsequent layers and ﬁne-tuning. The distribution of pre-hidden activity of
a zero-bias ReLU stretches equally on both sides of zero. As a result, for zero-bias ReLU activation
half of the probability mass concentrates on a delta spike located at zero, as illustrated it Figure 2
(right). While batch normalization alone will push the mean and variance into the optimal range for a
subsequent ReLU unit, it will not resolve the issue that the distribution is peaked at the negative bias.
In fact, the estimate of mean and variance will suffer from the presence of a highly non-Gaussian
distribution. Typical histograms over hidden unit activations for several activation functions are
shown in Figure 3a.

(a) zero bias ReLU activation

(b) linear layer activation

(c) Sigmoid activation

Figure 3: Histogram of output activation with different types of activation function.

2.2 DERIVATIVES IN THE PRESENCE OF LINEAR LAYERS

We now consider the derivatives of a ReLU network. The activation of the i-th layer is given by:
(cid:126)Hi+1 = R(wi (cid:126)Hi + (cid:126)bi),

(5)

where R() is the element-wise activation function. The back-propagated updates on wi will be:

∆wi = δ ◦ R

(cid:48) (cid:16) (cid:126)Hi+1

(cid:17)

· (cid:126)Hi

where δ stands for the down ﬂowing error signal coming from the upper layer, ◦ stands for element-
wise multiply, and · is the product of a vertical vector and a horizontal vector. As discussed in
Section 2.1, at least 50% (usually much more in practice due to negative biases) of the values in the
representation Hi and Hi+1 are typically equal to zero (cf., Figure 1, left) making a large fraction of
the entries of ∆wi per training case zero. If we introduce a linear layer between two ReLU layers,

(cid:126)Hl = wl (cid:126)Hi + (cid:126)bl

(cid:126)Hi+1 = R

wi (cid:126)Hl + (cid:126)bi

(cid:16)

(cid:17)

(6)

(7)

4

Under review as a conference paper at ICLR 2016

where (cid:126)Hl stands for the output of linear layer, and wl, bl are the weights and biases in the linear
layer, we obtain updates of the form:

∆wl = δl · (cid:126)Hi , ∆wi = δ ◦ R

(cid:48) (cid:16) (cid:126)Hi+1

(cid:17)

· (cid:126)Hl

where δl is the error signal passed to the linear layer, δl = δwi. Since the linear layer representa-
tion (cid:126)Hl is dense, both ∆wl and ∆wi become denser: only half of the values in these two update
matrices are zeros. More importantly, there always exists a simple ReLU layer that is equivalent to
a ReLU/linear combination because any linear layer can be absorbed into the weights of the ReLU
layer:

Then, the equivalent update on w becomes:

w = wiwl,

b = wibl + bi

∆w = ∆wi∆wl + wi∆wl + ∆wiwl

(8)

(9)

(10)

Even if half of the values in ∆wi and ∆wl are zero, their product is a dense matrix. The second
and third term in Equation 10 are also dense, so with a linear bottleneck layer, we actually obtain a
dense update in an equivalent ReLU layer.

2.3 REDUCING PARAMETERS

Besides helping with back propagation, it is important to note that linear layers also reduce the total
number of parameters. Suppose a linear layer with L units is inserted between two nonlinear layers
with N units each. The total number of parameters would become 2N L + L + N . This is much less
than the number of parameters that would result from directly connecting the two nonlinear layer,
which would amount to N 2 + N parameters. Convolutional network also reduces the number of
parameters by convolution kernels. Note that for any trained convolutional network, we can always
ﬁnd a fully connected network with the same accuracy by expanding the convolutional kernels.

3 PRE-TRAINING AND ZERO-BIAS ACTIVATIONS

It was suggested by Saxe et al. (2013) that the beneﬁt of unsupervised pre-training of a network
using RBMs or autoencoders may result in weight matrices that are closer to orthogonal and thus
less affected by vanishing gradients problems. It is interesting to note, however, that the sparsity-
inducing negative biases yield reconstructions that are afﬁne not linear and accordingly may not
orthogonalize weights after all (Konda et al., 2014). This may be one of the reasons why the practical
success of these pre-training schemes has been quite limited by comparison to fully supervised
learning using back propagation.

It is also important to note that due to sparsity, the number of active units in a layer is often smaller
than that the same number in the layer below, so the “effective” weight matrix for a given input
example is not a square matrix. Rather than simply orthogonal weight matrices, we should be
looking for networks where hidden units which tend to be active on the same inputs have weights
that tend to be orthogonal to one another. In other words, we should be looking for “orthogonal
active paths” through the network rather than overall orthogonal weight matrices.

In order to obtain hidden units with linear not afﬁne encodings Konda et al. (2014) introduce “zero-
bias autoencoders” (ZAE) whose activations are threshold-ed when pre-trained by minimizing the
autoencoder reconstruction error, and whose thresholds are removed when the weights are used
for classiﬁcation or for initializing a feed forward network. As discussed in Konda et al. (2014)
minimizing squared error under the linear encoding should encourage weights corresponding to
hidden units that tend to be “on” together to orthogonalize (because the orthogonal projection is what
minimizes reconstruction error). Konda et al. (2014) reported decent classiﬁcation performance in
various supervised tasks, but found only a weak improvement over standard autoencoders when used
to initialize a single-hidden-layer MLP.

The view of a zero-bias activation function as a way to orthogonalize weights suggests especially
deep networks to proﬁt from ZAE pre-training, and so we investigated the performance of ZAE-
pretrained networks with many hidden layers, as well as in conjunction with interleaved bottleneck
layers (as discussed in Section 2). We found them to yield a separate, and signiﬁcant, performance
improvement in fully connected networks.

5

Under review as a conference paper at ICLR 2016

4 EXPERIMENTS

4.1 CIFAR-10

The CIFAR-10 dataset is a subset of the 80 Million Tiny Images Torralba et al. (2008), and contains
10 balanced classes. It provides a training set with 50000 samples and a test set of 10000 samples.
Each sample is a color image with 32 × 32 RGB pixels. We ﬁrst compare mixed models with linear
bottleneck layers and ordinary networks. We compare two different activation functions: ReLU
and zero-bias ReLU (Konda et al., 2014). Comparison are based on classiﬁcation accuracy. All the
experiments in this subsection share the same pre-processing pipeline and the same type of classiﬁer.
For pre-processing, the raw data is contrast normalized and centered to have zero mean, followed by
PCA whitening, retaining 99% of the variance.

(a) ReLU-Lin network and various networks with pure
ReLU activation.

(b) Z-Lin network and various networks with pure
Zero-bias ReLU activation.

(c) Z-Lin, zero-bias ReLU, ReLU-Lin and ReLU net-
work trained on HIGGS dataset.

Figure 4: Comparing bottlenecked network with its various counterparts. Models compared in (a)
and (b) are trained on CIFAR-10, while those in (c) are trained on HIGGS dataset.

We trained 3 ReLU networks with different conﬁgurations, and compare their results with the ReLU-
Lin network 4000ReLU − 1000Linear − 4000ReLU, that interleaves a linear layer between two
ReLU layers. All networks in Figure 4a are trained by supervised back propagation using stochastic
gradient descent with 0.9 momentum. The ReLU-Lin network outperforms all the pure ReLU net-
works and reaches an accuracy of 56.84%. We also found that the ReLU-Lin network tends to be
more stable than the pure ReLU networks: if we pre-train these networks layer-wise, then for the
ReLU networks the majority of the units in higher layers become “dead”, whereas the ReLU-Lin
network is still stable for unsupervised pre-training without dead units at the second ReLU layer.

We repeat the same experiment by substituting ReLU with ZAE (Figure 4b). The Z-Lin network is
conﬁgured as 4000Z − 1000Linear − 4000Z (same as in Figure 1, but with only one Z-Lin pair).
Since ZAE does not suffer from the problem of dead units that much as ReLU, all the networks are
ﬁrst layer-wise pre-trained in an autoencoder, and then ﬁne-tuned with stochastic gradient descent.
During pre-training the linear layer, we have 1.0 weight decay added to the cost. Similar to the
case of ReLU, it is also observed that introducing linear bottleneck layers makes the stacked deeper
model outperform its shallow counterpart. Having a linear inserted in the middle makes the Z-Lin
model outperform all the other models, yielding an accuracy of 65.76%.

We also compare the bottleneck layer structure with other related modiﬁcations like PReLU (He
et al., 2015) and Maxout (Goodfellow et al., 2013), the bottleneck structure performs better than
both of them, if we apply it on the same network architecture. In comparison to batch normalization

6

Under review as a conference paper at ICLR 2016

(Ioffe & Szegedy, 2015) (but on fully connected networks) on the other hand, their improvements
are about the same.

4.2 THE HIGGS DATASET

The HIGGS dataset has 11 million samples with 28 dimensions. The ﬁrst 21 features are kinematic
properties measured by particle detectors in a particle accelerator, and the remaining 7 features are
functions of the ﬁrst 21 features. Thus the dataset itself is permutation invariant. The task is to
decide if or not a given sample corresponds to a Higgs Boson.

We tried both ReLU and ZAE with/without linear bottleneck layers on this dataset. Similar to
before, for each model PCA whitening retaining 99% of the variance is used for pre-processing.
(corresponding to 27 principle components). We use the same model size for four different models
that we compare (zero-bias ReLU, Z-Lin, ReLU, and ReLU-Lin). The structure is 27 − 800 − 100 −
800 − 100 − 2 for all, so the models differ by using different activation functions. We train all the
models using SGD with momentum, and tune learning rates individually. We do not use any pre-
training. The results are shown in Figure 4c, which also conﬁrm the effectiveness of the bottleneck
layers, albeit not as pronounced as on the CIFAR-10 data. Also, zero-bias units do not yield an
improvement here.

4.3 REDUCING PARAMETERS

In this subsection we explore how the network’s performance is affected by increasingly reducing
the number of parameters, using bottlenecks of different sizes.

We deﬁne a network by stacking 3 Z-LIN pairs, plus a ZAE layer and a logistic regression classiﬁer.
Each ZAE layer has 4000 hidden units. We reduce the linear layer size from 1000 down to 100
units. Training involves dropout, pre-training and ﬁne-tuning. The results are shown in Figure 5.
We observe that even with a hidden layer of size 100, which has only 1/20 of the parameters, the
network still works reasonably well and does not loose too much accuracy.

A 7-layer fully connected network with 4000 units each layer has around 112 million parameters.
With linear layers, the smallest model in Figure 5 has only around 2.44 million parameters. By
comparison, a typical convolutional network yielding an accuracy higher than 80% on CIFAR10
would have around 3.5 million parameters.

Figure 5: Classiﬁcation accuracy w.r.t different linear layer size.

4.4 ACHIEVING STATE-OF-THE-ART ON PERMUTATION INVARIANT CIFAR-10

We compare the performance of the Z-Lin model with other published methods on the CIFAR-10.
For our method, pre-processing steps are the same to Section 4.1. For the Z-Lin network, each ZAE
layer 4000 hidden units, and each linear autoencoder has 1000 hidden units. We use logistic regres-
sion on top of the last ZAE layer for classiﬁcation. Following Konda et al. (2014), the threshold of
all ZAEs are ﬁxed at 1.0 during pre-training, and set to 0 while training the subsequent layers and
performing ﬁne-tuning. As before, we subtract the mean value and normalize the activations to have
a standard deviation of 1.0 in all layers.

7

Under review as a conference paper at ICLR 2016

We train the networks using stochastic gradient descent with 0.9 momentum and decreasing learning
rate. The learning rate is set to 0.001 for the ZAEs and to 0.0001 for the linear autoencoder. Weight
decay is used for the linear autoencoder and for the logistic regression layer. The latter is trained
using nonlinear conjugate gradients. After pre-training, we use a tiny learning rate of 5 × 10−6 to
ﬁne-tune the whole network, which yields an overall accuracy of 65.7%. This already outperforms
all previous published permutation invariant CIFAR-10 results, the next best-performing of which
are 63.1% (Le et al., 2013), and 63.9% (Konda et al., 2014).

By adding dropout (Srivastava et al., 2014) during pre-training and ﬁne-tuning, and using a very
deep Z-LIN network (3 Z-LIN pairs, plus a ZAE layer and logistic regression classiﬁer, i.e., 4000Z−
1000Lin−4000Z−1000Lin−4000Z−1000Lin−4000Z−10) the performance improves to 69.62%,
which exceeds the current state-of-the-art on permutation invariant CIFAR10 by a very large margin.

If we give up on permutation-invariance by using data augmentation (eg., Krizhevsky et al. (2012))
but retain the use of a fully connected network, the performance improves much further. Here, we
add ﬂipping, rotation, and shifting to the original data during training of a 4000Z − 1000Lin −
4000Z − 10 Z-LIN network pushing the performance to 78.62%. This is a much higher accuracy
on CIFAR-10 achieved by any fully connected network we are aware of, and it is only about 10%
behind a well-trained convolutional network.

Figure 6: Test set accuracy of various methods. They are (from left to right): 1) Logistic Regres-
sion on whitened data; 2) Pure backprop on a 782-10000-10 network; 3) Pure backprop on a 782-
10000-10000-10 network; 4) RBM with 2 hidden layers of 10000 hidden units each, plus a logistic
regression; 5) RBM with 10000 hiddens plus logistic regression; 6) ”Fastfood FFT” model (Le et al.,
2013); 7) Zerobias autoencoder of 4000 hidden units with logistic regression (Konda et al., 2014);
8) 782-4000-1000-4000-10 Z-Lin network trained without dropout; 9) 782-4000-1000-4000-1000-
4000-1000-4000-10 Z-Lin network, trained with dropout 10) Z-Lin network the same as (8) but
trained with dropout and data augmentation; Results (1)-(5) are from Krizhevsky & Hinton (2009).
The ﬁnal one is distinguished with a grey background because it uses data augmentation.

5 RELATED WORK

The idea of a linear bottleneck layer is very old and has been used as early as the 1980’s in the context
of autoencoders (eg., Baldi & Hornik (1989)). More recently, Ba & Caruana (2014) used a linear
bottleneck layer to factorize a single-layer network and showed that it helped speed up learning. An
application of a linear bottleneck layer in the last layer of a neural network for dealing with high-
dimensional outputs is described in Sainath et al. (2013) and Xue et al. (2013). In contrast to our
work, in none of these methods is the goal to alleviate vanishing gradients and deal with sparsity,
and (accordingly) they use just a single bottleneck layer in the network.

Reshape distributions over activations using linear layers is also related to the recently introduced
batch-normalization trick (Ioffe & Szegedy, 2015), in that it is also a way to adjust the distribution
of inputs to a subsequent layer. In contrast to that work, linear bottleneck layers not only adjust the
mean and variance of the inputs to the subsequent layer, but reshape the whole distribution.

8

Under review as a conference paper at ICLR 2016

6 DISCUSSION

It is well known that a single-hidden-layer neural network can model any non-linear function under
mild conditions (Funahashi, 1989; Cybenko, 1989). The intuition behind this observation is that the
hidden layer carves up space into half-spaces, or “tiles”, and the subsequent linear layer composes
the non-linear function by combining different linear regions to produce the output. It is interesting
to note that this view may suggest using a pair of layers (a non-linear followed by a linear layer) to
deﬁne the non-linear function, leading thus to interleaved linear/non-linear layers.

The practical usefulness of this result is limited, however, because to approximate any given function
it would require an exponentially large number of hidden units. In practice, this is one motivation for
using multilayer networks which compute a sequence of consequently more restricted, but tractable
non-linear functions. Arguably, in the presence of enough training data and computational resources,
wide hidden layers would still be preferable to narrow ones. However, in practice, wider hidden
layers also entail more sparsity, which prevents the ﬂow of derivatives. Also, as sparse activations
propagate upwards through the network, they tend to proliferate, aggravating the problem in higher
layers.

The authors would like to thank the developers of Theano (Bastien et al., 2012). We acknowledge the
support of the following agencies for research funding and computing support: Samsung, NSERC,
Calcul Qu´ebec, Compute Canada, the Canada Research Chairs and CIFAR.

ACKNOWLEDGMENTS

REFERENCES

Ba, Jimmy and Caruana, Rich. Do deep nets really need to be deep?

In Advances in Neural

Information Processing Systems, pp. 2654–2662, 2014.

Baldi, P. and Hornik, K. Neural networks and principal component analysis: Learning from exam-

ples without local minima. Neural networks, 2(1), 1989.

Bastien, Fr´ed´eric, Lamblin, Pascal, Pascanu, Razvan, Bergstra, James, Goodfellow, Ian J., Bergeron,
Arnaud, Bouchard, Nicolas, and Bengio, Yoshua. Theano: new features and speed improvements.
Deep Learning and Unsupervised Feature Learning NIPS 2012 Workshop, 2012.

Cybenko, George. Approximation by superpositions of a sigmoidal function. Mathematics of con-

trol, signals and systems, 2(4):303–314, 1989.

DeGroot, Morris H, Schervish, Mark J, Fang, Xiangzhong, Lu, Ligang, and Li, Dongfeng. Proba-

bility and statistics, volume 2. Addison-Wesley Reading, MA, 1986.

Funahashi, Ken-Ichi. On the approximate realization of continuous mappings by neural networks.

Neural networks, 2(3):183–192, 1989.

Goodfellow, Ian J, Warde-Farley, David, Mirza, Mehdi, Courville, Aaron, and Bengio, Yoshua.

Maxout networks. arXiv preprint arXiv:1302.4389, 2013.

He, Kaiming, Zhang, Xiangyu, Ren, Shaoqing, and Sun, Jian. Delving deep into rectiﬁers: Sur-
passing human-level performance on imagenet classiﬁcation. arXiv preprint arXiv:1502.01852,
2015.

Hochreiter, Sepp, Bengio, Yoshua, Frasconi, Paolo, and Schmidhuber, J¨urgen. Gradient ﬂow in

recurrent nets: the difﬁculty of learning long-term dependencies, 2001.

Ioffe, Sergey and Szegedy, Christian. Batch normalization: Accelerating deep network training by

reducing internal covariate shift. arXiv preprint arXiv:1502.03167, 2015.

Konda, Kishore, Memisevic, Roland, and Krueger, David. Zero-bias autoencoders and the beneﬁts

of co-adapting features. stat, 1050:20, 2014.

Krizhevsky, Alex and Hinton, Geoffrey. Learning multiple layers of features from tiny images.

Computer Science Department, University of Toronto, Tech. Rep, 1(4):7, 2009.

9

Under review as a conference paper at ICLR 2016

Krizhevsky, Alex, Sutskever, Ilya, and Hinton, Geoffrey E. Imagenet classiﬁcation with deep convo-
lutional neural networks. In Advances in neural information processing systems, pp. 1097–1105,
2012.

Le, Quoc, Sarlos, Tamas, and Smola, Alex. Fastfood - approximating kernel expansions in loglinear

time. In 30th International Conference on Machine Learning (ICML), 2013.

Sainath, Tara N, Kingsbury, Brian, Sindhwani, Vikas, Arisoy, Ebru, and Ramabhadran, Bhuvana.
Low-rank matrix factorization for deep neural network training with high-dimensional output tar-
gets. In Acoustics, Speech and Signal Processing (ICASSP), 2013 IEEE International Conference
on, pp. 6655–6659. IEEE, 2013.

Saxe, Andrew M, McClelland, James L, and Ganguli, Surya. Exact solutions to the nonlinear dy-

namics of learning in deep linear neural networks. arXiv preprint arXiv:1312.6120, 2013.

Srivastava, Nitish, Hinton, Geoffrey, Krizhevsky, Alex, Sutskever, Ilya, and Salakhutdinov, Ruslan.
Dropout: A simple way to prevent neural networks from overﬁtting. The Journal of Machine
Learning Research, 15(1):1929–1958, 2014.

Torralba, Antonio, Fergus, Robert, and Freeman, William T. 80 million tiny images: A large data
set for nonparametric object and scene recognition. Pattern Analysis and Machine Intelligence,
IEEE Transactions on, 30(11):1958–1970, 2008.

Xue, Jian, Li, Jinyu, and Gong, Yifan. Restructuring of deep neural network acoustic models with

singular value decomposition. 2013.

10

