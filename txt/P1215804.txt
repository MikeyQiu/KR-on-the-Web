This manuscript is the pre-submission manuscript provided by the authors.
For the ﬁnal, post-review version, please see: http://dx.doi.org/10.1038/nature14422

Robots that can adapt like animals

Antoine Cully,1,2 Jeff Clune,6 Danesh Tarapore,1,2 Jean-Baptiste Mouret1−5,∗

5
1
0
2
 
y
a
M
 
7
2
 
 
]

O
R
.
s
c
[
 
 
4
v
1
0
5
3
.
7
0
4
1
:
v
i
X
r
a

As robots leave the controlled environments of factories to
autonomously function in more complex, natural environ-
ments1,2,3, they will have to respond to the inevitable fact that
they will become damaged4,5. However, while animals can
quickly adapt to a wide variety of injuries, current robots can-
not “think outside the box” to ﬁnd a compensatory behavior
when damaged:
they are limited to their pre-speciﬁed self-
sensing abilities, can diagnose only anticipated failure modes6,
and require a pre-programmed contingency plan for every type
of potential damage, an impracticality for complex robots4,5.
Here we introduce an intelligent trial and error algorithm that
allows robots to adapt to damage in less than two minutes,
without requiring self-diagnosis or pre-speciﬁed contingency
plans. Before deployment, a robot exploits a novel algorithm
to create a detailed map of the space of high-performing behav-
iors: This map represents the robot’s intuitions about what be-
haviors it can perform and their value. If the robot is damaged,
it uses these intuitions to guide a trial-and-error learning algo-
rithm that conducts intelligent experiments to rapidly discover
a compensatory behavior that works in spite of the damage. Ex-
periments reveal successful adaptations for a legged robot in-
jured in ﬁve different ways, including damaged, broken, and
missing legs, and for a robotic arm with joints broken in 14
different ways. This new technique will enable more robust,
effective, autonomous robots, and suggests principles that ani-
mals may use to adapt to injury.

Robots have transformed the economics of many industries,
most notably manufacturing7, and have the power to deliver
tremendous beneﬁts to society, such as in search and rescue8,
disaster response9, health care3, and transportation10. They are
also invaluable tools for scientiﬁc exploration, whether of distant
planets1,4 or deep oceans2. A major obstacle to their widespread
adoption in more complex environments outside of factories is
their fragility4,5: Robots presently pale in comparison to natural
animals in their ability to invent compensatory behaviors after an
injury (Fig. 1A).

Current damage recovery in robots typically involves two
phases: self-diagnosis, and then selecting the best, pre-designed
contingency plan11,12,13,14. Such self-diagnosing robots are expen-
sive, because self-monitoring sensors are expensive, and are difﬁ-
cult to design, because robot engineers cannot foresee every pos-
sible situation: this approach often fails either because the diag-
nosis is incorrect12,13 or because an appropriate contingency plan
is not provided14.

Injured animals respond differently: they learn by trial and
learning which
error how to compensate for damage (e.g.
limp minimizes pain)15,16. Similarly, trial-and-error learning al-
gorithms could allow robots to creatively discover compensatory
behaviors without being limited to their designers’ assumptions
about how damage may occur and how to compensate for each
damage type. However, state-of-the-art learning algorithms are
impractical because of the “curse of dimensionality”17: the fastest

1 Sorbonne Universités, UPMC Univ Paris 06, UMR 7222, ISIR, F-75005, Paris
2 CNRS, UMR 7222, ISIR, F-75005, Paris, France
3 Inria, Villers-lès-Nancy, F-54600, France
4 CNRS, Loria, UMR 7503, Vandœuvre-lès-Nancy, F-54500, France
5 Université de Lorraine, Loria, UMR 7503, Vandœuvre-lès-Nancy, F-54500,
France
6 University of Wyoming, Laramie, WY, USA
∗ Corresponding author: jean-baptiste.mouret@inria.fr

tun-
algorithms constrain the search to a few behaviors (e.g.
ing only 2 parameters, requiring 5-10 minutes) or require human
demonstrations17. Algorithms without these limitations take sev-
eral hours17. Damage recovery would be much more practical
and effective if robots adapted as creatively and quickly as an-
imals (e.g.
in minutes) and without expensive self-diagnosing
sensors.

Here, we show that rapid adaptation can be achieved by guid-
ing an intelligent trial-and-error learning algorithm with an auto-
matically generated, pre-computed, behavior-performance map
that predicts the performance of thousands of different behaviors
(Supplementary Video S1). The key insight is that, whereas cur-
rent learning algorithms either start with no knowledge of the
search space17 or with minimal knowledge from a few human
demonstrations17,18, animals better understand the space of pos-
sible behaviors and their value from previous experience19, en-
abling injured animals to intelligently select tests that validate or
invalidate whole families of promising compensatory behaviors.
We have robots store knowledge from previous experience in
the form of a map of the behavior-performance space. Guided
by this map, a damaged robot tries different types of behaviors
that are predicted to perform well and, as tests are conducted, up-
dates its estimates of the performance of those types of behaviors.
The process ends when the robot predicts that the most effective
behavior has already been discovered. The result is a robot that
quickly discovers a way to compensate for damage (e.g. Fig. 1C)
without a detailed mechanistic understanding of its cause, as oc-
curs with animals. We call this approach “Intelligent Trial and
Error” (Fig. 1D).

The behavior-performance map is created with a novel algo-
rithm and a simulation of the robot, which either can be a stan-
dard physics simulator or can be automatically discovered12. The
robot’s designers only have to describe the dimensions of the
space of possible behaviors and a performance measure. For
instance, walking gaits could be described by how much each
leg is involved in a gait (a behavioral measure) and speed (a
performance measure). For grasping, performance could be the
amount of surface contact, and it has been demonstrated that 90%
of effective poses for the 21-degree-of-freedom human hand can
be captured by a 3-dimensional behavioral space20. To ﬁll in the
behavior-performance map, an optimization algorithm simulta-
neously searches for a high-performing solution at each point in
the behavioral space (Fig. 2A,B and Extended Data Fig. 1). This
step requires simulating millions of behaviors, but needs to be
performed only once per robot design before deployment (Meth-
ods).

A low conﬁdence is assigned to the predicted performance
of behaviors stored in this behavior-performance map because
they have not been tried in reality (Fig. 2B and Extended Data
Fig. 1). During the robot’s mission, if it senses a performance
drop, it selects the most promising behavior from the behavior-
performance map, tests it, and measures its performance. The
robot subsequently updates its prediction for that behavior and
nearby behaviors, assigns high conﬁdence to these predictions
(Fig. 2C and Extended Data Fig. 1), and continues the selec-
tion/test/update process until it ﬁnds a satisfactory compen-
satory behavior (Fig. 2D and Extended Data Fig. 1).

All of these ideas are technically captured via a Gaussian
process model21, which approximates the performance function

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 1

Figure 1| With Intelligent Trial and Error, robots, like animals, can quickly adapt to recover from damage. (A) Most animals can ﬁnd a compen-
satory behavior after an injury. Without relying on predeﬁned compensatory behaviors, they learn how to avoid behaviors that are painful or no longer
effective. (B) An undamaged, hexapod robot. (C) One type of damage the hexapod may have to cope with (broken leg). (D) After damage occurs, in
this case making the robot unable to walk straight, damage recovery via Intelligent Trial and Error begins. The robot tests different types of behaviors
from an automatically generated map of the behavior-performance space. After each test, the robot updates its predictions of which behaviors will
perform well despite the damage. This way, the robot rapidly discovers an effective compensatory behavior.

with already acquired data, and a Bayesian optimization proce-
dure22,23, which exploits this model to search for the maximum
of the performance function (Methods). The robot selects which
behaviors to test by maximizing an information acquisition func-
tion that balances exploration (selecting points whose perfor-
mance is uncertain) and exploitation (selecting points whose per-
formance is expected to be high) (Methods). The selected behav-
ior is tested on the physical robot and the actual performance is
recorded. The algorithm updates the expected performance of
the tested behavior and lowers the uncertainty about it. These
updates are propagated to neighboring solutions in the behav-
ioral space by updating the Gaussian process (Methods). These
updated performance and conﬁdence distributions affect which
behavior is tested next. This select-test-update loop repeats un-
til the robot ﬁnds a behavior whose measured performance is
greater than 90% of the best performance predicted for any be-
havior in the behavior-performance map (Methods).

We ﬁrst test our algorithm on a hexapod robot that needs to
walk as fast as possible (Fig. 1B, D). The robot has 18 motors, an
onboard computer, and a depth camera that allows the robot to
estimate its walking speed (Supplementary Methods). The gait
is parametrized by 36 real-valued parameters that describe the
amplitude of oscillation, phase shift, and duty cycle for each joint
(Supplementary Methods). The behavior space is 6-dimensional,
where each dimension is the proportion of time the ith leg spends
in contact with the ground (i.e. the duty factor)7 (Supplementary
Methods).

The created behavior-performance map contains approxi-
mately 13,000 different gaits (Supplementary Video S2 shows ex-
amples). We tested our robot in six different conditions: undam-
aged (Fig. 3A:C1), four different structural failures (Fig. 3A:C2-
C5), and a temporary leg repair (Fig. 3A:C6). We compare
the walking speed of resultant gaits with a widely-used, classic,
hand-designed tripod gait7 (Supplementary Methods). For each
of the 6 damage conditions, we ran our adaptation step 5 times
for each of 8 independently generated behavior-performance
maps (with the default “duty factor” behavioral description),
leading to 6 × 5 × 8 = 240 experiments in total. We also ran our
adaptation step 5 times on 8 independently generated behavior-
performance maps deﬁned by an alternate behavioral descrip-

tion (“body orientation”, see Supplementary Methods) on two
damage conditions (Fig. 3B-C), leading to 2 × 5 × 8 = 80 addi-
tional experiments.

When the robot is undamaged (Fig. 3A:C1), our approach
yields dynamic gaits that are 30% faster than the classic reference
gait (Fig. 3B, median 0.32 m/s, 5th and 95th percentiles [0.26;
0.36] vs. 0.24m/s), suggesting that Intelligent Trial and Error is
a good search algorithm for automatically producing successful
robot behaviors, putting aside damage recovery. In all the dam-
age scenarios, the reference gait is no longer effective (~0.04 m/s
for the four damage conditions, Fig. 3B:C2-C5). After Intelligent
Trial and Error, the compensatory gaits achieve a reasonably fast
speed (> 0.15m/s) and are between 3 and 7 times more efﬁcient
than the reference gait for that damage condition (in m/s, C2:
0.24 [0.18; 0.31] vs. 0.04; C3: 0.22 [0.18; 0.26] vs. 0.03; C4: 0.21
[0.17; 0.26] vs. 0.04; C5: 0.17 [0.12; 0.24] vs. 0.05; C6: 0.3 [0.21;
0.33] vs 0.12).

These experiments demonstrate that Intelligent Trial and Error
allows the robot to both initially learn fast gaits and to reliably re-
cover after physical damage. Additional experiments reveal that
these capabilities are substantially faster than state-of-the-art al-
gorithms (Extended Data Fig. 2), and that Intelligent Trial and Er-
ror can help with another major challenge in robotics: adapting
to new environments (Extended Data Fig. 3). On the undam-
aged or repaired robot (Fig. 3: C6), Intelligent Trial and Error
learns a walking gait in less than 30 seconds (Fig. 3C, undam-
aged: 24 [16; 41] seconds, 3 [2; 5] physical trials, repaired: 29 [16;
82] seconds, 3.5 [2; 10] trials). For the four damage scenarios, the
robot adapts in approximately one minute (66 [24; 134] seconds,
8 [3; 16] trials). Our results are qualitatively unchanged when
using different behavioral characterizations, including randomly
choosing 6 descriptors among 63 possibilities (Fig. 3B-C and Ex-
tended Data Fig. 4). Additional experiments show that reducing
the high-dimensional parameter space to a low-dimensional be-
havior space via the behavior-performance map is the key com-
ponent for intelligent trial and error: standard Bayesian opti-
mization in the original parameter space does not ﬁnd working
controllers (Extended Data Fig. 2).

We investigated how the behavior-performance map is up-
dated when the robot loses a leg (Fig. 3A:C4). Initially the map

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 2

Figure 2| (A & B). Creating the behavior-performance map: A user reduces a high-dimensional search space to a low-dimensional behavior space by
deﬁning dimensions along which behaviors vary. In simulation, the high-dimensional space is then automatically searched to ﬁnd a high-performing
behavior at each point in the low-dimensional behavior space, creating a “behavior-performance” map of the performance potential of each location
in the low-dimensional space. In our hexapod robot experiments, the behavior space is six-dimensional: the portion of time that each leg is in contact
with the ground. The conﬁdence regarding the accuracy of the predicted performance for each behavior in the behavior-performance map is initially
low because no tests on the physical robot have been conducted. (C & D) Adaptation Step: After damage, the robot selects a promising behavior, tests
it, updates the predicted performance of that behavior in the behavior-performance map, and sets a high conﬁdence on this performance prediction.
The predicted performances of nearby behaviors–and conﬁdence in those predictions–are likely to be similar to the tested behavior and are thus
updated accordingly. This select/test/update loop is repeated until a tested behavior on the physical robot performs better than 90% of the best
predicted performance in the behavior-performance map, a value that can decrease with each test (Extended Data Fig. 1). The algorithm that selects
which behavior to test next balances between choosing the behavior with the highest predicted performance and behaviors that are different from
those tested so far. Overall, the Intelligent Trial and Error approach presented here rapidly locates which types of behaviors are least affected by the
damage to ﬁnd an effective, compensatory behavior.

predicts large areas of high performance. During adaptation,
these areas disappear because the behaviors do not work well on
the damaged robot. Intelligent Trial and Error quickly identiﬁes
one of the few, remaining, high-performance behaviors (Fig. 4
and Extended Data Fig. 5 and 6).

The same damage recovery approach can be applied to any
robot, such as a robotic arm. We tested 14 different damage con-
ditions with a planar, 8-joint robotic arm (Fig. 3D-F and Extended
Data Fig. 7). The behavior-performance map’s behavioral dimen-
sions are the x, y position of the end-effector and the performance
measure is minimizing the variance of the 8 speciﬁed motor an-
gles (Supplementary Methods). During adaptation, performance
is measured as distance to the target. Like with the hexapod
robot, our approach discovers a compensatory behavior in less
than 2 minutes, usually in less than 30 seconds, and with fewer
than 10 trials (Fig. 3F and Extended Data Fig. 7).

While natural animals do not use the speciﬁc algorithm we
present, there are parallels between Intelligent Trial and Error
and animal learning. Like animals, our robot does not have a
predeﬁned strategy for how to cope with every possible dam-
age condition: in the face of a new injury, it exploits its intuitions
about how its body works to experiment with different behaviors
to ﬁnd what works best. Also like animals24, Intelligent Trial and
Error allows the quick identiﬁcation of working behaviors with a
few, diverse tests instead of trying behaviors at random or trying
small modiﬁcations to the best behavior found so far. Addition-
ally, the Bayesian optimization procedure followed by our robot
appears similar to the technique employed by humans when they
optimize an unknown function23, and there is strong evidence
that animal brains learn probability distributions, combine them
with prior knowledge, and act as Bayesian optimizers25,26.

An additional parallel is that Intelligent Trial and Error primes
the robot for creativity during a motionless period, after which

the generated ideas are tested. This process is reminiscent of
the ﬁnding that some animals start the day with new ideas that
they may quickly disregard after experimenting with them27,
and more generally, that sleep improves creativity on cognitive
tasks28. A ﬁnal parallel is that the simulator and Gaussian process
components of Intelligent Trial and Error are two forms of predic-
tive models, which are known to exist in animals29,12. All told, we
have shown that combining pieces of nature’s algorithm, even if
differently assembled, moves robots more towards animals by
endowing them with the ability to rapidly adapt to unforeseen
circumstances.

Supplementary Information and methods are appended at
the end of this document.

Acknowledgments. Thanks to Luigi Tedesco, Stéphane Don-
cieux, Nicolas Bredeche, Shimon Whiteson, Roberto Calandra,
Jacques Droulez, Pierre Bessière, Florian Lesaint, Charles Thu-
rat, Serena Ivaldi, Jingyu Li, Joost Huizinga, Roby Velez, Henok
Mengistu, Tim Clune, and Anh Nguyen for helpful feedback and
discussions. Thanks to Michael Brashier for the photo of the
three-legged dog.

This work has been funded by the ANR Creadapt project (ANR-
12-JS03-0009), the European Research Council (ERC) under
the European Union’s Horizon 2020 research and innovation
programme (grant agreement number 637972), and a Direction
Géneérale de l’Armement (DGA) scholarship to A.C.

Author Contributions A.C. and J.-B. M designed the study.
A.C. and D.T. performed the experiments. A.C., J.-B. M, D.T. and
J.C. discussed additional experiments, analyzed the results, and
wrote the paper.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 3

Figure 3| (A) Conditions tested on
the physical hexapod robot. C1: The
undamaged robot. C2: One leg is
shortened by half. C3: One leg is
unpowered. C4: One leg is miss-
ing. C5: Two legs are missing. C6:
A temporary, makeshift repair to the
(B) Performance af-
tip of one leg.
ter adaptation. Box plots represent
Intelligent Trial and Error. The cen-
tral mark is the median, the edges
of the box are the 25th and 75th per-
centiles, the whiskers extend to the
most extreme data points not consid-
ered outliers, and outliers are plotted
individually. Yellow stars represent
the performance of the handmade
reference tripod gait (Supplementary
Methods).
Conditions C1-C6 are
tested 5 times each for 8 indepen-
dently created behavior-performance
maps with the “duty factor” behav-
ior description (i.e. 40 experiments
per damage condition, Supplemen-
tary Methods). Damage conditions
C1 and C3 are also tested 5 times
each for 8 independently created
behavior-performance maps with the
“body orientation” behavior descrip-
(C)
tion (Supplementary Methods).
Time and number of trials required
to adapt. Box plots represent Intel-
(D) Robotic
ligent Trial and Error.
arm experiment. The 8-joint, planar
robot has to drop a ball into a bin.
(E) Example conditions tested on the
physical robotic arm. C1: One joint
is stuck at 45 degrees. C2: One joint
has a permanent 45-degree offset. C3:
One broken and one offset joint. A to-
tal of 14 conditions were tested (Ex-
(F) Time and
tended Data Fig. 7).
number of trials required to reach
within 5 cm of the bin center. Each
condition is tested with 15 indepen-
dently created behavior-performance
maps.

Figure 4| An example behavior-performance map. This map stores high-performing behaviors at each point in a six-dimensional behavior space.
Each dimension is the portion of time that each leg is in contact with the ground. The behavioral space is discretized at ﬁve values for each dimension
(0; 0.25; 0.5; 0.75; 1). Each colored pixel represents the highest-performing behavior discovered during map creation at that point in the behavior space.
The matrices visualize the six-dimensional behavioral space in two dimensions according to the legend in the top-left. The behavior-performance
map is created with a simulated robot (bottom left) in the Open Dynamics Engine physics simulator (http://www.ode.org). The left matrix is a
pre-adaptation map produced by the map creation algorithm. During adaptation, the map is updated as tests are conducted (in this case, in the
damage condition where the robot is missing one leg: Fig. 3A:C4). The right matrix shows the state of the map after a compensatory behavior
is discovered. The arrows and white circles represent the order in which behaviors were tested on the physical robot. The red circle is the ﬁnal,
discovered, compensatory behavior. Amongst other areas, high-performing behaviors can be found for the damaged robot in the ﬁrst two columns
of the third dimension. These columns represent behaviors that least use the central-left leg, which is the leg that is missing.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 4

Author information Correspondence and requests for ma-
terials should be addressed to J.-B. M.
jean-
baptiste.mouret@inria.fr).

(email:

1.

J. G. Bellingham and K. Rajan. “Robotics in remote and hostile environ-
ments.” In: Science 318.5853 (Nov. 2007), pp. 1098–102. ISSN: 1095-9203.
DOI: 10.1126/science.1146230.

2. D. R. Yoerger. “Underwater robotics”. In: Springer handbook of robotics.

Springer, 2008, pp. 987–1008.

3. E. Broadbent, R. Stafford, and B. MacDonald. “Acceptance of healthcare
robots for the older population: review and future directions”. In: International
Journal of Social Robotics 1.4 (2009), pp. 319–330.

4. K. Sanderson. “Mars rover Spirit (2003-10)”. In: Nature 463.7281 (2010),

5.

p. 600.
J. Carlson and R. R. Murphy. “How UGVs physically fail in the ﬁeld”. In: IEEE
Transactions on Robotics 21.3 (2005), pp. 423–437.

6. M. Blanke and J. Schröder. Diagnosis and fault-tolerant control. Springer,

2006.

7. B. Siciliano and O. Khatib. Springer handbook of robotics. Springer, 2008.
8. R. R. Murphy. “Trial by ﬁre [rescue robots]”. In: Robotics & Automation Mag-

22.

azine, IEEE 11.3 (2004), pp. 50–61.

9. K. Nagatani, S. Kiribayashi, Y. Okada, K. Otake, K. Yoshida, S. Tadokoro,
T. Nishimura, T. Yoshida, E. Koyanagi, M. Fukushima, and S. Kawatsuma.
“Emergency response to the nuclear accident at the Fukushima Daiichi Nu-
clear Power Plants using mobile rescue robots”. In: Journal of Field Robotics
30.1 (2013), pp. 44–63.

10. S. Thrun, M. Montemerlo, H. Dahlkamp, D. Stavens, A. Aron, J. Diebel, P.
Fong, J. Gale, M. Halpenny, G. Hoffmann, et al. “Stanley: The robot that
won the DARPA Grand Challenge”. In: Journal of ﬁeld Robotics 23.9 (2006),
pp. 661–692.

11. V. Verma, G. Gordon, R. Simmons, and S. Thrun. “Real-time fault diagnosis”.

12.

In: Robotics & Automation Magazine 11.2 (2004), pp. 56–66.
J. Bongard, V. Zykov, and H. Lipson. “Resilient machines through continuous
self-modeling”. In: Science 314.5802 (2006), pp. 1118–1121.

13. W. G. Fenton, T. M. McGinnity, and L. P. Maguire. “Fault diagnosis of elec-
tronic systems using intelligent techniques: a review”. In: IEEE Transactions
on Systems, Man, and Cybernetics, Part C: Applications and Reviews 31.3
(2001), pp. 269–281.
J. Kluger and J. Lovell. Apollo 13. Mariner Books, 2006.
0618619580.

ISBN: 978-

14.

15. S. L. Jarvis, D. R. Worley, S. M. Hogy, A. E Hill, K. K. Haussler, and R. F.
Reiser II. “Kinematic and kinetic analysis of dogs during trotting after ampu-
tation of a thoracic limb”. In: American journal of veterinary research 74.9
(2013), pp. 1155–1163.

16. A Fuchs, B Goldner, I Nolte, and N Schilling. “Ground reaction force adap-
tations to tripedal locomotion in dogs.” In: Veterinary journal 201.3 (Sept.
2014), pp. 307–15. ISSN: 1532-2971. DOI: 10.1016/j.tvjl.2014.05.012.
J. Kober, J. A. Bagnell, and J. Peters. “Reinforcement learning in robotics:
a survey”. In: The International Journal of Robotics Research 32.11 (2013),
pp. 1238–1274. DOI: 10.1177/0278364913495721.

17.

18. B. D. Argall, S. Chernova, M. Veloso, and B. Browning. “A survey of robot
learning from demonstration”. In: Robotics and autonomous systems 57.5
(2009), pp. 469–483.

19. E. Thelen. “Motor development: a new synthesis”. In: American psychologist

(1995), pp. 79–95.

20. M. Santello. “Postural hand synergies for tool use”. In: The Journal of Neuro-

science 18.23 (1998), pp. 10105–10115.

21. C. E. Rasmussen and C. K. I. Williams. Gaussian processes for machine

learning. MIT Press, 2006. ISBN: 0-262-18253-X.
J. Mockus. Bayesian approach to global optimization: theory and applica-
tions. Kluwer Academic, 2013.

23. A. Borji and L. Itti. “Bayesian optimization explains human active search”.
In: Advances in Neural Information Processing Systems 26 (NIPS). 2013,
pp. 55–63.

24. S. Benson-Amram and K. E. Holekamp. “Innovative problem solving by wild
spotted hyenas”. In: Proceedings of the Royal Society B: Biological Sciences
279.1744 (2012), pp. 4087–4095.

25. A. Pouget, J. M. Beck, W. J. Ma, and P. E. Latham. “Probabilistic brains:
knowns and unknowns”. In: Nature neuroscience 16.9 (2013), pp. 1170–
1178.

26. K. P. Körding and D. M. Wolpert. “Bayesian integration in sensorimotor learn-

ing”. In: Nature 427.6971 (2004), pp. 244–247.

27. S. Derégnaucourt, P. P. Mitra, O. Fehér, C. Pytte, and O. Tchernichovski.
learning of bird song”. In: Nature

“How sleep affects the developmental
433.7027 (2005), pp. 710–716.

28. U. Wagner, S. Gais, H. Haider, R. Verleger, and J. Born. “Sleep inspires

insight”. In: Nature 427.6972 (2004), pp. 352–355.

29. M. Ito. “Control of mental activities by internal models in the cerebellum”. In:

Nature Reviews Neuroscience 9.4 (2008), pp. 304–313.

5

1 Methods

Notations

• c: Parameters of a controller (vector)
• x: A location in a discrete behavioral space (i.e. a type of

behavior) (vector)

• χ: A location in a discrete behavioral space that has been

tested on the physical robot (vector)

• P: Behavior-performance map (stores performance) (asso-

• C: Behavior-performance map (stores controllers) (associa-

ciative table)

tive table)

• P(x): Max performance yet encountered at x (scalar)
• C(x): Controller currently stored in x (vector)
• χ1:t: All previously tested behavioral descriptors at time t

(vector of vectors)

• P1:t: Performance in reality of all the candidate solutions

tested on the robot up to time t (vector)

• P(χ1:t): Performance in the behavior-performance map for
all the candidate solutions tested on the robot up to time t
(vector)

• f (): Performance function (unknown by the algorithm)

(function)

• σ2

(scalar)

(function)

noise: Observation noise (a user-speciﬁed parameter)

• k(x, x): Kernel function (see section “kernel function”)

• K: Kernel matrix (matrix)
• k: Kernel vector [k(x, χ1), k(x, χ2), ..., k(x, χt)] (vector)
• µt(x): Predicted performance for x (i.e.

the mean of the

Gaussian process) (function)

• σ2

t (x): Standard deviation for x in the Gaussian process

(function)

1.1 Intelligent Trial and Error algorithm (IT&E)

The Intelligent Trial and Error Algorithm consists of two major
steps (Extended Data Fig. 1):
the behavior-performance map
creation step and the adaptation step (while here we focus on
damage recovery, Intelligent Trial and Error can search for any
type of required adaptation, such as learning an initial gait for
an undamaged robot, adapting to new environments, etc.). The
behavior-performance map creation step is accomplished via a
new algorithm introduced in this paper called multi-dimensional
archive of phenotypic elites (MAP-Elites), which is explained
in the next section. The adaptation step is accomplished via a
second new algorithm introduced in this paper called the map-
based Bayesian optimization algorithm (M-BOA), which is ex-
plained in the “Adaptation Step” section below.

1.2 Behavior-performance map creation (via the

MAP-Elites algorithm)

The behavior-performance map is created by a new algorithm we
introduce in this paper called the multi-dimensional archive of
phenotypic elites (MAP-Elites) algorithm. MAP-Elites searches
for the highest-performing solution for each point in a user-
deﬁned space: the user chooses the dimensions of the space that
they are interested in seeing variation in. For example, when de-
signing robots, the user may be interested in seeing the highest-
performing solution at each point in a two-dimensional space
where one axis is the weight of the robot and the other axis is the
height of the robot. Alternatively, a user may wish to see weight
vs. cost, or see solutions throughout a 3D space of weight vs. cost
vs. height. Any dimension that can vary could be chosen by the
user. There is no limit on the number of dimensions that can be
chosen, although it becomes computationally more expensive to

ﬁll the behavior-performance map and store it as the number of
dimensions increases. It also becomes more difﬁcult to visualize
the results. We refer to this user-deﬁned space as the “behavior
space”, because usually the dimensions of variation measure be-
havioral characteristics. Note that the behavioral space can refer
to other aspects of the solution (as in this example, where the di-
mensions of variation are physical properties of a robot such as
its height and weight).

If the behavior descriptors and the parameters of the con-
troller are the same (i.e.
if there is only one possible so-
lution/genome/parameter set/policy/description for each lo-
cation in the behavioral space),
then creating the behavior-
performance map is straightforward: one simply needs to simu-
late the solution at each location in the behavior space and record
the performance. However, if it is not known a priori how to
produce a controller/parameter set/description that will end up
in a speciﬁc location in the behavior space (i.e. if the parameter
space is of higher dimension than the behavioral space: e.g., in
our example, if there are many different robot designs of a spe-
ciﬁc weight, height, and cost, or if it is unknown how to make
a description that will produce a robot with a speciﬁc weight,
height, and cost), then MAP-Elites is beneﬁcial. It will efﬁciently
search for the highest-performing solution at each point of the
low-dimensional behavioral space. It is more efﬁcient than a ran-
dom sampling of the search space because high-performing so-
lutions are often similar in many ways, such that randomly alter-
ing a high-performing solution of one type can produce a high-
performing solution of a different type (see Extended Data Fig.
10 and Supplementary Experiment S4). For this reason, search-
ing for high-performing solutions of all types simultaneously is
much quicker than separately searching for each type. For exam-
ple, to generate a lightweight, high-performing robot design, it
tends to be more effective and efﬁcient to modify an existing de-
sign of a light robot rather than randomly generate new designs
from scratch or launch a separate search process for each new
type of design.

MAP-Elites begins by generating a set of random candidate
solutions. It then evaluates the performance of each solution and
records where that solution is located in the behavior space (e.g.
if the dimensions of the behavior space are the height and weight,
it records the height and weight of each robot in addition to its
performance). For each solution, if its performance is better than
the current solution at that location in the behavior-performance
map, then it is added to the behavior-performance map, replac-
ing the solution in that location. In other words, it is only kept if
it is the best of that type of solution, where “type” is deﬁned as
a location in the behavior space. There is thus only one solution
kept at each location in the behavior space (keeping more could
be beneﬁcial, but for computational reasons we only keep one).
If no solution is present in the behavior-performance map at that
location, then the newly generated candidate solution is added
at that location.

Once this initialization step is ﬁnished, Map-Elites enters a
loop that is similar to stochastic, population-based, optimization
algorithms, such as evolutionary algorithms30: the solutions that
are in the behavior-performance map form a population that is
improved by random variation and selection. In each generation,
the algorithm picks a solution at random via a uniform distri-
bution, meaning that each solution has an equal chance of being
chosen. A copy of the selected solution is then randomly mutated
to change it in some way, its performance is evaluated, its loca-
tion in the behavioral space is determined, and it is kept if it out-
performs the current occupant at that point in the behavior space
(note that mutated solutions may end up in different behavior
space locations than their “parents”). This process is repeated
until a stopping criterion is met (e.g. after a ﬁxed amount of time
has expired). In our experiments, we stopped each MAP-Elites
run after 40 million iterations. Because MAP-Elites is a stochastic

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 6

(A) Behavior-performance map creation. After being
Extended Data Figure 1 | An overview of the Intelligent Trial and Error Algorithm.
initialized with random controllers, the behavioral map (A2), which stores the highest-performing controller found so far of each behavior type,
is improved by repeating the process depicted in (A1) until newly generated controllers are rarely good enough to be added to the map (here,
after 40 million evaluations). This step, which occurs in simulation, is computationally expensive, but only needs to be performed once per robot
(or robot design) prior to deployment.
In our experiments, creating one map involved 40 million iterations of (A1), which lasted roughly two
weeks on one multi-core computer (Supplementary Methods, section “Running time”). (B) Adaptation. (B1) Each behavior from the behavior-
performance map has an expected performance based on its performance in simulation (dark green line) and an estimate of uncertainty regarding
this predicted performance (light green band). The actual performance on the now-damaged robot (black dashed line) is unknown to the algorithm.
A behavior is selected to try on the damaged robot. This selection is made by balancing exploitation—trying behaviors expected to perform well—
and exploration—trying behaviors whose performance is uncertain (Methods, section “acquisition function”). Because all points initially have equal,
maximal uncertainty, the ﬁrst point chosen is that with the highest expected performance. Once this behavior is tested on the physical robot (B4),
the performance predicted for that behavior is set to its actual performance, the uncertainty regarding that prediction is lowered, and the predictions
for, and uncertainties about, nearby controllers are also updated (according to a Gaussian process model, see Methods, section “kernel function”),
the results of which can be seen in (B2). The process is then repeated until performance on the damaged robot is 90% or greater of the maximum
expected performance for any behavior (B3). This performance threshold (orange dashed line) lowers as the maximum expected performance (the
highest point on the dark green line) is lowered, which occurs when physical tests on the robot underperform expectations, as occurred in (B2).

search process, each resultant behavior-performance map can be
different, both in terms of the number of locations in the behav-
ioral space for which a candidate is found, and in terms of the
performance of the candidate in each location.

The pseudo-code of the algorithm is available in Supplemen-
tary Figure 8. More details and experiments about MAP-Elites
are available in (Mouret and Clune, 2015)31.

tainty associated with each prediction. For a cost function f , usu-
ally unknown, a Gaussian process deﬁnes the probability distri-
bution of the possible values f (x) for each point x. These prob-
ability distributions are Gaussian, and are therefore deﬁned by a
mean (µ) and a standard deviation (σ). However, µ and σ can be
different for each x; we therefore deﬁne a probability distribution
over functions:

1.3 Adaptation step (via M-BOA: the map-based

Bayesian optimization algorithm)

The adaptation step is accomplished via a Bayesian optimization
algorithm seeded with a behavior-performance map. We call this
approach a map-based Bayesian optimization algorithm, or M-
BOA.

Bayesian optimization is a model-based, black-box optimiza-
tion algorithm that is tailored for very expensive objective func-
tions (a.k.a. cost functions)32,33,22,34,35,23. As a black-box optimiza-
tion algorithm, Bayesian optimization searches for the maximum
of an unknown objective function from which samples can be ob-
tained (e.g., by measuring the performance of a robot). Like all
model-based optimization algorithms (e.g. surrogate-based algo-
rithms36,37,38, kriging39, or DACE40,41), Bayesian optimization cre-
ates a model of the objective function with a regression method,
uses this model to select the next point to acquire, then updates
the model, etc. It is called Bayesian because, in its general for-
mulation22, this algorithm chooses the next point by computing
a posterior distribution of the objective function using the like-
lihood of the data already acquired and a prior on the type of
function.

Here we use Gaussian process regression to ﬁnd a model21,
which is a common choice for Bayesian optimization42,35,33,32.
Gaussian processes are particularly interesting for regression be-
cause they not only model the cost function, but also the uncer-

P (f (x)|x) = N (µ(x), σ2(x))

(1)

where N denotes the standard normal distribution.

To estimate µ(x) and σ(x), we need to ﬁt the Gaussian process
to the data. To do so, we assume that each observation f (χ) is a
sample from a normal distribution. If we have a data set made
of several observations, that is, f (χ1), f (χ2), ..., f (χt), then the
vector [f (χ1), f (χ2), ..., f (χt)] is a sample from a multivariate nor-
mal distribution, which is deﬁned by a mean vector and a covari-
ance matrix. A Gaussian process is therefore a generalization of
a n-variate normal distribution, where n is the number of obser-
vations. The covariance matrix is what relates one observation
to another: two observations that correspond to nearby values
of χ1 and χ2 are likely to be correlated (this is a prior assump-
tion based on the fact that functions tend to be smooth, and is
injected into the algorithm via a prior on the likelihood of func-
tions), two observations that correspond to distant values of χ1
and χ2 should not inﬂuence each other (i.e. their distributions are
not correlated). Put differently, the covariance matrix represents
that distant samples are almost uncorrelated and nearby samples
are strongly correlated. This covariance matrix is deﬁned via a
kernel function, called k(χ1, χ2), which is usually based on the
Euclidean distance between χ1 and χ2 (see the “kernel function”
sub-section below).

Given a set of observations P1:t = f (χ1:t) and a sampling
noise(which is a user-speciﬁed parameter), the Gaussian

noise σ2

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 7

Variant

Intelligent Trial and Error
Variant 1
Variant 2
Variant 3
Variant 4
Variant 5

Behavior-performance map
creation
MAP-Elites
MAP-Elites
MAP-Elites
MAP-Elites
none
none

Priors on
performance
yes
none
none
none
none
none

Search
algorithm
Bayesian Optimization
random search
Bayesian optimization
policy gradient
Bayesian optimization
policy gradient

equivalent
approach
-
-
-
-
Lizotte et al. (2007)
Kohl et al. (2004)

Extended Data Figure 2 | The contribution of each subcomponent of the Intelligent Trial and Error Algorithm. (A) Adaptation progress versus
the number of robot trials. The walking speed achieved with Intelligent Trial and Error and several “knockout” variants that are missing one of the
algorithm’s key components. Some variants (4 and 5) correspond to state-of-the-art learning algorithms (policy gradient: Kohl et al. 2004; Bayesian
optimization: Lizotte et al. 2007, Tesch et al., 2011, Calandra et al. 2014,). The bold lines represent the medians and the colored areas extend to the
25th and 75th percentiles. (B, C) Adaptation performance after 17 and 150 trials. Shown is the the speed of the compensatory behavior discovered
by each algorithm after 17 and 150 evaluations on the robot, respectively. For all panels, data are pooled across six damage conditions (the removal
of each of the 6 legs in turn). See Supplementary Experiment S2 for methods and analysis.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 8

Extended Data Figure 3 | The Intelligent Trial and Error Algorithm is robust to environmental changes. Each plot shows both the performance and
required adaptation time for Intelligent Trial and Error when the robot must adapt to walk on terrains of different slopes. (A) Adaptation performance
on an undamaged robot. On all slope angles, with very few physical trials, the Intelligent Trial and Error Algorithm (pink shaded region) ﬁnds fast
gaits that outperform the reference gait (black dotted line). (B) Adaptation performance on a damaged robot. The robot is damaged by having
each of the six legs removed in six different damage scenarios. Data are pooled from all six of these damage conditions. The median compensatory
behavior found via Intelligent Trial and Error outperforms the median reference controller on all slope angles. The middle, black lines represent
medians, while the colored areas extend to the 25th and 75th percentiles. In (A), the black dashed line is the performance of a classic tripod gait for
reference. In (B), the reference gait is tried in all six damage conditions and its median (black line) and 25th and 75th percentiles (black colored area)
are shown. See Supplementary Experiment S3 for methods and analysis.

process is computed as follows33,21:

the update equation for the mean function (µt(x), equation 2):

P (f (x)|P1:t, x) = N (µt(x), σ2

t (x))

where :
µt(x) = k(cid:124)K−1P1:t
t (x) = k(x, x) − k(cid:124)K−1k
σ2

K =






k(χ1, χ1)
...
k(χt, χ1)

k = (cid:2) k(x, χ1)

· · ·
. . .
· · ·
k(x, χ2)

k(χ1, χt)
...
k(χt, χt)
· · ·


 + σ2


noiseI

k(x, χt) (cid:3)

Our implementation of Bayesian optimization uses this Gaus-
sian process model to search for the maximum of the objective
function f (x), f (x) being unknown. It selects the next χ to test
by selecting the maximum of the acquisition function, which bal-
ances exploration – improving the model in the less explored
parts of the search space – and exploitation – favoring parts that
the models predicts as promising. Here, we use the “Upper Con-
ﬁdence Bound” acquisition function (see the “information acqui-
sition function” section below). Once the observation is made,
the algorithm updates the Gaussian process to take the new data
into account. In classic Bayesian optimization, the Gaussian pro-
cess is initialized with a constant mean because it is assumed that
all the points of the search space are equally likely to be good.
The model is then progressively reﬁned after each observation.

The key concept of the map-based Bayesian optimization al-
gorithm (M-BOA) is to use the output of MAP-Elites as a prior
for the Bayesian optimization algorithm: thanks to the simula-
tions, we expect some behaviors to perform better than others
on the robot. To incorporate this idea into the Bayesian opti-
mization, M-BOA models the difference between the prediction
of the behavior-performance map and the actual performance on
the real robot, instead of directly modeling the objective function.
This idea is incorporated into the Gaussian process by modifying

(cid:124)
µt(x) = P(x) + k

K−1(P1:t − P(χ1:t))

(3)

(2)

where P(x) is the performance of x according to the simula-
tion and P(χ1:t) is the performance of all the previous observa-
tions, also according to the simulation. Replacing P1:t (eq. 2)
by P1:t − P(χ1:t) (eq. 3) means that the Gaussian process mod-
els the difference between the actual performance P1:t and the
performance from the behavior-performance map P(χ1:t). The
term P(x) is the prediction of the behavior-performance map.
M-BOA therefore starts with the prediction from the behavior-
performance map and corrects it with the Gaussian process.

The pseudo-code of the algorithm is available in Supplemen-

tary Figure 8.

Kernel function The kernel function is the covariance function
of the Gaussian process. It deﬁnes the inﬂuence of a controller’s
performance (on the physical robot) on the performance and con-
ﬁdence estimations of not-yet-tested controllers in the behavior-
performance map that are nearby in behavior space to the tested
controller (Extended Data Fig. 9a).

The Squared Exponential covariance function and the Matérn
kernel are the most common kernels for Gaussian pro-
cesses33,34,21. Both kernels are variants of the “bell curve”. Here
we chose the Matérn kernel because it is more general (it includes
the Squared Exponential function as a special case) and because
it allows us to control not only the distance at which effects be-
come nearly zero (as a function of parameter ρ, Extended Data
Fig. 9a), but also the rate at which distance effects decrease (as a
function of parameter ν).

The Matérn kernel function is computed as follows43,44 (with

ν = 5/2):

(cid:16)

√

k(x1, x2) =
where d(x1, x2) is the Euclidean distance in behavior space.

exp

1 +

−

5d(x1,x2)
ρ

5d(x1,x2)
ρ

+ 5d(x1,x2)2
3ρ2

(cid:17)

(cid:16)

√

(cid:17)

Cully, Clune, Tarapore, and Mouret. 2015

(4)

arXiv preprint | 9

Extended Data Figure 4 | The Intelligent Trial and Error Algorithm is largely robust to alternate choices of behavior descriptors. (A, B) The speed
of the compensatory behavior discovered by Intelligent Trial and Error for various choices of behavior descriptors. Performance is plotted after 17
and 150 evaluations in panels A and B, respectively. Experiments were performed on a simulated, damaged hexapod. The damaged robot has each of
its six legs removed in six different damage scenarios. Data are pooled across all six damage conditions. As described in Supplementary Experiment
S5, the evaluated behavior descriptors characterize the following: (i) Time each leg is in contact with the ground (Duty factor); (ii) Orientation of the
robot frame (Orientation); (iii) Instantaneous velocity of the robot (Displacement); (iv) Energy expended by the robot in walking (Energy (Total),
Energy (Relative)); (v) Deviation from a straight line (Deviation); (vi) Ground reaction force on each leg (GRF (Total), GRF (Relative)); (vii) The
angle of each leg when it touches the ground (Lower-leg angle (Pitch), Lower-leg angle (Roll), Lower-leg angle (Yaw)); and (viii) A random selection
without replacement from subcomponents of all the available behavior descriptors (i-vii) (Random). For the hand-designed reference gait (yellow)
and the compensatory gaits found by the default duty factor behavior descriptor (green), the bold lines represent the medians and the colored areas
extend to the 25th and 75th percentiles of the data. For the other treatments, including the duty factor treatment, black circles represent the median, the
colored area extends to the 25th and 75th percentiles of the data, and the colored circles are outliers. See Supplementary Experiment S5 for methods
and analysis.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 10

Extended Data Figure 5 | How the behavior performance map is explored to discover a compensatory behavior (normalized each iteration to
highlight the range of remaining performance predictions). Colors represent the performance prediction for each point in the map relative to the
highest performing prediction in the map at that step of the process. A black circle indicates the next behavior to be tested on the physical robot. A
red circle indicates the behavior that was just tested (note that the performance predictions surrounding it have changed versus the previous panel).
Arrows reveal the order that points have been explored. The red circle in the last map is the ﬁnal, selected, compensatory behavior. In this scenario,
the robot loses leg number 3. The six dimensional space is visualized according to the inset legend.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 11

Extended Data Figure 6 | How the behavior performance map is explored to discover a compensatory behavior (non-normalized to highlight
that performance predictions decrease as it is discovered that predictions from the simulated, undamaged robot do not work well on the damaged
robot). Colors represent the performance prediction for each point in the map relative to the highest performing prediction in the ﬁrst map. A black
circle indicates the next behavior to be tested on the physical robot. A red circle indicates the behavior that was just tested (note that the performance
predictions surrounding it have changed versus the previous panel). Arrows reveal the order that points have been explored. The red circle in the
last map in the sequence is the ﬁnal, selected, compensatory behavior. In this scenario, the robot loses leg number 3. The six dimensional space
is visualized according to the inset legend. The data visualized in this ﬁgure are identical to those in the previous ﬁgure: the difference is simply
whether the data are renormalized for each new map in the sequence.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 12

Extended Data Figure 7 | Intelligent Trial and Error works on a completely different type of robot: supplementary data from the robotic arm
experiment. (A) The robotic arm experimental setup. (B) Tested damage conditions. (C) Example of behavior performance maps (colormaps)
and behaviors (overlaid arm conﬁgurations) obtained with MAP-Elites. Left: A typical behavior-performance map produced by MAP-Elites with
5 example behaviors, where a behavior is described by the angle of each of the 8 joints. The color of each point is a function of its performance,
which is deﬁned as having low variance in the joint angles (i.e. a zigzag arm is lower performing than a straighter arm that reaches the same point).
Right: Neighboring points in the map tend to have similar behaviors, thanks to the performance function, which would penalize more jagged ways of
reaching those points. That neighbors have similar behaviors justiﬁes updating predictions about the performance of nearby behaviors after a testing a
single behavior on the real (damaged) robot. (D) Performance vs. trial number for Intelligent Trial and Error and traditional Bayesian optimization.
The experiment was conducted on the physical robot, with 15 independent replications for each of the 14 damage conditions. Performance is pooled
from all of these 14×15 = 210 experiments. (E) Success for each damage condition. Shown is the success rate for the 15 replications for each damage
condition, deﬁned as the percentage of replicates in which the robot reaches within 5 cm of the bin center. (F) Trials required to adapt. Shown is the
number of iterations required to reach within 5 cm of the basket center. (G) Accuracy after 30 physical trials. Performance after 30 physical trials for
each damage condition (with the stopping criterion disabled). See Supplementary Experiment S1 for methods and analysis.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 13

CREATE BEHAVIOR-PERFORMANCE MAP (VIA THE MAP-ELITES ALGORITHM IN SIMULATION)

procedure INTELLIGENT TRIAL AND ERROR ALGORITHM (IT&E)

Before the mission:

while In mission do

if Signiﬁcant performance fall then

ADAPTATION STEP (VIA M-BOA ALGORITHM)

procedure MAP-ELITES ALGORITHM

(P ← ∅, C ← ∅)
for iter = 1 → I do

if iter < 400 then

c(cid:48) ← random_controller()

else

c ← random_selection(C)
c(cid:48) ← random_variation(c)

x(cid:48) ←behavioral_descriptor(simu(c(cid:48)))
p(cid:48) ←performance(simu(c(cid:48)))
if P(x(cid:48)) = ∅ or P(x(cid:48)) < p(cid:48) then

P(x(cid:48)) ← p(cid:48)

C(x(cid:48)) ← c(cid:48)

(cid:46) Creation of an empty behavior-performance map (empty N-dimensional grid).
(cid:46) Repeat during I iterations (here we choose I = 40 million iterations).

(cid:46) The ﬁrst 400 controllers are generated randomly.
(cid:46) The next controllers are generated using the map.
(cid:46) Randomly select a controller c in the map.
(cid:46) Create a randomly modiﬁed copy of c.
(cid:46) Simulate the controller and record its behavioral descriptor.
(cid:46) Record its performance.
(cid:46) If the cell is empty or if p(cid:48) is better than the current stored performance.
(cid:46) Store the performance of c(cid:48) in the behavior-performance map according
(cid:46) to its behavioral descriptor x(cid:48).
(cid:46) Associate the controller with its behavioral descriptor.

return behavior-performance map (P and C)

procedure M-BOA (MAP-BASED BAYESIAN OPTIMIZATION ALGORITHM)

∀x ∈ map:

P (f (x)|x) = N (µ0(x), σ2
where
µ0(x) = P(x)
σ2

0(x) = k(x, x)

0(x))

while max(P1:t) < α max(µt(x)) do
χt+1 ← arg maxx(µt(x) + κσt(x))
Pt+1 ← performance(physical_robot(C(χt+1))).
P (f (x)|P1:t+1, x) = N (µt+1(x), σ2
where
µt+1(x) = P(x) + k(cid:124)K−1(P1:t+1 − P(χ1:t+1))
t+1(x) = k(x, x) − k(cid:124)K−1k
σ2

t+1(x))






K =

k(χ1, χ1)
...
k(χt+1, χ1)

· · ·
. . .
· · ·
k(x, χ2)

k(χ1, χt+1)
...
k(χt+1, χt+1)
· · ·

k(x, χt+1) (cid:3)


 + σ2


noiseI

k = (cid:2) k(x, χ1)

(cid:46) Initialisation.
(cid:46) Deﬁnition of the Gaussian Process.

(cid:46) Initialize the mean prior from the map.
(cid:46) Initialize the variance prior (in the common case, k(x, x) = 1).
(cid:46) Iteration loop.
(cid:46) Select next test (argmax of acquisition function).
(cid:46) Evaluation of xt+1 on the physical robot.
(cid:46) Update the Gaussian Process.

(cid:46) Update the mean.
(cid:46) Update the variance.

(cid:46) Compute the observations’ correlation matrix.

(cid:46) Compute the x vs. observation correlation vector.

Extended Data Figure 8 | Pseudo-code for the Intelligent Trial and Error Algorithm, the MAP-Elites algorithm, and the Map-based Bayesian
Optimization Algorithm (M-BOA). Notations are described at the beginning of the methods section.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 14

Because the model update step directly depends on ρ, it is one
of the most critical parameters of the Intelligent Trial and Error
Algorithm. We selected its value after extensive experiments in
simulation (Extended Data Fig. 9 and section 1.6).

Information acquisition function The information acquisition
function selects the next solution that will be evaluated on the
physical robot. The selection is made by ﬁnding the solution
that maximizes the acquisition function. This step is another op-
timization problem, but does not require testing the controller
in simulation or reality. In general, for this optimization prob-
lem we can derive the exact equation and ﬁnd a solution with
gradient-based optimization45. For the speciﬁc behavior space in
the example problem in this paper, though, the discretized search
space of the behavior-performance map is small enough that we
can exhaustively compute the acquisition value of each solution
of the behavior-performance map and then choose the maximum
value.

Several different acquisition functions exist, such as the proba-
bility of improvement, the expected improvement, or the Upper
Conﬁdence Bound (UCB)33,42. We chose UCB because it provided
the best results in several previous studies33,42. The equation for
UCB is:

xt+1 = arg max

(µt(x) + κσt(x))

(5)

x

where κ is a user-deﬁned parameter that tunes the tradeoff be-
tween exploration and exploitation.

The acquisition function handles the exploitation/exploration
trade-off of the adaptation (M-BOA) step. In the UCB function
(Eq. 5), the emphasis on exploitation vs. exploration is explicit
and easy to adjust. The UCB function can be seen as the max-
imum value (argmax) across all solutions of the weighted sum
of the expected performance (mean of the Gaussian, µt(x)) and
of the uncertainty (standard deviation of the Gaussian, σt(x)) of
each solution. This sum is weighted by the κ factor. With a low κ,
the algorithm will choose solutions that are expected to be high-
performing. Conversely, with a high κ, the algorithm will fo-
cus its search on unexplored areas of the search space that may
have high-performing solutions. The κ factor enables ﬁne adjust-
ments to the exploitation/exploration trade-off of the M-BOA al-
gorithm (the adaptation step). We describe how we chose the κ
value in supplementary methods, section 1.6.

Code availability The source code (for GNU/Linux) for the ex-
periments of this paper is available at the following URL:
http://pages.isir.upmc.fr/~mouret/code/ite_source_code.tar.gz An implementa-
tion of the Bayesian optimization algorithm is freely available on:
http://github.com/jbmouret/limbo

1.4 Hexapod Experiment

Physical robot The robot is a 6-legged robot with 3 degrees
of freedom (DOFs) per leg. Each DOF is actuated by position-
controlled servos (MX-28 Dynamixel actuators manufactured by
Robotis). The ﬁrst servo controls the horizontal (front-back) ori-
entation of the leg and the two others control its elevation. An
RGB-D camera (Xtion, from ASUS) is ﬁxed on top of the robot. Its
data are used to estimate the forward displacement of the robot
via an RGB-D SLAM algorithm146 from the robot operating sys-
tem (ROS) framework247.

Simulator The simulator is a dynamic physics simulation of the
undamaged 6-legged robot on ﬂat ground (Fig. 4). We weighted
each segment of the leg and the body of the real robot, and we

1http://wiki.ros.org/ccny_openni_launch
2http://www.ros.org

used the same masses for the simulations. The simulator is based
on the Open Dynamics Engine (ODE, http://www.ode.org).

Parametrized controller The angular position of each DOF is
governed by a periodic function γ parametrized by its amplitude
α, its phase φ, and its duty cycle τ (the duty cycle is the propor-
tion of one period in which the joint is in its higher position). The
function is deﬁned with a square signal of frequency 1Hz, with
amplitude α, and duty cycle τ . This signal is then smoothed via
a Gaussian ﬁlter in order to remove sharp transitions, and is then
shifted according to the phase φ.

Angular positions are sent to the servos every 30 ms. In or-
der to keep the “tibia” of each leg vertical, the control signal of
the third servo is the opposite of the second one. Consequently,
angles sent to the ith leg are:

• γ(t, αi1 , φi1 , τi1 ) for DOF 1
• γ(t, αi2 , φi2 , τi2 ) for DOF 2
• −γ(t, αi2 , φi2 , τi2 ) for DOF 3

This controller makes the robot equivalent to a 12 DOF system,
even though 18 motors are controlled.

There are 6 parameters for each leg (αi1 , αi2 , φi1 , φi2 , τi1 ,
τi2 ), therefore each controller is fully described by 36 parame-
ters. Each parameter can have one of these possible values: 0,
0.05, 0.1, ... 0.95, 1. Different values for these 36 parameters can
produce numerous different gaits, from purely quadruped gaits
to classic tripod gaits.

This controller is designed to be simple enough to show the
performance of the algorithm in an intuitive setup. Neverthe-
less, the algorithm will work with any type of controller, includ-
ing bio-inspired central pattern generators48 and evolved neural
networks49,50,51,52.

Reference controller Our reference controller is a classic tri-
pod gait7,53,54,55,56,57. It involves two tripods: legs 1-4-5 and legs 2-
3-6 (Fig. 4). This controller is designed to always keep the robot
balanced on at least one of these tripods. The walking gait is
achieved by lifting one tripod, while the other tripod pushes the
robot forward (by shifting itself backward). The lifted tripod is
then placed forward in order to repeat the cycle with the other
tripod. This gait is static, fast, and similar to insect gaits53,58.

Table S1 shows the 36 parameters of the reference controller.
The amplitude orientation parameters (αi1 ) are set to 1 to pro-
duce the fastest possible gait, while the amplitude elevation pa-
rameters (αi2 ) are set to a small value (0.25) to keep the gait sta-
ble. The phase elevation parameters (φi2 ) deﬁne two tripods:
0.25 for legs 2-3-5; 0.75 for legs 1-4-5. To achieve a cyclic mo-
tion of the leg, the phase orientation values (φi1 ) are chosen by
subtracting 0.25 to the phase elevation values (φi2 ), plus a 0.5
shift for legs 1-3-5, which are on the left side of the robot. All the
duty cycle parameters (τi) are set to 0.5 so that the motors spend
the same proportion of time in their two limit angles. The actual
speed of the reference controller is not important for the compar-
isons made in this paper: it is simply intended as a reference and
to show that the performance of classic, hand-programmed gaits
tend to fail when damage occurs.

Random variation of controller’s parameters Each parame-
ter of the controller has a 5% chance of being changed to any
value in the set of possible values, with the new value chosen
randomly from a uniform distribution over the possible values.

Main Behavioral descriptor (duty factor) The default behav-
ioral descriptor is a 6-dimensional vector that corresponds to the
proportion of time that each leg is in contact with the ground
(also called duty factor). When a controller is simulated, the al-
gorithm records at each time step (every 30 ms) whether each leg

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 15

Leg number

First joint

Two last joints

1
1.00
0.00
0.5
0.25
0.75
0.5

2
1.00
0.00
0.5
0.25
0.25
0.5

3
1.00
0.50
0.5
0.25
0.25
0.5

4
1.00
0.50
0.5
0.25
0.75
0.5

5
1.00
0.00
0.5
0.25
0.75
0.5

6
1.00
0.00
0.5
0.25
0.25
0.5

αi1
φi1
τi1
αi2
φi2
τi2

Extended Data Table 1| Parameters of the reference controller.

is in contact with the ground (1: contact, 0: no contact). The re-
sult is 6 Boolean time series (Ci for the ith leg). The behavioral
descriptor is then computed with the average of each time series:







x =

(cid:80)

t C1(t)
numTimesteps(C1)

...

(cid:80)

t C6(t)
numTimesteps(C6)







During the generation of the behavior-performance map, the
behaviors are stored in the maps’s cells by discretizing each di-
mension of the behavioral descriptor space with these ﬁve val-
ues: {0, 0.25, 0.5, 0.75, 1}. During the adaptation phase, the behav-
ioral descriptors are used with their actual values and are thus
not discretized.

Alternative Behavioral descriptor (orientation) The alterna-
tive behavioral descriptor tested on the physical robot (we in-
vestigated many other descriptors in simulation: Supplementary
Experiment S5) characterizes changes in the angular position of
the robot during walking, measured as the proportion of 15ms
intervals that each of the pitch, roll and yaw angles of the robot
frame are positive (three dimensions) and negative (three addi-
tional dimensions):

x =











1
K
1
K
1
K
1
K
1
K
1
K

(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)

k U (ΘT (k) − 0.005π)
k U (−ΘT (k) − 0.005π)
k U (ΨT (k) − 0.005π)
k U (−ΨT (k) − 0.005π)
k U (ΦT (k) − 0.005π)
k U (−ΦT (k) − 0.005π)











(7)

where ΘT (k), ΨT (k) and ΦT (k) denote the pitch, roll and yaw
angles, respectively, of the robot torso (hence T ) at the end of
interval k, and K denotes the number of 15ms intervals during
the 5 seconds of simulated movement (here, K = 5s/0.015s ≈
334). The unit step function U (·) returns 1 if its argument exceeds
0, and returns 0 otherwise. To discount for insigniﬁcant motion
around 0 rad, orientation angles are only deﬁned as positive if
they exceed 0.5% of π rad. Similarly, orientation angles are only
deﬁned as negative if they are less than −0.5% of π rad.

Performance function In these experiments, the “mission”
of the robot is to go forward as fast as possible. The perfor-
mance of a controller, which is a set of parameters (section 1.4:
Parametrized controller), is deﬁned as how far the robot moves
in a pre-speciﬁed direction in 5 seconds.

During the behavior-performance map creation step, the per-
formance is obtained thanks to the simulation of the robot. All
odometry results reported on the physical robot, during the
adaptation step, are measured with the embedded simultaneous
location and mapping (SLAM) algorithm46. The accuracy of this
algorithm was evaluated by comparing its measurements to ones
made by hand on 40 different walking gaits. These experiments
revealed that the median measurement produced by the odome-
try algorithm is reasonably accurate, being just 2.2% lower than
the handmade measurement (Extended Data Fig. 9d).

Some damage to the robot may make it ﬂip over. In such cases,
the visual odometry algorithm returns pathological distance-

traveled measurements either several meters backward or for-
ward. To remove these errors, we set all distance-traveled mea-
surements less than zero or greater than two meters to zero. The
result of this adjustment is that the algorithm appropriately con-
siders such behaviors low-performing. Additionally, the SLAM
algorithm sometimes reports substantially inaccurate low val-
ues (outliers on Supplementary Fig. 9d).
In these cases the
adaptation step algorithm will assume that the behavior is low-
performing and will select another working behavior. Thus, the
overall algorithm is not substantially impacted by such infre-
quent under-measurements of performance.

(6)

Stopping criterion In addition to guiding the learning process
to the most promising area of the search space, the estimated per-
formance of each solution in the map also informs the algorithm
of the maximum performance that can be expected on the physi-
cal robot. For example, if there is no controller in the map that is
expected to perform faster on the real robot than 0.3m/s, it is un-
likely that a faster solution exists. This information is used in our
algorithm to decide if it is worth continuing to search for a bet-
ter controller; if the algorithm has already discovered a controller
that performs nearly as well as the highest value predicted by the
model, we can stop the search.

Formally, our stopping criterion is

max(P1:t) ≥ α max
x∈P

(µt(x)), with α = 0.9

(8)

where x is a location in the discrete behavioral space (i.e. a type of
behavior) and µt is the predicted performance of this type of be-
havior. Thus, when one of the tested solutions has a performance
of 90% or higher of the maximum expected performance of any
behavior in the map, the algorithm terminates. At that point,
the highest-performing solution found so far will be the compen-
satory behavior that the algorithm selects. An alternative way
the algorithm can halt is if 20 tests on the physical robot occur
without triggering the stopping criterion described in equation
8: this event only occurred in 2 of 240 experiments performed
on the physical robot described in the main text. In this case, we
selected the highest-performing solution encountered during the
search. This user-deﬁned stopping criterion is not strictly neces-
sary, as the algorithm is guaranteed to stop in the worst case after
every behavior in the map is tested, but it allows a practical limit
on the number of trials performed on the physical robot.

Initiating the Adaptation Step The adaptation step is trig-
gered when the performance drops by a certain amount. The
simplest way to choose that threshold is to let the user specify
it. Automating the selection of this value, and the impact of trig-
gering the algorithm prematurely, is an interesting question for
future research in this area.

Main parameters of MAP-Elites
• parameters in controller: 36
• parameter values (controller): 0 to 1, with 0.05 increments
• size of behavioral space: 6
• possible behavioral descriptors: {0, 0.25, 0.5, 0.75, 1}

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 16

• iterations: 40 million

Main parameters of M-BOA

noise: 0.001

• σ2
• α: 0.9
• ρ: 0.4
• κ: 0.05

1.5 Robotic Arm Experiment

Physical robot The physical robot is a planar robotic arm with
8 degrees of freedom (Extended Data Fig. 7a) and a 1-degree-
of-freedom gripper. The robot has to release a ball into a bin (a
variant of the classic “pick and place” task in industrial robotics).
To assess the position of the gripper, a red cap, placed on top of
the gripper, is tracked with a video camera. The visual tracking
is achieved with the “cmvision” ROS package, which tracks col-
ored blobs (http://wiki.ros.org/cmvision). The eight joints of the
robot are actuated by position-controlled servos manufactured
by Dynamixel. To maximize the reliability of the the arm, the
type of servo is not the same for all the joints: heavy-duty servos
are used near the base of the robot and lighter ones are used for
the end of the arm. The ﬁrst joint, ﬁxed to the base, is moved
by two MX-28 servos mounted in parallel. The second joint is
moved by an MX-64 servo. The 3 subsequent servos are single
MX-28s, and the 3 remaining servos are AX-18s. All the robot’s
joints are limited to a motion range of ±π/2.

Simulator The generation of the behavior-performance map is
made with a simulated robot in the same way as for the hexapod
experiment. For consistency with the simulated hexapod experi-
ments, we used the dynamic (as opposed to kinematic) version of
the simulator, based on the ODE library. Any joint conﬁguration
that resulted in the arm colliding with itself was not added to the
map.

Parametrized controller The controller deﬁnes the target posi-
tion for each joint. The controller is thus parametrized by eight
continuous values from 0 to 1 describing the angle of each joint,
which is mapped to the the total motion range of each joint of
±π/2. The 8 joints are activated simultaneously and are driven
to their target position by internal PID controllers.

We chose this simple control strategy to make the experiments
easy to reproduce and highlight the contribution of Intelligent
Trial & Error for damage recovery. More advanced control strate-
gies, for instance visual servoing7, would be more realistic in a
industrial environment, but they would have made it hard to an-
alyze the experimental results because both Intelligent Trial & Er-
ror and the controller would compensate for damage at the same
time.

Randomly varying the controller’s parameters Each param-
eter of the controller (section “Parametrized controller”) has a
12.5% chance of being changed to any value from 0 to 1, with the
new value chosen from a polynomial distribution as described
on p. 124 of (Deb, 2000), with ηm = 10.0.

Behavioral descriptor Because the most important aspect of
the robot’s behavior in this task is the ﬁnal position of the gripper,
we use it as the behavioral descriptor:

behavioral_descriptor(simu(c)) =

(9)

(cid:21)

(cid:20) xg
yg

where (xg, yg) denotes the position of the gripper once all the
joint have reached their target position.

The size of the working area of the robot is a rectangle measur-
ing 1.4m × 0.7m. For the behavior-performance map, this rect-
angle is discretized into a grid composed of 20000 square cells
(200 × 100). The robot is 62cm long.

Performance function Contrary to the hexapod experiment,
for the robotic arm experiment the performance function for the
behavior-map creation step and for the adaptation step are dif-
ferent. We did so to demonstrate that the two can be different,
and to create a behavior-performance map that would work with
arbitrary locations of the target bin.

For the behavior-performance map generation step (accomplished
via the MAP-Elites algorithm), the performance function cap-
tures the idea that all joints should contribute equally to the
movement. Speciﬁcally, high-performance is deﬁned as minimiz-
ing the variance of the joint angles, that is:

performance(simu(c))) = −

(pi − m)2

(10)

1
8

i=7
(cid:88)

i=0

(cid:80)i=7

where pi is the angular position of joint i (in radians) and m =
1
i=0 pi is the mean of the joint angles. This performance func-
8
tion does not depend on the target. The map is therefore generic:
it contains a high-performing controller for each point of the
robot’s working space.

For the adaptation step (accomplished via the M-BOA algo-
rithm), the behavior-performance map, which is generic to many
tasks, is used for a particular task. To do so, the adaption step has
a different performance measure than the step that creates the
behavior-performance map. For this problem, the predicted per-
formance measure is the Euclidean distance to the target (closer
is better). Speciﬁcally, for each behavior descriptor x in the map,
performance is

P(x) = −||x − b||

(11)

where b is the (x, y) position of the target bin. Note that the
variance of the joint angles, which is used to create the behavior-
performance map, is ignored during the adaptation step.

The performance of a controller on the physical robot is mini-
mizing the Euclidean distance between the gripper (as measured
with the external camera) and the target bin:

performance(physical_robot(C(χ))) = −||xg − b||

(12)

where xg is the position of the physical gripper after all joints
have reached their ﬁnal position, b is the position of the bin, and
C(χ) is the controller being evaluated (χ is the position in simu-
lation that controller reached).

If the gripper reaches a position outside of the working area,
then the camera cannot see the marker. In these rare cases, we set
the performance of the corresponding controller to a low value
(−1 m).

For the control experiments with traditional Bayesian opti-
mization on the physical robot (see Supplementary Experiment
S1), self-collisions are frequent during adaptation, especially
given that we initialize the process with purely random con-
trollers (i.e. random joint angles). While a single self-collision
is unlikely to break the robot, hundreds of them can wear out the
gearboxes because each servo continues to apply a force for a pe-
riod of time until it determines that it cannot move. To minimize
costs, and because we ran 210 independent runs of the algorithm
(14 scenarios × 15 replicates), we ﬁrst tested each behavior in
simulation (taking the damage into account) to check that there
were no self-collisions. If we detected a self-collision, the perfor-
mance for that behavior was set to a low value (−1m).

Auto-collisions are much less likely with Intelligent Trial & Er-
ror because the behavior-performance map contains only con-
trollers that do not self-collide on the undamaged, simulated

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 17

robot. As a consequence, in the Intelligent Trial & Error experi-
ments we did not simulate controllers before testing them on the
physical robot.

Stopping criterion Because the robot’s task is to release a ball
into a bin, the adaptation step can be stopped when the gripper
is above the bin. The bin is circular with a diameter of 10 cm, so
we stopped the adaptation step when the red cap is within 5 cm
of the center of the bin.

Main MAP-Elites parameters for the robotic arm experiment:

• parameters in controller: 8
• controller parameter values: 0 to 1 (continuous)
• dimensions in the behavioral space: 2
• simulated evaluations to create the behavior-performance

map: 20 million

Main M-BOA parameters for the robotic arm experiment:

noise: 0.03

• σ2
• ρ: 0.1
• κ: 0.3

1.6 Selection of parameters

All of the data reported in this section comes from experiments
with the simulated hexapod robot, unless otherwise stated.

Selecting the ρ value For ρ between 0.1 and 0.8, we counted
the number of behaviors from the map that would be inﬂuenced
by a single test on the real hexapod robot (we considered a behav-
ior to be inﬂuenced when its predicted performance was affected
by more than 25% of the magnitude of the update for the tested
behavior): with ρ = 0.2, the update process does not affect any
neighbor in the map, with ρ = 0.4, it affects 10% of the behaviors,
and with ρ = 0.8, it affects 80% of them. Additional values are
shown in Extended Data Fig. 9c.

The previous paragraph describes tests we conducted to de-
termine the number of behaviors in the map affected by different
ρ values, but those experiments do not tell us how different ρ
values affect the performance of the algorithm overall. To assess
that, we then repeated the experiments from the main paper with
a set of possible values (ρ ∈ [0.1 : 0.025 : 0.8]) in simulation (i.e.,
with a simulated, damaged robot), including testing on 6 sepa-
rate damage scenarios (each where the robot loses a different leg)
with all 8 independently generated replicates of the default 6-
dimensional behavior-performance map. The algorithm stopped
if 20 adaptation iterations passed without success according to
the stopping criteria described in the main text and section 1.4:
Stopping criterion. The results reveal that median performance
decreases only modestly, but signiﬁcantly, when the value of ρ
increases: changing ρ from 0.1 to 0.8 only decreases the median
value 12%, from 0.25 m/s to 0.22 m/s (p-value = 9.3 × 10−5 via
Matlab’s Wilcoxon ranksum test, Extended Data Fig. 9b). The
variance in performance, especially at the extreme low end of the
distribution of performance values, is not constant over the range
of explored values. Around ρ = 0.3 the minimum performance
(Extended Data Fig. 9b, dotted red line) is higher than the mini-
mum performance for more extreme values of ρ.

A larger effect of changing ρ is the amount of time required to
ﬁnd a compensatory behavior, which decreases when the value
of ρ increases (Extended Data Fig. 9b). With a ρ value lower than
0.25, the algorithm rarely converges in less than the allotted 20
iterations, which occurs because many more tests are required
to cover all the promising areas of the search space to know if
a higher-performing behavior exists than the best-already-tested.
On the other hand, with a high ρ value, the algorithm updates

its predictions for the entire search space in a few observations:
while fast, this strategy risks missing promising areas of the
search space.

In light of these data, we chose ρ = 0.4 as the default value
for our hexapod experiments because it represents a good trade-
off between a high minimum performance and a low number of
physical tests on the robot. The value of ρ for the robotic arm
experiment has been chosen with the same method.

Selection of the κ value For the hexapod robot experiments,
we chose κ = 0.05. This relatively low value emphasizes ex-
ploitation over exploration. We chose this value because the ex-
ploration of the search space has already been largely performed
the map
during the behavior-performance map creation step:
suggests which areas of the space will be high-performing, and
should thus be tested, and which areas of the space are likely un-
proﬁtable, and thus should be avoided.

For the robotic arm experiments, we chose κ = 0.3, which
emphasizes exploration more, because it experimentally leads to
better results.

1.7 Running time

Computing hardware All computation (on the physical robots
and in simulation) was conducted on a hyperthreaded 16-core
computer (Intel Xeon E5-2650 2.00GHz with 64Gb of RAM).
This computational power is mainly required for the behavior-
performance map creation step. Creating one map for the hexa-
pod experiment took 2 weeks, taking advantage of the fact that
map creation can easily be parallelized across multiple cores.
Map creation only needs to be performed once per robot (or
robot design), and can happen before the robot is deployed. As
such, the robot’s onboard computer does not need to be powerful
enough to create the map.

For the hexapod robot experiment, the most expensive part
of adaptation is the Simultaneous Localization And Mapping
(SLAM) algorithm46,59,60, which measures the distance traveled
on the physical hexapod robot. It is slow because it processes mil-
lions of 3D points per second. It can be run on less powerful com-
puters, but doing so lowers its accuracy because fewer frames per
second can be processed. As computers become faster, it should
be possible to run high-accuracy SLAM algorithms in low-cost,
onboard computers for robots.

The rest of the adaptation step needs much less computational
power and can easily be run on an onboard computer, such as a
smartphone. That is because it takes approximately 15,000 arith-
metic operations between two evaluations on the physical robot,
which requires less than a second or two on current smartphones.

Measuring how long adaptation takes (hexapod robot) The
reported time to adapt includes the time required for the com-
puter to select each test and the time to conduct each test on the
physical robot. Overall, evaluating a controller on the physical
hexapod robot takes about 8 seconds (median 8.03 seconds, 5th
and 95th percentiles [7.95; 8.21] seconds): 0.5-1 second to initial-
ize the robot, 5 seconds during which the robot can walk, 0.5-1
second to allow the robot to stabilize before taking the ﬁnal mea-
surement, and 1-2 seconds to run the SLAM algorithm. Identify-
ing the ﬁrst controller to test takes 0.03 [0.0216; 0.1277] seconds.
The time to select the next controller to test increases depending
on the number of previous experiments because the size of the
Kernel Matrix (K matrix, see Methods and Extended Data Fig. 8),
which is involved in many of the arithmetic operations, grows by
one row and one column per test that has been conducted. For
example, selecting the second test takes 0.15 [0.13; 0.22] seconds,
while the 10th selection takes 0.31 [0.17; 0.34] seconds.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 18

Extended Data Figure 9 | The effect of changing the algorithm’s parameters. (a) The shape of the Matérn kernel function for different values
of the ρ parameter. (b) Performance and required adaptation time obtained for different values of ρ. For each ρ value, the M-BOA algorithm
was executed in simulation with 8 independently generated behavior-performance maps and for 6 different damage conditions (each case where
one leg is missing). (c) The number of controllers in the map affected by a new observation according to different values of the ρ parameter. (d)
The precision of the odometry value. The distances traveled by the physical robot, as measured manually (“real performance”) is compared to the
measurements automatically provided by the simultaneous location and mapping (SLAM) algorithm(“measured performance”). The dashed black
line indicates the hypothetical case where SLAM measurements are error-free and thus are the same as manual measurements. In (b), (c) and (d), the
middle, black lines represent medians and the borders of the shaded areas show the 25th and 75th percentiles. The dotted lines are the minimum and
maximum values. The gray bars show the ρ value chosen for the hexapod experiments in the main text.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 19

2 Supplementary Experiments S1

Additional conditions for the robotic arm

Methods We investigated 11 damage conditions on the physi-
cal robot in addition to the 3 described in the main text (Fig. 3).
We used the same setup as described in the main text (see main
text and section 1.5). Extended Data Fig. 7 shows the 14 scenar-
ios.

For each of the 14 damage scenarios, we replicated experi-
ments on the physical robot with 15 independently generated
behavior-performance maps (210 runs in total). We also repli-
cated control experiments, which consist of traditional Bayesian
optimization directly in the original parameter space (i.e. with-
out behavior-performance maps), 15 times for each of the 14
damage conditions (210 runs in total). For both the experimental
and control treatments, each experiment involved 30 evaluations
on the physical robot (31 if the ﬁrst trial is counted). In many
cases, not all 30 evaluations were required to reach the target, so
we report only the number of trials required to reach that goal.

Results After running the MAP-Elites algorithm for 20 million
evaluations, each of the 15 generated maps contain more than
11, 000 behaviors (11,209 [1,1206; 1,1217] behaviors, Extended
Data Fig. 7c).

In all the generated maps, the regions of different performance
values for behaviors are arranged in concentric shapes resem-
bling cardioids (inverted, heart-shaped curves) that cover the
places the robot can reach (Extended Data Fig. 7c). The black
line drawn over the shown map corresponds to all the positions
of the end-effector for which all the degrees of freedom are set to
the same angle (from −π/4 to +π/4), that is, for the theoretically
highest achievable performance (i.e. the lowest possible variance
in servo angles). The performance of the behaviors tends to de-
crease the further they are from this optimal line.

The adaptation results (Extended Data Fig. 7e) show that the
Intelligent trial and error algorithm manages to reach the goal
of being less than 5 cm from the center of the bin for all the
runs in all the tested scenarios save two (scenarios 11 & 12). For
these two scenarios, the algorithm still reaches the target 60%
and 80% of the time, respectively. For all the damage conditions,
the Intelligent Trial and Error algorithm reaches the target sig-
niﬁcantly more often than the Bayesian optimization algorithm
(p < 10−24). Speciﬁcally, the median number of iterations to
reach the target (Extended Data Fig. 7f) is below 11 iterations
(27.5 seconds) for all scenarios except 11 and 12, for which 31
and 20 iterations are required, respectively. When the robot is not
able to reach the target, the recorded number of iterations is set to
31, which explains why the median number of iterations for the
Bayesian optimization algorithm is equal to 31 for most damage
conditions. For all the damage conditions except one (scenario
11), the Intelligent Trial and Error algorithm used fewer trials to
reach the target than the traditional Bayesian optimization algo-
rithm.

If the robot is allowed to continue its experiment after reach-
ing the 5 cm radius tolerance, for a total of 31 iterations (Extended
Data Fig. 7g), it reaches an accuracy around 1 cm for all the dam-
age conditions except the two difﬁcult ones (scenarios 11 and 12).
This level of accuracy is never achieved with the classic Bayesian
optimization algorithm, whose lowest median accuracy is 2.6cm.
Scenarios 11 and 12 appear to challenge the Intelligent Trial
and Error algorithm. While in both cases the success rate is im-
proved, though not substantially, in case 11 the median accuracy
is actually lower. These results stem from the fact that the dif-
ference between the successful pre-damage and post-damage be-
haviors is so large that the post-damage solutions for both scenar-
ios lie outside of the map. This illustrates a limit of the proposed
approach: if the map does not contain a behavior able to cope

with the damage, the robot will not be able to adapt. This limit
mainly comes from the behavioral descriptor choice: we chose
it because of its simplicity, but it does not capture all of the im-
portant dimensions of variation of the robot. More sophisticated
descriptors are likely to allow the algorithm to cope with such
situations. On the other hand, this experiment shows that with
a very simple behavioral descriptor, using only the ﬁnal position
of the end-effector, our approach is able to deal with a large va-
riety of different target positions and is signiﬁcantly faster than
the traditional Bayesian optimization approach (Extended Data
Fig. 7d, maximum p-value over each time step < 10−16), which
is the current state of the art technique for direct policy search in
robotics32,61,42,17.

3 Supplementary Experiments S2

The contribution of each subcomponent of the
Intelligent Trial and Error Algorithm

Methods The Intelligent Trial and Error Algorithm relies on
three main concepts: (1) the creation of a behavior-performance
map in simulation via the MAP-Elites algorithm, (2) searching
this map with a Bayesian optimization algorithm to ﬁnd behav-
iors that perform well on the physical robot, and (3) initializing
this Bayesian optimization search with the performance predic-
tions obtained via the MAP-Elites algorithm: note that the sec-
ond step could be performed without the third step by searching
through the MAP-Elites-generated behavior-performance map
with Bayesian optimization, but having the initial priors uni-
formly set to the same value. We investigated the contribution
of each of these subcomponents by testing ﬁve variants of our al-
gorithm : in each of them, we deactivated one of these three sub-
components or replaced it with an alternative algorithm from the
literature. We then tested these variants on the hexapod robot.
The variants are as follows:

• Variant 1 (MAP-Elites in 6 dimensions + random search):
evaluates the beneﬁt of searching the map via Bayesian opti-
mization by searching that map with random search instead.
Each iteration, a behavior is randomly selected from the map
and tested on the robot. The best one is kept.

• Variant 2 (MAP-Elites in 6 dimensions + Bayesian optimiza-
tion, no use of priors): evaluates the contribution of initializ-
ing the Gaussian process with the performance predictions
of the behavior-performance map. In this variant, the Gaus-
sian process is initialized with a constant mean (the average
performance of the map: 0.24 m/s) at each location in the
behavior space and a constant variance (the average vari-
ance of the map’s performance: 0.005 m2/s2). As is custom-
ary, the ﬁrst few trials (here, 5) of the Bayesian optimization
process are selected randomly instead of letting the algo-
rithm choose those points, which is known to improve per-
formance.42

• Variant 3 (MAP-Elites in 6 dimensions + policy gradient):
evaluates the beneﬁt of Bayesian optimization compared to
a more classic, local search algorithm17,62; there is no obvious
way to use priors in policy gradient algorithms.

• Variant 4 (Bayesian optimization in the original parameter
space of 36 dimensions): evaluates the contribution of us-
ing a map in a lower-dimensional behavioral space. This
variant searches directly in the original 36-dimensional pa-
rameter space instead of reducing that space to the lower-
dimensional (six-dimensional) behavior space. Thus, in this
variant no map of behaviors is produced ahead of time: the
algorithm searches directly in the original, high-dimensional
space. This variant corresponds to one of the best algorithms
known to learn locomotion patterns32,42. In this variant, the
Gaussian process is initialized with a constant mean set to

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 20

zero and with a constant variance (0.002m2/s2). As de-
scribed above, the ﬁve ﬁrst trials are selected from pure ran-
dom search to prime the Bayesian optimization algorithm42.
• Variant 5 (Policy gradient in the original parameter space of
36 dimensions): a stochastic gradient descent in the original
parameter space62. This approach is a classic reinforcement
learning algorithm for locomotion17 and it is a baseline in
many papers32.

It was necessary to compare these variants in simulation be-
cause doing so on the physical robot would have required
months of experiments and would have repeatedly worn out or
broken the robot. We modiﬁed the simulator from the main ex-
periments (section 1.4: Simulator) to emulate 6 different possible
damage conditions, each of which involved removing a different
leg. For variants in which MAP-Elites creates a map (variants
1, 2 and 3), we used the same maps from the main experiments
(the eight independently generated maps, which were all gener-
ated with a simulation of the undamaged robot): In these cases,
we launched ten replicates of each variant for each of the eight
maps and each of the six damage conditions. There are there-
fore 10 × 8 × 6 = 480 replicates for each of those variants. For
the other variants (4 and 5), we replicated each experiment 80
times for each of the six damage conditions, which also led to
80 × 6 = 480 replicates per variant. In all these simulated ex-
periments, to roughly simulate the distribution of noisy odome-
try measurements on the real robot, the simulated performance
values were randomly perturbed with a multiplicative Gaussian
noise centered on 0.95 with a standard deviation of 0.1.

We analyze the fastest walking speed achieved with each vari-
ant after two different numbers of trials: the ﬁrst case is after 17
trials, which was the maximum number of iterations used by the
Intelligent Trial and Error Algorithm, and the second case is after
150 trials, which is approximately the number of trials used in
previous work62,32,42.

Results After 17 trials on the robot, Intelligent Trial and Error
signiﬁcantly outperforms all the variants (Extended Data Fig. 2b,
p < 10−67, Intelligent Trial and Error performance: 0.26 [0.20;
0.33] m/s), demonstrating that the three main components of the
algorithm are needed to quickly ﬁnd high-performing behaviors.
Among the investigated variants, the random search in the map
performs the best (Variant 1: 0.21 [0.16; 0.27] m/s), followed by
Bayesian optimization in the map (Variant 2: 0.20 [0.13; 0.25]
m/s), and policy gradient in the map (Variant 3: 0.13 [0; 0.23]
m/s). Variants that search directly in the parameter space did
not ﬁnd any working behavior (Variant 4, Bayesian optimiza-
tion: 0.04m/s, [0.01; 0.09]; Variant 5, policy gradient: 0.02 [0; 0.06]
m/s).

There are two reasons that random search performs better than
one might expect. First, the map only contains high-performing
solutions, which are the result of the intense search of the MAP-
Elites algorithm (40 million evaluations in simulation). The map
thus already contains high-performing gaits of nearly every pos-
sible type. Therefore, this variant is not testing random con-
trollers, but is randomly selecting high-performing solutions.
Second, Bayesian optimization and policy gradient are not de-
signed for such a low number of trials: without the priors on per-
formance predictions introduced in the Intelligent Trial and Er-
ror Algorithm, the Bayesian optimization process needs to learn
the overall shape of the search space to model it with a Gaussian
process. 17 trials is too low a number to effectively sample six di-
mensions (for a uniform sampling with only two possible values
in each dimension, 26 = 64 trials are needed; for ﬁve possible
values, 56 = 15, 625 samples are needed). As a consequence,
with this low number of trials, the Gaussian process that models
the performance function is not informed enough to effectively
guide the search. For the policy gradient algorithm, a gradient is
estimated by empirically measuring the partial derivative of the

performance function in each dimension. To do so, following62,
the policy gradient algorithm performs 15 trials at each iteration.
Consequently, when only 17 trials are allowed, it iterates only
once. In addition, policy gradient is a local optimization algo-
rithm that highly depends on the starting point (which is here
chosen randomly), as illustrated by the high variability in the
performance achieved with this variant (Extended Data Fig. 2b).
The issues faced by Bayesian optimization and policy gradi-
ent are exacerbated when the algorithms search directly in the
original, 36-dimensional parameter space instead of the lower-
dimensional (six-dimensional) behavior space of the map. As
mentioned previously, no working controller was found in the
two variants directly searching in this high-dimensional space.

Overall, the analysis after 17 trials shows that:
• The most critical component of the Intelligent Trial and Er-
ror Algorithm is the MAP-Elites algorithm, which reduces
the search space and produces a map of high-performing
behaviors in that space: p < 5 × 10−50 when comparing
variants searching in the behavior-performance map space
vs. variants that search in the original, higher-dimensional
space of motor parameters.

• Bayesian optimization critically improves the search, but
only when it is initialized with the performance obtained in
simulation during the behavior-performance map creation
step (with initialization: 0.26 [0.20; 0.33] m/s, without ini-
tialization: 0.20 [0.13; 0.25] m/s, p = 10−96).

To check whether these variants might perform better if allowed
the number of evaluations typically given to previous state-of-
the-art algorithms62,32,42, we continued the experiments until 150
trials on the robot were conducted (Extended Data Fig. 2c). Al-
though the results for all the variants improved, Intelligent Trial
and Error still outperforms all them (p < 10−94; Intelligent Trial
and Error: 0.31 [0.26; 0.37] m/s, random search: 0.26 [0.22; 0.30]
m/s, Bayesian optimization: 0.25 [0.18; 0.31] m/s, policy search:
0.23 [0.19, 0.29] m/s). These results are consistent with the previ-
ously published results62,32,42,17, which optimize in 4 to 10 dimen-
sions in a few hundred trials. Nevertheless, when MAP-Elites is
not used, i.e. when we run these algorithms in the original 36
dimensions for 150 evaluations, Bayesian optimization and pol-
icy gradient both perform much worse (Bayesian optimization:
0.08 [0.05; 0.12]; policy gradient: 0.06 [0.01; 0.12] m/s). These re-
sults shows that MAP-Elites is a powerful method to reduce the
dimensionality of a search space for learning algorithms, in addi-
tion to providing helpful priors about the search space that speed
up Bayesian optimization.

Overall, these additional experiments demonstrate that each
of the three main components of the Intelligent Trial and Error
Algorithm substantially improves performance. The results also
indicate that Intelligent Trial and Error signiﬁcantly outperforms
previous algorithms for both damage recovery63,12,64,65,66 and gait
learning67,62,68,48,69,32,61,42,17,49, and can therefore be considered the
state of the art.

4 Supplementary Experiments S3

Robustness to environmental changes

Methods The map creation algorithm (MAP-Elites) uses an un-
damaged robot on ﬂat terrain. The main experiments show that
this algorithm provides useful priors for damage recovery on a
ﬂat terrain. In these supplementary experiments, we evaluated,
in simulation, if the map created on ﬂat terrain also provides a
useful starting point for discovering gaits for sloped terrains.

We ﬁrst evaluated the effect slopes have on undamaged robots
(Extended Data Fig. 3a). We launched 10 replicates for each of
the eight maps and each one-degree increment between −20◦
and +20◦, for a total of 10 × 8 × 41 = 3280 experiments. As in

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 21

Supplementary Experiments S2, to roughly simulate the distribu-
tion of noisy odometry measurements on the real robot, we per-
turbed performance values with a multiplicative Gaussian noise
centered on 0.95 with a standard deviation of 0.1.

Results The results show that, when the slope is negative (de-
scending), the Intelligent Trial and Error approach ﬁnds fast gaits
in fewer than than 3 trials. For reference, a hand-designed, clas-
sic, tripod gait (section 1.4) falls on slopes below −15◦ degrees.
When the slope is positive (ascent), Intelligent Trial and Error
ﬁnds slower behaviors, as is expected, but even above 10◦ the
gait learned by Intelligent Trial and Error outperforms the ref-
erence gait on ﬂat ground. Overall, for every slope angle, the
controller found by Intelligent Trial and Error is faster than the
hand-designed reference controller.

We further evaluated damage recovery performance for these
same slopes with the same setup as Experiments S2 (6 damage
conditions). We launched 10 replicates for each damage condi-
tion, for 8 independently generated behavior-performance maps,
and each two-degree increment between −20◦ and +20◦ degrees.
There are therefore 480 replicates for each two-degree increment
between −20◦ and +20◦, for a total of 480 × 21 = 10080 experi-
ments.

Intelligent Trial and Error is not critically affected by variations
of slope between −10◦ and +10◦ (Extended Data Fig. 3b): for
these slopes, and for all 6 damage conditions, Intelligent Trial
and Error ﬁnds fast gaits (above 0.2 m/s) in less than 15 tests
on the robot despite the slope. As expected, it ﬁnds faster gaits
for negative slopes (descent) and slower gaits for positive slopes
(ascent). For slopes below −10◦ and above 10◦, the algorithm
performs worse and requires more trials. These results likely are
caused by the constraints placed on the controller and the lim-
ited sensors on the robot, rather than the inabilities of the algo-
rithm. Speciﬁcally, the controller was kept simple to make the sci-
ence clearer, more intuitive, and more reproducible. Those con-
straints, of course, prevent it from performing the more complex
behaviors necessary to deal with highly sloped terrain. For exam-
ple, the constraints prevent the robot from keeping its legs ver-
tical on sloped ground, which would substantially reduce slip-
page. Nevertheless, the median Intelligent Trial and Error com-
pensatory gait still outperforms the median performance of the
reference gait on all slope angles.

5 Supplementary Experiments S4

Comparison between MAP-Elites and Random
Sampling

Methods The MAP-Elites algorithm is a stochastic search algo-
rithm that attempts to ﬁll a discretized map with the highest-

performing solution at each point in the map. As explained in
the main text, each point in the map represents a different type
of behavior, as deﬁned by the behavioral dimension of the map.
MAP-Elites generates new candidate points by randomly select-
ing a location in the map, changing the parameters of the con-
troller that is stored there, and then saving that controller in the
appropriate map location if it is better than the current occupant
at that location. Intuitively, generating new candidate solutions
from the best solutions found so far should be better than gener-
ating a multitude of controllers randomly and then keeping the
best one found for each location in the map. In this section we
report on experiments that conﬁrm that intuition.

To understand the advantages of MAP-Elites over random
sampling, we compared the two algorithms by generating data
with the simulated hexapod. The experiments have the same vir-
tual robot, environment, controller, performance function, and
behavioral descriptors as in the main experiments (see Methods).
We analyzed the number of cells for which a solution is found (an
indication of the diversity of behavior types the algorithms gen-
erate), the average performance of behaviors in the map, and the
maximum performance discovered.

We replicated each experiment 8 times, each of which included

20 million evaluations on the simulated robot.

Results The results show that the MAP-Elites algorithm out-
performs random sampling on each of these measures (Extended
Data Fig. 10). After 20 million evaluations, about 13000 cells
(median: 12968, 5th & 95th percentiles: [12892; 13018]) are ﬁlled
by MAP-Elites (about 83% percent of the map), whereas random
sampling only ﬁlled approximately 8600 (8624 [8566; 8641]) cells
(about 55% percent of the map) (Extended Data Fig. 10a). The
difference between the two algorithms is large and appears early
(Extended Data Fig. 10a); after only 1 million evaluations, MAP-
Elites ﬁlled 10670 [10511; 10775] cells (68% of the map), whereas
random sampling ﬁlled 5928 [5882; 5966] cells (38% of the map).
The solutions discovered by MAP-Elites are not only more nu-
merous, but also outperform those found by random sampling
(Extended Data Fig. 10b): with MAP-Elites, after 20 million eval-
uations the average performance of ﬁlled cells is 0.22 [0.22; 0.23]
m/s, whereas it is 0.06 [0.06; 0.06] m/s with random sampling,
which is similar to the performance obtained with the reference
controller on a damaged robot (Fig. 3). These two results demon-
strate that MAP-Elites is a much better algorithm than random
sampling to ﬁnd a map of the diverse, “elite” performers in a
search space.

In addition, MAP-Elites is a better optimization algorithm, as
measured by the performance of the best single solution pro-
duced. The performance of the best solution in the map after
20 million evaluations is 0.40 [0.39;0.41] m/s with MAP-Elites,
compared to 0.21 [0.20; 0.22] m/s with random sampling.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 22

Extended Data Figure 10 | Comparing MAP-Elites and random sampling for generating behavior-performance maps. (a) The number of points
in the map for which a behavior is discovered. (b) The mean performance of the behaviors in the map. (c) The maximum performance of the
behaviors in the map. For all these ﬁgures, the middle lines represent medians over 8 independently generated maps and the shaded regions extend
to the 25th and 75th percentiles, even for (a) and (b), where the variance of the distribution is so small that it is difﬁcult to see. See Supplementary
Experiment S4 for methods and analysis.

where ΘT (k), ΨT (k) and ΦT (k) denote the pitch, roll and
yaw angles, respectively, of the robot torso (hence T ) at the
end of interval k, and K denotes the number of 15ms in-
tervals during the 5 seconds of simulated movement (here,
K = 5s/0.015s ≈ 334). The unit step function U (·) returns
1 if its argument exceeds 0, and returns 0 otherwise. To dis-
count for insigniﬁcant motion around 0 rad, orientation an-
gles are only deﬁned as positive if they exceed 0.5% of π rad.
Similarly, orientation angles are only deﬁned as negative if
they are less than −0.5% of π rad.

3. Displacement (6-dimensional): This behavioral descriptor
characterizes changes in the postion of the robot during
It is measured as the proportion of 15ms inter-
walking.
vals that the robot is positively or negatively displaced along
each of the x, y, and z axes:

x =











(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)

1
K
1
K
1
K
1
K
1
K
1
K

k U (∆x(k) − 0.001)
k U (−∆x(k) − 0.001)
k U (∆y(k) − 0.001)
k U (−∆y(k) − 0.001)
k U (∆z(k) − 0.001)
k U (−∆z(k) − 0.001)











(15)

where [∆x(k), ∆y(k), ∆z(k)] denote the linear displacement
in meters of the robot during interval k, and K denotes the
number of 15ms intervals during 5 seconds of simulated
movement (here, K = 5s/0.015s ≈ 334). The unit step func-
tion U (·) returns a value of 1 if its argument exceeds 0, and
returns a value of 0 otherwise. To ignore insigniﬁcant mo-
tion, linear displacements are deﬁned to be positive if they
exceed 1mm, and are deﬁned to be negative if they are less
than −1mm.

6 Supplementary Experiments S5

Alternative behavioral descriptors

Methods To create a map with MAP-Elites, one has to deﬁne
the dimensions of the behavioral space, i.e. the behavioral de-
scriptors. The main experiments show that using a predeﬁned
behavioral descriptor (the proportion of time that each leg of a
hexapod robot is in contact with the ground, i.e. the duty factor)
creates a map that provides useful priors for damage recovery.

This section describes how we tested (in simulation) how per-
formance is affected by alternative behavioral descriptors, in-
cluding descriptors that have a different number of dimensions.
We also evaluated how performance is affected if the behavioral
descriptors are randomly selected from a large list of potential
descriptors. This test simulates the algorithm’s performance if
the behavioral descriptors are chosen without insight into the
problem domain.

The behavioral descriptors we tested are as follows:
1. Duty factor (6-dimensional): This descriptor is the default
one from the main experiment. It corresponds to the pro-
portion of time each leg is in contact with the ground:







x =

(cid:80)

t C1(t)
numTimesteps

...

(cid:80)

t C6(t)
numTimesteps







where Ci(t) denotes the Boolean value of whether leg i is in
contact with the ground at time t (1: contact, 0: no contact).
2. Orientation (6-dimensional): This behavioral descriptor
characterizes changes in the angular position of the robot
during walking, measured as the proportion of 15ms inter-
vals that each of the pitch, roll and yaw angles of the robot
frame are positive (three dimensions) and negative (three
additional dimensions):

x =











1
K
1
K
1
K
1
K
1
K
1
K

(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)

k U (ΘT (k) − 0.005π)
k U (−ΘT (k) − 0.005π)
k U (ΨT (k) − 0.005π)
k U (−ΨT (k) − 0.005π)
k U (ΦT (k) − 0.005π)
k U (−ΦT (k) − 0.005π)











(13)

(14)

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 23

4. Total energy expended per leg (6-dimensional): This be-
havioral descriptor captures the total amount of energy ex-
pended to move each leg during 5 seconds of movement:







E1
ME

...







x =

E6
ME
where Ei denotes the energy utilized by leg i of the robot
during 5 seconds of simulated movement, measured in
N.m.rad. ME is the maximum amount of energy available
according to the servo model of the simulator, which for 5
seconds is 100 N.m.rad.

5. Relative energy expended per leg (6-dimensional): This be-
havioral descriptor captures the amount of energy expended
to move each leg relative to the energy expended by all the
legs during 5 seconds of simulated movement:







x =

(cid:80)

E1
i=1..6 Ei

...

(cid:80)

E6
i=1..6 Ei







(17)

where Ei denotes the energy utilized by leg i of the robot
during 5 seconds of simulated movement, measured in
N.m.rad.

6. Deviation (3-dimensional): This descriptor captures the
range of deviation of the center of the robot frame versus
the expected location of the robot if it traveled in a straight
line at a constant speed.

(cid:18)

x =

0.95

max
t

(y(t)−

yﬁnal

0.2
5 ×t)−min
0.2

t

(y(t)−

(cid:19)

yﬁnal

5 ×t)

(18)










(cid:18)

0.95

max
t

(x(t))−min

(x(t))

(cid:19)

(cid:19)

t

t

(cid:18)

0.95

max
t

(z(t))−min

(z(t))

0.2










where [x(t), y(t), z(t)] denote the position of robot’s center
at time t, and [xﬁnal, yﬁnal, zﬁnal] denote its ﬁnal position after
5 seconds.
The robot’s task is to move along the y-axis. Its starting po-
sition is (0,0,0). The deviation along the x and z axes is com-
puted as the maximum difference in the robot’s position in
those dimensions at any point during 5 seconds. For the y
axis, yﬁnal
corresponds to the average speed of the robot (the
5
distance covered divided by total time), therefore yﬁnal
5 × t is
the expected position at timestep t if the robot was moving
at constant speed. The deviation from the y axis is computed
with respect to this “theoretical” position.
To obtain values in the range [0,1], the ﬁnal behavioral de-
scriptors are multiplied by 0.95 and then divided by 20 cm
(these values were determined empirically).

7. Total ground reaction force per leg (6-dimensional): This be-
havioral descriptor corresponds to the amount of force each
leg applies to the ground, measured as a fraction the to-
tal possible amount of force that a leg could apply to the
ground. Speciﬁcally, the measurement is

x =













F1
MF

...

F6
MF

(19)

where Fi denotes the ground reaction force (GRF) each leg
i generates, averaged over 5 seconds of simulated move-
ment. MF is the maximum such force that each leg can ap-
ply, which is 10N.

(16)

8. Relative ground reaction force per leg (6-dimensional): This
behavioral descriptor corresponds to the amount of force
each leg applies to the ground, relative to that of all the legs:







x =

(cid:80)

F1
i=1..6 Fi

...

(cid:80)

F6
i=1..6 Fi







x =















(cid:80)

1 (t)

t ΘL
π×N1
...
t ΘL
π×N6

(cid:80)

6 (t)

x =








(cid:80)

1 (t)

t ΨL
π×N1
...
t ΨL
π×N6

(cid:80)

6 (t)








where Fi denotes the ground reaction force (GRF) each leg i
generates, averaged over 5 seconds of simulated movement.
9. Lower-leg pitch angle (6-dimensional): This descriptor cap-
tures the pitch angle for the lower-leg with respect to the
ground (in a global coordinate frame), averaged over 5 sec-
onds:

where ΘL
i (t) is the pitch angle of lower-leg i (hence the L in
ΘL
i ) when it is in contact with the ground at time t, and Ni is
the number of time-steps for which lower-leg i touches the
ground. The foot pitch angles are in range [0, π] (as the leg
can not penetrate the ground) and normalized to [0, 1].
10. Lower-leg roll angle (6-dimensional): This descriptor cap-
tures the roll angle for the lower-leg with respect to the
ground (in a global coordinate frame), averaged over 5 sec-
onds:

where ΨL
i (t) is the roll angle of lower-leg i (hence L in ΨL
i )
when it is in contact with the ground at time t, and Ni is
the number of time-steps for which lower-leg i touches the
ground. The foot roll angles are in range [0, π] (as the leg can
not penetrate the ground) and normalized to [0, 1].

11. Lower-leg yaw angle (6-dimensional): This descriptor cap-
tures the yaw angle for the lower-leg with respect to the
ground (in a global coordinate frame), averaged over 5 sec-
onds:

x =








(cid:80)

1 (t)+π

t ΦL
2π×N1
...
t ΦL
2π×N6

(cid:80)

6 (t)+π








where ΦL
i (t) is the yaw angle of lower-leg i (hence L in ΦL
i )
when it is in contact with the ground at time t,and Ni is
the number of time-steps for which lower-leg i touches the
ground. The foot yaw angles are in range [−π, π] and are
normalized to [0, 1].

(20)

(21)

(22)

(23)

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 24

12. Random (6-dimensional): The random behavioral descrip-
tor differs from the other intentionally chosen descriptors
in that it does not consist of one type of knowledge, but
is instead randomly selected as a subset of variables from
the previously described 11 behavioral descriptors. This de-
scriptor is intended to simulate a situation in which one has
little expectation for which behavioral descriptor will per-
form well, so one quickly picks a few different descriptor
dimensions without consideration or experimentation. In-
stead of generating one such list in this fashion, we ran-
domly sample from a large set to ﬁnd the average perfor-
mance of this approach over many different possible choices.
For the random descriptor, each of the 6-dimensions is se-
lected at random (without replacement) from the 1×3+10×
6 = 63 available behavior descriptor dimensions described
in the previous 11 descriptors (1 of the above descriptors is
three-dimensional and the other 10 are six-dimensional):

x =











R1
...
R6

(24)

where Ri denotes the ith dimension of the descriptor, ran-
domly selected uniformly and without replacement from the
63 available dimensions in behavior descriptors 1-11.

It was necessary to compare these behavioral descriptors in
simulation because doing so on the physical robot would have re-
quired months of experiments and would have repeatedly worn
out or broken the robot. We modiﬁed the simulator from the
main experiments (section 1.4) to emulate 6 different possible
damage conditions, each of which involved removing a differ-
ent leg. The MAP-Elites algorithm, run for 3 million iterations,
was used to create the behavior-performance maps for each of
the behavioral descriptors (using a simulation of the undamaged
robot). During the generation of the behavior-performance maps,
the behaviors were stored in the map’s cells by discretizing each
dimension of the behavioral descriptor space with these ﬁve val-
ues: {0, 0.25, 0.5, 0.75, 1} for the 6-dimensional behavioral de-
scriptors, and with twenty equidistant values between [0, 1] for
the 3-dimensional behavioral descriptor. During the adaptation
phase, the behaviors were used with their actual values and thus
not discretized.

We independently generated eight maps for each of the 11
intentionally chosen behavioral descriptors. Twenty indepen-
dently generated maps were generated for the random behav-
ioral descriptor. We launched ten replicates of each descriptor for
each of the maps (eight for intentionally chosen behavioral de-
scriptors and twenty for random behavioral descriptor) and each
of the six damage conditions. There are therefore 10×8×6 = 480
replicates for each of the intentionally chosen descriptors, and
10 × 20 × 6 = 1200 replicates for the random descriptor.
In
all these simulated experiments, to roughly simulate the distri-
bution of noisy odometry measurements on the real robot, the
simulated performance values were randomly perturbed with a
multiplicative Gaussian noise centered on 0.95 with a standard
deviation of 0.1.

We analyze the fastest walking speed achieved with each be-
havioral descriptor after two different numbers of trials: the ﬁrst
case is after 17 trials, and the second case is after 150 trials.

Results The following results include 17 trials on the simulated
robot, which was the maximum number of trials required for In-
telligent Trial and Error to ﬁnd a compensatory gait in the Sup-
plementary Experiment S2. The post-adaptation performance

achieved with our alternative, intentionally chosen behavioral
descriptors (numbers 2-11) was similar to the original duty factor
behavioral descriptor (number 1) (Extended Data Fig. 4a). All 11
alternative, intentionally chosen descriptors (numbers 2-11) led
to a median performance within 17% of the duty factor descrip-
tor (performance: 0.241 [0.19; 0.29] m/s). The difference in per-
formance was effectively nonexistent with the deviation descrip-
tor (0.241 [0.14; 0.31] m/s), the total GRF descriptor (0.237 [0.15;
0.30] m/s), and the lower-leg roll angle descriptor (0.235 [0.14;
0.31] m/s). The lowest performance was discovered with the rel-
ative GRF descriptor (16.7% lower than the duty factor descrip-
tor, 0.204 [0.08; 0.31] m/s).
In terms of statistical signiﬁcance,
the performance achieved with the duty factor descriptor was no
different from the deviation (p = 0.53) and total GRF (p = 0.29)
descriptors. With all the remaining descriptors, the difference in
performance was statistically signiﬁcant (p < 10−3), but it did
not exceed 0.04m/s. Additionally, the compensatory behaviors
discovered with all our 11 alternative, intentionally chosen de-
scriptors were always faster than the reference gait for all damage
conditions.

To check whether our alternative, intentionally chosen behav-
ioral descriptors lead to better performance if allowed a higher
number of evaluations, we extended the experiments to 150 tri-
als on the robot (Extended Data Fig. 4b). After 150 trials, the dif-
ference in performance between the duty factor behavioral de-
scriptor (0.277 [0.24; 0.34] m/s) and our alternative behavioral
descriptors was further reduced. For all but three alternative,
intentionally chosen descriptors (displacement, total GRF and
lower-leg yaw angle), the median performance was within 4% of
the duty factor descriptor. The difference in performance was at
±3.6% with the orientation (0.274 [0.22; 0.32] m/s), total energy
(0.274 [0.19; 0.33] m/s), relative energy (0.273 [0.20; 0.32] m/s),
deviation (0.287 [0.21; 0.34] m/s), relative GRF (0.266 [0.15; 0.35]
m/s), lower-leg pitch angle (0.271 [0.21; 0.34] m/s) and lower-
leg roll angle (0.268 [0.17; 0.34] m/s) descriptors.
In the three
remaining behavioral descriptors, displacement, total GRF, and
lower-leg yaw angle, the performance was 0.264 [0.18; 0.32] m/s,
0.299 [0.25; 0.35] m/s and 0.255 [0.18; 0.32] m/s, respectively (dif-
ference at ±7.8% of duty factor descriptor in all three cases). In
terms of statistical signiﬁcance, the performance achieved with
the duty factor descriptor was barely statistically signiﬁcantly
different from the deviation descriptor (p = 0.041). In all the re-
maining descriptors, the performance difference was statistically
signiﬁcant (p < 10−2), but no larger than 0.02m/s.

Our random behavioral descriptor also performed similarly to
the duty factor descriptor. After 17 trials, the performance of
M-BOA with the maps generated by the random descriptor was
0.232 [0.14; 0.30] m/s (4.2% lower than the duty factor descrip-
tor performance). While the difference is statistically signiﬁcant
(p < 10−3), the difference in performance itself was negligible at
0.01m/s. This difference in performance was further reduced to
3.6% after 150 trials (random descriptor performance: 0.274 [0.21;
0.34] m/s, duty factor description performance: 0.277 [0.24; 0.34]
m/s, p = 0.002). Moreover, as with the intentionally chosen be-
havioral descriptors, the compensatory behavior discovered with
the random descriptor was also faster than the reference gait.

These experiments show that the selection of the behavioral
dimensions is not critical to get good results. Indeed, all tested
behavioral descriptors, even those randomly generated, perform
well (median > 0.20 m/s after 17 trials). On the other hand, if
the robot’s designers have some prior knowledge about which
dimensions of variation are likely to reveal different types of be-
haviors, the algorithm can beneﬁt from this knowledge to further
improve results (as with the duty factor descriptor).

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 25

7 Caption for Supplementary Videos

Video S1

This video can be viewed at: https://youtu.be/T-c17RKh3uE
Damage Recovery in Robots via Intelligent Trial and Error.
The video shows the Intelligent Trial and Error Algorithm in ac-
tion with the two robots introduced in this paper: the hexapod
robot and the 8 degrees of freedom robotic arm (Fig. 3). The
video shows several examples of the different types of behav-
iors that are produced during the behavior-performance map cre-
ation step, from classic hexapod gaits to more unexpected forms
of locomotion. Then, it shows how the hexapod robot uses that
behavior-performance map to deal with a leg that has lost power
(Fig. 3a:C3). Finally, the video illustrates how the Intelligent Trial
and Error Algorithm can be applied to the second robot and to
different damage conditions.

Video S2

This video can be viewed at: http://youtu.be/ycLspV5lXK8
A Behavior-Performance Map Containing Many Different
Types of Walking Gaits. In the behavior-performance map cre-
ation step, the MAP-Elites algorithm produces a collection of dif-
ferent types of walking gaits. The video shows several examples
of the different types of behaviors that are produced, from classic
hexapod gaits to more unexpected forms of locomotion.

Supplementary References

30. A. E. Eiben and J. E. Smith. Introduction to evolutionary computing. Springer,

31.

2003.
J.-B. Mouret and J. Clune. “Illuminating search spaces by mapping elites”.
In: arXiv preprint arXiv:1504.04909 (2015).

32. D. J. Lizotte, T. Wang, M. H. Bowling, and D. Schuurmans. “Automatic Gait
Optimization with Gaussian Process Regression.” In: Proceedings of the the
International Joint Conference on Artiﬁcial Intelligence (IJCAI). Vol. 7. 2007,
pp. 944–949.

34.

33. E. Brochu, V. M. Cora, and N. De Freitas. “A tutorial on Bayesian optimization
of expensive cost functions, with application to active user modeling and hi-
erarchical reinforcement learning”. In: arXiv preprint arXiv:1012.2599 (2010).
J. Snoek, H. Larochelle, and R. P. Adams. “Practical Bayesian Optimization
of Machine Learning Algorithms”. In: Advances in Neural Information Pro-
cessing Systems 25 (NIPS). 2012, pp. 2951–2959.
T. L. Grifﬁths, C. Lucas, J. Williams, and M. L. Kalish. “Modeling human func-
tion learning with Gaussian processes”. In: Advances in Neural Information
Processing Systems 21 (NIPS). 2009, pp. 553–560.

35.

36. A. J. Booker, J. E. Dennis Jr, P. D. Frank, D. B. Seraﬁni, V. Torczon, and M.
W. Trosset. “A rigorous framework for optimization of expensive functions by
surrogates”. In: Structural optimization 17.1 (1999), pp. 1–13.

39.

37. A. I. J. Forrester and A. J. Keane. “Recent advances in surrogate-based op-
timization”. In: Progress in Aerospace Sciences 45.1 (2009), pp. 50–79.
38. Y Jin. “Surrogate-assisted evolutionary computation: Recent advances and
future challenges”. In: Swarm and Evolutionary Computation 1.2 (2011),
pp. 61–70.
T. W. Simpson, T. M. Mauery, J. J. Korte, and F. Mistree. “Comparison of re-
sponse surface and kriging models for multidisciplinary design optimization”.
In: American Institute of Aeronautics and Astronautics 98.7 (1998), pp. 1–16.
40. D. R. Jones, M. Schonlau, and W. J. Welch. “Efﬁcient global optimization
of expensive black-box functions”. In: Journal of Global optimization 13.4
(1998), pp. 455–492.
J. Sacks, W. J. Welch, T. J. Mitchell, H. P. Wynn, et al. “Design and analysis
of computer experiments”. In: Statistical science 4.4 (1989), pp. 409–423.

41.

42. R. Calandra, A. Seyfarth, J. Peters, and M. P. Deisenroth. “An experimen-
tal comparison of Bayesian optimization for bipedal
locomotion”. In: Pro-
ceedings of the IEEE International Conference on Robotics and Automation
(ICRA). 2014.

43. B. Matérn et al. “Spatial variation. Stochastic models and their application
to some problems in forest surveys and other sampling investigations.” In:
Meddelanden fran statens Skogsforskningsinstitut 49.5 (1960).

44. M. L. Stein. Interpolation of spatial data: some theory for kriging. Springer,

1999.

45. A. V. Fiacco and G. P. McCormick. Nonlinear programming: sequential un-

46.

constrained minimization techniques. Vol. 4. Siam, 1990.
I. Dryanovski, R. G. Valenti, and J. Xiao. “Fast visual odometry and mapping
from rgb-d data”. In: Proceedings of the IEEE International Conference on
Robotics and Automation (ICRA). IEEE. 2013, pp. 2305–2310.

49.

47. M. Quigley, K. Conley, B. P. Gerkey, J. Faust, T. Foote, J. Leibs, R. Wheeler,
and A. Y. Ng. “ROS: an open-source Robot Operating System”. In: Proceed-
ings of ICRA’s workshop on Open Source Software. 2009.

48. A. Sproewitz, R. Moeckel, J. Maye, and A. Ijspeert. “Learning to move in
modular robots using central pattern generators and online optimization”. In:
The International Journal of Robotics Research 27.3-4 (2008), pp. 423–443.
J. Yosinski, J. Clune, D. Hidalgo, S. Nguyen, J. Zagal, and H. Lipson. “Evolv-
ing Robot Gaits in Hardware: the HyperNEAT Generative Encoding Vs. Pa-
rameter Optimization”. In: Proceedings of ECAL (2011), pp. 890–897.
J. Clune, K. Stanley, R. Pennock, and C. Ofria. “On the performance of indi-
rect encoding across the continuum of regularity”. In: IEEE Transactions on
Evolutionary Computation 15.3 (2011), pp. 346–367.
J. Clune, B. Beckmann, C. Ofria, and R. Pennock. “Evolving coordinated
quadruped gaits with the HyperNEAT generative encoding”. In: Proceedings
of the IEEE Congress on Evolutionary Computation. 2009, pp. 2764–2771.

51.

50.

52. S. Lee, J. Yosinski, K. Glette, H. Lipson, and J. Clune. “Evolving gaits for
physical robots with the HyperNEAT generative encoding: the beneﬁts of sim-
ulation.” In: Applications of Evolutionary Computing. Springer, 2013.
53. D. Wilson. “Insect walking”. In: Annual Review of Entomology 11.1 (1966),

pp. 103–122.

54. U. Saranli, M. Buehler, and D. Koditschek. “Rhex: A simple and highly mo-
bile hexapod robot”. In: The International Journal of Robotics Research 20.7
(2001), pp. 616–631.
J. Schmitz, J. Dean, T. Kindermann, M. Schumm, and H. Cruse. “A biolog-
ically inspired controller for hexapod walking: simple solutions by exploiting
physical properties”. In: The biological bulletin 200.2 (2001), pp. 195–200.

55.

56. X. Ding, Z. Wang, A. Rovetta, and J. Zhu. “Locomotion analysis of hexa-
pod robot”. In: Proceedings of Conference on Climbing and Walking Robots
(CLAWAR) (2010), pp. 291–310.

57. S. Steingrube, M. Timme, F. Wörgötter, and P. Manoonpong. “Self-organized
adaptation of a simple neural circuit enables complex robot behaviour”. In:
Nature Physics 6.3 (2010), pp. 224–230.
F. Delcomyn. “The Locomotion of the Cockroach Pariplaneta americana”. In:
Journal of Experimental Biology 54.2 (1971), pp. 443–452.

58.

59. S. Thrun, W. Burgard, D. Fox, et al. Probabilistic robotics. MIT press Cam-

bridge, 2005.

60. M. G. Dissanayake, P. Newman, S. Clark, H. F. Durrant-Whyte, and M.
Csorba. “A solution to the simultaneous localization and map building
(SLAM) problem”. In: IEEE Transactions on Robotics and Automation 17.3
(2001), pp. 229–241.

61. M. Tesch, J. Schneider, and H. Choset. “Using response surfaces and ex-
pected improvement to optimize snake robot gait parameters”. In: Proceed-
ings of the IEEE/RSJ International Conference on Intelligent Robots and Sys-
tems (IROS). IEEE. 2011, pp. 1069–1074.

62. N. Kohl and P. Stone. “Policy gradient reinforcement

learning for fast
quadrupedal locomotion”. In: Proceedings of the IEEE International Confer-
ence on Robotics and Automation (ICRA). Vol. 3. IEEE. 2004, pp. 2619–
2624.

63. M. S. Erden and K. Leblebicio ˘glu. “Free gait generation with reinforcement
learning for a six-legged robot”. In: Robotics and Autonomous Systems 56.3
(2008), pp. 199–212.

64. D. J. Christensen, J. C. Larsen, and K. Stoy. “Fault-tolerant gait learning and
morphology optimization of a polymorphic walking robot”. In: Evolving Sys-
tems 5 (2014), pp. 21–32.

65. S. Mahdavi and P. Bentley. “Innately adaptive robotics through embodied

evolution”. In: Autonomous Robots 20.2 (2006), pp. 149–163.

66. S. Koos, A. Cully, and J.-B. Mouret. “Fast damage recovery in robotics with
the T-resilience algorithm”. In: The International Journal of Robotics Re-
search 32.14 (2013), pp. 1700–1723.

67. G. Hornby, S. Takamura, T. Yamamoto, and M. Fujita. “Autonomous evolu-
tion of dynamic gaits with two quadruped robots”. In: IEEE Transactions on
Robotics 21.3 (2005), pp. 402–410.
T. Barfoot, E. Earon, and G. D’Eleuterio. “Experiments in learning distributed
control for a hexapod robot”. In: Robotics and Autonomous Systems 54.10
(2006), pp. 864–872.

68.

69. S. Koos, J.-B. Mouret, and S. Doncieux. “The transferability approach: Cross-
ing the reality gap in evolutionary robotics”. In: IEEE Transactions on Evolu-
tionary Computation 17.1 (2013), pp. 122–145.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 26

This manuscript is the pre-submission manuscript provided by the authors.
For the ﬁnal, post-review version, please see: http://dx.doi.org/10.1038/nature14422

Robots that can adapt like animals

Antoine Cully,1,2 Jeff Clune,6 Danesh Tarapore,1,2 Jean-Baptiste Mouret1−5,∗

5
1
0
2
 
y
a
M
 
7
2
 
 
]

O
R
.
s
c
[
 
 
4
v
1
0
5
3
.
7
0
4
1
:
v
i
X
r
a

As robots leave the controlled environments of factories to
autonomously function in more complex, natural environ-
ments1,2,3, they will have to respond to the inevitable fact that
they will become damaged4,5. However, while animals can
quickly adapt to a wide variety of injuries, current robots can-
not “think outside the box” to ﬁnd a compensatory behavior
when damaged:
they are limited to their pre-speciﬁed self-
sensing abilities, can diagnose only anticipated failure modes6,
and require a pre-programmed contingency plan for every type
of potential damage, an impracticality for complex robots4,5.
Here we introduce an intelligent trial and error algorithm that
allows robots to adapt to damage in less than two minutes,
without requiring self-diagnosis or pre-speciﬁed contingency
plans. Before deployment, a robot exploits a novel algorithm
to create a detailed map of the space of high-performing behav-
iors: This map represents the robot’s intuitions about what be-
haviors it can perform and their value. If the robot is damaged,
it uses these intuitions to guide a trial-and-error learning algo-
rithm that conducts intelligent experiments to rapidly discover
a compensatory behavior that works in spite of the damage. Ex-
periments reveal successful adaptations for a legged robot in-
jured in ﬁve different ways, including damaged, broken, and
missing legs, and for a robotic arm with joints broken in 14
different ways. This new technique will enable more robust,
effective, autonomous robots, and suggests principles that ani-
mals may use to adapt to injury.

Robots have transformed the economics of many industries,
most notably manufacturing7, and have the power to deliver
tremendous beneﬁts to society, such as in search and rescue8,
disaster response9, health care3, and transportation10. They are
also invaluable tools for scientiﬁc exploration, whether of distant
planets1,4 or deep oceans2. A major obstacle to their widespread
adoption in more complex environments outside of factories is
their fragility4,5: Robots presently pale in comparison to natural
animals in their ability to invent compensatory behaviors after an
injury (Fig. 1A).

Current damage recovery in robots typically involves two
phases: self-diagnosis, and then selecting the best, pre-designed
contingency plan11,12,13,14. Such self-diagnosing robots are expen-
sive, because self-monitoring sensors are expensive, and are difﬁ-
cult to design, because robot engineers cannot foresee every pos-
sible situation: this approach often fails either because the diag-
nosis is incorrect12,13 or because an appropriate contingency plan
is not provided14.

Injured animals respond differently: they learn by trial and
learning which
error how to compensate for damage (e.g.
limp minimizes pain)15,16. Similarly, trial-and-error learning al-
gorithms could allow robots to creatively discover compensatory
behaviors without being limited to their designers’ assumptions
about how damage may occur and how to compensate for each
damage type. However, state-of-the-art learning algorithms are
impractical because of the “curse of dimensionality”17: the fastest

1 Sorbonne Universités, UPMC Univ Paris 06, UMR 7222, ISIR, F-75005, Paris
2 CNRS, UMR 7222, ISIR, F-75005, Paris, France
3 Inria, Villers-lès-Nancy, F-54600, France
4 CNRS, Loria, UMR 7503, Vandœuvre-lès-Nancy, F-54500, France
5 Université de Lorraine, Loria, UMR 7503, Vandœuvre-lès-Nancy, F-54500,
France
6 University of Wyoming, Laramie, WY, USA
∗ Corresponding author: jean-baptiste.mouret@inria.fr

tun-
algorithms constrain the search to a few behaviors (e.g.
ing only 2 parameters, requiring 5-10 minutes) or require human
demonstrations17. Algorithms without these limitations take sev-
eral hours17. Damage recovery would be much more practical
and effective if robots adapted as creatively and quickly as an-
imals (e.g.
in minutes) and without expensive self-diagnosing
sensors.

Here, we show that rapid adaptation can be achieved by guid-
ing an intelligent trial-and-error learning algorithm with an auto-
matically generated, pre-computed, behavior-performance map
that predicts the performance of thousands of different behaviors
(Supplementary Video S1). The key insight is that, whereas cur-
rent learning algorithms either start with no knowledge of the
search space17 or with minimal knowledge from a few human
demonstrations17,18, animals better understand the space of pos-
sible behaviors and their value from previous experience19, en-
abling injured animals to intelligently select tests that validate or
invalidate whole families of promising compensatory behaviors.
We have robots store knowledge from previous experience in
the form of a map of the behavior-performance space. Guided
by this map, a damaged robot tries different types of behaviors
that are predicted to perform well and, as tests are conducted, up-
dates its estimates of the performance of those types of behaviors.
The process ends when the robot predicts that the most effective
behavior has already been discovered. The result is a robot that
quickly discovers a way to compensate for damage (e.g. Fig. 1C)
without a detailed mechanistic understanding of its cause, as oc-
curs with animals. We call this approach “Intelligent Trial and
Error” (Fig. 1D).

The behavior-performance map is created with a novel algo-
rithm and a simulation of the robot, which either can be a stan-
dard physics simulator or can be automatically discovered12. The
robot’s designers only have to describe the dimensions of the
space of possible behaviors and a performance measure. For
instance, walking gaits could be described by how much each
leg is involved in a gait (a behavioral measure) and speed (a
performance measure). For grasping, performance could be the
amount of surface contact, and it has been demonstrated that 90%
of effective poses for the 21-degree-of-freedom human hand can
be captured by a 3-dimensional behavioral space20. To ﬁll in the
behavior-performance map, an optimization algorithm simulta-
neously searches for a high-performing solution at each point in
the behavioral space (Fig. 2A,B and Extended Data Fig. 1). This
step requires simulating millions of behaviors, but needs to be
performed only once per robot design before deployment (Meth-
ods).

A low conﬁdence is assigned to the predicted performance
of behaviors stored in this behavior-performance map because
they have not been tried in reality (Fig. 2B and Extended Data
Fig. 1). During the robot’s mission, if it senses a performance
drop, it selects the most promising behavior from the behavior-
performance map, tests it, and measures its performance. The
robot subsequently updates its prediction for that behavior and
nearby behaviors, assigns high conﬁdence to these predictions
(Fig. 2C and Extended Data Fig. 1), and continues the selec-
tion/test/update process until it ﬁnds a satisfactory compen-
satory behavior (Fig. 2D and Extended Data Fig. 1).

All of these ideas are technically captured via a Gaussian
process model21, which approximates the performance function

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 1

Figure 1| With Intelligent Trial and Error, robots, like animals, can quickly adapt to recover from damage. (A) Most animals can ﬁnd a compen-
satory behavior after an injury. Without relying on predeﬁned compensatory behaviors, they learn how to avoid behaviors that are painful or no longer
effective. (B) An undamaged, hexapod robot. (C) One type of damage the hexapod may have to cope with (broken leg). (D) After damage occurs, in
this case making the robot unable to walk straight, damage recovery via Intelligent Trial and Error begins. The robot tests different types of behaviors
from an automatically generated map of the behavior-performance space. After each test, the robot updates its predictions of which behaviors will
perform well despite the damage. This way, the robot rapidly discovers an effective compensatory behavior.

with already acquired data, and a Bayesian optimization proce-
dure22,23, which exploits this model to search for the maximum
of the performance function (Methods). The robot selects which
behaviors to test by maximizing an information acquisition func-
tion that balances exploration (selecting points whose perfor-
mance is uncertain) and exploitation (selecting points whose per-
formance is expected to be high) (Methods). The selected behav-
ior is tested on the physical robot and the actual performance is
recorded. The algorithm updates the expected performance of
the tested behavior and lowers the uncertainty about it. These
updates are propagated to neighboring solutions in the behav-
ioral space by updating the Gaussian process (Methods). These
updated performance and conﬁdence distributions affect which
behavior is tested next. This select-test-update loop repeats un-
til the robot ﬁnds a behavior whose measured performance is
greater than 90% of the best performance predicted for any be-
havior in the behavior-performance map (Methods).

We ﬁrst test our algorithm on a hexapod robot that needs to
walk as fast as possible (Fig. 1B, D). The robot has 18 motors, an
onboard computer, and a depth camera that allows the robot to
estimate its walking speed (Supplementary Methods). The gait
is parametrized by 36 real-valued parameters that describe the
amplitude of oscillation, phase shift, and duty cycle for each joint
(Supplementary Methods). The behavior space is 6-dimensional,
where each dimension is the proportion of time the ith leg spends
in contact with the ground (i.e. the duty factor)7 (Supplementary
Methods).

The created behavior-performance map contains approxi-
mately 13,000 different gaits (Supplementary Video S2 shows ex-
amples). We tested our robot in six different conditions: undam-
aged (Fig. 3A:C1), four different structural failures (Fig. 3A:C2-
C5), and a temporary leg repair (Fig. 3A:C6). We compare
the walking speed of resultant gaits with a widely-used, classic,
hand-designed tripod gait7 (Supplementary Methods). For each
of the 6 damage conditions, we ran our adaptation step 5 times
for each of 8 independently generated behavior-performance
maps (with the default “duty factor” behavioral description),
leading to 6 × 5 × 8 = 240 experiments in total. We also ran our
adaptation step 5 times on 8 independently generated behavior-
performance maps deﬁned by an alternate behavioral descrip-

tion (“body orientation”, see Supplementary Methods) on two
damage conditions (Fig. 3B-C), leading to 2 × 5 × 8 = 80 addi-
tional experiments.

When the robot is undamaged (Fig. 3A:C1), our approach
yields dynamic gaits that are 30% faster than the classic reference
gait (Fig. 3B, median 0.32 m/s, 5th and 95th percentiles [0.26;
0.36] vs. 0.24m/s), suggesting that Intelligent Trial and Error is
a good search algorithm for automatically producing successful
robot behaviors, putting aside damage recovery. In all the dam-
age scenarios, the reference gait is no longer effective (~0.04 m/s
for the four damage conditions, Fig. 3B:C2-C5). After Intelligent
Trial and Error, the compensatory gaits achieve a reasonably fast
speed (> 0.15m/s) and are between 3 and 7 times more efﬁcient
than the reference gait for that damage condition (in m/s, C2:
0.24 [0.18; 0.31] vs. 0.04; C3: 0.22 [0.18; 0.26] vs. 0.03; C4: 0.21
[0.17; 0.26] vs. 0.04; C5: 0.17 [0.12; 0.24] vs. 0.05; C6: 0.3 [0.21;
0.33] vs 0.12).

These experiments demonstrate that Intelligent Trial and Error
allows the robot to both initially learn fast gaits and to reliably re-
cover after physical damage. Additional experiments reveal that
these capabilities are substantially faster than state-of-the-art al-
gorithms (Extended Data Fig. 2), and that Intelligent Trial and Er-
ror can help with another major challenge in robotics: adapting
to new environments (Extended Data Fig. 3). On the undam-
aged or repaired robot (Fig. 3: C6), Intelligent Trial and Error
learns a walking gait in less than 30 seconds (Fig. 3C, undam-
aged: 24 [16; 41] seconds, 3 [2; 5] physical trials, repaired: 29 [16;
82] seconds, 3.5 [2; 10] trials). For the four damage scenarios, the
robot adapts in approximately one minute (66 [24; 134] seconds,
8 [3; 16] trials). Our results are qualitatively unchanged when
using different behavioral characterizations, including randomly
choosing 6 descriptors among 63 possibilities (Fig. 3B-C and Ex-
tended Data Fig. 4). Additional experiments show that reducing
the high-dimensional parameter space to a low-dimensional be-
havior space via the behavior-performance map is the key com-
ponent for intelligent trial and error: standard Bayesian opti-
mization in the original parameter space does not ﬁnd working
controllers (Extended Data Fig. 2).

We investigated how the behavior-performance map is up-
dated when the robot loses a leg (Fig. 3A:C4). Initially the map

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 2

Figure 2| (A & B). Creating the behavior-performance map: A user reduces a high-dimensional search space to a low-dimensional behavior space by
deﬁning dimensions along which behaviors vary. In simulation, the high-dimensional space is then automatically searched to ﬁnd a high-performing
behavior at each point in the low-dimensional behavior space, creating a “behavior-performance” map of the performance potential of each location
in the low-dimensional space. In our hexapod robot experiments, the behavior space is six-dimensional: the portion of time that each leg is in contact
with the ground. The conﬁdence regarding the accuracy of the predicted performance for each behavior in the behavior-performance map is initially
low because no tests on the physical robot have been conducted. (C & D) Adaptation Step: After damage, the robot selects a promising behavior, tests
it, updates the predicted performance of that behavior in the behavior-performance map, and sets a high conﬁdence on this performance prediction.
The predicted performances of nearby behaviors–and conﬁdence in those predictions–are likely to be similar to the tested behavior and are thus
updated accordingly. This select/test/update loop is repeated until a tested behavior on the physical robot performs better than 90% of the best
predicted performance in the behavior-performance map, a value that can decrease with each test (Extended Data Fig. 1). The algorithm that selects
which behavior to test next balances between choosing the behavior with the highest predicted performance and behaviors that are different from
those tested so far. Overall, the Intelligent Trial and Error approach presented here rapidly locates which types of behaviors are least affected by the
damage to ﬁnd an effective, compensatory behavior.

predicts large areas of high performance. During adaptation,
these areas disappear because the behaviors do not work well on
the damaged robot. Intelligent Trial and Error quickly identiﬁes
one of the few, remaining, high-performance behaviors (Fig. 4
and Extended Data Fig. 5 and 6).

The same damage recovery approach can be applied to any
robot, such as a robotic arm. We tested 14 different damage con-
ditions with a planar, 8-joint robotic arm (Fig. 3D-F and Extended
Data Fig. 7). The behavior-performance map’s behavioral dimen-
sions are the x, y position of the end-effector and the performance
measure is minimizing the variance of the 8 speciﬁed motor an-
gles (Supplementary Methods). During adaptation, performance
is measured as distance to the target. Like with the hexapod
robot, our approach discovers a compensatory behavior in less
than 2 minutes, usually in less than 30 seconds, and with fewer
than 10 trials (Fig. 3F and Extended Data Fig. 7).

While natural animals do not use the speciﬁc algorithm we
present, there are parallels between Intelligent Trial and Error
and animal learning. Like animals, our robot does not have a
predeﬁned strategy for how to cope with every possible dam-
age condition: in the face of a new injury, it exploits its intuitions
about how its body works to experiment with different behaviors
to ﬁnd what works best. Also like animals24, Intelligent Trial and
Error allows the quick identiﬁcation of working behaviors with a
few, diverse tests instead of trying behaviors at random or trying
small modiﬁcations to the best behavior found so far. Addition-
ally, the Bayesian optimization procedure followed by our robot
appears similar to the technique employed by humans when they
optimize an unknown function23, and there is strong evidence
that animal brains learn probability distributions, combine them
with prior knowledge, and act as Bayesian optimizers25,26.

An additional parallel is that Intelligent Trial and Error primes
the robot for creativity during a motionless period, after which

the generated ideas are tested. This process is reminiscent of
the ﬁnding that some animals start the day with new ideas that
they may quickly disregard after experimenting with them27,
and more generally, that sleep improves creativity on cognitive
tasks28. A ﬁnal parallel is that the simulator and Gaussian process
components of Intelligent Trial and Error are two forms of predic-
tive models, which are known to exist in animals29,12. All told, we
have shown that combining pieces of nature’s algorithm, even if
differently assembled, moves robots more towards animals by
endowing them with the ability to rapidly adapt to unforeseen
circumstances.

Supplementary Information and methods are appended at
the end of this document.

Acknowledgments. Thanks to Luigi Tedesco, Stéphane Don-
cieux, Nicolas Bredeche, Shimon Whiteson, Roberto Calandra,
Jacques Droulez, Pierre Bessière, Florian Lesaint, Charles Thu-
rat, Serena Ivaldi, Jingyu Li, Joost Huizinga, Roby Velez, Henok
Mengistu, Tim Clune, and Anh Nguyen for helpful feedback and
discussions. Thanks to Michael Brashier for the photo of the
three-legged dog.

This work has been funded by the ANR Creadapt project (ANR-
12-JS03-0009), the European Research Council (ERC) under
the European Union’s Horizon 2020 research and innovation
programme (grant agreement number 637972), and a Direction
Géneérale de l’Armement (DGA) scholarship to A.C.

Author Contributions A.C. and J.-B. M designed the study.
A.C. and D.T. performed the experiments. A.C., J.-B. M, D.T. and
J.C. discussed additional experiments, analyzed the results, and
wrote the paper.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 3

Figure 3| (A) Conditions tested on
the physical hexapod robot. C1: The
undamaged robot. C2: One leg is
shortened by half. C3: One leg is
unpowered. C4: One leg is miss-
ing. C5: Two legs are missing. C6:
A temporary, makeshift repair to the
(B) Performance af-
tip of one leg.
ter adaptation. Box plots represent
Intelligent Trial and Error. The cen-
tral mark is the median, the edges
of the box are the 25th and 75th per-
centiles, the whiskers extend to the
most extreme data points not consid-
ered outliers, and outliers are plotted
individually. Yellow stars represent
the performance of the handmade
reference tripod gait (Supplementary
Methods).
Conditions C1-C6 are
tested 5 times each for 8 indepen-
dently created behavior-performance
maps with the “duty factor” behav-
ior description (i.e. 40 experiments
per damage condition, Supplemen-
tary Methods). Damage conditions
C1 and C3 are also tested 5 times
each for 8 independently created
behavior-performance maps with the
“body orientation” behavior descrip-
(C)
tion (Supplementary Methods).
Time and number of trials required
to adapt. Box plots represent Intel-
(D) Robotic
ligent Trial and Error.
arm experiment. The 8-joint, planar
robot has to drop a ball into a bin.
(E) Example conditions tested on the
physical robotic arm. C1: One joint
is stuck at 45 degrees. C2: One joint
has a permanent 45-degree offset. C3:
One broken and one offset joint. A to-
tal of 14 conditions were tested (Ex-
(F) Time and
tended Data Fig. 7).
number of trials required to reach
within 5 cm of the bin center. Each
condition is tested with 15 indepen-
dently created behavior-performance
maps.

Figure 4| An example behavior-performance map. This map stores high-performing behaviors at each point in a six-dimensional behavior space.
Each dimension is the portion of time that each leg is in contact with the ground. The behavioral space is discretized at ﬁve values for each dimension
(0; 0.25; 0.5; 0.75; 1). Each colored pixel represents the highest-performing behavior discovered during map creation at that point in the behavior space.
The matrices visualize the six-dimensional behavioral space in two dimensions according to the legend in the top-left. The behavior-performance
map is created with a simulated robot (bottom left) in the Open Dynamics Engine physics simulator (http://www.ode.org). The left matrix is a
pre-adaptation map produced by the map creation algorithm. During adaptation, the map is updated as tests are conducted (in this case, in the
damage condition where the robot is missing one leg: Fig. 3A:C4). The right matrix shows the state of the map after a compensatory behavior
is discovered. The arrows and white circles represent the order in which behaviors were tested on the physical robot. The red circle is the ﬁnal,
discovered, compensatory behavior. Amongst other areas, high-performing behaviors can be found for the damaged robot in the ﬁrst two columns
of the third dimension. These columns represent behaviors that least use the central-left leg, which is the leg that is missing.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 4

Author information Correspondence and requests for ma-
terials should be addressed to J.-B. M.
jean-
baptiste.mouret@inria.fr).

(email:

1.

J. G. Bellingham and K. Rajan. “Robotics in remote and hostile environ-
ments.” In: Science 318.5853 (Nov. 2007), pp. 1098–102. ISSN: 1095-9203.
DOI: 10.1126/science.1146230.

2. D. R. Yoerger. “Underwater robotics”. In: Springer handbook of robotics.

Springer, 2008, pp. 987–1008.

3. E. Broadbent, R. Stafford, and B. MacDonald. “Acceptance of healthcare
robots for the older population: review and future directions”. In: International
Journal of Social Robotics 1.4 (2009), pp. 319–330.

4. K. Sanderson. “Mars rover Spirit (2003-10)”. In: Nature 463.7281 (2010),

5.

p. 600.
J. Carlson and R. R. Murphy. “How UGVs physically fail in the ﬁeld”. In: IEEE
Transactions on Robotics 21.3 (2005), pp. 423–437.

6. M. Blanke and J. Schröder. Diagnosis and fault-tolerant control. Springer,

2006.

7. B. Siciliano and O. Khatib. Springer handbook of robotics. Springer, 2008.
8. R. R. Murphy. “Trial by ﬁre [rescue robots]”. In: Robotics & Automation Mag-

22.

azine, IEEE 11.3 (2004), pp. 50–61.

9. K. Nagatani, S. Kiribayashi, Y. Okada, K. Otake, K. Yoshida, S. Tadokoro,
T. Nishimura, T. Yoshida, E. Koyanagi, M. Fukushima, and S. Kawatsuma.
“Emergency response to the nuclear accident at the Fukushima Daiichi Nu-
clear Power Plants using mobile rescue robots”. In: Journal of Field Robotics
30.1 (2013), pp. 44–63.

10. S. Thrun, M. Montemerlo, H. Dahlkamp, D. Stavens, A. Aron, J. Diebel, P.
Fong, J. Gale, M. Halpenny, G. Hoffmann, et al. “Stanley: The robot that
won the DARPA Grand Challenge”. In: Journal of ﬁeld Robotics 23.9 (2006),
pp. 661–692.

11. V. Verma, G. Gordon, R. Simmons, and S. Thrun. “Real-time fault diagnosis”.

12.

In: Robotics & Automation Magazine 11.2 (2004), pp. 56–66.
J. Bongard, V. Zykov, and H. Lipson. “Resilient machines through continuous
self-modeling”. In: Science 314.5802 (2006), pp. 1118–1121.

13. W. G. Fenton, T. M. McGinnity, and L. P. Maguire. “Fault diagnosis of elec-
tronic systems using intelligent techniques: a review”. In: IEEE Transactions
on Systems, Man, and Cybernetics, Part C: Applications and Reviews 31.3
(2001), pp. 269–281.
J. Kluger and J. Lovell. Apollo 13. Mariner Books, 2006.
0618619580.

ISBN: 978-

14.

15. S. L. Jarvis, D. R. Worley, S. M. Hogy, A. E Hill, K. K. Haussler, and R. F.
Reiser II. “Kinematic and kinetic analysis of dogs during trotting after ampu-
tation of a thoracic limb”. In: American journal of veterinary research 74.9
(2013), pp. 1155–1163.

16. A Fuchs, B Goldner, I Nolte, and N Schilling. “Ground reaction force adap-
tations to tripedal locomotion in dogs.” In: Veterinary journal 201.3 (Sept.
2014), pp. 307–15. ISSN: 1532-2971. DOI: 10.1016/j.tvjl.2014.05.012.
J. Kober, J. A. Bagnell, and J. Peters. “Reinforcement learning in robotics:
a survey”. In: The International Journal of Robotics Research 32.11 (2013),
pp. 1238–1274. DOI: 10.1177/0278364913495721.

17.

18. B. D. Argall, S. Chernova, M. Veloso, and B. Browning. “A survey of robot
learning from demonstration”. In: Robotics and autonomous systems 57.5
(2009), pp. 469–483.

19. E. Thelen. “Motor development: a new synthesis”. In: American psychologist

(1995), pp. 79–95.

20. M. Santello. “Postural hand synergies for tool use”. In: The Journal of Neuro-

science 18.23 (1998), pp. 10105–10115.

21. C. E. Rasmussen and C. K. I. Williams. Gaussian processes for machine

learning. MIT Press, 2006. ISBN: 0-262-18253-X.
J. Mockus. Bayesian approach to global optimization: theory and applica-
tions. Kluwer Academic, 2013.

23. A. Borji and L. Itti. “Bayesian optimization explains human active search”.
In: Advances in Neural Information Processing Systems 26 (NIPS). 2013,
pp. 55–63.

24. S. Benson-Amram and K. E. Holekamp. “Innovative problem solving by wild
spotted hyenas”. In: Proceedings of the Royal Society B: Biological Sciences
279.1744 (2012), pp. 4087–4095.

25. A. Pouget, J. M. Beck, W. J. Ma, and P. E. Latham. “Probabilistic brains:
knowns and unknowns”. In: Nature neuroscience 16.9 (2013), pp. 1170–
1178.

26. K. P. Körding and D. M. Wolpert. “Bayesian integration in sensorimotor learn-

ing”. In: Nature 427.6971 (2004), pp. 244–247.

27. S. Derégnaucourt, P. P. Mitra, O. Fehér, C. Pytte, and O. Tchernichovski.
learning of bird song”. In: Nature

“How sleep affects the developmental
433.7027 (2005), pp. 710–716.

28. U. Wagner, S. Gais, H. Haider, R. Verleger, and J. Born. “Sleep inspires

insight”. In: Nature 427.6972 (2004), pp. 352–355.

29. M. Ito. “Control of mental activities by internal models in the cerebellum”. In:

Nature Reviews Neuroscience 9.4 (2008), pp. 304–313.

5

1 Methods

Notations

• c: Parameters of a controller (vector)
• x: A location in a discrete behavioral space (i.e. a type of

behavior) (vector)

• χ: A location in a discrete behavioral space that has been

tested on the physical robot (vector)

• P: Behavior-performance map (stores performance) (asso-

• C: Behavior-performance map (stores controllers) (associa-

ciative table)

tive table)

• P(x): Max performance yet encountered at x (scalar)
• C(x): Controller currently stored in x (vector)
• χ1:t: All previously tested behavioral descriptors at time t

(vector of vectors)

• P1:t: Performance in reality of all the candidate solutions

tested on the robot up to time t (vector)

• P(χ1:t): Performance in the behavior-performance map for
all the candidate solutions tested on the robot up to time t
(vector)

• f (): Performance function (unknown by the algorithm)

(function)

• σ2

(scalar)

(function)

noise: Observation noise (a user-speciﬁed parameter)

• k(x, x): Kernel function (see section “kernel function”)

• K: Kernel matrix (matrix)
• k: Kernel vector [k(x, χ1), k(x, χ2), ..., k(x, χt)] (vector)
• µt(x): Predicted performance for x (i.e.

the mean of the

Gaussian process) (function)

• σ2

t (x): Standard deviation for x in the Gaussian process

(function)

1.1 Intelligent Trial and Error algorithm (IT&E)

The Intelligent Trial and Error Algorithm consists of two major
steps (Extended Data Fig. 1):
the behavior-performance map
creation step and the adaptation step (while here we focus on
damage recovery, Intelligent Trial and Error can search for any
type of required adaptation, such as learning an initial gait for
an undamaged robot, adapting to new environments, etc.). The
behavior-performance map creation step is accomplished via a
new algorithm introduced in this paper called multi-dimensional
archive of phenotypic elites (MAP-Elites), which is explained
in the next section. The adaptation step is accomplished via a
second new algorithm introduced in this paper called the map-
based Bayesian optimization algorithm (M-BOA), which is ex-
plained in the “Adaptation Step” section below.

1.2 Behavior-performance map creation (via the

MAP-Elites algorithm)

The behavior-performance map is created by a new algorithm we
introduce in this paper called the multi-dimensional archive of
phenotypic elites (MAP-Elites) algorithm. MAP-Elites searches
for the highest-performing solution for each point in a user-
deﬁned space: the user chooses the dimensions of the space that
they are interested in seeing variation in. For example, when de-
signing robots, the user may be interested in seeing the highest-
performing solution at each point in a two-dimensional space
where one axis is the weight of the robot and the other axis is the
height of the robot. Alternatively, a user may wish to see weight
vs. cost, or see solutions throughout a 3D space of weight vs. cost
vs. height. Any dimension that can vary could be chosen by the
user. There is no limit on the number of dimensions that can be
chosen, although it becomes computationally more expensive to

ﬁll the behavior-performance map and store it as the number of
dimensions increases. It also becomes more difﬁcult to visualize
the results. We refer to this user-deﬁned space as the “behavior
space”, because usually the dimensions of variation measure be-
havioral characteristics. Note that the behavioral space can refer
to other aspects of the solution (as in this example, where the di-
mensions of variation are physical properties of a robot such as
its height and weight).

If the behavior descriptors and the parameters of the con-
troller are the same (i.e.
if there is only one possible so-
lution/genome/parameter set/policy/description for each lo-
cation in the behavioral space),
then creating the behavior-
performance map is straightforward: one simply needs to simu-
late the solution at each location in the behavior space and record
the performance. However, if it is not known a priori how to
produce a controller/parameter set/description that will end up
in a speciﬁc location in the behavior space (i.e. if the parameter
space is of higher dimension than the behavioral space: e.g., in
our example, if there are many different robot designs of a spe-
ciﬁc weight, height, and cost, or if it is unknown how to make
a description that will produce a robot with a speciﬁc weight,
height, and cost), then MAP-Elites is beneﬁcial. It will efﬁciently
search for the highest-performing solution at each point of the
low-dimensional behavioral space. It is more efﬁcient than a ran-
dom sampling of the search space because high-performing so-
lutions are often similar in many ways, such that randomly alter-
ing a high-performing solution of one type can produce a high-
performing solution of a different type (see Extended Data Fig.
10 and Supplementary Experiment S4). For this reason, search-
ing for high-performing solutions of all types simultaneously is
much quicker than separately searching for each type. For exam-
ple, to generate a lightweight, high-performing robot design, it
tends to be more effective and efﬁcient to modify an existing de-
sign of a light robot rather than randomly generate new designs
from scratch or launch a separate search process for each new
type of design.

MAP-Elites begins by generating a set of random candidate
solutions. It then evaluates the performance of each solution and
records where that solution is located in the behavior space (e.g.
if the dimensions of the behavior space are the height and weight,
it records the height and weight of each robot in addition to its
performance). For each solution, if its performance is better than
the current solution at that location in the behavior-performance
map, then it is added to the behavior-performance map, replac-
ing the solution in that location. In other words, it is only kept if
it is the best of that type of solution, where “type” is deﬁned as
a location in the behavior space. There is thus only one solution
kept at each location in the behavior space (keeping more could
be beneﬁcial, but for computational reasons we only keep one).
If no solution is present in the behavior-performance map at that
location, then the newly generated candidate solution is added
at that location.

Once this initialization step is ﬁnished, Map-Elites enters a
loop that is similar to stochastic, population-based, optimization
algorithms, such as evolutionary algorithms30: the solutions that
are in the behavior-performance map form a population that is
improved by random variation and selection. In each generation,
the algorithm picks a solution at random via a uniform distri-
bution, meaning that each solution has an equal chance of being
chosen. A copy of the selected solution is then randomly mutated
to change it in some way, its performance is evaluated, its loca-
tion in the behavioral space is determined, and it is kept if it out-
performs the current occupant at that point in the behavior space
(note that mutated solutions may end up in different behavior
space locations than their “parents”). This process is repeated
until a stopping criterion is met (e.g. after a ﬁxed amount of time
has expired). In our experiments, we stopped each MAP-Elites
run after 40 million iterations. Because MAP-Elites is a stochastic

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 6

(A) Behavior-performance map creation. After being
Extended Data Figure 1 | An overview of the Intelligent Trial and Error Algorithm.
initialized with random controllers, the behavioral map (A2), which stores the highest-performing controller found so far of each behavior type,
is improved by repeating the process depicted in (A1) until newly generated controllers are rarely good enough to be added to the map (here,
after 40 million evaluations). This step, which occurs in simulation, is computationally expensive, but only needs to be performed once per robot
(or robot design) prior to deployment.
In our experiments, creating one map involved 40 million iterations of (A1), which lasted roughly two
weeks on one multi-core computer (Supplementary Methods, section “Running time”). (B) Adaptation. (B1) Each behavior from the behavior-
performance map has an expected performance based on its performance in simulation (dark green line) and an estimate of uncertainty regarding
this predicted performance (light green band). The actual performance on the now-damaged robot (black dashed line) is unknown to the algorithm.
A behavior is selected to try on the damaged robot. This selection is made by balancing exploitation—trying behaviors expected to perform well—
and exploration—trying behaviors whose performance is uncertain (Methods, section “acquisition function”). Because all points initially have equal,
maximal uncertainty, the ﬁrst point chosen is that with the highest expected performance. Once this behavior is tested on the physical robot (B4),
the performance predicted for that behavior is set to its actual performance, the uncertainty regarding that prediction is lowered, and the predictions
for, and uncertainties about, nearby controllers are also updated (according to a Gaussian process model, see Methods, section “kernel function”),
the results of which can be seen in (B2). The process is then repeated until performance on the damaged robot is 90% or greater of the maximum
expected performance for any behavior (B3). This performance threshold (orange dashed line) lowers as the maximum expected performance (the
highest point on the dark green line) is lowered, which occurs when physical tests on the robot underperform expectations, as occurred in (B2).

search process, each resultant behavior-performance map can be
different, both in terms of the number of locations in the behav-
ioral space for which a candidate is found, and in terms of the
performance of the candidate in each location.

The pseudo-code of the algorithm is available in Supplemen-
tary Figure 8. More details and experiments about MAP-Elites
are available in (Mouret and Clune, 2015)31.

tainty associated with each prediction. For a cost function f , usu-
ally unknown, a Gaussian process deﬁnes the probability distri-
bution of the possible values f (x) for each point x. These prob-
ability distributions are Gaussian, and are therefore deﬁned by a
mean (µ) and a standard deviation (σ). However, µ and σ can be
different for each x; we therefore deﬁne a probability distribution
over functions:

1.3 Adaptation step (via M-BOA: the map-based

Bayesian optimization algorithm)

The adaptation step is accomplished via a Bayesian optimization
algorithm seeded with a behavior-performance map. We call this
approach a map-based Bayesian optimization algorithm, or M-
BOA.

Bayesian optimization is a model-based, black-box optimiza-
tion algorithm that is tailored for very expensive objective func-
tions (a.k.a. cost functions)32,33,22,34,35,23. As a black-box optimiza-
tion algorithm, Bayesian optimization searches for the maximum
of an unknown objective function from which samples can be ob-
tained (e.g., by measuring the performance of a robot). Like all
model-based optimization algorithms (e.g. surrogate-based algo-
rithms36,37,38, kriging39, or DACE40,41), Bayesian optimization cre-
ates a model of the objective function with a regression method,
uses this model to select the next point to acquire, then updates
the model, etc. It is called Bayesian because, in its general for-
mulation22, this algorithm chooses the next point by computing
a posterior distribution of the objective function using the like-
lihood of the data already acquired and a prior on the type of
function.

Here we use Gaussian process regression to ﬁnd a model21,
which is a common choice for Bayesian optimization42,35,33,32.
Gaussian processes are particularly interesting for regression be-
cause they not only model the cost function, but also the uncer-

P (f (x)|x) = N (µ(x), σ2(x))

(1)

where N denotes the standard normal distribution.

To estimate µ(x) and σ(x), we need to ﬁt the Gaussian process
to the data. To do so, we assume that each observation f (χ) is a
sample from a normal distribution. If we have a data set made
of several observations, that is, f (χ1), f (χ2), ..., f (χt), then the
vector [f (χ1), f (χ2), ..., f (χt)] is a sample from a multivariate nor-
mal distribution, which is deﬁned by a mean vector and a covari-
ance matrix. A Gaussian process is therefore a generalization of
a n-variate normal distribution, where n is the number of obser-
vations. The covariance matrix is what relates one observation
to another: two observations that correspond to nearby values
of χ1 and χ2 are likely to be correlated (this is a prior assump-
tion based on the fact that functions tend to be smooth, and is
injected into the algorithm via a prior on the likelihood of func-
tions), two observations that correspond to distant values of χ1
and χ2 should not inﬂuence each other (i.e. their distributions are
not correlated). Put differently, the covariance matrix represents
that distant samples are almost uncorrelated and nearby samples
are strongly correlated. This covariance matrix is deﬁned via a
kernel function, called k(χ1, χ2), which is usually based on the
Euclidean distance between χ1 and χ2 (see the “kernel function”
sub-section below).

Given a set of observations P1:t = f (χ1:t) and a sampling
noise(which is a user-speciﬁed parameter), the Gaussian

noise σ2

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 7

Variant

Intelligent Trial and Error
Variant 1
Variant 2
Variant 3
Variant 4
Variant 5

Behavior-performance map
creation
MAP-Elites
MAP-Elites
MAP-Elites
MAP-Elites
none
none

Priors on
performance
yes
none
none
none
none
none

Search
algorithm
Bayesian Optimization
random search
Bayesian optimization
policy gradient
Bayesian optimization
policy gradient

equivalent
approach
-
-
-
-
Lizotte et al. (2007)
Kohl et al. (2004)

Extended Data Figure 2 | The contribution of each subcomponent of the Intelligent Trial and Error Algorithm. (A) Adaptation progress versus
the number of robot trials. The walking speed achieved with Intelligent Trial and Error and several “knockout” variants that are missing one of the
algorithm’s key components. Some variants (4 and 5) correspond to state-of-the-art learning algorithms (policy gradient: Kohl et al. 2004; Bayesian
optimization: Lizotte et al. 2007, Tesch et al., 2011, Calandra et al. 2014,). The bold lines represent the medians and the colored areas extend to the
25th and 75th percentiles. (B, C) Adaptation performance after 17 and 150 trials. Shown is the the speed of the compensatory behavior discovered
by each algorithm after 17 and 150 evaluations on the robot, respectively. For all panels, data are pooled across six damage conditions (the removal
of each of the 6 legs in turn). See Supplementary Experiment S2 for methods and analysis.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 8

Extended Data Figure 3 | The Intelligent Trial and Error Algorithm is robust to environmental changes. Each plot shows both the performance and
required adaptation time for Intelligent Trial and Error when the robot must adapt to walk on terrains of different slopes. (A) Adaptation performance
on an undamaged robot. On all slope angles, with very few physical trials, the Intelligent Trial and Error Algorithm (pink shaded region) ﬁnds fast
gaits that outperform the reference gait (black dotted line). (B) Adaptation performance on a damaged robot. The robot is damaged by having
each of the six legs removed in six different damage scenarios. Data are pooled from all six of these damage conditions. The median compensatory
behavior found via Intelligent Trial and Error outperforms the median reference controller on all slope angles. The middle, black lines represent
medians, while the colored areas extend to the 25th and 75th percentiles. In (A), the black dashed line is the performance of a classic tripod gait for
reference. In (B), the reference gait is tried in all six damage conditions and its median (black line) and 25th and 75th percentiles (black colored area)
are shown. See Supplementary Experiment S3 for methods and analysis.

process is computed as follows33,21:

the update equation for the mean function (µt(x), equation 2):

P (f (x)|P1:t, x) = N (µt(x), σ2

t (x))

where :
µt(x) = k(cid:124)K−1P1:t
t (x) = k(x, x) − k(cid:124)K−1k
σ2

K =






k(χ1, χ1)
...
k(χt, χ1)

k = (cid:2) k(x, χ1)

· · ·
. . .
· · ·
k(x, χ2)

k(χ1, χt)
...
k(χt, χt)
· · ·


 + σ2


noiseI

k(x, χt) (cid:3)

Our implementation of Bayesian optimization uses this Gaus-
sian process model to search for the maximum of the objective
function f (x), f (x) being unknown. It selects the next χ to test
by selecting the maximum of the acquisition function, which bal-
ances exploration – improving the model in the less explored
parts of the search space – and exploitation – favoring parts that
the models predicts as promising. Here, we use the “Upper Con-
ﬁdence Bound” acquisition function (see the “information acqui-
sition function” section below). Once the observation is made,
the algorithm updates the Gaussian process to take the new data
into account. In classic Bayesian optimization, the Gaussian pro-
cess is initialized with a constant mean because it is assumed that
all the points of the search space are equally likely to be good.
The model is then progressively reﬁned after each observation.

The key concept of the map-based Bayesian optimization al-
gorithm (M-BOA) is to use the output of MAP-Elites as a prior
for the Bayesian optimization algorithm: thanks to the simula-
tions, we expect some behaviors to perform better than others
on the robot. To incorporate this idea into the Bayesian opti-
mization, M-BOA models the difference between the prediction
of the behavior-performance map and the actual performance on
the real robot, instead of directly modeling the objective function.
This idea is incorporated into the Gaussian process by modifying

(cid:124)
µt(x) = P(x) + k

K−1(P1:t − P(χ1:t))

(3)

(2)

where P(x) is the performance of x according to the simula-
tion and P(χ1:t) is the performance of all the previous observa-
tions, also according to the simulation. Replacing P1:t (eq. 2)
by P1:t − P(χ1:t) (eq. 3) means that the Gaussian process mod-
els the difference between the actual performance P1:t and the
performance from the behavior-performance map P(χ1:t). The
term P(x) is the prediction of the behavior-performance map.
M-BOA therefore starts with the prediction from the behavior-
performance map and corrects it with the Gaussian process.

The pseudo-code of the algorithm is available in Supplemen-

tary Figure 8.

Kernel function The kernel function is the covariance function
of the Gaussian process. It deﬁnes the inﬂuence of a controller’s
performance (on the physical robot) on the performance and con-
ﬁdence estimations of not-yet-tested controllers in the behavior-
performance map that are nearby in behavior space to the tested
controller (Extended Data Fig. 9a).

The Squared Exponential covariance function and the Matérn
kernel are the most common kernels for Gaussian pro-
cesses33,34,21. Both kernels are variants of the “bell curve”. Here
we chose the Matérn kernel because it is more general (it includes
the Squared Exponential function as a special case) and because
it allows us to control not only the distance at which effects be-
come nearly zero (as a function of parameter ρ, Extended Data
Fig. 9a), but also the rate at which distance effects decrease (as a
function of parameter ν).

The Matérn kernel function is computed as follows43,44 (with

ν = 5/2):

(cid:16)

√

k(x1, x2) =
where d(x1, x2) is the Euclidean distance in behavior space.

exp

1 +

−

5d(x1,x2)
ρ

5d(x1,x2)
ρ

+ 5d(x1,x2)2
3ρ2

(cid:17)

(cid:16)

√

(cid:17)

Cully, Clune, Tarapore, and Mouret. 2015

(4)

arXiv preprint | 9

Extended Data Figure 4 | The Intelligent Trial and Error Algorithm is largely robust to alternate choices of behavior descriptors. (A, B) The speed
of the compensatory behavior discovered by Intelligent Trial and Error for various choices of behavior descriptors. Performance is plotted after 17
and 150 evaluations in panels A and B, respectively. Experiments were performed on a simulated, damaged hexapod. The damaged robot has each of
its six legs removed in six different damage scenarios. Data are pooled across all six damage conditions. As described in Supplementary Experiment
S5, the evaluated behavior descriptors characterize the following: (i) Time each leg is in contact with the ground (Duty factor); (ii) Orientation of the
robot frame (Orientation); (iii) Instantaneous velocity of the robot (Displacement); (iv) Energy expended by the robot in walking (Energy (Total),
Energy (Relative)); (v) Deviation from a straight line (Deviation); (vi) Ground reaction force on each leg (GRF (Total), GRF (Relative)); (vii) The
angle of each leg when it touches the ground (Lower-leg angle (Pitch), Lower-leg angle (Roll), Lower-leg angle (Yaw)); and (viii) A random selection
without replacement from subcomponents of all the available behavior descriptors (i-vii) (Random). For the hand-designed reference gait (yellow)
and the compensatory gaits found by the default duty factor behavior descriptor (green), the bold lines represent the medians and the colored areas
extend to the 25th and 75th percentiles of the data. For the other treatments, including the duty factor treatment, black circles represent the median, the
colored area extends to the 25th and 75th percentiles of the data, and the colored circles are outliers. See Supplementary Experiment S5 for methods
and analysis.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 10

Extended Data Figure 5 | How the behavior performance map is explored to discover a compensatory behavior (normalized each iteration to
highlight the range of remaining performance predictions). Colors represent the performance prediction for each point in the map relative to the
highest performing prediction in the map at that step of the process. A black circle indicates the next behavior to be tested on the physical robot. A
red circle indicates the behavior that was just tested (note that the performance predictions surrounding it have changed versus the previous panel).
Arrows reveal the order that points have been explored. The red circle in the last map is the ﬁnal, selected, compensatory behavior. In this scenario,
the robot loses leg number 3. The six dimensional space is visualized according to the inset legend.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 11

Extended Data Figure 6 | How the behavior performance map is explored to discover a compensatory behavior (non-normalized to highlight
that performance predictions decrease as it is discovered that predictions from the simulated, undamaged robot do not work well on the damaged
robot). Colors represent the performance prediction for each point in the map relative to the highest performing prediction in the ﬁrst map. A black
circle indicates the next behavior to be tested on the physical robot. A red circle indicates the behavior that was just tested (note that the performance
predictions surrounding it have changed versus the previous panel). Arrows reveal the order that points have been explored. The red circle in the
last map in the sequence is the ﬁnal, selected, compensatory behavior. In this scenario, the robot loses leg number 3. The six dimensional space
is visualized according to the inset legend. The data visualized in this ﬁgure are identical to those in the previous ﬁgure: the difference is simply
whether the data are renormalized for each new map in the sequence.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 12

Extended Data Figure 7 | Intelligent Trial and Error works on a completely different type of robot: supplementary data from the robotic arm
experiment. (A) The robotic arm experimental setup. (B) Tested damage conditions. (C) Example of behavior performance maps (colormaps)
and behaviors (overlaid arm conﬁgurations) obtained with MAP-Elites. Left: A typical behavior-performance map produced by MAP-Elites with
5 example behaviors, where a behavior is described by the angle of each of the 8 joints. The color of each point is a function of its performance,
which is deﬁned as having low variance in the joint angles (i.e. a zigzag arm is lower performing than a straighter arm that reaches the same point).
Right: Neighboring points in the map tend to have similar behaviors, thanks to the performance function, which would penalize more jagged ways of
reaching those points. That neighbors have similar behaviors justiﬁes updating predictions about the performance of nearby behaviors after a testing a
single behavior on the real (damaged) robot. (D) Performance vs. trial number for Intelligent Trial and Error and traditional Bayesian optimization.
The experiment was conducted on the physical robot, with 15 independent replications for each of the 14 damage conditions. Performance is pooled
from all of these 14×15 = 210 experiments. (E) Success for each damage condition. Shown is the success rate for the 15 replications for each damage
condition, deﬁned as the percentage of replicates in which the robot reaches within 5 cm of the bin center. (F) Trials required to adapt. Shown is the
number of iterations required to reach within 5 cm of the basket center. (G) Accuracy after 30 physical trials. Performance after 30 physical trials for
each damage condition (with the stopping criterion disabled). See Supplementary Experiment S1 for methods and analysis.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 13

CREATE BEHAVIOR-PERFORMANCE MAP (VIA THE MAP-ELITES ALGORITHM IN SIMULATION)

procedure INTELLIGENT TRIAL AND ERROR ALGORITHM (IT&E)

Before the mission:

while In mission do

if Signiﬁcant performance fall then

ADAPTATION STEP (VIA M-BOA ALGORITHM)

procedure MAP-ELITES ALGORITHM

(P ← ∅, C ← ∅)
for iter = 1 → I do

if iter < 400 then

c(cid:48) ← random_controller()

else

c ← random_selection(C)
c(cid:48) ← random_variation(c)

x(cid:48) ←behavioral_descriptor(simu(c(cid:48)))
p(cid:48) ←performance(simu(c(cid:48)))
if P(x(cid:48)) = ∅ or P(x(cid:48)) < p(cid:48) then

P(x(cid:48)) ← p(cid:48)

C(x(cid:48)) ← c(cid:48)

(cid:46) Creation of an empty behavior-performance map (empty N-dimensional grid).
(cid:46) Repeat during I iterations (here we choose I = 40 million iterations).

(cid:46) The ﬁrst 400 controllers are generated randomly.
(cid:46) The next controllers are generated using the map.
(cid:46) Randomly select a controller c in the map.
(cid:46) Create a randomly modiﬁed copy of c.
(cid:46) Simulate the controller and record its behavioral descriptor.
(cid:46) Record its performance.
(cid:46) If the cell is empty or if p(cid:48) is better than the current stored performance.
(cid:46) Store the performance of c(cid:48) in the behavior-performance map according
(cid:46) to its behavioral descriptor x(cid:48).
(cid:46) Associate the controller with its behavioral descriptor.

return behavior-performance map (P and C)

procedure M-BOA (MAP-BASED BAYESIAN OPTIMIZATION ALGORITHM)

∀x ∈ map:

P (f (x)|x) = N (µ0(x), σ2
where
µ0(x) = P(x)
σ2

0(x) = k(x, x)

0(x))

while max(P1:t) < α max(µt(x)) do
χt+1 ← arg maxx(µt(x) + κσt(x))
Pt+1 ← performance(physical_robot(C(χt+1))).
P (f (x)|P1:t+1, x) = N (µt+1(x), σ2
where
µt+1(x) = P(x) + k(cid:124)K−1(P1:t+1 − P(χ1:t+1))
t+1(x) = k(x, x) − k(cid:124)K−1k
σ2

t+1(x))






K =

k(χ1, χ1)
...
k(χt+1, χ1)

· · ·
. . .
· · ·
k(x, χ2)

k(χ1, χt+1)
...
k(χt+1, χt+1)
· · ·

k(x, χt+1) (cid:3)


 + σ2


noiseI

k = (cid:2) k(x, χ1)

(cid:46) Initialisation.
(cid:46) Deﬁnition of the Gaussian Process.

(cid:46) Initialize the mean prior from the map.
(cid:46) Initialize the variance prior (in the common case, k(x, x) = 1).
(cid:46) Iteration loop.
(cid:46) Select next test (argmax of acquisition function).
(cid:46) Evaluation of xt+1 on the physical robot.
(cid:46) Update the Gaussian Process.

(cid:46) Update the mean.
(cid:46) Update the variance.

(cid:46) Compute the observations’ correlation matrix.

(cid:46) Compute the x vs. observation correlation vector.

Extended Data Figure 8 | Pseudo-code for the Intelligent Trial and Error Algorithm, the MAP-Elites algorithm, and the Map-based Bayesian
Optimization Algorithm (M-BOA). Notations are described at the beginning of the methods section.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 14

Because the model update step directly depends on ρ, it is one
of the most critical parameters of the Intelligent Trial and Error
Algorithm. We selected its value after extensive experiments in
simulation (Extended Data Fig. 9 and section 1.6).

Information acquisition function The information acquisition
function selects the next solution that will be evaluated on the
physical robot. The selection is made by ﬁnding the solution
that maximizes the acquisition function. This step is another op-
timization problem, but does not require testing the controller
in simulation or reality. In general, for this optimization prob-
lem we can derive the exact equation and ﬁnd a solution with
gradient-based optimization45. For the speciﬁc behavior space in
the example problem in this paper, though, the discretized search
space of the behavior-performance map is small enough that we
can exhaustively compute the acquisition value of each solution
of the behavior-performance map and then choose the maximum
value.

Several different acquisition functions exist, such as the proba-
bility of improvement, the expected improvement, or the Upper
Conﬁdence Bound (UCB)33,42. We chose UCB because it provided
the best results in several previous studies33,42. The equation for
UCB is:

xt+1 = arg max

(µt(x) + κσt(x))

(5)

x

where κ is a user-deﬁned parameter that tunes the tradeoff be-
tween exploration and exploitation.

The acquisition function handles the exploitation/exploration
trade-off of the adaptation (M-BOA) step. In the UCB function
(Eq. 5), the emphasis on exploitation vs. exploration is explicit
and easy to adjust. The UCB function can be seen as the max-
imum value (argmax) across all solutions of the weighted sum
of the expected performance (mean of the Gaussian, µt(x)) and
of the uncertainty (standard deviation of the Gaussian, σt(x)) of
each solution. This sum is weighted by the κ factor. With a low κ,
the algorithm will choose solutions that are expected to be high-
performing. Conversely, with a high κ, the algorithm will fo-
cus its search on unexplored areas of the search space that may
have high-performing solutions. The κ factor enables ﬁne adjust-
ments to the exploitation/exploration trade-off of the M-BOA al-
gorithm (the adaptation step). We describe how we chose the κ
value in supplementary methods, section 1.6.

Code availability The source code (for GNU/Linux) for the ex-
periments of this paper is available at the following URL:
http://pages.isir.upmc.fr/~mouret/code/ite_source_code.tar.gz An implementa-
tion of the Bayesian optimization algorithm is freely available on:
http://github.com/jbmouret/limbo

1.4 Hexapod Experiment

Physical robot The robot is a 6-legged robot with 3 degrees
of freedom (DOFs) per leg. Each DOF is actuated by position-
controlled servos (MX-28 Dynamixel actuators manufactured by
Robotis). The ﬁrst servo controls the horizontal (front-back) ori-
entation of the leg and the two others control its elevation. An
RGB-D camera (Xtion, from ASUS) is ﬁxed on top of the robot. Its
data are used to estimate the forward displacement of the robot
via an RGB-D SLAM algorithm146 from the robot operating sys-
tem (ROS) framework247.

Simulator The simulator is a dynamic physics simulation of the
undamaged 6-legged robot on ﬂat ground (Fig. 4). We weighted
each segment of the leg and the body of the real robot, and we

1http://wiki.ros.org/ccny_openni_launch
2http://www.ros.org

used the same masses for the simulations. The simulator is based
on the Open Dynamics Engine (ODE, http://www.ode.org).

Parametrized controller The angular position of each DOF is
governed by a periodic function γ parametrized by its amplitude
α, its phase φ, and its duty cycle τ (the duty cycle is the propor-
tion of one period in which the joint is in its higher position). The
function is deﬁned with a square signal of frequency 1Hz, with
amplitude α, and duty cycle τ . This signal is then smoothed via
a Gaussian ﬁlter in order to remove sharp transitions, and is then
shifted according to the phase φ.

Angular positions are sent to the servos every 30 ms. In or-
der to keep the “tibia” of each leg vertical, the control signal of
the third servo is the opposite of the second one. Consequently,
angles sent to the ith leg are:

• γ(t, αi1 , φi1 , τi1 ) for DOF 1
• γ(t, αi2 , φi2 , τi2 ) for DOF 2
• −γ(t, αi2 , φi2 , τi2 ) for DOF 3

This controller makes the robot equivalent to a 12 DOF system,
even though 18 motors are controlled.

There are 6 parameters for each leg (αi1 , αi2 , φi1 , φi2 , τi1 ,
τi2 ), therefore each controller is fully described by 36 parame-
ters. Each parameter can have one of these possible values: 0,
0.05, 0.1, ... 0.95, 1. Different values for these 36 parameters can
produce numerous different gaits, from purely quadruped gaits
to classic tripod gaits.

This controller is designed to be simple enough to show the
performance of the algorithm in an intuitive setup. Neverthe-
less, the algorithm will work with any type of controller, includ-
ing bio-inspired central pattern generators48 and evolved neural
networks49,50,51,52.

Reference controller Our reference controller is a classic tri-
pod gait7,53,54,55,56,57. It involves two tripods: legs 1-4-5 and legs 2-
3-6 (Fig. 4). This controller is designed to always keep the robot
balanced on at least one of these tripods. The walking gait is
achieved by lifting one tripod, while the other tripod pushes the
robot forward (by shifting itself backward). The lifted tripod is
then placed forward in order to repeat the cycle with the other
tripod. This gait is static, fast, and similar to insect gaits53,58.

Table S1 shows the 36 parameters of the reference controller.
The amplitude orientation parameters (αi1 ) are set to 1 to pro-
duce the fastest possible gait, while the amplitude elevation pa-
rameters (αi2 ) are set to a small value (0.25) to keep the gait sta-
ble. The phase elevation parameters (φi2 ) deﬁne two tripods:
0.25 for legs 2-3-5; 0.75 for legs 1-4-5. To achieve a cyclic mo-
tion of the leg, the phase orientation values (φi1 ) are chosen by
subtracting 0.25 to the phase elevation values (φi2 ), plus a 0.5
shift for legs 1-3-5, which are on the left side of the robot. All the
duty cycle parameters (τi) are set to 0.5 so that the motors spend
the same proportion of time in their two limit angles. The actual
speed of the reference controller is not important for the compar-
isons made in this paper: it is simply intended as a reference and
to show that the performance of classic, hand-programmed gaits
tend to fail when damage occurs.

Random variation of controller’s parameters Each parame-
ter of the controller has a 5% chance of being changed to any
value in the set of possible values, with the new value chosen
randomly from a uniform distribution over the possible values.

Main Behavioral descriptor (duty factor) The default behav-
ioral descriptor is a 6-dimensional vector that corresponds to the
proportion of time that each leg is in contact with the ground
(also called duty factor). When a controller is simulated, the al-
gorithm records at each time step (every 30 ms) whether each leg

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 15

Leg number

First joint

Two last joints

1
1.00
0.00
0.5
0.25
0.75
0.5

2
1.00
0.00
0.5
0.25
0.25
0.5

3
1.00
0.50
0.5
0.25
0.25
0.5

4
1.00
0.50
0.5
0.25
0.75
0.5

5
1.00
0.00
0.5
0.25
0.75
0.5

6
1.00
0.00
0.5
0.25
0.25
0.5

αi1
φi1
τi1
αi2
φi2
τi2

Extended Data Table 1| Parameters of the reference controller.

is in contact with the ground (1: contact, 0: no contact). The re-
sult is 6 Boolean time series (Ci for the ith leg). The behavioral
descriptor is then computed with the average of each time series:







x =

(cid:80)

t C1(t)
numTimesteps(C1)

...

(cid:80)

t C6(t)
numTimesteps(C6)







During the generation of the behavior-performance map, the
behaviors are stored in the maps’s cells by discretizing each di-
mension of the behavioral descriptor space with these ﬁve val-
ues: {0, 0.25, 0.5, 0.75, 1}. During the adaptation phase, the behav-
ioral descriptors are used with their actual values and are thus
not discretized.

Alternative Behavioral descriptor (orientation) The alterna-
tive behavioral descriptor tested on the physical robot (we in-
vestigated many other descriptors in simulation: Supplementary
Experiment S5) characterizes changes in the angular position of
the robot during walking, measured as the proportion of 15ms
intervals that each of the pitch, roll and yaw angles of the robot
frame are positive (three dimensions) and negative (three addi-
tional dimensions):

x =











1
K
1
K
1
K
1
K
1
K
1
K

(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)

k U (ΘT (k) − 0.005π)
k U (−ΘT (k) − 0.005π)
k U (ΨT (k) − 0.005π)
k U (−ΨT (k) − 0.005π)
k U (ΦT (k) − 0.005π)
k U (−ΦT (k) − 0.005π)











(7)

where ΘT (k), ΨT (k) and ΦT (k) denote the pitch, roll and yaw
angles, respectively, of the robot torso (hence T ) at the end of
interval k, and K denotes the number of 15ms intervals during
the 5 seconds of simulated movement (here, K = 5s/0.015s ≈
334). The unit step function U (·) returns 1 if its argument exceeds
0, and returns 0 otherwise. To discount for insigniﬁcant motion
around 0 rad, orientation angles are only deﬁned as positive if
they exceed 0.5% of π rad. Similarly, orientation angles are only
deﬁned as negative if they are less than −0.5% of π rad.

Performance function In these experiments, the “mission”
of the robot is to go forward as fast as possible. The perfor-
mance of a controller, which is a set of parameters (section 1.4:
Parametrized controller), is deﬁned as how far the robot moves
in a pre-speciﬁed direction in 5 seconds.

During the behavior-performance map creation step, the per-
formance is obtained thanks to the simulation of the robot. All
odometry results reported on the physical robot, during the
adaptation step, are measured with the embedded simultaneous
location and mapping (SLAM) algorithm46. The accuracy of this
algorithm was evaluated by comparing its measurements to ones
made by hand on 40 different walking gaits. These experiments
revealed that the median measurement produced by the odome-
try algorithm is reasonably accurate, being just 2.2% lower than
the handmade measurement (Extended Data Fig. 9d).

Some damage to the robot may make it ﬂip over. In such cases,
the visual odometry algorithm returns pathological distance-

traveled measurements either several meters backward or for-
ward. To remove these errors, we set all distance-traveled mea-
surements less than zero or greater than two meters to zero. The
result of this adjustment is that the algorithm appropriately con-
siders such behaviors low-performing. Additionally, the SLAM
algorithm sometimes reports substantially inaccurate low val-
ues (outliers on Supplementary Fig. 9d).
In these cases the
adaptation step algorithm will assume that the behavior is low-
performing and will select another working behavior. Thus, the
overall algorithm is not substantially impacted by such infre-
quent under-measurements of performance.

(6)

Stopping criterion In addition to guiding the learning process
to the most promising area of the search space, the estimated per-
formance of each solution in the map also informs the algorithm
of the maximum performance that can be expected on the physi-
cal robot. For example, if there is no controller in the map that is
expected to perform faster on the real robot than 0.3m/s, it is un-
likely that a faster solution exists. This information is used in our
algorithm to decide if it is worth continuing to search for a bet-
ter controller; if the algorithm has already discovered a controller
that performs nearly as well as the highest value predicted by the
model, we can stop the search.

Formally, our stopping criterion is

max(P1:t) ≥ α max
x∈P

(µt(x)), with α = 0.9

(8)

where x is a location in the discrete behavioral space (i.e. a type of
behavior) and µt is the predicted performance of this type of be-
havior. Thus, when one of the tested solutions has a performance
of 90% or higher of the maximum expected performance of any
behavior in the map, the algorithm terminates. At that point,
the highest-performing solution found so far will be the compen-
satory behavior that the algorithm selects. An alternative way
the algorithm can halt is if 20 tests on the physical robot occur
without triggering the stopping criterion described in equation
8: this event only occurred in 2 of 240 experiments performed
on the physical robot described in the main text. In this case, we
selected the highest-performing solution encountered during the
search. This user-deﬁned stopping criterion is not strictly neces-
sary, as the algorithm is guaranteed to stop in the worst case after
every behavior in the map is tested, but it allows a practical limit
on the number of trials performed on the physical robot.

Initiating the Adaptation Step The adaptation step is trig-
gered when the performance drops by a certain amount. The
simplest way to choose that threshold is to let the user specify
it. Automating the selection of this value, and the impact of trig-
gering the algorithm prematurely, is an interesting question for
future research in this area.

Main parameters of MAP-Elites
• parameters in controller: 36
• parameter values (controller): 0 to 1, with 0.05 increments
• size of behavioral space: 6
• possible behavioral descriptors: {0, 0.25, 0.5, 0.75, 1}

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 16

• iterations: 40 million

Main parameters of M-BOA

noise: 0.001

• σ2
• α: 0.9
• ρ: 0.4
• κ: 0.05

1.5 Robotic Arm Experiment

Physical robot The physical robot is a planar robotic arm with
8 degrees of freedom (Extended Data Fig. 7a) and a 1-degree-
of-freedom gripper. The robot has to release a ball into a bin (a
variant of the classic “pick and place” task in industrial robotics).
To assess the position of the gripper, a red cap, placed on top of
the gripper, is tracked with a video camera. The visual tracking
is achieved with the “cmvision” ROS package, which tracks col-
ored blobs (http://wiki.ros.org/cmvision). The eight joints of the
robot are actuated by position-controlled servos manufactured
by Dynamixel. To maximize the reliability of the the arm, the
type of servo is not the same for all the joints: heavy-duty servos
are used near the base of the robot and lighter ones are used for
the end of the arm. The ﬁrst joint, ﬁxed to the base, is moved
by two MX-28 servos mounted in parallel. The second joint is
moved by an MX-64 servo. The 3 subsequent servos are single
MX-28s, and the 3 remaining servos are AX-18s. All the robot’s
joints are limited to a motion range of ±π/2.

Simulator The generation of the behavior-performance map is
made with a simulated robot in the same way as for the hexapod
experiment. For consistency with the simulated hexapod experi-
ments, we used the dynamic (as opposed to kinematic) version of
the simulator, based on the ODE library. Any joint conﬁguration
that resulted in the arm colliding with itself was not added to the
map.

Parametrized controller The controller deﬁnes the target posi-
tion for each joint. The controller is thus parametrized by eight
continuous values from 0 to 1 describing the angle of each joint,
which is mapped to the the total motion range of each joint of
±π/2. The 8 joints are activated simultaneously and are driven
to their target position by internal PID controllers.

We chose this simple control strategy to make the experiments
easy to reproduce and highlight the contribution of Intelligent
Trial & Error for damage recovery. More advanced control strate-
gies, for instance visual servoing7, would be more realistic in a
industrial environment, but they would have made it hard to an-
alyze the experimental results because both Intelligent Trial & Er-
ror and the controller would compensate for damage at the same
time.

Randomly varying the controller’s parameters Each param-
eter of the controller (section “Parametrized controller”) has a
12.5% chance of being changed to any value from 0 to 1, with the
new value chosen from a polynomial distribution as described
on p. 124 of (Deb, 2000), with ηm = 10.0.

Behavioral descriptor Because the most important aspect of
the robot’s behavior in this task is the ﬁnal position of the gripper,
we use it as the behavioral descriptor:

behavioral_descriptor(simu(c)) =

(9)

(cid:21)

(cid:20) xg
yg

where (xg, yg) denotes the position of the gripper once all the
joint have reached their target position.

The size of the working area of the robot is a rectangle measur-
ing 1.4m × 0.7m. For the behavior-performance map, this rect-
angle is discretized into a grid composed of 20000 square cells
(200 × 100). The robot is 62cm long.

Performance function Contrary to the hexapod experiment,
for the robotic arm experiment the performance function for the
behavior-map creation step and for the adaptation step are dif-
ferent. We did so to demonstrate that the two can be different,
and to create a behavior-performance map that would work with
arbitrary locations of the target bin.

For the behavior-performance map generation step (accomplished
via the MAP-Elites algorithm), the performance function cap-
tures the idea that all joints should contribute equally to the
movement. Speciﬁcally, high-performance is deﬁned as minimiz-
ing the variance of the joint angles, that is:

performance(simu(c))) = −

(pi − m)2

(10)

1
8

i=7
(cid:88)

i=0

(cid:80)i=7

where pi is the angular position of joint i (in radians) and m =
1
i=0 pi is the mean of the joint angles. This performance func-
8
tion does not depend on the target. The map is therefore generic:
it contains a high-performing controller for each point of the
robot’s working space.

For the adaptation step (accomplished via the M-BOA algo-
rithm), the behavior-performance map, which is generic to many
tasks, is used for a particular task. To do so, the adaption step has
a different performance measure than the step that creates the
behavior-performance map. For this problem, the predicted per-
formance measure is the Euclidean distance to the target (closer
is better). Speciﬁcally, for each behavior descriptor x in the map,
performance is

P(x) = −||x − b||

(11)

where b is the (x, y) position of the target bin. Note that the
variance of the joint angles, which is used to create the behavior-
performance map, is ignored during the adaptation step.

The performance of a controller on the physical robot is mini-
mizing the Euclidean distance between the gripper (as measured
with the external camera) and the target bin:

performance(physical_robot(C(χ))) = −||xg − b||

(12)

where xg is the position of the physical gripper after all joints
have reached their ﬁnal position, b is the position of the bin, and
C(χ) is the controller being evaluated (χ is the position in simu-
lation that controller reached).

If the gripper reaches a position outside of the working area,
then the camera cannot see the marker. In these rare cases, we set
the performance of the corresponding controller to a low value
(−1 m).

For the control experiments with traditional Bayesian opti-
mization on the physical robot (see Supplementary Experiment
S1), self-collisions are frequent during adaptation, especially
given that we initialize the process with purely random con-
trollers (i.e. random joint angles). While a single self-collision
is unlikely to break the robot, hundreds of them can wear out the
gearboxes because each servo continues to apply a force for a pe-
riod of time until it determines that it cannot move. To minimize
costs, and because we ran 210 independent runs of the algorithm
(14 scenarios × 15 replicates), we ﬁrst tested each behavior in
simulation (taking the damage into account) to check that there
were no self-collisions. If we detected a self-collision, the perfor-
mance for that behavior was set to a low value (−1m).

Auto-collisions are much less likely with Intelligent Trial & Er-
ror because the behavior-performance map contains only con-
trollers that do not self-collide on the undamaged, simulated

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 17

robot. As a consequence, in the Intelligent Trial & Error experi-
ments we did not simulate controllers before testing them on the
physical robot.

Stopping criterion Because the robot’s task is to release a ball
into a bin, the adaptation step can be stopped when the gripper
is above the bin. The bin is circular with a diameter of 10 cm, so
we stopped the adaptation step when the red cap is within 5 cm
of the center of the bin.

Main MAP-Elites parameters for the robotic arm experiment:

• parameters in controller: 8
• controller parameter values: 0 to 1 (continuous)
• dimensions in the behavioral space: 2
• simulated evaluations to create the behavior-performance

map: 20 million

Main M-BOA parameters for the robotic arm experiment:

noise: 0.03

• σ2
• ρ: 0.1
• κ: 0.3

1.6 Selection of parameters

All of the data reported in this section comes from experiments
with the simulated hexapod robot, unless otherwise stated.

Selecting the ρ value For ρ between 0.1 and 0.8, we counted
the number of behaviors from the map that would be inﬂuenced
by a single test on the real hexapod robot (we considered a behav-
ior to be inﬂuenced when its predicted performance was affected
by more than 25% of the magnitude of the update for the tested
behavior): with ρ = 0.2, the update process does not affect any
neighbor in the map, with ρ = 0.4, it affects 10% of the behaviors,
and with ρ = 0.8, it affects 80% of them. Additional values are
shown in Extended Data Fig. 9c.

The previous paragraph describes tests we conducted to de-
termine the number of behaviors in the map affected by different
ρ values, but those experiments do not tell us how different ρ
values affect the performance of the algorithm overall. To assess
that, we then repeated the experiments from the main paper with
a set of possible values (ρ ∈ [0.1 : 0.025 : 0.8]) in simulation (i.e.,
with a simulated, damaged robot), including testing on 6 sepa-
rate damage scenarios (each where the robot loses a different leg)
with all 8 independently generated replicates of the default 6-
dimensional behavior-performance map. The algorithm stopped
if 20 adaptation iterations passed without success according to
the stopping criteria described in the main text and section 1.4:
Stopping criterion. The results reveal that median performance
decreases only modestly, but signiﬁcantly, when the value of ρ
increases: changing ρ from 0.1 to 0.8 only decreases the median
value 12%, from 0.25 m/s to 0.22 m/s (p-value = 9.3 × 10−5 via
Matlab’s Wilcoxon ranksum test, Extended Data Fig. 9b). The
variance in performance, especially at the extreme low end of the
distribution of performance values, is not constant over the range
of explored values. Around ρ = 0.3 the minimum performance
(Extended Data Fig. 9b, dotted red line) is higher than the mini-
mum performance for more extreme values of ρ.

A larger effect of changing ρ is the amount of time required to
ﬁnd a compensatory behavior, which decreases when the value
of ρ increases (Extended Data Fig. 9b). With a ρ value lower than
0.25, the algorithm rarely converges in less than the allotted 20
iterations, which occurs because many more tests are required
to cover all the promising areas of the search space to know if
a higher-performing behavior exists than the best-already-tested.
On the other hand, with a high ρ value, the algorithm updates

its predictions for the entire search space in a few observations:
while fast, this strategy risks missing promising areas of the
search space.

In light of these data, we chose ρ = 0.4 as the default value
for our hexapod experiments because it represents a good trade-
off between a high minimum performance and a low number of
physical tests on the robot. The value of ρ for the robotic arm
experiment has been chosen with the same method.

Selection of the κ value For the hexapod robot experiments,
we chose κ = 0.05. This relatively low value emphasizes ex-
ploitation over exploration. We chose this value because the ex-
ploration of the search space has already been largely performed
the map
during the behavior-performance map creation step:
suggests which areas of the space will be high-performing, and
should thus be tested, and which areas of the space are likely un-
proﬁtable, and thus should be avoided.

For the robotic arm experiments, we chose κ = 0.3, which
emphasizes exploration more, because it experimentally leads to
better results.

1.7 Running time

Computing hardware All computation (on the physical robots
and in simulation) was conducted on a hyperthreaded 16-core
computer (Intel Xeon E5-2650 2.00GHz with 64Gb of RAM).
This computational power is mainly required for the behavior-
performance map creation step. Creating one map for the hexa-
pod experiment took 2 weeks, taking advantage of the fact that
map creation can easily be parallelized across multiple cores.
Map creation only needs to be performed once per robot (or
robot design), and can happen before the robot is deployed. As
such, the robot’s onboard computer does not need to be powerful
enough to create the map.

For the hexapod robot experiment, the most expensive part
of adaptation is the Simultaneous Localization And Mapping
(SLAM) algorithm46,59,60, which measures the distance traveled
on the physical hexapod robot. It is slow because it processes mil-
lions of 3D points per second. It can be run on less powerful com-
puters, but doing so lowers its accuracy because fewer frames per
second can be processed. As computers become faster, it should
be possible to run high-accuracy SLAM algorithms in low-cost,
onboard computers for robots.

The rest of the adaptation step needs much less computational
power and can easily be run on an onboard computer, such as a
smartphone. That is because it takes approximately 15,000 arith-
metic operations between two evaluations on the physical robot,
which requires less than a second or two on current smartphones.

Measuring how long adaptation takes (hexapod robot) The
reported time to adapt includes the time required for the com-
puter to select each test and the time to conduct each test on the
physical robot. Overall, evaluating a controller on the physical
hexapod robot takes about 8 seconds (median 8.03 seconds, 5th
and 95th percentiles [7.95; 8.21] seconds): 0.5-1 second to initial-
ize the robot, 5 seconds during which the robot can walk, 0.5-1
second to allow the robot to stabilize before taking the ﬁnal mea-
surement, and 1-2 seconds to run the SLAM algorithm. Identify-
ing the ﬁrst controller to test takes 0.03 [0.0216; 0.1277] seconds.
The time to select the next controller to test increases depending
on the number of previous experiments because the size of the
Kernel Matrix (K matrix, see Methods and Extended Data Fig. 8),
which is involved in many of the arithmetic operations, grows by
one row and one column per test that has been conducted. For
example, selecting the second test takes 0.15 [0.13; 0.22] seconds,
while the 10th selection takes 0.31 [0.17; 0.34] seconds.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 18

Extended Data Figure 9 | The effect of changing the algorithm’s parameters. (a) The shape of the Matérn kernel function for different values
of the ρ parameter. (b) Performance and required adaptation time obtained for different values of ρ. For each ρ value, the M-BOA algorithm
was executed in simulation with 8 independently generated behavior-performance maps and for 6 different damage conditions (each case where
one leg is missing). (c) The number of controllers in the map affected by a new observation according to different values of the ρ parameter. (d)
The precision of the odometry value. The distances traveled by the physical robot, as measured manually (“real performance”) is compared to the
measurements automatically provided by the simultaneous location and mapping (SLAM) algorithm(“measured performance”). The dashed black
line indicates the hypothetical case where SLAM measurements are error-free and thus are the same as manual measurements. In (b), (c) and (d), the
middle, black lines represent medians and the borders of the shaded areas show the 25th and 75th percentiles. The dotted lines are the minimum and
maximum values. The gray bars show the ρ value chosen for the hexapod experiments in the main text.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 19

2 Supplementary Experiments S1

Additional conditions for the robotic arm

Methods We investigated 11 damage conditions on the physi-
cal robot in addition to the 3 described in the main text (Fig. 3).
We used the same setup as described in the main text (see main
text and section 1.5). Extended Data Fig. 7 shows the 14 scenar-
ios.

For each of the 14 damage scenarios, we replicated experi-
ments on the physical robot with 15 independently generated
behavior-performance maps (210 runs in total). We also repli-
cated control experiments, which consist of traditional Bayesian
optimization directly in the original parameter space (i.e. with-
out behavior-performance maps), 15 times for each of the 14
damage conditions (210 runs in total). For both the experimental
and control treatments, each experiment involved 30 evaluations
on the physical robot (31 if the ﬁrst trial is counted). In many
cases, not all 30 evaluations were required to reach the target, so
we report only the number of trials required to reach that goal.

Results After running the MAP-Elites algorithm for 20 million
evaluations, each of the 15 generated maps contain more than
11, 000 behaviors (11,209 [1,1206; 1,1217] behaviors, Extended
Data Fig. 7c).

In all the generated maps, the regions of different performance
values for behaviors are arranged in concentric shapes resem-
bling cardioids (inverted, heart-shaped curves) that cover the
places the robot can reach (Extended Data Fig. 7c). The black
line drawn over the shown map corresponds to all the positions
of the end-effector for which all the degrees of freedom are set to
the same angle (from −π/4 to +π/4), that is, for the theoretically
highest achievable performance (i.e. the lowest possible variance
in servo angles). The performance of the behaviors tends to de-
crease the further they are from this optimal line.

The adaptation results (Extended Data Fig. 7e) show that the
Intelligent trial and error algorithm manages to reach the goal
of being less than 5 cm from the center of the bin for all the
runs in all the tested scenarios save two (scenarios 11 & 12). For
these two scenarios, the algorithm still reaches the target 60%
and 80% of the time, respectively. For all the damage conditions,
the Intelligent Trial and Error algorithm reaches the target sig-
niﬁcantly more often than the Bayesian optimization algorithm
(p < 10−24). Speciﬁcally, the median number of iterations to
reach the target (Extended Data Fig. 7f) is below 11 iterations
(27.5 seconds) for all scenarios except 11 and 12, for which 31
and 20 iterations are required, respectively. When the robot is not
able to reach the target, the recorded number of iterations is set to
31, which explains why the median number of iterations for the
Bayesian optimization algorithm is equal to 31 for most damage
conditions. For all the damage conditions except one (scenario
11), the Intelligent Trial and Error algorithm used fewer trials to
reach the target than the traditional Bayesian optimization algo-
rithm.

If the robot is allowed to continue its experiment after reach-
ing the 5 cm radius tolerance, for a total of 31 iterations (Extended
Data Fig. 7g), it reaches an accuracy around 1 cm for all the dam-
age conditions except the two difﬁcult ones (scenarios 11 and 12).
This level of accuracy is never achieved with the classic Bayesian
optimization algorithm, whose lowest median accuracy is 2.6cm.
Scenarios 11 and 12 appear to challenge the Intelligent Trial
and Error algorithm. While in both cases the success rate is im-
proved, though not substantially, in case 11 the median accuracy
is actually lower. These results stem from the fact that the dif-
ference between the successful pre-damage and post-damage be-
haviors is so large that the post-damage solutions for both scenar-
ios lie outside of the map. This illustrates a limit of the proposed
approach: if the map does not contain a behavior able to cope

with the damage, the robot will not be able to adapt. This limit
mainly comes from the behavioral descriptor choice: we chose
it because of its simplicity, but it does not capture all of the im-
portant dimensions of variation of the robot. More sophisticated
descriptors are likely to allow the algorithm to cope with such
situations. On the other hand, this experiment shows that with
a very simple behavioral descriptor, using only the ﬁnal position
of the end-effector, our approach is able to deal with a large va-
riety of different target positions and is signiﬁcantly faster than
the traditional Bayesian optimization approach (Extended Data
Fig. 7d, maximum p-value over each time step < 10−16), which
is the current state of the art technique for direct policy search in
robotics32,61,42,17.

3 Supplementary Experiments S2

The contribution of each subcomponent of the
Intelligent Trial and Error Algorithm

Methods The Intelligent Trial and Error Algorithm relies on
three main concepts: (1) the creation of a behavior-performance
map in simulation via the MAP-Elites algorithm, (2) searching
this map with a Bayesian optimization algorithm to ﬁnd behav-
iors that perform well on the physical robot, and (3) initializing
this Bayesian optimization search with the performance predic-
tions obtained via the MAP-Elites algorithm: note that the sec-
ond step could be performed without the third step by searching
through the MAP-Elites-generated behavior-performance map
with Bayesian optimization, but having the initial priors uni-
formly set to the same value. We investigated the contribution
of each of these subcomponents by testing ﬁve variants of our al-
gorithm : in each of them, we deactivated one of these three sub-
components or replaced it with an alternative algorithm from the
literature. We then tested these variants on the hexapod robot.
The variants are as follows:

• Variant 1 (MAP-Elites in 6 dimensions + random search):
evaluates the beneﬁt of searching the map via Bayesian opti-
mization by searching that map with random search instead.
Each iteration, a behavior is randomly selected from the map
and tested on the robot. The best one is kept.

• Variant 2 (MAP-Elites in 6 dimensions + Bayesian optimiza-
tion, no use of priors): evaluates the contribution of initializ-
ing the Gaussian process with the performance predictions
of the behavior-performance map. In this variant, the Gaus-
sian process is initialized with a constant mean (the average
performance of the map: 0.24 m/s) at each location in the
behavior space and a constant variance (the average vari-
ance of the map’s performance: 0.005 m2/s2). As is custom-
ary, the ﬁrst few trials (here, 5) of the Bayesian optimization
process are selected randomly instead of letting the algo-
rithm choose those points, which is known to improve per-
formance.42

• Variant 3 (MAP-Elites in 6 dimensions + policy gradient):
evaluates the beneﬁt of Bayesian optimization compared to
a more classic, local search algorithm17,62; there is no obvious
way to use priors in policy gradient algorithms.

• Variant 4 (Bayesian optimization in the original parameter
space of 36 dimensions): evaluates the contribution of us-
ing a map in a lower-dimensional behavioral space. This
variant searches directly in the original 36-dimensional pa-
rameter space instead of reducing that space to the lower-
dimensional (six-dimensional) behavior space. Thus, in this
variant no map of behaviors is produced ahead of time: the
algorithm searches directly in the original, high-dimensional
space. This variant corresponds to one of the best algorithms
known to learn locomotion patterns32,42. In this variant, the
Gaussian process is initialized with a constant mean set to

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 20

zero and with a constant variance (0.002m2/s2). As de-
scribed above, the ﬁve ﬁrst trials are selected from pure ran-
dom search to prime the Bayesian optimization algorithm42.
• Variant 5 (Policy gradient in the original parameter space of
36 dimensions): a stochastic gradient descent in the original
parameter space62. This approach is a classic reinforcement
learning algorithm for locomotion17 and it is a baseline in
many papers32.

It was necessary to compare these variants in simulation be-
cause doing so on the physical robot would have required
months of experiments and would have repeatedly worn out or
broken the robot. We modiﬁed the simulator from the main ex-
periments (section 1.4: Simulator) to emulate 6 different possible
damage conditions, each of which involved removing a different
leg. For variants in which MAP-Elites creates a map (variants
1, 2 and 3), we used the same maps from the main experiments
(the eight independently generated maps, which were all gener-
ated with a simulation of the undamaged robot): In these cases,
we launched ten replicates of each variant for each of the eight
maps and each of the six damage conditions. There are there-
fore 10 × 8 × 6 = 480 replicates for each of those variants. For
the other variants (4 and 5), we replicated each experiment 80
times for each of the six damage conditions, which also led to
80 × 6 = 480 replicates per variant. In all these simulated ex-
periments, to roughly simulate the distribution of noisy odome-
try measurements on the real robot, the simulated performance
values were randomly perturbed with a multiplicative Gaussian
noise centered on 0.95 with a standard deviation of 0.1.

We analyze the fastest walking speed achieved with each vari-
ant after two different numbers of trials: the ﬁrst case is after 17
trials, which was the maximum number of iterations used by the
Intelligent Trial and Error Algorithm, and the second case is after
150 trials, which is approximately the number of trials used in
previous work62,32,42.

Results After 17 trials on the robot, Intelligent Trial and Error
signiﬁcantly outperforms all the variants (Extended Data Fig. 2b,
p < 10−67, Intelligent Trial and Error performance: 0.26 [0.20;
0.33] m/s), demonstrating that the three main components of the
algorithm are needed to quickly ﬁnd high-performing behaviors.
Among the investigated variants, the random search in the map
performs the best (Variant 1: 0.21 [0.16; 0.27] m/s), followed by
Bayesian optimization in the map (Variant 2: 0.20 [0.13; 0.25]
m/s), and policy gradient in the map (Variant 3: 0.13 [0; 0.23]
m/s). Variants that search directly in the parameter space did
not ﬁnd any working behavior (Variant 4, Bayesian optimiza-
tion: 0.04m/s, [0.01; 0.09]; Variant 5, policy gradient: 0.02 [0; 0.06]
m/s).

There are two reasons that random search performs better than
one might expect. First, the map only contains high-performing
solutions, which are the result of the intense search of the MAP-
Elites algorithm (40 million evaluations in simulation). The map
thus already contains high-performing gaits of nearly every pos-
sible type. Therefore, this variant is not testing random con-
trollers, but is randomly selecting high-performing solutions.
Second, Bayesian optimization and policy gradient are not de-
signed for such a low number of trials: without the priors on per-
formance predictions introduced in the Intelligent Trial and Er-
ror Algorithm, the Bayesian optimization process needs to learn
the overall shape of the search space to model it with a Gaussian
process. 17 trials is too low a number to effectively sample six di-
mensions (for a uniform sampling with only two possible values
in each dimension, 26 = 64 trials are needed; for ﬁve possible
values, 56 = 15, 625 samples are needed). As a consequence,
with this low number of trials, the Gaussian process that models
the performance function is not informed enough to effectively
guide the search. For the policy gradient algorithm, a gradient is
estimated by empirically measuring the partial derivative of the

performance function in each dimension. To do so, following62,
the policy gradient algorithm performs 15 trials at each iteration.
Consequently, when only 17 trials are allowed, it iterates only
once. In addition, policy gradient is a local optimization algo-
rithm that highly depends on the starting point (which is here
chosen randomly), as illustrated by the high variability in the
performance achieved with this variant (Extended Data Fig. 2b).
The issues faced by Bayesian optimization and policy gradi-
ent are exacerbated when the algorithms search directly in the
original, 36-dimensional parameter space instead of the lower-
dimensional (six-dimensional) behavior space of the map. As
mentioned previously, no working controller was found in the
two variants directly searching in this high-dimensional space.

Overall, the analysis after 17 trials shows that:
• The most critical component of the Intelligent Trial and Er-
ror Algorithm is the MAP-Elites algorithm, which reduces
the search space and produces a map of high-performing
behaviors in that space: p < 5 × 10−50 when comparing
variants searching in the behavior-performance map space
vs. variants that search in the original, higher-dimensional
space of motor parameters.

• Bayesian optimization critically improves the search, but
only when it is initialized with the performance obtained in
simulation during the behavior-performance map creation
step (with initialization: 0.26 [0.20; 0.33] m/s, without ini-
tialization: 0.20 [0.13; 0.25] m/s, p = 10−96).

To check whether these variants might perform better if allowed
the number of evaluations typically given to previous state-of-
the-art algorithms62,32,42, we continued the experiments until 150
trials on the robot were conducted (Extended Data Fig. 2c). Al-
though the results for all the variants improved, Intelligent Trial
and Error still outperforms all them (p < 10−94; Intelligent Trial
and Error: 0.31 [0.26; 0.37] m/s, random search: 0.26 [0.22; 0.30]
m/s, Bayesian optimization: 0.25 [0.18; 0.31] m/s, policy search:
0.23 [0.19, 0.29] m/s). These results are consistent with the previ-
ously published results62,32,42,17, which optimize in 4 to 10 dimen-
sions in a few hundred trials. Nevertheless, when MAP-Elites is
not used, i.e. when we run these algorithms in the original 36
dimensions for 150 evaluations, Bayesian optimization and pol-
icy gradient both perform much worse (Bayesian optimization:
0.08 [0.05; 0.12]; policy gradient: 0.06 [0.01; 0.12] m/s). These re-
sults shows that MAP-Elites is a powerful method to reduce the
dimensionality of a search space for learning algorithms, in addi-
tion to providing helpful priors about the search space that speed
up Bayesian optimization.

Overall, these additional experiments demonstrate that each
of the three main components of the Intelligent Trial and Error
Algorithm substantially improves performance. The results also
indicate that Intelligent Trial and Error signiﬁcantly outperforms
previous algorithms for both damage recovery63,12,64,65,66 and gait
learning67,62,68,48,69,32,61,42,17,49, and can therefore be considered the
state of the art.

4 Supplementary Experiments S3

Robustness to environmental changes

Methods The map creation algorithm (MAP-Elites) uses an un-
damaged robot on ﬂat terrain. The main experiments show that
this algorithm provides useful priors for damage recovery on a
ﬂat terrain. In these supplementary experiments, we evaluated,
in simulation, if the map created on ﬂat terrain also provides a
useful starting point for discovering gaits for sloped terrains.

We ﬁrst evaluated the effect slopes have on undamaged robots
(Extended Data Fig. 3a). We launched 10 replicates for each of
the eight maps and each one-degree increment between −20◦
and +20◦, for a total of 10 × 8 × 41 = 3280 experiments. As in

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 21

Supplementary Experiments S2, to roughly simulate the distribu-
tion of noisy odometry measurements on the real robot, we per-
turbed performance values with a multiplicative Gaussian noise
centered on 0.95 with a standard deviation of 0.1.

Results The results show that, when the slope is negative (de-
scending), the Intelligent Trial and Error approach ﬁnds fast gaits
in fewer than than 3 trials. For reference, a hand-designed, clas-
sic, tripod gait (section 1.4) falls on slopes below −15◦ degrees.
When the slope is positive (ascent), Intelligent Trial and Error
ﬁnds slower behaviors, as is expected, but even above 10◦ the
gait learned by Intelligent Trial and Error outperforms the ref-
erence gait on ﬂat ground. Overall, for every slope angle, the
controller found by Intelligent Trial and Error is faster than the
hand-designed reference controller.

We further evaluated damage recovery performance for these
same slopes with the same setup as Experiments S2 (6 damage
conditions). We launched 10 replicates for each damage condi-
tion, for 8 independently generated behavior-performance maps,
and each two-degree increment between −20◦ and +20◦ degrees.
There are therefore 480 replicates for each two-degree increment
between −20◦ and +20◦, for a total of 480 × 21 = 10080 experi-
ments.

Intelligent Trial and Error is not critically affected by variations
of slope between −10◦ and +10◦ (Extended Data Fig. 3b): for
these slopes, and for all 6 damage conditions, Intelligent Trial
and Error ﬁnds fast gaits (above 0.2 m/s) in less than 15 tests
on the robot despite the slope. As expected, it ﬁnds faster gaits
for negative slopes (descent) and slower gaits for positive slopes
(ascent). For slopes below −10◦ and above 10◦, the algorithm
performs worse and requires more trials. These results likely are
caused by the constraints placed on the controller and the lim-
ited sensors on the robot, rather than the inabilities of the algo-
rithm. Speciﬁcally, the controller was kept simple to make the sci-
ence clearer, more intuitive, and more reproducible. Those con-
straints, of course, prevent it from performing the more complex
behaviors necessary to deal with highly sloped terrain. For exam-
ple, the constraints prevent the robot from keeping its legs ver-
tical on sloped ground, which would substantially reduce slip-
page. Nevertheless, the median Intelligent Trial and Error com-
pensatory gait still outperforms the median performance of the
reference gait on all slope angles.

5 Supplementary Experiments S4

Comparison between MAP-Elites and Random
Sampling

Methods The MAP-Elites algorithm is a stochastic search algo-
rithm that attempts to ﬁll a discretized map with the highest-

performing solution at each point in the map. As explained in
the main text, each point in the map represents a different type
of behavior, as deﬁned by the behavioral dimension of the map.
MAP-Elites generates new candidate points by randomly select-
ing a location in the map, changing the parameters of the con-
troller that is stored there, and then saving that controller in the
appropriate map location if it is better than the current occupant
at that location. Intuitively, generating new candidate solutions
from the best solutions found so far should be better than gener-
ating a multitude of controllers randomly and then keeping the
best one found for each location in the map. In this section we
report on experiments that conﬁrm that intuition.

To understand the advantages of MAP-Elites over random
sampling, we compared the two algorithms by generating data
with the simulated hexapod. The experiments have the same vir-
tual robot, environment, controller, performance function, and
behavioral descriptors as in the main experiments (see Methods).
We analyzed the number of cells for which a solution is found (an
indication of the diversity of behavior types the algorithms gen-
erate), the average performance of behaviors in the map, and the
maximum performance discovered.

We replicated each experiment 8 times, each of which included

20 million evaluations on the simulated robot.

Results The results show that the MAP-Elites algorithm out-
performs random sampling on each of these measures (Extended
Data Fig. 10). After 20 million evaluations, about 13000 cells
(median: 12968, 5th & 95th percentiles: [12892; 13018]) are ﬁlled
by MAP-Elites (about 83% percent of the map), whereas random
sampling only ﬁlled approximately 8600 (8624 [8566; 8641]) cells
(about 55% percent of the map) (Extended Data Fig. 10a). The
difference between the two algorithms is large and appears early
(Extended Data Fig. 10a); after only 1 million evaluations, MAP-
Elites ﬁlled 10670 [10511; 10775] cells (68% of the map), whereas
random sampling ﬁlled 5928 [5882; 5966] cells (38% of the map).
The solutions discovered by MAP-Elites are not only more nu-
merous, but also outperform those found by random sampling
(Extended Data Fig. 10b): with MAP-Elites, after 20 million eval-
uations the average performance of ﬁlled cells is 0.22 [0.22; 0.23]
m/s, whereas it is 0.06 [0.06; 0.06] m/s with random sampling,
which is similar to the performance obtained with the reference
controller on a damaged robot (Fig. 3). These two results demon-
strate that MAP-Elites is a much better algorithm than random
sampling to ﬁnd a map of the diverse, “elite” performers in a
search space.

In addition, MAP-Elites is a better optimization algorithm, as
measured by the performance of the best single solution pro-
duced. The performance of the best solution in the map after
20 million evaluations is 0.40 [0.39;0.41] m/s with MAP-Elites,
compared to 0.21 [0.20; 0.22] m/s with random sampling.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 22

Extended Data Figure 10 | Comparing MAP-Elites and random sampling for generating behavior-performance maps. (a) The number of points
in the map for which a behavior is discovered. (b) The mean performance of the behaviors in the map. (c) The maximum performance of the
behaviors in the map. For all these ﬁgures, the middle lines represent medians over 8 independently generated maps and the shaded regions extend
to the 25th and 75th percentiles, even for (a) and (b), where the variance of the distribution is so small that it is difﬁcult to see. See Supplementary
Experiment S4 for methods and analysis.

where ΘT (k), ΨT (k) and ΦT (k) denote the pitch, roll and
yaw angles, respectively, of the robot torso (hence T ) at the
end of interval k, and K denotes the number of 15ms in-
tervals during the 5 seconds of simulated movement (here,
K = 5s/0.015s ≈ 334). The unit step function U (·) returns
1 if its argument exceeds 0, and returns 0 otherwise. To dis-
count for insigniﬁcant motion around 0 rad, orientation an-
gles are only deﬁned as positive if they exceed 0.5% of π rad.
Similarly, orientation angles are only deﬁned as negative if
they are less than −0.5% of π rad.

3. Displacement (6-dimensional): This behavioral descriptor
characterizes changes in the postion of the robot during
It is measured as the proportion of 15ms inter-
walking.
vals that the robot is positively or negatively displaced along
each of the x, y, and z axes:

x =











(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)

1
K
1
K
1
K
1
K
1
K
1
K

k U (∆x(k) − 0.001)
k U (−∆x(k) − 0.001)
k U (∆y(k) − 0.001)
k U (−∆y(k) − 0.001)
k U (∆z(k) − 0.001)
k U (−∆z(k) − 0.001)











(15)

where [∆x(k), ∆y(k), ∆z(k)] denote the linear displacement
in meters of the robot during interval k, and K denotes the
number of 15ms intervals during 5 seconds of simulated
movement (here, K = 5s/0.015s ≈ 334). The unit step func-
tion U (·) returns a value of 1 if its argument exceeds 0, and
returns a value of 0 otherwise. To ignore insigniﬁcant mo-
tion, linear displacements are deﬁned to be positive if they
exceed 1mm, and are deﬁned to be negative if they are less
than −1mm.

6 Supplementary Experiments S5

Alternative behavioral descriptors

Methods To create a map with MAP-Elites, one has to deﬁne
the dimensions of the behavioral space, i.e. the behavioral de-
scriptors. The main experiments show that using a predeﬁned
behavioral descriptor (the proportion of time that each leg of a
hexapod robot is in contact with the ground, i.e. the duty factor)
creates a map that provides useful priors for damage recovery.

This section describes how we tested (in simulation) how per-
formance is affected by alternative behavioral descriptors, in-
cluding descriptors that have a different number of dimensions.
We also evaluated how performance is affected if the behavioral
descriptors are randomly selected from a large list of potential
descriptors. This test simulates the algorithm’s performance if
the behavioral descriptors are chosen without insight into the
problem domain.

The behavioral descriptors we tested are as follows:
1. Duty factor (6-dimensional): This descriptor is the default
one from the main experiment. It corresponds to the pro-
portion of time each leg is in contact with the ground:







x =

(cid:80)

t C1(t)
numTimesteps

...

(cid:80)

t C6(t)
numTimesteps







where Ci(t) denotes the Boolean value of whether leg i is in
contact with the ground at time t (1: contact, 0: no contact).
2. Orientation (6-dimensional): This behavioral descriptor
characterizes changes in the angular position of the robot
during walking, measured as the proportion of 15ms inter-
vals that each of the pitch, roll and yaw angles of the robot
frame are positive (three dimensions) and negative (three
additional dimensions):

x =











1
K
1
K
1
K
1
K
1
K
1
K

(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)

k U (ΘT (k) − 0.005π)
k U (−ΘT (k) − 0.005π)
k U (ΨT (k) − 0.005π)
k U (−ΨT (k) − 0.005π)
k U (ΦT (k) − 0.005π)
k U (−ΦT (k) − 0.005π)











(13)

(14)

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 23

4. Total energy expended per leg (6-dimensional): This be-
havioral descriptor captures the total amount of energy ex-
pended to move each leg during 5 seconds of movement:







E1
ME

...







x =

E6
ME
where Ei denotes the energy utilized by leg i of the robot
during 5 seconds of simulated movement, measured in
N.m.rad. ME is the maximum amount of energy available
according to the servo model of the simulator, which for 5
seconds is 100 N.m.rad.

5. Relative energy expended per leg (6-dimensional): This be-
havioral descriptor captures the amount of energy expended
to move each leg relative to the energy expended by all the
legs during 5 seconds of simulated movement:







x =

(cid:80)

E1
i=1..6 Ei

...

(cid:80)

E6
i=1..6 Ei







(17)

where Ei denotes the energy utilized by leg i of the robot
during 5 seconds of simulated movement, measured in
N.m.rad.

6. Deviation (3-dimensional): This descriptor captures the
range of deviation of the center of the robot frame versus
the expected location of the robot if it traveled in a straight
line at a constant speed.

(cid:18)

x =

0.95

max
t

(y(t)−

yﬁnal

0.2
5 ×t)−min
0.2

t

(y(t)−

(cid:19)

yﬁnal

5 ×t)

(18)










(cid:18)

0.95

max
t

(x(t))−min

(x(t))

(cid:19)

(cid:19)

t

t

(cid:18)

0.95

max
t

(z(t))−min

(z(t))

0.2










where [x(t), y(t), z(t)] denote the position of robot’s center
at time t, and [xﬁnal, yﬁnal, zﬁnal] denote its ﬁnal position after
5 seconds.
The robot’s task is to move along the y-axis. Its starting po-
sition is (0,0,0). The deviation along the x and z axes is com-
puted as the maximum difference in the robot’s position in
those dimensions at any point during 5 seconds. For the y
axis, yﬁnal
corresponds to the average speed of the robot (the
5
distance covered divided by total time), therefore yﬁnal
5 × t is
the expected position at timestep t if the robot was moving
at constant speed. The deviation from the y axis is computed
with respect to this “theoretical” position.
To obtain values in the range [0,1], the ﬁnal behavioral de-
scriptors are multiplied by 0.95 and then divided by 20 cm
(these values were determined empirically).

7. Total ground reaction force per leg (6-dimensional): This be-
havioral descriptor corresponds to the amount of force each
leg applies to the ground, measured as a fraction the to-
tal possible amount of force that a leg could apply to the
ground. Speciﬁcally, the measurement is

x =













F1
MF

...

F6
MF

(19)

where Fi denotes the ground reaction force (GRF) each leg
i generates, averaged over 5 seconds of simulated move-
ment. MF is the maximum such force that each leg can ap-
ply, which is 10N.

(16)

8. Relative ground reaction force per leg (6-dimensional): This
behavioral descriptor corresponds to the amount of force
each leg applies to the ground, relative to that of all the legs:







x =

(cid:80)

F1
i=1..6 Fi

...

(cid:80)

F6
i=1..6 Fi







x =















(cid:80)

1 (t)

t ΘL
π×N1
...
t ΘL
π×N6

(cid:80)

6 (t)

x =








(cid:80)

1 (t)

t ΨL
π×N1
...
t ΨL
π×N6

(cid:80)

6 (t)








where Fi denotes the ground reaction force (GRF) each leg i
generates, averaged over 5 seconds of simulated movement.
9. Lower-leg pitch angle (6-dimensional): This descriptor cap-
tures the pitch angle for the lower-leg with respect to the
ground (in a global coordinate frame), averaged over 5 sec-
onds:

where ΘL
i (t) is the pitch angle of lower-leg i (hence the L in
ΘL
i ) when it is in contact with the ground at time t, and Ni is
the number of time-steps for which lower-leg i touches the
ground. The foot pitch angles are in range [0, π] (as the leg
can not penetrate the ground) and normalized to [0, 1].
10. Lower-leg roll angle (6-dimensional): This descriptor cap-
tures the roll angle for the lower-leg with respect to the
ground (in a global coordinate frame), averaged over 5 sec-
onds:

where ΨL
i (t) is the roll angle of lower-leg i (hence L in ΨL
i )
when it is in contact with the ground at time t, and Ni is
the number of time-steps for which lower-leg i touches the
ground. The foot roll angles are in range [0, π] (as the leg can
not penetrate the ground) and normalized to [0, 1].

11. Lower-leg yaw angle (6-dimensional): This descriptor cap-
tures the yaw angle for the lower-leg with respect to the
ground (in a global coordinate frame), averaged over 5 sec-
onds:

x =








(cid:80)

1 (t)+π

t ΦL
2π×N1
...
t ΦL
2π×N6

(cid:80)

6 (t)+π








where ΦL
i (t) is the yaw angle of lower-leg i (hence L in ΦL
i )
when it is in contact with the ground at time t,and Ni is
the number of time-steps for which lower-leg i touches the
ground. The foot yaw angles are in range [−π, π] and are
normalized to [0, 1].

(20)

(21)

(22)

(23)

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 24

12. Random (6-dimensional): The random behavioral descrip-
tor differs from the other intentionally chosen descriptors
in that it does not consist of one type of knowledge, but
is instead randomly selected as a subset of variables from
the previously described 11 behavioral descriptors. This de-
scriptor is intended to simulate a situation in which one has
little expectation for which behavioral descriptor will per-
form well, so one quickly picks a few different descriptor
dimensions without consideration or experimentation. In-
stead of generating one such list in this fashion, we ran-
domly sample from a large set to ﬁnd the average perfor-
mance of this approach over many different possible choices.
For the random descriptor, each of the 6-dimensions is se-
lected at random (without replacement) from the 1×3+10×
6 = 63 available behavior descriptor dimensions described
in the previous 11 descriptors (1 of the above descriptors is
three-dimensional and the other 10 are six-dimensional):

x =











R1
...
R6

(24)

where Ri denotes the ith dimension of the descriptor, ran-
domly selected uniformly and without replacement from the
63 available dimensions in behavior descriptors 1-11.

It was necessary to compare these behavioral descriptors in
simulation because doing so on the physical robot would have re-
quired months of experiments and would have repeatedly worn
out or broken the robot. We modiﬁed the simulator from the
main experiments (section 1.4) to emulate 6 different possible
damage conditions, each of which involved removing a differ-
ent leg. The MAP-Elites algorithm, run for 3 million iterations,
was used to create the behavior-performance maps for each of
the behavioral descriptors (using a simulation of the undamaged
robot). During the generation of the behavior-performance maps,
the behaviors were stored in the map’s cells by discretizing each
dimension of the behavioral descriptor space with these ﬁve val-
ues: {0, 0.25, 0.5, 0.75, 1} for the 6-dimensional behavioral de-
scriptors, and with twenty equidistant values between [0, 1] for
the 3-dimensional behavioral descriptor. During the adaptation
phase, the behaviors were used with their actual values and thus
not discretized.

We independently generated eight maps for each of the 11
intentionally chosen behavioral descriptors. Twenty indepen-
dently generated maps were generated for the random behav-
ioral descriptor. We launched ten replicates of each descriptor for
each of the maps (eight for intentionally chosen behavioral de-
scriptors and twenty for random behavioral descriptor) and each
of the six damage conditions. There are therefore 10×8×6 = 480
replicates for each of the intentionally chosen descriptors, and
10 × 20 × 6 = 1200 replicates for the random descriptor.
In
all these simulated experiments, to roughly simulate the distri-
bution of noisy odometry measurements on the real robot, the
simulated performance values were randomly perturbed with a
multiplicative Gaussian noise centered on 0.95 with a standard
deviation of 0.1.

We analyze the fastest walking speed achieved with each be-
havioral descriptor after two different numbers of trials: the ﬁrst
case is after 17 trials, and the second case is after 150 trials.

Results The following results include 17 trials on the simulated
robot, which was the maximum number of trials required for In-
telligent Trial and Error to ﬁnd a compensatory gait in the Sup-
plementary Experiment S2. The post-adaptation performance

achieved with our alternative, intentionally chosen behavioral
descriptors (numbers 2-11) was similar to the original duty factor
behavioral descriptor (number 1) (Extended Data Fig. 4a). All 11
alternative, intentionally chosen descriptors (numbers 2-11) led
to a median performance within 17% of the duty factor descrip-
tor (performance: 0.241 [0.19; 0.29] m/s). The difference in per-
formance was effectively nonexistent with the deviation descrip-
tor (0.241 [0.14; 0.31] m/s), the total GRF descriptor (0.237 [0.15;
0.30] m/s), and the lower-leg roll angle descriptor (0.235 [0.14;
0.31] m/s). The lowest performance was discovered with the rel-
ative GRF descriptor (16.7% lower than the duty factor descrip-
tor, 0.204 [0.08; 0.31] m/s).
In terms of statistical signiﬁcance,
the performance achieved with the duty factor descriptor was no
different from the deviation (p = 0.53) and total GRF (p = 0.29)
descriptors. With all the remaining descriptors, the difference in
performance was statistically signiﬁcant (p < 10−3), but it did
not exceed 0.04m/s. Additionally, the compensatory behaviors
discovered with all our 11 alternative, intentionally chosen de-
scriptors were always faster than the reference gait for all damage
conditions.

To check whether our alternative, intentionally chosen behav-
ioral descriptors lead to better performance if allowed a higher
number of evaluations, we extended the experiments to 150 tri-
als on the robot (Extended Data Fig. 4b). After 150 trials, the dif-
ference in performance between the duty factor behavioral de-
scriptor (0.277 [0.24; 0.34] m/s) and our alternative behavioral
descriptors was further reduced. For all but three alternative,
intentionally chosen descriptors (displacement, total GRF and
lower-leg yaw angle), the median performance was within 4% of
the duty factor descriptor. The difference in performance was at
±3.6% with the orientation (0.274 [0.22; 0.32] m/s), total energy
(0.274 [0.19; 0.33] m/s), relative energy (0.273 [0.20; 0.32] m/s),
deviation (0.287 [0.21; 0.34] m/s), relative GRF (0.266 [0.15; 0.35]
m/s), lower-leg pitch angle (0.271 [0.21; 0.34] m/s) and lower-
leg roll angle (0.268 [0.17; 0.34] m/s) descriptors.
In the three
remaining behavioral descriptors, displacement, total GRF, and
lower-leg yaw angle, the performance was 0.264 [0.18; 0.32] m/s,
0.299 [0.25; 0.35] m/s and 0.255 [0.18; 0.32] m/s, respectively (dif-
ference at ±7.8% of duty factor descriptor in all three cases). In
terms of statistical signiﬁcance, the performance achieved with
the duty factor descriptor was barely statistically signiﬁcantly
different from the deviation descriptor (p = 0.041). In all the re-
maining descriptors, the performance difference was statistically
signiﬁcant (p < 10−2), but no larger than 0.02m/s.

Our random behavioral descriptor also performed similarly to
the duty factor descriptor. After 17 trials, the performance of
M-BOA with the maps generated by the random descriptor was
0.232 [0.14; 0.30] m/s (4.2% lower than the duty factor descrip-
tor performance). While the difference is statistically signiﬁcant
(p < 10−3), the difference in performance itself was negligible at
0.01m/s. This difference in performance was further reduced to
3.6% after 150 trials (random descriptor performance: 0.274 [0.21;
0.34] m/s, duty factor description performance: 0.277 [0.24; 0.34]
m/s, p = 0.002). Moreover, as with the intentionally chosen be-
havioral descriptors, the compensatory behavior discovered with
the random descriptor was also faster than the reference gait.

These experiments show that the selection of the behavioral
dimensions is not critical to get good results. Indeed, all tested
behavioral descriptors, even those randomly generated, perform
well (median > 0.20 m/s after 17 trials). On the other hand, if
the robot’s designers have some prior knowledge about which
dimensions of variation are likely to reveal different types of be-
haviors, the algorithm can beneﬁt from this knowledge to further
improve results (as with the duty factor descriptor).

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 25

7 Caption for Supplementary Videos

Video S1

This video can be viewed at: https://youtu.be/T-c17RKh3uE
Damage Recovery in Robots via Intelligent Trial and Error.
The video shows the Intelligent Trial and Error Algorithm in ac-
tion with the two robots introduced in this paper: the hexapod
robot and the 8 degrees of freedom robotic arm (Fig. 3). The
video shows several examples of the different types of behav-
iors that are produced during the behavior-performance map cre-
ation step, from classic hexapod gaits to more unexpected forms
of locomotion. Then, it shows how the hexapod robot uses that
behavior-performance map to deal with a leg that has lost power
(Fig. 3a:C3). Finally, the video illustrates how the Intelligent Trial
and Error Algorithm can be applied to the second robot and to
different damage conditions.

Video S2

This video can be viewed at: http://youtu.be/ycLspV5lXK8
A Behavior-Performance Map Containing Many Different
Types of Walking Gaits. In the behavior-performance map cre-
ation step, the MAP-Elites algorithm produces a collection of dif-
ferent types of walking gaits. The video shows several examples
of the different types of behaviors that are produced, from classic
hexapod gaits to more unexpected forms of locomotion.

Supplementary References

30. A. E. Eiben and J. E. Smith. Introduction to evolutionary computing. Springer,

31.

2003.
J.-B. Mouret and J. Clune. “Illuminating search spaces by mapping elites”.
In: arXiv preprint arXiv:1504.04909 (2015).

32. D. J. Lizotte, T. Wang, M. H. Bowling, and D. Schuurmans. “Automatic Gait
Optimization with Gaussian Process Regression.” In: Proceedings of the the
International Joint Conference on Artiﬁcial Intelligence (IJCAI). Vol. 7. 2007,
pp. 944–949.

34.

33. E. Brochu, V. M. Cora, and N. De Freitas. “A tutorial on Bayesian optimization
of expensive cost functions, with application to active user modeling and hi-
erarchical reinforcement learning”. In: arXiv preprint arXiv:1012.2599 (2010).
J. Snoek, H. Larochelle, and R. P. Adams. “Practical Bayesian Optimization
of Machine Learning Algorithms”. In: Advances in Neural Information Pro-
cessing Systems 25 (NIPS). 2012, pp. 2951–2959.
T. L. Grifﬁths, C. Lucas, J. Williams, and M. L. Kalish. “Modeling human func-
tion learning with Gaussian processes”. In: Advances in Neural Information
Processing Systems 21 (NIPS). 2009, pp. 553–560.

35.

36. A. J. Booker, J. E. Dennis Jr, P. D. Frank, D. B. Seraﬁni, V. Torczon, and M.
W. Trosset. “A rigorous framework for optimization of expensive functions by
surrogates”. In: Structural optimization 17.1 (1999), pp. 1–13.

39.

37. A. I. J. Forrester and A. J. Keane. “Recent advances in surrogate-based op-
timization”. In: Progress in Aerospace Sciences 45.1 (2009), pp. 50–79.
38. Y Jin. “Surrogate-assisted evolutionary computation: Recent advances and
future challenges”. In: Swarm and Evolutionary Computation 1.2 (2011),
pp. 61–70.
T. W. Simpson, T. M. Mauery, J. J. Korte, and F. Mistree. “Comparison of re-
sponse surface and kriging models for multidisciplinary design optimization”.
In: American Institute of Aeronautics and Astronautics 98.7 (1998), pp. 1–16.
40. D. R. Jones, M. Schonlau, and W. J. Welch. “Efﬁcient global optimization
of expensive black-box functions”. In: Journal of Global optimization 13.4
(1998), pp. 455–492.
J. Sacks, W. J. Welch, T. J. Mitchell, H. P. Wynn, et al. “Design and analysis
of computer experiments”. In: Statistical science 4.4 (1989), pp. 409–423.

41.

42. R. Calandra, A. Seyfarth, J. Peters, and M. P. Deisenroth. “An experimen-
tal comparison of Bayesian optimization for bipedal
locomotion”. In: Pro-
ceedings of the IEEE International Conference on Robotics and Automation
(ICRA). 2014.

43. B. Matérn et al. “Spatial variation. Stochastic models and their application
to some problems in forest surveys and other sampling investigations.” In:
Meddelanden fran statens Skogsforskningsinstitut 49.5 (1960).

44. M. L. Stein. Interpolation of spatial data: some theory for kriging. Springer,

1999.

45. A. V. Fiacco and G. P. McCormick. Nonlinear programming: sequential un-

46.

constrained minimization techniques. Vol. 4. Siam, 1990.
I. Dryanovski, R. G. Valenti, and J. Xiao. “Fast visual odometry and mapping
from rgb-d data”. In: Proceedings of the IEEE International Conference on
Robotics and Automation (ICRA). IEEE. 2013, pp. 2305–2310.

49.

47. M. Quigley, K. Conley, B. P. Gerkey, J. Faust, T. Foote, J. Leibs, R. Wheeler,
and A. Y. Ng. “ROS: an open-source Robot Operating System”. In: Proceed-
ings of ICRA’s workshop on Open Source Software. 2009.

48. A. Sproewitz, R. Moeckel, J. Maye, and A. Ijspeert. “Learning to move in
modular robots using central pattern generators and online optimization”. In:
The International Journal of Robotics Research 27.3-4 (2008), pp. 423–443.
J. Yosinski, J. Clune, D. Hidalgo, S. Nguyen, J. Zagal, and H. Lipson. “Evolv-
ing Robot Gaits in Hardware: the HyperNEAT Generative Encoding Vs. Pa-
rameter Optimization”. In: Proceedings of ECAL (2011), pp. 890–897.
J. Clune, K. Stanley, R. Pennock, and C. Ofria. “On the performance of indi-
rect encoding across the continuum of regularity”. In: IEEE Transactions on
Evolutionary Computation 15.3 (2011), pp. 346–367.
J. Clune, B. Beckmann, C. Ofria, and R. Pennock. “Evolving coordinated
quadruped gaits with the HyperNEAT generative encoding”. In: Proceedings
of the IEEE Congress on Evolutionary Computation. 2009, pp. 2764–2771.

51.

50.

52. S. Lee, J. Yosinski, K. Glette, H. Lipson, and J. Clune. “Evolving gaits for
physical robots with the HyperNEAT generative encoding: the beneﬁts of sim-
ulation.” In: Applications of Evolutionary Computing. Springer, 2013.
53. D. Wilson. “Insect walking”. In: Annual Review of Entomology 11.1 (1966),

pp. 103–122.

54. U. Saranli, M. Buehler, and D. Koditschek. “Rhex: A simple and highly mo-
bile hexapod robot”. In: The International Journal of Robotics Research 20.7
(2001), pp. 616–631.
J. Schmitz, J. Dean, T. Kindermann, M. Schumm, and H. Cruse. “A biolog-
ically inspired controller for hexapod walking: simple solutions by exploiting
physical properties”. In: The biological bulletin 200.2 (2001), pp. 195–200.

55.

56. X. Ding, Z. Wang, A. Rovetta, and J. Zhu. “Locomotion analysis of hexa-
pod robot”. In: Proceedings of Conference on Climbing and Walking Robots
(CLAWAR) (2010), pp. 291–310.

57. S. Steingrube, M. Timme, F. Wörgötter, and P. Manoonpong. “Self-organized
adaptation of a simple neural circuit enables complex robot behaviour”. In:
Nature Physics 6.3 (2010), pp. 224–230.
F. Delcomyn. “The Locomotion of the Cockroach Pariplaneta americana”. In:
Journal of Experimental Biology 54.2 (1971), pp. 443–452.

58.

59. S. Thrun, W. Burgard, D. Fox, et al. Probabilistic robotics. MIT press Cam-

bridge, 2005.

60. M. G. Dissanayake, P. Newman, S. Clark, H. F. Durrant-Whyte, and M.
Csorba. “A solution to the simultaneous localization and map building
(SLAM) problem”. In: IEEE Transactions on Robotics and Automation 17.3
(2001), pp. 229–241.

61. M. Tesch, J. Schneider, and H. Choset. “Using response surfaces and ex-
pected improvement to optimize snake robot gait parameters”. In: Proceed-
ings of the IEEE/RSJ International Conference on Intelligent Robots and Sys-
tems (IROS). IEEE. 2011, pp. 1069–1074.

62. N. Kohl and P. Stone. “Policy gradient reinforcement

learning for fast
quadrupedal locomotion”. In: Proceedings of the IEEE International Confer-
ence on Robotics and Automation (ICRA). Vol. 3. IEEE. 2004, pp. 2619–
2624.

63. M. S. Erden and K. Leblebicio ˘glu. “Free gait generation with reinforcement
learning for a six-legged robot”. In: Robotics and Autonomous Systems 56.3
(2008), pp. 199–212.

64. D. J. Christensen, J. C. Larsen, and K. Stoy. “Fault-tolerant gait learning and
morphology optimization of a polymorphic walking robot”. In: Evolving Sys-
tems 5 (2014), pp. 21–32.

65. S. Mahdavi and P. Bentley. “Innately adaptive robotics through embodied

evolution”. In: Autonomous Robots 20.2 (2006), pp. 149–163.

66. S. Koos, A. Cully, and J.-B. Mouret. “Fast damage recovery in robotics with
the T-resilience algorithm”. In: The International Journal of Robotics Re-
search 32.14 (2013), pp. 1700–1723.

67. G. Hornby, S. Takamura, T. Yamamoto, and M. Fujita. “Autonomous evolu-
tion of dynamic gaits with two quadruped robots”. In: IEEE Transactions on
Robotics 21.3 (2005), pp. 402–410.
T. Barfoot, E. Earon, and G. D’Eleuterio. “Experiments in learning distributed
control for a hexapod robot”. In: Robotics and Autonomous Systems 54.10
(2006), pp. 864–872.

68.

69. S. Koos, J.-B. Mouret, and S. Doncieux. “The transferability approach: Cross-
ing the reality gap in evolutionary robotics”. In: IEEE Transactions on Evolu-
tionary Computation 17.1 (2013), pp. 122–145.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 26

This manuscript is the pre-submission manuscript provided by the authors.
For the ﬁnal, post-review version, please see: http://dx.doi.org/10.1038/nature14422

Robots that can adapt like animals

Antoine Cully,1,2 Jeff Clune,6 Danesh Tarapore,1,2 Jean-Baptiste Mouret1−5,∗

5
1
0
2
 
y
a
M
 
7
2
 
 
]

O
R
.
s
c
[
 
 
4
v
1
0
5
3
.
7
0
4
1
:
v
i
X
r
a

As robots leave the controlled environments of factories to
autonomously function in more complex, natural environ-
ments1,2,3, they will have to respond to the inevitable fact that
they will become damaged4,5. However, while animals can
quickly adapt to a wide variety of injuries, current robots can-
not “think outside the box” to ﬁnd a compensatory behavior
when damaged:
they are limited to their pre-speciﬁed self-
sensing abilities, can diagnose only anticipated failure modes6,
and require a pre-programmed contingency plan for every type
of potential damage, an impracticality for complex robots4,5.
Here we introduce an intelligent trial and error algorithm that
allows robots to adapt to damage in less than two minutes,
without requiring self-diagnosis or pre-speciﬁed contingency
plans. Before deployment, a robot exploits a novel algorithm
to create a detailed map of the space of high-performing behav-
iors: This map represents the robot’s intuitions about what be-
haviors it can perform and their value. If the robot is damaged,
it uses these intuitions to guide a trial-and-error learning algo-
rithm that conducts intelligent experiments to rapidly discover
a compensatory behavior that works in spite of the damage. Ex-
periments reveal successful adaptations for a legged robot in-
jured in ﬁve different ways, including damaged, broken, and
missing legs, and for a robotic arm with joints broken in 14
different ways. This new technique will enable more robust,
effective, autonomous robots, and suggests principles that ani-
mals may use to adapt to injury.

Robots have transformed the economics of many industries,
most notably manufacturing7, and have the power to deliver
tremendous beneﬁts to society, such as in search and rescue8,
disaster response9, health care3, and transportation10. They are
also invaluable tools for scientiﬁc exploration, whether of distant
planets1,4 or deep oceans2. A major obstacle to their widespread
adoption in more complex environments outside of factories is
their fragility4,5: Robots presently pale in comparison to natural
animals in their ability to invent compensatory behaviors after an
injury (Fig. 1A).

Current damage recovery in robots typically involves two
phases: self-diagnosis, and then selecting the best, pre-designed
contingency plan11,12,13,14. Such self-diagnosing robots are expen-
sive, because self-monitoring sensors are expensive, and are difﬁ-
cult to design, because robot engineers cannot foresee every pos-
sible situation: this approach often fails either because the diag-
nosis is incorrect12,13 or because an appropriate contingency plan
is not provided14.

Injured animals respond differently: they learn by trial and
learning which
error how to compensate for damage (e.g.
limp minimizes pain)15,16. Similarly, trial-and-error learning al-
gorithms could allow robots to creatively discover compensatory
behaviors without being limited to their designers’ assumptions
about how damage may occur and how to compensate for each
damage type. However, state-of-the-art learning algorithms are
impractical because of the “curse of dimensionality”17: the fastest

1 Sorbonne Universités, UPMC Univ Paris 06, UMR 7222, ISIR, F-75005, Paris
2 CNRS, UMR 7222, ISIR, F-75005, Paris, France
3 Inria, Villers-lès-Nancy, F-54600, France
4 CNRS, Loria, UMR 7503, Vandœuvre-lès-Nancy, F-54500, France
5 Université de Lorraine, Loria, UMR 7503, Vandœuvre-lès-Nancy, F-54500,
France
6 University of Wyoming, Laramie, WY, USA
∗ Corresponding author: jean-baptiste.mouret@inria.fr

tun-
algorithms constrain the search to a few behaviors (e.g.
ing only 2 parameters, requiring 5-10 minutes) or require human
demonstrations17. Algorithms without these limitations take sev-
eral hours17. Damage recovery would be much more practical
and effective if robots adapted as creatively and quickly as an-
imals (e.g.
in minutes) and without expensive self-diagnosing
sensors.

Here, we show that rapid adaptation can be achieved by guid-
ing an intelligent trial-and-error learning algorithm with an auto-
matically generated, pre-computed, behavior-performance map
that predicts the performance of thousands of different behaviors
(Supplementary Video S1). The key insight is that, whereas cur-
rent learning algorithms either start with no knowledge of the
search space17 or with minimal knowledge from a few human
demonstrations17,18, animals better understand the space of pos-
sible behaviors and their value from previous experience19, en-
abling injured animals to intelligently select tests that validate or
invalidate whole families of promising compensatory behaviors.
We have robots store knowledge from previous experience in
the form of a map of the behavior-performance space. Guided
by this map, a damaged robot tries different types of behaviors
that are predicted to perform well and, as tests are conducted, up-
dates its estimates of the performance of those types of behaviors.
The process ends when the robot predicts that the most effective
behavior has already been discovered. The result is a robot that
quickly discovers a way to compensate for damage (e.g. Fig. 1C)
without a detailed mechanistic understanding of its cause, as oc-
curs with animals. We call this approach “Intelligent Trial and
Error” (Fig. 1D).

The behavior-performance map is created with a novel algo-
rithm and a simulation of the robot, which either can be a stan-
dard physics simulator or can be automatically discovered12. The
robot’s designers only have to describe the dimensions of the
space of possible behaviors and a performance measure. For
instance, walking gaits could be described by how much each
leg is involved in a gait (a behavioral measure) and speed (a
performance measure). For grasping, performance could be the
amount of surface contact, and it has been demonstrated that 90%
of effective poses for the 21-degree-of-freedom human hand can
be captured by a 3-dimensional behavioral space20. To ﬁll in the
behavior-performance map, an optimization algorithm simulta-
neously searches for a high-performing solution at each point in
the behavioral space (Fig. 2A,B and Extended Data Fig. 1). This
step requires simulating millions of behaviors, but needs to be
performed only once per robot design before deployment (Meth-
ods).

A low conﬁdence is assigned to the predicted performance
of behaviors stored in this behavior-performance map because
they have not been tried in reality (Fig. 2B and Extended Data
Fig. 1). During the robot’s mission, if it senses a performance
drop, it selects the most promising behavior from the behavior-
performance map, tests it, and measures its performance. The
robot subsequently updates its prediction for that behavior and
nearby behaviors, assigns high conﬁdence to these predictions
(Fig. 2C and Extended Data Fig. 1), and continues the selec-
tion/test/update process until it ﬁnds a satisfactory compen-
satory behavior (Fig. 2D and Extended Data Fig. 1).

All of these ideas are technically captured via a Gaussian
process model21, which approximates the performance function

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 1

Figure 1| With Intelligent Trial and Error, robots, like animals, can quickly adapt to recover from damage. (A) Most animals can ﬁnd a compen-
satory behavior after an injury. Without relying on predeﬁned compensatory behaviors, they learn how to avoid behaviors that are painful or no longer
effective. (B) An undamaged, hexapod robot. (C) One type of damage the hexapod may have to cope with (broken leg). (D) After damage occurs, in
this case making the robot unable to walk straight, damage recovery via Intelligent Trial and Error begins. The robot tests different types of behaviors
from an automatically generated map of the behavior-performance space. After each test, the robot updates its predictions of which behaviors will
perform well despite the damage. This way, the robot rapidly discovers an effective compensatory behavior.

with already acquired data, and a Bayesian optimization proce-
dure22,23, which exploits this model to search for the maximum
of the performance function (Methods). The robot selects which
behaviors to test by maximizing an information acquisition func-
tion that balances exploration (selecting points whose perfor-
mance is uncertain) and exploitation (selecting points whose per-
formance is expected to be high) (Methods). The selected behav-
ior is tested on the physical robot and the actual performance is
recorded. The algorithm updates the expected performance of
the tested behavior and lowers the uncertainty about it. These
updates are propagated to neighboring solutions in the behav-
ioral space by updating the Gaussian process (Methods). These
updated performance and conﬁdence distributions affect which
behavior is tested next. This select-test-update loop repeats un-
til the robot ﬁnds a behavior whose measured performance is
greater than 90% of the best performance predicted for any be-
havior in the behavior-performance map (Methods).

We ﬁrst test our algorithm on a hexapod robot that needs to
walk as fast as possible (Fig. 1B, D). The robot has 18 motors, an
onboard computer, and a depth camera that allows the robot to
estimate its walking speed (Supplementary Methods). The gait
is parametrized by 36 real-valued parameters that describe the
amplitude of oscillation, phase shift, and duty cycle for each joint
(Supplementary Methods). The behavior space is 6-dimensional,
where each dimension is the proportion of time the ith leg spends
in contact with the ground (i.e. the duty factor)7 (Supplementary
Methods).

The created behavior-performance map contains approxi-
mately 13,000 different gaits (Supplementary Video S2 shows ex-
amples). We tested our robot in six different conditions: undam-
aged (Fig. 3A:C1), four different structural failures (Fig. 3A:C2-
C5), and a temporary leg repair (Fig. 3A:C6). We compare
the walking speed of resultant gaits with a widely-used, classic,
hand-designed tripod gait7 (Supplementary Methods). For each
of the 6 damage conditions, we ran our adaptation step 5 times
for each of 8 independently generated behavior-performance
maps (with the default “duty factor” behavioral description),
leading to 6 × 5 × 8 = 240 experiments in total. We also ran our
adaptation step 5 times on 8 independently generated behavior-
performance maps deﬁned by an alternate behavioral descrip-

tion (“body orientation”, see Supplementary Methods) on two
damage conditions (Fig. 3B-C), leading to 2 × 5 × 8 = 80 addi-
tional experiments.

When the robot is undamaged (Fig. 3A:C1), our approach
yields dynamic gaits that are 30% faster than the classic reference
gait (Fig. 3B, median 0.32 m/s, 5th and 95th percentiles [0.26;
0.36] vs. 0.24m/s), suggesting that Intelligent Trial and Error is
a good search algorithm for automatically producing successful
robot behaviors, putting aside damage recovery. In all the dam-
age scenarios, the reference gait is no longer effective (~0.04 m/s
for the four damage conditions, Fig. 3B:C2-C5). After Intelligent
Trial and Error, the compensatory gaits achieve a reasonably fast
speed (> 0.15m/s) and are between 3 and 7 times more efﬁcient
than the reference gait for that damage condition (in m/s, C2:
0.24 [0.18; 0.31] vs. 0.04; C3: 0.22 [0.18; 0.26] vs. 0.03; C4: 0.21
[0.17; 0.26] vs. 0.04; C5: 0.17 [0.12; 0.24] vs. 0.05; C6: 0.3 [0.21;
0.33] vs 0.12).

These experiments demonstrate that Intelligent Trial and Error
allows the robot to both initially learn fast gaits and to reliably re-
cover after physical damage. Additional experiments reveal that
these capabilities are substantially faster than state-of-the-art al-
gorithms (Extended Data Fig. 2), and that Intelligent Trial and Er-
ror can help with another major challenge in robotics: adapting
to new environments (Extended Data Fig. 3). On the undam-
aged or repaired robot (Fig. 3: C6), Intelligent Trial and Error
learns a walking gait in less than 30 seconds (Fig. 3C, undam-
aged: 24 [16; 41] seconds, 3 [2; 5] physical trials, repaired: 29 [16;
82] seconds, 3.5 [2; 10] trials). For the four damage scenarios, the
robot adapts in approximately one minute (66 [24; 134] seconds,
8 [3; 16] trials). Our results are qualitatively unchanged when
using different behavioral characterizations, including randomly
choosing 6 descriptors among 63 possibilities (Fig. 3B-C and Ex-
tended Data Fig. 4). Additional experiments show that reducing
the high-dimensional parameter space to a low-dimensional be-
havior space via the behavior-performance map is the key com-
ponent for intelligent trial and error: standard Bayesian opti-
mization in the original parameter space does not ﬁnd working
controllers (Extended Data Fig. 2).

We investigated how the behavior-performance map is up-
dated when the robot loses a leg (Fig. 3A:C4). Initially the map

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 2

Figure 2| (A & B). Creating the behavior-performance map: A user reduces a high-dimensional search space to a low-dimensional behavior space by
deﬁning dimensions along which behaviors vary. In simulation, the high-dimensional space is then automatically searched to ﬁnd a high-performing
behavior at each point in the low-dimensional behavior space, creating a “behavior-performance” map of the performance potential of each location
in the low-dimensional space. In our hexapod robot experiments, the behavior space is six-dimensional: the portion of time that each leg is in contact
with the ground. The conﬁdence regarding the accuracy of the predicted performance for each behavior in the behavior-performance map is initially
low because no tests on the physical robot have been conducted. (C & D) Adaptation Step: After damage, the robot selects a promising behavior, tests
it, updates the predicted performance of that behavior in the behavior-performance map, and sets a high conﬁdence on this performance prediction.
The predicted performances of nearby behaviors–and conﬁdence in those predictions–are likely to be similar to the tested behavior and are thus
updated accordingly. This select/test/update loop is repeated until a tested behavior on the physical robot performs better than 90% of the best
predicted performance in the behavior-performance map, a value that can decrease with each test (Extended Data Fig. 1). The algorithm that selects
which behavior to test next balances between choosing the behavior with the highest predicted performance and behaviors that are different from
those tested so far. Overall, the Intelligent Trial and Error approach presented here rapidly locates which types of behaviors are least affected by the
damage to ﬁnd an effective, compensatory behavior.

predicts large areas of high performance. During adaptation,
these areas disappear because the behaviors do not work well on
the damaged robot. Intelligent Trial and Error quickly identiﬁes
one of the few, remaining, high-performance behaviors (Fig. 4
and Extended Data Fig. 5 and 6).

The same damage recovery approach can be applied to any
robot, such as a robotic arm. We tested 14 different damage con-
ditions with a planar, 8-joint robotic arm (Fig. 3D-F and Extended
Data Fig. 7). The behavior-performance map’s behavioral dimen-
sions are the x, y position of the end-effector and the performance
measure is minimizing the variance of the 8 speciﬁed motor an-
gles (Supplementary Methods). During adaptation, performance
is measured as distance to the target. Like with the hexapod
robot, our approach discovers a compensatory behavior in less
than 2 minutes, usually in less than 30 seconds, and with fewer
than 10 trials (Fig. 3F and Extended Data Fig. 7).

While natural animals do not use the speciﬁc algorithm we
present, there are parallels between Intelligent Trial and Error
and animal learning. Like animals, our robot does not have a
predeﬁned strategy for how to cope with every possible dam-
age condition: in the face of a new injury, it exploits its intuitions
about how its body works to experiment with different behaviors
to ﬁnd what works best. Also like animals24, Intelligent Trial and
Error allows the quick identiﬁcation of working behaviors with a
few, diverse tests instead of trying behaviors at random or trying
small modiﬁcations to the best behavior found so far. Addition-
ally, the Bayesian optimization procedure followed by our robot
appears similar to the technique employed by humans when they
optimize an unknown function23, and there is strong evidence
that animal brains learn probability distributions, combine them
with prior knowledge, and act as Bayesian optimizers25,26.

An additional parallel is that Intelligent Trial and Error primes
the robot for creativity during a motionless period, after which

the generated ideas are tested. This process is reminiscent of
the ﬁnding that some animals start the day with new ideas that
they may quickly disregard after experimenting with them27,
and more generally, that sleep improves creativity on cognitive
tasks28. A ﬁnal parallel is that the simulator and Gaussian process
components of Intelligent Trial and Error are two forms of predic-
tive models, which are known to exist in animals29,12. All told, we
have shown that combining pieces of nature’s algorithm, even if
differently assembled, moves robots more towards animals by
endowing them with the ability to rapidly adapt to unforeseen
circumstances.

Supplementary Information and methods are appended at
the end of this document.

Acknowledgments. Thanks to Luigi Tedesco, Stéphane Don-
cieux, Nicolas Bredeche, Shimon Whiteson, Roberto Calandra,
Jacques Droulez, Pierre Bessière, Florian Lesaint, Charles Thu-
rat, Serena Ivaldi, Jingyu Li, Joost Huizinga, Roby Velez, Henok
Mengistu, Tim Clune, and Anh Nguyen for helpful feedback and
discussions. Thanks to Michael Brashier for the photo of the
three-legged dog.

This work has been funded by the ANR Creadapt project (ANR-
12-JS03-0009), the European Research Council (ERC) under
the European Union’s Horizon 2020 research and innovation
programme (grant agreement number 637972), and a Direction
Géneérale de l’Armement (DGA) scholarship to A.C.

Author Contributions A.C. and J.-B. M designed the study.
A.C. and D.T. performed the experiments. A.C., J.-B. M, D.T. and
J.C. discussed additional experiments, analyzed the results, and
wrote the paper.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 3

Figure 3| (A) Conditions tested on
the physical hexapod robot. C1: The
undamaged robot. C2: One leg is
shortened by half. C3: One leg is
unpowered. C4: One leg is miss-
ing. C5: Two legs are missing. C6:
A temporary, makeshift repair to the
(B) Performance af-
tip of one leg.
ter adaptation. Box plots represent
Intelligent Trial and Error. The cen-
tral mark is the median, the edges
of the box are the 25th and 75th per-
centiles, the whiskers extend to the
most extreme data points not consid-
ered outliers, and outliers are plotted
individually. Yellow stars represent
the performance of the handmade
reference tripod gait (Supplementary
Methods).
Conditions C1-C6 are
tested 5 times each for 8 indepen-
dently created behavior-performance
maps with the “duty factor” behav-
ior description (i.e. 40 experiments
per damage condition, Supplemen-
tary Methods). Damage conditions
C1 and C3 are also tested 5 times
each for 8 independently created
behavior-performance maps with the
“body orientation” behavior descrip-
(C)
tion (Supplementary Methods).
Time and number of trials required
to adapt. Box plots represent Intel-
(D) Robotic
ligent Trial and Error.
arm experiment. The 8-joint, planar
robot has to drop a ball into a bin.
(E) Example conditions tested on the
physical robotic arm. C1: One joint
is stuck at 45 degrees. C2: One joint
has a permanent 45-degree offset. C3:
One broken and one offset joint. A to-
tal of 14 conditions were tested (Ex-
(F) Time and
tended Data Fig. 7).
number of trials required to reach
within 5 cm of the bin center. Each
condition is tested with 15 indepen-
dently created behavior-performance
maps.

Figure 4| An example behavior-performance map. This map stores high-performing behaviors at each point in a six-dimensional behavior space.
Each dimension is the portion of time that each leg is in contact with the ground. The behavioral space is discretized at ﬁve values for each dimension
(0; 0.25; 0.5; 0.75; 1). Each colored pixel represents the highest-performing behavior discovered during map creation at that point in the behavior space.
The matrices visualize the six-dimensional behavioral space in two dimensions according to the legend in the top-left. The behavior-performance
map is created with a simulated robot (bottom left) in the Open Dynamics Engine physics simulator (http://www.ode.org). The left matrix is a
pre-adaptation map produced by the map creation algorithm. During adaptation, the map is updated as tests are conducted (in this case, in the
damage condition where the robot is missing one leg: Fig. 3A:C4). The right matrix shows the state of the map after a compensatory behavior
is discovered. The arrows and white circles represent the order in which behaviors were tested on the physical robot. The red circle is the ﬁnal,
discovered, compensatory behavior. Amongst other areas, high-performing behaviors can be found for the damaged robot in the ﬁrst two columns
of the third dimension. These columns represent behaviors that least use the central-left leg, which is the leg that is missing.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 4

Author information Correspondence and requests for ma-
terials should be addressed to J.-B. M.
jean-
baptiste.mouret@inria.fr).

(email:

1.

J. G. Bellingham and K. Rajan. “Robotics in remote and hostile environ-
ments.” In: Science 318.5853 (Nov. 2007), pp. 1098–102. ISSN: 1095-9203.
DOI: 10.1126/science.1146230.

2. D. R. Yoerger. “Underwater robotics”. In: Springer handbook of robotics.

Springer, 2008, pp. 987–1008.

3. E. Broadbent, R. Stafford, and B. MacDonald. “Acceptance of healthcare
robots for the older population: review and future directions”. In: International
Journal of Social Robotics 1.4 (2009), pp. 319–330.

4. K. Sanderson. “Mars rover Spirit (2003-10)”. In: Nature 463.7281 (2010),

5.

p. 600.
J. Carlson and R. R. Murphy. “How UGVs physically fail in the ﬁeld”. In: IEEE
Transactions on Robotics 21.3 (2005), pp. 423–437.

6. M. Blanke and J. Schröder. Diagnosis and fault-tolerant control. Springer,

2006.

7. B. Siciliano and O. Khatib. Springer handbook of robotics. Springer, 2008.
8. R. R. Murphy. “Trial by ﬁre [rescue robots]”. In: Robotics & Automation Mag-

22.

azine, IEEE 11.3 (2004), pp. 50–61.

9. K. Nagatani, S. Kiribayashi, Y. Okada, K. Otake, K. Yoshida, S. Tadokoro,
T. Nishimura, T. Yoshida, E. Koyanagi, M. Fukushima, and S. Kawatsuma.
“Emergency response to the nuclear accident at the Fukushima Daiichi Nu-
clear Power Plants using mobile rescue robots”. In: Journal of Field Robotics
30.1 (2013), pp. 44–63.

10. S. Thrun, M. Montemerlo, H. Dahlkamp, D. Stavens, A. Aron, J. Diebel, P.
Fong, J. Gale, M. Halpenny, G. Hoffmann, et al. “Stanley: The robot that
won the DARPA Grand Challenge”. In: Journal of ﬁeld Robotics 23.9 (2006),
pp. 661–692.

11. V. Verma, G. Gordon, R. Simmons, and S. Thrun. “Real-time fault diagnosis”.

12.

In: Robotics & Automation Magazine 11.2 (2004), pp. 56–66.
J. Bongard, V. Zykov, and H. Lipson. “Resilient machines through continuous
self-modeling”. In: Science 314.5802 (2006), pp. 1118–1121.

13. W. G. Fenton, T. M. McGinnity, and L. P. Maguire. “Fault diagnosis of elec-
tronic systems using intelligent techniques: a review”. In: IEEE Transactions
on Systems, Man, and Cybernetics, Part C: Applications and Reviews 31.3
(2001), pp. 269–281.
J. Kluger and J. Lovell. Apollo 13. Mariner Books, 2006.
0618619580.

ISBN: 978-

14.

15. S. L. Jarvis, D. R. Worley, S. M. Hogy, A. E Hill, K. K. Haussler, and R. F.
Reiser II. “Kinematic and kinetic analysis of dogs during trotting after ampu-
tation of a thoracic limb”. In: American journal of veterinary research 74.9
(2013), pp. 1155–1163.

16. A Fuchs, B Goldner, I Nolte, and N Schilling. “Ground reaction force adap-
tations to tripedal locomotion in dogs.” In: Veterinary journal 201.3 (Sept.
2014), pp. 307–15. ISSN: 1532-2971. DOI: 10.1016/j.tvjl.2014.05.012.
J. Kober, J. A. Bagnell, and J. Peters. “Reinforcement learning in robotics:
a survey”. In: The International Journal of Robotics Research 32.11 (2013),
pp. 1238–1274. DOI: 10.1177/0278364913495721.

17.

18. B. D. Argall, S. Chernova, M. Veloso, and B. Browning. “A survey of robot
learning from demonstration”. In: Robotics and autonomous systems 57.5
(2009), pp. 469–483.

19. E. Thelen. “Motor development: a new synthesis”. In: American psychologist

(1995), pp. 79–95.

20. M. Santello. “Postural hand synergies for tool use”. In: The Journal of Neuro-

science 18.23 (1998), pp. 10105–10115.

21. C. E. Rasmussen and C. K. I. Williams. Gaussian processes for machine

learning. MIT Press, 2006. ISBN: 0-262-18253-X.
J. Mockus. Bayesian approach to global optimization: theory and applica-
tions. Kluwer Academic, 2013.

23. A. Borji and L. Itti. “Bayesian optimization explains human active search”.
In: Advances in Neural Information Processing Systems 26 (NIPS). 2013,
pp. 55–63.

24. S. Benson-Amram and K. E. Holekamp. “Innovative problem solving by wild
spotted hyenas”. In: Proceedings of the Royal Society B: Biological Sciences
279.1744 (2012), pp. 4087–4095.

25. A. Pouget, J. M. Beck, W. J. Ma, and P. E. Latham. “Probabilistic brains:
knowns and unknowns”. In: Nature neuroscience 16.9 (2013), pp. 1170–
1178.

26. K. P. Körding and D. M. Wolpert. “Bayesian integration in sensorimotor learn-

ing”. In: Nature 427.6971 (2004), pp. 244–247.

27. S. Derégnaucourt, P. P. Mitra, O. Fehér, C. Pytte, and O. Tchernichovski.
learning of bird song”. In: Nature

“How sleep affects the developmental
433.7027 (2005), pp. 710–716.

28. U. Wagner, S. Gais, H. Haider, R. Verleger, and J. Born. “Sleep inspires

insight”. In: Nature 427.6972 (2004), pp. 352–355.

29. M. Ito. “Control of mental activities by internal models in the cerebellum”. In:

Nature Reviews Neuroscience 9.4 (2008), pp. 304–313.

5

1 Methods

Notations

• c: Parameters of a controller (vector)
• x: A location in a discrete behavioral space (i.e. a type of

behavior) (vector)

• χ: A location in a discrete behavioral space that has been

tested on the physical robot (vector)

• P: Behavior-performance map (stores performance) (asso-

• C: Behavior-performance map (stores controllers) (associa-

ciative table)

tive table)

• P(x): Max performance yet encountered at x (scalar)
• C(x): Controller currently stored in x (vector)
• χ1:t: All previously tested behavioral descriptors at time t

(vector of vectors)

• P1:t: Performance in reality of all the candidate solutions

tested on the robot up to time t (vector)

• P(χ1:t): Performance in the behavior-performance map for
all the candidate solutions tested on the robot up to time t
(vector)

• f (): Performance function (unknown by the algorithm)

(function)

• σ2

(scalar)

(function)

noise: Observation noise (a user-speciﬁed parameter)

• k(x, x): Kernel function (see section “kernel function”)

• K: Kernel matrix (matrix)
• k: Kernel vector [k(x, χ1), k(x, χ2), ..., k(x, χt)] (vector)
• µt(x): Predicted performance for x (i.e.

the mean of the

Gaussian process) (function)

• σ2

t (x): Standard deviation for x in the Gaussian process

(function)

1.1 Intelligent Trial and Error algorithm (IT&E)

The Intelligent Trial and Error Algorithm consists of two major
steps (Extended Data Fig. 1):
the behavior-performance map
creation step and the adaptation step (while here we focus on
damage recovery, Intelligent Trial and Error can search for any
type of required adaptation, such as learning an initial gait for
an undamaged robot, adapting to new environments, etc.). The
behavior-performance map creation step is accomplished via a
new algorithm introduced in this paper called multi-dimensional
archive of phenotypic elites (MAP-Elites), which is explained
in the next section. The adaptation step is accomplished via a
second new algorithm introduced in this paper called the map-
based Bayesian optimization algorithm (M-BOA), which is ex-
plained in the “Adaptation Step” section below.

1.2 Behavior-performance map creation (via the

MAP-Elites algorithm)

The behavior-performance map is created by a new algorithm we
introduce in this paper called the multi-dimensional archive of
phenotypic elites (MAP-Elites) algorithm. MAP-Elites searches
for the highest-performing solution for each point in a user-
deﬁned space: the user chooses the dimensions of the space that
they are interested in seeing variation in. For example, when de-
signing robots, the user may be interested in seeing the highest-
performing solution at each point in a two-dimensional space
where one axis is the weight of the robot and the other axis is the
height of the robot. Alternatively, a user may wish to see weight
vs. cost, or see solutions throughout a 3D space of weight vs. cost
vs. height. Any dimension that can vary could be chosen by the
user. There is no limit on the number of dimensions that can be
chosen, although it becomes computationally more expensive to

ﬁll the behavior-performance map and store it as the number of
dimensions increases. It also becomes more difﬁcult to visualize
the results. We refer to this user-deﬁned space as the “behavior
space”, because usually the dimensions of variation measure be-
havioral characteristics. Note that the behavioral space can refer
to other aspects of the solution (as in this example, where the di-
mensions of variation are physical properties of a robot such as
its height and weight).

If the behavior descriptors and the parameters of the con-
troller are the same (i.e.
if there is only one possible so-
lution/genome/parameter set/policy/description for each lo-
cation in the behavioral space),
then creating the behavior-
performance map is straightforward: one simply needs to simu-
late the solution at each location in the behavior space and record
the performance. However, if it is not known a priori how to
produce a controller/parameter set/description that will end up
in a speciﬁc location in the behavior space (i.e. if the parameter
space is of higher dimension than the behavioral space: e.g., in
our example, if there are many different robot designs of a spe-
ciﬁc weight, height, and cost, or if it is unknown how to make
a description that will produce a robot with a speciﬁc weight,
height, and cost), then MAP-Elites is beneﬁcial. It will efﬁciently
search for the highest-performing solution at each point of the
low-dimensional behavioral space. It is more efﬁcient than a ran-
dom sampling of the search space because high-performing so-
lutions are often similar in many ways, such that randomly alter-
ing a high-performing solution of one type can produce a high-
performing solution of a different type (see Extended Data Fig.
10 and Supplementary Experiment S4). For this reason, search-
ing for high-performing solutions of all types simultaneously is
much quicker than separately searching for each type. For exam-
ple, to generate a lightweight, high-performing robot design, it
tends to be more effective and efﬁcient to modify an existing de-
sign of a light robot rather than randomly generate new designs
from scratch or launch a separate search process for each new
type of design.

MAP-Elites begins by generating a set of random candidate
solutions. It then evaluates the performance of each solution and
records where that solution is located in the behavior space (e.g.
if the dimensions of the behavior space are the height and weight,
it records the height and weight of each robot in addition to its
performance). For each solution, if its performance is better than
the current solution at that location in the behavior-performance
map, then it is added to the behavior-performance map, replac-
ing the solution in that location. In other words, it is only kept if
it is the best of that type of solution, where “type” is deﬁned as
a location in the behavior space. There is thus only one solution
kept at each location in the behavior space (keeping more could
be beneﬁcial, but for computational reasons we only keep one).
If no solution is present in the behavior-performance map at that
location, then the newly generated candidate solution is added
at that location.

Once this initialization step is ﬁnished, Map-Elites enters a
loop that is similar to stochastic, population-based, optimization
algorithms, such as evolutionary algorithms30: the solutions that
are in the behavior-performance map form a population that is
improved by random variation and selection. In each generation,
the algorithm picks a solution at random via a uniform distri-
bution, meaning that each solution has an equal chance of being
chosen. A copy of the selected solution is then randomly mutated
to change it in some way, its performance is evaluated, its loca-
tion in the behavioral space is determined, and it is kept if it out-
performs the current occupant at that point in the behavior space
(note that mutated solutions may end up in different behavior
space locations than their “parents”). This process is repeated
until a stopping criterion is met (e.g. after a ﬁxed amount of time
has expired). In our experiments, we stopped each MAP-Elites
run after 40 million iterations. Because MAP-Elites is a stochastic

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 6

(A) Behavior-performance map creation. After being
Extended Data Figure 1 | An overview of the Intelligent Trial and Error Algorithm.
initialized with random controllers, the behavioral map (A2), which stores the highest-performing controller found so far of each behavior type,
is improved by repeating the process depicted in (A1) until newly generated controllers are rarely good enough to be added to the map (here,
after 40 million evaluations). This step, which occurs in simulation, is computationally expensive, but only needs to be performed once per robot
(or robot design) prior to deployment.
In our experiments, creating one map involved 40 million iterations of (A1), which lasted roughly two
weeks on one multi-core computer (Supplementary Methods, section “Running time”). (B) Adaptation. (B1) Each behavior from the behavior-
performance map has an expected performance based on its performance in simulation (dark green line) and an estimate of uncertainty regarding
this predicted performance (light green band). The actual performance on the now-damaged robot (black dashed line) is unknown to the algorithm.
A behavior is selected to try on the damaged robot. This selection is made by balancing exploitation—trying behaviors expected to perform well—
and exploration—trying behaviors whose performance is uncertain (Methods, section “acquisition function”). Because all points initially have equal,
maximal uncertainty, the ﬁrst point chosen is that with the highest expected performance. Once this behavior is tested on the physical robot (B4),
the performance predicted for that behavior is set to its actual performance, the uncertainty regarding that prediction is lowered, and the predictions
for, and uncertainties about, nearby controllers are also updated (according to a Gaussian process model, see Methods, section “kernel function”),
the results of which can be seen in (B2). The process is then repeated until performance on the damaged robot is 90% or greater of the maximum
expected performance for any behavior (B3). This performance threshold (orange dashed line) lowers as the maximum expected performance (the
highest point on the dark green line) is lowered, which occurs when physical tests on the robot underperform expectations, as occurred in (B2).

search process, each resultant behavior-performance map can be
different, both in terms of the number of locations in the behav-
ioral space for which a candidate is found, and in terms of the
performance of the candidate in each location.

The pseudo-code of the algorithm is available in Supplemen-
tary Figure 8. More details and experiments about MAP-Elites
are available in (Mouret and Clune, 2015)31.

tainty associated with each prediction. For a cost function f , usu-
ally unknown, a Gaussian process deﬁnes the probability distri-
bution of the possible values f (x) for each point x. These prob-
ability distributions are Gaussian, and are therefore deﬁned by a
mean (µ) and a standard deviation (σ). However, µ and σ can be
different for each x; we therefore deﬁne a probability distribution
over functions:

1.3 Adaptation step (via M-BOA: the map-based

Bayesian optimization algorithm)

The adaptation step is accomplished via a Bayesian optimization
algorithm seeded with a behavior-performance map. We call this
approach a map-based Bayesian optimization algorithm, or M-
BOA.

Bayesian optimization is a model-based, black-box optimiza-
tion algorithm that is tailored for very expensive objective func-
tions (a.k.a. cost functions)32,33,22,34,35,23. As a black-box optimiza-
tion algorithm, Bayesian optimization searches for the maximum
of an unknown objective function from which samples can be ob-
tained (e.g., by measuring the performance of a robot). Like all
model-based optimization algorithms (e.g. surrogate-based algo-
rithms36,37,38, kriging39, or DACE40,41), Bayesian optimization cre-
ates a model of the objective function with a regression method,
uses this model to select the next point to acquire, then updates
the model, etc. It is called Bayesian because, in its general for-
mulation22, this algorithm chooses the next point by computing
a posterior distribution of the objective function using the like-
lihood of the data already acquired and a prior on the type of
function.

Here we use Gaussian process regression to ﬁnd a model21,
which is a common choice for Bayesian optimization42,35,33,32.
Gaussian processes are particularly interesting for regression be-
cause they not only model the cost function, but also the uncer-

P (f (x)|x) = N (µ(x), σ2(x))

(1)

where N denotes the standard normal distribution.

To estimate µ(x) and σ(x), we need to ﬁt the Gaussian process
to the data. To do so, we assume that each observation f (χ) is a
sample from a normal distribution. If we have a data set made
of several observations, that is, f (χ1), f (χ2), ..., f (χt), then the
vector [f (χ1), f (χ2), ..., f (χt)] is a sample from a multivariate nor-
mal distribution, which is deﬁned by a mean vector and a covari-
ance matrix. A Gaussian process is therefore a generalization of
a n-variate normal distribution, where n is the number of obser-
vations. The covariance matrix is what relates one observation
to another: two observations that correspond to nearby values
of χ1 and χ2 are likely to be correlated (this is a prior assump-
tion based on the fact that functions tend to be smooth, and is
injected into the algorithm via a prior on the likelihood of func-
tions), two observations that correspond to distant values of χ1
and χ2 should not inﬂuence each other (i.e. their distributions are
not correlated). Put differently, the covariance matrix represents
that distant samples are almost uncorrelated and nearby samples
are strongly correlated. This covariance matrix is deﬁned via a
kernel function, called k(χ1, χ2), which is usually based on the
Euclidean distance between χ1 and χ2 (see the “kernel function”
sub-section below).

Given a set of observations P1:t = f (χ1:t) and a sampling
noise(which is a user-speciﬁed parameter), the Gaussian

noise σ2

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 7

Variant

Intelligent Trial and Error
Variant 1
Variant 2
Variant 3
Variant 4
Variant 5

Behavior-performance map
creation
MAP-Elites
MAP-Elites
MAP-Elites
MAP-Elites
none
none

Priors on
performance
yes
none
none
none
none
none

Search
algorithm
Bayesian Optimization
random search
Bayesian optimization
policy gradient
Bayesian optimization
policy gradient

equivalent
approach
-
-
-
-
Lizotte et al. (2007)
Kohl et al. (2004)

Extended Data Figure 2 | The contribution of each subcomponent of the Intelligent Trial and Error Algorithm. (A) Adaptation progress versus
the number of robot trials. The walking speed achieved with Intelligent Trial and Error and several “knockout” variants that are missing one of the
algorithm’s key components. Some variants (4 and 5) correspond to state-of-the-art learning algorithms (policy gradient: Kohl et al. 2004; Bayesian
optimization: Lizotte et al. 2007, Tesch et al., 2011, Calandra et al. 2014,). The bold lines represent the medians and the colored areas extend to the
25th and 75th percentiles. (B, C) Adaptation performance after 17 and 150 trials. Shown is the the speed of the compensatory behavior discovered
by each algorithm after 17 and 150 evaluations on the robot, respectively. For all panels, data are pooled across six damage conditions (the removal
of each of the 6 legs in turn). See Supplementary Experiment S2 for methods and analysis.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 8

Extended Data Figure 3 | The Intelligent Trial and Error Algorithm is robust to environmental changes. Each plot shows both the performance and
required adaptation time for Intelligent Trial and Error when the robot must adapt to walk on terrains of different slopes. (A) Adaptation performance
on an undamaged robot. On all slope angles, with very few physical trials, the Intelligent Trial and Error Algorithm (pink shaded region) ﬁnds fast
gaits that outperform the reference gait (black dotted line). (B) Adaptation performance on a damaged robot. The robot is damaged by having
each of the six legs removed in six different damage scenarios. Data are pooled from all six of these damage conditions. The median compensatory
behavior found via Intelligent Trial and Error outperforms the median reference controller on all slope angles. The middle, black lines represent
medians, while the colored areas extend to the 25th and 75th percentiles. In (A), the black dashed line is the performance of a classic tripod gait for
reference. In (B), the reference gait is tried in all six damage conditions and its median (black line) and 25th and 75th percentiles (black colored area)
are shown. See Supplementary Experiment S3 for methods and analysis.

process is computed as follows33,21:

the update equation for the mean function (µt(x), equation 2):

P (f (x)|P1:t, x) = N (µt(x), σ2

t (x))

where :
µt(x) = k(cid:124)K−1P1:t
t (x) = k(x, x) − k(cid:124)K−1k
σ2

K =






k(χ1, χ1)
...
k(χt, χ1)

k = (cid:2) k(x, χ1)

· · ·
. . .
· · ·
k(x, χ2)

k(χ1, χt)
...
k(χt, χt)
· · ·


 + σ2


noiseI

k(x, χt) (cid:3)

Our implementation of Bayesian optimization uses this Gaus-
sian process model to search for the maximum of the objective
function f (x), f (x) being unknown. It selects the next χ to test
by selecting the maximum of the acquisition function, which bal-
ances exploration – improving the model in the less explored
parts of the search space – and exploitation – favoring parts that
the models predicts as promising. Here, we use the “Upper Con-
ﬁdence Bound” acquisition function (see the “information acqui-
sition function” section below). Once the observation is made,
the algorithm updates the Gaussian process to take the new data
into account. In classic Bayesian optimization, the Gaussian pro-
cess is initialized with a constant mean because it is assumed that
all the points of the search space are equally likely to be good.
The model is then progressively reﬁned after each observation.

The key concept of the map-based Bayesian optimization al-
gorithm (M-BOA) is to use the output of MAP-Elites as a prior
for the Bayesian optimization algorithm: thanks to the simula-
tions, we expect some behaviors to perform better than others
on the robot. To incorporate this idea into the Bayesian opti-
mization, M-BOA models the difference between the prediction
of the behavior-performance map and the actual performance on
the real robot, instead of directly modeling the objective function.
This idea is incorporated into the Gaussian process by modifying

(cid:124)
µt(x) = P(x) + k

K−1(P1:t − P(χ1:t))

(3)

(2)

where P(x) is the performance of x according to the simula-
tion and P(χ1:t) is the performance of all the previous observa-
tions, also according to the simulation. Replacing P1:t (eq. 2)
by P1:t − P(χ1:t) (eq. 3) means that the Gaussian process mod-
els the difference between the actual performance P1:t and the
performance from the behavior-performance map P(χ1:t). The
term P(x) is the prediction of the behavior-performance map.
M-BOA therefore starts with the prediction from the behavior-
performance map and corrects it with the Gaussian process.

The pseudo-code of the algorithm is available in Supplemen-

tary Figure 8.

Kernel function The kernel function is the covariance function
of the Gaussian process. It deﬁnes the inﬂuence of a controller’s
performance (on the physical robot) on the performance and con-
ﬁdence estimations of not-yet-tested controllers in the behavior-
performance map that are nearby in behavior space to the tested
controller (Extended Data Fig. 9a).

The Squared Exponential covariance function and the Matérn
kernel are the most common kernels for Gaussian pro-
cesses33,34,21. Both kernels are variants of the “bell curve”. Here
we chose the Matérn kernel because it is more general (it includes
the Squared Exponential function as a special case) and because
it allows us to control not only the distance at which effects be-
come nearly zero (as a function of parameter ρ, Extended Data
Fig. 9a), but also the rate at which distance effects decrease (as a
function of parameter ν).

The Matérn kernel function is computed as follows43,44 (with

ν = 5/2):

(cid:16)

√

k(x1, x2) =
where d(x1, x2) is the Euclidean distance in behavior space.

exp

1 +

−

5d(x1,x2)
ρ

5d(x1,x2)
ρ

+ 5d(x1,x2)2
3ρ2

(cid:17)

(cid:16)

√

(cid:17)

Cully, Clune, Tarapore, and Mouret. 2015

(4)

arXiv preprint | 9

Extended Data Figure 4 | The Intelligent Trial and Error Algorithm is largely robust to alternate choices of behavior descriptors. (A, B) The speed
of the compensatory behavior discovered by Intelligent Trial and Error for various choices of behavior descriptors. Performance is plotted after 17
and 150 evaluations in panels A and B, respectively. Experiments were performed on a simulated, damaged hexapod. The damaged robot has each of
its six legs removed in six different damage scenarios. Data are pooled across all six damage conditions. As described in Supplementary Experiment
S5, the evaluated behavior descriptors characterize the following: (i) Time each leg is in contact with the ground (Duty factor); (ii) Orientation of the
robot frame (Orientation); (iii) Instantaneous velocity of the robot (Displacement); (iv) Energy expended by the robot in walking (Energy (Total),
Energy (Relative)); (v) Deviation from a straight line (Deviation); (vi) Ground reaction force on each leg (GRF (Total), GRF (Relative)); (vii) The
angle of each leg when it touches the ground (Lower-leg angle (Pitch), Lower-leg angle (Roll), Lower-leg angle (Yaw)); and (viii) A random selection
without replacement from subcomponents of all the available behavior descriptors (i-vii) (Random). For the hand-designed reference gait (yellow)
and the compensatory gaits found by the default duty factor behavior descriptor (green), the bold lines represent the medians and the colored areas
extend to the 25th and 75th percentiles of the data. For the other treatments, including the duty factor treatment, black circles represent the median, the
colored area extends to the 25th and 75th percentiles of the data, and the colored circles are outliers. See Supplementary Experiment S5 for methods
and analysis.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 10

Extended Data Figure 5 | How the behavior performance map is explored to discover a compensatory behavior (normalized each iteration to
highlight the range of remaining performance predictions). Colors represent the performance prediction for each point in the map relative to the
highest performing prediction in the map at that step of the process. A black circle indicates the next behavior to be tested on the physical robot. A
red circle indicates the behavior that was just tested (note that the performance predictions surrounding it have changed versus the previous panel).
Arrows reveal the order that points have been explored. The red circle in the last map is the ﬁnal, selected, compensatory behavior. In this scenario,
the robot loses leg number 3. The six dimensional space is visualized according to the inset legend.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 11

Extended Data Figure 6 | How the behavior performance map is explored to discover a compensatory behavior (non-normalized to highlight
that performance predictions decrease as it is discovered that predictions from the simulated, undamaged robot do not work well on the damaged
robot). Colors represent the performance prediction for each point in the map relative to the highest performing prediction in the ﬁrst map. A black
circle indicates the next behavior to be tested on the physical robot. A red circle indicates the behavior that was just tested (note that the performance
predictions surrounding it have changed versus the previous panel). Arrows reveal the order that points have been explored. The red circle in the
last map in the sequence is the ﬁnal, selected, compensatory behavior. In this scenario, the robot loses leg number 3. The six dimensional space
is visualized according to the inset legend. The data visualized in this ﬁgure are identical to those in the previous ﬁgure: the difference is simply
whether the data are renormalized for each new map in the sequence.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 12

Extended Data Figure 7 | Intelligent Trial and Error works on a completely different type of robot: supplementary data from the robotic arm
experiment. (A) The robotic arm experimental setup. (B) Tested damage conditions. (C) Example of behavior performance maps (colormaps)
and behaviors (overlaid arm conﬁgurations) obtained with MAP-Elites. Left: A typical behavior-performance map produced by MAP-Elites with
5 example behaviors, where a behavior is described by the angle of each of the 8 joints. The color of each point is a function of its performance,
which is deﬁned as having low variance in the joint angles (i.e. a zigzag arm is lower performing than a straighter arm that reaches the same point).
Right: Neighboring points in the map tend to have similar behaviors, thanks to the performance function, which would penalize more jagged ways of
reaching those points. That neighbors have similar behaviors justiﬁes updating predictions about the performance of nearby behaviors after a testing a
single behavior on the real (damaged) robot. (D) Performance vs. trial number for Intelligent Trial and Error and traditional Bayesian optimization.
The experiment was conducted on the physical robot, with 15 independent replications for each of the 14 damage conditions. Performance is pooled
from all of these 14×15 = 210 experiments. (E) Success for each damage condition. Shown is the success rate for the 15 replications for each damage
condition, deﬁned as the percentage of replicates in which the robot reaches within 5 cm of the bin center. (F) Trials required to adapt. Shown is the
number of iterations required to reach within 5 cm of the basket center. (G) Accuracy after 30 physical trials. Performance after 30 physical trials for
each damage condition (with the stopping criterion disabled). See Supplementary Experiment S1 for methods and analysis.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 13

CREATE BEHAVIOR-PERFORMANCE MAP (VIA THE MAP-ELITES ALGORITHM IN SIMULATION)

procedure INTELLIGENT TRIAL AND ERROR ALGORITHM (IT&E)

Before the mission:

while In mission do

if Signiﬁcant performance fall then

ADAPTATION STEP (VIA M-BOA ALGORITHM)

procedure MAP-ELITES ALGORITHM

(P ← ∅, C ← ∅)
for iter = 1 → I do

if iter < 400 then

c(cid:48) ← random_controller()

else

c ← random_selection(C)
c(cid:48) ← random_variation(c)

x(cid:48) ←behavioral_descriptor(simu(c(cid:48)))
p(cid:48) ←performance(simu(c(cid:48)))
if P(x(cid:48)) = ∅ or P(x(cid:48)) < p(cid:48) then

P(x(cid:48)) ← p(cid:48)

C(x(cid:48)) ← c(cid:48)

(cid:46) Creation of an empty behavior-performance map (empty N-dimensional grid).
(cid:46) Repeat during I iterations (here we choose I = 40 million iterations).

(cid:46) The ﬁrst 400 controllers are generated randomly.
(cid:46) The next controllers are generated using the map.
(cid:46) Randomly select a controller c in the map.
(cid:46) Create a randomly modiﬁed copy of c.
(cid:46) Simulate the controller and record its behavioral descriptor.
(cid:46) Record its performance.
(cid:46) If the cell is empty or if p(cid:48) is better than the current stored performance.
(cid:46) Store the performance of c(cid:48) in the behavior-performance map according
(cid:46) to its behavioral descriptor x(cid:48).
(cid:46) Associate the controller with its behavioral descriptor.

return behavior-performance map (P and C)

procedure M-BOA (MAP-BASED BAYESIAN OPTIMIZATION ALGORITHM)

∀x ∈ map:

P (f (x)|x) = N (µ0(x), σ2
where
µ0(x) = P(x)
σ2

0(x) = k(x, x)

0(x))

while max(P1:t) < α max(µt(x)) do
χt+1 ← arg maxx(µt(x) + κσt(x))
Pt+1 ← performance(physical_robot(C(χt+1))).
P (f (x)|P1:t+1, x) = N (µt+1(x), σ2
where
µt+1(x) = P(x) + k(cid:124)K−1(P1:t+1 − P(χ1:t+1))
t+1(x) = k(x, x) − k(cid:124)K−1k
σ2

t+1(x))






K =

k(χ1, χ1)
...
k(χt+1, χ1)

· · ·
. . .
· · ·
k(x, χ2)

k(χ1, χt+1)
...
k(χt+1, χt+1)
· · ·

k(x, χt+1) (cid:3)


 + σ2


noiseI

k = (cid:2) k(x, χ1)

(cid:46) Initialisation.
(cid:46) Deﬁnition of the Gaussian Process.

(cid:46) Initialize the mean prior from the map.
(cid:46) Initialize the variance prior (in the common case, k(x, x) = 1).
(cid:46) Iteration loop.
(cid:46) Select next test (argmax of acquisition function).
(cid:46) Evaluation of xt+1 on the physical robot.
(cid:46) Update the Gaussian Process.

(cid:46) Update the mean.
(cid:46) Update the variance.

(cid:46) Compute the observations’ correlation matrix.

(cid:46) Compute the x vs. observation correlation vector.

Extended Data Figure 8 | Pseudo-code for the Intelligent Trial and Error Algorithm, the MAP-Elites algorithm, and the Map-based Bayesian
Optimization Algorithm (M-BOA). Notations are described at the beginning of the methods section.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 14

Because the model update step directly depends on ρ, it is one
of the most critical parameters of the Intelligent Trial and Error
Algorithm. We selected its value after extensive experiments in
simulation (Extended Data Fig. 9 and section 1.6).

Information acquisition function The information acquisition
function selects the next solution that will be evaluated on the
physical robot. The selection is made by ﬁnding the solution
that maximizes the acquisition function. This step is another op-
timization problem, but does not require testing the controller
in simulation or reality. In general, for this optimization prob-
lem we can derive the exact equation and ﬁnd a solution with
gradient-based optimization45. For the speciﬁc behavior space in
the example problem in this paper, though, the discretized search
space of the behavior-performance map is small enough that we
can exhaustively compute the acquisition value of each solution
of the behavior-performance map and then choose the maximum
value.

Several different acquisition functions exist, such as the proba-
bility of improvement, the expected improvement, or the Upper
Conﬁdence Bound (UCB)33,42. We chose UCB because it provided
the best results in several previous studies33,42. The equation for
UCB is:

xt+1 = arg max

(µt(x) + κσt(x))

(5)

x

where κ is a user-deﬁned parameter that tunes the tradeoff be-
tween exploration and exploitation.

The acquisition function handles the exploitation/exploration
trade-off of the adaptation (M-BOA) step. In the UCB function
(Eq. 5), the emphasis on exploitation vs. exploration is explicit
and easy to adjust. The UCB function can be seen as the max-
imum value (argmax) across all solutions of the weighted sum
of the expected performance (mean of the Gaussian, µt(x)) and
of the uncertainty (standard deviation of the Gaussian, σt(x)) of
each solution. This sum is weighted by the κ factor. With a low κ,
the algorithm will choose solutions that are expected to be high-
performing. Conversely, with a high κ, the algorithm will fo-
cus its search on unexplored areas of the search space that may
have high-performing solutions. The κ factor enables ﬁne adjust-
ments to the exploitation/exploration trade-off of the M-BOA al-
gorithm (the adaptation step). We describe how we chose the κ
value in supplementary methods, section 1.6.

Code availability The source code (for GNU/Linux) for the ex-
periments of this paper is available at the following URL:
http://pages.isir.upmc.fr/~mouret/code/ite_source_code.tar.gz An implementa-
tion of the Bayesian optimization algorithm is freely available on:
http://github.com/jbmouret/limbo

1.4 Hexapod Experiment

Physical robot The robot is a 6-legged robot with 3 degrees
of freedom (DOFs) per leg. Each DOF is actuated by position-
controlled servos (MX-28 Dynamixel actuators manufactured by
Robotis). The ﬁrst servo controls the horizontal (front-back) ori-
entation of the leg and the two others control its elevation. An
RGB-D camera (Xtion, from ASUS) is ﬁxed on top of the robot. Its
data are used to estimate the forward displacement of the robot
via an RGB-D SLAM algorithm146 from the robot operating sys-
tem (ROS) framework247.

Simulator The simulator is a dynamic physics simulation of the
undamaged 6-legged robot on ﬂat ground (Fig. 4). We weighted
each segment of the leg and the body of the real robot, and we

1http://wiki.ros.org/ccny_openni_launch
2http://www.ros.org

used the same masses for the simulations. The simulator is based
on the Open Dynamics Engine (ODE, http://www.ode.org).

Parametrized controller The angular position of each DOF is
governed by a periodic function γ parametrized by its amplitude
α, its phase φ, and its duty cycle τ (the duty cycle is the propor-
tion of one period in which the joint is in its higher position). The
function is deﬁned with a square signal of frequency 1Hz, with
amplitude α, and duty cycle τ . This signal is then smoothed via
a Gaussian ﬁlter in order to remove sharp transitions, and is then
shifted according to the phase φ.

Angular positions are sent to the servos every 30 ms. In or-
der to keep the “tibia” of each leg vertical, the control signal of
the third servo is the opposite of the second one. Consequently,
angles sent to the ith leg are:

• γ(t, αi1 , φi1 , τi1 ) for DOF 1
• γ(t, αi2 , φi2 , τi2 ) for DOF 2
• −γ(t, αi2 , φi2 , τi2 ) for DOF 3

This controller makes the robot equivalent to a 12 DOF system,
even though 18 motors are controlled.

There are 6 parameters for each leg (αi1 , αi2 , φi1 , φi2 , τi1 ,
τi2 ), therefore each controller is fully described by 36 parame-
ters. Each parameter can have one of these possible values: 0,
0.05, 0.1, ... 0.95, 1. Different values for these 36 parameters can
produce numerous different gaits, from purely quadruped gaits
to classic tripod gaits.

This controller is designed to be simple enough to show the
performance of the algorithm in an intuitive setup. Neverthe-
less, the algorithm will work with any type of controller, includ-
ing bio-inspired central pattern generators48 and evolved neural
networks49,50,51,52.

Reference controller Our reference controller is a classic tri-
pod gait7,53,54,55,56,57. It involves two tripods: legs 1-4-5 and legs 2-
3-6 (Fig. 4). This controller is designed to always keep the robot
balanced on at least one of these tripods. The walking gait is
achieved by lifting one tripod, while the other tripod pushes the
robot forward (by shifting itself backward). The lifted tripod is
then placed forward in order to repeat the cycle with the other
tripod. This gait is static, fast, and similar to insect gaits53,58.

Table S1 shows the 36 parameters of the reference controller.
The amplitude orientation parameters (αi1 ) are set to 1 to pro-
duce the fastest possible gait, while the amplitude elevation pa-
rameters (αi2 ) are set to a small value (0.25) to keep the gait sta-
ble. The phase elevation parameters (φi2 ) deﬁne two tripods:
0.25 for legs 2-3-5; 0.75 for legs 1-4-5. To achieve a cyclic mo-
tion of the leg, the phase orientation values (φi1 ) are chosen by
subtracting 0.25 to the phase elevation values (φi2 ), plus a 0.5
shift for legs 1-3-5, which are on the left side of the robot. All the
duty cycle parameters (τi) are set to 0.5 so that the motors spend
the same proportion of time in their two limit angles. The actual
speed of the reference controller is not important for the compar-
isons made in this paper: it is simply intended as a reference and
to show that the performance of classic, hand-programmed gaits
tend to fail when damage occurs.

Random variation of controller’s parameters Each parame-
ter of the controller has a 5% chance of being changed to any
value in the set of possible values, with the new value chosen
randomly from a uniform distribution over the possible values.

Main Behavioral descriptor (duty factor) The default behav-
ioral descriptor is a 6-dimensional vector that corresponds to the
proportion of time that each leg is in contact with the ground
(also called duty factor). When a controller is simulated, the al-
gorithm records at each time step (every 30 ms) whether each leg

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 15

Leg number

First joint

Two last joints

1
1.00
0.00
0.5
0.25
0.75
0.5

2
1.00
0.00
0.5
0.25
0.25
0.5

3
1.00
0.50
0.5
0.25
0.25
0.5

4
1.00
0.50
0.5
0.25
0.75
0.5

5
1.00
0.00
0.5
0.25
0.75
0.5

6
1.00
0.00
0.5
0.25
0.25
0.5

αi1
φi1
τi1
αi2
φi2
τi2

Extended Data Table 1| Parameters of the reference controller.

is in contact with the ground (1: contact, 0: no contact). The re-
sult is 6 Boolean time series (Ci for the ith leg). The behavioral
descriptor is then computed with the average of each time series:







x =

(cid:80)

t C1(t)
numTimesteps(C1)

...

(cid:80)

t C6(t)
numTimesteps(C6)







During the generation of the behavior-performance map, the
behaviors are stored in the maps’s cells by discretizing each di-
mension of the behavioral descriptor space with these ﬁve val-
ues: {0, 0.25, 0.5, 0.75, 1}. During the adaptation phase, the behav-
ioral descriptors are used with their actual values and are thus
not discretized.

Alternative Behavioral descriptor (orientation) The alterna-
tive behavioral descriptor tested on the physical robot (we in-
vestigated many other descriptors in simulation: Supplementary
Experiment S5) characterizes changes in the angular position of
the robot during walking, measured as the proportion of 15ms
intervals that each of the pitch, roll and yaw angles of the robot
frame are positive (three dimensions) and negative (three addi-
tional dimensions):

x =











1
K
1
K
1
K
1
K
1
K
1
K

(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)

k U (ΘT (k) − 0.005π)
k U (−ΘT (k) − 0.005π)
k U (ΨT (k) − 0.005π)
k U (−ΨT (k) − 0.005π)
k U (ΦT (k) − 0.005π)
k U (−ΦT (k) − 0.005π)











(7)

where ΘT (k), ΨT (k) and ΦT (k) denote the pitch, roll and yaw
angles, respectively, of the robot torso (hence T ) at the end of
interval k, and K denotes the number of 15ms intervals during
the 5 seconds of simulated movement (here, K = 5s/0.015s ≈
334). The unit step function U (·) returns 1 if its argument exceeds
0, and returns 0 otherwise. To discount for insigniﬁcant motion
around 0 rad, orientation angles are only deﬁned as positive if
they exceed 0.5% of π rad. Similarly, orientation angles are only
deﬁned as negative if they are less than −0.5% of π rad.

Performance function In these experiments, the “mission”
of the robot is to go forward as fast as possible. The perfor-
mance of a controller, which is a set of parameters (section 1.4:
Parametrized controller), is deﬁned as how far the robot moves
in a pre-speciﬁed direction in 5 seconds.

During the behavior-performance map creation step, the per-
formance is obtained thanks to the simulation of the robot. All
odometry results reported on the physical robot, during the
adaptation step, are measured with the embedded simultaneous
location and mapping (SLAM) algorithm46. The accuracy of this
algorithm was evaluated by comparing its measurements to ones
made by hand on 40 different walking gaits. These experiments
revealed that the median measurement produced by the odome-
try algorithm is reasonably accurate, being just 2.2% lower than
the handmade measurement (Extended Data Fig. 9d).

Some damage to the robot may make it ﬂip over. In such cases,
the visual odometry algorithm returns pathological distance-

traveled measurements either several meters backward or for-
ward. To remove these errors, we set all distance-traveled mea-
surements less than zero or greater than two meters to zero. The
result of this adjustment is that the algorithm appropriately con-
siders such behaviors low-performing. Additionally, the SLAM
algorithm sometimes reports substantially inaccurate low val-
ues (outliers on Supplementary Fig. 9d).
In these cases the
adaptation step algorithm will assume that the behavior is low-
performing and will select another working behavior. Thus, the
overall algorithm is not substantially impacted by such infre-
quent under-measurements of performance.

(6)

Stopping criterion In addition to guiding the learning process
to the most promising area of the search space, the estimated per-
formance of each solution in the map also informs the algorithm
of the maximum performance that can be expected on the physi-
cal robot. For example, if there is no controller in the map that is
expected to perform faster on the real robot than 0.3m/s, it is un-
likely that a faster solution exists. This information is used in our
algorithm to decide if it is worth continuing to search for a bet-
ter controller; if the algorithm has already discovered a controller
that performs nearly as well as the highest value predicted by the
model, we can stop the search.

Formally, our stopping criterion is

max(P1:t) ≥ α max
x∈P

(µt(x)), with α = 0.9

(8)

where x is a location in the discrete behavioral space (i.e. a type of
behavior) and µt is the predicted performance of this type of be-
havior. Thus, when one of the tested solutions has a performance
of 90% or higher of the maximum expected performance of any
behavior in the map, the algorithm terminates. At that point,
the highest-performing solution found so far will be the compen-
satory behavior that the algorithm selects. An alternative way
the algorithm can halt is if 20 tests on the physical robot occur
without triggering the stopping criterion described in equation
8: this event only occurred in 2 of 240 experiments performed
on the physical robot described in the main text. In this case, we
selected the highest-performing solution encountered during the
search. This user-deﬁned stopping criterion is not strictly neces-
sary, as the algorithm is guaranteed to stop in the worst case after
every behavior in the map is tested, but it allows a practical limit
on the number of trials performed on the physical robot.

Initiating the Adaptation Step The adaptation step is trig-
gered when the performance drops by a certain amount. The
simplest way to choose that threshold is to let the user specify
it. Automating the selection of this value, and the impact of trig-
gering the algorithm prematurely, is an interesting question for
future research in this area.

Main parameters of MAP-Elites
• parameters in controller: 36
• parameter values (controller): 0 to 1, with 0.05 increments
• size of behavioral space: 6
• possible behavioral descriptors: {0, 0.25, 0.5, 0.75, 1}

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 16

• iterations: 40 million

Main parameters of M-BOA

noise: 0.001

• σ2
• α: 0.9
• ρ: 0.4
• κ: 0.05

1.5 Robotic Arm Experiment

Physical robot The physical robot is a planar robotic arm with
8 degrees of freedom (Extended Data Fig. 7a) and a 1-degree-
of-freedom gripper. The robot has to release a ball into a bin (a
variant of the classic “pick and place” task in industrial robotics).
To assess the position of the gripper, a red cap, placed on top of
the gripper, is tracked with a video camera. The visual tracking
is achieved with the “cmvision” ROS package, which tracks col-
ored blobs (http://wiki.ros.org/cmvision). The eight joints of the
robot are actuated by position-controlled servos manufactured
by Dynamixel. To maximize the reliability of the the arm, the
type of servo is not the same for all the joints: heavy-duty servos
are used near the base of the robot and lighter ones are used for
the end of the arm. The ﬁrst joint, ﬁxed to the base, is moved
by two MX-28 servos mounted in parallel. The second joint is
moved by an MX-64 servo. The 3 subsequent servos are single
MX-28s, and the 3 remaining servos are AX-18s. All the robot’s
joints are limited to a motion range of ±π/2.

Simulator The generation of the behavior-performance map is
made with a simulated robot in the same way as for the hexapod
experiment. For consistency with the simulated hexapod experi-
ments, we used the dynamic (as opposed to kinematic) version of
the simulator, based on the ODE library. Any joint conﬁguration
that resulted in the arm colliding with itself was not added to the
map.

Parametrized controller The controller deﬁnes the target posi-
tion for each joint. The controller is thus parametrized by eight
continuous values from 0 to 1 describing the angle of each joint,
which is mapped to the the total motion range of each joint of
±π/2. The 8 joints are activated simultaneously and are driven
to their target position by internal PID controllers.

We chose this simple control strategy to make the experiments
easy to reproduce and highlight the contribution of Intelligent
Trial & Error for damage recovery. More advanced control strate-
gies, for instance visual servoing7, would be more realistic in a
industrial environment, but they would have made it hard to an-
alyze the experimental results because both Intelligent Trial & Er-
ror and the controller would compensate for damage at the same
time.

Randomly varying the controller’s parameters Each param-
eter of the controller (section “Parametrized controller”) has a
12.5% chance of being changed to any value from 0 to 1, with the
new value chosen from a polynomial distribution as described
on p. 124 of (Deb, 2000), with ηm = 10.0.

Behavioral descriptor Because the most important aspect of
the robot’s behavior in this task is the ﬁnal position of the gripper,
we use it as the behavioral descriptor:

behavioral_descriptor(simu(c)) =

(9)

(cid:21)

(cid:20) xg
yg

where (xg, yg) denotes the position of the gripper once all the
joint have reached their target position.

The size of the working area of the robot is a rectangle measur-
ing 1.4m × 0.7m. For the behavior-performance map, this rect-
angle is discretized into a grid composed of 20000 square cells
(200 × 100). The robot is 62cm long.

Performance function Contrary to the hexapod experiment,
for the robotic arm experiment the performance function for the
behavior-map creation step and for the adaptation step are dif-
ferent. We did so to demonstrate that the two can be different,
and to create a behavior-performance map that would work with
arbitrary locations of the target bin.

For the behavior-performance map generation step (accomplished
via the MAP-Elites algorithm), the performance function cap-
tures the idea that all joints should contribute equally to the
movement. Speciﬁcally, high-performance is deﬁned as minimiz-
ing the variance of the joint angles, that is:

performance(simu(c))) = −

(pi − m)2

(10)

1
8

i=7
(cid:88)

i=0

(cid:80)i=7

where pi is the angular position of joint i (in radians) and m =
1
i=0 pi is the mean of the joint angles. This performance func-
8
tion does not depend on the target. The map is therefore generic:
it contains a high-performing controller for each point of the
robot’s working space.

For the adaptation step (accomplished via the M-BOA algo-
rithm), the behavior-performance map, which is generic to many
tasks, is used for a particular task. To do so, the adaption step has
a different performance measure than the step that creates the
behavior-performance map. For this problem, the predicted per-
formance measure is the Euclidean distance to the target (closer
is better). Speciﬁcally, for each behavior descriptor x in the map,
performance is

P(x) = −||x − b||

(11)

where b is the (x, y) position of the target bin. Note that the
variance of the joint angles, which is used to create the behavior-
performance map, is ignored during the adaptation step.

The performance of a controller on the physical robot is mini-
mizing the Euclidean distance between the gripper (as measured
with the external camera) and the target bin:

performance(physical_robot(C(χ))) = −||xg − b||

(12)

where xg is the position of the physical gripper after all joints
have reached their ﬁnal position, b is the position of the bin, and
C(χ) is the controller being evaluated (χ is the position in simu-
lation that controller reached).

If the gripper reaches a position outside of the working area,
then the camera cannot see the marker. In these rare cases, we set
the performance of the corresponding controller to a low value
(−1 m).

For the control experiments with traditional Bayesian opti-
mization on the physical robot (see Supplementary Experiment
S1), self-collisions are frequent during adaptation, especially
given that we initialize the process with purely random con-
trollers (i.e. random joint angles). While a single self-collision
is unlikely to break the robot, hundreds of them can wear out the
gearboxes because each servo continues to apply a force for a pe-
riod of time until it determines that it cannot move. To minimize
costs, and because we ran 210 independent runs of the algorithm
(14 scenarios × 15 replicates), we ﬁrst tested each behavior in
simulation (taking the damage into account) to check that there
were no self-collisions. If we detected a self-collision, the perfor-
mance for that behavior was set to a low value (−1m).

Auto-collisions are much less likely with Intelligent Trial & Er-
ror because the behavior-performance map contains only con-
trollers that do not self-collide on the undamaged, simulated

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 17

robot. As a consequence, in the Intelligent Trial & Error experi-
ments we did not simulate controllers before testing them on the
physical robot.

Stopping criterion Because the robot’s task is to release a ball
into a bin, the adaptation step can be stopped when the gripper
is above the bin. The bin is circular with a diameter of 10 cm, so
we stopped the adaptation step when the red cap is within 5 cm
of the center of the bin.

Main MAP-Elites parameters for the robotic arm experiment:

• parameters in controller: 8
• controller parameter values: 0 to 1 (continuous)
• dimensions in the behavioral space: 2
• simulated evaluations to create the behavior-performance

map: 20 million

Main M-BOA parameters for the robotic arm experiment:

noise: 0.03

• σ2
• ρ: 0.1
• κ: 0.3

1.6 Selection of parameters

All of the data reported in this section comes from experiments
with the simulated hexapod robot, unless otherwise stated.

Selecting the ρ value For ρ between 0.1 and 0.8, we counted
the number of behaviors from the map that would be inﬂuenced
by a single test on the real hexapod robot (we considered a behav-
ior to be inﬂuenced when its predicted performance was affected
by more than 25% of the magnitude of the update for the tested
behavior): with ρ = 0.2, the update process does not affect any
neighbor in the map, with ρ = 0.4, it affects 10% of the behaviors,
and with ρ = 0.8, it affects 80% of them. Additional values are
shown in Extended Data Fig. 9c.

The previous paragraph describes tests we conducted to de-
termine the number of behaviors in the map affected by different
ρ values, but those experiments do not tell us how different ρ
values affect the performance of the algorithm overall. To assess
that, we then repeated the experiments from the main paper with
a set of possible values (ρ ∈ [0.1 : 0.025 : 0.8]) in simulation (i.e.,
with a simulated, damaged robot), including testing on 6 sepa-
rate damage scenarios (each where the robot loses a different leg)
with all 8 independently generated replicates of the default 6-
dimensional behavior-performance map. The algorithm stopped
if 20 adaptation iterations passed without success according to
the stopping criteria described in the main text and section 1.4:
Stopping criterion. The results reveal that median performance
decreases only modestly, but signiﬁcantly, when the value of ρ
increases: changing ρ from 0.1 to 0.8 only decreases the median
value 12%, from 0.25 m/s to 0.22 m/s (p-value = 9.3 × 10−5 via
Matlab’s Wilcoxon ranksum test, Extended Data Fig. 9b). The
variance in performance, especially at the extreme low end of the
distribution of performance values, is not constant over the range
of explored values. Around ρ = 0.3 the minimum performance
(Extended Data Fig. 9b, dotted red line) is higher than the mini-
mum performance for more extreme values of ρ.

A larger effect of changing ρ is the amount of time required to
ﬁnd a compensatory behavior, which decreases when the value
of ρ increases (Extended Data Fig. 9b). With a ρ value lower than
0.25, the algorithm rarely converges in less than the allotted 20
iterations, which occurs because many more tests are required
to cover all the promising areas of the search space to know if
a higher-performing behavior exists than the best-already-tested.
On the other hand, with a high ρ value, the algorithm updates

its predictions for the entire search space in a few observations:
while fast, this strategy risks missing promising areas of the
search space.

In light of these data, we chose ρ = 0.4 as the default value
for our hexapod experiments because it represents a good trade-
off between a high minimum performance and a low number of
physical tests on the robot. The value of ρ for the robotic arm
experiment has been chosen with the same method.

Selection of the κ value For the hexapod robot experiments,
we chose κ = 0.05. This relatively low value emphasizes ex-
ploitation over exploration. We chose this value because the ex-
ploration of the search space has already been largely performed
the map
during the behavior-performance map creation step:
suggests which areas of the space will be high-performing, and
should thus be tested, and which areas of the space are likely un-
proﬁtable, and thus should be avoided.

For the robotic arm experiments, we chose κ = 0.3, which
emphasizes exploration more, because it experimentally leads to
better results.

1.7 Running time

Computing hardware All computation (on the physical robots
and in simulation) was conducted on a hyperthreaded 16-core
computer (Intel Xeon E5-2650 2.00GHz with 64Gb of RAM).
This computational power is mainly required for the behavior-
performance map creation step. Creating one map for the hexa-
pod experiment took 2 weeks, taking advantage of the fact that
map creation can easily be parallelized across multiple cores.
Map creation only needs to be performed once per robot (or
robot design), and can happen before the robot is deployed. As
such, the robot’s onboard computer does not need to be powerful
enough to create the map.

For the hexapod robot experiment, the most expensive part
of adaptation is the Simultaneous Localization And Mapping
(SLAM) algorithm46,59,60, which measures the distance traveled
on the physical hexapod robot. It is slow because it processes mil-
lions of 3D points per second. It can be run on less powerful com-
puters, but doing so lowers its accuracy because fewer frames per
second can be processed. As computers become faster, it should
be possible to run high-accuracy SLAM algorithms in low-cost,
onboard computers for robots.

The rest of the adaptation step needs much less computational
power and can easily be run on an onboard computer, such as a
smartphone. That is because it takes approximately 15,000 arith-
metic operations between two evaluations on the physical robot,
which requires less than a second or two on current smartphones.

Measuring how long adaptation takes (hexapod robot) The
reported time to adapt includes the time required for the com-
puter to select each test and the time to conduct each test on the
physical robot. Overall, evaluating a controller on the physical
hexapod robot takes about 8 seconds (median 8.03 seconds, 5th
and 95th percentiles [7.95; 8.21] seconds): 0.5-1 second to initial-
ize the robot, 5 seconds during which the robot can walk, 0.5-1
second to allow the robot to stabilize before taking the ﬁnal mea-
surement, and 1-2 seconds to run the SLAM algorithm. Identify-
ing the ﬁrst controller to test takes 0.03 [0.0216; 0.1277] seconds.
The time to select the next controller to test increases depending
on the number of previous experiments because the size of the
Kernel Matrix (K matrix, see Methods and Extended Data Fig. 8),
which is involved in many of the arithmetic operations, grows by
one row and one column per test that has been conducted. For
example, selecting the second test takes 0.15 [0.13; 0.22] seconds,
while the 10th selection takes 0.31 [0.17; 0.34] seconds.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 18

Extended Data Figure 9 | The effect of changing the algorithm’s parameters. (a) The shape of the Matérn kernel function for different values
of the ρ parameter. (b) Performance and required adaptation time obtained for different values of ρ. For each ρ value, the M-BOA algorithm
was executed in simulation with 8 independently generated behavior-performance maps and for 6 different damage conditions (each case where
one leg is missing). (c) The number of controllers in the map affected by a new observation according to different values of the ρ parameter. (d)
The precision of the odometry value. The distances traveled by the physical robot, as measured manually (“real performance”) is compared to the
measurements automatically provided by the simultaneous location and mapping (SLAM) algorithm(“measured performance”). The dashed black
line indicates the hypothetical case where SLAM measurements are error-free and thus are the same as manual measurements. In (b), (c) and (d), the
middle, black lines represent medians and the borders of the shaded areas show the 25th and 75th percentiles. The dotted lines are the minimum and
maximum values. The gray bars show the ρ value chosen for the hexapod experiments in the main text.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 19

2 Supplementary Experiments S1

Additional conditions for the robotic arm

Methods We investigated 11 damage conditions on the physi-
cal robot in addition to the 3 described in the main text (Fig. 3).
We used the same setup as described in the main text (see main
text and section 1.5). Extended Data Fig. 7 shows the 14 scenar-
ios.

For each of the 14 damage scenarios, we replicated experi-
ments on the physical robot with 15 independently generated
behavior-performance maps (210 runs in total). We also repli-
cated control experiments, which consist of traditional Bayesian
optimization directly in the original parameter space (i.e. with-
out behavior-performance maps), 15 times for each of the 14
damage conditions (210 runs in total). For both the experimental
and control treatments, each experiment involved 30 evaluations
on the physical robot (31 if the ﬁrst trial is counted). In many
cases, not all 30 evaluations were required to reach the target, so
we report only the number of trials required to reach that goal.

Results After running the MAP-Elites algorithm for 20 million
evaluations, each of the 15 generated maps contain more than
11, 000 behaviors (11,209 [1,1206; 1,1217] behaviors, Extended
Data Fig. 7c).

In all the generated maps, the regions of different performance
values for behaviors are arranged in concentric shapes resem-
bling cardioids (inverted, heart-shaped curves) that cover the
places the robot can reach (Extended Data Fig. 7c). The black
line drawn over the shown map corresponds to all the positions
of the end-effector for which all the degrees of freedom are set to
the same angle (from −π/4 to +π/4), that is, for the theoretically
highest achievable performance (i.e. the lowest possible variance
in servo angles). The performance of the behaviors tends to de-
crease the further they are from this optimal line.

The adaptation results (Extended Data Fig. 7e) show that the
Intelligent trial and error algorithm manages to reach the goal
of being less than 5 cm from the center of the bin for all the
runs in all the tested scenarios save two (scenarios 11 & 12). For
these two scenarios, the algorithm still reaches the target 60%
and 80% of the time, respectively. For all the damage conditions,
the Intelligent Trial and Error algorithm reaches the target sig-
niﬁcantly more often than the Bayesian optimization algorithm
(p < 10−24). Speciﬁcally, the median number of iterations to
reach the target (Extended Data Fig. 7f) is below 11 iterations
(27.5 seconds) for all scenarios except 11 and 12, for which 31
and 20 iterations are required, respectively. When the robot is not
able to reach the target, the recorded number of iterations is set to
31, which explains why the median number of iterations for the
Bayesian optimization algorithm is equal to 31 for most damage
conditions. For all the damage conditions except one (scenario
11), the Intelligent Trial and Error algorithm used fewer trials to
reach the target than the traditional Bayesian optimization algo-
rithm.

If the robot is allowed to continue its experiment after reach-
ing the 5 cm radius tolerance, for a total of 31 iterations (Extended
Data Fig. 7g), it reaches an accuracy around 1 cm for all the dam-
age conditions except the two difﬁcult ones (scenarios 11 and 12).
This level of accuracy is never achieved with the classic Bayesian
optimization algorithm, whose lowest median accuracy is 2.6cm.
Scenarios 11 and 12 appear to challenge the Intelligent Trial
and Error algorithm. While in both cases the success rate is im-
proved, though not substantially, in case 11 the median accuracy
is actually lower. These results stem from the fact that the dif-
ference between the successful pre-damage and post-damage be-
haviors is so large that the post-damage solutions for both scenar-
ios lie outside of the map. This illustrates a limit of the proposed
approach: if the map does not contain a behavior able to cope

with the damage, the robot will not be able to adapt. This limit
mainly comes from the behavioral descriptor choice: we chose
it because of its simplicity, but it does not capture all of the im-
portant dimensions of variation of the robot. More sophisticated
descriptors are likely to allow the algorithm to cope with such
situations. On the other hand, this experiment shows that with
a very simple behavioral descriptor, using only the ﬁnal position
of the end-effector, our approach is able to deal with a large va-
riety of different target positions and is signiﬁcantly faster than
the traditional Bayesian optimization approach (Extended Data
Fig. 7d, maximum p-value over each time step < 10−16), which
is the current state of the art technique for direct policy search in
robotics32,61,42,17.

3 Supplementary Experiments S2

The contribution of each subcomponent of the
Intelligent Trial and Error Algorithm

Methods The Intelligent Trial and Error Algorithm relies on
three main concepts: (1) the creation of a behavior-performance
map in simulation via the MAP-Elites algorithm, (2) searching
this map with a Bayesian optimization algorithm to ﬁnd behav-
iors that perform well on the physical robot, and (3) initializing
this Bayesian optimization search with the performance predic-
tions obtained via the MAP-Elites algorithm: note that the sec-
ond step could be performed without the third step by searching
through the MAP-Elites-generated behavior-performance map
with Bayesian optimization, but having the initial priors uni-
formly set to the same value. We investigated the contribution
of each of these subcomponents by testing ﬁve variants of our al-
gorithm : in each of them, we deactivated one of these three sub-
components or replaced it with an alternative algorithm from the
literature. We then tested these variants on the hexapod robot.
The variants are as follows:

• Variant 1 (MAP-Elites in 6 dimensions + random search):
evaluates the beneﬁt of searching the map via Bayesian opti-
mization by searching that map with random search instead.
Each iteration, a behavior is randomly selected from the map
and tested on the robot. The best one is kept.

• Variant 2 (MAP-Elites in 6 dimensions + Bayesian optimiza-
tion, no use of priors): evaluates the contribution of initializ-
ing the Gaussian process with the performance predictions
of the behavior-performance map. In this variant, the Gaus-
sian process is initialized with a constant mean (the average
performance of the map: 0.24 m/s) at each location in the
behavior space and a constant variance (the average vari-
ance of the map’s performance: 0.005 m2/s2). As is custom-
ary, the ﬁrst few trials (here, 5) of the Bayesian optimization
process are selected randomly instead of letting the algo-
rithm choose those points, which is known to improve per-
formance.42

• Variant 3 (MAP-Elites in 6 dimensions + policy gradient):
evaluates the beneﬁt of Bayesian optimization compared to
a more classic, local search algorithm17,62; there is no obvious
way to use priors in policy gradient algorithms.

• Variant 4 (Bayesian optimization in the original parameter
space of 36 dimensions): evaluates the contribution of us-
ing a map in a lower-dimensional behavioral space. This
variant searches directly in the original 36-dimensional pa-
rameter space instead of reducing that space to the lower-
dimensional (six-dimensional) behavior space. Thus, in this
variant no map of behaviors is produced ahead of time: the
algorithm searches directly in the original, high-dimensional
space. This variant corresponds to one of the best algorithms
known to learn locomotion patterns32,42. In this variant, the
Gaussian process is initialized with a constant mean set to

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 20

zero and with a constant variance (0.002m2/s2). As de-
scribed above, the ﬁve ﬁrst trials are selected from pure ran-
dom search to prime the Bayesian optimization algorithm42.
• Variant 5 (Policy gradient in the original parameter space of
36 dimensions): a stochastic gradient descent in the original
parameter space62. This approach is a classic reinforcement
learning algorithm for locomotion17 and it is a baseline in
many papers32.

It was necessary to compare these variants in simulation be-
cause doing so on the physical robot would have required
months of experiments and would have repeatedly worn out or
broken the robot. We modiﬁed the simulator from the main ex-
periments (section 1.4: Simulator) to emulate 6 different possible
damage conditions, each of which involved removing a different
leg. For variants in which MAP-Elites creates a map (variants
1, 2 and 3), we used the same maps from the main experiments
(the eight independently generated maps, which were all gener-
ated with a simulation of the undamaged robot): In these cases,
we launched ten replicates of each variant for each of the eight
maps and each of the six damage conditions. There are there-
fore 10 × 8 × 6 = 480 replicates for each of those variants. For
the other variants (4 and 5), we replicated each experiment 80
times for each of the six damage conditions, which also led to
80 × 6 = 480 replicates per variant. In all these simulated ex-
periments, to roughly simulate the distribution of noisy odome-
try measurements on the real robot, the simulated performance
values were randomly perturbed with a multiplicative Gaussian
noise centered on 0.95 with a standard deviation of 0.1.

We analyze the fastest walking speed achieved with each vari-
ant after two different numbers of trials: the ﬁrst case is after 17
trials, which was the maximum number of iterations used by the
Intelligent Trial and Error Algorithm, and the second case is after
150 trials, which is approximately the number of trials used in
previous work62,32,42.

Results After 17 trials on the robot, Intelligent Trial and Error
signiﬁcantly outperforms all the variants (Extended Data Fig. 2b,
p < 10−67, Intelligent Trial and Error performance: 0.26 [0.20;
0.33] m/s), demonstrating that the three main components of the
algorithm are needed to quickly ﬁnd high-performing behaviors.
Among the investigated variants, the random search in the map
performs the best (Variant 1: 0.21 [0.16; 0.27] m/s), followed by
Bayesian optimization in the map (Variant 2: 0.20 [0.13; 0.25]
m/s), and policy gradient in the map (Variant 3: 0.13 [0; 0.23]
m/s). Variants that search directly in the parameter space did
not ﬁnd any working behavior (Variant 4, Bayesian optimiza-
tion: 0.04m/s, [0.01; 0.09]; Variant 5, policy gradient: 0.02 [0; 0.06]
m/s).

There are two reasons that random search performs better than
one might expect. First, the map only contains high-performing
solutions, which are the result of the intense search of the MAP-
Elites algorithm (40 million evaluations in simulation). The map
thus already contains high-performing gaits of nearly every pos-
sible type. Therefore, this variant is not testing random con-
trollers, but is randomly selecting high-performing solutions.
Second, Bayesian optimization and policy gradient are not de-
signed for such a low number of trials: without the priors on per-
formance predictions introduced in the Intelligent Trial and Er-
ror Algorithm, the Bayesian optimization process needs to learn
the overall shape of the search space to model it with a Gaussian
process. 17 trials is too low a number to effectively sample six di-
mensions (for a uniform sampling with only two possible values
in each dimension, 26 = 64 trials are needed; for ﬁve possible
values, 56 = 15, 625 samples are needed). As a consequence,
with this low number of trials, the Gaussian process that models
the performance function is not informed enough to effectively
guide the search. For the policy gradient algorithm, a gradient is
estimated by empirically measuring the partial derivative of the

performance function in each dimension. To do so, following62,
the policy gradient algorithm performs 15 trials at each iteration.
Consequently, when only 17 trials are allowed, it iterates only
once. In addition, policy gradient is a local optimization algo-
rithm that highly depends on the starting point (which is here
chosen randomly), as illustrated by the high variability in the
performance achieved with this variant (Extended Data Fig. 2b).
The issues faced by Bayesian optimization and policy gradi-
ent are exacerbated when the algorithms search directly in the
original, 36-dimensional parameter space instead of the lower-
dimensional (six-dimensional) behavior space of the map. As
mentioned previously, no working controller was found in the
two variants directly searching in this high-dimensional space.

Overall, the analysis after 17 trials shows that:
• The most critical component of the Intelligent Trial and Er-
ror Algorithm is the MAP-Elites algorithm, which reduces
the search space and produces a map of high-performing
behaviors in that space: p < 5 × 10−50 when comparing
variants searching in the behavior-performance map space
vs. variants that search in the original, higher-dimensional
space of motor parameters.

• Bayesian optimization critically improves the search, but
only when it is initialized with the performance obtained in
simulation during the behavior-performance map creation
step (with initialization: 0.26 [0.20; 0.33] m/s, without ini-
tialization: 0.20 [0.13; 0.25] m/s, p = 10−96).

To check whether these variants might perform better if allowed
the number of evaluations typically given to previous state-of-
the-art algorithms62,32,42, we continued the experiments until 150
trials on the robot were conducted (Extended Data Fig. 2c). Al-
though the results for all the variants improved, Intelligent Trial
and Error still outperforms all them (p < 10−94; Intelligent Trial
and Error: 0.31 [0.26; 0.37] m/s, random search: 0.26 [0.22; 0.30]
m/s, Bayesian optimization: 0.25 [0.18; 0.31] m/s, policy search:
0.23 [0.19, 0.29] m/s). These results are consistent with the previ-
ously published results62,32,42,17, which optimize in 4 to 10 dimen-
sions in a few hundred trials. Nevertheless, when MAP-Elites is
not used, i.e. when we run these algorithms in the original 36
dimensions for 150 evaluations, Bayesian optimization and pol-
icy gradient both perform much worse (Bayesian optimization:
0.08 [0.05; 0.12]; policy gradient: 0.06 [0.01; 0.12] m/s). These re-
sults shows that MAP-Elites is a powerful method to reduce the
dimensionality of a search space for learning algorithms, in addi-
tion to providing helpful priors about the search space that speed
up Bayesian optimization.

Overall, these additional experiments demonstrate that each
of the three main components of the Intelligent Trial and Error
Algorithm substantially improves performance. The results also
indicate that Intelligent Trial and Error signiﬁcantly outperforms
previous algorithms for both damage recovery63,12,64,65,66 and gait
learning67,62,68,48,69,32,61,42,17,49, and can therefore be considered the
state of the art.

4 Supplementary Experiments S3

Robustness to environmental changes

Methods The map creation algorithm (MAP-Elites) uses an un-
damaged robot on ﬂat terrain. The main experiments show that
this algorithm provides useful priors for damage recovery on a
ﬂat terrain. In these supplementary experiments, we evaluated,
in simulation, if the map created on ﬂat terrain also provides a
useful starting point for discovering gaits for sloped terrains.

We ﬁrst evaluated the effect slopes have on undamaged robots
(Extended Data Fig. 3a). We launched 10 replicates for each of
the eight maps and each one-degree increment between −20◦
and +20◦, for a total of 10 × 8 × 41 = 3280 experiments. As in

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 21

Supplementary Experiments S2, to roughly simulate the distribu-
tion of noisy odometry measurements on the real robot, we per-
turbed performance values with a multiplicative Gaussian noise
centered on 0.95 with a standard deviation of 0.1.

Results The results show that, when the slope is negative (de-
scending), the Intelligent Trial and Error approach ﬁnds fast gaits
in fewer than than 3 trials. For reference, a hand-designed, clas-
sic, tripod gait (section 1.4) falls on slopes below −15◦ degrees.
When the slope is positive (ascent), Intelligent Trial and Error
ﬁnds slower behaviors, as is expected, but even above 10◦ the
gait learned by Intelligent Trial and Error outperforms the ref-
erence gait on ﬂat ground. Overall, for every slope angle, the
controller found by Intelligent Trial and Error is faster than the
hand-designed reference controller.

We further evaluated damage recovery performance for these
same slopes with the same setup as Experiments S2 (6 damage
conditions). We launched 10 replicates for each damage condi-
tion, for 8 independently generated behavior-performance maps,
and each two-degree increment between −20◦ and +20◦ degrees.
There are therefore 480 replicates for each two-degree increment
between −20◦ and +20◦, for a total of 480 × 21 = 10080 experi-
ments.

Intelligent Trial and Error is not critically affected by variations
of slope between −10◦ and +10◦ (Extended Data Fig. 3b): for
these slopes, and for all 6 damage conditions, Intelligent Trial
and Error ﬁnds fast gaits (above 0.2 m/s) in less than 15 tests
on the robot despite the slope. As expected, it ﬁnds faster gaits
for negative slopes (descent) and slower gaits for positive slopes
(ascent). For slopes below −10◦ and above 10◦, the algorithm
performs worse and requires more trials. These results likely are
caused by the constraints placed on the controller and the lim-
ited sensors on the robot, rather than the inabilities of the algo-
rithm. Speciﬁcally, the controller was kept simple to make the sci-
ence clearer, more intuitive, and more reproducible. Those con-
straints, of course, prevent it from performing the more complex
behaviors necessary to deal with highly sloped terrain. For exam-
ple, the constraints prevent the robot from keeping its legs ver-
tical on sloped ground, which would substantially reduce slip-
page. Nevertheless, the median Intelligent Trial and Error com-
pensatory gait still outperforms the median performance of the
reference gait on all slope angles.

5 Supplementary Experiments S4

Comparison between MAP-Elites and Random
Sampling

Methods The MAP-Elites algorithm is a stochastic search algo-
rithm that attempts to ﬁll a discretized map with the highest-

performing solution at each point in the map. As explained in
the main text, each point in the map represents a different type
of behavior, as deﬁned by the behavioral dimension of the map.
MAP-Elites generates new candidate points by randomly select-
ing a location in the map, changing the parameters of the con-
troller that is stored there, and then saving that controller in the
appropriate map location if it is better than the current occupant
at that location. Intuitively, generating new candidate solutions
from the best solutions found so far should be better than gener-
ating a multitude of controllers randomly and then keeping the
best one found for each location in the map. In this section we
report on experiments that conﬁrm that intuition.

To understand the advantages of MAP-Elites over random
sampling, we compared the two algorithms by generating data
with the simulated hexapod. The experiments have the same vir-
tual robot, environment, controller, performance function, and
behavioral descriptors as in the main experiments (see Methods).
We analyzed the number of cells for which a solution is found (an
indication of the diversity of behavior types the algorithms gen-
erate), the average performance of behaviors in the map, and the
maximum performance discovered.

We replicated each experiment 8 times, each of which included

20 million evaluations on the simulated robot.

Results The results show that the MAP-Elites algorithm out-
performs random sampling on each of these measures (Extended
Data Fig. 10). After 20 million evaluations, about 13000 cells
(median: 12968, 5th & 95th percentiles: [12892; 13018]) are ﬁlled
by MAP-Elites (about 83% percent of the map), whereas random
sampling only ﬁlled approximately 8600 (8624 [8566; 8641]) cells
(about 55% percent of the map) (Extended Data Fig. 10a). The
difference between the two algorithms is large and appears early
(Extended Data Fig. 10a); after only 1 million evaluations, MAP-
Elites ﬁlled 10670 [10511; 10775] cells (68% of the map), whereas
random sampling ﬁlled 5928 [5882; 5966] cells (38% of the map).
The solutions discovered by MAP-Elites are not only more nu-
merous, but also outperform those found by random sampling
(Extended Data Fig. 10b): with MAP-Elites, after 20 million eval-
uations the average performance of ﬁlled cells is 0.22 [0.22; 0.23]
m/s, whereas it is 0.06 [0.06; 0.06] m/s with random sampling,
which is similar to the performance obtained with the reference
controller on a damaged robot (Fig. 3). These two results demon-
strate that MAP-Elites is a much better algorithm than random
sampling to ﬁnd a map of the diverse, “elite” performers in a
search space.

In addition, MAP-Elites is a better optimization algorithm, as
measured by the performance of the best single solution pro-
duced. The performance of the best solution in the map after
20 million evaluations is 0.40 [0.39;0.41] m/s with MAP-Elites,
compared to 0.21 [0.20; 0.22] m/s with random sampling.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 22

Extended Data Figure 10 | Comparing MAP-Elites and random sampling for generating behavior-performance maps. (a) The number of points
in the map for which a behavior is discovered. (b) The mean performance of the behaviors in the map. (c) The maximum performance of the
behaviors in the map. For all these ﬁgures, the middle lines represent medians over 8 independently generated maps and the shaded regions extend
to the 25th and 75th percentiles, even for (a) and (b), where the variance of the distribution is so small that it is difﬁcult to see. See Supplementary
Experiment S4 for methods and analysis.

where ΘT (k), ΨT (k) and ΦT (k) denote the pitch, roll and
yaw angles, respectively, of the robot torso (hence T ) at the
end of interval k, and K denotes the number of 15ms in-
tervals during the 5 seconds of simulated movement (here,
K = 5s/0.015s ≈ 334). The unit step function U (·) returns
1 if its argument exceeds 0, and returns 0 otherwise. To dis-
count for insigniﬁcant motion around 0 rad, orientation an-
gles are only deﬁned as positive if they exceed 0.5% of π rad.
Similarly, orientation angles are only deﬁned as negative if
they are less than −0.5% of π rad.

3. Displacement (6-dimensional): This behavioral descriptor
characterizes changes in the postion of the robot during
It is measured as the proportion of 15ms inter-
walking.
vals that the robot is positively or negatively displaced along
each of the x, y, and z axes:

x =











(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)

1
K
1
K
1
K
1
K
1
K
1
K

k U (∆x(k) − 0.001)
k U (−∆x(k) − 0.001)
k U (∆y(k) − 0.001)
k U (−∆y(k) − 0.001)
k U (∆z(k) − 0.001)
k U (−∆z(k) − 0.001)











(15)

where [∆x(k), ∆y(k), ∆z(k)] denote the linear displacement
in meters of the robot during interval k, and K denotes the
number of 15ms intervals during 5 seconds of simulated
movement (here, K = 5s/0.015s ≈ 334). The unit step func-
tion U (·) returns a value of 1 if its argument exceeds 0, and
returns a value of 0 otherwise. To ignore insigniﬁcant mo-
tion, linear displacements are deﬁned to be positive if they
exceed 1mm, and are deﬁned to be negative if they are less
than −1mm.

6 Supplementary Experiments S5

Alternative behavioral descriptors

Methods To create a map with MAP-Elites, one has to deﬁne
the dimensions of the behavioral space, i.e. the behavioral de-
scriptors. The main experiments show that using a predeﬁned
behavioral descriptor (the proportion of time that each leg of a
hexapod robot is in contact with the ground, i.e. the duty factor)
creates a map that provides useful priors for damage recovery.

This section describes how we tested (in simulation) how per-
formance is affected by alternative behavioral descriptors, in-
cluding descriptors that have a different number of dimensions.
We also evaluated how performance is affected if the behavioral
descriptors are randomly selected from a large list of potential
descriptors. This test simulates the algorithm’s performance if
the behavioral descriptors are chosen without insight into the
problem domain.

The behavioral descriptors we tested are as follows:
1. Duty factor (6-dimensional): This descriptor is the default
one from the main experiment. It corresponds to the pro-
portion of time each leg is in contact with the ground:







x =

(cid:80)

t C1(t)
numTimesteps

...

(cid:80)

t C6(t)
numTimesteps







where Ci(t) denotes the Boolean value of whether leg i is in
contact with the ground at time t (1: contact, 0: no contact).
2. Orientation (6-dimensional): This behavioral descriptor
characterizes changes in the angular position of the robot
during walking, measured as the proportion of 15ms inter-
vals that each of the pitch, roll and yaw angles of the robot
frame are positive (three dimensions) and negative (three
additional dimensions):

x =











1
K
1
K
1
K
1
K
1
K
1
K

(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)

k U (ΘT (k) − 0.005π)
k U (−ΘT (k) − 0.005π)
k U (ΨT (k) − 0.005π)
k U (−ΨT (k) − 0.005π)
k U (ΦT (k) − 0.005π)
k U (−ΦT (k) − 0.005π)











(13)

(14)

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 23

4. Total energy expended per leg (6-dimensional): This be-
havioral descriptor captures the total amount of energy ex-
pended to move each leg during 5 seconds of movement:







E1
ME

...







x =

E6
ME
where Ei denotes the energy utilized by leg i of the robot
during 5 seconds of simulated movement, measured in
N.m.rad. ME is the maximum amount of energy available
according to the servo model of the simulator, which for 5
seconds is 100 N.m.rad.

5. Relative energy expended per leg (6-dimensional): This be-
havioral descriptor captures the amount of energy expended
to move each leg relative to the energy expended by all the
legs during 5 seconds of simulated movement:







x =

(cid:80)

E1
i=1..6 Ei

...

(cid:80)

E6
i=1..6 Ei







(17)

where Ei denotes the energy utilized by leg i of the robot
during 5 seconds of simulated movement, measured in
N.m.rad.

6. Deviation (3-dimensional): This descriptor captures the
range of deviation of the center of the robot frame versus
the expected location of the robot if it traveled in a straight
line at a constant speed.

(cid:18)

x =

0.95

max
t

(y(t)−

yﬁnal

0.2
5 ×t)−min
0.2

t

(y(t)−

(cid:19)

yﬁnal

5 ×t)

(18)










(cid:18)

0.95

max
t

(x(t))−min

(x(t))

(cid:19)

(cid:19)

t

t

(cid:18)

0.95

max
t

(z(t))−min

(z(t))

0.2










where [x(t), y(t), z(t)] denote the position of robot’s center
at time t, and [xﬁnal, yﬁnal, zﬁnal] denote its ﬁnal position after
5 seconds.
The robot’s task is to move along the y-axis. Its starting po-
sition is (0,0,0). The deviation along the x and z axes is com-
puted as the maximum difference in the robot’s position in
those dimensions at any point during 5 seconds. For the y
axis, yﬁnal
corresponds to the average speed of the robot (the
5
distance covered divided by total time), therefore yﬁnal
5 × t is
the expected position at timestep t if the robot was moving
at constant speed. The deviation from the y axis is computed
with respect to this “theoretical” position.
To obtain values in the range [0,1], the ﬁnal behavioral de-
scriptors are multiplied by 0.95 and then divided by 20 cm
(these values were determined empirically).

7. Total ground reaction force per leg (6-dimensional): This be-
havioral descriptor corresponds to the amount of force each
leg applies to the ground, measured as a fraction the to-
tal possible amount of force that a leg could apply to the
ground. Speciﬁcally, the measurement is

x =













F1
MF

...

F6
MF

(19)

where Fi denotes the ground reaction force (GRF) each leg
i generates, averaged over 5 seconds of simulated move-
ment. MF is the maximum such force that each leg can ap-
ply, which is 10N.

(16)

8. Relative ground reaction force per leg (6-dimensional): This
behavioral descriptor corresponds to the amount of force
each leg applies to the ground, relative to that of all the legs:







x =

(cid:80)

F1
i=1..6 Fi

...

(cid:80)

F6
i=1..6 Fi







x =















(cid:80)

1 (t)

t ΘL
π×N1
...
t ΘL
π×N6

(cid:80)

6 (t)

x =








(cid:80)

1 (t)

t ΨL
π×N1
...
t ΨL
π×N6

(cid:80)

6 (t)








where Fi denotes the ground reaction force (GRF) each leg i
generates, averaged over 5 seconds of simulated movement.
9. Lower-leg pitch angle (6-dimensional): This descriptor cap-
tures the pitch angle for the lower-leg with respect to the
ground (in a global coordinate frame), averaged over 5 sec-
onds:

where ΘL
i (t) is the pitch angle of lower-leg i (hence the L in
ΘL
i ) when it is in contact with the ground at time t, and Ni is
the number of time-steps for which lower-leg i touches the
ground. The foot pitch angles are in range [0, π] (as the leg
can not penetrate the ground) and normalized to [0, 1].
10. Lower-leg roll angle (6-dimensional): This descriptor cap-
tures the roll angle for the lower-leg with respect to the
ground (in a global coordinate frame), averaged over 5 sec-
onds:

where ΨL
i (t) is the roll angle of lower-leg i (hence L in ΨL
i )
when it is in contact with the ground at time t, and Ni is
the number of time-steps for which lower-leg i touches the
ground. The foot roll angles are in range [0, π] (as the leg can
not penetrate the ground) and normalized to [0, 1].

11. Lower-leg yaw angle (6-dimensional): This descriptor cap-
tures the yaw angle for the lower-leg with respect to the
ground (in a global coordinate frame), averaged over 5 sec-
onds:

x =








(cid:80)

1 (t)+π

t ΦL
2π×N1
...
t ΦL
2π×N6

(cid:80)

6 (t)+π








where ΦL
i (t) is the yaw angle of lower-leg i (hence L in ΦL
i )
when it is in contact with the ground at time t,and Ni is
the number of time-steps for which lower-leg i touches the
ground. The foot yaw angles are in range [−π, π] and are
normalized to [0, 1].

(20)

(21)

(22)

(23)

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 24

12. Random (6-dimensional): The random behavioral descrip-
tor differs from the other intentionally chosen descriptors
in that it does not consist of one type of knowledge, but
is instead randomly selected as a subset of variables from
the previously described 11 behavioral descriptors. This de-
scriptor is intended to simulate a situation in which one has
little expectation for which behavioral descriptor will per-
form well, so one quickly picks a few different descriptor
dimensions without consideration or experimentation. In-
stead of generating one such list in this fashion, we ran-
domly sample from a large set to ﬁnd the average perfor-
mance of this approach over many different possible choices.
For the random descriptor, each of the 6-dimensions is se-
lected at random (without replacement) from the 1×3+10×
6 = 63 available behavior descriptor dimensions described
in the previous 11 descriptors (1 of the above descriptors is
three-dimensional and the other 10 are six-dimensional):

x =











R1
...
R6

(24)

where Ri denotes the ith dimension of the descriptor, ran-
domly selected uniformly and without replacement from the
63 available dimensions in behavior descriptors 1-11.

It was necessary to compare these behavioral descriptors in
simulation because doing so on the physical robot would have re-
quired months of experiments and would have repeatedly worn
out or broken the robot. We modiﬁed the simulator from the
main experiments (section 1.4) to emulate 6 different possible
damage conditions, each of which involved removing a differ-
ent leg. The MAP-Elites algorithm, run for 3 million iterations,
was used to create the behavior-performance maps for each of
the behavioral descriptors (using a simulation of the undamaged
robot). During the generation of the behavior-performance maps,
the behaviors were stored in the map’s cells by discretizing each
dimension of the behavioral descriptor space with these ﬁve val-
ues: {0, 0.25, 0.5, 0.75, 1} for the 6-dimensional behavioral de-
scriptors, and with twenty equidistant values between [0, 1] for
the 3-dimensional behavioral descriptor. During the adaptation
phase, the behaviors were used with their actual values and thus
not discretized.

We independently generated eight maps for each of the 11
intentionally chosen behavioral descriptors. Twenty indepen-
dently generated maps were generated for the random behav-
ioral descriptor. We launched ten replicates of each descriptor for
each of the maps (eight for intentionally chosen behavioral de-
scriptors and twenty for random behavioral descriptor) and each
of the six damage conditions. There are therefore 10×8×6 = 480
replicates for each of the intentionally chosen descriptors, and
10 × 20 × 6 = 1200 replicates for the random descriptor.
In
all these simulated experiments, to roughly simulate the distri-
bution of noisy odometry measurements on the real robot, the
simulated performance values were randomly perturbed with a
multiplicative Gaussian noise centered on 0.95 with a standard
deviation of 0.1.

We analyze the fastest walking speed achieved with each be-
havioral descriptor after two different numbers of trials: the ﬁrst
case is after 17 trials, and the second case is after 150 trials.

Results The following results include 17 trials on the simulated
robot, which was the maximum number of trials required for In-
telligent Trial and Error to ﬁnd a compensatory gait in the Sup-
plementary Experiment S2. The post-adaptation performance

achieved with our alternative, intentionally chosen behavioral
descriptors (numbers 2-11) was similar to the original duty factor
behavioral descriptor (number 1) (Extended Data Fig. 4a). All 11
alternative, intentionally chosen descriptors (numbers 2-11) led
to a median performance within 17% of the duty factor descrip-
tor (performance: 0.241 [0.19; 0.29] m/s). The difference in per-
formance was effectively nonexistent with the deviation descrip-
tor (0.241 [0.14; 0.31] m/s), the total GRF descriptor (0.237 [0.15;
0.30] m/s), and the lower-leg roll angle descriptor (0.235 [0.14;
0.31] m/s). The lowest performance was discovered with the rel-
ative GRF descriptor (16.7% lower than the duty factor descrip-
tor, 0.204 [0.08; 0.31] m/s).
In terms of statistical signiﬁcance,
the performance achieved with the duty factor descriptor was no
different from the deviation (p = 0.53) and total GRF (p = 0.29)
descriptors. With all the remaining descriptors, the difference in
performance was statistically signiﬁcant (p < 10−3), but it did
not exceed 0.04m/s. Additionally, the compensatory behaviors
discovered with all our 11 alternative, intentionally chosen de-
scriptors were always faster than the reference gait for all damage
conditions.

To check whether our alternative, intentionally chosen behav-
ioral descriptors lead to better performance if allowed a higher
number of evaluations, we extended the experiments to 150 tri-
als on the robot (Extended Data Fig. 4b). After 150 trials, the dif-
ference in performance between the duty factor behavioral de-
scriptor (0.277 [0.24; 0.34] m/s) and our alternative behavioral
descriptors was further reduced. For all but three alternative,
intentionally chosen descriptors (displacement, total GRF and
lower-leg yaw angle), the median performance was within 4% of
the duty factor descriptor. The difference in performance was at
±3.6% with the orientation (0.274 [0.22; 0.32] m/s), total energy
(0.274 [0.19; 0.33] m/s), relative energy (0.273 [0.20; 0.32] m/s),
deviation (0.287 [0.21; 0.34] m/s), relative GRF (0.266 [0.15; 0.35]
m/s), lower-leg pitch angle (0.271 [0.21; 0.34] m/s) and lower-
leg roll angle (0.268 [0.17; 0.34] m/s) descriptors.
In the three
remaining behavioral descriptors, displacement, total GRF, and
lower-leg yaw angle, the performance was 0.264 [0.18; 0.32] m/s,
0.299 [0.25; 0.35] m/s and 0.255 [0.18; 0.32] m/s, respectively (dif-
ference at ±7.8% of duty factor descriptor in all three cases). In
terms of statistical signiﬁcance, the performance achieved with
the duty factor descriptor was barely statistically signiﬁcantly
different from the deviation descriptor (p = 0.041). In all the re-
maining descriptors, the performance difference was statistically
signiﬁcant (p < 10−2), but no larger than 0.02m/s.

Our random behavioral descriptor also performed similarly to
the duty factor descriptor. After 17 trials, the performance of
M-BOA with the maps generated by the random descriptor was
0.232 [0.14; 0.30] m/s (4.2% lower than the duty factor descrip-
tor performance). While the difference is statistically signiﬁcant
(p < 10−3), the difference in performance itself was negligible at
0.01m/s. This difference in performance was further reduced to
3.6% after 150 trials (random descriptor performance: 0.274 [0.21;
0.34] m/s, duty factor description performance: 0.277 [0.24; 0.34]
m/s, p = 0.002). Moreover, as with the intentionally chosen be-
havioral descriptors, the compensatory behavior discovered with
the random descriptor was also faster than the reference gait.

These experiments show that the selection of the behavioral
dimensions is not critical to get good results. Indeed, all tested
behavioral descriptors, even those randomly generated, perform
well (median > 0.20 m/s after 17 trials). On the other hand, if
the robot’s designers have some prior knowledge about which
dimensions of variation are likely to reveal different types of be-
haviors, the algorithm can beneﬁt from this knowledge to further
improve results (as with the duty factor descriptor).

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 25

7 Caption for Supplementary Videos

Video S1

This video can be viewed at: https://youtu.be/T-c17RKh3uE
Damage Recovery in Robots via Intelligent Trial and Error.
The video shows the Intelligent Trial and Error Algorithm in ac-
tion with the two robots introduced in this paper: the hexapod
robot and the 8 degrees of freedom robotic arm (Fig. 3). The
video shows several examples of the different types of behav-
iors that are produced during the behavior-performance map cre-
ation step, from classic hexapod gaits to more unexpected forms
of locomotion. Then, it shows how the hexapod robot uses that
behavior-performance map to deal with a leg that has lost power
(Fig. 3a:C3). Finally, the video illustrates how the Intelligent Trial
and Error Algorithm can be applied to the second robot and to
different damage conditions.

Video S2

This video can be viewed at: http://youtu.be/ycLspV5lXK8
A Behavior-Performance Map Containing Many Different
Types of Walking Gaits. In the behavior-performance map cre-
ation step, the MAP-Elites algorithm produces a collection of dif-
ferent types of walking gaits. The video shows several examples
of the different types of behaviors that are produced, from classic
hexapod gaits to more unexpected forms of locomotion.

Supplementary References

30. A. E. Eiben and J. E. Smith. Introduction to evolutionary computing. Springer,

31.

2003.
J.-B. Mouret and J. Clune. “Illuminating search spaces by mapping elites”.
In: arXiv preprint arXiv:1504.04909 (2015).

32. D. J. Lizotte, T. Wang, M. H. Bowling, and D. Schuurmans. “Automatic Gait
Optimization with Gaussian Process Regression.” In: Proceedings of the the
International Joint Conference on Artiﬁcial Intelligence (IJCAI). Vol. 7. 2007,
pp. 944–949.

34.

33. E. Brochu, V. M. Cora, and N. De Freitas. “A tutorial on Bayesian optimization
of expensive cost functions, with application to active user modeling and hi-
erarchical reinforcement learning”. In: arXiv preprint arXiv:1012.2599 (2010).
J. Snoek, H. Larochelle, and R. P. Adams. “Practical Bayesian Optimization
of Machine Learning Algorithms”. In: Advances in Neural Information Pro-
cessing Systems 25 (NIPS). 2012, pp. 2951–2959.
T. L. Grifﬁths, C. Lucas, J. Williams, and M. L. Kalish. “Modeling human func-
tion learning with Gaussian processes”. In: Advances in Neural Information
Processing Systems 21 (NIPS). 2009, pp. 553–560.

35.

36. A. J. Booker, J. E. Dennis Jr, P. D. Frank, D. B. Seraﬁni, V. Torczon, and M.
W. Trosset. “A rigorous framework for optimization of expensive functions by
surrogates”. In: Structural optimization 17.1 (1999), pp. 1–13.

39.

37. A. I. J. Forrester and A. J. Keane. “Recent advances in surrogate-based op-
timization”. In: Progress in Aerospace Sciences 45.1 (2009), pp. 50–79.
38. Y Jin. “Surrogate-assisted evolutionary computation: Recent advances and
future challenges”. In: Swarm and Evolutionary Computation 1.2 (2011),
pp. 61–70.
T. W. Simpson, T. M. Mauery, J. J. Korte, and F. Mistree. “Comparison of re-
sponse surface and kriging models for multidisciplinary design optimization”.
In: American Institute of Aeronautics and Astronautics 98.7 (1998), pp. 1–16.
40. D. R. Jones, M. Schonlau, and W. J. Welch. “Efﬁcient global optimization
of expensive black-box functions”. In: Journal of Global optimization 13.4
(1998), pp. 455–492.
J. Sacks, W. J. Welch, T. J. Mitchell, H. P. Wynn, et al. “Design and analysis
of computer experiments”. In: Statistical science 4.4 (1989), pp. 409–423.

41.

42. R. Calandra, A. Seyfarth, J. Peters, and M. P. Deisenroth. “An experimen-
tal comparison of Bayesian optimization for bipedal
locomotion”. In: Pro-
ceedings of the IEEE International Conference on Robotics and Automation
(ICRA). 2014.

43. B. Matérn et al. “Spatial variation. Stochastic models and their application
to some problems in forest surveys and other sampling investigations.” In:
Meddelanden fran statens Skogsforskningsinstitut 49.5 (1960).

44. M. L. Stein. Interpolation of spatial data: some theory for kriging. Springer,

1999.

45. A. V. Fiacco and G. P. McCormick. Nonlinear programming: sequential un-

46.

constrained minimization techniques. Vol. 4. Siam, 1990.
I. Dryanovski, R. G. Valenti, and J. Xiao. “Fast visual odometry and mapping
from rgb-d data”. In: Proceedings of the IEEE International Conference on
Robotics and Automation (ICRA). IEEE. 2013, pp. 2305–2310.

49.

47. M. Quigley, K. Conley, B. P. Gerkey, J. Faust, T. Foote, J. Leibs, R. Wheeler,
and A. Y. Ng. “ROS: an open-source Robot Operating System”. In: Proceed-
ings of ICRA’s workshop on Open Source Software. 2009.

48. A. Sproewitz, R. Moeckel, J. Maye, and A. Ijspeert. “Learning to move in
modular robots using central pattern generators and online optimization”. In:
The International Journal of Robotics Research 27.3-4 (2008), pp. 423–443.
J. Yosinski, J. Clune, D. Hidalgo, S. Nguyen, J. Zagal, and H. Lipson. “Evolv-
ing Robot Gaits in Hardware: the HyperNEAT Generative Encoding Vs. Pa-
rameter Optimization”. In: Proceedings of ECAL (2011), pp. 890–897.
J. Clune, K. Stanley, R. Pennock, and C. Ofria. “On the performance of indi-
rect encoding across the continuum of regularity”. In: IEEE Transactions on
Evolutionary Computation 15.3 (2011), pp. 346–367.
J. Clune, B. Beckmann, C. Ofria, and R. Pennock. “Evolving coordinated
quadruped gaits with the HyperNEAT generative encoding”. In: Proceedings
of the IEEE Congress on Evolutionary Computation. 2009, pp. 2764–2771.

51.

50.

52. S. Lee, J. Yosinski, K. Glette, H. Lipson, and J. Clune. “Evolving gaits for
physical robots with the HyperNEAT generative encoding: the beneﬁts of sim-
ulation.” In: Applications of Evolutionary Computing. Springer, 2013.
53. D. Wilson. “Insect walking”. In: Annual Review of Entomology 11.1 (1966),

pp. 103–122.

54. U. Saranli, M. Buehler, and D. Koditschek. “Rhex: A simple and highly mo-
bile hexapod robot”. In: The International Journal of Robotics Research 20.7
(2001), pp. 616–631.
J. Schmitz, J. Dean, T. Kindermann, M. Schumm, and H. Cruse. “A biolog-
ically inspired controller for hexapod walking: simple solutions by exploiting
physical properties”. In: The biological bulletin 200.2 (2001), pp. 195–200.

55.

56. X. Ding, Z. Wang, A. Rovetta, and J. Zhu. “Locomotion analysis of hexa-
pod robot”. In: Proceedings of Conference on Climbing and Walking Robots
(CLAWAR) (2010), pp. 291–310.

57. S. Steingrube, M. Timme, F. Wörgötter, and P. Manoonpong. “Self-organized
adaptation of a simple neural circuit enables complex robot behaviour”. In:
Nature Physics 6.3 (2010), pp. 224–230.
F. Delcomyn. “The Locomotion of the Cockroach Pariplaneta americana”. In:
Journal of Experimental Biology 54.2 (1971), pp. 443–452.

58.

59. S. Thrun, W. Burgard, D. Fox, et al. Probabilistic robotics. MIT press Cam-

bridge, 2005.

60. M. G. Dissanayake, P. Newman, S. Clark, H. F. Durrant-Whyte, and M.
Csorba. “A solution to the simultaneous localization and map building
(SLAM) problem”. In: IEEE Transactions on Robotics and Automation 17.3
(2001), pp. 229–241.

61. M. Tesch, J. Schneider, and H. Choset. “Using response surfaces and ex-
pected improvement to optimize snake robot gait parameters”. In: Proceed-
ings of the IEEE/RSJ International Conference on Intelligent Robots and Sys-
tems (IROS). IEEE. 2011, pp. 1069–1074.

62. N. Kohl and P. Stone. “Policy gradient reinforcement

learning for fast
quadrupedal locomotion”. In: Proceedings of the IEEE International Confer-
ence on Robotics and Automation (ICRA). Vol. 3. IEEE. 2004, pp. 2619–
2624.

63. M. S. Erden and K. Leblebicio ˘glu. “Free gait generation with reinforcement
learning for a six-legged robot”. In: Robotics and Autonomous Systems 56.3
(2008), pp. 199–212.

64. D. J. Christensen, J. C. Larsen, and K. Stoy. “Fault-tolerant gait learning and
morphology optimization of a polymorphic walking robot”. In: Evolving Sys-
tems 5 (2014), pp. 21–32.

65. S. Mahdavi and P. Bentley. “Innately adaptive robotics through embodied

evolution”. In: Autonomous Robots 20.2 (2006), pp. 149–163.

66. S. Koos, A. Cully, and J.-B. Mouret. “Fast damage recovery in robotics with
the T-resilience algorithm”. In: The International Journal of Robotics Re-
search 32.14 (2013), pp. 1700–1723.

67. G. Hornby, S. Takamura, T. Yamamoto, and M. Fujita. “Autonomous evolu-
tion of dynamic gaits with two quadruped robots”. In: IEEE Transactions on
Robotics 21.3 (2005), pp. 402–410.
T. Barfoot, E. Earon, and G. D’Eleuterio. “Experiments in learning distributed
control for a hexapod robot”. In: Robotics and Autonomous Systems 54.10
(2006), pp. 864–872.

68.

69. S. Koos, J.-B. Mouret, and S. Doncieux. “The transferability approach: Cross-
ing the reality gap in evolutionary robotics”. In: IEEE Transactions on Evolu-
tionary Computation 17.1 (2013), pp. 122–145.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 26

This manuscript is the pre-submission manuscript provided by the authors.
For the ﬁnal, post-review version, please see: http://dx.doi.org/10.1038/nature14422

Robots that can adapt like animals

Antoine Cully,1,2 Jeff Clune,6 Danesh Tarapore,1,2 Jean-Baptiste Mouret1−5,∗

5
1
0
2
 
y
a
M
 
7
2
 
 
]

O
R
.
s
c
[
 
 
4
v
1
0
5
3
.
7
0
4
1
:
v
i
X
r
a

As robots leave the controlled environments of factories to
autonomously function in more complex, natural environ-
ments1,2,3, they will have to respond to the inevitable fact that
they will become damaged4,5. However, while animals can
quickly adapt to a wide variety of injuries, current robots can-
not “think outside the box” to ﬁnd a compensatory behavior
when damaged:
they are limited to their pre-speciﬁed self-
sensing abilities, can diagnose only anticipated failure modes6,
and require a pre-programmed contingency plan for every type
of potential damage, an impracticality for complex robots4,5.
Here we introduce an intelligent trial and error algorithm that
allows robots to adapt to damage in less than two minutes,
without requiring self-diagnosis or pre-speciﬁed contingency
plans. Before deployment, a robot exploits a novel algorithm
to create a detailed map of the space of high-performing behav-
iors: This map represents the robot’s intuitions about what be-
haviors it can perform and their value. If the robot is damaged,
it uses these intuitions to guide a trial-and-error learning algo-
rithm that conducts intelligent experiments to rapidly discover
a compensatory behavior that works in spite of the damage. Ex-
periments reveal successful adaptations for a legged robot in-
jured in ﬁve different ways, including damaged, broken, and
missing legs, and for a robotic arm with joints broken in 14
different ways. This new technique will enable more robust,
effective, autonomous robots, and suggests principles that ani-
mals may use to adapt to injury.

Robots have transformed the economics of many industries,
most notably manufacturing7, and have the power to deliver
tremendous beneﬁts to society, such as in search and rescue8,
disaster response9, health care3, and transportation10. They are
also invaluable tools for scientiﬁc exploration, whether of distant
planets1,4 or deep oceans2. A major obstacle to their widespread
adoption in more complex environments outside of factories is
their fragility4,5: Robots presently pale in comparison to natural
animals in their ability to invent compensatory behaviors after an
injury (Fig. 1A).

Current damage recovery in robots typically involves two
phases: self-diagnosis, and then selecting the best, pre-designed
contingency plan11,12,13,14. Such self-diagnosing robots are expen-
sive, because self-monitoring sensors are expensive, and are difﬁ-
cult to design, because robot engineers cannot foresee every pos-
sible situation: this approach often fails either because the diag-
nosis is incorrect12,13 or because an appropriate contingency plan
is not provided14.

Injured animals respond differently: they learn by trial and
learning which
error how to compensate for damage (e.g.
limp minimizes pain)15,16. Similarly, trial-and-error learning al-
gorithms could allow robots to creatively discover compensatory
behaviors without being limited to their designers’ assumptions
about how damage may occur and how to compensate for each
damage type. However, state-of-the-art learning algorithms are
impractical because of the “curse of dimensionality”17: the fastest

1 Sorbonne Universités, UPMC Univ Paris 06, UMR 7222, ISIR, F-75005, Paris
2 CNRS, UMR 7222, ISIR, F-75005, Paris, France
3 Inria, Villers-lès-Nancy, F-54600, France
4 CNRS, Loria, UMR 7503, Vandœuvre-lès-Nancy, F-54500, France
5 Université de Lorraine, Loria, UMR 7503, Vandœuvre-lès-Nancy, F-54500,
France
6 University of Wyoming, Laramie, WY, USA
∗ Corresponding author: jean-baptiste.mouret@inria.fr

tun-
algorithms constrain the search to a few behaviors (e.g.
ing only 2 parameters, requiring 5-10 minutes) or require human
demonstrations17. Algorithms without these limitations take sev-
eral hours17. Damage recovery would be much more practical
and effective if robots adapted as creatively and quickly as an-
imals (e.g.
in minutes) and without expensive self-diagnosing
sensors.

Here, we show that rapid adaptation can be achieved by guid-
ing an intelligent trial-and-error learning algorithm with an auto-
matically generated, pre-computed, behavior-performance map
that predicts the performance of thousands of different behaviors
(Supplementary Video S1). The key insight is that, whereas cur-
rent learning algorithms either start with no knowledge of the
search space17 or with minimal knowledge from a few human
demonstrations17,18, animals better understand the space of pos-
sible behaviors and their value from previous experience19, en-
abling injured animals to intelligently select tests that validate or
invalidate whole families of promising compensatory behaviors.
We have robots store knowledge from previous experience in
the form of a map of the behavior-performance space. Guided
by this map, a damaged robot tries different types of behaviors
that are predicted to perform well and, as tests are conducted, up-
dates its estimates of the performance of those types of behaviors.
The process ends when the robot predicts that the most effective
behavior has already been discovered. The result is a robot that
quickly discovers a way to compensate for damage (e.g. Fig. 1C)
without a detailed mechanistic understanding of its cause, as oc-
curs with animals. We call this approach “Intelligent Trial and
Error” (Fig. 1D).

The behavior-performance map is created with a novel algo-
rithm and a simulation of the robot, which either can be a stan-
dard physics simulator or can be automatically discovered12. The
robot’s designers only have to describe the dimensions of the
space of possible behaviors and a performance measure. For
instance, walking gaits could be described by how much each
leg is involved in a gait (a behavioral measure) and speed (a
performance measure). For grasping, performance could be the
amount of surface contact, and it has been demonstrated that 90%
of effective poses for the 21-degree-of-freedom human hand can
be captured by a 3-dimensional behavioral space20. To ﬁll in the
behavior-performance map, an optimization algorithm simulta-
neously searches for a high-performing solution at each point in
the behavioral space (Fig. 2A,B and Extended Data Fig. 1). This
step requires simulating millions of behaviors, but needs to be
performed only once per robot design before deployment (Meth-
ods).

A low conﬁdence is assigned to the predicted performance
of behaviors stored in this behavior-performance map because
they have not been tried in reality (Fig. 2B and Extended Data
Fig. 1). During the robot’s mission, if it senses a performance
drop, it selects the most promising behavior from the behavior-
performance map, tests it, and measures its performance. The
robot subsequently updates its prediction for that behavior and
nearby behaviors, assigns high conﬁdence to these predictions
(Fig. 2C and Extended Data Fig. 1), and continues the selec-
tion/test/update process until it ﬁnds a satisfactory compen-
satory behavior (Fig. 2D and Extended Data Fig. 1).

All of these ideas are technically captured via a Gaussian
process model21, which approximates the performance function

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 1

Figure 1| With Intelligent Trial and Error, robots, like animals, can quickly adapt to recover from damage. (A) Most animals can ﬁnd a compen-
satory behavior after an injury. Without relying on predeﬁned compensatory behaviors, they learn how to avoid behaviors that are painful or no longer
effective. (B) An undamaged, hexapod robot. (C) One type of damage the hexapod may have to cope with (broken leg). (D) After damage occurs, in
this case making the robot unable to walk straight, damage recovery via Intelligent Trial and Error begins. The robot tests different types of behaviors
from an automatically generated map of the behavior-performance space. After each test, the robot updates its predictions of which behaviors will
perform well despite the damage. This way, the robot rapidly discovers an effective compensatory behavior.

with already acquired data, and a Bayesian optimization proce-
dure22,23, which exploits this model to search for the maximum
of the performance function (Methods). The robot selects which
behaviors to test by maximizing an information acquisition func-
tion that balances exploration (selecting points whose perfor-
mance is uncertain) and exploitation (selecting points whose per-
formance is expected to be high) (Methods). The selected behav-
ior is tested on the physical robot and the actual performance is
recorded. The algorithm updates the expected performance of
the tested behavior and lowers the uncertainty about it. These
updates are propagated to neighboring solutions in the behav-
ioral space by updating the Gaussian process (Methods). These
updated performance and conﬁdence distributions affect which
behavior is tested next. This select-test-update loop repeats un-
til the robot ﬁnds a behavior whose measured performance is
greater than 90% of the best performance predicted for any be-
havior in the behavior-performance map (Methods).

We ﬁrst test our algorithm on a hexapod robot that needs to
walk as fast as possible (Fig. 1B, D). The robot has 18 motors, an
onboard computer, and a depth camera that allows the robot to
estimate its walking speed (Supplementary Methods). The gait
is parametrized by 36 real-valued parameters that describe the
amplitude of oscillation, phase shift, and duty cycle for each joint
(Supplementary Methods). The behavior space is 6-dimensional,
where each dimension is the proportion of time the ith leg spends
in contact with the ground (i.e. the duty factor)7 (Supplementary
Methods).

The created behavior-performance map contains approxi-
mately 13,000 different gaits (Supplementary Video S2 shows ex-
amples). We tested our robot in six different conditions: undam-
aged (Fig. 3A:C1), four different structural failures (Fig. 3A:C2-
C5), and a temporary leg repair (Fig. 3A:C6). We compare
the walking speed of resultant gaits with a widely-used, classic,
hand-designed tripod gait7 (Supplementary Methods). For each
of the 6 damage conditions, we ran our adaptation step 5 times
for each of 8 independently generated behavior-performance
maps (with the default “duty factor” behavioral description),
leading to 6 × 5 × 8 = 240 experiments in total. We also ran our
adaptation step 5 times on 8 independently generated behavior-
performance maps deﬁned by an alternate behavioral descrip-

tion (“body orientation”, see Supplementary Methods) on two
damage conditions (Fig. 3B-C), leading to 2 × 5 × 8 = 80 addi-
tional experiments.

When the robot is undamaged (Fig. 3A:C1), our approach
yields dynamic gaits that are 30% faster than the classic reference
gait (Fig. 3B, median 0.32 m/s, 5th and 95th percentiles [0.26;
0.36] vs. 0.24m/s), suggesting that Intelligent Trial and Error is
a good search algorithm for automatically producing successful
robot behaviors, putting aside damage recovery. In all the dam-
age scenarios, the reference gait is no longer effective (~0.04 m/s
for the four damage conditions, Fig. 3B:C2-C5). After Intelligent
Trial and Error, the compensatory gaits achieve a reasonably fast
speed (> 0.15m/s) and are between 3 and 7 times more efﬁcient
than the reference gait for that damage condition (in m/s, C2:
0.24 [0.18; 0.31] vs. 0.04; C3: 0.22 [0.18; 0.26] vs. 0.03; C4: 0.21
[0.17; 0.26] vs. 0.04; C5: 0.17 [0.12; 0.24] vs. 0.05; C6: 0.3 [0.21;
0.33] vs 0.12).

These experiments demonstrate that Intelligent Trial and Error
allows the robot to both initially learn fast gaits and to reliably re-
cover after physical damage. Additional experiments reveal that
these capabilities are substantially faster than state-of-the-art al-
gorithms (Extended Data Fig. 2), and that Intelligent Trial and Er-
ror can help with another major challenge in robotics: adapting
to new environments (Extended Data Fig. 3). On the undam-
aged or repaired robot (Fig. 3: C6), Intelligent Trial and Error
learns a walking gait in less than 30 seconds (Fig. 3C, undam-
aged: 24 [16; 41] seconds, 3 [2; 5] physical trials, repaired: 29 [16;
82] seconds, 3.5 [2; 10] trials). For the four damage scenarios, the
robot adapts in approximately one minute (66 [24; 134] seconds,
8 [3; 16] trials). Our results are qualitatively unchanged when
using different behavioral characterizations, including randomly
choosing 6 descriptors among 63 possibilities (Fig. 3B-C and Ex-
tended Data Fig. 4). Additional experiments show that reducing
the high-dimensional parameter space to a low-dimensional be-
havior space via the behavior-performance map is the key com-
ponent for intelligent trial and error: standard Bayesian opti-
mization in the original parameter space does not ﬁnd working
controllers (Extended Data Fig. 2).

We investigated how the behavior-performance map is up-
dated when the robot loses a leg (Fig. 3A:C4). Initially the map

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 2

Figure 2| (A & B). Creating the behavior-performance map: A user reduces a high-dimensional search space to a low-dimensional behavior space by
deﬁning dimensions along which behaviors vary. In simulation, the high-dimensional space is then automatically searched to ﬁnd a high-performing
behavior at each point in the low-dimensional behavior space, creating a “behavior-performance” map of the performance potential of each location
in the low-dimensional space. In our hexapod robot experiments, the behavior space is six-dimensional: the portion of time that each leg is in contact
with the ground. The conﬁdence regarding the accuracy of the predicted performance for each behavior in the behavior-performance map is initially
low because no tests on the physical robot have been conducted. (C & D) Adaptation Step: After damage, the robot selects a promising behavior, tests
it, updates the predicted performance of that behavior in the behavior-performance map, and sets a high conﬁdence on this performance prediction.
The predicted performances of nearby behaviors–and conﬁdence in those predictions–are likely to be similar to the tested behavior and are thus
updated accordingly. This select/test/update loop is repeated until a tested behavior on the physical robot performs better than 90% of the best
predicted performance in the behavior-performance map, a value that can decrease with each test (Extended Data Fig. 1). The algorithm that selects
which behavior to test next balances between choosing the behavior with the highest predicted performance and behaviors that are different from
those tested so far. Overall, the Intelligent Trial and Error approach presented here rapidly locates which types of behaviors are least affected by the
damage to ﬁnd an effective, compensatory behavior.

predicts large areas of high performance. During adaptation,
these areas disappear because the behaviors do not work well on
the damaged robot. Intelligent Trial and Error quickly identiﬁes
one of the few, remaining, high-performance behaviors (Fig. 4
and Extended Data Fig. 5 and 6).

The same damage recovery approach can be applied to any
robot, such as a robotic arm. We tested 14 different damage con-
ditions with a planar, 8-joint robotic arm (Fig. 3D-F and Extended
Data Fig. 7). The behavior-performance map’s behavioral dimen-
sions are the x, y position of the end-effector and the performance
measure is minimizing the variance of the 8 speciﬁed motor an-
gles (Supplementary Methods). During adaptation, performance
is measured as distance to the target. Like with the hexapod
robot, our approach discovers a compensatory behavior in less
than 2 minutes, usually in less than 30 seconds, and with fewer
than 10 trials (Fig. 3F and Extended Data Fig. 7).

While natural animals do not use the speciﬁc algorithm we
present, there are parallels between Intelligent Trial and Error
and animal learning. Like animals, our robot does not have a
predeﬁned strategy for how to cope with every possible dam-
age condition: in the face of a new injury, it exploits its intuitions
about how its body works to experiment with different behaviors
to ﬁnd what works best. Also like animals24, Intelligent Trial and
Error allows the quick identiﬁcation of working behaviors with a
few, diverse tests instead of trying behaviors at random or trying
small modiﬁcations to the best behavior found so far. Addition-
ally, the Bayesian optimization procedure followed by our robot
appears similar to the technique employed by humans when they
optimize an unknown function23, and there is strong evidence
that animal brains learn probability distributions, combine them
with prior knowledge, and act as Bayesian optimizers25,26.

An additional parallel is that Intelligent Trial and Error primes
the robot for creativity during a motionless period, after which

the generated ideas are tested. This process is reminiscent of
the ﬁnding that some animals start the day with new ideas that
they may quickly disregard after experimenting with them27,
and more generally, that sleep improves creativity on cognitive
tasks28. A ﬁnal parallel is that the simulator and Gaussian process
components of Intelligent Trial and Error are two forms of predic-
tive models, which are known to exist in animals29,12. All told, we
have shown that combining pieces of nature’s algorithm, even if
differently assembled, moves robots more towards animals by
endowing them with the ability to rapidly adapt to unforeseen
circumstances.

Supplementary Information and methods are appended at
the end of this document.

Acknowledgments. Thanks to Luigi Tedesco, Stéphane Don-
cieux, Nicolas Bredeche, Shimon Whiteson, Roberto Calandra,
Jacques Droulez, Pierre Bessière, Florian Lesaint, Charles Thu-
rat, Serena Ivaldi, Jingyu Li, Joost Huizinga, Roby Velez, Henok
Mengistu, Tim Clune, and Anh Nguyen for helpful feedback and
discussions. Thanks to Michael Brashier for the photo of the
three-legged dog.

This work has been funded by the ANR Creadapt project (ANR-
12-JS03-0009), the European Research Council (ERC) under
the European Union’s Horizon 2020 research and innovation
programme (grant agreement number 637972), and a Direction
Géneérale de l’Armement (DGA) scholarship to A.C.

Author Contributions A.C. and J.-B. M designed the study.
A.C. and D.T. performed the experiments. A.C., J.-B. M, D.T. and
J.C. discussed additional experiments, analyzed the results, and
wrote the paper.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 3

Figure 3| (A) Conditions tested on
the physical hexapod robot. C1: The
undamaged robot. C2: One leg is
shortened by half. C3: One leg is
unpowered. C4: One leg is miss-
ing. C5: Two legs are missing. C6:
A temporary, makeshift repair to the
(B) Performance af-
tip of one leg.
ter adaptation. Box plots represent
Intelligent Trial and Error. The cen-
tral mark is the median, the edges
of the box are the 25th and 75th per-
centiles, the whiskers extend to the
most extreme data points not consid-
ered outliers, and outliers are plotted
individually. Yellow stars represent
the performance of the handmade
reference tripod gait (Supplementary
Methods).
Conditions C1-C6 are
tested 5 times each for 8 indepen-
dently created behavior-performance
maps with the “duty factor” behav-
ior description (i.e. 40 experiments
per damage condition, Supplemen-
tary Methods). Damage conditions
C1 and C3 are also tested 5 times
each for 8 independently created
behavior-performance maps with the
“body orientation” behavior descrip-
(C)
tion (Supplementary Methods).
Time and number of trials required
to adapt. Box plots represent Intel-
(D) Robotic
ligent Trial and Error.
arm experiment. The 8-joint, planar
robot has to drop a ball into a bin.
(E) Example conditions tested on the
physical robotic arm. C1: One joint
is stuck at 45 degrees. C2: One joint
has a permanent 45-degree offset. C3:
One broken and one offset joint. A to-
tal of 14 conditions were tested (Ex-
(F) Time and
tended Data Fig. 7).
number of trials required to reach
within 5 cm of the bin center. Each
condition is tested with 15 indepen-
dently created behavior-performance
maps.

Figure 4| An example behavior-performance map. This map stores high-performing behaviors at each point in a six-dimensional behavior space.
Each dimension is the portion of time that each leg is in contact with the ground. The behavioral space is discretized at ﬁve values for each dimension
(0; 0.25; 0.5; 0.75; 1). Each colored pixel represents the highest-performing behavior discovered during map creation at that point in the behavior space.
The matrices visualize the six-dimensional behavioral space in two dimensions according to the legend in the top-left. The behavior-performance
map is created with a simulated robot (bottom left) in the Open Dynamics Engine physics simulator (http://www.ode.org). The left matrix is a
pre-adaptation map produced by the map creation algorithm. During adaptation, the map is updated as tests are conducted (in this case, in the
damage condition where the robot is missing one leg: Fig. 3A:C4). The right matrix shows the state of the map after a compensatory behavior
is discovered. The arrows and white circles represent the order in which behaviors were tested on the physical robot. The red circle is the ﬁnal,
discovered, compensatory behavior. Amongst other areas, high-performing behaviors can be found for the damaged robot in the ﬁrst two columns
of the third dimension. These columns represent behaviors that least use the central-left leg, which is the leg that is missing.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 4

Author information Correspondence and requests for ma-
terials should be addressed to J.-B. M.
jean-
baptiste.mouret@inria.fr).

(email:

1.

J. G. Bellingham and K. Rajan. “Robotics in remote and hostile environ-
ments.” In: Science 318.5853 (Nov. 2007), pp. 1098–102. ISSN: 1095-9203.
DOI: 10.1126/science.1146230.

2. D. R. Yoerger. “Underwater robotics”. In: Springer handbook of robotics.

Springer, 2008, pp. 987–1008.

3. E. Broadbent, R. Stafford, and B. MacDonald. “Acceptance of healthcare
robots for the older population: review and future directions”. In: International
Journal of Social Robotics 1.4 (2009), pp. 319–330.

4. K. Sanderson. “Mars rover Spirit (2003-10)”. In: Nature 463.7281 (2010),

5.

p. 600.
J. Carlson and R. R. Murphy. “How UGVs physically fail in the ﬁeld”. In: IEEE
Transactions on Robotics 21.3 (2005), pp. 423–437.

6. M. Blanke and J. Schröder. Diagnosis and fault-tolerant control. Springer,

2006.

7. B. Siciliano and O. Khatib. Springer handbook of robotics. Springer, 2008.
8. R. R. Murphy. “Trial by ﬁre [rescue robots]”. In: Robotics & Automation Mag-

22.

azine, IEEE 11.3 (2004), pp. 50–61.

9. K. Nagatani, S. Kiribayashi, Y. Okada, K. Otake, K. Yoshida, S. Tadokoro,
T. Nishimura, T. Yoshida, E. Koyanagi, M. Fukushima, and S. Kawatsuma.
“Emergency response to the nuclear accident at the Fukushima Daiichi Nu-
clear Power Plants using mobile rescue robots”. In: Journal of Field Robotics
30.1 (2013), pp. 44–63.

10. S. Thrun, M. Montemerlo, H. Dahlkamp, D. Stavens, A. Aron, J. Diebel, P.
Fong, J. Gale, M. Halpenny, G. Hoffmann, et al. “Stanley: The robot that
won the DARPA Grand Challenge”. In: Journal of ﬁeld Robotics 23.9 (2006),
pp. 661–692.

11. V. Verma, G. Gordon, R. Simmons, and S. Thrun. “Real-time fault diagnosis”.

12.

In: Robotics & Automation Magazine 11.2 (2004), pp. 56–66.
J. Bongard, V. Zykov, and H. Lipson. “Resilient machines through continuous
self-modeling”. In: Science 314.5802 (2006), pp. 1118–1121.

13. W. G. Fenton, T. M. McGinnity, and L. P. Maguire. “Fault diagnosis of elec-
tronic systems using intelligent techniques: a review”. In: IEEE Transactions
on Systems, Man, and Cybernetics, Part C: Applications and Reviews 31.3
(2001), pp. 269–281.
J. Kluger and J. Lovell. Apollo 13. Mariner Books, 2006.
0618619580.

ISBN: 978-

14.

15. S. L. Jarvis, D. R. Worley, S. M. Hogy, A. E Hill, K. K. Haussler, and R. F.
Reiser II. “Kinematic and kinetic analysis of dogs during trotting after ampu-
tation of a thoracic limb”. In: American journal of veterinary research 74.9
(2013), pp. 1155–1163.

16. A Fuchs, B Goldner, I Nolte, and N Schilling. “Ground reaction force adap-
tations to tripedal locomotion in dogs.” In: Veterinary journal 201.3 (Sept.
2014), pp. 307–15. ISSN: 1532-2971. DOI: 10.1016/j.tvjl.2014.05.012.
J. Kober, J. A. Bagnell, and J. Peters. “Reinforcement learning in robotics:
a survey”. In: The International Journal of Robotics Research 32.11 (2013),
pp. 1238–1274. DOI: 10.1177/0278364913495721.

17.

18. B. D. Argall, S. Chernova, M. Veloso, and B. Browning. “A survey of robot
learning from demonstration”. In: Robotics and autonomous systems 57.5
(2009), pp. 469–483.

19. E. Thelen. “Motor development: a new synthesis”. In: American psychologist

(1995), pp. 79–95.

20. M. Santello. “Postural hand synergies for tool use”. In: The Journal of Neuro-

science 18.23 (1998), pp. 10105–10115.

21. C. E. Rasmussen and C. K. I. Williams. Gaussian processes for machine

learning. MIT Press, 2006. ISBN: 0-262-18253-X.
J. Mockus. Bayesian approach to global optimization: theory and applica-
tions. Kluwer Academic, 2013.

23. A. Borji and L. Itti. “Bayesian optimization explains human active search”.
In: Advances in Neural Information Processing Systems 26 (NIPS). 2013,
pp. 55–63.

24. S. Benson-Amram and K. E. Holekamp. “Innovative problem solving by wild
spotted hyenas”. In: Proceedings of the Royal Society B: Biological Sciences
279.1744 (2012), pp. 4087–4095.

25. A. Pouget, J. M. Beck, W. J. Ma, and P. E. Latham. “Probabilistic brains:
knowns and unknowns”. In: Nature neuroscience 16.9 (2013), pp. 1170–
1178.

26. K. P. Körding and D. M. Wolpert. “Bayesian integration in sensorimotor learn-

ing”. In: Nature 427.6971 (2004), pp. 244–247.

27. S. Derégnaucourt, P. P. Mitra, O. Fehér, C. Pytte, and O. Tchernichovski.
learning of bird song”. In: Nature

“How sleep affects the developmental
433.7027 (2005), pp. 710–716.

28. U. Wagner, S. Gais, H. Haider, R. Verleger, and J. Born. “Sleep inspires

insight”. In: Nature 427.6972 (2004), pp. 352–355.

29. M. Ito. “Control of mental activities by internal models in the cerebellum”. In:

Nature Reviews Neuroscience 9.4 (2008), pp. 304–313.

5

1 Methods

Notations

• c: Parameters of a controller (vector)
• x: A location in a discrete behavioral space (i.e. a type of

behavior) (vector)

• χ: A location in a discrete behavioral space that has been

tested on the physical robot (vector)

• P: Behavior-performance map (stores performance) (asso-

• C: Behavior-performance map (stores controllers) (associa-

ciative table)

tive table)

• P(x): Max performance yet encountered at x (scalar)
• C(x): Controller currently stored in x (vector)
• χ1:t: All previously tested behavioral descriptors at time t

(vector of vectors)

• P1:t: Performance in reality of all the candidate solutions

tested on the robot up to time t (vector)

• P(χ1:t): Performance in the behavior-performance map for
all the candidate solutions tested on the robot up to time t
(vector)

• f (): Performance function (unknown by the algorithm)

(function)

• σ2

(scalar)

(function)

noise: Observation noise (a user-speciﬁed parameter)

• k(x, x): Kernel function (see section “kernel function”)

• K: Kernel matrix (matrix)
• k: Kernel vector [k(x, χ1), k(x, χ2), ..., k(x, χt)] (vector)
• µt(x): Predicted performance for x (i.e.

the mean of the

Gaussian process) (function)

• σ2

t (x): Standard deviation for x in the Gaussian process

(function)

1.1 Intelligent Trial and Error algorithm (IT&E)

The Intelligent Trial and Error Algorithm consists of two major
steps (Extended Data Fig. 1):
the behavior-performance map
creation step and the adaptation step (while here we focus on
damage recovery, Intelligent Trial and Error can search for any
type of required adaptation, such as learning an initial gait for
an undamaged robot, adapting to new environments, etc.). The
behavior-performance map creation step is accomplished via a
new algorithm introduced in this paper called multi-dimensional
archive of phenotypic elites (MAP-Elites), which is explained
in the next section. The adaptation step is accomplished via a
second new algorithm introduced in this paper called the map-
based Bayesian optimization algorithm (M-BOA), which is ex-
plained in the “Adaptation Step” section below.

1.2 Behavior-performance map creation (via the

MAP-Elites algorithm)

The behavior-performance map is created by a new algorithm we
introduce in this paper called the multi-dimensional archive of
phenotypic elites (MAP-Elites) algorithm. MAP-Elites searches
for the highest-performing solution for each point in a user-
deﬁned space: the user chooses the dimensions of the space that
they are interested in seeing variation in. For example, when de-
signing robots, the user may be interested in seeing the highest-
performing solution at each point in a two-dimensional space
where one axis is the weight of the robot and the other axis is the
height of the robot. Alternatively, a user may wish to see weight
vs. cost, or see solutions throughout a 3D space of weight vs. cost
vs. height. Any dimension that can vary could be chosen by the
user. There is no limit on the number of dimensions that can be
chosen, although it becomes computationally more expensive to

ﬁll the behavior-performance map and store it as the number of
dimensions increases. It also becomes more difﬁcult to visualize
the results. We refer to this user-deﬁned space as the “behavior
space”, because usually the dimensions of variation measure be-
havioral characteristics. Note that the behavioral space can refer
to other aspects of the solution (as in this example, where the di-
mensions of variation are physical properties of a robot such as
its height and weight).

If the behavior descriptors and the parameters of the con-
troller are the same (i.e.
if there is only one possible so-
lution/genome/parameter set/policy/description for each lo-
cation in the behavioral space),
then creating the behavior-
performance map is straightforward: one simply needs to simu-
late the solution at each location in the behavior space and record
the performance. However, if it is not known a priori how to
produce a controller/parameter set/description that will end up
in a speciﬁc location in the behavior space (i.e. if the parameter
space is of higher dimension than the behavioral space: e.g., in
our example, if there are many different robot designs of a spe-
ciﬁc weight, height, and cost, or if it is unknown how to make
a description that will produce a robot with a speciﬁc weight,
height, and cost), then MAP-Elites is beneﬁcial. It will efﬁciently
search for the highest-performing solution at each point of the
low-dimensional behavioral space. It is more efﬁcient than a ran-
dom sampling of the search space because high-performing so-
lutions are often similar in many ways, such that randomly alter-
ing a high-performing solution of one type can produce a high-
performing solution of a different type (see Extended Data Fig.
10 and Supplementary Experiment S4). For this reason, search-
ing for high-performing solutions of all types simultaneously is
much quicker than separately searching for each type. For exam-
ple, to generate a lightweight, high-performing robot design, it
tends to be more effective and efﬁcient to modify an existing de-
sign of a light robot rather than randomly generate new designs
from scratch or launch a separate search process for each new
type of design.

MAP-Elites begins by generating a set of random candidate
solutions. It then evaluates the performance of each solution and
records where that solution is located in the behavior space (e.g.
if the dimensions of the behavior space are the height and weight,
it records the height and weight of each robot in addition to its
performance). For each solution, if its performance is better than
the current solution at that location in the behavior-performance
map, then it is added to the behavior-performance map, replac-
ing the solution in that location. In other words, it is only kept if
it is the best of that type of solution, where “type” is deﬁned as
a location in the behavior space. There is thus only one solution
kept at each location in the behavior space (keeping more could
be beneﬁcial, but for computational reasons we only keep one).
If no solution is present in the behavior-performance map at that
location, then the newly generated candidate solution is added
at that location.

Once this initialization step is ﬁnished, Map-Elites enters a
loop that is similar to stochastic, population-based, optimization
algorithms, such as evolutionary algorithms30: the solutions that
are in the behavior-performance map form a population that is
improved by random variation and selection. In each generation,
the algorithm picks a solution at random via a uniform distri-
bution, meaning that each solution has an equal chance of being
chosen. A copy of the selected solution is then randomly mutated
to change it in some way, its performance is evaluated, its loca-
tion in the behavioral space is determined, and it is kept if it out-
performs the current occupant at that point in the behavior space
(note that mutated solutions may end up in different behavior
space locations than their “parents”). This process is repeated
until a stopping criterion is met (e.g. after a ﬁxed amount of time
has expired). In our experiments, we stopped each MAP-Elites
run after 40 million iterations. Because MAP-Elites is a stochastic

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 6

(A) Behavior-performance map creation. After being
Extended Data Figure 1 | An overview of the Intelligent Trial and Error Algorithm.
initialized with random controllers, the behavioral map (A2), which stores the highest-performing controller found so far of each behavior type,
is improved by repeating the process depicted in (A1) until newly generated controllers are rarely good enough to be added to the map (here,
after 40 million evaluations). This step, which occurs in simulation, is computationally expensive, but only needs to be performed once per robot
(or robot design) prior to deployment.
In our experiments, creating one map involved 40 million iterations of (A1), which lasted roughly two
weeks on one multi-core computer (Supplementary Methods, section “Running time”). (B) Adaptation. (B1) Each behavior from the behavior-
performance map has an expected performance based on its performance in simulation (dark green line) and an estimate of uncertainty regarding
this predicted performance (light green band). The actual performance on the now-damaged robot (black dashed line) is unknown to the algorithm.
A behavior is selected to try on the damaged robot. This selection is made by balancing exploitation—trying behaviors expected to perform well—
and exploration—trying behaviors whose performance is uncertain (Methods, section “acquisition function”). Because all points initially have equal,
maximal uncertainty, the ﬁrst point chosen is that with the highest expected performance. Once this behavior is tested on the physical robot (B4),
the performance predicted for that behavior is set to its actual performance, the uncertainty regarding that prediction is lowered, and the predictions
for, and uncertainties about, nearby controllers are also updated (according to a Gaussian process model, see Methods, section “kernel function”),
the results of which can be seen in (B2). The process is then repeated until performance on the damaged robot is 90% or greater of the maximum
expected performance for any behavior (B3). This performance threshold (orange dashed line) lowers as the maximum expected performance (the
highest point on the dark green line) is lowered, which occurs when physical tests on the robot underperform expectations, as occurred in (B2).

search process, each resultant behavior-performance map can be
different, both in terms of the number of locations in the behav-
ioral space for which a candidate is found, and in terms of the
performance of the candidate in each location.

The pseudo-code of the algorithm is available in Supplemen-
tary Figure 8. More details and experiments about MAP-Elites
are available in (Mouret and Clune, 2015)31.

tainty associated with each prediction. For a cost function f , usu-
ally unknown, a Gaussian process deﬁnes the probability distri-
bution of the possible values f (x) for each point x. These prob-
ability distributions are Gaussian, and are therefore deﬁned by a
mean (µ) and a standard deviation (σ). However, µ and σ can be
different for each x; we therefore deﬁne a probability distribution
over functions:

1.3 Adaptation step (via M-BOA: the map-based

Bayesian optimization algorithm)

The adaptation step is accomplished via a Bayesian optimization
algorithm seeded with a behavior-performance map. We call this
approach a map-based Bayesian optimization algorithm, or M-
BOA.

Bayesian optimization is a model-based, black-box optimiza-
tion algorithm that is tailored for very expensive objective func-
tions (a.k.a. cost functions)32,33,22,34,35,23. As a black-box optimiza-
tion algorithm, Bayesian optimization searches for the maximum
of an unknown objective function from which samples can be ob-
tained (e.g., by measuring the performance of a robot). Like all
model-based optimization algorithms (e.g. surrogate-based algo-
rithms36,37,38, kriging39, or DACE40,41), Bayesian optimization cre-
ates a model of the objective function with a regression method,
uses this model to select the next point to acquire, then updates
the model, etc. It is called Bayesian because, in its general for-
mulation22, this algorithm chooses the next point by computing
a posterior distribution of the objective function using the like-
lihood of the data already acquired and a prior on the type of
function.

Here we use Gaussian process regression to ﬁnd a model21,
which is a common choice for Bayesian optimization42,35,33,32.
Gaussian processes are particularly interesting for regression be-
cause they not only model the cost function, but also the uncer-

P (f (x)|x) = N (µ(x), σ2(x))

(1)

where N denotes the standard normal distribution.

To estimate µ(x) and σ(x), we need to ﬁt the Gaussian process
to the data. To do so, we assume that each observation f (χ) is a
sample from a normal distribution. If we have a data set made
of several observations, that is, f (χ1), f (χ2), ..., f (χt), then the
vector [f (χ1), f (χ2), ..., f (χt)] is a sample from a multivariate nor-
mal distribution, which is deﬁned by a mean vector and a covari-
ance matrix. A Gaussian process is therefore a generalization of
a n-variate normal distribution, where n is the number of obser-
vations. The covariance matrix is what relates one observation
to another: two observations that correspond to nearby values
of χ1 and χ2 are likely to be correlated (this is a prior assump-
tion based on the fact that functions tend to be smooth, and is
injected into the algorithm via a prior on the likelihood of func-
tions), two observations that correspond to distant values of χ1
and χ2 should not inﬂuence each other (i.e. their distributions are
not correlated). Put differently, the covariance matrix represents
that distant samples are almost uncorrelated and nearby samples
are strongly correlated. This covariance matrix is deﬁned via a
kernel function, called k(χ1, χ2), which is usually based on the
Euclidean distance between χ1 and χ2 (see the “kernel function”
sub-section below).

Given a set of observations P1:t = f (χ1:t) and a sampling
noise(which is a user-speciﬁed parameter), the Gaussian

noise σ2

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 7

Variant

Intelligent Trial and Error
Variant 1
Variant 2
Variant 3
Variant 4
Variant 5

Behavior-performance map
creation
MAP-Elites
MAP-Elites
MAP-Elites
MAP-Elites
none
none

Priors on
performance
yes
none
none
none
none
none

Search
algorithm
Bayesian Optimization
random search
Bayesian optimization
policy gradient
Bayesian optimization
policy gradient

equivalent
approach
-
-
-
-
Lizotte et al. (2007)
Kohl et al. (2004)

Extended Data Figure 2 | The contribution of each subcomponent of the Intelligent Trial and Error Algorithm. (A) Adaptation progress versus
the number of robot trials. The walking speed achieved with Intelligent Trial and Error and several “knockout” variants that are missing one of the
algorithm’s key components. Some variants (4 and 5) correspond to state-of-the-art learning algorithms (policy gradient: Kohl et al. 2004; Bayesian
optimization: Lizotte et al. 2007, Tesch et al., 2011, Calandra et al. 2014,). The bold lines represent the medians and the colored areas extend to the
25th and 75th percentiles. (B, C) Adaptation performance after 17 and 150 trials. Shown is the the speed of the compensatory behavior discovered
by each algorithm after 17 and 150 evaluations on the robot, respectively. For all panels, data are pooled across six damage conditions (the removal
of each of the 6 legs in turn). See Supplementary Experiment S2 for methods and analysis.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 8

Extended Data Figure 3 | The Intelligent Trial and Error Algorithm is robust to environmental changes. Each plot shows both the performance and
required adaptation time for Intelligent Trial and Error when the robot must adapt to walk on terrains of different slopes. (A) Adaptation performance
on an undamaged robot. On all slope angles, with very few physical trials, the Intelligent Trial and Error Algorithm (pink shaded region) ﬁnds fast
gaits that outperform the reference gait (black dotted line). (B) Adaptation performance on a damaged robot. The robot is damaged by having
each of the six legs removed in six different damage scenarios. Data are pooled from all six of these damage conditions. The median compensatory
behavior found via Intelligent Trial and Error outperforms the median reference controller on all slope angles. The middle, black lines represent
medians, while the colored areas extend to the 25th and 75th percentiles. In (A), the black dashed line is the performance of a classic tripod gait for
reference. In (B), the reference gait is tried in all six damage conditions and its median (black line) and 25th and 75th percentiles (black colored area)
are shown. See Supplementary Experiment S3 for methods and analysis.

process is computed as follows33,21:

the update equation for the mean function (µt(x), equation 2):

P (f (x)|P1:t, x) = N (µt(x), σ2

t (x))

where :
µt(x) = k(cid:124)K−1P1:t
t (x) = k(x, x) − k(cid:124)K−1k
σ2

K =






k(χ1, χ1)
...
k(χt, χ1)

k = (cid:2) k(x, χ1)

· · ·
. . .
· · ·
k(x, χ2)

k(χ1, χt)
...
k(χt, χt)
· · ·


 + σ2


noiseI

k(x, χt) (cid:3)

Our implementation of Bayesian optimization uses this Gaus-
sian process model to search for the maximum of the objective
function f (x), f (x) being unknown. It selects the next χ to test
by selecting the maximum of the acquisition function, which bal-
ances exploration – improving the model in the less explored
parts of the search space – and exploitation – favoring parts that
the models predicts as promising. Here, we use the “Upper Con-
ﬁdence Bound” acquisition function (see the “information acqui-
sition function” section below). Once the observation is made,
the algorithm updates the Gaussian process to take the new data
into account. In classic Bayesian optimization, the Gaussian pro-
cess is initialized with a constant mean because it is assumed that
all the points of the search space are equally likely to be good.
The model is then progressively reﬁned after each observation.

The key concept of the map-based Bayesian optimization al-
gorithm (M-BOA) is to use the output of MAP-Elites as a prior
for the Bayesian optimization algorithm: thanks to the simula-
tions, we expect some behaviors to perform better than others
on the robot. To incorporate this idea into the Bayesian opti-
mization, M-BOA models the difference between the prediction
of the behavior-performance map and the actual performance on
the real robot, instead of directly modeling the objective function.
This idea is incorporated into the Gaussian process by modifying

(cid:124)
µt(x) = P(x) + k

K−1(P1:t − P(χ1:t))

(3)

(2)

where P(x) is the performance of x according to the simula-
tion and P(χ1:t) is the performance of all the previous observa-
tions, also according to the simulation. Replacing P1:t (eq. 2)
by P1:t − P(χ1:t) (eq. 3) means that the Gaussian process mod-
els the difference between the actual performance P1:t and the
performance from the behavior-performance map P(χ1:t). The
term P(x) is the prediction of the behavior-performance map.
M-BOA therefore starts with the prediction from the behavior-
performance map and corrects it with the Gaussian process.

The pseudo-code of the algorithm is available in Supplemen-

tary Figure 8.

Kernel function The kernel function is the covariance function
of the Gaussian process. It deﬁnes the inﬂuence of a controller’s
performance (on the physical robot) on the performance and con-
ﬁdence estimations of not-yet-tested controllers in the behavior-
performance map that are nearby in behavior space to the tested
controller (Extended Data Fig. 9a).

The Squared Exponential covariance function and the Matérn
kernel are the most common kernels for Gaussian pro-
cesses33,34,21. Both kernels are variants of the “bell curve”. Here
we chose the Matérn kernel because it is more general (it includes
the Squared Exponential function as a special case) and because
it allows us to control not only the distance at which effects be-
come nearly zero (as a function of parameter ρ, Extended Data
Fig. 9a), but also the rate at which distance effects decrease (as a
function of parameter ν).

The Matérn kernel function is computed as follows43,44 (with

ν = 5/2):

(cid:16)

√

k(x1, x2) =
where d(x1, x2) is the Euclidean distance in behavior space.

exp

1 +

−

5d(x1,x2)
ρ

5d(x1,x2)
ρ

+ 5d(x1,x2)2
3ρ2

(cid:17)

(cid:16)

√

(cid:17)

Cully, Clune, Tarapore, and Mouret. 2015

(4)

arXiv preprint | 9

Extended Data Figure 4 | The Intelligent Trial and Error Algorithm is largely robust to alternate choices of behavior descriptors. (A, B) The speed
of the compensatory behavior discovered by Intelligent Trial and Error for various choices of behavior descriptors. Performance is plotted after 17
and 150 evaluations in panels A and B, respectively. Experiments were performed on a simulated, damaged hexapod. The damaged robot has each of
its six legs removed in six different damage scenarios. Data are pooled across all six damage conditions. As described in Supplementary Experiment
S5, the evaluated behavior descriptors characterize the following: (i) Time each leg is in contact with the ground (Duty factor); (ii) Orientation of the
robot frame (Orientation); (iii) Instantaneous velocity of the robot (Displacement); (iv) Energy expended by the robot in walking (Energy (Total),
Energy (Relative)); (v) Deviation from a straight line (Deviation); (vi) Ground reaction force on each leg (GRF (Total), GRF (Relative)); (vii) The
angle of each leg when it touches the ground (Lower-leg angle (Pitch), Lower-leg angle (Roll), Lower-leg angle (Yaw)); and (viii) A random selection
without replacement from subcomponents of all the available behavior descriptors (i-vii) (Random). For the hand-designed reference gait (yellow)
and the compensatory gaits found by the default duty factor behavior descriptor (green), the bold lines represent the medians and the colored areas
extend to the 25th and 75th percentiles of the data. For the other treatments, including the duty factor treatment, black circles represent the median, the
colored area extends to the 25th and 75th percentiles of the data, and the colored circles are outliers. See Supplementary Experiment S5 for methods
and analysis.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 10

Extended Data Figure 5 | How the behavior performance map is explored to discover a compensatory behavior (normalized each iteration to
highlight the range of remaining performance predictions). Colors represent the performance prediction for each point in the map relative to the
highest performing prediction in the map at that step of the process. A black circle indicates the next behavior to be tested on the physical robot. A
red circle indicates the behavior that was just tested (note that the performance predictions surrounding it have changed versus the previous panel).
Arrows reveal the order that points have been explored. The red circle in the last map is the ﬁnal, selected, compensatory behavior. In this scenario,
the robot loses leg number 3. The six dimensional space is visualized according to the inset legend.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 11

Extended Data Figure 6 | How the behavior performance map is explored to discover a compensatory behavior (non-normalized to highlight
that performance predictions decrease as it is discovered that predictions from the simulated, undamaged robot do not work well on the damaged
robot). Colors represent the performance prediction for each point in the map relative to the highest performing prediction in the ﬁrst map. A black
circle indicates the next behavior to be tested on the physical robot. A red circle indicates the behavior that was just tested (note that the performance
predictions surrounding it have changed versus the previous panel). Arrows reveal the order that points have been explored. The red circle in the
last map in the sequence is the ﬁnal, selected, compensatory behavior. In this scenario, the robot loses leg number 3. The six dimensional space
is visualized according to the inset legend. The data visualized in this ﬁgure are identical to those in the previous ﬁgure: the difference is simply
whether the data are renormalized for each new map in the sequence.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 12

Extended Data Figure 7 | Intelligent Trial and Error works on a completely different type of robot: supplementary data from the robotic arm
experiment. (A) The robotic arm experimental setup. (B) Tested damage conditions. (C) Example of behavior performance maps (colormaps)
and behaviors (overlaid arm conﬁgurations) obtained with MAP-Elites. Left: A typical behavior-performance map produced by MAP-Elites with
5 example behaviors, where a behavior is described by the angle of each of the 8 joints. The color of each point is a function of its performance,
which is deﬁned as having low variance in the joint angles (i.e. a zigzag arm is lower performing than a straighter arm that reaches the same point).
Right: Neighboring points in the map tend to have similar behaviors, thanks to the performance function, which would penalize more jagged ways of
reaching those points. That neighbors have similar behaviors justiﬁes updating predictions about the performance of nearby behaviors after a testing a
single behavior on the real (damaged) robot. (D) Performance vs. trial number for Intelligent Trial and Error and traditional Bayesian optimization.
The experiment was conducted on the physical robot, with 15 independent replications for each of the 14 damage conditions. Performance is pooled
from all of these 14×15 = 210 experiments. (E) Success for each damage condition. Shown is the success rate for the 15 replications for each damage
condition, deﬁned as the percentage of replicates in which the robot reaches within 5 cm of the bin center. (F) Trials required to adapt. Shown is the
number of iterations required to reach within 5 cm of the basket center. (G) Accuracy after 30 physical trials. Performance after 30 physical trials for
each damage condition (with the stopping criterion disabled). See Supplementary Experiment S1 for methods and analysis.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 13

CREATE BEHAVIOR-PERFORMANCE MAP (VIA THE MAP-ELITES ALGORITHM IN SIMULATION)

procedure INTELLIGENT TRIAL AND ERROR ALGORITHM (IT&E)

Before the mission:

while In mission do

if Signiﬁcant performance fall then

ADAPTATION STEP (VIA M-BOA ALGORITHM)

procedure MAP-ELITES ALGORITHM

(P ← ∅, C ← ∅)
for iter = 1 → I do

if iter < 400 then

c(cid:48) ← random_controller()

else

c ← random_selection(C)
c(cid:48) ← random_variation(c)

x(cid:48) ←behavioral_descriptor(simu(c(cid:48)))
p(cid:48) ←performance(simu(c(cid:48)))
if P(x(cid:48)) = ∅ or P(x(cid:48)) < p(cid:48) then

P(x(cid:48)) ← p(cid:48)

C(x(cid:48)) ← c(cid:48)

(cid:46) Creation of an empty behavior-performance map (empty N-dimensional grid).
(cid:46) Repeat during I iterations (here we choose I = 40 million iterations).

(cid:46) The ﬁrst 400 controllers are generated randomly.
(cid:46) The next controllers are generated using the map.
(cid:46) Randomly select a controller c in the map.
(cid:46) Create a randomly modiﬁed copy of c.
(cid:46) Simulate the controller and record its behavioral descriptor.
(cid:46) Record its performance.
(cid:46) If the cell is empty or if p(cid:48) is better than the current stored performance.
(cid:46) Store the performance of c(cid:48) in the behavior-performance map according
(cid:46) to its behavioral descriptor x(cid:48).
(cid:46) Associate the controller with its behavioral descriptor.

return behavior-performance map (P and C)

procedure M-BOA (MAP-BASED BAYESIAN OPTIMIZATION ALGORITHM)

∀x ∈ map:

P (f (x)|x) = N (µ0(x), σ2
where
µ0(x) = P(x)
σ2

0(x) = k(x, x)

0(x))

while max(P1:t) < α max(µt(x)) do
χt+1 ← arg maxx(µt(x) + κσt(x))
Pt+1 ← performance(physical_robot(C(χt+1))).
P (f (x)|P1:t+1, x) = N (µt+1(x), σ2
where
µt+1(x) = P(x) + k(cid:124)K−1(P1:t+1 − P(χ1:t+1))
t+1(x) = k(x, x) − k(cid:124)K−1k
σ2

t+1(x))






K =

k(χ1, χ1)
...
k(χt+1, χ1)

· · ·
. . .
· · ·
k(x, χ2)

k(χ1, χt+1)
...
k(χt+1, χt+1)
· · ·

k(x, χt+1) (cid:3)


 + σ2


noiseI

k = (cid:2) k(x, χ1)

(cid:46) Initialisation.
(cid:46) Deﬁnition of the Gaussian Process.

(cid:46) Initialize the mean prior from the map.
(cid:46) Initialize the variance prior (in the common case, k(x, x) = 1).
(cid:46) Iteration loop.
(cid:46) Select next test (argmax of acquisition function).
(cid:46) Evaluation of xt+1 on the physical robot.
(cid:46) Update the Gaussian Process.

(cid:46) Update the mean.
(cid:46) Update the variance.

(cid:46) Compute the observations’ correlation matrix.

(cid:46) Compute the x vs. observation correlation vector.

Extended Data Figure 8 | Pseudo-code for the Intelligent Trial and Error Algorithm, the MAP-Elites algorithm, and the Map-based Bayesian
Optimization Algorithm (M-BOA). Notations are described at the beginning of the methods section.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 14

Because the model update step directly depends on ρ, it is one
of the most critical parameters of the Intelligent Trial and Error
Algorithm. We selected its value after extensive experiments in
simulation (Extended Data Fig. 9 and section 1.6).

Information acquisition function The information acquisition
function selects the next solution that will be evaluated on the
physical robot. The selection is made by ﬁnding the solution
that maximizes the acquisition function. This step is another op-
timization problem, but does not require testing the controller
in simulation or reality. In general, for this optimization prob-
lem we can derive the exact equation and ﬁnd a solution with
gradient-based optimization45. For the speciﬁc behavior space in
the example problem in this paper, though, the discretized search
space of the behavior-performance map is small enough that we
can exhaustively compute the acquisition value of each solution
of the behavior-performance map and then choose the maximum
value.

Several different acquisition functions exist, such as the proba-
bility of improvement, the expected improvement, or the Upper
Conﬁdence Bound (UCB)33,42. We chose UCB because it provided
the best results in several previous studies33,42. The equation for
UCB is:

xt+1 = arg max

(µt(x) + κσt(x))

(5)

x

where κ is a user-deﬁned parameter that tunes the tradeoff be-
tween exploration and exploitation.

The acquisition function handles the exploitation/exploration
trade-off of the adaptation (M-BOA) step. In the UCB function
(Eq. 5), the emphasis on exploitation vs. exploration is explicit
and easy to adjust. The UCB function can be seen as the max-
imum value (argmax) across all solutions of the weighted sum
of the expected performance (mean of the Gaussian, µt(x)) and
of the uncertainty (standard deviation of the Gaussian, σt(x)) of
each solution. This sum is weighted by the κ factor. With a low κ,
the algorithm will choose solutions that are expected to be high-
performing. Conversely, with a high κ, the algorithm will fo-
cus its search on unexplored areas of the search space that may
have high-performing solutions. The κ factor enables ﬁne adjust-
ments to the exploitation/exploration trade-off of the M-BOA al-
gorithm (the adaptation step). We describe how we chose the κ
value in supplementary methods, section 1.6.

Code availability The source code (for GNU/Linux) for the ex-
periments of this paper is available at the following URL:
http://pages.isir.upmc.fr/~mouret/code/ite_source_code.tar.gz An implementa-
tion of the Bayesian optimization algorithm is freely available on:
http://github.com/jbmouret/limbo

1.4 Hexapod Experiment

Physical robot The robot is a 6-legged robot with 3 degrees
of freedom (DOFs) per leg. Each DOF is actuated by position-
controlled servos (MX-28 Dynamixel actuators manufactured by
Robotis). The ﬁrst servo controls the horizontal (front-back) ori-
entation of the leg and the two others control its elevation. An
RGB-D camera (Xtion, from ASUS) is ﬁxed on top of the robot. Its
data are used to estimate the forward displacement of the robot
via an RGB-D SLAM algorithm146 from the robot operating sys-
tem (ROS) framework247.

Simulator The simulator is a dynamic physics simulation of the
undamaged 6-legged robot on ﬂat ground (Fig. 4). We weighted
each segment of the leg and the body of the real robot, and we

1http://wiki.ros.org/ccny_openni_launch
2http://www.ros.org

used the same masses for the simulations. The simulator is based
on the Open Dynamics Engine (ODE, http://www.ode.org).

Parametrized controller The angular position of each DOF is
governed by a periodic function γ parametrized by its amplitude
α, its phase φ, and its duty cycle τ (the duty cycle is the propor-
tion of one period in which the joint is in its higher position). The
function is deﬁned with a square signal of frequency 1Hz, with
amplitude α, and duty cycle τ . This signal is then smoothed via
a Gaussian ﬁlter in order to remove sharp transitions, and is then
shifted according to the phase φ.

Angular positions are sent to the servos every 30 ms. In or-
der to keep the “tibia” of each leg vertical, the control signal of
the third servo is the opposite of the second one. Consequently,
angles sent to the ith leg are:

• γ(t, αi1 , φi1 , τi1 ) for DOF 1
• γ(t, αi2 , φi2 , τi2 ) for DOF 2
• −γ(t, αi2 , φi2 , τi2 ) for DOF 3

This controller makes the robot equivalent to a 12 DOF system,
even though 18 motors are controlled.

There are 6 parameters for each leg (αi1 , αi2 , φi1 , φi2 , τi1 ,
τi2 ), therefore each controller is fully described by 36 parame-
ters. Each parameter can have one of these possible values: 0,
0.05, 0.1, ... 0.95, 1. Different values for these 36 parameters can
produce numerous different gaits, from purely quadruped gaits
to classic tripod gaits.

This controller is designed to be simple enough to show the
performance of the algorithm in an intuitive setup. Neverthe-
less, the algorithm will work with any type of controller, includ-
ing bio-inspired central pattern generators48 and evolved neural
networks49,50,51,52.

Reference controller Our reference controller is a classic tri-
pod gait7,53,54,55,56,57. It involves two tripods: legs 1-4-5 and legs 2-
3-6 (Fig. 4). This controller is designed to always keep the robot
balanced on at least one of these tripods. The walking gait is
achieved by lifting one tripod, while the other tripod pushes the
robot forward (by shifting itself backward). The lifted tripod is
then placed forward in order to repeat the cycle with the other
tripod. This gait is static, fast, and similar to insect gaits53,58.

Table S1 shows the 36 parameters of the reference controller.
The amplitude orientation parameters (αi1 ) are set to 1 to pro-
duce the fastest possible gait, while the amplitude elevation pa-
rameters (αi2 ) are set to a small value (0.25) to keep the gait sta-
ble. The phase elevation parameters (φi2 ) deﬁne two tripods:
0.25 for legs 2-3-5; 0.75 for legs 1-4-5. To achieve a cyclic mo-
tion of the leg, the phase orientation values (φi1 ) are chosen by
subtracting 0.25 to the phase elevation values (φi2 ), plus a 0.5
shift for legs 1-3-5, which are on the left side of the robot. All the
duty cycle parameters (τi) are set to 0.5 so that the motors spend
the same proportion of time in their two limit angles. The actual
speed of the reference controller is not important for the compar-
isons made in this paper: it is simply intended as a reference and
to show that the performance of classic, hand-programmed gaits
tend to fail when damage occurs.

Random variation of controller’s parameters Each parame-
ter of the controller has a 5% chance of being changed to any
value in the set of possible values, with the new value chosen
randomly from a uniform distribution over the possible values.

Main Behavioral descriptor (duty factor) The default behav-
ioral descriptor is a 6-dimensional vector that corresponds to the
proportion of time that each leg is in contact with the ground
(also called duty factor). When a controller is simulated, the al-
gorithm records at each time step (every 30 ms) whether each leg

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 15

Leg number

First joint

Two last joints

1
1.00
0.00
0.5
0.25
0.75
0.5

2
1.00
0.00
0.5
0.25
0.25
0.5

3
1.00
0.50
0.5
0.25
0.25
0.5

4
1.00
0.50
0.5
0.25
0.75
0.5

5
1.00
0.00
0.5
0.25
0.75
0.5

6
1.00
0.00
0.5
0.25
0.25
0.5

αi1
φi1
τi1
αi2
φi2
τi2

Extended Data Table 1| Parameters of the reference controller.

is in contact with the ground (1: contact, 0: no contact). The re-
sult is 6 Boolean time series (Ci for the ith leg). The behavioral
descriptor is then computed with the average of each time series:







x =

(cid:80)

t C1(t)
numTimesteps(C1)

...

(cid:80)

t C6(t)
numTimesteps(C6)







During the generation of the behavior-performance map, the
behaviors are stored in the maps’s cells by discretizing each di-
mension of the behavioral descriptor space with these ﬁve val-
ues: {0, 0.25, 0.5, 0.75, 1}. During the adaptation phase, the behav-
ioral descriptors are used with their actual values and are thus
not discretized.

Alternative Behavioral descriptor (orientation) The alterna-
tive behavioral descriptor tested on the physical robot (we in-
vestigated many other descriptors in simulation: Supplementary
Experiment S5) characterizes changes in the angular position of
the robot during walking, measured as the proportion of 15ms
intervals that each of the pitch, roll and yaw angles of the robot
frame are positive (three dimensions) and negative (three addi-
tional dimensions):

x =











1
K
1
K
1
K
1
K
1
K
1
K

(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)

k U (ΘT (k) − 0.005π)
k U (−ΘT (k) − 0.005π)
k U (ΨT (k) − 0.005π)
k U (−ΨT (k) − 0.005π)
k U (ΦT (k) − 0.005π)
k U (−ΦT (k) − 0.005π)











(7)

where ΘT (k), ΨT (k) and ΦT (k) denote the pitch, roll and yaw
angles, respectively, of the robot torso (hence T ) at the end of
interval k, and K denotes the number of 15ms intervals during
the 5 seconds of simulated movement (here, K = 5s/0.015s ≈
334). The unit step function U (·) returns 1 if its argument exceeds
0, and returns 0 otherwise. To discount for insigniﬁcant motion
around 0 rad, orientation angles are only deﬁned as positive if
they exceed 0.5% of π rad. Similarly, orientation angles are only
deﬁned as negative if they are less than −0.5% of π rad.

Performance function In these experiments, the “mission”
of the robot is to go forward as fast as possible. The perfor-
mance of a controller, which is a set of parameters (section 1.4:
Parametrized controller), is deﬁned as how far the robot moves
in a pre-speciﬁed direction in 5 seconds.

During the behavior-performance map creation step, the per-
formance is obtained thanks to the simulation of the robot. All
odometry results reported on the physical robot, during the
adaptation step, are measured with the embedded simultaneous
location and mapping (SLAM) algorithm46. The accuracy of this
algorithm was evaluated by comparing its measurements to ones
made by hand on 40 different walking gaits. These experiments
revealed that the median measurement produced by the odome-
try algorithm is reasonably accurate, being just 2.2% lower than
the handmade measurement (Extended Data Fig. 9d).

Some damage to the robot may make it ﬂip over. In such cases,
the visual odometry algorithm returns pathological distance-

traveled measurements either several meters backward or for-
ward. To remove these errors, we set all distance-traveled mea-
surements less than zero or greater than two meters to zero. The
result of this adjustment is that the algorithm appropriately con-
siders such behaviors low-performing. Additionally, the SLAM
algorithm sometimes reports substantially inaccurate low val-
ues (outliers on Supplementary Fig. 9d).
In these cases the
adaptation step algorithm will assume that the behavior is low-
performing and will select another working behavior. Thus, the
overall algorithm is not substantially impacted by such infre-
quent under-measurements of performance.

(6)

Stopping criterion In addition to guiding the learning process
to the most promising area of the search space, the estimated per-
formance of each solution in the map also informs the algorithm
of the maximum performance that can be expected on the physi-
cal robot. For example, if there is no controller in the map that is
expected to perform faster on the real robot than 0.3m/s, it is un-
likely that a faster solution exists. This information is used in our
algorithm to decide if it is worth continuing to search for a bet-
ter controller; if the algorithm has already discovered a controller
that performs nearly as well as the highest value predicted by the
model, we can stop the search.

Formally, our stopping criterion is

max(P1:t) ≥ α max
x∈P

(µt(x)), with α = 0.9

(8)

where x is a location in the discrete behavioral space (i.e. a type of
behavior) and µt is the predicted performance of this type of be-
havior. Thus, when one of the tested solutions has a performance
of 90% or higher of the maximum expected performance of any
behavior in the map, the algorithm terminates. At that point,
the highest-performing solution found so far will be the compen-
satory behavior that the algorithm selects. An alternative way
the algorithm can halt is if 20 tests on the physical robot occur
without triggering the stopping criterion described in equation
8: this event only occurred in 2 of 240 experiments performed
on the physical robot described in the main text. In this case, we
selected the highest-performing solution encountered during the
search. This user-deﬁned stopping criterion is not strictly neces-
sary, as the algorithm is guaranteed to stop in the worst case after
every behavior in the map is tested, but it allows a practical limit
on the number of trials performed on the physical robot.

Initiating the Adaptation Step The adaptation step is trig-
gered when the performance drops by a certain amount. The
simplest way to choose that threshold is to let the user specify
it. Automating the selection of this value, and the impact of trig-
gering the algorithm prematurely, is an interesting question for
future research in this area.

Main parameters of MAP-Elites
• parameters in controller: 36
• parameter values (controller): 0 to 1, with 0.05 increments
• size of behavioral space: 6
• possible behavioral descriptors: {0, 0.25, 0.5, 0.75, 1}

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 16

• iterations: 40 million

Main parameters of M-BOA

noise: 0.001

• σ2
• α: 0.9
• ρ: 0.4
• κ: 0.05

1.5 Robotic Arm Experiment

Physical robot The physical robot is a planar robotic arm with
8 degrees of freedom (Extended Data Fig. 7a) and a 1-degree-
of-freedom gripper. The robot has to release a ball into a bin (a
variant of the classic “pick and place” task in industrial robotics).
To assess the position of the gripper, a red cap, placed on top of
the gripper, is tracked with a video camera. The visual tracking
is achieved with the “cmvision” ROS package, which tracks col-
ored blobs (http://wiki.ros.org/cmvision). The eight joints of the
robot are actuated by position-controlled servos manufactured
by Dynamixel. To maximize the reliability of the the arm, the
type of servo is not the same for all the joints: heavy-duty servos
are used near the base of the robot and lighter ones are used for
the end of the arm. The ﬁrst joint, ﬁxed to the base, is moved
by two MX-28 servos mounted in parallel. The second joint is
moved by an MX-64 servo. The 3 subsequent servos are single
MX-28s, and the 3 remaining servos are AX-18s. All the robot’s
joints are limited to a motion range of ±π/2.

Simulator The generation of the behavior-performance map is
made with a simulated robot in the same way as for the hexapod
experiment. For consistency with the simulated hexapod experi-
ments, we used the dynamic (as opposed to kinematic) version of
the simulator, based on the ODE library. Any joint conﬁguration
that resulted in the arm colliding with itself was not added to the
map.

Parametrized controller The controller deﬁnes the target posi-
tion for each joint. The controller is thus parametrized by eight
continuous values from 0 to 1 describing the angle of each joint,
which is mapped to the the total motion range of each joint of
±π/2. The 8 joints are activated simultaneously and are driven
to their target position by internal PID controllers.

We chose this simple control strategy to make the experiments
easy to reproduce and highlight the contribution of Intelligent
Trial & Error for damage recovery. More advanced control strate-
gies, for instance visual servoing7, would be more realistic in a
industrial environment, but they would have made it hard to an-
alyze the experimental results because both Intelligent Trial & Er-
ror and the controller would compensate for damage at the same
time.

Randomly varying the controller’s parameters Each param-
eter of the controller (section “Parametrized controller”) has a
12.5% chance of being changed to any value from 0 to 1, with the
new value chosen from a polynomial distribution as described
on p. 124 of (Deb, 2000), with ηm = 10.0.

Behavioral descriptor Because the most important aspect of
the robot’s behavior in this task is the ﬁnal position of the gripper,
we use it as the behavioral descriptor:

behavioral_descriptor(simu(c)) =

(9)

(cid:21)

(cid:20) xg
yg

where (xg, yg) denotes the position of the gripper once all the
joint have reached their target position.

The size of the working area of the robot is a rectangle measur-
ing 1.4m × 0.7m. For the behavior-performance map, this rect-
angle is discretized into a grid composed of 20000 square cells
(200 × 100). The robot is 62cm long.

Performance function Contrary to the hexapod experiment,
for the robotic arm experiment the performance function for the
behavior-map creation step and for the adaptation step are dif-
ferent. We did so to demonstrate that the two can be different,
and to create a behavior-performance map that would work with
arbitrary locations of the target bin.

For the behavior-performance map generation step (accomplished
via the MAP-Elites algorithm), the performance function cap-
tures the idea that all joints should contribute equally to the
movement. Speciﬁcally, high-performance is deﬁned as minimiz-
ing the variance of the joint angles, that is:

performance(simu(c))) = −

(pi − m)2

(10)

1
8

i=7
(cid:88)

i=0

(cid:80)i=7

where pi is the angular position of joint i (in radians) and m =
1
i=0 pi is the mean of the joint angles. This performance func-
8
tion does not depend on the target. The map is therefore generic:
it contains a high-performing controller for each point of the
robot’s working space.

For the adaptation step (accomplished via the M-BOA algo-
rithm), the behavior-performance map, which is generic to many
tasks, is used for a particular task. To do so, the adaption step has
a different performance measure than the step that creates the
behavior-performance map. For this problem, the predicted per-
formance measure is the Euclidean distance to the target (closer
is better). Speciﬁcally, for each behavior descriptor x in the map,
performance is

P(x) = −||x − b||

(11)

where b is the (x, y) position of the target bin. Note that the
variance of the joint angles, which is used to create the behavior-
performance map, is ignored during the adaptation step.

The performance of a controller on the physical robot is mini-
mizing the Euclidean distance between the gripper (as measured
with the external camera) and the target bin:

performance(physical_robot(C(χ))) = −||xg − b||

(12)

where xg is the position of the physical gripper after all joints
have reached their ﬁnal position, b is the position of the bin, and
C(χ) is the controller being evaluated (χ is the position in simu-
lation that controller reached).

If the gripper reaches a position outside of the working area,
then the camera cannot see the marker. In these rare cases, we set
the performance of the corresponding controller to a low value
(−1 m).

For the control experiments with traditional Bayesian opti-
mization on the physical robot (see Supplementary Experiment
S1), self-collisions are frequent during adaptation, especially
given that we initialize the process with purely random con-
trollers (i.e. random joint angles). While a single self-collision
is unlikely to break the robot, hundreds of them can wear out the
gearboxes because each servo continues to apply a force for a pe-
riod of time until it determines that it cannot move. To minimize
costs, and because we ran 210 independent runs of the algorithm
(14 scenarios × 15 replicates), we ﬁrst tested each behavior in
simulation (taking the damage into account) to check that there
were no self-collisions. If we detected a self-collision, the perfor-
mance for that behavior was set to a low value (−1m).

Auto-collisions are much less likely with Intelligent Trial & Er-
ror because the behavior-performance map contains only con-
trollers that do not self-collide on the undamaged, simulated

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 17

robot. As a consequence, in the Intelligent Trial & Error experi-
ments we did not simulate controllers before testing them on the
physical robot.

Stopping criterion Because the robot’s task is to release a ball
into a bin, the adaptation step can be stopped when the gripper
is above the bin. The bin is circular with a diameter of 10 cm, so
we stopped the adaptation step when the red cap is within 5 cm
of the center of the bin.

Main MAP-Elites parameters for the robotic arm experiment:

• parameters in controller: 8
• controller parameter values: 0 to 1 (continuous)
• dimensions in the behavioral space: 2
• simulated evaluations to create the behavior-performance

map: 20 million

Main M-BOA parameters for the robotic arm experiment:

noise: 0.03

• σ2
• ρ: 0.1
• κ: 0.3

1.6 Selection of parameters

All of the data reported in this section comes from experiments
with the simulated hexapod robot, unless otherwise stated.

Selecting the ρ value For ρ between 0.1 and 0.8, we counted
the number of behaviors from the map that would be inﬂuenced
by a single test on the real hexapod robot (we considered a behav-
ior to be inﬂuenced when its predicted performance was affected
by more than 25% of the magnitude of the update for the tested
behavior): with ρ = 0.2, the update process does not affect any
neighbor in the map, with ρ = 0.4, it affects 10% of the behaviors,
and with ρ = 0.8, it affects 80% of them. Additional values are
shown in Extended Data Fig. 9c.

The previous paragraph describes tests we conducted to de-
termine the number of behaviors in the map affected by different
ρ values, but those experiments do not tell us how different ρ
values affect the performance of the algorithm overall. To assess
that, we then repeated the experiments from the main paper with
a set of possible values (ρ ∈ [0.1 : 0.025 : 0.8]) in simulation (i.e.,
with a simulated, damaged robot), including testing on 6 sepa-
rate damage scenarios (each where the robot loses a different leg)
with all 8 independently generated replicates of the default 6-
dimensional behavior-performance map. The algorithm stopped
if 20 adaptation iterations passed without success according to
the stopping criteria described in the main text and section 1.4:
Stopping criterion. The results reveal that median performance
decreases only modestly, but signiﬁcantly, when the value of ρ
increases: changing ρ from 0.1 to 0.8 only decreases the median
value 12%, from 0.25 m/s to 0.22 m/s (p-value = 9.3 × 10−5 via
Matlab’s Wilcoxon ranksum test, Extended Data Fig. 9b). The
variance in performance, especially at the extreme low end of the
distribution of performance values, is not constant over the range
of explored values. Around ρ = 0.3 the minimum performance
(Extended Data Fig. 9b, dotted red line) is higher than the mini-
mum performance for more extreme values of ρ.

A larger effect of changing ρ is the amount of time required to
ﬁnd a compensatory behavior, which decreases when the value
of ρ increases (Extended Data Fig. 9b). With a ρ value lower than
0.25, the algorithm rarely converges in less than the allotted 20
iterations, which occurs because many more tests are required
to cover all the promising areas of the search space to know if
a higher-performing behavior exists than the best-already-tested.
On the other hand, with a high ρ value, the algorithm updates

its predictions for the entire search space in a few observations:
while fast, this strategy risks missing promising areas of the
search space.

In light of these data, we chose ρ = 0.4 as the default value
for our hexapod experiments because it represents a good trade-
off between a high minimum performance and a low number of
physical tests on the robot. The value of ρ for the robotic arm
experiment has been chosen with the same method.

Selection of the κ value For the hexapod robot experiments,
we chose κ = 0.05. This relatively low value emphasizes ex-
ploitation over exploration. We chose this value because the ex-
ploration of the search space has already been largely performed
the map
during the behavior-performance map creation step:
suggests which areas of the space will be high-performing, and
should thus be tested, and which areas of the space are likely un-
proﬁtable, and thus should be avoided.

For the robotic arm experiments, we chose κ = 0.3, which
emphasizes exploration more, because it experimentally leads to
better results.

1.7 Running time

Computing hardware All computation (on the physical robots
and in simulation) was conducted on a hyperthreaded 16-core
computer (Intel Xeon E5-2650 2.00GHz with 64Gb of RAM).
This computational power is mainly required for the behavior-
performance map creation step. Creating one map for the hexa-
pod experiment took 2 weeks, taking advantage of the fact that
map creation can easily be parallelized across multiple cores.
Map creation only needs to be performed once per robot (or
robot design), and can happen before the robot is deployed. As
such, the robot’s onboard computer does not need to be powerful
enough to create the map.

For the hexapod robot experiment, the most expensive part
of adaptation is the Simultaneous Localization And Mapping
(SLAM) algorithm46,59,60, which measures the distance traveled
on the physical hexapod robot. It is slow because it processes mil-
lions of 3D points per second. It can be run on less powerful com-
puters, but doing so lowers its accuracy because fewer frames per
second can be processed. As computers become faster, it should
be possible to run high-accuracy SLAM algorithms in low-cost,
onboard computers for robots.

The rest of the adaptation step needs much less computational
power and can easily be run on an onboard computer, such as a
smartphone. That is because it takes approximately 15,000 arith-
metic operations between two evaluations on the physical robot,
which requires less than a second or two on current smartphones.

Measuring how long adaptation takes (hexapod robot) The
reported time to adapt includes the time required for the com-
puter to select each test and the time to conduct each test on the
physical robot. Overall, evaluating a controller on the physical
hexapod robot takes about 8 seconds (median 8.03 seconds, 5th
and 95th percentiles [7.95; 8.21] seconds): 0.5-1 second to initial-
ize the robot, 5 seconds during which the robot can walk, 0.5-1
second to allow the robot to stabilize before taking the ﬁnal mea-
surement, and 1-2 seconds to run the SLAM algorithm. Identify-
ing the ﬁrst controller to test takes 0.03 [0.0216; 0.1277] seconds.
The time to select the next controller to test increases depending
on the number of previous experiments because the size of the
Kernel Matrix (K matrix, see Methods and Extended Data Fig. 8),
which is involved in many of the arithmetic operations, grows by
one row and one column per test that has been conducted. For
example, selecting the second test takes 0.15 [0.13; 0.22] seconds,
while the 10th selection takes 0.31 [0.17; 0.34] seconds.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 18

Extended Data Figure 9 | The effect of changing the algorithm’s parameters. (a) The shape of the Matérn kernel function for different values
of the ρ parameter. (b) Performance and required adaptation time obtained for different values of ρ. For each ρ value, the M-BOA algorithm
was executed in simulation with 8 independently generated behavior-performance maps and for 6 different damage conditions (each case where
one leg is missing). (c) The number of controllers in the map affected by a new observation according to different values of the ρ parameter. (d)
The precision of the odometry value. The distances traveled by the physical robot, as measured manually (“real performance”) is compared to the
measurements automatically provided by the simultaneous location and mapping (SLAM) algorithm(“measured performance”). The dashed black
line indicates the hypothetical case where SLAM measurements are error-free and thus are the same as manual measurements. In (b), (c) and (d), the
middle, black lines represent medians and the borders of the shaded areas show the 25th and 75th percentiles. The dotted lines are the minimum and
maximum values. The gray bars show the ρ value chosen for the hexapod experiments in the main text.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 19

2 Supplementary Experiments S1

Additional conditions for the robotic arm

Methods We investigated 11 damage conditions on the physi-
cal robot in addition to the 3 described in the main text (Fig. 3).
We used the same setup as described in the main text (see main
text and section 1.5). Extended Data Fig. 7 shows the 14 scenar-
ios.

For each of the 14 damage scenarios, we replicated experi-
ments on the physical robot with 15 independently generated
behavior-performance maps (210 runs in total). We also repli-
cated control experiments, which consist of traditional Bayesian
optimization directly in the original parameter space (i.e. with-
out behavior-performance maps), 15 times for each of the 14
damage conditions (210 runs in total). For both the experimental
and control treatments, each experiment involved 30 evaluations
on the physical robot (31 if the ﬁrst trial is counted). In many
cases, not all 30 evaluations were required to reach the target, so
we report only the number of trials required to reach that goal.

Results After running the MAP-Elites algorithm for 20 million
evaluations, each of the 15 generated maps contain more than
11, 000 behaviors (11,209 [1,1206; 1,1217] behaviors, Extended
Data Fig. 7c).

In all the generated maps, the regions of different performance
values for behaviors are arranged in concentric shapes resem-
bling cardioids (inverted, heart-shaped curves) that cover the
places the robot can reach (Extended Data Fig. 7c). The black
line drawn over the shown map corresponds to all the positions
of the end-effector for which all the degrees of freedom are set to
the same angle (from −π/4 to +π/4), that is, for the theoretically
highest achievable performance (i.e. the lowest possible variance
in servo angles). The performance of the behaviors tends to de-
crease the further they are from this optimal line.

The adaptation results (Extended Data Fig. 7e) show that the
Intelligent trial and error algorithm manages to reach the goal
of being less than 5 cm from the center of the bin for all the
runs in all the tested scenarios save two (scenarios 11 & 12). For
these two scenarios, the algorithm still reaches the target 60%
and 80% of the time, respectively. For all the damage conditions,
the Intelligent Trial and Error algorithm reaches the target sig-
niﬁcantly more often than the Bayesian optimization algorithm
(p < 10−24). Speciﬁcally, the median number of iterations to
reach the target (Extended Data Fig. 7f) is below 11 iterations
(27.5 seconds) for all scenarios except 11 and 12, for which 31
and 20 iterations are required, respectively. When the robot is not
able to reach the target, the recorded number of iterations is set to
31, which explains why the median number of iterations for the
Bayesian optimization algorithm is equal to 31 for most damage
conditions. For all the damage conditions except one (scenario
11), the Intelligent Trial and Error algorithm used fewer trials to
reach the target than the traditional Bayesian optimization algo-
rithm.

If the robot is allowed to continue its experiment after reach-
ing the 5 cm radius tolerance, for a total of 31 iterations (Extended
Data Fig. 7g), it reaches an accuracy around 1 cm for all the dam-
age conditions except the two difﬁcult ones (scenarios 11 and 12).
This level of accuracy is never achieved with the classic Bayesian
optimization algorithm, whose lowest median accuracy is 2.6cm.
Scenarios 11 and 12 appear to challenge the Intelligent Trial
and Error algorithm. While in both cases the success rate is im-
proved, though not substantially, in case 11 the median accuracy
is actually lower. These results stem from the fact that the dif-
ference between the successful pre-damage and post-damage be-
haviors is so large that the post-damage solutions for both scenar-
ios lie outside of the map. This illustrates a limit of the proposed
approach: if the map does not contain a behavior able to cope

with the damage, the robot will not be able to adapt. This limit
mainly comes from the behavioral descriptor choice: we chose
it because of its simplicity, but it does not capture all of the im-
portant dimensions of variation of the robot. More sophisticated
descriptors are likely to allow the algorithm to cope with such
situations. On the other hand, this experiment shows that with
a very simple behavioral descriptor, using only the ﬁnal position
of the end-effector, our approach is able to deal with a large va-
riety of different target positions and is signiﬁcantly faster than
the traditional Bayesian optimization approach (Extended Data
Fig. 7d, maximum p-value over each time step < 10−16), which
is the current state of the art technique for direct policy search in
robotics32,61,42,17.

3 Supplementary Experiments S2

The contribution of each subcomponent of the
Intelligent Trial and Error Algorithm

Methods The Intelligent Trial and Error Algorithm relies on
three main concepts: (1) the creation of a behavior-performance
map in simulation via the MAP-Elites algorithm, (2) searching
this map with a Bayesian optimization algorithm to ﬁnd behav-
iors that perform well on the physical robot, and (3) initializing
this Bayesian optimization search with the performance predic-
tions obtained via the MAP-Elites algorithm: note that the sec-
ond step could be performed without the third step by searching
through the MAP-Elites-generated behavior-performance map
with Bayesian optimization, but having the initial priors uni-
formly set to the same value. We investigated the contribution
of each of these subcomponents by testing ﬁve variants of our al-
gorithm : in each of them, we deactivated one of these three sub-
components or replaced it with an alternative algorithm from the
literature. We then tested these variants on the hexapod robot.
The variants are as follows:

• Variant 1 (MAP-Elites in 6 dimensions + random search):
evaluates the beneﬁt of searching the map via Bayesian opti-
mization by searching that map with random search instead.
Each iteration, a behavior is randomly selected from the map
and tested on the robot. The best one is kept.

• Variant 2 (MAP-Elites in 6 dimensions + Bayesian optimiza-
tion, no use of priors): evaluates the contribution of initializ-
ing the Gaussian process with the performance predictions
of the behavior-performance map. In this variant, the Gaus-
sian process is initialized with a constant mean (the average
performance of the map: 0.24 m/s) at each location in the
behavior space and a constant variance (the average vari-
ance of the map’s performance: 0.005 m2/s2). As is custom-
ary, the ﬁrst few trials (here, 5) of the Bayesian optimization
process are selected randomly instead of letting the algo-
rithm choose those points, which is known to improve per-
formance.42

• Variant 3 (MAP-Elites in 6 dimensions + policy gradient):
evaluates the beneﬁt of Bayesian optimization compared to
a more classic, local search algorithm17,62; there is no obvious
way to use priors in policy gradient algorithms.

• Variant 4 (Bayesian optimization in the original parameter
space of 36 dimensions): evaluates the contribution of us-
ing a map in a lower-dimensional behavioral space. This
variant searches directly in the original 36-dimensional pa-
rameter space instead of reducing that space to the lower-
dimensional (six-dimensional) behavior space. Thus, in this
variant no map of behaviors is produced ahead of time: the
algorithm searches directly in the original, high-dimensional
space. This variant corresponds to one of the best algorithms
known to learn locomotion patterns32,42. In this variant, the
Gaussian process is initialized with a constant mean set to

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 20

zero and with a constant variance (0.002m2/s2). As de-
scribed above, the ﬁve ﬁrst trials are selected from pure ran-
dom search to prime the Bayesian optimization algorithm42.
• Variant 5 (Policy gradient in the original parameter space of
36 dimensions): a stochastic gradient descent in the original
parameter space62. This approach is a classic reinforcement
learning algorithm for locomotion17 and it is a baseline in
many papers32.

It was necessary to compare these variants in simulation be-
cause doing so on the physical robot would have required
months of experiments and would have repeatedly worn out or
broken the robot. We modiﬁed the simulator from the main ex-
periments (section 1.4: Simulator) to emulate 6 different possible
damage conditions, each of which involved removing a different
leg. For variants in which MAP-Elites creates a map (variants
1, 2 and 3), we used the same maps from the main experiments
(the eight independently generated maps, which were all gener-
ated with a simulation of the undamaged robot): In these cases,
we launched ten replicates of each variant for each of the eight
maps and each of the six damage conditions. There are there-
fore 10 × 8 × 6 = 480 replicates for each of those variants. For
the other variants (4 and 5), we replicated each experiment 80
times for each of the six damage conditions, which also led to
80 × 6 = 480 replicates per variant. In all these simulated ex-
periments, to roughly simulate the distribution of noisy odome-
try measurements on the real robot, the simulated performance
values were randomly perturbed with a multiplicative Gaussian
noise centered on 0.95 with a standard deviation of 0.1.

We analyze the fastest walking speed achieved with each vari-
ant after two different numbers of trials: the ﬁrst case is after 17
trials, which was the maximum number of iterations used by the
Intelligent Trial and Error Algorithm, and the second case is after
150 trials, which is approximately the number of trials used in
previous work62,32,42.

Results After 17 trials on the robot, Intelligent Trial and Error
signiﬁcantly outperforms all the variants (Extended Data Fig. 2b,
p < 10−67, Intelligent Trial and Error performance: 0.26 [0.20;
0.33] m/s), demonstrating that the three main components of the
algorithm are needed to quickly ﬁnd high-performing behaviors.
Among the investigated variants, the random search in the map
performs the best (Variant 1: 0.21 [0.16; 0.27] m/s), followed by
Bayesian optimization in the map (Variant 2: 0.20 [0.13; 0.25]
m/s), and policy gradient in the map (Variant 3: 0.13 [0; 0.23]
m/s). Variants that search directly in the parameter space did
not ﬁnd any working behavior (Variant 4, Bayesian optimiza-
tion: 0.04m/s, [0.01; 0.09]; Variant 5, policy gradient: 0.02 [0; 0.06]
m/s).

There are two reasons that random search performs better than
one might expect. First, the map only contains high-performing
solutions, which are the result of the intense search of the MAP-
Elites algorithm (40 million evaluations in simulation). The map
thus already contains high-performing gaits of nearly every pos-
sible type. Therefore, this variant is not testing random con-
trollers, but is randomly selecting high-performing solutions.
Second, Bayesian optimization and policy gradient are not de-
signed for such a low number of trials: without the priors on per-
formance predictions introduced in the Intelligent Trial and Er-
ror Algorithm, the Bayesian optimization process needs to learn
the overall shape of the search space to model it with a Gaussian
process. 17 trials is too low a number to effectively sample six di-
mensions (for a uniform sampling with only two possible values
in each dimension, 26 = 64 trials are needed; for ﬁve possible
values, 56 = 15, 625 samples are needed). As a consequence,
with this low number of trials, the Gaussian process that models
the performance function is not informed enough to effectively
guide the search. For the policy gradient algorithm, a gradient is
estimated by empirically measuring the partial derivative of the

performance function in each dimension. To do so, following62,
the policy gradient algorithm performs 15 trials at each iteration.
Consequently, when only 17 trials are allowed, it iterates only
once. In addition, policy gradient is a local optimization algo-
rithm that highly depends on the starting point (which is here
chosen randomly), as illustrated by the high variability in the
performance achieved with this variant (Extended Data Fig. 2b).
The issues faced by Bayesian optimization and policy gradi-
ent are exacerbated when the algorithms search directly in the
original, 36-dimensional parameter space instead of the lower-
dimensional (six-dimensional) behavior space of the map. As
mentioned previously, no working controller was found in the
two variants directly searching in this high-dimensional space.

Overall, the analysis after 17 trials shows that:
• The most critical component of the Intelligent Trial and Er-
ror Algorithm is the MAP-Elites algorithm, which reduces
the search space and produces a map of high-performing
behaviors in that space: p < 5 × 10−50 when comparing
variants searching in the behavior-performance map space
vs. variants that search in the original, higher-dimensional
space of motor parameters.

• Bayesian optimization critically improves the search, but
only when it is initialized with the performance obtained in
simulation during the behavior-performance map creation
step (with initialization: 0.26 [0.20; 0.33] m/s, without ini-
tialization: 0.20 [0.13; 0.25] m/s, p = 10−96).

To check whether these variants might perform better if allowed
the number of evaluations typically given to previous state-of-
the-art algorithms62,32,42, we continued the experiments until 150
trials on the robot were conducted (Extended Data Fig. 2c). Al-
though the results for all the variants improved, Intelligent Trial
and Error still outperforms all them (p < 10−94; Intelligent Trial
and Error: 0.31 [0.26; 0.37] m/s, random search: 0.26 [0.22; 0.30]
m/s, Bayesian optimization: 0.25 [0.18; 0.31] m/s, policy search:
0.23 [0.19, 0.29] m/s). These results are consistent with the previ-
ously published results62,32,42,17, which optimize in 4 to 10 dimen-
sions in a few hundred trials. Nevertheless, when MAP-Elites is
not used, i.e. when we run these algorithms in the original 36
dimensions for 150 evaluations, Bayesian optimization and pol-
icy gradient both perform much worse (Bayesian optimization:
0.08 [0.05; 0.12]; policy gradient: 0.06 [0.01; 0.12] m/s). These re-
sults shows that MAP-Elites is a powerful method to reduce the
dimensionality of a search space for learning algorithms, in addi-
tion to providing helpful priors about the search space that speed
up Bayesian optimization.

Overall, these additional experiments demonstrate that each
of the three main components of the Intelligent Trial and Error
Algorithm substantially improves performance. The results also
indicate that Intelligent Trial and Error signiﬁcantly outperforms
previous algorithms for both damage recovery63,12,64,65,66 and gait
learning67,62,68,48,69,32,61,42,17,49, and can therefore be considered the
state of the art.

4 Supplementary Experiments S3

Robustness to environmental changes

Methods The map creation algorithm (MAP-Elites) uses an un-
damaged robot on ﬂat terrain. The main experiments show that
this algorithm provides useful priors for damage recovery on a
ﬂat terrain. In these supplementary experiments, we evaluated,
in simulation, if the map created on ﬂat terrain also provides a
useful starting point for discovering gaits for sloped terrains.

We ﬁrst evaluated the effect slopes have on undamaged robots
(Extended Data Fig. 3a). We launched 10 replicates for each of
the eight maps and each one-degree increment between −20◦
and +20◦, for a total of 10 × 8 × 41 = 3280 experiments. As in

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 21

Supplementary Experiments S2, to roughly simulate the distribu-
tion of noisy odometry measurements on the real robot, we per-
turbed performance values with a multiplicative Gaussian noise
centered on 0.95 with a standard deviation of 0.1.

Results The results show that, when the slope is negative (de-
scending), the Intelligent Trial and Error approach ﬁnds fast gaits
in fewer than than 3 trials. For reference, a hand-designed, clas-
sic, tripod gait (section 1.4) falls on slopes below −15◦ degrees.
When the slope is positive (ascent), Intelligent Trial and Error
ﬁnds slower behaviors, as is expected, but even above 10◦ the
gait learned by Intelligent Trial and Error outperforms the ref-
erence gait on ﬂat ground. Overall, for every slope angle, the
controller found by Intelligent Trial and Error is faster than the
hand-designed reference controller.

We further evaluated damage recovery performance for these
same slopes with the same setup as Experiments S2 (6 damage
conditions). We launched 10 replicates for each damage condi-
tion, for 8 independently generated behavior-performance maps,
and each two-degree increment between −20◦ and +20◦ degrees.
There are therefore 480 replicates for each two-degree increment
between −20◦ and +20◦, for a total of 480 × 21 = 10080 experi-
ments.

Intelligent Trial and Error is not critically affected by variations
of slope between −10◦ and +10◦ (Extended Data Fig. 3b): for
these slopes, and for all 6 damage conditions, Intelligent Trial
and Error ﬁnds fast gaits (above 0.2 m/s) in less than 15 tests
on the robot despite the slope. As expected, it ﬁnds faster gaits
for negative slopes (descent) and slower gaits for positive slopes
(ascent). For slopes below −10◦ and above 10◦, the algorithm
performs worse and requires more trials. These results likely are
caused by the constraints placed on the controller and the lim-
ited sensors on the robot, rather than the inabilities of the algo-
rithm. Speciﬁcally, the controller was kept simple to make the sci-
ence clearer, more intuitive, and more reproducible. Those con-
straints, of course, prevent it from performing the more complex
behaviors necessary to deal with highly sloped terrain. For exam-
ple, the constraints prevent the robot from keeping its legs ver-
tical on sloped ground, which would substantially reduce slip-
page. Nevertheless, the median Intelligent Trial and Error com-
pensatory gait still outperforms the median performance of the
reference gait on all slope angles.

5 Supplementary Experiments S4

Comparison between MAP-Elites and Random
Sampling

Methods The MAP-Elites algorithm is a stochastic search algo-
rithm that attempts to ﬁll a discretized map with the highest-

performing solution at each point in the map. As explained in
the main text, each point in the map represents a different type
of behavior, as deﬁned by the behavioral dimension of the map.
MAP-Elites generates new candidate points by randomly select-
ing a location in the map, changing the parameters of the con-
troller that is stored there, and then saving that controller in the
appropriate map location if it is better than the current occupant
at that location. Intuitively, generating new candidate solutions
from the best solutions found so far should be better than gener-
ating a multitude of controllers randomly and then keeping the
best one found for each location in the map. In this section we
report on experiments that conﬁrm that intuition.

To understand the advantages of MAP-Elites over random
sampling, we compared the two algorithms by generating data
with the simulated hexapod. The experiments have the same vir-
tual robot, environment, controller, performance function, and
behavioral descriptors as in the main experiments (see Methods).
We analyzed the number of cells for which a solution is found (an
indication of the diversity of behavior types the algorithms gen-
erate), the average performance of behaviors in the map, and the
maximum performance discovered.

We replicated each experiment 8 times, each of which included

20 million evaluations on the simulated robot.

Results The results show that the MAP-Elites algorithm out-
performs random sampling on each of these measures (Extended
Data Fig. 10). After 20 million evaluations, about 13000 cells
(median: 12968, 5th & 95th percentiles: [12892; 13018]) are ﬁlled
by MAP-Elites (about 83% percent of the map), whereas random
sampling only ﬁlled approximately 8600 (8624 [8566; 8641]) cells
(about 55% percent of the map) (Extended Data Fig. 10a). The
difference between the two algorithms is large and appears early
(Extended Data Fig. 10a); after only 1 million evaluations, MAP-
Elites ﬁlled 10670 [10511; 10775] cells (68% of the map), whereas
random sampling ﬁlled 5928 [5882; 5966] cells (38% of the map).
The solutions discovered by MAP-Elites are not only more nu-
merous, but also outperform those found by random sampling
(Extended Data Fig. 10b): with MAP-Elites, after 20 million eval-
uations the average performance of ﬁlled cells is 0.22 [0.22; 0.23]
m/s, whereas it is 0.06 [0.06; 0.06] m/s with random sampling,
which is similar to the performance obtained with the reference
controller on a damaged robot (Fig. 3). These two results demon-
strate that MAP-Elites is a much better algorithm than random
sampling to ﬁnd a map of the diverse, “elite” performers in a
search space.

In addition, MAP-Elites is a better optimization algorithm, as
measured by the performance of the best single solution pro-
duced. The performance of the best solution in the map after
20 million evaluations is 0.40 [0.39;0.41] m/s with MAP-Elites,
compared to 0.21 [0.20; 0.22] m/s with random sampling.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 22

Extended Data Figure 10 | Comparing MAP-Elites and random sampling for generating behavior-performance maps. (a) The number of points
in the map for which a behavior is discovered. (b) The mean performance of the behaviors in the map. (c) The maximum performance of the
behaviors in the map. For all these ﬁgures, the middle lines represent medians over 8 independently generated maps and the shaded regions extend
to the 25th and 75th percentiles, even for (a) and (b), where the variance of the distribution is so small that it is difﬁcult to see. See Supplementary
Experiment S4 for methods and analysis.

where ΘT (k), ΨT (k) and ΦT (k) denote the pitch, roll and
yaw angles, respectively, of the robot torso (hence T ) at the
end of interval k, and K denotes the number of 15ms in-
tervals during the 5 seconds of simulated movement (here,
K = 5s/0.015s ≈ 334). The unit step function U (·) returns
1 if its argument exceeds 0, and returns 0 otherwise. To dis-
count for insigniﬁcant motion around 0 rad, orientation an-
gles are only deﬁned as positive if they exceed 0.5% of π rad.
Similarly, orientation angles are only deﬁned as negative if
they are less than −0.5% of π rad.

3. Displacement (6-dimensional): This behavioral descriptor
characterizes changes in the postion of the robot during
It is measured as the proportion of 15ms inter-
walking.
vals that the robot is positively or negatively displaced along
each of the x, y, and z axes:

x =











(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)

1
K
1
K
1
K
1
K
1
K
1
K

k U (∆x(k) − 0.001)
k U (−∆x(k) − 0.001)
k U (∆y(k) − 0.001)
k U (−∆y(k) − 0.001)
k U (∆z(k) − 0.001)
k U (−∆z(k) − 0.001)











(15)

where [∆x(k), ∆y(k), ∆z(k)] denote the linear displacement
in meters of the robot during interval k, and K denotes the
number of 15ms intervals during 5 seconds of simulated
movement (here, K = 5s/0.015s ≈ 334). The unit step func-
tion U (·) returns a value of 1 if its argument exceeds 0, and
returns a value of 0 otherwise. To ignore insigniﬁcant mo-
tion, linear displacements are deﬁned to be positive if they
exceed 1mm, and are deﬁned to be negative if they are less
than −1mm.

6 Supplementary Experiments S5

Alternative behavioral descriptors

Methods To create a map with MAP-Elites, one has to deﬁne
the dimensions of the behavioral space, i.e. the behavioral de-
scriptors. The main experiments show that using a predeﬁned
behavioral descriptor (the proportion of time that each leg of a
hexapod robot is in contact with the ground, i.e. the duty factor)
creates a map that provides useful priors for damage recovery.

This section describes how we tested (in simulation) how per-
formance is affected by alternative behavioral descriptors, in-
cluding descriptors that have a different number of dimensions.
We also evaluated how performance is affected if the behavioral
descriptors are randomly selected from a large list of potential
descriptors. This test simulates the algorithm’s performance if
the behavioral descriptors are chosen without insight into the
problem domain.

The behavioral descriptors we tested are as follows:
1. Duty factor (6-dimensional): This descriptor is the default
one from the main experiment. It corresponds to the pro-
portion of time each leg is in contact with the ground:







x =

(cid:80)

t C1(t)
numTimesteps

...

(cid:80)

t C6(t)
numTimesteps







where Ci(t) denotes the Boolean value of whether leg i is in
contact with the ground at time t (1: contact, 0: no contact).
2. Orientation (6-dimensional): This behavioral descriptor
characterizes changes in the angular position of the robot
during walking, measured as the proportion of 15ms inter-
vals that each of the pitch, roll and yaw angles of the robot
frame are positive (three dimensions) and negative (three
additional dimensions):

x =











1
K
1
K
1
K
1
K
1
K
1
K

(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)
(cid:80)

k U (ΘT (k) − 0.005π)
k U (−ΘT (k) − 0.005π)
k U (ΨT (k) − 0.005π)
k U (−ΨT (k) − 0.005π)
k U (ΦT (k) − 0.005π)
k U (−ΦT (k) − 0.005π)











(13)

(14)

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 23

4. Total energy expended per leg (6-dimensional): This be-
havioral descriptor captures the total amount of energy ex-
pended to move each leg during 5 seconds of movement:







E1
ME

...







x =

E6
ME
where Ei denotes the energy utilized by leg i of the robot
during 5 seconds of simulated movement, measured in
N.m.rad. ME is the maximum amount of energy available
according to the servo model of the simulator, which for 5
seconds is 100 N.m.rad.

5. Relative energy expended per leg (6-dimensional): This be-
havioral descriptor captures the amount of energy expended
to move each leg relative to the energy expended by all the
legs during 5 seconds of simulated movement:







x =

(cid:80)

E1
i=1..6 Ei

...

(cid:80)

E6
i=1..6 Ei







(17)

where Ei denotes the energy utilized by leg i of the robot
during 5 seconds of simulated movement, measured in
N.m.rad.

6. Deviation (3-dimensional): This descriptor captures the
range of deviation of the center of the robot frame versus
the expected location of the robot if it traveled in a straight
line at a constant speed.

(cid:18)

x =

0.95

max
t

(y(t)−

yﬁnal

0.2
5 ×t)−min
0.2

t

(y(t)−

(cid:19)

yﬁnal

5 ×t)

(18)










(cid:18)

0.95

max
t

(x(t))−min

(x(t))

(cid:19)

(cid:19)

t

t

(cid:18)

0.95

max
t

(z(t))−min

(z(t))

0.2










where [x(t), y(t), z(t)] denote the position of robot’s center
at time t, and [xﬁnal, yﬁnal, zﬁnal] denote its ﬁnal position after
5 seconds.
The robot’s task is to move along the y-axis. Its starting po-
sition is (0,0,0). The deviation along the x and z axes is com-
puted as the maximum difference in the robot’s position in
those dimensions at any point during 5 seconds. For the y
axis, yﬁnal
corresponds to the average speed of the robot (the
5
distance covered divided by total time), therefore yﬁnal
5 × t is
the expected position at timestep t if the robot was moving
at constant speed. The deviation from the y axis is computed
with respect to this “theoretical” position.
To obtain values in the range [0,1], the ﬁnal behavioral de-
scriptors are multiplied by 0.95 and then divided by 20 cm
(these values were determined empirically).

7. Total ground reaction force per leg (6-dimensional): This be-
havioral descriptor corresponds to the amount of force each
leg applies to the ground, measured as a fraction the to-
tal possible amount of force that a leg could apply to the
ground. Speciﬁcally, the measurement is

x =













F1
MF

...

F6
MF

(19)

where Fi denotes the ground reaction force (GRF) each leg
i generates, averaged over 5 seconds of simulated move-
ment. MF is the maximum such force that each leg can ap-
ply, which is 10N.

(16)

8. Relative ground reaction force per leg (6-dimensional): This
behavioral descriptor corresponds to the amount of force
each leg applies to the ground, relative to that of all the legs:







x =

(cid:80)

F1
i=1..6 Fi

...

(cid:80)

F6
i=1..6 Fi







x =















(cid:80)

1 (t)

t ΘL
π×N1
...
t ΘL
π×N6

(cid:80)

6 (t)

x =








(cid:80)

1 (t)

t ΨL
π×N1
...
t ΨL
π×N6

(cid:80)

6 (t)








where Fi denotes the ground reaction force (GRF) each leg i
generates, averaged over 5 seconds of simulated movement.
9. Lower-leg pitch angle (6-dimensional): This descriptor cap-
tures the pitch angle for the lower-leg with respect to the
ground (in a global coordinate frame), averaged over 5 sec-
onds:

where ΘL
i (t) is the pitch angle of lower-leg i (hence the L in
ΘL
i ) when it is in contact with the ground at time t, and Ni is
the number of time-steps for which lower-leg i touches the
ground. The foot pitch angles are in range [0, π] (as the leg
can not penetrate the ground) and normalized to [0, 1].
10. Lower-leg roll angle (6-dimensional): This descriptor cap-
tures the roll angle for the lower-leg with respect to the
ground (in a global coordinate frame), averaged over 5 sec-
onds:

where ΨL
i (t) is the roll angle of lower-leg i (hence L in ΨL
i )
when it is in contact with the ground at time t, and Ni is
the number of time-steps for which lower-leg i touches the
ground. The foot roll angles are in range [0, π] (as the leg can
not penetrate the ground) and normalized to [0, 1].

11. Lower-leg yaw angle (6-dimensional): This descriptor cap-
tures the yaw angle for the lower-leg with respect to the
ground (in a global coordinate frame), averaged over 5 sec-
onds:

x =








(cid:80)

1 (t)+π

t ΦL
2π×N1
...
t ΦL
2π×N6

(cid:80)

6 (t)+π








where ΦL
i (t) is the yaw angle of lower-leg i (hence L in ΦL
i )
when it is in contact with the ground at time t,and Ni is
the number of time-steps for which lower-leg i touches the
ground. The foot yaw angles are in range [−π, π] and are
normalized to [0, 1].

(20)

(21)

(22)

(23)

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 24

12. Random (6-dimensional): The random behavioral descrip-
tor differs from the other intentionally chosen descriptors
in that it does not consist of one type of knowledge, but
is instead randomly selected as a subset of variables from
the previously described 11 behavioral descriptors. This de-
scriptor is intended to simulate a situation in which one has
little expectation for which behavioral descriptor will per-
form well, so one quickly picks a few different descriptor
dimensions without consideration or experimentation. In-
stead of generating one such list in this fashion, we ran-
domly sample from a large set to ﬁnd the average perfor-
mance of this approach over many different possible choices.
For the random descriptor, each of the 6-dimensions is se-
lected at random (without replacement) from the 1×3+10×
6 = 63 available behavior descriptor dimensions described
in the previous 11 descriptors (1 of the above descriptors is
three-dimensional and the other 10 are six-dimensional):

x =











R1
...
R6

(24)

where Ri denotes the ith dimension of the descriptor, ran-
domly selected uniformly and without replacement from the
63 available dimensions in behavior descriptors 1-11.

It was necessary to compare these behavioral descriptors in
simulation because doing so on the physical robot would have re-
quired months of experiments and would have repeatedly worn
out or broken the robot. We modiﬁed the simulator from the
main experiments (section 1.4) to emulate 6 different possible
damage conditions, each of which involved removing a differ-
ent leg. The MAP-Elites algorithm, run for 3 million iterations,
was used to create the behavior-performance maps for each of
the behavioral descriptors (using a simulation of the undamaged
robot). During the generation of the behavior-performance maps,
the behaviors were stored in the map’s cells by discretizing each
dimension of the behavioral descriptor space with these ﬁve val-
ues: {0, 0.25, 0.5, 0.75, 1} for the 6-dimensional behavioral de-
scriptors, and with twenty equidistant values between [0, 1] for
the 3-dimensional behavioral descriptor. During the adaptation
phase, the behaviors were used with their actual values and thus
not discretized.

We independently generated eight maps for each of the 11
intentionally chosen behavioral descriptors. Twenty indepen-
dently generated maps were generated for the random behav-
ioral descriptor. We launched ten replicates of each descriptor for
each of the maps (eight for intentionally chosen behavioral de-
scriptors and twenty for random behavioral descriptor) and each
of the six damage conditions. There are therefore 10×8×6 = 480
replicates for each of the intentionally chosen descriptors, and
10 × 20 × 6 = 1200 replicates for the random descriptor.
In
all these simulated experiments, to roughly simulate the distri-
bution of noisy odometry measurements on the real robot, the
simulated performance values were randomly perturbed with a
multiplicative Gaussian noise centered on 0.95 with a standard
deviation of 0.1.

We analyze the fastest walking speed achieved with each be-
havioral descriptor after two different numbers of trials: the ﬁrst
case is after 17 trials, and the second case is after 150 trials.

Results The following results include 17 trials on the simulated
robot, which was the maximum number of trials required for In-
telligent Trial and Error to ﬁnd a compensatory gait in the Sup-
plementary Experiment S2. The post-adaptation performance

achieved with our alternative, intentionally chosen behavioral
descriptors (numbers 2-11) was similar to the original duty factor
behavioral descriptor (number 1) (Extended Data Fig. 4a). All 11
alternative, intentionally chosen descriptors (numbers 2-11) led
to a median performance within 17% of the duty factor descrip-
tor (performance: 0.241 [0.19; 0.29] m/s). The difference in per-
formance was effectively nonexistent with the deviation descrip-
tor (0.241 [0.14; 0.31] m/s), the total GRF descriptor (0.237 [0.15;
0.30] m/s), and the lower-leg roll angle descriptor (0.235 [0.14;
0.31] m/s). The lowest performance was discovered with the rel-
ative GRF descriptor (16.7% lower than the duty factor descrip-
tor, 0.204 [0.08; 0.31] m/s).
In terms of statistical signiﬁcance,
the performance achieved with the duty factor descriptor was no
different from the deviation (p = 0.53) and total GRF (p = 0.29)
descriptors. With all the remaining descriptors, the difference in
performance was statistically signiﬁcant (p < 10−3), but it did
not exceed 0.04m/s. Additionally, the compensatory behaviors
discovered with all our 11 alternative, intentionally chosen de-
scriptors were always faster than the reference gait for all damage
conditions.

To check whether our alternative, intentionally chosen behav-
ioral descriptors lead to better performance if allowed a higher
number of evaluations, we extended the experiments to 150 tri-
als on the robot (Extended Data Fig. 4b). After 150 trials, the dif-
ference in performance between the duty factor behavioral de-
scriptor (0.277 [0.24; 0.34] m/s) and our alternative behavioral
descriptors was further reduced. For all but three alternative,
intentionally chosen descriptors (displacement, total GRF and
lower-leg yaw angle), the median performance was within 4% of
the duty factor descriptor. The difference in performance was at
±3.6% with the orientation (0.274 [0.22; 0.32] m/s), total energy
(0.274 [0.19; 0.33] m/s), relative energy (0.273 [0.20; 0.32] m/s),
deviation (0.287 [0.21; 0.34] m/s), relative GRF (0.266 [0.15; 0.35]
m/s), lower-leg pitch angle (0.271 [0.21; 0.34] m/s) and lower-
leg roll angle (0.268 [0.17; 0.34] m/s) descriptors.
In the three
remaining behavioral descriptors, displacement, total GRF, and
lower-leg yaw angle, the performance was 0.264 [0.18; 0.32] m/s,
0.299 [0.25; 0.35] m/s and 0.255 [0.18; 0.32] m/s, respectively (dif-
ference at ±7.8% of duty factor descriptor in all three cases). In
terms of statistical signiﬁcance, the performance achieved with
the duty factor descriptor was barely statistically signiﬁcantly
different from the deviation descriptor (p = 0.041). In all the re-
maining descriptors, the performance difference was statistically
signiﬁcant (p < 10−2), but no larger than 0.02m/s.

Our random behavioral descriptor also performed similarly to
the duty factor descriptor. After 17 trials, the performance of
M-BOA with the maps generated by the random descriptor was
0.232 [0.14; 0.30] m/s (4.2% lower than the duty factor descrip-
tor performance). While the difference is statistically signiﬁcant
(p < 10−3), the difference in performance itself was negligible at
0.01m/s. This difference in performance was further reduced to
3.6% after 150 trials (random descriptor performance: 0.274 [0.21;
0.34] m/s, duty factor description performance: 0.277 [0.24; 0.34]
m/s, p = 0.002). Moreover, as with the intentionally chosen be-
havioral descriptors, the compensatory behavior discovered with
the random descriptor was also faster than the reference gait.

These experiments show that the selection of the behavioral
dimensions is not critical to get good results. Indeed, all tested
behavioral descriptors, even those randomly generated, perform
well (median > 0.20 m/s after 17 trials). On the other hand, if
the robot’s designers have some prior knowledge about which
dimensions of variation are likely to reveal different types of be-
haviors, the algorithm can beneﬁt from this knowledge to further
improve results (as with the duty factor descriptor).

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 25

7 Caption for Supplementary Videos

Video S1

This video can be viewed at: https://youtu.be/T-c17RKh3uE
Damage Recovery in Robots via Intelligent Trial and Error.
The video shows the Intelligent Trial and Error Algorithm in ac-
tion with the two robots introduced in this paper: the hexapod
robot and the 8 degrees of freedom robotic arm (Fig. 3). The
video shows several examples of the different types of behav-
iors that are produced during the behavior-performance map cre-
ation step, from classic hexapod gaits to more unexpected forms
of locomotion. Then, it shows how the hexapod robot uses that
behavior-performance map to deal with a leg that has lost power
(Fig. 3a:C3). Finally, the video illustrates how the Intelligent Trial
and Error Algorithm can be applied to the second robot and to
different damage conditions.

Video S2

This video can be viewed at: http://youtu.be/ycLspV5lXK8
A Behavior-Performance Map Containing Many Different
Types of Walking Gaits. In the behavior-performance map cre-
ation step, the MAP-Elites algorithm produces a collection of dif-
ferent types of walking gaits. The video shows several examples
of the different types of behaviors that are produced, from classic
hexapod gaits to more unexpected forms of locomotion.

Supplementary References

30. A. E. Eiben and J. E. Smith. Introduction to evolutionary computing. Springer,

31.

2003.
J.-B. Mouret and J. Clune. “Illuminating search spaces by mapping elites”.
In: arXiv preprint arXiv:1504.04909 (2015).

32. D. J. Lizotte, T. Wang, M. H. Bowling, and D. Schuurmans. “Automatic Gait
Optimization with Gaussian Process Regression.” In: Proceedings of the the
International Joint Conference on Artiﬁcial Intelligence (IJCAI). Vol. 7. 2007,
pp. 944–949.

34.

33. E. Brochu, V. M. Cora, and N. De Freitas. “A tutorial on Bayesian optimization
of expensive cost functions, with application to active user modeling and hi-
erarchical reinforcement learning”. In: arXiv preprint arXiv:1012.2599 (2010).
J. Snoek, H. Larochelle, and R. P. Adams. “Practical Bayesian Optimization
of Machine Learning Algorithms”. In: Advances in Neural Information Pro-
cessing Systems 25 (NIPS). 2012, pp. 2951–2959.
T. L. Grifﬁths, C. Lucas, J. Williams, and M. L. Kalish. “Modeling human func-
tion learning with Gaussian processes”. In: Advances in Neural Information
Processing Systems 21 (NIPS). 2009, pp. 553–560.

35.

36. A. J. Booker, J. E. Dennis Jr, P. D. Frank, D. B. Seraﬁni, V. Torczon, and M.
W. Trosset. “A rigorous framework for optimization of expensive functions by
surrogates”. In: Structural optimization 17.1 (1999), pp. 1–13.

39.

37. A. I. J. Forrester and A. J. Keane. “Recent advances in surrogate-based op-
timization”. In: Progress in Aerospace Sciences 45.1 (2009), pp. 50–79.
38. Y Jin. “Surrogate-assisted evolutionary computation: Recent advances and
future challenges”. In: Swarm and Evolutionary Computation 1.2 (2011),
pp. 61–70.
T. W. Simpson, T. M. Mauery, J. J. Korte, and F. Mistree. “Comparison of re-
sponse surface and kriging models for multidisciplinary design optimization”.
In: American Institute of Aeronautics and Astronautics 98.7 (1998), pp. 1–16.
40. D. R. Jones, M. Schonlau, and W. J. Welch. “Efﬁcient global optimization
of expensive black-box functions”. In: Journal of Global optimization 13.4
(1998), pp. 455–492.
J. Sacks, W. J. Welch, T. J. Mitchell, H. P. Wynn, et al. “Design and analysis
of computer experiments”. In: Statistical science 4.4 (1989), pp. 409–423.

41.

42. R. Calandra, A. Seyfarth, J. Peters, and M. P. Deisenroth. “An experimen-
tal comparison of Bayesian optimization for bipedal
locomotion”. In: Pro-
ceedings of the IEEE International Conference on Robotics and Automation
(ICRA). 2014.

43. B. Matérn et al. “Spatial variation. Stochastic models and their application
to some problems in forest surveys and other sampling investigations.” In:
Meddelanden fran statens Skogsforskningsinstitut 49.5 (1960).

44. M. L. Stein. Interpolation of spatial data: some theory for kriging. Springer,

1999.

45. A. V. Fiacco and G. P. McCormick. Nonlinear programming: sequential un-

46.

constrained minimization techniques. Vol. 4. Siam, 1990.
I. Dryanovski, R. G. Valenti, and J. Xiao. “Fast visual odometry and mapping
from rgb-d data”. In: Proceedings of the IEEE International Conference on
Robotics and Automation (ICRA). IEEE. 2013, pp. 2305–2310.

49.

47. M. Quigley, K. Conley, B. P. Gerkey, J. Faust, T. Foote, J. Leibs, R. Wheeler,
and A. Y. Ng. “ROS: an open-source Robot Operating System”. In: Proceed-
ings of ICRA’s workshop on Open Source Software. 2009.

48. A. Sproewitz, R. Moeckel, J. Maye, and A. Ijspeert. “Learning to move in
modular robots using central pattern generators and online optimization”. In:
The International Journal of Robotics Research 27.3-4 (2008), pp. 423–443.
J. Yosinski, J. Clune, D. Hidalgo, S. Nguyen, J. Zagal, and H. Lipson. “Evolv-
ing Robot Gaits in Hardware: the HyperNEAT Generative Encoding Vs. Pa-
rameter Optimization”. In: Proceedings of ECAL (2011), pp. 890–897.
J. Clune, K. Stanley, R. Pennock, and C. Ofria. “On the performance of indi-
rect encoding across the continuum of regularity”. In: IEEE Transactions on
Evolutionary Computation 15.3 (2011), pp. 346–367.
J. Clune, B. Beckmann, C. Ofria, and R. Pennock. “Evolving coordinated
quadruped gaits with the HyperNEAT generative encoding”. In: Proceedings
of the IEEE Congress on Evolutionary Computation. 2009, pp. 2764–2771.

51.

50.

52. S. Lee, J. Yosinski, K. Glette, H. Lipson, and J. Clune. “Evolving gaits for
physical robots with the HyperNEAT generative encoding: the beneﬁts of sim-
ulation.” In: Applications of Evolutionary Computing. Springer, 2013.
53. D. Wilson. “Insect walking”. In: Annual Review of Entomology 11.1 (1966),

pp. 103–122.

54. U. Saranli, M. Buehler, and D. Koditschek. “Rhex: A simple and highly mo-
bile hexapod robot”. In: The International Journal of Robotics Research 20.7
(2001), pp. 616–631.
J. Schmitz, J. Dean, T. Kindermann, M. Schumm, and H. Cruse. “A biolog-
ically inspired controller for hexapod walking: simple solutions by exploiting
physical properties”. In: The biological bulletin 200.2 (2001), pp. 195–200.

55.

56. X. Ding, Z. Wang, A. Rovetta, and J. Zhu. “Locomotion analysis of hexa-
pod robot”. In: Proceedings of Conference on Climbing and Walking Robots
(CLAWAR) (2010), pp. 291–310.

57. S. Steingrube, M. Timme, F. Wörgötter, and P. Manoonpong. “Self-organized
adaptation of a simple neural circuit enables complex robot behaviour”. In:
Nature Physics 6.3 (2010), pp. 224–230.
F. Delcomyn. “The Locomotion of the Cockroach Pariplaneta americana”. In:
Journal of Experimental Biology 54.2 (1971), pp. 443–452.

58.

59. S. Thrun, W. Burgard, D. Fox, et al. Probabilistic robotics. MIT press Cam-

bridge, 2005.

60. M. G. Dissanayake, P. Newman, S. Clark, H. F. Durrant-Whyte, and M.
Csorba. “A solution to the simultaneous localization and map building
(SLAM) problem”. In: IEEE Transactions on Robotics and Automation 17.3
(2001), pp. 229–241.

61. M. Tesch, J. Schneider, and H. Choset. “Using response surfaces and ex-
pected improvement to optimize snake robot gait parameters”. In: Proceed-
ings of the IEEE/RSJ International Conference on Intelligent Robots and Sys-
tems (IROS). IEEE. 2011, pp. 1069–1074.

62. N. Kohl and P. Stone. “Policy gradient reinforcement

learning for fast
quadrupedal locomotion”. In: Proceedings of the IEEE International Confer-
ence on Robotics and Automation (ICRA). Vol. 3. IEEE. 2004, pp. 2619–
2624.

63. M. S. Erden and K. Leblebicio ˘glu. “Free gait generation with reinforcement
learning for a six-legged robot”. In: Robotics and Autonomous Systems 56.3
(2008), pp. 199–212.

64. D. J. Christensen, J. C. Larsen, and K. Stoy. “Fault-tolerant gait learning and
morphology optimization of a polymorphic walking robot”. In: Evolving Sys-
tems 5 (2014), pp. 21–32.

65. S. Mahdavi and P. Bentley. “Innately adaptive robotics through embodied

evolution”. In: Autonomous Robots 20.2 (2006), pp. 149–163.

66. S. Koos, A. Cully, and J.-B. Mouret. “Fast damage recovery in robotics with
the T-resilience algorithm”. In: The International Journal of Robotics Re-
search 32.14 (2013), pp. 1700–1723.

67. G. Hornby, S. Takamura, T. Yamamoto, and M. Fujita. “Autonomous evolu-
tion of dynamic gaits with two quadruped robots”. In: IEEE Transactions on
Robotics 21.3 (2005), pp. 402–410.
T. Barfoot, E. Earon, and G. D’Eleuterio. “Experiments in learning distributed
control for a hexapod robot”. In: Robotics and Autonomous Systems 54.10
(2006), pp. 864–872.

68.

69. S. Koos, J.-B. Mouret, and S. Doncieux. “The transferability approach: Cross-
ing the reality gap in evolutionary robotics”. In: IEEE Transactions on Evolu-
tionary Computation 17.1 (2013), pp. 122–145.

Cully, Clune, Tarapore, and Mouret. 2015

arXiv preprint | 26

