From the Proceedings of EACL 2017 (Valencia, Spain). This version includes slightly more information

than the published version (January, 2017).

An Incremental Parser for Abstract Meaning Representation

Marco Damonte
School of Informatics
University of Edinburgh
m.damonte@sms.ed.ac.uk

Shay B. Cohen
School of Informatics
University of Edinburgh
scohen@inf.ed.ac.uk

Giorgio Satta
Dept. of Information Engineering
University of Padua
satta@dei.unipd.it

7
1
0
2
 
r
p
A
 
0
1
 
 
]
L
C
.
s
c
[
 
 
5
v
1
1
1
6
0
.
8
0
6
1
:
v
i
X
r
a

Abstract

Abstract Meaning Representation (AMR)
is a semantic representation for natural
language that embeds annotations related
to traditional tasks such as named entity
recognition, semantic role labeling, word
sense disambiguation and co-reference
resolution. We describe a transition-based
parser for AMR that parses sentences left-
to-right, in linear time. We further pro-
pose a test-suite that assesses speciﬁc sub-
tasks that are helpful in comparing AMR
parsers, and show that our parser is com-
petitive with the state of the art on the
LDC2015E86 dataset and that it outper-
forms state-of-the-art parsers for recover-
ing named entities and handling polarity.

1 Introduction

Semantic parsing aims to solve the problem
of canonicalizing language and representing its
meaning: given an input sentence, it aims to ex-
tract a semantic representation of that sentence.
Abstract meaning representation (Banarescu et al.,
2013), or AMR for short, allows us to do that
with the inclusion of most of the shallow-semantic
natural language processing (NLP) tasks that are
usually addressed separately, such as named en-
tity recognition, semantic role labeling and co-
reference resolution. AMR is partially motivated
by the need to provide the NLP community with
a single dataset that includes basic disambiguation
information, instead of having to rely on differ-
ent datasets for each disambiguation problem. The
annotation process is straightforward, enabling the
development of large datasets.

Several parsers for AMR have been recently de-
veloped (Flanigan et al., 2014; Wang et al., 2015a;
Peng et al., 2015; Pust et al., 2015; Goodman
et al., 2016; Rao et al., 2015; Vanderwende et
al., 2015; Artzi et al., 2015; Barzdins and Gosko,
2016; Zhou et al., 2016). This line of research
is new and current results suggest a large room
for improvement. Greedy transition-based meth-
ods (Nivre, 2008) are one of the most popular
choices for dependency parsing, because of their
good balance between efﬁciency and accuracy.
These methods seem promising also for AMR,
due to the similarity between dependency trees
and AMR structures, i.e., both representations use
graphs with nodes that have lexical content and
edges that represent linguistic relations.

A transition system is an abstract machine char-
acterized by a set of conﬁgurations and transitions
between them. The basic components of a con-
ﬁguration are a stack of partially processed words
and a buffer of unseen input words. Starting from
an initial conﬁguration, the system applies tran-
sitions until a terminal conﬁguration is reached.
The sentence is scanned left to right, with linear
time complexity for dependency parsing. This is
made possible by the use of a greedy classiﬁer that
chooses the transition to be applied at each step.

In this paper we introduce a parser for AMR that
is inspired by the ARCEAGER dependency tran-
sition system of Nivre (2004). The main differ-
ence between our system and ARCEAGER is that
we need to account for the mapping from word
tokens to AMR nodes, non-projectivity of AMR
structures and reentrant nodes (multiple incom-
ing edges). Our AMR parser brings closer depen-
dency parsing and AMR parsing by showing that
dependency parsing algorithms, with some mod-
iﬁcations, can be used for AMR. Key properties

such as working left-to-right, incrementality1 and
linear complexity further strengthen its relevance.
The AMR parser of Wang et al. (2015a), called
CAMR, also deﬁnes a transition system. It differs
from ours because we process the sentence left-to-
right while they ﬁrst acquire the entire dependency
tree and then process it bottom-up. More recently
Zhou et al. (2016) presented a non-greedy tran-
sition system for AMR parsing, based on ARC-
STANDARD (Nivre, 2004). Our transition sys-
tem is also related to an adaptation of ARCEAGER
for directed acyclic graphs (DAGs), introduced by
Sagae and Tsujii (2008). This is also the basis
for Ribeyre et al. (2015), a transition system used
to parse dependency graphs. Similarly, Du et al.
(2014) also address dependency graph parsing by
means of transition systems. Analogously to de-
pendency trees, dependency graphs have the prop-
erty that their nodes consist of the word tokens,
which is not true for AMR. As such, these transi-
tion systems are more closely related to traditional
transition systems for dependency parsing.

Our contributions in this paper are as follows:

• In §3 we develop a left-to-right, linear-time
transition system for AMR parsing, inspired
by the ARCEAGER transition system for de-
pendency tree parsing;

• In §5 we claim that the Smatch score (Cai
and Knight, 2013) is not sufﬁcient to evalu-
ate AMR parsers and propose a set of metrics
to alleviate this problem and better compare
alternative parsers;

• In §6 we show that our algorithm is compet-
itive with publicly available state-of-the-art
parsers on several metrics.

2 Background and Notation

AMR Structures AMRs are rooted and directed
graphs with node and edge labels. An annotation
example for the sentence I beg you to excuse me is
shown in Figure 1, with the AMR graph reported
in Figure 2.

Concepts are represented as labeled nodes in
the graph and can be either English words (e.g. I
and you) or Propbank framesets (e.g. beg-01 and
excuse-01). Each node in the graph is assigned to

1Strictly speaking,

transition-based parsing cannot
achieve full incrementality, which requires to have a single
connected component at all times (Nivre, 2004).

( b / beg-01

i

/

:ARG0 ( i
:ARG1 ( y / you)
:ARG2 ( e / excuse-01

:ARG0 y
:ARG1 i ) )

Figure 1: Annotation for the sentence “I beg you to
excuse me.” Variables are in boldface and concepts
and edge labels are in italics.

:top

beg-01

:ARG1

:ARG0

i

:ARG1

:ARG2

you

:ARG0

excuse-01

Figure 2: AMR graph representation for Figure 1.

a variable in the AMR annotation so that a variable
re-used in the annotation corresponds to reentran-
cies (multiple incoming edges) in the graph. Rela-
tions are represented as labeled and directed edges
in the graph.

Notation For most sentences in our dataset, the
AMR graph is a directed acyclic graph (DAG),
with a few speciﬁc cases where cycles are permit-
ted. These cases are rare, and for the purpose of
this paper, we consider AMR as DAGs.

We denote by [n] the set {1, . . . , n}. We deﬁne
an AMR structure as a tuple (G, x, π), where x =
x1 · · · xn is a sentence, with each xi, i ∈ [n], a
word token, and G is a directed graph G = (V, E)
with V and E the set of nodes and edges, respec-
tively.2 We assume G comes along with a node
labeling function and an edge labeling function.
Finally, π : V → [n] is a total alignment function
that maps every node of the graph to an index i
for the sentence x, with the meaning that node v
represents (part of) the concept expressed by the
word xπ(v).3

2We collapse all multi-word named entities in a single to-
ken (e.g., United Kingdom becomes United Kingdom) both
in training and parsing.

3π is a function because we do not consider co-references,
which would otherwise cause a node to map to multiple in-
dices. This is in line with current work on AMR parsing.

We note that the function π is not invertible,
since it is neither injective nor surjective. For each
i ∈ [n], we let

π−1(i) = {v | v ∈ V, π(v) = i}

be the pre-image of i under π (this set can be
empty for some i), which means that we map a to-
ken in the sentence to a set of nodes in the AMR.
In this way we can align each index i for x to the
induced subgraph of G. More formally, we deﬁne

←−π (i) = (π−1(i), E ∩ (π−1(i) × π−1(i))),

(1)

with the node and edge labeling functions of ←−π (i)
inherited from G. Hence, ←−π (i) returns the AMR
subgraph aligned with a particular token in the
sentence.

2.1 Transition-Based AMR Parsing

Similarly to dependency parsing, AMR parsing is
partially based on the identiﬁcation of predicate-
argument structures. Much of the dependency
parsing literature focuses on transition-based de-
pendency parsing—an approach to parsing that
scans the sentence from left to right in linear time
and updates an intermediate structure that eventu-
ally ends up being a dependency tree.

The two most common transition systems for
greedy dependency parsing are ARCSTANDARD
and ARCEAGER. With ARCSTANDARD, a stack
is maintained along with a buffer on which the
left-to-right scan is performed. At each step, the
parser chooses to scan a word in the buffer and
shift it onto the stack, or else to create an arc
between the two top-most elements in the stack
and pop the dependent. ARCSTANDARD parses
a sentence in a pure bottom-up, left-to-right fash-
ion (similarly to shift-reduce context-free gram-
mar parsers), and must delay the construction of
right arcs until all the dependent node has been
completed. This imposes strong limitations on
the degree of incrementality of the parser. The
ARCEAGER system was designed to improve on
ARCSTANDARD by mixing bottom up and top-
down strategies. More precisely, in the ARCEA-
GER parser left arcs are constructed bottom-up and
right arcs are constructed top-down, so that right
dependents can be attached to their heads even if
some of their own dependents are not identiﬁed
yet. In this way arcs are constructed as soon as the
head and the dependent are available in the stack.

◦

I

beg

you

excuse

Figure 3: AMR’s edges for the sentence “I beg
you to excuse me.” mapped back to the sentence,
according to the alignment. ◦ is a special token
representing the root.

Because of the similarity of AMR structures
to dependency structures, transition systems are
also helpful for AMR parsing. Starting from the
ARCEAGER system, we develop here a novel tran-
sition system, called AMREAGER that parses sen-
tences into AMR structures. There are three key
differences between AMRs and dependency trees
that require further adjustments for dependency
parsers to be used with AMRs.

Non-Projectivity A key difference between En-
glish dependency trees and AMR structures is pro-
jectivity. Dependency trees in English are usu-
ally projective, roughly meaning that there are no
crossing arcs if the edges are drawn in the semi-
plane above the words. While this restriction is
empirically motivated in syntactic theories for En-
glish, it is no longer motivated for AMR struc-
tures.

The notion of projectivity can be generalized to
AMR graphs as follows. The intuition is that we
can use the alignment π to map AMR edges back
to the sentence x, and test whether there exist pairs
of crossing edges. Figure 3 shows this mapping
for the AMR of Figure 2, where the edge connect-
ing excuse to I crosses another edge. More for-
mally, consider an AMR edge e = (u, ℓ, v). Let
π(u) = i and π(v) = j, so that u is aligned with
xi and v is aligned with xj. The spanning set for
e, written S(e), is the set of all nodes w such that
π(w) = k and i < k < j if i < j or j < k < i
if j < i. We say that e is projective if, for every
node w ∈ S(e), all of its parent and child nodes
are in S(e) ∪ {u, v}; otherwise, we say that e is
non-projective. An AMR is projective if all of its
edges are projective, and is non-projective other-
wise. This corresponds to the intuitive deﬁnition
of projectivity for DAGs introduced in Sagae and
Tsujii (2008) and is closely related to the deﬁni-
tion of non-crossing graphs of Kuhlmann and Jon-
sson (2015).

Non-projective edges
Non-projective AMRs
Reentrant edges
AMRs with at least one reentrancy

8%
35%
7%
51%

deﬁned in Equation (1). To obtain alignments be-
tween the tokens in the sentence and the nodes in
the AMR graph of our training data, we run the
JAMR aligner.7

Table 1: Statistics for non-projectivity and reen-
trancies in 200 AMR manually aligned with the
associated sentences.5

Table 1 demonstrates that a relatively small per-
centage of all AMR edges are non-projective. Yet,
35% of the sentences contain at least one non-
projective edge.

Reentrancy AMRs are graphs rather than trees
because they can have nodes with multiple par-
ents, called reentrant nodes, as in the node you for
the AMR of Figure 2. There are two phenomena
that cause reentrancies in AMR: control, where a
reentrant edge appears between siblings of a con-
trol verb, and co-reference, where multiple men-
tions correspond to the same concept.6

In contrast, dependency trees do not have nodes
with multiple parents. Therefore, when creating
a new arc, transition systems for dependency pars-
ing check that the dependent does not already have
a head node, preventing the node from having ad-
ditional parents. To handle reentrancy, which is
not uncommon in AMR structures as shown in Ta-
ble 1, we drop this constraint.

Alignment Another main difference with de-
pendency parsing is that
in AMR there is no
straightforward mapping between a word in the
sentence and a node in the graph: words may gen-
erate no nodes, one node or multiple nodes.
In
addition, the labels at the nodes are often not eas-
ily determined by the word in the sentence. For
instance expectation translates to expect-01 and
teacher translates to the two nodes teach-01 and
person, connected through an :ARG0 edge, ex-
pressing that a teacher is a person who teaches. A
mechanism of concept identiﬁcation is therefore
required to map each token xi to a subgraph with
the correct labels at its nodes and edges: if π is the
gold alignment, this should be the subgraph ←−π (i)

5https://github.com/jflanigan/jamr/

blob/master/docs/Hand_Alignments.md

6A valid criticism of AMR is that these two reentrancies
are of a completely different type, and should not be col-
lapsed together. Co-reference is a discourse feature, work-
ing by extra-semantic mechanisms and able to cross sentence
boundaries, which are not crossed in AMR annotation.

3 Transition system for AMR Parsing

A stack σ = σn| · · · |σ1|σ0 is a list of nodes
of the partially constructed AMR graph, with the
top element σ0 at the right. We use the sym-
bol ‘|’ as the concatenation operator. A buffer
β = β0|β1| · · · |βn is a list of indices from x, with
the ﬁrst element β0 at the left, representing the
word tokens from the input still to be processed.
A conﬁguration of our parser is a triple (σ, β, A),
where A is the set of AMR edges that have been
constructed up to this point.

In order to introduce the transition actions of
our parser we need some additional notation. We
use a function a that maps indices from x to AMR
graph fragments. For each i ∈ [n], a(i) is a graph
Ga = (Va, Ea), with single root root(Ga), repre-
senting the semantic contribution of word xi to the
AMR for x. As already mentioned, Ga can have
a single node representing the concept associated
with xi, or it can have several nodes in case xi de-
notes a complex concept, or it can be empty.

The transition Shift is used to decide if and
what to push on the stack after consuming a to-
ken from the buffer.
Intuitively, the graph frag-
ment a(β0) obtained from the token β0, if not
empty, is “merged” with the graph we have con-
structed so far. We then push onto the stack the
node root(a(β0)) for further processing. LArc(ℓ)
creates an edge with label ℓ between the top-most
node and the second top-most node in the stack,
and pops the latter. RArc(ℓ) is the symmetric op-
eration, but does not pop any node from the stack.
Finally, Reduce pops the top-most node from
the stack, and it also recovers reentrant edges be-
tween its sibling nodes, capturing for instance sev-
eral control verb patterns. To accomplish this, Re-
duce decides whether to create an additional edge
between the node being removed and the previ-
ously created sibling in the partial graph. This way
of handling control verbs is similar to the REEN-
TRANCE transition of Wang et al. (2015a).

The choice of popping the dependent in the
LArc transition is inspired by ARCEAGER, where
left-arcs are constructed bottom-up to increase
the incrementality of the transition system (Nivre,

7https://github.com/jflanigan/jamr

2004). This affects our ability to recover some
reentrant edges: consider a node u with two par-
ents v and v′, where the arc v → u is a left-arc and
v′ → u is any arc. If the ﬁrst arc to be processed is
v → u, we use LArc that pops u, hence making it
impossible to create the second arc v′ → u. Nev-
ertheless, we discovered that this approach works
better than a completely unrestricted allowance of
reentrancy. The reason is that if we do not remove
dependents at all when ﬁrst attached to a node, the
stack becomes larger, and nodes which should be
connected end up being distant from each other,
and as such, are never connected.

The initial conﬁguration of the system has a ◦
node (representing the root) in the stack and the
entire sentence in the buffer. The terminal con-
ﬁguration consists of an empty buffer and a stack
with only the ◦ node. The transitions required to
parse the sentence The boy and the girl are shown
in Table 2, where the ﬁrst line shows the initial
conﬁguration and the last line shows the terminal
conﬁguration.

Similarly to the transitions of the ARCEAGER,
the above transitions construct edges as soon as the
head and the dependent are available in the stack,
with the aim of maximizing the parser incremen-
tality. We now show that our greedy transition-
based AMR parser is linear-time in n, the length of
the input sentence x. We ﬁrst claim that the output
graph has size O(n). Each token in x is mapped to
a constant number of nodes in the graph by Shift.
Thus the number of nodes is O(n). Furthermore,
each node can have at most three parent nodes,
created by transitions RArc, LArc and Reduce,
respectively. Thus the number of edges is also
O(n). It is possible to bound the maximum num-
ber of transitions required to parse x: the number
of Shift is bounded by n, and the number of Re-
duce, LArc and RArc is bounded by the size of
the graph, which is O(n). Since each transition
can be carried out in constant time, we conclude
that our parser runs in linear time.

4 Training the System

Several components have to be learned: (1) a tran-
sition classiﬁer that predicts the next transition
given the current conﬁguration, (2) a binary clas-
siﬁer that decides whether or not to create a reen-
trancy after a Reduce, (3) a concept identiﬁcation
step for each Shift to compute a(β0), and 3) an-
other classiﬁer to label edges after each LArc or

RArc.

4.1 Oracle

Training our
system from data requires an
oracle—an algorithm that given a gold-standard
AMR graph and a sentence returns transition se-
quences that maximize the overlap between the
gold-standard graph and the graph dictated by the
sequence of transitions.

We adopt a shortest stack, static oracle similar
to Chen and Manning (2014).
Informally, static
means that if the actual conﬁguration of the parser
has no mistakes, the oracle provides a transition
that does not introduce any mistake. Shortest stack
means that the oracle prefers transitions where the
number of items in the stack is minimized. Given
the current conﬁguration (σ, β, A) and the gold-
standard graph G = (Vg, Ag), the oracle is deﬁned
as follows, where we test the conditions in the
given order and apply the action associated with
the ﬁrst match:

1. if ∃ℓ[(σ0, ℓ, σ1) ∈ Ag] then LArc(ℓ);

2. if ∃ℓ[(σ1, ℓ, σ0) ∈ Ag] then RArc(ℓ);

3. if ¬∃i, ℓ[(σ0, ℓ, βi) ∈ Ag ∨ (βi, ℓ, σ0) ∈ Ag]

then Reduce;

4. Shift otherwise.

The oracle ﬁrst checks whether some gold-
standard edge can be constructed from the two el-
ements at the top of the stack (conditions 1 and 2).
If LArc or RArc are not possible, the oracle checks
whether all possible edges in the gold graph in-
volving σ0 have already been processed, in which
case it chooses Reduce (conditions 3). To this
end, it sufﬁces to check the buffer, since LArc and
RArc have already been excluded and elements in
the stack deeper than position two can no longer
be accessed by the parser. If Reduce is not possi-
ble, Shift is chosen.

Besides deciding on the next transition, the ora-
cle also needs the alignments, which we generate
with JAMR, in order to know how to map the next
token in the sentence to its AMR subgraph ←−π (i)
deﬁned in (1).

4.2 Transition Classiﬁer

Like all other transition systems of this kind, our
transition system has a “controller” that predicts a
transition given the current conﬁguration (among

stack
[◦]
[◦]
[◦, boy]
[◦, boy, and ]
[◦, and ]
[◦, and ]
[◦, and ]
[◦, and, girl ]
[◦, and, girl ]

action
-
Shift
Shift
Shift
LArc
RArc
Shift
Shift
RArc
Reduce [◦, and ]
Reduce [◦]

buffer
[the,boy,and,the,girl]
[boy,and,the,girl]
[and,the,girl]
[the,girl]
[the,girl]
[the,girl]
[girl]
[]
[]
[]
[]

edges
{}
{}
{}
{}
{hand,:op1,boyi} = A1
A1 ∪ {h◦,:top,andi} = A2
A2
A2
A2 ∪ {hand,:op2,girli} = A3
A3
A3

Table 2: Parsing steps for the sentence “The boy and the girl.”

Shift, LArc, RArc and Reduce). The examples
from which we learn this controller are based on
features extracted from the oracle transition se-
quences, where the oracle is applied on the train-
ing data.

As a classiﬁer, we use a feed-forward neural
network with two hidden layers of 200 tanh units
and learning rate set to 0.1, with linear decay-
ing. The input to the network consists of the
concatenation of embeddings for words, POS tags
and Stanford parser dependencies, one-hot vec-
tors for named entities and additional sparse fea-
tures, extracted from the current conﬁguration of
the transition system; this is reported in more de-
tails in Table 3. The embeddings for words and
POS tags were pre-trained on a large unanno-
tated corpus consisting of the ﬁrst 1 billion char-
acters from Wikipedia.8 For lexical information,
we also extract the leftmost (in the order of the
aligned words) child (c), leftmost parent (p) and
leftmost grandchild (cc). Leftmost and rightmost
items are common features for transition-based
parsers (Zhang and Nivre, 2011; Chen and Man-
ning, 2014) but we found only leftmost to be
helpful in our case. All POS tags, dependencies
and named entities are generated using Stanford
CoreNLP (Manning et al., 2014). The accuracy of
this classiﬁer on the development set is 84%.

Similarly, we train a binary classiﬁer for decid-
ing whether or not to create a reentrant edge after
a Reduce: in this case we use word and POS em-
beddings for the two nodes being connected and
their parent as well as dependency label embed-
dings for the arcs between them.

8http://mattmahoney.net/dc/enwik9.zip

4.3 Concept Identiﬁcation

This routine is called every time the transition
classiﬁer decides to do a Shift; it is denoted by a(·)
in §3. This component could be learned in a super-
vised manner, but we were not able to improve on
a simple heuristic, which works as follows: during
training, for each Shift decided by the oracle, we
store the pair (β0, ←−π (i)) in a phrase-table. Dur-
ing parsing, the most frequent graph H for the
given token is then chosen. In other words, a(i)
approximates ←−π (i) by means of the graph most
frequently seen among all occurrences of token xi
in the training set.

An obvious problem with the phrase-table ap-
proach is that it does not generalize to unseen
words. In addition, our heuristic relies on the fact
that the mappings observed in the data are correct,
which is not the case when the JAMR-generated
alignments contain a mistake. In order to alleviate
this problem we observe that there are classes of
words such as named entities and numeric quan-
tities that can be disambiguated in a deterministic
manner. We therefore implement a set of “hooks”
that are triggered by the named entity tag of the
next token in the sentence. These hooks override
the normal Shift mechanism and apply a ﬁxed rule
instead. For instance, when we see the token New
York (the two tokens are collapsed in a single one
at preprocessing) we generate the subgraph of Fig-
ure 4 and push its root onto the stack. Similar sub-
graphs are generated for all states, cities, countries
and people. We also use hooks for ordinal num-
bers, percentages, money and dates.

depth
children
parents
lexical

POS
entities
dependency

d(σ0), d(σ1)
#c(σ0), #c(σ1)
#p(σ0), #p(σ1)
w(σ0), w(σ1), w(β0), w(β1),
w(p(σ0)), w(c(σ0)), w(cc(σ0)),
w(p(σ1)), w(c(σ1)), w(cc(σ1))
s(σ0), s(σ1), s(β0), s(β1)
e(σ0), e(σ1), e(β0), e(β1)
ℓ(σ0, σ1), ℓ(σ1, σ0),
∀i ∈ {0, 1}: ℓ(σi, β0), ℓ(β0, σi)
∀i ∈ {1, 2, 3}: ℓ(β0, βi), ℓ(βi, β0)
∀i ∈ {1, 2, 3}: ℓ(σ0, βi), ℓ(βi, σ0)

Table 3: Features used in transition classiﬁer. The
function d maps a stack element to the depth of
the associated graph fragment. The functions #c
and #p count the number of children and par-
ents, respectively, of a stack element. The function
w maps a stack/buffer element to the word em-
bedding for the associated word in the sentence.
The function p gives the leftmost (according to the
alignment) parent of a stack element, the function
c the leftmost child and the function cc the leftmost
grandchild. The function s maps a stack/buffer el-
ement to the part-of-speech embedding for the as-
sociated word. The function e maps a stack/buffer
element to its entity. Finally, the function ℓ maps
a pair of symbols to the dependency label embed-
ding, according to the edge (or lack of) in the de-
pendency tree for the two words these symbols are
mapped to.

4.4 Edge Labeling

Edge labeling determines the labels for the edges
being created. Every time the transition classiﬁer
decides to take an LArc or RArc operation, the
edge labeler needs to decide on a label for it. There
are more than 100 possible labels such as :ARG0,
:ARG0-of, :ARG1, :location, :time and :polarity.
We use a feed-forward neural network similar to
the one we trained for the transition classier, with
features shown in Table 4. The accuracy of this
classiﬁer on the development set is 77%.

Labeling Rules Sometimes the label predicted
by the neural network is not a label that satisﬁes
the requirements of AMR. For instance, the la-
bel :top can only be applied when the node from
which the edge starts is the special ◦ node. In or-
der to avoid generating such erroneous labels, we
use a set of rules, shown in Table 5. These rules
determine which labels are allowed for the newly

:top

country

:name

name

:wiki

New York

:op1

New

:op2

York

Figure 4: Subgraph for “New York.”

name
depth
children
parents
lexical

POS
entities
dependency

feature template
d(σ0), d(σ1)
#c(σ0), #c(σ1)
#p(σ0), #p(σ1)
w(σ0), w(σ1),
w(p(σ0)), w(c(σ0)), w(cc(σ0)),
w(p(σ1)), w(c(σ1)), w(cc(σ1))
s(σ0), s(σ1)
e(σ0), e(σ1)
ℓ(σ0, β0), ℓ(β0, σ0)

Table 4: Features used in edge labeling. See Ta-
ble 3 for a legend of symbols.

created edge so that we only consider those during
prediction. Also ARG roles cannot always be ap-
plied: each Propbank frame allows a limited num-
ber of arguments. For example, while add-01 and
add-02 allow for :ARG1 and :ARG2 (and their in-
verse :ARG1-of and :ARG2-of ), add-03 and add-
04 only allow :ARG2 (and :ARG2-of ).

5 Fine-grained Evaluation

Until now, AMR parsers were evaluated using the
Smatch score.9 Given the candidate graphs and
the gold graphs in the form of AMR annotations,
Smatch ﬁrst tries to ﬁnd the best alignments be-
tween the variable names for each pair of graphs
and it then computes precision, recall and F1 of the
concepts and relations. We note that the Smatch
score has two ﬂaws: (1) while AMR parsing in-
volves a large number of subtasks, the Smatch
score consists of a single number that does not as-
sess the quality of each subtasks separately; (2) the
Smatch score weighs different types of errors in

9Since Smatch is an approximate randomized algorithm,
decimal points in the results vary between different runs and
are not reported. This approach was also taken by Wang et al.
(2015b) and others.

start
◦

end

label
:top
:polarity
:mode

:value
:day
:month
:year
:decade
:century
:weekday

:quarter
:season

ex.
Yes
Yes
Yes

No
No
No
No
No
No
Yes

No
Yes

d-ent
d-ent
d-ent
d-ent
d-ent
d-ent

d-ent
d-ent

:timezone Yes

d-ent

-
inter.|
expr.|imp.
“\w+” |[0-9]+
[1|2|· · · |31]
[1|2|· · · |12]+
[0-9]+
[0-9]+
[0-9]+
[monday|· · · |
sunday]
[1|2|3|4]+
[winter|fall|
spring|summer]+
[A−Z]3

Table 5: Labeling rules: For each edge label, we
provide regular expressions that must hold on the
labels at the start node (start) and the end node
(end) of the edge. Ex. indicates when the rule is
exclusive, d-ent is the AMR concept date-entity,
inter. is the AMR constant interrogative, expr. is
the AMR constant expressive, imp.
is the AMR
constant imperative.

a way which is not necessarily useful for solving
a speciﬁc NLP problem. For example, for a spe-
ciﬁc problem concept detection might be deemed
more important than edge detection, or guessing
the wrong sense for a concept might be consid-
ered less severe than guessing the wrong verb al-
together.

Consider the two parses for the sentence Silvio
Berlusconi gave Lucio Stanca his current role of
modernizing Italy’s bureaucracy in Figure 5. At
the top, we show the output of a parser (Parse 1)
that is not able to deal with named entities. At
the bottom, we show the output of a parser (Parse
2) which, except for :name, :op and :wiki, always
uses the edge label :ARG0. The Smatch scores for
the two parses are 56 and 78 respectively. Both
parses make obvious mistakes but the three named
entity errors in Parse 1 are considered more impor-
tant than the six wrong labels in Parse 2. However,
without further analysis, it is not advisable to con-
clude that Parse 2 is better than Parse 1. In order
to better understand the limitations of the differ-
ent parsers, ﬁnd their strengths and gain insight in
which downstream tasks they may be helpful, we
compute a set of metrics on the test set.

Unlabeled is the Smatch score computed on
the predicted graphs after removing all edge la-
bels. In this way, we only assess the node labels

( g / give-01

:ARG0 ( p3 / silvio :mod ( n4 / berlusconi ) )
:ARG1 ( r / role

:time ( c2 / current )
:mod ( m / modernize-01
:ARG0 p4
:ARG1 ( b / bureaucracy :part-of

:poss p4 )

:ARG2 ( p4 / person lucio :mod stanca ) )

( c3 /

italy ) ) )

( g / give-01

:ARG0 ( p3 / person :wiki ” S i l v i o B e r l u s c o n i ”

:name ( n4 / name :op1 ” S i l v i o ” :op2 ” B e r l u s c o n i ” ) )

:ARG0 ( r / role

:ARG0 ( c2 / current )
:ARG0 ( m / modernize-01
:ARG0 p4
:ARG0 ( b / bureaucracy

:ARG0 ( c3 / country :wiki ” I t a l y ”

:name ( n6 / name :op1 ” I t a l y ” ) ) ) )

:ARG0 p4 )

:ARG0 ( p4 / person :wiki −

:name ( n5 / name :op1 ” L u c i o ” :op2 ” S t a n c a ” ) ) )

Figure 5: Two parses for the sentence “Silvio
Berlusconi gave Lucio Stanca his current role of
modernizing Italy’s bureaucracy.”

and the graph topology, which may be enough to
beneﬁt several NLP tasks because it identiﬁes ba-
sic predicate-argument structure. For instance, we
may be interested in knowing whether two events
or entities are related to each other, while not being
concerned with the precise type of relation holding
between them.

No WSD gives a score that does not take into
account word sense disambiguation errors. By ig-
noring the sense speciﬁed by the Propbank frame
used (e.g., duck-01 vs duck-02) we have a score
that does not take into account this additional com-
plexity in the parsing procedure. To compute this
score, we simply strip off the sufﬁxes from all
Propbank frames and calculate the Smatch score.
Following Sawai et al. (2015), we also evalu-
ate the parsers using the Smatch score on noun
phrases only (NP-only), by extracting from the
AMR dataset all noun phrases that do not include
further NPs.

As we previously discussed, reentrancy is a very
important characteristic of AMR graphs and it is
not trivial to handle. We therefore implement a
test for it (Reentrancy), where we compute the
Smatch score only on reentrant edges.

Concept identiﬁcation is another critical com-
ponent of the parsing process and we therefore
compute the F-score on the list of predicted con-
cepts (Concepts) too. Identifying the correct con-
cepts is fundamental:
if a concept is not identi-
ﬁed, it will not be possible to retrieve any edge
involving that concept, with likely signiﬁcant con-
sequences on accuracy. This metric is therefore

First parse Second parse

Metric
Smatch
Unlabeled
No WSD
NP-only
Reentrancy
Concepts
Named Ent.
Wikiﬁcation
Negations
SRL

56
65
56
39
69
56
0
0
0
69

78
100
78
86
46
100
100
100
0
54

Metric
Smatch
Unlabeled
No WSD
NP-only
Reentrancy
Concepts
Named Ent.
Wikiﬁcation
Negations
SRL

J’14 C’15
63
58
69
61
64
58
54
47
41
38
80
79
75
75
0
0
18
16
60
55

J’16 Ours
67
64
69
69
68
65
58
55
42
41
83
83
83
79
75
64
48
45
60
56

Table 6: Evaluation of the two parses in Figure 5
with the proposed evaluation suite.

Table 7: Results on test split of LDC2015E86 for
JAMR, CAMR and our AMREAGER. J stands for
JAMR and C for CAMR (followed by the year of
publication). Best systems are in bold.

quite important to score highly on.

6 Experiments

Similarly to our score for concepts, we fur-
ther compute an F-score on the named entities
(Named Ent.) and wiki roles for named entities
(Wikiﬁcation) that consider edges labeled with
:name and :wiki respectively. These two metrics
are strictly related to the concept score. How-
ever, since named entity recognition is the fo-
cus of dedicated research, we believe it is impor-
tant to deﬁne a metric that speciﬁcally assesses
this problem. Negation detection is another task
which has received some attention. An F-score
for this (Negations) is also deﬁned, where we ﬁnd
all negated concepts by looking for the :polarity
role. The reason we can compute a simple F-score
instead of using Smatch for these metrics is that
there are no variable names involved.

Finally we compute the Smatch score on :ARG
edges only, in order to have a score for semantic
role labeling (SRL), which is another extremely
important subtask of AMR, as it is based on the
identiﬁcation of predicate-argument structures.

Using this evaluation suite we can evaluate
AMRs on a wide range of metrics that can help us
ﬁnd strengths and weakness of each parser, hence
speeding up the research in this area. Table 6 re-
ports the scores for the two parses of Figure 5,
where we see that Parse 1 gets a high score for
semantic role labeling while Parse 2 is optimal
for named entity recognition. Moreover, we can
make additional observations such as that Parse 2
is optimal with respect to unlabeled score and that
Parse 1 recovers more reentrancies.

We compare our parser10 against two available
parsers: JAMR (Flanigan et al., 2014) and CAMR
(Wang et al., 2015b; Wang et al., 2015a), using the
LDC2015E86 dataset for evaluation. Both parsers
are available online11 and were recently updated
for SemEval-2016 Task 8 (Flanigan et al., 2016;
Wang et al., 2016). However, CAMR’s SemEval
system, which reports a Smatch score of 67, is
not publicly available. CAMR has a quadratic
worst-case complexity (although linear in prac-
tice).
In JAMR, the concept identiﬁcation step
is quadratic and the relation identiﬁcation step is
O(|V |2 log |V |), with |V | being the set of nodes in
the AMR graph.

Table 7 shows the results obtained by the
parsers on all metrics previously introduced. On
Smatch, our system does not give state-of-the-art
results. However, we do obtain the best results
for Unlabeled and Concept and outperform the
other parses for Named Ent. and Negations. Our
score of Reentrancy is also close the best scor-
ing system, which is particularly relevant given
the importance of reentrancies in AMR. The use
of the Reduce transition, which targets reentran-
cies caused by control verbs, is critical in order to
achieve this result.

The relatively high results we obtain for the un-

10Our parser is available at https://github.com/
mdtux89/amr-eager, the evaluation suite at https:
//github.com/mdtux89/amr-evaluation
and a demo at http://cohort.inf.ed.ac.uk/
amreager.html

11JAMR:

https://github.com/jflanigan/
jamr, CAMR: https://github.com/c-amr/camr.

labeled case suggests that our parser has difﬁculty
in labeling the arcs. Our score for concept identi-
ﬁcation, which is on par with the best result from
the other parsers, demonstrates that there is a rel-
atively low level of token ambiguity. State-of-the-
art results for this problem can be obtained by
choosing the most frequent subgraph for a given
token based on a phrase-table constructed from
JAMR alignments on the training data. The scores
for named entities and wikiﬁcation are heavily de-
pendent on the hooks mentioned in §4.3, which
in turn relies on the named entity recognizer to
make the correct predictions. In order to alleviate
the problem of wrong automatic alignments with
respect to polarity and better detect negation, we
performed a post-processing step on the aligner
output where we align the AMR constant - (mi-
nus) with words bearing negative polarity such as
not, illegitimate and asymmetry.

Our experiments demonstrate that there is no
parser for AMR yet that conclusively does better
than all other parsers on all metrics. Advantages
of our parser are the worst-case linear complexity
and the fact that is possible to perform incremen-
tal AMR parsing, which is both helpful for real-
time applications and to investigate how meaning
of English sentences can be built incrementally
left-to-right.

7 Related Work

The ﬁrst data-driven AMR parser is due to Flani-
gan et al. (2014). The problem is addressed in
two separate stages: concept identiﬁcation and re-
lation identiﬁcation. They use a sequence label-
ing algorithm to identify concepts and frame the
relation prediction task as a constrained combina-
torial optimization problem. Werling et al. (2015)
notice that the difﬁcult bit is the concept identi-
ﬁcation and propose a better way to handle that
task: an action classiﬁer to generate concepts by
applying predetermined actions. Other propos-
als involve a synchronous hyperedge replacement
grammar solution (Peng et al., 2015), a syntax-
based machine translation approach (Pust et al.,
2015) where a grammar of string-to-tree rules is
created after reducing AMR graphs to trees by re-
moving all reentrancies, a CCG system that ﬁrst
parses sentences into lambda-calculus representa-
tions (Artzi et al., 2015). A systematic transla-
tion from AMR to ﬁrst order logic formulas, with
a special treatment for quantiﬁcation, reentrancy

and negation, is discussed in Bos (2016). In Van-
derwende et al. (2015), a pre-existing logical form
parser is used and the output is then converted into
AMR graphs. Yet another solution is proposed by
Rao et al. (2015) who discuss a parser that uses
SEARN (Daum´e III et al., 2009), a “learning to
search” algorithm.

Transition-based algorithms for AMR parsing
are compelling because traditional graph-based
techniques are computationally expensive. Wang
et al. (2015b) and Wang et al. (2015a) propose a
framework that parses a sentence into its AMR
structure through a two-stage process: a depen-
dency tree is generated from the input sentence
through a transition-based parser and then an-
other transition-based parser is used to generate
the AMR. The main beneﬁt of this approach is that
the dependency parser can be trained on a training
set much larger than the training set for the tree-
to-graph algorithm. Others further built on this
parser: Goodman et al. (2016) use imitation learn-
ing to alleviate the probem of error propagation
in the greedy parser, while Barzdins and Gosko
(2016) create a wrapper around it to ﬁx frequent
mistakes and investigate ensembles with a char-
acter level neural parser. More recently Zhou et
al. (2016) presented a non-greedy transition sys-
tem for AMR parsing, based on ARCSTANDARD
(Nivre, 2004).

AMR parsing as a whole is a complex task be-
cause it involves many subtasks including named
entity recognition, co-reference resolution and se-
mantic role labeling. Sawai et al. (2015) do not
attempt at parsing AMR graphs for entire sen-
tences but they instead handle simple noun phrases
(NPs). They extract NPs from the AMR dataset
only when they do not include further NPs, do not
include pronouns nor named entities. Due to these
restrictions, the AMRs are mostly trees and eas-
ier to handle than the original AMR graphs. They
approach this task using a transition based system
inspired by ARCSTANDARD.

AMR is not the only way to represent meaning
in natural language sentences. Alternative seman-
tic representations have been developed and stud-
ied, such as Boxer (Bos et al., 2004), CCG (Steed-
man, 1996; Steedman, 2000) and UCCA (Abend
and Rappoport, 2013).

8 Conclusion

We presented a transition system that builds AMR
graphs in linear time by processing the sentences
left-to-right, trained with feed-forward neural net-
works. The parser demonstrates that it is possi-
ble to perform AMR parsing using techniques in-
spired by dependency parsing.

We also noted that it is less informative to eval-
uate the entire parsing process with Smatch than
to use a collection of metrics aimed at evaluat-
ing the various subproblems in the parsing pro-
cess. We further showed that our left-to-right tran-
sition system is competitive with publicly avail-
able state-of-the-art parsers. Although we do not
outperform the best baseline in terms of Smatch
score, we show on par or better results for sev-
eral of the metrics proposed. We hope that moving
away from a single-metric evaluation will further
speed up progress in AMR parsing.

Acknowledgments

The authors would like to thank the three anony-
mous reviewers and Sameer Bansal, Jeff Flanigan,
Sorcha Gilroy, Adam Lopez, Nikos Papasaran-
topoulos, Nathan Schneider, Mark Steedman, Sam
Thomson, Clara Vania and Chuan Wang for their
help and comments. This research was supported
by a grant from Bloomberg and by the H2020
project SUMMA, under grant agreement 688139.

References

Omri Abend and Ari Rappoport. 2013. Universal con-
ceptual cognitive annotation (UCCA). In Proceed-
ings of ACL.

Yoav Artzi, Kenton Lee, and Luke Zettlemoyer. 2015.
Broad-coverage CCG semantic parsing with AMR.
Proceedings of EMNLP.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Grifﬁtt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract meaning representation
for sembanking. Proceedings of Linguistic Annota-
tion Workshop.

Guntis Barzdins and Didzis Gosko. 2016. RIGA at
SemEval-2016 task 8: Impact of smatch extensions
and character-level neural translation on AMR pars-
ing accuracy. arXiv preprint arXiv:1604.01278.

Johan Bos, Stephen Clark, Mark Steedman, James R
Curran, and Julia Hockenmaier.
2004. Wide-
coverage semantic representations from a ccg parser.

In Proceedings of COLING. Association for Compu-
tational Linguistics.

Johan Bos. 2016. Expressive power of abstract mean-
ing representations. Computational Linguistics, 42.

Shu Cai and Kevin Knight. 2013. Smatch: an evalua-
tion metric for semantic feature structures. Proceed-
ings of ACL.

Danqi Chen and Christopher D Manning. 2014. A fast
and accurate dependency parser using neural net-
works. In Proceesings of EMNLP.

Hal Daum´e III, John Langford, and Daniel Marcu.
2009. Search-based structured prediction. Machine
learning, 75(3):297–325.

Yantao Du, Fan Zhang, Weiwei Sun, and Xiaojun Wan.
2014. Peking: Proﬁling syntactic tree parsing tech-
niques for semantic graph parsing. In Proceedings
of the 8th International Workshop on Semantic Eval-
uation (SemEval-2014), pages 459–464.

Jeffrey Flanigan, Sam Thomson, Jaime G Carbonell,
Chris Dyer, and Noah A Smith. 2014. A discrim-
inative graph-based parser for the abstract meaning
representation. Proceedings of ACL.

Jeffrey Flanigan, Chris Dyer, Noah A Smith, and Jaime
Carbonell. 2016. CMU at SemEval-2016 task 8:
Graph-based AMR parsing with inﬁnite ramp loss.
Proceedings of SemEval, pages 1202–1206.

James Goodman, Andreas Vlachos, and Jason Narad-
owsky. 2016. Noise reduction and targeted explo-
ration in imitation learning for abstract meaning rep-
resentation parsing. Proceedings of ACL.

Marco Kuhlmann and Peter Jonsson.

2015. Pars-
ing to noncrossing dependency graphs. Transac-
tions of the Association for Computational Linguis-
tics, pages 559–570.

Christopher D. Manning, Mihai Surdeanu, John Bauer,
Jenny Finkel, Steven J. Bethard, and David Mc-
Closky. 2014. The Stanford CoreNLP natural lan-
In ACL System Demon-
guage processing toolkit.
strations.

Joakim Nivre. 2004. Incrementality in deterministic
dependency parsing. Proceedings of the Workshop
on Incremental Parsing: Bringing Engineering and
Cognition Together. ACL.

Joakim Nivre. 2008. Algorithms for deterministic in-
cremental dependency parsing. Computational Lin-
guistics, Volume 34, Number 4, December 2008.

Xiaochang Peng, Linfeng Song, and Daniel Gildea.
2015. A synchronous hyperedge replacement gram-
mar based approach for AMR parsing. Proceedings
of CoNLL.

Michael Pust, Ulf Hermjakob, Kevin Knight, Daniel
Marcu, and Jonathan May. 2015. Using syntax-
based machine translation to parse english into
arXiv preprint
abstract meaning representation.
arXiv:1504.06665.

Sudh Rao, Yogarshi Vyas, Hal Daume III, and Philip
Resnik. 2015. Parser for abstract meaning represen-
tation using learning to search. arXiv:1510.07586.

Corentin Ribeyre, ´Eric Villemonte de La Clergerie, and
Djam´e Seddah. 2015. Because syntax does matter:
Improving predicate-argument structures parsing us-
In Conference of the North
ing syntactic features.
American Chapter of the Association for Computa-
tional Linguistics: Human Language Technologies.

Kenji Sagae and Jun’ichi Tsujii. 2008. Shift-reduce
dependency DAG parsing. Proceedings of COL-
ING.

Yuichiro Sawai, Hiroyuki Shindo, and Yuji Matsumoto.
2015. Semantic structure analysis of noun phrases
using abstract meaning representation. Proceedings
of ACL.

Mark Steedman. 1996. Surface Structure and Inter-

pretation. The MIT Press.

Mark Steedman. 2000. The Syntactic Process. The

MIT Press.

Lucy Vanderwende, Arul Menezes, and Chris Quirk.
2015. An AMR parser for english, french, german,
spanish and japanese and a new AMR-annotated
corpus. Proceedings of NAACL-HLT.

Chuan Wang, Nianwen Xue, and Sameer Pradhan.
2015a. Boosting transition-based AMR parsing
with reﬁned actions and auxiliary analyzers. Pro-
ceedings of ACL.

Chuan Wang, Nianwen Xue, and Sameer Pradhan.
2015b. A transition-based algorithm for AMR pars-
ing. Proceedings of NAACL.

Chuan Wang, Sameer Pradhan, Nianwen Xue, Xiao-
man Pan, and Heng Ji. 2016. CAMR at SemEval-
2016 task 8: An extended transition-based AMR
parser. Proceedings of SemEval.

Keenon Werling, Gabor Angeli, and Christopher Man-
ning. 2015. Robust subgraph generation improves
arXiv
abstract meaning representation parsing.
preprint arXiv:1506.03139.

Yue Zhang and Joakim Nivre.

2011. Transition-
based dependency parsing with rich non-local fea-
tures. Proceedings of ACL.

Junsheng Zhou, Feiyu Xu, Hans Uszkoreit, Weiguang
QU, Ran Li, and Yanhui Gu. 2016. AMR parsing
with an incremental joint model. In Proceedings of
the 2016 Conference on Empirical Methods in Nat-
ural Language Processing.

From the Proceedings of EACL 2017 (Valencia, Spain). This version includes slightly more information

than the published version (January, 2017).

An Incremental Parser for Abstract Meaning Representation

Marco Damonte
School of Informatics
University of Edinburgh
m.damonte@sms.ed.ac.uk

Shay B. Cohen
School of Informatics
University of Edinburgh
scohen@inf.ed.ac.uk

Giorgio Satta
Dept. of Information Engineering
University of Padua
satta@dei.unipd.it

7
1
0
2
 
r
p
A
 
0
1
 
 
]
L
C
.
s
c
[
 
 
5
v
1
1
1
6
0
.
8
0
6
1
:
v
i
X
r
a

Abstract

Abstract Meaning Representation (AMR)
is a semantic representation for natural
language that embeds annotations related
to traditional tasks such as named entity
recognition, semantic role labeling, word
sense disambiguation and co-reference
resolution. We describe a transition-based
parser for AMR that parses sentences left-
to-right, in linear time. We further pro-
pose a test-suite that assesses speciﬁc sub-
tasks that are helpful in comparing AMR
parsers, and show that our parser is com-
petitive with the state of the art on the
LDC2015E86 dataset and that it outper-
forms state-of-the-art parsers for recover-
ing named entities and handling polarity.

1 Introduction

Semantic parsing aims to solve the problem
of canonicalizing language and representing its
meaning: given an input sentence, it aims to ex-
tract a semantic representation of that sentence.
Abstract meaning representation (Banarescu et al.,
2013), or AMR for short, allows us to do that
with the inclusion of most of the shallow-semantic
natural language processing (NLP) tasks that are
usually addressed separately, such as named en-
tity recognition, semantic role labeling and co-
reference resolution. AMR is partially motivated
by the need to provide the NLP community with
a single dataset that includes basic disambiguation
information, instead of having to rely on differ-
ent datasets for each disambiguation problem. The
annotation process is straightforward, enabling the
development of large datasets.

Several parsers for AMR have been recently de-
veloped (Flanigan et al., 2014; Wang et al., 2015a;
Peng et al., 2015; Pust et al., 2015; Goodman
et al., 2016; Rao et al., 2015; Vanderwende et
al., 2015; Artzi et al., 2015; Barzdins and Gosko,
2016; Zhou et al., 2016). This line of research
is new and current results suggest a large room
for improvement. Greedy transition-based meth-
ods (Nivre, 2008) are one of the most popular
choices for dependency parsing, because of their
good balance between efﬁciency and accuracy.
These methods seem promising also for AMR,
due to the similarity between dependency trees
and AMR structures, i.e., both representations use
graphs with nodes that have lexical content and
edges that represent linguistic relations.

A transition system is an abstract machine char-
acterized by a set of conﬁgurations and transitions
between them. The basic components of a con-
ﬁguration are a stack of partially processed words
and a buffer of unseen input words. Starting from
an initial conﬁguration, the system applies tran-
sitions until a terminal conﬁguration is reached.
The sentence is scanned left to right, with linear
time complexity for dependency parsing. This is
made possible by the use of a greedy classiﬁer that
chooses the transition to be applied at each step.

In this paper we introduce a parser for AMR that
is inspired by the ARCEAGER dependency tran-
sition system of Nivre (2004). The main differ-
ence between our system and ARCEAGER is that
we need to account for the mapping from word
tokens to AMR nodes, non-projectivity of AMR
structures and reentrant nodes (multiple incom-
ing edges). Our AMR parser brings closer depen-
dency parsing and AMR parsing by showing that
dependency parsing algorithms, with some mod-
iﬁcations, can be used for AMR. Key properties

such as working left-to-right, incrementality1 and
linear complexity further strengthen its relevance.
The AMR parser of Wang et al. (2015a), called
CAMR, also deﬁnes a transition system. It differs
from ours because we process the sentence left-to-
right while they ﬁrst acquire the entire dependency
tree and then process it bottom-up. More recently
Zhou et al. (2016) presented a non-greedy tran-
sition system for AMR parsing, based on ARC-
STANDARD (Nivre, 2004). Our transition sys-
tem is also related to an adaptation of ARCEAGER
for directed acyclic graphs (DAGs), introduced by
Sagae and Tsujii (2008). This is also the basis
for Ribeyre et al. (2015), a transition system used
to parse dependency graphs. Similarly, Du et al.
(2014) also address dependency graph parsing by
means of transition systems. Analogously to de-
pendency trees, dependency graphs have the prop-
erty that their nodes consist of the word tokens,
which is not true for AMR. As such, these transi-
tion systems are more closely related to traditional
transition systems for dependency parsing.

Our contributions in this paper are as follows:

• In §3 we develop a left-to-right, linear-time
transition system for AMR parsing, inspired
by the ARCEAGER transition system for de-
pendency tree parsing;

• In §5 we claim that the Smatch score (Cai
and Knight, 2013) is not sufﬁcient to evalu-
ate AMR parsers and propose a set of metrics
to alleviate this problem and better compare
alternative parsers;

• In §6 we show that our algorithm is compet-
itive with publicly available state-of-the-art
parsers on several metrics.

2 Background and Notation

AMR Structures AMRs are rooted and directed
graphs with node and edge labels. An annotation
example for the sentence I beg you to excuse me is
shown in Figure 1, with the AMR graph reported
in Figure 2.

Concepts are represented as labeled nodes in
the graph and can be either English words (e.g. I
and you) or Propbank framesets (e.g. beg-01 and
excuse-01). Each node in the graph is assigned to

1Strictly speaking,

transition-based parsing cannot
achieve full incrementality, which requires to have a single
connected component at all times (Nivre, 2004).

( b / beg-01

i

/

:ARG0 ( i
:ARG1 ( y / you)
:ARG2 ( e / excuse-01

:ARG0 y
:ARG1 i ) )

Figure 1: Annotation for the sentence “I beg you to
excuse me.” Variables are in boldface and concepts
and edge labels are in italics.

:top

beg-01

:ARG1

:ARG0

i

:ARG1

:ARG2

you

:ARG0

excuse-01

Figure 2: AMR graph representation for Figure 1.

a variable in the AMR annotation so that a variable
re-used in the annotation corresponds to reentran-
cies (multiple incoming edges) in the graph. Rela-
tions are represented as labeled and directed edges
in the graph.

Notation For most sentences in our dataset, the
AMR graph is a directed acyclic graph (DAG),
with a few speciﬁc cases where cycles are permit-
ted. These cases are rare, and for the purpose of
this paper, we consider AMR as DAGs.

We denote by [n] the set {1, . . . , n}. We deﬁne
an AMR structure as a tuple (G, x, π), where x =
x1 · · · xn is a sentence, with each xi, i ∈ [n], a
word token, and G is a directed graph G = (V, E)
with V and E the set of nodes and edges, respec-
tively.2 We assume G comes along with a node
labeling function and an edge labeling function.
Finally, π : V → [n] is a total alignment function
that maps every node of the graph to an index i
for the sentence x, with the meaning that node v
represents (part of) the concept expressed by the
word xπ(v).3

2We collapse all multi-word named entities in a single to-
ken (e.g., United Kingdom becomes United Kingdom) both
in training and parsing.

3π is a function because we do not consider co-references,
which would otherwise cause a node to map to multiple in-
dices. This is in line with current work on AMR parsing.

We note that the function π is not invertible,
since it is neither injective nor surjective. For each
i ∈ [n], we let

π−1(i) = {v | v ∈ V, π(v) = i}

be the pre-image of i under π (this set can be
empty for some i), which means that we map a to-
ken in the sentence to a set of nodes in the AMR.
In this way we can align each index i for x to the
induced subgraph of G. More formally, we deﬁne

←−π (i) = (π−1(i), E ∩ (π−1(i) × π−1(i))),

(1)

with the node and edge labeling functions of ←−π (i)
inherited from G. Hence, ←−π (i) returns the AMR
subgraph aligned with a particular token in the
sentence.

2.1 Transition-Based AMR Parsing

Similarly to dependency parsing, AMR parsing is
partially based on the identiﬁcation of predicate-
argument structures. Much of the dependency
parsing literature focuses on transition-based de-
pendency parsing—an approach to parsing that
scans the sentence from left to right in linear time
and updates an intermediate structure that eventu-
ally ends up being a dependency tree.

The two most common transition systems for
greedy dependency parsing are ARCSTANDARD
and ARCEAGER. With ARCSTANDARD, a stack
is maintained along with a buffer on which the
left-to-right scan is performed. At each step, the
parser chooses to scan a word in the buffer and
shift it onto the stack, or else to create an arc
between the two top-most elements in the stack
and pop the dependent. ARCSTANDARD parses
a sentence in a pure bottom-up, left-to-right fash-
ion (similarly to shift-reduce context-free gram-
mar parsers), and must delay the construction of
right arcs until all the dependent node has been
completed. This imposes strong limitations on
the degree of incrementality of the parser. The
ARCEAGER system was designed to improve on
ARCSTANDARD by mixing bottom up and top-
down strategies. More precisely, in the ARCEA-
GER parser left arcs are constructed bottom-up and
right arcs are constructed top-down, so that right
dependents can be attached to their heads even if
some of their own dependents are not identiﬁed
yet. In this way arcs are constructed as soon as the
head and the dependent are available in the stack.

◦

I

beg

you

excuse

Figure 3: AMR’s edges for the sentence “I beg
you to excuse me.” mapped back to the sentence,
according to the alignment. ◦ is a special token
representing the root.

Because of the similarity of AMR structures
to dependency structures, transition systems are
also helpful for AMR parsing. Starting from the
ARCEAGER system, we develop here a novel tran-
sition system, called AMREAGER that parses sen-
tences into AMR structures. There are three key
differences between AMRs and dependency trees
that require further adjustments for dependency
parsers to be used with AMRs.

Non-Projectivity A key difference between En-
glish dependency trees and AMR structures is pro-
jectivity. Dependency trees in English are usu-
ally projective, roughly meaning that there are no
crossing arcs if the edges are drawn in the semi-
plane above the words. While this restriction is
empirically motivated in syntactic theories for En-
glish, it is no longer motivated for AMR struc-
tures.

The notion of projectivity can be generalized to
AMR graphs as follows. The intuition is that we
can use the alignment π to map AMR edges back
to the sentence x, and test whether there exist pairs
of crossing edges. Figure 3 shows this mapping
for the AMR of Figure 2, where the edge connect-
ing excuse to I crosses another edge. More for-
mally, consider an AMR edge e = (u, ℓ, v). Let
π(u) = i and π(v) = j, so that u is aligned with
xi and v is aligned with xj. The spanning set for
e, written S(e), is the set of all nodes w such that
π(w) = k and i < k < j if i < j or j < k < i
if j < i. We say that e is projective if, for every
node w ∈ S(e), all of its parent and child nodes
are in S(e) ∪ {u, v}; otherwise, we say that e is
non-projective. An AMR is projective if all of its
edges are projective, and is non-projective other-
wise. This corresponds to the intuitive deﬁnition
of projectivity for DAGs introduced in Sagae and
Tsujii (2008) and is closely related to the deﬁni-
tion of non-crossing graphs of Kuhlmann and Jon-
sson (2015).

Non-projective edges
Non-projective AMRs
Reentrant edges
AMRs with at least one reentrancy

8%
35%
7%
51%

deﬁned in Equation (1). To obtain alignments be-
tween the tokens in the sentence and the nodes in
the AMR graph of our training data, we run the
JAMR aligner.7

Table 1: Statistics for non-projectivity and reen-
trancies in 200 AMR manually aligned with the
associated sentences.5

Table 1 demonstrates that a relatively small per-
centage of all AMR edges are non-projective. Yet,
35% of the sentences contain at least one non-
projective edge.

Reentrancy AMRs are graphs rather than trees
because they can have nodes with multiple par-
ents, called reentrant nodes, as in the node you for
the AMR of Figure 2. There are two phenomena
that cause reentrancies in AMR: control, where a
reentrant edge appears between siblings of a con-
trol verb, and co-reference, where multiple men-
tions correspond to the same concept.6

In contrast, dependency trees do not have nodes
with multiple parents. Therefore, when creating
a new arc, transition systems for dependency pars-
ing check that the dependent does not already have
a head node, preventing the node from having ad-
ditional parents. To handle reentrancy, which is
not uncommon in AMR structures as shown in Ta-
ble 1, we drop this constraint.

Alignment Another main difference with de-
pendency parsing is that
in AMR there is no
straightforward mapping between a word in the
sentence and a node in the graph: words may gen-
erate no nodes, one node or multiple nodes.
In
addition, the labels at the nodes are often not eas-
ily determined by the word in the sentence. For
instance expectation translates to expect-01 and
teacher translates to the two nodes teach-01 and
person, connected through an :ARG0 edge, ex-
pressing that a teacher is a person who teaches. A
mechanism of concept identiﬁcation is therefore
required to map each token xi to a subgraph with
the correct labels at its nodes and edges: if π is the
gold alignment, this should be the subgraph ←−π (i)

5https://github.com/jflanigan/jamr/

blob/master/docs/Hand_Alignments.md

6A valid criticism of AMR is that these two reentrancies
are of a completely different type, and should not be col-
lapsed together. Co-reference is a discourse feature, work-
ing by extra-semantic mechanisms and able to cross sentence
boundaries, which are not crossed in AMR annotation.

3 Transition system for AMR Parsing

A stack σ = σn| · · · |σ1|σ0 is a list of nodes
of the partially constructed AMR graph, with the
top element σ0 at the right. We use the sym-
bol ‘|’ as the concatenation operator. A buffer
β = β0|β1| · · · |βn is a list of indices from x, with
the ﬁrst element β0 at the left, representing the
word tokens from the input still to be processed.
A conﬁguration of our parser is a triple (σ, β, A),
where A is the set of AMR edges that have been
constructed up to this point.

In order to introduce the transition actions of
our parser we need some additional notation. We
use a function a that maps indices from x to AMR
graph fragments. For each i ∈ [n], a(i) is a graph
Ga = (Va, Ea), with single root root(Ga), repre-
senting the semantic contribution of word xi to the
AMR for x. As already mentioned, Ga can have
a single node representing the concept associated
with xi, or it can have several nodes in case xi de-
notes a complex concept, or it can be empty.

The transition Shift is used to decide if and
what to push on the stack after consuming a to-
ken from the buffer.
Intuitively, the graph frag-
ment a(β0) obtained from the token β0, if not
empty, is “merged” with the graph we have con-
structed so far. We then push onto the stack the
node root(a(β0)) for further processing. LArc(ℓ)
creates an edge with label ℓ between the top-most
node and the second top-most node in the stack,
and pops the latter. RArc(ℓ) is the symmetric op-
eration, but does not pop any node from the stack.
Finally, Reduce pops the top-most node from
the stack, and it also recovers reentrant edges be-
tween its sibling nodes, capturing for instance sev-
eral control verb patterns. To accomplish this, Re-
duce decides whether to create an additional edge
between the node being removed and the previ-
ously created sibling in the partial graph. This way
of handling control verbs is similar to the REEN-
TRANCE transition of Wang et al. (2015a).

The choice of popping the dependent in the
LArc transition is inspired by ARCEAGER, where
left-arcs are constructed bottom-up to increase
the incrementality of the transition system (Nivre,

7https://github.com/jflanigan/jamr

2004). This affects our ability to recover some
reentrant edges: consider a node u with two par-
ents v and v′, where the arc v → u is a left-arc and
v′ → u is any arc. If the ﬁrst arc to be processed is
v → u, we use LArc that pops u, hence making it
impossible to create the second arc v′ → u. Nev-
ertheless, we discovered that this approach works
better than a completely unrestricted allowance of
reentrancy. The reason is that if we do not remove
dependents at all when ﬁrst attached to a node, the
stack becomes larger, and nodes which should be
connected end up being distant from each other,
and as such, are never connected.

The initial conﬁguration of the system has a ◦
node (representing the root) in the stack and the
entire sentence in the buffer. The terminal con-
ﬁguration consists of an empty buffer and a stack
with only the ◦ node. The transitions required to
parse the sentence The boy and the girl are shown
in Table 2, where the ﬁrst line shows the initial
conﬁguration and the last line shows the terminal
conﬁguration.

Similarly to the transitions of the ARCEAGER,
the above transitions construct edges as soon as the
head and the dependent are available in the stack,
with the aim of maximizing the parser incremen-
tality. We now show that our greedy transition-
based AMR parser is linear-time in n, the length of
the input sentence x. We ﬁrst claim that the output
graph has size O(n). Each token in x is mapped to
a constant number of nodes in the graph by Shift.
Thus the number of nodes is O(n). Furthermore,
each node can have at most three parent nodes,
created by transitions RArc, LArc and Reduce,
respectively. Thus the number of edges is also
O(n). It is possible to bound the maximum num-
ber of transitions required to parse x: the number
of Shift is bounded by n, and the number of Re-
duce, LArc and RArc is bounded by the size of
the graph, which is O(n). Since each transition
can be carried out in constant time, we conclude
that our parser runs in linear time.

4 Training the System

Several components have to be learned: (1) a tran-
sition classiﬁer that predicts the next transition
given the current conﬁguration, (2) a binary clas-
siﬁer that decides whether or not to create a reen-
trancy after a Reduce, (3) a concept identiﬁcation
step for each Shift to compute a(β0), and 3) an-
other classiﬁer to label edges after each LArc or

RArc.

4.1 Oracle

Training our
system from data requires an
oracle—an algorithm that given a gold-standard
AMR graph and a sentence returns transition se-
quences that maximize the overlap between the
gold-standard graph and the graph dictated by the
sequence of transitions.

We adopt a shortest stack, static oracle similar
to Chen and Manning (2014).
Informally, static
means that if the actual conﬁguration of the parser
has no mistakes, the oracle provides a transition
that does not introduce any mistake. Shortest stack
means that the oracle prefers transitions where the
number of items in the stack is minimized. Given
the current conﬁguration (σ, β, A) and the gold-
standard graph G = (Vg, Ag), the oracle is deﬁned
as follows, where we test the conditions in the
given order and apply the action associated with
the ﬁrst match:

1. if ∃ℓ[(σ0, ℓ, σ1) ∈ Ag] then LArc(ℓ);

2. if ∃ℓ[(σ1, ℓ, σ0) ∈ Ag] then RArc(ℓ);

3. if ¬∃i, ℓ[(σ0, ℓ, βi) ∈ Ag ∨ (βi, ℓ, σ0) ∈ Ag]

then Reduce;

4. Shift otherwise.

The oracle ﬁrst checks whether some gold-
standard edge can be constructed from the two el-
ements at the top of the stack (conditions 1 and 2).
If LArc or RArc are not possible, the oracle checks
whether all possible edges in the gold graph in-
volving σ0 have already been processed, in which
case it chooses Reduce (conditions 3). To this
end, it sufﬁces to check the buffer, since LArc and
RArc have already been excluded and elements in
the stack deeper than position two can no longer
be accessed by the parser. If Reduce is not possi-
ble, Shift is chosen.

Besides deciding on the next transition, the ora-
cle also needs the alignments, which we generate
with JAMR, in order to know how to map the next
token in the sentence to its AMR subgraph ←−π (i)
deﬁned in (1).

4.2 Transition Classiﬁer

Like all other transition systems of this kind, our
transition system has a “controller” that predicts a
transition given the current conﬁguration (among

stack
[◦]
[◦]
[◦, boy]
[◦, boy, and ]
[◦, and ]
[◦, and ]
[◦, and ]
[◦, and, girl ]
[◦, and, girl ]

action
-
Shift
Shift
Shift
LArc
RArc
Shift
Shift
RArc
Reduce [◦, and ]
Reduce [◦]

buffer
[the,boy,and,the,girl]
[boy,and,the,girl]
[and,the,girl]
[the,girl]
[the,girl]
[the,girl]
[girl]
[]
[]
[]
[]

edges
{}
{}
{}
{}
{hand,:op1,boyi} = A1
A1 ∪ {h◦,:top,andi} = A2
A2
A2
A2 ∪ {hand,:op2,girli} = A3
A3
A3

Table 2: Parsing steps for the sentence “The boy and the girl.”

Shift, LArc, RArc and Reduce). The examples
from which we learn this controller are based on
features extracted from the oracle transition se-
quences, where the oracle is applied on the train-
ing data.

As a classiﬁer, we use a feed-forward neural
network with two hidden layers of 200 tanh units
and learning rate set to 0.1, with linear decay-
ing. The input to the network consists of the
concatenation of embeddings for words, POS tags
and Stanford parser dependencies, one-hot vec-
tors for named entities and additional sparse fea-
tures, extracted from the current conﬁguration of
the transition system; this is reported in more de-
tails in Table 3. The embeddings for words and
POS tags were pre-trained on a large unanno-
tated corpus consisting of the ﬁrst 1 billion char-
acters from Wikipedia.8 For lexical information,
we also extract the leftmost (in the order of the
aligned words) child (c), leftmost parent (p) and
leftmost grandchild (cc). Leftmost and rightmost
items are common features for transition-based
parsers (Zhang and Nivre, 2011; Chen and Man-
ning, 2014) but we found only leftmost to be
helpful in our case. All POS tags, dependencies
and named entities are generated using Stanford
CoreNLP (Manning et al., 2014). The accuracy of
this classiﬁer on the development set is 84%.

Similarly, we train a binary classiﬁer for decid-
ing whether or not to create a reentrant edge after
a Reduce: in this case we use word and POS em-
beddings for the two nodes being connected and
their parent as well as dependency label embed-
dings for the arcs between them.

8http://mattmahoney.net/dc/enwik9.zip

4.3 Concept Identiﬁcation

This routine is called every time the transition
classiﬁer decides to do a Shift; it is denoted by a(·)
in §3. This component could be learned in a super-
vised manner, but we were not able to improve on
a simple heuristic, which works as follows: during
training, for each Shift decided by the oracle, we
store the pair (β0, ←−π (i)) in a phrase-table. Dur-
ing parsing, the most frequent graph H for the
given token is then chosen. In other words, a(i)
approximates ←−π (i) by means of the graph most
frequently seen among all occurrences of token xi
in the training set.

An obvious problem with the phrase-table ap-
proach is that it does not generalize to unseen
words. In addition, our heuristic relies on the fact
that the mappings observed in the data are correct,
which is not the case when the JAMR-generated
alignments contain a mistake. In order to alleviate
this problem we observe that there are classes of
words such as named entities and numeric quan-
tities that can be disambiguated in a deterministic
manner. We therefore implement a set of “hooks”
that are triggered by the named entity tag of the
next token in the sentence. These hooks override
the normal Shift mechanism and apply a ﬁxed rule
instead. For instance, when we see the token New
York (the two tokens are collapsed in a single one
at preprocessing) we generate the subgraph of Fig-
ure 4 and push its root onto the stack. Similar sub-
graphs are generated for all states, cities, countries
and people. We also use hooks for ordinal num-
bers, percentages, money and dates.

depth
children
parents
lexical

POS
entities
dependency

d(σ0), d(σ1)
#c(σ0), #c(σ1)
#p(σ0), #p(σ1)
w(σ0), w(σ1), w(β0), w(β1),
w(p(σ0)), w(c(σ0)), w(cc(σ0)),
w(p(σ1)), w(c(σ1)), w(cc(σ1))
s(σ0), s(σ1), s(β0), s(β1)
e(σ0), e(σ1), e(β0), e(β1)
ℓ(σ0, σ1), ℓ(σ1, σ0),
∀i ∈ {0, 1}: ℓ(σi, β0), ℓ(β0, σi)
∀i ∈ {1, 2, 3}: ℓ(β0, βi), ℓ(βi, β0)
∀i ∈ {1, 2, 3}: ℓ(σ0, βi), ℓ(βi, σ0)

Table 3: Features used in transition classiﬁer. The
function d maps a stack element to the depth of
the associated graph fragment. The functions #c
and #p count the number of children and par-
ents, respectively, of a stack element. The function
w maps a stack/buffer element to the word em-
bedding for the associated word in the sentence.
The function p gives the leftmost (according to the
alignment) parent of a stack element, the function
c the leftmost child and the function cc the leftmost
grandchild. The function s maps a stack/buffer el-
ement to the part-of-speech embedding for the as-
sociated word. The function e maps a stack/buffer
element to its entity. Finally, the function ℓ maps
a pair of symbols to the dependency label embed-
ding, according to the edge (or lack of) in the de-
pendency tree for the two words these symbols are
mapped to.

4.4 Edge Labeling

Edge labeling determines the labels for the edges
being created. Every time the transition classiﬁer
decides to take an LArc or RArc operation, the
edge labeler needs to decide on a label for it. There
are more than 100 possible labels such as :ARG0,
:ARG0-of, :ARG1, :location, :time and :polarity.
We use a feed-forward neural network similar to
the one we trained for the transition classier, with
features shown in Table 4. The accuracy of this
classiﬁer on the development set is 77%.

Labeling Rules Sometimes the label predicted
by the neural network is not a label that satisﬁes
the requirements of AMR. For instance, the la-
bel :top can only be applied when the node from
which the edge starts is the special ◦ node. In or-
der to avoid generating such erroneous labels, we
use a set of rules, shown in Table 5. These rules
determine which labels are allowed for the newly

:top

country

:name

name

:wiki

New York

:op1

New

:op2

York

Figure 4: Subgraph for “New York.”

name
depth
children
parents
lexical

POS
entities
dependency

feature template
d(σ0), d(σ1)
#c(σ0), #c(σ1)
#p(σ0), #p(σ1)
w(σ0), w(σ1),
w(p(σ0)), w(c(σ0)), w(cc(σ0)),
w(p(σ1)), w(c(σ1)), w(cc(σ1))
s(σ0), s(σ1)
e(σ0), e(σ1)
ℓ(σ0, β0), ℓ(β0, σ0)

Table 4: Features used in edge labeling. See Ta-
ble 3 for a legend of symbols.

created edge so that we only consider those during
prediction. Also ARG roles cannot always be ap-
plied: each Propbank frame allows a limited num-
ber of arguments. For example, while add-01 and
add-02 allow for :ARG1 and :ARG2 (and their in-
verse :ARG1-of and :ARG2-of ), add-03 and add-
04 only allow :ARG2 (and :ARG2-of ).

5 Fine-grained Evaluation

Until now, AMR parsers were evaluated using the
Smatch score.9 Given the candidate graphs and
the gold graphs in the form of AMR annotations,
Smatch ﬁrst tries to ﬁnd the best alignments be-
tween the variable names for each pair of graphs
and it then computes precision, recall and F1 of the
concepts and relations. We note that the Smatch
score has two ﬂaws: (1) while AMR parsing in-
volves a large number of subtasks, the Smatch
score consists of a single number that does not as-
sess the quality of each subtasks separately; (2) the
Smatch score weighs different types of errors in

9Since Smatch is an approximate randomized algorithm,
decimal points in the results vary between different runs and
are not reported. This approach was also taken by Wang et al.
(2015b) and others.

start
◦

end

label
:top
:polarity
:mode

:value
:day
:month
:year
:decade
:century
:weekday

:quarter
:season

ex.
Yes
Yes
Yes

No
No
No
No
No
No
Yes

No
Yes

d-ent
d-ent
d-ent
d-ent
d-ent
d-ent

d-ent
d-ent

:timezone Yes

d-ent

-
inter.|
expr.|imp.
“\w+” |[0-9]+
[1|2|· · · |31]
[1|2|· · · |12]+
[0-9]+
[0-9]+
[0-9]+
[monday|· · · |
sunday]
[1|2|3|4]+
[winter|fall|
spring|summer]+
[A−Z]3

Table 5: Labeling rules: For each edge label, we
provide regular expressions that must hold on the
labels at the start node (start) and the end node
(end) of the edge. Ex. indicates when the rule is
exclusive, d-ent is the AMR concept date-entity,
inter. is the AMR constant interrogative, expr. is
the AMR constant expressive, imp.
is the AMR
constant imperative.

a way which is not necessarily useful for solving
a speciﬁc NLP problem. For example, for a spe-
ciﬁc problem concept detection might be deemed
more important than edge detection, or guessing
the wrong sense for a concept might be consid-
ered less severe than guessing the wrong verb al-
together.

Consider the two parses for the sentence Silvio
Berlusconi gave Lucio Stanca his current role of
modernizing Italy’s bureaucracy in Figure 5. At
the top, we show the output of a parser (Parse 1)
that is not able to deal with named entities. At
the bottom, we show the output of a parser (Parse
2) which, except for :name, :op and :wiki, always
uses the edge label :ARG0. The Smatch scores for
the two parses are 56 and 78 respectively. Both
parses make obvious mistakes but the three named
entity errors in Parse 1 are considered more impor-
tant than the six wrong labels in Parse 2. However,
without further analysis, it is not advisable to con-
clude that Parse 2 is better than Parse 1. In order
to better understand the limitations of the differ-
ent parsers, ﬁnd their strengths and gain insight in
which downstream tasks they may be helpful, we
compute a set of metrics on the test set.

Unlabeled is the Smatch score computed on
the predicted graphs after removing all edge la-
bels. In this way, we only assess the node labels

( g / give-01

:ARG0 ( p3 / silvio :mod ( n4 / berlusconi ) )
:ARG1 ( r / role

:time ( c2 / current )
:mod ( m / modernize-01
:ARG0 p4
:ARG1 ( b / bureaucracy :part-of

:poss p4 )

:ARG2 ( p4 / person lucio :mod stanca ) )

( c3 /

italy ) ) )

( g / give-01

:ARG0 ( p3 / person :wiki ” S i l v i o B e r l u s c o n i ”

:name ( n4 / name :op1 ” S i l v i o ” :op2 ” B e r l u s c o n i ” ) )

:ARG0 ( r / role

:ARG0 ( c2 / current )
:ARG0 ( m / modernize-01
:ARG0 p4
:ARG0 ( b / bureaucracy

:ARG0 ( c3 / country :wiki ” I t a l y ”

:name ( n6 / name :op1 ” I t a l y ” ) ) ) )

:ARG0 p4 )

:ARG0 ( p4 / person :wiki −

:name ( n5 / name :op1 ” L u c i o ” :op2 ” S t a n c a ” ) ) )

Figure 5: Two parses for the sentence “Silvio
Berlusconi gave Lucio Stanca his current role of
modernizing Italy’s bureaucracy.”

and the graph topology, which may be enough to
beneﬁt several NLP tasks because it identiﬁes ba-
sic predicate-argument structure. For instance, we
may be interested in knowing whether two events
or entities are related to each other, while not being
concerned with the precise type of relation holding
between them.

No WSD gives a score that does not take into
account word sense disambiguation errors. By ig-
noring the sense speciﬁed by the Propbank frame
used (e.g., duck-01 vs duck-02) we have a score
that does not take into account this additional com-
plexity in the parsing procedure. To compute this
score, we simply strip off the sufﬁxes from all
Propbank frames and calculate the Smatch score.
Following Sawai et al. (2015), we also evalu-
ate the parsers using the Smatch score on noun
phrases only (NP-only), by extracting from the
AMR dataset all noun phrases that do not include
further NPs.

As we previously discussed, reentrancy is a very
important characteristic of AMR graphs and it is
not trivial to handle. We therefore implement a
test for it (Reentrancy), where we compute the
Smatch score only on reentrant edges.

Concept identiﬁcation is another critical com-
ponent of the parsing process and we therefore
compute the F-score on the list of predicted con-
cepts (Concepts) too. Identifying the correct con-
cepts is fundamental:
if a concept is not identi-
ﬁed, it will not be possible to retrieve any edge
involving that concept, with likely signiﬁcant con-
sequences on accuracy. This metric is therefore

First parse Second parse

Metric
Smatch
Unlabeled
No WSD
NP-only
Reentrancy
Concepts
Named Ent.
Wikiﬁcation
Negations
SRL

56
65
56
39
69
56
0
0
0
69

78
100
78
86
46
100
100
100
0
54

Metric
Smatch
Unlabeled
No WSD
NP-only
Reentrancy
Concepts
Named Ent.
Wikiﬁcation
Negations
SRL

J’14 C’15
63
58
69
61
64
58
54
47
41
38
80
79
75
75
0
0
18
16
60
55

J’16 Ours
67
64
69
69
68
65
58
55
42
41
83
83
83
79
75
64
48
45
60
56

Table 6: Evaluation of the two parses in Figure 5
with the proposed evaluation suite.

Table 7: Results on test split of LDC2015E86 for
JAMR, CAMR and our AMREAGER. J stands for
JAMR and C for CAMR (followed by the year of
publication). Best systems are in bold.

quite important to score highly on.

6 Experiments

Similarly to our score for concepts, we fur-
ther compute an F-score on the named entities
(Named Ent.) and wiki roles for named entities
(Wikiﬁcation) that consider edges labeled with
:name and :wiki respectively. These two metrics
are strictly related to the concept score. How-
ever, since named entity recognition is the fo-
cus of dedicated research, we believe it is impor-
tant to deﬁne a metric that speciﬁcally assesses
this problem. Negation detection is another task
which has received some attention. An F-score
for this (Negations) is also deﬁned, where we ﬁnd
all negated concepts by looking for the :polarity
role. The reason we can compute a simple F-score
instead of using Smatch for these metrics is that
there are no variable names involved.

Finally we compute the Smatch score on :ARG
edges only, in order to have a score for semantic
role labeling (SRL), which is another extremely
important subtask of AMR, as it is based on the
identiﬁcation of predicate-argument structures.

Using this evaluation suite we can evaluate
AMRs on a wide range of metrics that can help us
ﬁnd strengths and weakness of each parser, hence
speeding up the research in this area. Table 6 re-
ports the scores for the two parses of Figure 5,
where we see that Parse 1 gets a high score for
semantic role labeling while Parse 2 is optimal
for named entity recognition. Moreover, we can
make additional observations such as that Parse 2
is optimal with respect to unlabeled score and that
Parse 1 recovers more reentrancies.

We compare our parser10 against two available
parsers: JAMR (Flanigan et al., 2014) and CAMR
(Wang et al., 2015b; Wang et al., 2015a), using the
LDC2015E86 dataset for evaluation. Both parsers
are available online11 and were recently updated
for SemEval-2016 Task 8 (Flanigan et al., 2016;
Wang et al., 2016). However, CAMR’s SemEval
system, which reports a Smatch score of 67, is
not publicly available. CAMR has a quadratic
worst-case complexity (although linear in prac-
tice).
In JAMR, the concept identiﬁcation step
is quadratic and the relation identiﬁcation step is
O(|V |2 log |V |), with |V | being the set of nodes in
the AMR graph.

Table 7 shows the results obtained by the
parsers on all metrics previously introduced. On
Smatch, our system does not give state-of-the-art
results. However, we do obtain the best results
for Unlabeled and Concept and outperform the
other parses for Named Ent. and Negations. Our
score of Reentrancy is also close the best scor-
ing system, which is particularly relevant given
the importance of reentrancies in AMR. The use
of the Reduce transition, which targets reentran-
cies caused by control verbs, is critical in order to
achieve this result.

The relatively high results we obtain for the un-

10Our parser is available at https://github.com/
mdtux89/amr-eager, the evaluation suite at https:
//github.com/mdtux89/amr-evaluation
and a demo at http://cohort.inf.ed.ac.uk/
amreager.html

11JAMR:

https://github.com/jflanigan/
jamr, CAMR: https://github.com/c-amr/camr.

labeled case suggests that our parser has difﬁculty
in labeling the arcs. Our score for concept identi-
ﬁcation, which is on par with the best result from
the other parsers, demonstrates that there is a rel-
atively low level of token ambiguity. State-of-the-
art results for this problem can be obtained by
choosing the most frequent subgraph for a given
token based on a phrase-table constructed from
JAMR alignments on the training data. The scores
for named entities and wikiﬁcation are heavily de-
pendent on the hooks mentioned in §4.3, which
in turn relies on the named entity recognizer to
make the correct predictions. In order to alleviate
the problem of wrong automatic alignments with
respect to polarity and better detect negation, we
performed a post-processing step on the aligner
output where we align the AMR constant - (mi-
nus) with words bearing negative polarity such as
not, illegitimate and asymmetry.

Our experiments demonstrate that there is no
parser for AMR yet that conclusively does better
than all other parsers on all metrics. Advantages
of our parser are the worst-case linear complexity
and the fact that is possible to perform incremen-
tal AMR parsing, which is both helpful for real-
time applications and to investigate how meaning
of English sentences can be built incrementally
left-to-right.

7 Related Work

The ﬁrst data-driven AMR parser is due to Flani-
gan et al. (2014). The problem is addressed in
two separate stages: concept identiﬁcation and re-
lation identiﬁcation. They use a sequence label-
ing algorithm to identify concepts and frame the
relation prediction task as a constrained combina-
torial optimization problem. Werling et al. (2015)
notice that the difﬁcult bit is the concept identi-
ﬁcation and propose a better way to handle that
task: an action classiﬁer to generate concepts by
applying predetermined actions. Other propos-
als involve a synchronous hyperedge replacement
grammar solution (Peng et al., 2015), a syntax-
based machine translation approach (Pust et al.,
2015) where a grammar of string-to-tree rules is
created after reducing AMR graphs to trees by re-
moving all reentrancies, a CCG system that ﬁrst
parses sentences into lambda-calculus representa-
tions (Artzi et al., 2015). A systematic transla-
tion from AMR to ﬁrst order logic formulas, with
a special treatment for quantiﬁcation, reentrancy

and negation, is discussed in Bos (2016). In Van-
derwende et al. (2015), a pre-existing logical form
parser is used and the output is then converted into
AMR graphs. Yet another solution is proposed by
Rao et al. (2015) who discuss a parser that uses
SEARN (Daum´e III et al., 2009), a “learning to
search” algorithm.

Transition-based algorithms for AMR parsing
are compelling because traditional graph-based
techniques are computationally expensive. Wang
et al. (2015b) and Wang et al. (2015a) propose a
framework that parses a sentence into its AMR
structure through a two-stage process: a depen-
dency tree is generated from the input sentence
through a transition-based parser and then an-
other transition-based parser is used to generate
the AMR. The main beneﬁt of this approach is that
the dependency parser can be trained on a training
set much larger than the training set for the tree-
to-graph algorithm. Others further built on this
parser: Goodman et al. (2016) use imitation learn-
ing to alleviate the probem of error propagation
in the greedy parser, while Barzdins and Gosko
(2016) create a wrapper around it to ﬁx frequent
mistakes and investigate ensembles with a char-
acter level neural parser. More recently Zhou et
al. (2016) presented a non-greedy transition sys-
tem for AMR parsing, based on ARCSTANDARD
(Nivre, 2004).

AMR parsing as a whole is a complex task be-
cause it involves many subtasks including named
entity recognition, co-reference resolution and se-
mantic role labeling. Sawai et al. (2015) do not
attempt at parsing AMR graphs for entire sen-
tences but they instead handle simple noun phrases
(NPs). They extract NPs from the AMR dataset
only when they do not include further NPs, do not
include pronouns nor named entities. Due to these
restrictions, the AMRs are mostly trees and eas-
ier to handle than the original AMR graphs. They
approach this task using a transition based system
inspired by ARCSTANDARD.

AMR is not the only way to represent meaning
in natural language sentences. Alternative seman-
tic representations have been developed and stud-
ied, such as Boxer (Bos et al., 2004), CCG (Steed-
man, 1996; Steedman, 2000) and UCCA (Abend
and Rappoport, 2013).

8 Conclusion

We presented a transition system that builds AMR
graphs in linear time by processing the sentences
left-to-right, trained with feed-forward neural net-
works. The parser demonstrates that it is possi-
ble to perform AMR parsing using techniques in-
spired by dependency parsing.

We also noted that it is less informative to eval-
uate the entire parsing process with Smatch than
to use a collection of metrics aimed at evaluat-
ing the various subproblems in the parsing pro-
cess. We further showed that our left-to-right tran-
sition system is competitive with publicly avail-
able state-of-the-art parsers. Although we do not
outperform the best baseline in terms of Smatch
score, we show on par or better results for sev-
eral of the metrics proposed. We hope that moving
away from a single-metric evaluation will further
speed up progress in AMR parsing.

Acknowledgments

The authors would like to thank the three anony-
mous reviewers and Sameer Bansal, Jeff Flanigan,
Sorcha Gilroy, Adam Lopez, Nikos Papasaran-
topoulos, Nathan Schneider, Mark Steedman, Sam
Thomson, Clara Vania and Chuan Wang for their
help and comments. This research was supported
by a grant from Bloomberg and by the H2020
project SUMMA, under grant agreement 688139.

References

Omri Abend and Ari Rappoport. 2013. Universal con-
ceptual cognitive annotation (UCCA). In Proceed-
ings of ACL.

Yoav Artzi, Kenton Lee, and Luke Zettlemoyer. 2015.
Broad-coverage CCG semantic parsing with AMR.
Proceedings of EMNLP.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Grifﬁtt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract meaning representation
for sembanking. Proceedings of Linguistic Annota-
tion Workshop.

Guntis Barzdins and Didzis Gosko. 2016. RIGA at
SemEval-2016 task 8: Impact of smatch extensions
and character-level neural translation on AMR pars-
ing accuracy. arXiv preprint arXiv:1604.01278.

Johan Bos, Stephen Clark, Mark Steedman, James R
Curran, and Julia Hockenmaier.
2004. Wide-
coverage semantic representations from a ccg parser.

In Proceedings of COLING. Association for Compu-
tational Linguistics.

Johan Bos. 2016. Expressive power of abstract mean-
ing representations. Computational Linguistics, 42.

Shu Cai and Kevin Knight. 2013. Smatch: an evalua-
tion metric for semantic feature structures. Proceed-
ings of ACL.

Danqi Chen and Christopher D Manning. 2014. A fast
and accurate dependency parser using neural net-
works. In Proceesings of EMNLP.

Hal Daum´e III, John Langford, and Daniel Marcu.
2009. Search-based structured prediction. Machine
learning, 75(3):297–325.

Yantao Du, Fan Zhang, Weiwei Sun, and Xiaojun Wan.
2014. Peking: Proﬁling syntactic tree parsing tech-
niques for semantic graph parsing. In Proceedings
of the 8th International Workshop on Semantic Eval-
uation (SemEval-2014), pages 459–464.

Jeffrey Flanigan, Sam Thomson, Jaime G Carbonell,
Chris Dyer, and Noah A Smith. 2014. A discrim-
inative graph-based parser for the abstract meaning
representation. Proceedings of ACL.

Jeffrey Flanigan, Chris Dyer, Noah A Smith, and Jaime
Carbonell. 2016. CMU at SemEval-2016 task 8:
Graph-based AMR parsing with inﬁnite ramp loss.
Proceedings of SemEval, pages 1202–1206.

James Goodman, Andreas Vlachos, and Jason Narad-
owsky. 2016. Noise reduction and targeted explo-
ration in imitation learning for abstract meaning rep-
resentation parsing. Proceedings of ACL.

Marco Kuhlmann and Peter Jonsson.

2015. Pars-
ing to noncrossing dependency graphs. Transac-
tions of the Association for Computational Linguis-
tics, pages 559–570.

Christopher D. Manning, Mihai Surdeanu, John Bauer,
Jenny Finkel, Steven J. Bethard, and David Mc-
Closky. 2014. The Stanford CoreNLP natural lan-
In ACL System Demon-
guage processing toolkit.
strations.

Joakim Nivre. 2004. Incrementality in deterministic
dependency parsing. Proceedings of the Workshop
on Incremental Parsing: Bringing Engineering and
Cognition Together. ACL.

Joakim Nivre. 2008. Algorithms for deterministic in-
cremental dependency parsing. Computational Lin-
guistics, Volume 34, Number 4, December 2008.

Xiaochang Peng, Linfeng Song, and Daniel Gildea.
2015. A synchronous hyperedge replacement gram-
mar based approach for AMR parsing. Proceedings
of CoNLL.

Michael Pust, Ulf Hermjakob, Kevin Knight, Daniel
Marcu, and Jonathan May. 2015. Using syntax-
based machine translation to parse english into
arXiv preprint
abstract meaning representation.
arXiv:1504.06665.

Sudh Rao, Yogarshi Vyas, Hal Daume III, and Philip
Resnik. 2015. Parser for abstract meaning represen-
tation using learning to search. arXiv:1510.07586.

Corentin Ribeyre, ´Eric Villemonte de La Clergerie, and
Djam´e Seddah. 2015. Because syntax does matter:
Improving predicate-argument structures parsing us-
In Conference of the North
ing syntactic features.
American Chapter of the Association for Computa-
tional Linguistics: Human Language Technologies.

Kenji Sagae and Jun’ichi Tsujii. 2008. Shift-reduce
dependency DAG parsing. Proceedings of COL-
ING.

Yuichiro Sawai, Hiroyuki Shindo, and Yuji Matsumoto.
2015. Semantic structure analysis of noun phrases
using abstract meaning representation. Proceedings
of ACL.

Mark Steedman. 1996. Surface Structure and Inter-

pretation. The MIT Press.

Mark Steedman. 2000. The Syntactic Process. The

MIT Press.

Lucy Vanderwende, Arul Menezes, and Chris Quirk.
2015. An AMR parser for english, french, german,
spanish and japanese and a new AMR-annotated
corpus. Proceedings of NAACL-HLT.

Chuan Wang, Nianwen Xue, and Sameer Pradhan.
2015a. Boosting transition-based AMR parsing
with reﬁned actions and auxiliary analyzers. Pro-
ceedings of ACL.

Chuan Wang, Nianwen Xue, and Sameer Pradhan.
2015b. A transition-based algorithm for AMR pars-
ing. Proceedings of NAACL.

Chuan Wang, Sameer Pradhan, Nianwen Xue, Xiao-
man Pan, and Heng Ji. 2016. CAMR at SemEval-
2016 task 8: An extended transition-based AMR
parser. Proceedings of SemEval.

Keenon Werling, Gabor Angeli, and Christopher Man-
ning. 2015. Robust subgraph generation improves
arXiv
abstract meaning representation parsing.
preprint arXiv:1506.03139.

Yue Zhang and Joakim Nivre.

2011. Transition-
based dependency parsing with rich non-local fea-
tures. Proceedings of ACL.

Junsheng Zhou, Feiyu Xu, Hans Uszkoreit, Weiguang
QU, Ran Li, and Yanhui Gu. 2016. AMR parsing
with an incremental joint model. In Proceedings of
the 2016 Conference on Empirical Methods in Nat-
ural Language Processing.

From the Proceedings of EACL 2017 (Valencia, Spain). This version includes slightly more information

than the published version (January, 2017).

An Incremental Parser for Abstract Meaning Representation

Marco Damonte
School of Informatics
University of Edinburgh
m.damonte@sms.ed.ac.uk

Shay B. Cohen
School of Informatics
University of Edinburgh
scohen@inf.ed.ac.uk

Giorgio Satta
Dept. of Information Engineering
University of Padua
satta@dei.unipd.it

7
1
0
2
 
r
p
A
 
0
1
 
 
]
L
C
.
s
c
[
 
 
5
v
1
1
1
6
0
.
8
0
6
1
:
v
i
X
r
a

Abstract

Abstract Meaning Representation (AMR)
is a semantic representation for natural
language that embeds annotations related
to traditional tasks such as named entity
recognition, semantic role labeling, word
sense disambiguation and co-reference
resolution. We describe a transition-based
parser for AMR that parses sentences left-
to-right, in linear time. We further pro-
pose a test-suite that assesses speciﬁc sub-
tasks that are helpful in comparing AMR
parsers, and show that our parser is com-
petitive with the state of the art on the
LDC2015E86 dataset and that it outper-
forms state-of-the-art parsers for recover-
ing named entities and handling polarity.

1 Introduction

Semantic parsing aims to solve the problem
of canonicalizing language and representing its
meaning: given an input sentence, it aims to ex-
tract a semantic representation of that sentence.
Abstract meaning representation (Banarescu et al.,
2013), or AMR for short, allows us to do that
with the inclusion of most of the shallow-semantic
natural language processing (NLP) tasks that are
usually addressed separately, such as named en-
tity recognition, semantic role labeling and co-
reference resolution. AMR is partially motivated
by the need to provide the NLP community with
a single dataset that includes basic disambiguation
information, instead of having to rely on differ-
ent datasets for each disambiguation problem. The
annotation process is straightforward, enabling the
development of large datasets.

Several parsers for AMR have been recently de-
veloped (Flanigan et al., 2014; Wang et al., 2015a;
Peng et al., 2015; Pust et al., 2015; Goodman
et al., 2016; Rao et al., 2015; Vanderwende et
al., 2015; Artzi et al., 2015; Barzdins and Gosko,
2016; Zhou et al., 2016). This line of research
is new and current results suggest a large room
for improvement. Greedy transition-based meth-
ods (Nivre, 2008) are one of the most popular
choices for dependency parsing, because of their
good balance between efﬁciency and accuracy.
These methods seem promising also for AMR,
due to the similarity between dependency trees
and AMR structures, i.e., both representations use
graphs with nodes that have lexical content and
edges that represent linguistic relations.

A transition system is an abstract machine char-
acterized by a set of conﬁgurations and transitions
between them. The basic components of a con-
ﬁguration are a stack of partially processed words
and a buffer of unseen input words. Starting from
an initial conﬁguration, the system applies tran-
sitions until a terminal conﬁguration is reached.
The sentence is scanned left to right, with linear
time complexity for dependency parsing. This is
made possible by the use of a greedy classiﬁer that
chooses the transition to be applied at each step.

In this paper we introduce a parser for AMR that
is inspired by the ARCEAGER dependency tran-
sition system of Nivre (2004). The main differ-
ence between our system and ARCEAGER is that
we need to account for the mapping from word
tokens to AMR nodes, non-projectivity of AMR
structures and reentrant nodes (multiple incom-
ing edges). Our AMR parser brings closer depen-
dency parsing and AMR parsing by showing that
dependency parsing algorithms, with some mod-
iﬁcations, can be used for AMR. Key properties

such as working left-to-right, incrementality1 and
linear complexity further strengthen its relevance.
The AMR parser of Wang et al. (2015a), called
CAMR, also deﬁnes a transition system. It differs
from ours because we process the sentence left-to-
right while they ﬁrst acquire the entire dependency
tree and then process it bottom-up. More recently
Zhou et al. (2016) presented a non-greedy tran-
sition system for AMR parsing, based on ARC-
STANDARD (Nivre, 2004). Our transition sys-
tem is also related to an adaptation of ARCEAGER
for directed acyclic graphs (DAGs), introduced by
Sagae and Tsujii (2008). This is also the basis
for Ribeyre et al. (2015), a transition system used
to parse dependency graphs. Similarly, Du et al.
(2014) also address dependency graph parsing by
means of transition systems. Analogously to de-
pendency trees, dependency graphs have the prop-
erty that their nodes consist of the word tokens,
which is not true for AMR. As such, these transi-
tion systems are more closely related to traditional
transition systems for dependency parsing.

Our contributions in this paper are as follows:

• In §3 we develop a left-to-right, linear-time
transition system for AMR parsing, inspired
by the ARCEAGER transition system for de-
pendency tree parsing;

• In §5 we claim that the Smatch score (Cai
and Knight, 2013) is not sufﬁcient to evalu-
ate AMR parsers and propose a set of metrics
to alleviate this problem and better compare
alternative parsers;

• In §6 we show that our algorithm is compet-
itive with publicly available state-of-the-art
parsers on several metrics.

2 Background and Notation

AMR Structures AMRs are rooted and directed
graphs with node and edge labels. An annotation
example for the sentence I beg you to excuse me is
shown in Figure 1, with the AMR graph reported
in Figure 2.

Concepts are represented as labeled nodes in
the graph and can be either English words (e.g. I
and you) or Propbank framesets (e.g. beg-01 and
excuse-01). Each node in the graph is assigned to

1Strictly speaking,

transition-based parsing cannot
achieve full incrementality, which requires to have a single
connected component at all times (Nivre, 2004).

( b / beg-01

i

/

:ARG0 ( i
:ARG1 ( y / you)
:ARG2 ( e / excuse-01

:ARG0 y
:ARG1 i ) )

Figure 1: Annotation for the sentence “I beg you to
excuse me.” Variables are in boldface and concepts
and edge labels are in italics.

:top

beg-01

:ARG1

:ARG0

i

:ARG1

:ARG2

you

:ARG0

excuse-01

Figure 2: AMR graph representation for Figure 1.

a variable in the AMR annotation so that a variable
re-used in the annotation corresponds to reentran-
cies (multiple incoming edges) in the graph. Rela-
tions are represented as labeled and directed edges
in the graph.

Notation For most sentences in our dataset, the
AMR graph is a directed acyclic graph (DAG),
with a few speciﬁc cases where cycles are permit-
ted. These cases are rare, and for the purpose of
this paper, we consider AMR as DAGs.

We denote by [n] the set {1, . . . , n}. We deﬁne
an AMR structure as a tuple (G, x, π), where x =
x1 · · · xn is a sentence, with each xi, i ∈ [n], a
word token, and G is a directed graph G = (V, E)
with V and E the set of nodes and edges, respec-
tively.2 We assume G comes along with a node
labeling function and an edge labeling function.
Finally, π : V → [n] is a total alignment function
that maps every node of the graph to an index i
for the sentence x, with the meaning that node v
represents (part of) the concept expressed by the
word xπ(v).3

2We collapse all multi-word named entities in a single to-
ken (e.g., United Kingdom becomes United Kingdom) both
in training and parsing.

3π is a function because we do not consider co-references,
which would otherwise cause a node to map to multiple in-
dices. This is in line with current work on AMR parsing.

We note that the function π is not invertible,
since it is neither injective nor surjective. For each
i ∈ [n], we let

π−1(i) = {v | v ∈ V, π(v) = i}

be the pre-image of i under π (this set can be
empty for some i), which means that we map a to-
ken in the sentence to a set of nodes in the AMR.
In this way we can align each index i for x to the
induced subgraph of G. More formally, we deﬁne

←−π (i) = (π−1(i), E ∩ (π−1(i) × π−1(i))),

(1)

with the node and edge labeling functions of ←−π (i)
inherited from G. Hence, ←−π (i) returns the AMR
subgraph aligned with a particular token in the
sentence.

2.1 Transition-Based AMR Parsing

Similarly to dependency parsing, AMR parsing is
partially based on the identiﬁcation of predicate-
argument structures. Much of the dependency
parsing literature focuses on transition-based de-
pendency parsing—an approach to parsing that
scans the sentence from left to right in linear time
and updates an intermediate structure that eventu-
ally ends up being a dependency tree.

The two most common transition systems for
greedy dependency parsing are ARCSTANDARD
and ARCEAGER. With ARCSTANDARD, a stack
is maintained along with a buffer on which the
left-to-right scan is performed. At each step, the
parser chooses to scan a word in the buffer and
shift it onto the stack, or else to create an arc
between the two top-most elements in the stack
and pop the dependent. ARCSTANDARD parses
a sentence in a pure bottom-up, left-to-right fash-
ion (similarly to shift-reduce context-free gram-
mar parsers), and must delay the construction of
right arcs until all the dependent node has been
completed. This imposes strong limitations on
the degree of incrementality of the parser. The
ARCEAGER system was designed to improve on
ARCSTANDARD by mixing bottom up and top-
down strategies. More precisely, in the ARCEA-
GER parser left arcs are constructed bottom-up and
right arcs are constructed top-down, so that right
dependents can be attached to their heads even if
some of their own dependents are not identiﬁed
yet. In this way arcs are constructed as soon as the
head and the dependent are available in the stack.

◦

I

beg

you

excuse

Figure 3: AMR’s edges for the sentence “I beg
you to excuse me.” mapped back to the sentence,
according to the alignment. ◦ is a special token
representing the root.

Because of the similarity of AMR structures
to dependency structures, transition systems are
also helpful for AMR parsing. Starting from the
ARCEAGER system, we develop here a novel tran-
sition system, called AMREAGER that parses sen-
tences into AMR structures. There are three key
differences between AMRs and dependency trees
that require further adjustments for dependency
parsers to be used with AMRs.

Non-Projectivity A key difference between En-
glish dependency trees and AMR structures is pro-
jectivity. Dependency trees in English are usu-
ally projective, roughly meaning that there are no
crossing arcs if the edges are drawn in the semi-
plane above the words. While this restriction is
empirically motivated in syntactic theories for En-
glish, it is no longer motivated for AMR struc-
tures.

The notion of projectivity can be generalized to
AMR graphs as follows. The intuition is that we
can use the alignment π to map AMR edges back
to the sentence x, and test whether there exist pairs
of crossing edges. Figure 3 shows this mapping
for the AMR of Figure 2, where the edge connect-
ing excuse to I crosses another edge. More for-
mally, consider an AMR edge e = (u, ℓ, v). Let
π(u) = i and π(v) = j, so that u is aligned with
xi and v is aligned with xj. The spanning set for
e, written S(e), is the set of all nodes w such that
π(w) = k and i < k < j if i < j or j < k < i
if j < i. We say that e is projective if, for every
node w ∈ S(e), all of its parent and child nodes
are in S(e) ∪ {u, v}; otherwise, we say that e is
non-projective. An AMR is projective if all of its
edges are projective, and is non-projective other-
wise. This corresponds to the intuitive deﬁnition
of projectivity for DAGs introduced in Sagae and
Tsujii (2008) and is closely related to the deﬁni-
tion of non-crossing graphs of Kuhlmann and Jon-
sson (2015).

Non-projective edges
Non-projective AMRs
Reentrant edges
AMRs with at least one reentrancy

8%
35%
7%
51%

deﬁned in Equation (1). To obtain alignments be-
tween the tokens in the sentence and the nodes in
the AMR graph of our training data, we run the
JAMR aligner.7

Table 1: Statistics for non-projectivity and reen-
trancies in 200 AMR manually aligned with the
associated sentences.5

Table 1 demonstrates that a relatively small per-
centage of all AMR edges are non-projective. Yet,
35% of the sentences contain at least one non-
projective edge.

Reentrancy AMRs are graphs rather than trees
because they can have nodes with multiple par-
ents, called reentrant nodes, as in the node you for
the AMR of Figure 2. There are two phenomena
that cause reentrancies in AMR: control, where a
reentrant edge appears between siblings of a con-
trol verb, and co-reference, where multiple men-
tions correspond to the same concept.6

In contrast, dependency trees do not have nodes
with multiple parents. Therefore, when creating
a new arc, transition systems for dependency pars-
ing check that the dependent does not already have
a head node, preventing the node from having ad-
ditional parents. To handle reentrancy, which is
not uncommon in AMR structures as shown in Ta-
ble 1, we drop this constraint.

Alignment Another main difference with de-
pendency parsing is that
in AMR there is no
straightforward mapping between a word in the
sentence and a node in the graph: words may gen-
erate no nodes, one node or multiple nodes.
In
addition, the labels at the nodes are often not eas-
ily determined by the word in the sentence. For
instance expectation translates to expect-01 and
teacher translates to the two nodes teach-01 and
person, connected through an :ARG0 edge, ex-
pressing that a teacher is a person who teaches. A
mechanism of concept identiﬁcation is therefore
required to map each token xi to a subgraph with
the correct labels at its nodes and edges: if π is the
gold alignment, this should be the subgraph ←−π (i)

5https://github.com/jflanigan/jamr/

blob/master/docs/Hand_Alignments.md

6A valid criticism of AMR is that these two reentrancies
are of a completely different type, and should not be col-
lapsed together. Co-reference is a discourse feature, work-
ing by extra-semantic mechanisms and able to cross sentence
boundaries, which are not crossed in AMR annotation.

3 Transition system for AMR Parsing

A stack σ = σn| · · · |σ1|σ0 is a list of nodes
of the partially constructed AMR graph, with the
top element σ0 at the right. We use the sym-
bol ‘|’ as the concatenation operator. A buffer
β = β0|β1| · · · |βn is a list of indices from x, with
the ﬁrst element β0 at the left, representing the
word tokens from the input still to be processed.
A conﬁguration of our parser is a triple (σ, β, A),
where A is the set of AMR edges that have been
constructed up to this point.

In order to introduce the transition actions of
our parser we need some additional notation. We
use a function a that maps indices from x to AMR
graph fragments. For each i ∈ [n], a(i) is a graph
Ga = (Va, Ea), with single root root(Ga), repre-
senting the semantic contribution of word xi to the
AMR for x. As already mentioned, Ga can have
a single node representing the concept associated
with xi, or it can have several nodes in case xi de-
notes a complex concept, or it can be empty.

The transition Shift is used to decide if and
what to push on the stack after consuming a to-
ken from the buffer.
Intuitively, the graph frag-
ment a(β0) obtained from the token β0, if not
empty, is “merged” with the graph we have con-
structed so far. We then push onto the stack the
node root(a(β0)) for further processing. LArc(ℓ)
creates an edge with label ℓ between the top-most
node and the second top-most node in the stack,
and pops the latter. RArc(ℓ) is the symmetric op-
eration, but does not pop any node from the stack.
Finally, Reduce pops the top-most node from
the stack, and it also recovers reentrant edges be-
tween its sibling nodes, capturing for instance sev-
eral control verb patterns. To accomplish this, Re-
duce decides whether to create an additional edge
between the node being removed and the previ-
ously created sibling in the partial graph. This way
of handling control verbs is similar to the REEN-
TRANCE transition of Wang et al. (2015a).

The choice of popping the dependent in the
LArc transition is inspired by ARCEAGER, where
left-arcs are constructed bottom-up to increase
the incrementality of the transition system (Nivre,

7https://github.com/jflanigan/jamr

2004). This affects our ability to recover some
reentrant edges: consider a node u with two par-
ents v and v′, where the arc v → u is a left-arc and
v′ → u is any arc. If the ﬁrst arc to be processed is
v → u, we use LArc that pops u, hence making it
impossible to create the second arc v′ → u. Nev-
ertheless, we discovered that this approach works
better than a completely unrestricted allowance of
reentrancy. The reason is that if we do not remove
dependents at all when ﬁrst attached to a node, the
stack becomes larger, and nodes which should be
connected end up being distant from each other,
and as such, are never connected.

The initial conﬁguration of the system has a ◦
node (representing the root) in the stack and the
entire sentence in the buffer. The terminal con-
ﬁguration consists of an empty buffer and a stack
with only the ◦ node. The transitions required to
parse the sentence The boy and the girl are shown
in Table 2, where the ﬁrst line shows the initial
conﬁguration and the last line shows the terminal
conﬁguration.

Similarly to the transitions of the ARCEAGER,
the above transitions construct edges as soon as the
head and the dependent are available in the stack,
with the aim of maximizing the parser incremen-
tality. We now show that our greedy transition-
based AMR parser is linear-time in n, the length of
the input sentence x. We ﬁrst claim that the output
graph has size O(n). Each token in x is mapped to
a constant number of nodes in the graph by Shift.
Thus the number of nodes is O(n). Furthermore,
each node can have at most three parent nodes,
created by transitions RArc, LArc and Reduce,
respectively. Thus the number of edges is also
O(n). It is possible to bound the maximum num-
ber of transitions required to parse x: the number
of Shift is bounded by n, and the number of Re-
duce, LArc and RArc is bounded by the size of
the graph, which is O(n). Since each transition
can be carried out in constant time, we conclude
that our parser runs in linear time.

4 Training the System

Several components have to be learned: (1) a tran-
sition classiﬁer that predicts the next transition
given the current conﬁguration, (2) a binary clas-
siﬁer that decides whether or not to create a reen-
trancy after a Reduce, (3) a concept identiﬁcation
step for each Shift to compute a(β0), and 3) an-
other classiﬁer to label edges after each LArc or

RArc.

4.1 Oracle

Training our
system from data requires an
oracle—an algorithm that given a gold-standard
AMR graph and a sentence returns transition se-
quences that maximize the overlap between the
gold-standard graph and the graph dictated by the
sequence of transitions.

We adopt a shortest stack, static oracle similar
to Chen and Manning (2014).
Informally, static
means that if the actual conﬁguration of the parser
has no mistakes, the oracle provides a transition
that does not introduce any mistake. Shortest stack
means that the oracle prefers transitions where the
number of items in the stack is minimized. Given
the current conﬁguration (σ, β, A) and the gold-
standard graph G = (Vg, Ag), the oracle is deﬁned
as follows, where we test the conditions in the
given order and apply the action associated with
the ﬁrst match:

1. if ∃ℓ[(σ0, ℓ, σ1) ∈ Ag] then LArc(ℓ);

2. if ∃ℓ[(σ1, ℓ, σ0) ∈ Ag] then RArc(ℓ);

3. if ¬∃i, ℓ[(σ0, ℓ, βi) ∈ Ag ∨ (βi, ℓ, σ0) ∈ Ag]

then Reduce;

4. Shift otherwise.

The oracle ﬁrst checks whether some gold-
standard edge can be constructed from the two el-
ements at the top of the stack (conditions 1 and 2).
If LArc or RArc are not possible, the oracle checks
whether all possible edges in the gold graph in-
volving σ0 have already been processed, in which
case it chooses Reduce (conditions 3). To this
end, it sufﬁces to check the buffer, since LArc and
RArc have already been excluded and elements in
the stack deeper than position two can no longer
be accessed by the parser. If Reduce is not possi-
ble, Shift is chosen.

Besides deciding on the next transition, the ora-
cle also needs the alignments, which we generate
with JAMR, in order to know how to map the next
token in the sentence to its AMR subgraph ←−π (i)
deﬁned in (1).

4.2 Transition Classiﬁer

Like all other transition systems of this kind, our
transition system has a “controller” that predicts a
transition given the current conﬁguration (among

stack
[◦]
[◦]
[◦, boy]
[◦, boy, and ]
[◦, and ]
[◦, and ]
[◦, and ]
[◦, and, girl ]
[◦, and, girl ]

action
-
Shift
Shift
Shift
LArc
RArc
Shift
Shift
RArc
Reduce [◦, and ]
Reduce [◦]

buffer
[the,boy,and,the,girl]
[boy,and,the,girl]
[and,the,girl]
[the,girl]
[the,girl]
[the,girl]
[girl]
[]
[]
[]
[]

edges
{}
{}
{}
{}
{hand,:op1,boyi} = A1
A1 ∪ {h◦,:top,andi} = A2
A2
A2
A2 ∪ {hand,:op2,girli} = A3
A3
A3

Table 2: Parsing steps for the sentence “The boy and the girl.”

Shift, LArc, RArc and Reduce). The examples
from which we learn this controller are based on
features extracted from the oracle transition se-
quences, where the oracle is applied on the train-
ing data.

As a classiﬁer, we use a feed-forward neural
network with two hidden layers of 200 tanh units
and learning rate set to 0.1, with linear decay-
ing. The input to the network consists of the
concatenation of embeddings for words, POS tags
and Stanford parser dependencies, one-hot vec-
tors for named entities and additional sparse fea-
tures, extracted from the current conﬁguration of
the transition system; this is reported in more de-
tails in Table 3. The embeddings for words and
POS tags were pre-trained on a large unanno-
tated corpus consisting of the ﬁrst 1 billion char-
acters from Wikipedia.8 For lexical information,
we also extract the leftmost (in the order of the
aligned words) child (c), leftmost parent (p) and
leftmost grandchild (cc). Leftmost and rightmost
items are common features for transition-based
parsers (Zhang and Nivre, 2011; Chen and Man-
ning, 2014) but we found only leftmost to be
helpful in our case. All POS tags, dependencies
and named entities are generated using Stanford
CoreNLP (Manning et al., 2014). The accuracy of
this classiﬁer on the development set is 84%.

Similarly, we train a binary classiﬁer for decid-
ing whether or not to create a reentrant edge after
a Reduce: in this case we use word and POS em-
beddings for the two nodes being connected and
their parent as well as dependency label embed-
dings for the arcs between them.

8http://mattmahoney.net/dc/enwik9.zip

4.3 Concept Identiﬁcation

This routine is called every time the transition
classiﬁer decides to do a Shift; it is denoted by a(·)
in §3. This component could be learned in a super-
vised manner, but we were not able to improve on
a simple heuristic, which works as follows: during
training, for each Shift decided by the oracle, we
store the pair (β0, ←−π (i)) in a phrase-table. Dur-
ing parsing, the most frequent graph H for the
given token is then chosen. In other words, a(i)
approximates ←−π (i) by means of the graph most
frequently seen among all occurrences of token xi
in the training set.

An obvious problem with the phrase-table ap-
proach is that it does not generalize to unseen
words. In addition, our heuristic relies on the fact
that the mappings observed in the data are correct,
which is not the case when the JAMR-generated
alignments contain a mistake. In order to alleviate
this problem we observe that there are classes of
words such as named entities and numeric quan-
tities that can be disambiguated in a deterministic
manner. We therefore implement a set of “hooks”
that are triggered by the named entity tag of the
next token in the sentence. These hooks override
the normal Shift mechanism and apply a ﬁxed rule
instead. For instance, when we see the token New
York (the two tokens are collapsed in a single one
at preprocessing) we generate the subgraph of Fig-
ure 4 and push its root onto the stack. Similar sub-
graphs are generated for all states, cities, countries
and people. We also use hooks for ordinal num-
bers, percentages, money and dates.

depth
children
parents
lexical

POS
entities
dependency

d(σ0), d(σ1)
#c(σ0), #c(σ1)
#p(σ0), #p(σ1)
w(σ0), w(σ1), w(β0), w(β1),
w(p(σ0)), w(c(σ0)), w(cc(σ0)),
w(p(σ1)), w(c(σ1)), w(cc(σ1))
s(σ0), s(σ1), s(β0), s(β1)
e(σ0), e(σ1), e(β0), e(β1)
ℓ(σ0, σ1), ℓ(σ1, σ0),
∀i ∈ {0, 1}: ℓ(σi, β0), ℓ(β0, σi)
∀i ∈ {1, 2, 3}: ℓ(β0, βi), ℓ(βi, β0)
∀i ∈ {1, 2, 3}: ℓ(σ0, βi), ℓ(βi, σ0)

Table 3: Features used in transition classiﬁer. The
function d maps a stack element to the depth of
the associated graph fragment. The functions #c
and #p count the number of children and par-
ents, respectively, of a stack element. The function
w maps a stack/buffer element to the word em-
bedding for the associated word in the sentence.
The function p gives the leftmost (according to the
alignment) parent of a stack element, the function
c the leftmost child and the function cc the leftmost
grandchild. The function s maps a stack/buffer el-
ement to the part-of-speech embedding for the as-
sociated word. The function e maps a stack/buffer
element to its entity. Finally, the function ℓ maps
a pair of symbols to the dependency label embed-
ding, according to the edge (or lack of) in the de-
pendency tree for the two words these symbols are
mapped to.

4.4 Edge Labeling

Edge labeling determines the labels for the edges
being created. Every time the transition classiﬁer
decides to take an LArc or RArc operation, the
edge labeler needs to decide on a label for it. There
are more than 100 possible labels such as :ARG0,
:ARG0-of, :ARG1, :location, :time and :polarity.
We use a feed-forward neural network similar to
the one we trained for the transition classier, with
features shown in Table 4. The accuracy of this
classiﬁer on the development set is 77%.

Labeling Rules Sometimes the label predicted
by the neural network is not a label that satisﬁes
the requirements of AMR. For instance, the la-
bel :top can only be applied when the node from
which the edge starts is the special ◦ node. In or-
der to avoid generating such erroneous labels, we
use a set of rules, shown in Table 5. These rules
determine which labels are allowed for the newly

:top

country

:name

name

:wiki

New York

:op1

New

:op2

York

Figure 4: Subgraph for “New York.”

name
depth
children
parents
lexical

POS
entities
dependency

feature template
d(σ0), d(σ1)
#c(σ0), #c(σ1)
#p(σ0), #p(σ1)
w(σ0), w(σ1),
w(p(σ0)), w(c(σ0)), w(cc(σ0)),
w(p(σ1)), w(c(σ1)), w(cc(σ1))
s(σ0), s(σ1)
e(σ0), e(σ1)
ℓ(σ0, β0), ℓ(β0, σ0)

Table 4: Features used in edge labeling. See Ta-
ble 3 for a legend of symbols.

created edge so that we only consider those during
prediction. Also ARG roles cannot always be ap-
plied: each Propbank frame allows a limited num-
ber of arguments. For example, while add-01 and
add-02 allow for :ARG1 and :ARG2 (and their in-
verse :ARG1-of and :ARG2-of ), add-03 and add-
04 only allow :ARG2 (and :ARG2-of ).

5 Fine-grained Evaluation

Until now, AMR parsers were evaluated using the
Smatch score.9 Given the candidate graphs and
the gold graphs in the form of AMR annotations,
Smatch ﬁrst tries to ﬁnd the best alignments be-
tween the variable names for each pair of graphs
and it then computes precision, recall and F1 of the
concepts and relations. We note that the Smatch
score has two ﬂaws: (1) while AMR parsing in-
volves a large number of subtasks, the Smatch
score consists of a single number that does not as-
sess the quality of each subtasks separately; (2) the
Smatch score weighs different types of errors in

9Since Smatch is an approximate randomized algorithm,
decimal points in the results vary between different runs and
are not reported. This approach was also taken by Wang et al.
(2015b) and others.

start
◦

end

label
:top
:polarity
:mode

:value
:day
:month
:year
:decade
:century
:weekday

:quarter
:season

ex.
Yes
Yes
Yes

No
No
No
No
No
No
Yes

No
Yes

d-ent
d-ent
d-ent
d-ent
d-ent
d-ent

d-ent
d-ent

:timezone Yes

d-ent

-
inter.|
expr.|imp.
“\w+” |[0-9]+
[1|2|· · · |31]
[1|2|· · · |12]+
[0-9]+
[0-9]+
[0-9]+
[monday|· · · |
sunday]
[1|2|3|4]+
[winter|fall|
spring|summer]+
[A−Z]3

Table 5: Labeling rules: For each edge label, we
provide regular expressions that must hold on the
labels at the start node (start) and the end node
(end) of the edge. Ex. indicates when the rule is
exclusive, d-ent is the AMR concept date-entity,
inter. is the AMR constant interrogative, expr. is
the AMR constant expressive, imp.
is the AMR
constant imperative.

a way which is not necessarily useful for solving
a speciﬁc NLP problem. For example, for a spe-
ciﬁc problem concept detection might be deemed
more important than edge detection, or guessing
the wrong sense for a concept might be consid-
ered less severe than guessing the wrong verb al-
together.

Consider the two parses for the sentence Silvio
Berlusconi gave Lucio Stanca his current role of
modernizing Italy’s bureaucracy in Figure 5. At
the top, we show the output of a parser (Parse 1)
that is not able to deal with named entities. At
the bottom, we show the output of a parser (Parse
2) which, except for :name, :op and :wiki, always
uses the edge label :ARG0. The Smatch scores for
the two parses are 56 and 78 respectively. Both
parses make obvious mistakes but the three named
entity errors in Parse 1 are considered more impor-
tant than the six wrong labels in Parse 2. However,
without further analysis, it is not advisable to con-
clude that Parse 2 is better than Parse 1. In order
to better understand the limitations of the differ-
ent parsers, ﬁnd their strengths and gain insight in
which downstream tasks they may be helpful, we
compute a set of metrics on the test set.

Unlabeled is the Smatch score computed on
the predicted graphs after removing all edge la-
bels. In this way, we only assess the node labels

( g / give-01

:ARG0 ( p3 / silvio :mod ( n4 / berlusconi ) )
:ARG1 ( r / role

:time ( c2 / current )
:mod ( m / modernize-01
:ARG0 p4
:ARG1 ( b / bureaucracy :part-of

:poss p4 )

:ARG2 ( p4 / person lucio :mod stanca ) )

( c3 /

italy ) ) )

( g / give-01

:ARG0 ( p3 / person :wiki ” S i l v i o B e r l u s c o n i ”

:name ( n4 / name :op1 ” S i l v i o ” :op2 ” B e r l u s c o n i ” ) )

:ARG0 ( r / role

:ARG0 ( c2 / current )
:ARG0 ( m / modernize-01
:ARG0 p4
:ARG0 ( b / bureaucracy

:ARG0 ( c3 / country :wiki ” I t a l y ”

:name ( n6 / name :op1 ” I t a l y ” ) ) ) )

:ARG0 p4 )

:ARG0 ( p4 / person :wiki −

:name ( n5 / name :op1 ” L u c i o ” :op2 ” S t a n c a ” ) ) )

Figure 5: Two parses for the sentence “Silvio
Berlusconi gave Lucio Stanca his current role of
modernizing Italy’s bureaucracy.”

and the graph topology, which may be enough to
beneﬁt several NLP tasks because it identiﬁes ba-
sic predicate-argument structure. For instance, we
may be interested in knowing whether two events
or entities are related to each other, while not being
concerned with the precise type of relation holding
between them.

No WSD gives a score that does not take into
account word sense disambiguation errors. By ig-
noring the sense speciﬁed by the Propbank frame
used (e.g., duck-01 vs duck-02) we have a score
that does not take into account this additional com-
plexity in the parsing procedure. To compute this
score, we simply strip off the sufﬁxes from all
Propbank frames and calculate the Smatch score.
Following Sawai et al. (2015), we also evalu-
ate the parsers using the Smatch score on noun
phrases only (NP-only), by extracting from the
AMR dataset all noun phrases that do not include
further NPs.

As we previously discussed, reentrancy is a very
important characteristic of AMR graphs and it is
not trivial to handle. We therefore implement a
test for it (Reentrancy), where we compute the
Smatch score only on reentrant edges.

Concept identiﬁcation is another critical com-
ponent of the parsing process and we therefore
compute the F-score on the list of predicted con-
cepts (Concepts) too. Identifying the correct con-
cepts is fundamental:
if a concept is not identi-
ﬁed, it will not be possible to retrieve any edge
involving that concept, with likely signiﬁcant con-
sequences on accuracy. This metric is therefore

First parse Second parse

Metric
Smatch
Unlabeled
No WSD
NP-only
Reentrancy
Concepts
Named Ent.
Wikiﬁcation
Negations
SRL

56
65
56
39
69
56
0
0
0
69

78
100
78
86
46
100
100
100
0
54

Metric
Smatch
Unlabeled
No WSD
NP-only
Reentrancy
Concepts
Named Ent.
Wikiﬁcation
Negations
SRL

J’14 C’15
63
58
69
61
64
58
54
47
41
38
80
79
75
75
0
0
18
16
60
55

J’16 Ours
67
64
69
69
68
65
58
55
42
41
83
83
83
79
75
64
48
45
60
56

Table 6: Evaluation of the two parses in Figure 5
with the proposed evaluation suite.

Table 7: Results on test split of LDC2015E86 for
JAMR, CAMR and our AMREAGER. J stands for
JAMR and C for CAMR (followed by the year of
publication). Best systems are in bold.

quite important to score highly on.

6 Experiments

Similarly to our score for concepts, we fur-
ther compute an F-score on the named entities
(Named Ent.) and wiki roles for named entities
(Wikiﬁcation) that consider edges labeled with
:name and :wiki respectively. These two metrics
are strictly related to the concept score. How-
ever, since named entity recognition is the fo-
cus of dedicated research, we believe it is impor-
tant to deﬁne a metric that speciﬁcally assesses
this problem. Negation detection is another task
which has received some attention. An F-score
for this (Negations) is also deﬁned, where we ﬁnd
all negated concepts by looking for the :polarity
role. The reason we can compute a simple F-score
instead of using Smatch for these metrics is that
there are no variable names involved.

Finally we compute the Smatch score on :ARG
edges only, in order to have a score for semantic
role labeling (SRL), which is another extremely
important subtask of AMR, as it is based on the
identiﬁcation of predicate-argument structures.

Using this evaluation suite we can evaluate
AMRs on a wide range of metrics that can help us
ﬁnd strengths and weakness of each parser, hence
speeding up the research in this area. Table 6 re-
ports the scores for the two parses of Figure 5,
where we see that Parse 1 gets a high score for
semantic role labeling while Parse 2 is optimal
for named entity recognition. Moreover, we can
make additional observations such as that Parse 2
is optimal with respect to unlabeled score and that
Parse 1 recovers more reentrancies.

We compare our parser10 against two available
parsers: JAMR (Flanigan et al., 2014) and CAMR
(Wang et al., 2015b; Wang et al., 2015a), using the
LDC2015E86 dataset for evaluation. Both parsers
are available online11 and were recently updated
for SemEval-2016 Task 8 (Flanigan et al., 2016;
Wang et al., 2016). However, CAMR’s SemEval
system, which reports a Smatch score of 67, is
not publicly available. CAMR has a quadratic
worst-case complexity (although linear in prac-
tice).
In JAMR, the concept identiﬁcation step
is quadratic and the relation identiﬁcation step is
O(|V |2 log |V |), with |V | being the set of nodes in
the AMR graph.

Table 7 shows the results obtained by the
parsers on all metrics previously introduced. On
Smatch, our system does not give state-of-the-art
results. However, we do obtain the best results
for Unlabeled and Concept and outperform the
other parses for Named Ent. and Negations. Our
score of Reentrancy is also close the best scor-
ing system, which is particularly relevant given
the importance of reentrancies in AMR. The use
of the Reduce transition, which targets reentran-
cies caused by control verbs, is critical in order to
achieve this result.

The relatively high results we obtain for the un-

10Our parser is available at https://github.com/
mdtux89/amr-eager, the evaluation suite at https:
//github.com/mdtux89/amr-evaluation
and a demo at http://cohort.inf.ed.ac.uk/
amreager.html

11JAMR:

https://github.com/jflanigan/
jamr, CAMR: https://github.com/c-amr/camr.

labeled case suggests that our parser has difﬁculty
in labeling the arcs. Our score for concept identi-
ﬁcation, which is on par with the best result from
the other parsers, demonstrates that there is a rel-
atively low level of token ambiguity. State-of-the-
art results for this problem can be obtained by
choosing the most frequent subgraph for a given
token based on a phrase-table constructed from
JAMR alignments on the training data. The scores
for named entities and wikiﬁcation are heavily de-
pendent on the hooks mentioned in §4.3, which
in turn relies on the named entity recognizer to
make the correct predictions. In order to alleviate
the problem of wrong automatic alignments with
respect to polarity and better detect negation, we
performed a post-processing step on the aligner
output where we align the AMR constant - (mi-
nus) with words bearing negative polarity such as
not, illegitimate and asymmetry.

Our experiments demonstrate that there is no
parser for AMR yet that conclusively does better
than all other parsers on all metrics. Advantages
of our parser are the worst-case linear complexity
and the fact that is possible to perform incremen-
tal AMR parsing, which is both helpful for real-
time applications and to investigate how meaning
of English sentences can be built incrementally
left-to-right.

7 Related Work

The ﬁrst data-driven AMR parser is due to Flani-
gan et al. (2014). The problem is addressed in
two separate stages: concept identiﬁcation and re-
lation identiﬁcation. They use a sequence label-
ing algorithm to identify concepts and frame the
relation prediction task as a constrained combina-
torial optimization problem. Werling et al. (2015)
notice that the difﬁcult bit is the concept identi-
ﬁcation and propose a better way to handle that
task: an action classiﬁer to generate concepts by
applying predetermined actions. Other propos-
als involve a synchronous hyperedge replacement
grammar solution (Peng et al., 2015), a syntax-
based machine translation approach (Pust et al.,
2015) where a grammar of string-to-tree rules is
created after reducing AMR graphs to trees by re-
moving all reentrancies, a CCG system that ﬁrst
parses sentences into lambda-calculus representa-
tions (Artzi et al., 2015). A systematic transla-
tion from AMR to ﬁrst order logic formulas, with
a special treatment for quantiﬁcation, reentrancy

and negation, is discussed in Bos (2016). In Van-
derwende et al. (2015), a pre-existing logical form
parser is used and the output is then converted into
AMR graphs. Yet another solution is proposed by
Rao et al. (2015) who discuss a parser that uses
SEARN (Daum´e III et al., 2009), a “learning to
search” algorithm.

Transition-based algorithms for AMR parsing
are compelling because traditional graph-based
techniques are computationally expensive. Wang
et al. (2015b) and Wang et al. (2015a) propose a
framework that parses a sentence into its AMR
structure through a two-stage process: a depen-
dency tree is generated from the input sentence
through a transition-based parser and then an-
other transition-based parser is used to generate
the AMR. The main beneﬁt of this approach is that
the dependency parser can be trained on a training
set much larger than the training set for the tree-
to-graph algorithm. Others further built on this
parser: Goodman et al. (2016) use imitation learn-
ing to alleviate the probem of error propagation
in the greedy parser, while Barzdins and Gosko
(2016) create a wrapper around it to ﬁx frequent
mistakes and investigate ensembles with a char-
acter level neural parser. More recently Zhou et
al. (2016) presented a non-greedy transition sys-
tem for AMR parsing, based on ARCSTANDARD
(Nivre, 2004).

AMR parsing as a whole is a complex task be-
cause it involves many subtasks including named
entity recognition, co-reference resolution and se-
mantic role labeling. Sawai et al. (2015) do not
attempt at parsing AMR graphs for entire sen-
tences but they instead handle simple noun phrases
(NPs). They extract NPs from the AMR dataset
only when they do not include further NPs, do not
include pronouns nor named entities. Due to these
restrictions, the AMRs are mostly trees and eas-
ier to handle than the original AMR graphs. They
approach this task using a transition based system
inspired by ARCSTANDARD.

AMR is not the only way to represent meaning
in natural language sentences. Alternative seman-
tic representations have been developed and stud-
ied, such as Boxer (Bos et al., 2004), CCG (Steed-
man, 1996; Steedman, 2000) and UCCA (Abend
and Rappoport, 2013).

8 Conclusion

We presented a transition system that builds AMR
graphs in linear time by processing the sentences
left-to-right, trained with feed-forward neural net-
works. The parser demonstrates that it is possi-
ble to perform AMR parsing using techniques in-
spired by dependency parsing.

We also noted that it is less informative to eval-
uate the entire parsing process with Smatch than
to use a collection of metrics aimed at evaluat-
ing the various subproblems in the parsing pro-
cess. We further showed that our left-to-right tran-
sition system is competitive with publicly avail-
able state-of-the-art parsers. Although we do not
outperform the best baseline in terms of Smatch
score, we show on par or better results for sev-
eral of the metrics proposed. We hope that moving
away from a single-metric evaluation will further
speed up progress in AMR parsing.

Acknowledgments

The authors would like to thank the three anony-
mous reviewers and Sameer Bansal, Jeff Flanigan,
Sorcha Gilroy, Adam Lopez, Nikos Papasaran-
topoulos, Nathan Schneider, Mark Steedman, Sam
Thomson, Clara Vania and Chuan Wang for their
help and comments. This research was supported
by a grant from Bloomberg and by the H2020
project SUMMA, under grant agreement 688139.

References

Omri Abend and Ari Rappoport. 2013. Universal con-
ceptual cognitive annotation (UCCA). In Proceed-
ings of ACL.

Yoav Artzi, Kenton Lee, and Luke Zettlemoyer. 2015.
Broad-coverage CCG semantic parsing with AMR.
Proceedings of EMNLP.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Grifﬁtt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract meaning representation
for sembanking. Proceedings of Linguistic Annota-
tion Workshop.

Guntis Barzdins and Didzis Gosko. 2016. RIGA at
SemEval-2016 task 8: Impact of smatch extensions
and character-level neural translation on AMR pars-
ing accuracy. arXiv preprint arXiv:1604.01278.

Johan Bos, Stephen Clark, Mark Steedman, James R
Curran, and Julia Hockenmaier.
2004. Wide-
coverage semantic representations from a ccg parser.

In Proceedings of COLING. Association for Compu-
tational Linguistics.

Johan Bos. 2016. Expressive power of abstract mean-
ing representations. Computational Linguistics, 42.

Shu Cai and Kevin Knight. 2013. Smatch: an evalua-
tion metric for semantic feature structures. Proceed-
ings of ACL.

Danqi Chen and Christopher D Manning. 2014. A fast
and accurate dependency parser using neural net-
works. In Proceesings of EMNLP.

Hal Daum´e III, John Langford, and Daniel Marcu.
2009. Search-based structured prediction. Machine
learning, 75(3):297–325.

Yantao Du, Fan Zhang, Weiwei Sun, and Xiaojun Wan.
2014. Peking: Proﬁling syntactic tree parsing tech-
niques for semantic graph parsing. In Proceedings
of the 8th International Workshop on Semantic Eval-
uation (SemEval-2014), pages 459–464.

Jeffrey Flanigan, Sam Thomson, Jaime G Carbonell,
Chris Dyer, and Noah A Smith. 2014. A discrim-
inative graph-based parser for the abstract meaning
representation. Proceedings of ACL.

Jeffrey Flanigan, Chris Dyer, Noah A Smith, and Jaime
Carbonell. 2016. CMU at SemEval-2016 task 8:
Graph-based AMR parsing with inﬁnite ramp loss.
Proceedings of SemEval, pages 1202–1206.

James Goodman, Andreas Vlachos, and Jason Narad-
owsky. 2016. Noise reduction and targeted explo-
ration in imitation learning for abstract meaning rep-
resentation parsing. Proceedings of ACL.

Marco Kuhlmann and Peter Jonsson.

2015. Pars-
ing to noncrossing dependency graphs. Transac-
tions of the Association for Computational Linguis-
tics, pages 559–570.

Christopher D. Manning, Mihai Surdeanu, John Bauer,
Jenny Finkel, Steven J. Bethard, and David Mc-
Closky. 2014. The Stanford CoreNLP natural lan-
In ACL System Demon-
guage processing toolkit.
strations.

Joakim Nivre. 2004. Incrementality in deterministic
dependency parsing. Proceedings of the Workshop
on Incremental Parsing: Bringing Engineering and
Cognition Together. ACL.

Joakim Nivre. 2008. Algorithms for deterministic in-
cremental dependency parsing. Computational Lin-
guistics, Volume 34, Number 4, December 2008.

Xiaochang Peng, Linfeng Song, and Daniel Gildea.
2015. A synchronous hyperedge replacement gram-
mar based approach for AMR parsing. Proceedings
of CoNLL.

Michael Pust, Ulf Hermjakob, Kevin Knight, Daniel
Marcu, and Jonathan May. 2015. Using syntax-
based machine translation to parse english into
arXiv preprint
abstract meaning representation.
arXiv:1504.06665.

Sudh Rao, Yogarshi Vyas, Hal Daume III, and Philip
Resnik. 2015. Parser for abstract meaning represen-
tation using learning to search. arXiv:1510.07586.

Corentin Ribeyre, ´Eric Villemonte de La Clergerie, and
Djam´e Seddah. 2015. Because syntax does matter:
Improving predicate-argument structures parsing us-
In Conference of the North
ing syntactic features.
American Chapter of the Association for Computa-
tional Linguistics: Human Language Technologies.

Kenji Sagae and Jun’ichi Tsujii. 2008. Shift-reduce
dependency DAG parsing. Proceedings of COL-
ING.

Yuichiro Sawai, Hiroyuki Shindo, and Yuji Matsumoto.
2015. Semantic structure analysis of noun phrases
using abstract meaning representation. Proceedings
of ACL.

Mark Steedman. 1996. Surface Structure and Inter-

pretation. The MIT Press.

Mark Steedman. 2000. The Syntactic Process. The

MIT Press.

Lucy Vanderwende, Arul Menezes, and Chris Quirk.
2015. An AMR parser for english, french, german,
spanish and japanese and a new AMR-annotated
corpus. Proceedings of NAACL-HLT.

Chuan Wang, Nianwen Xue, and Sameer Pradhan.
2015a. Boosting transition-based AMR parsing
with reﬁned actions and auxiliary analyzers. Pro-
ceedings of ACL.

Chuan Wang, Nianwen Xue, and Sameer Pradhan.
2015b. A transition-based algorithm for AMR pars-
ing. Proceedings of NAACL.

Chuan Wang, Sameer Pradhan, Nianwen Xue, Xiao-
man Pan, and Heng Ji. 2016. CAMR at SemEval-
2016 task 8: An extended transition-based AMR
parser. Proceedings of SemEval.

Keenon Werling, Gabor Angeli, and Christopher Man-
ning. 2015. Robust subgraph generation improves
arXiv
abstract meaning representation parsing.
preprint arXiv:1506.03139.

Yue Zhang and Joakim Nivre.

2011. Transition-
based dependency parsing with rich non-local fea-
tures. Proceedings of ACL.

Junsheng Zhou, Feiyu Xu, Hans Uszkoreit, Weiguang
QU, Ran Li, and Yanhui Gu. 2016. AMR parsing
with an incremental joint model. In Proceedings of
the 2016 Conference on Empirical Methods in Nat-
ural Language Processing.

