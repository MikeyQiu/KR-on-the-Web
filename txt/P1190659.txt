9
1
0
2
 
n
a
J
 
9
2
 
 
]
L
M

.
t
a
t
s
[
 
 
4
v
0
6
9
0
0
.
0
1
6
1
:
v
i
X
r
a

An Inexact Variable Metric Proximal Point Algorithm
for Generic Quasi-Newton Acceleration

Hongzhou Lin
MIT∗
hongzhou@mit.edu

Julien Mairal
Inria†
julien.mairal@inria.fr

Zaid Harchaoui
University of Washington‡
zaid@uw.edu

January 30, 2019

Abstract

We propose an inexact variable metric proximal point algorithm to accelerate gradient-based optimiza-
tion algorithms. The proposed scheme, called QNing, can be notably applied to incremental ﬁrst-order
methods such as the stochastic variance-reduced gradient descent algorithm (SVRG) and other randomized
incremental optimization algorithms. QNing is also compatible with composite objectives, meaning that
it has the ability to provide exactly sparse solutions when the objective involves a sparsity-inducing
regularization. When combined with limited-memory BFGS rules, QNing is particularly eﬀective to solve
high-dimensional optimization problems, while enjoying a worst-case linear convergence rate for strongly
convex problems. We present experimental results where QNing gives signiﬁcant improvements over
competing methods for training machine learning methods on large samples and in high dimensions.

1

Introduction

Convex composite optimization arises in many scientiﬁc ﬁelds, such as image and signal processing or machine
learning. It consists of minimizing a real-valued function composed of two convex terms:

n

min
x∈Rd

f (x) (cid:44) f0(x) + ψ(x)

o

,

(1)

where f0 is smooth with Lipschitz continuous derivatives, and ψ is a regularization function which is not
necessarily diﬀerentiable. A typical example from the signal and image processing literature is the ‘1-norm
ψ(x) = kxk1, which encourages sparse solutions [19, 40]; composite minimization also encompasses constrained
minimization when considering extended-valued indicator functions ψ that may take the value +∞ outside of
a convex set C and 0 inside (see [28]). In general, algorithms that are dedicated to composite optimization
only require to be able to compute eﬃciently the proximal operator of ψ:

pψ(y) (cid:44) arg min

ψ(x) +

kx − yk2

,

(cid:26)

x∈Rd

1
2

(cid:27)

where k · k denotes the Euclidean norm. Note that when ψ is an indicator function, the proximal operator
corresponds to the simple Euclidean projection.

To solve (1), signiﬁcant eﬀorts have been devoted to (i) extending techniques for smooth optimization
to deal with composite terms; (ii) exploiting the underlying structure of the problem—is f a ﬁnite sum of

∗Computer Science and Artiﬁcial Intelligence Laboratory Cambridge, MA 02139, USA. This work was performed in large

parts while Hongzhou Lin was at Inria.

†Univ. Grenoble Alpes, Inria, CNRS, Grenoble INP, LJK, Grenoble, 38000, France.
‡Department of Statistics Seattle, WA 98195, USA.

1

independent terms? Is ψ separable in diﬀerent blocks of coordinates? (iii) exploiting the local curvature of
the smooth term f to achieve faster convergence than gradient-based approaches when the dimension d is
large. Typically, the ﬁrst point is well understood in the context of optimal ﬁrst-order methods, see [2, 49],
and the third point is tackled with eﬀective heuristics such as L-BFGS when the problem is smooth [35, 50].
Yet, addressing all these challenges at the same time is diﬃcult, which is precisely the focus of this paper.

In particular, a problem of interest that initially motivated our work is that of empirical risk minimization
(ERM); the problem arises in machine learning and can be formulated as the minimization of a composite
function f : Rd → R:

(
f (x) (cid:44) 1
n

min
x∈Rd

n
X

i=1

)

fi(x) + ψ(x)

,

(2)

where the functions fi are convex and smooth with Lipschitz continuous derivatives, and ψ is a composite
term, possibly non-smooth. The function fi measures the ﬁt of some model parameters x to a speciﬁc
data point indexed by i, and ψ is a regularization penalty to prevent over-ﬁtting. To exploit the sum
structure of f , a large number of randomized incremental gradient-based techniques have been proposed,
such as SAG [57], SAGA [15], SDCA [59], SVRG [61], Finito [16], or MISO [38]. These approaches access a
single gradient ∇fi(x) at every iteration instead of the full gradient (1/n) Pn
i=1 ∇fi(x) and achieve lower
computational complexity in expectation than optimal ﬁrst-order methods [2, 49] under a few assumptions.
Yet, these methods are unable to exploit the curvature of the objective function; this is indeed also the case
for variants that are accelerated in the sense of Nesterov [21, 33, 59].

To tackle (2), dedicated ﬁrst-order methods are often the default choice in machine learning, but it is
also known that standard Quasi-Newton approaches can sometimes be surprisingly eﬀective in the smooth
case—that is when ψ = 0, see, e.g., [57] for extensive benchmarks. Since the dimension of the problem d
is typically very large (d ≥ 10 000), “limited memory” variants of these algorithms, such as L-BFGS, are
necessary to achieve the desired scalability [35, 50]. The theoretical guarantees oﬀered by L-BFGS are
somewhat limited, meaning that it does not outperform accelerated ﬁrst-order methods in terms of worst-case
convergence rate, and also it is not guaranteed to correctly approximate the Hessian of the objective. Yet,
L-BFGS remains one of the greatest practical success of smooth optimization. Adapting L-BFGS to composite
and structured problems, such as the ﬁnite sum of functions (2), is of utmost importance nowadays.

For instance, there have been several attempts to develop a proximal Quasi-Newton method [10, 31, 55, 63].
These algorithms typically require computing many times the proximal operator of ψ with respect to a
variable metric. Quasi-Newton steps were also incorporated as local search steps into accelerated ﬁrst-order
methods to further enhance their numerical performance [24]. More related to our work, L-BFGS is combined
with SVRG for minimizing smooth ﬁnite sums in [26]. The scope of our approach is broader beyond the
case of SVRG. We present a generic Quasi-Newton scheme, applicable to a large-class of ﬁrst-order methods
for composite optimization, including other incremental algorithms [15, 16, 38, 57, 59] and block coordinate
descent methods [52, 53]

More precisely, the main contribution of this paper is a generic meta-algorithm, called QNing (the
letters “Q” and “N” stand for Quasi-Newton), which uses a given optimization method to solve a sequence
of auxiliary problems up to some appropriate accuracy, resulting in faster global convergence in practice.
QNing falls into the class of inexact proximal point algorithms with variable metric and may be seen as
applying a Quasi-Newton algorithm with inexact (but accurate enough) gradients to the Moreau envelope of
the objective. As a result, our approach is (i) generic, as stated previously; (ii) despite the smoothing of the
objective, the sub-problems that we solve are composite ones, which may lead to exactly sparse iterates when
a sparsity-inducing regularization is involved, e.g., the ‘1-norm; (iii) when used with L-BFGS rules, it admits
a worst-case linear convergence rate for strongly convex problems similar to that of gradient descent, which is
typically the best guarantees obtained for L-BFGS schemes in the literature.

The idea of combining second-order or Quasi-Newton methods with Moreau envelope is in fact relatively
old. It may be traced back to variable metric proximal bundle methods [14, 23, 41], which aims to incorporate
curvature information into the bundle methods. Our approach revisits this principle with a limited-memory
variant (to deal with large dimension d), with a simple line search scheme, with several warm start strategies

2

for the sub-problems and with a global complexity analysis that is more relevant than convergence rates that
do not take into account the cost per iteration.

To demonstrate the eﬀectiveness of our scheme in practice, we evaluate QNing on regularized logistic
regression and regularized least-squares, with smooth and nonsmooth regularization penalities such as the
Elastic-Net [64]. We use large-scale machine learning datasets and show that QNing performs at least as well
as the recently proposed accelerated incremental algorithm Catalyst [33], and other Quasi-Newton baselines
such as proximal Quasi-Newton methods [31] and Stochastic L-BFGS [44] in all numerical experiments, and
signiﬁcantly outperforms them in many cases.

The paper is organized as follows: Section 2 presents related work on Quasi-Newton methods such as
L-BFGS; we introduce QNing in Section 3 and its convergence analysis in Section 4; Section 5 is devoted to
numerical experiments and Section 6 concludes the paper.

2 Related work and preliminaries

The history of Quasi-Newton methods can be traced back to the 1950’s [6, 29, 51]. Quasi-Newton methods
often lead to signiﬁcantly faster convergence in practice compared to simpler gradient-based methods for
solving smooth optimization problems [56]. Yet, a theoretical analysis of Quasi-Newton methods that explains
their impressive empirical behavior is still an open topic. Here, we brieﬂy review the well-known BFGS
algorithm in Section 2.1, its limited memory variant [50], and a few recent extensions in Section 2.2. Then,
we present earlier works that combine proximal point algorithm and Quasi-Newton methods in Section 2.3.

2.1 Quasi-Newton methods for smooth optimization

The most popular Quasi-Newton method is probably BFGS, named after its inventors (Broyden-Fletcher-
Goldfarb-Shanno), and its limited variant L-BFGS [51]. These approaches will be the workhorses of the
QNing meta-algorithm in practice. Consider a smooth convex objective f to be minimized, the BFGS method
constructs at iteration k a couple (xk, Bk) with the following update:

xk+1 = xk − αkB−1

k ∇f (xk)

and Bk+1 = Bk −

k Bk

Bksks>
s>
k Bksk

+

yky>
k
y>
k sk

,

(3)

where αk is a suitable stepsize and

sk = xk+1 − xk,

yk = ∇f (xk+1) − ∇f (xk).

The matrix Bk aims to approximate the Hessian matrix at the iterate xk. When f is strongly convex, the
positive deﬁniteness of Bk is guaranteed, as well as the condition y>
k sk > 0, which ensures that (3) is well
deﬁned. The stepsize αk is usually determined by a line search strategy. For instance, applying Wolfe’s
line-search strategy provides linear convergence rate for strongly convex objectives. Moreover, under stronger
conditions that the objective f is twice diﬀerentiable and its Hessian is Lipschitz continuous, the algorithm
can asymptotically achieve superlinear convergence rate [51].

However, when the dimension d is large, storing the d-by-d matrix Bk is infeasible. The limited memory
variant L-BFGS [50] overcomes this issue by restricting the matrix Bk to be low rank. More precisely, instead
of storing the full matrix, a “generating list” of at most l pairs of vectors {(sk
i )}i=0...j is kept in memory.
The low rank matrix Bk can then be recovered by performing the matrix update recursion in (3) involving all
pairs of the generating list. Between iteration k and k + 1, the generating list is incrementally updated, by
removing the oldest pair in the list (when j = l) and adding a new one. What makes the approach appealing
is the ability of computing the matrix-vector product Hkz = B−1
k z with only O(ld) ﬂoating point operations
for any vector z. This procedure entirely relies on vector-vector product which does not explicitly construct
the d-by-d matrix Bk or Hk. The price to pay is that superlinear convergence becomes out of reach.

i , yk

L-BFGS is thus appropriate for high-dimensional problems (when d is large), but it still requires computing
the full gradient at each iteration, which may be cumbersome in the large sum setting (2). This motivated

3

stochastic counterparts of the Quasi-Newton methods (SQN) [8, 42, 58]. Unfortunately, directly substituting
the full gradient ∇f (xk) by its stochastic counterpart does not lead to a convergent scheme.
Instead,
the SQN method [8] uses updates with sub-sampled Hessian-vector products, which leads to a sublinear
convergence rate. Later, a linearly-convergent SQN algorithm is proposed by exploiting a variance reduction
scheme [26, 44]. However, it is unclear how to extend these techniques into the composite setting.

2.2 Quasi-Newton methods for composite optimization

Diﬀerent approaches have been proposed to extend Quasi-Newton methods to composite optimization
problems. A ﬁrst approach consists in minimizing successive quadratic approximations, also called proximal
Quasi-Newton methods [10, 25, 30, 31, 36, 55]. More concretely, a local quadratic approximation qk is
minimized at each iteration:

qk(x) (cid:44) f0(xk) + h∇f0(xk), x − xki +

(x − xk)T Bk(x − xk) + ψ(x),

(4)

1
2

where Bk is a Hessian approximation based on Quasi-Newton methods. The minimizer of qk provides a
descent direction, which is subsequently used to build the next iterate. However, a closed form solution
of (4) is usually not available since Bk changes over the iterations. Thus, one needs to apply an optimization
algorithm to approximately solve (4). The composite structure of the subproblem naturally leads to choosing
a ﬁrst-order optimization algorithm, such as randomized coordinate descent algorithms. Then, superlinear
complexity becomes out of reach since it requires the subproblems (4) to be solved with “high accuracy” [31].
The global convergence rate of this inexact variant has been for instance analyzed in [55], where a sublinear
convergence rate is obtained for convex problems; later, the analysis has been extended to strongly convex
problems in [36], where linear convergence rate is achieved.

A second approach of extending Quasi-Newton methods to composite optimization problems is based
on smoothing techniques. More precisely, a Quasi-Newton method is applied to a smoothed version of
the objective. For instance, one may use the forward-backward envelope [4, 60]. The idea is to mimic
forward-backward splitting methods and apply Quasi-Newton instead of gradient steps on top of the envelope.
Another well known smoothing technique is to apply the Moreau-Yosida regularization [43, 62] which gives the
smoothed function called Moreau envelope. Then apply Quasi-Newton methods on it leads to the family of
variable metric proximal point algorithms [7, 14, 22, 23]. Our method pursues this line of work by developing
a practical inexact variant with global complexity guarantees.

2.3 Combining the proximal point algorithm and Quasi-Newton methods

We brieﬂy recall the deﬁnition of the Moreau envelope and its basic properties.

Deﬁnition 1. Given an objective function f and a smoothing parameter κ > 0, the Moreau envelope of f
is the function F obtained by performing the inﬁmal convolution

F (x) (cid:44) min
z∈Rd

n

f (z) +

kz − xk2o

.

κ
2

(5)

When f is convex, the sub-problem deﬁned in (5) is strongly convex which provides an unique minimizer,

called the proximal point of x, which we denote by p(x).

Proposition 1 (Basic properties of the Moreau Envelope). If f is convex, the Moreau envelope F
deﬁned in (5) satisﬁes

1. F has the same minimum as f , i.e.

and the solution set of the two above problems coincide with each other.

min
x∈Rd

F (x) = min
x∈Rd

f (x),

4

(6)

(7)

(8)

(9)

2. F is continuously diﬀerentiable even when f is not and

∇F (x) = κ(x − p(x)).

Moreover the gradient ∇F is Lipschitz continuous with constant LF = κ.

3. F is convex; moreover, when f is µ-strongly convex with respect to the Euclidean norm, F is µF -strongly

convex with µF = µκ

µ+κ .

4. F is upper-bounded by f . More precisely, for any x ∈ Rd,

F (x) +

k∇F (x)k2 ≤ f (x).

1
2κ

q =

LF
µF

=

µ + κ
µ

,

Interestingly, F inherits all the convex properties of f and more importantly it is always continuously

diﬀerentiable, see [32] for elementary proofs. Moreover, the condition number of F is given by

which may be adjusted by the regularization parameter κ. Then, a naive approach to overcome the non-
smoothness of the function f is to transfer the optimization problem to its Moreau envelope F . More
concretely, we may apply an optimization algorithm to minimize F and use the obtained solution as a solution
to the original problem, since both functions share the same minimizers. This yields the following well-known
algorithms.

Proximal point algorithm. Consider the gradient descent method with constant step size 1/LF :

By rewriting the gradient ∇F (xk) as κ(xk − p(xk)), we obtain the proximal point algorithm [54]:

xk+1 = xk −

∇F (xk).

1
κ

n

xk+1 = p(xk) = arg min

f (z) +

z∈Rd

kz − xkk2o

.

κ
2

Accelerated proximal point algorithm. Since gradient descent on F yields the proximal point algorithm,
it is natural to apply an accelerated ﬁrst-order method to get faster convergence. To that eﬀect, Nesterov’s
algorithm [45] uses a two-stage update, along with a speciﬁc extrapolation parameter βk+1:

xk+1 = yk −

∇F (yk)

and

yk+1 = xk+1 + βk+1(xk+1 − xk),

1
κ

and, given (6), we obtain that

xk+1 = p(yk)

and

yk+1 = xk+1 + βk+1(xk+1 − xk),

This is known as the accelerated proximal point algorithm introduced by Güler [27], which was recently
extended in [33, 34].

Variable metric proximal point algorithm. One can also apply Quasi-Newton methods on F , which
yields

xk+1 = xk − αkB−1

k ∇F (xk),

(10)

where Bk is the Hessian approximation of F based on Quasi-Newton methods. This is known as the variable
metric proximal point algorithm [7, 14, 22, 23].

5

Towards an inexact variable metric proximal point algorithm. Quasi-Newton approaches have been
applied after inexact Moreau envelope in various ways [7, 14, 22, 23]. In particular, it is shown in [14] that if
the sub-problems (5) are solved up to high enough accuracy, then the inexact variable metric proximal point
algorithm preserves the superlinear convergence rate. However, the complexity for solving the sub-problems
with high accuracy is typically not taken into account in these previous works.

In the unrealistic case where p(xk) can be obtained at no cost, proximal point algorithm can aﬀord much
larger step sizes than classical gradient methods, thus are more eﬀective. For instance, when f is strongly
convex, the Moreau envelope F can be made arbitrarily well-conditioned by making κ arbitrarily small,
according to (8). Then, a single gradient step on F is enough to be arbitrarily close to the optimum. In
practice, however, sub-problems are solved only approximately and the complexity of solving the sub-problems
is directly related to the smoothing parameter κ. This leaves an important question: how to choose the
smoothing parameter κ. A small κ makes the smoothed function F better conditioned, while a large κ is
needed to improve the conditioning of the sub-problem (5).

The main contribution of our paper is to close this gap by providing a global complexity analysis
which takes into account the complexity of solving the subproblems. More concretely, in the proposed
QNing algorithm, we provide i) a practical stopping criterion for the sub-problems; ii) several warm-start
strategies; iii) a simple line-search strategy which guarantees suﬃcient descent in terms of function value.
These three components together yield the global convergence analysis, which allows us to use ﬁrst-order
method as a subproblem solver. Moreover, the global complexity we developed depends on the smoothing
parameter κ, which provides some insight about how to practically choose this parameter.

In the composite setting, both proximal Quasi-
Solving the subproblems with ﬁrst-order algorithms.
Newton methods and the variable metric proximal point algorithm require solving sub-problems, namely (4)
and (5), respectively. In the general case, when a generic ﬁrst-order method—e.g., proximal gradient descent—
is used, our worst-case complexity analysis does not provide a clear winner, and our experiments in Section 5.4
conﬁrm that both approaches perform similarly. However, when it is possible to exploit the speciﬁc structure
of the sub-problems in one case, but not in the other one, the conclusion may diﬀer.

For instance, when the problem has a ﬁnite sum (2) structure, the proximal point algorithm approach
leads to sub-problems that can be solved in O(n log(1/ε)) iterations with ﬁrst-order incremental methods
such as SVRG [61], SAGA [15] or MISO [38], by using the same choice of smoothing parameter κ = 2L/n as
Catalyst [34]. Assuming that computing a gradient of a function fi and computing the proximal operator
of ψ are both feasible in O(d) ﬂoating point operations, our approach solves each sub-problem with enough
accuracy in ˜O(nd) operations.1 On the other hand, we cannot naively apply SVRG to solve the proximal
Quasi-Newton update (4) at the same cost due to the following reasons. First, the variable metric matrix Bk
does not admit a natural ﬁnite sum decomposition. The naive way of writing it into n copies results an
increase of computational complexity for evaluating the incremental gradients. More precisely, when Bk has
rank l, computing a single gradient now requires to compute a matrix-vector product with cost at least O(dl),
resulting in l-fold increase per iteration. Second, the previous iteration-complexity O(n log(1/ε)) for solving
the sub-problems would require the subproblems to be well-conditioned, i.e. Bk (cid:23) (L/n)I, forcing the
Quasi-Newton metric to be potentially more isotropic. For these reasons, existing attempts to combine SVRG
with Quasi-Newton principles have adopted other directions [26, 44].

3 QNing: a Quasi-Newton meta-algorithm

We now present the QNing method in Algorithm 1, which consists of applying variable metric algorithms on
the smoothed objective F with inexact gradients. Each gradient approximation is the result of a minimization
problem tackled with the algorithm M, used as a sub-routine. The outer loop of the algorithm performs
Quasi-Newton updates. The method M can be any algorithm of the user’s choice, as long as it enjoys linear
convergence rate for strongly convex problems. More technical details are given in Section 3.1.

1 The notation ˜O hides logarithmic quantities.

6

Algorithm 1 QNing: a Quasi-Newton meta-algorithm
input Initial point x0 in Rd; number of iterations K; smoothing parameter κ > 0; optimization algorithm M;

optionally, budget TM for solving the sub-problems.

1: Initialization: (g0, F0, z0) = ApproxGradient (x0, M); H0 = 1
2: for k = 0, . . . , K − 1 do
Initialize ηk = 1.
3:
Perform the Quasi-Newton step

4:

κ I.

xtest = xk − (ηkHk + (1 − ηk)H0) gk.

5:

Estimate the gradient and function value of the Approximate Moreau envelope at xtest

(gtest, Ftest, ztest) = ApproxGradient (xtest, M) .

6: while Ftest > Fk − 1
7:

4κ kgkk2 do

Decrease the value of the line search parameter ηk in [0, 1] and re-evaluate xtest.
Re-evaluate (gtest, Ftest, ztest) = ApproxGradient (xtest, M) .

8:

end while

9:
10: Accept the new iterate: (xk+1, gk+1, Fk+1, zk+1) = (xtest, gtest, Ftest, ztest).
11: Update Hk+1 (for example, use L-BFGS update with sk = xk+1 − xk, and yk = gk+1 − gk).
12: end for
output inexact proximal point zK (solution).

Algorithm 2 Generic procedure ApproxGradient
input Current point x in Rd; smoothing parameter κ > 0; optionally, budget TM.
1: Compute the approximate proximal mapping using an optimization method M:

z ≈ arg min

h(w) (cid:44) f (w) +

n

w∈Rd

kw − xk2o

,

κ
2

using one of the following stopping criteria:

• Stop when the approximate solution z satisﬁes

h(z) − h∗ ≤

kz − xk2.

κ
36

(11)

(12)

• Stop when we reach the pre-deﬁned constant budget TM (for instance one pass over the data).

2: Estimate the gradient ∇F (x) of the Moreau envelope using

output gradient estimate g, objective value estimate Fa (cid:44) h(z), proximal mapping estimate z.

g = κ(x − z).

7

3.1 The main algorithm

We now discuss the main algorithm components and its main features.

Outer-loop: inexact variable metric proximal point algorithm. We apply variable metric algorithms
with a simple line search strategy similar to [55] on the Moreau envelope F . Given a positive deﬁnite matrix Hk
and a step size ηk in [0, 1], the algorithm computes the update

xk+1 = xk − (ηkHk + (1 − ηk)H0)gk,

(LS)

where H0 = 1
κ I. When ηk = 1, the update uses the metric Hk, and when ηk = 0, it uses an inexact proximal
point update xk+1 = xk − (1/κ)gk. In other words, when the quality of the metric Hk is not good enough,
due to the inexactness of the gradients used in its construction, the update is corrected towards a simple
proximal point update, whose convergence is well understood when the gradients are inexact.

In order to determine the stepsize ηk, we introduce the following descent condition,

Fk+1 ≤ Fk −

kgkk2.

1
4κ

(13)

We show that the descent condition (13) is always satisﬁed when ηk = 0, thus the ﬁnite termination of the
line search follows, see Section 4.3 for more details. In our experiments, we observed empirically that the
stepsize ηk = 1 was almost always selected. In practice, we try the values ηk in {1, 1/2, 1/4, 1/8, 0} starting
from the largest one and stops whenever condition (13) is satisﬁed.

Example of variable metric algorithm: inexact L-BFGS method. The L-BFGS rule we consider is
the standard one and consists in updating incrementally a generating list of vectors {(si, yi)}i=1...j, which
implicitly deﬁnes the L-BFGS matrix. We use here the two-loop recursion detailed in [51, Algorithm 7.4] and
use skipping steps when the condition s>
i yi > 0 is not satisﬁed, in order to ensure the positive-deﬁniteness of
the L-BFGS matrix Hk (see [20]).

Inner-loop: approximate Moreau envelope. The inexactness of our scheme comes from the approxi-
mation of the Moreau envelope F and its gradient. The procedure ApproxGradient () calls an minimization
algorithm M and apply M to minimize the sub-problem (11). When the problem is solved exactly, the
function returns the exact values g = ∇F (x), Fa = F (x), and z = p(x). However, this is infeasible in practice
and we can only expect approximate solutions. In particular, a stopping criterion should be speciﬁed. We
consider the following variants:

(a) we deﬁne an adaptive stopping criterion based on function values and stop M when the approximate
solution satisﬁes the inequality (12). In contrast to standard stopping criterion where the accuracy is
an absolute constant, our stopping criterion is adaptive since the righthand side of (12) also depends on
the current iterate z. More detailed theoretical insights will be given in Section 4. Typically, checking
whether or not the criterion is satisﬁed requires computing a duality gap, as in Catalyst [34].

(b) using a pre-deﬁned budget TM in terms of number of iterations of the method M, where TM is a

constant independent of k.

Note that such an adaptive stopping criterion is relatively classical in the literature of inexact gradient-based
methods [9]. As we will see later in Section 4, when TM is large enough, criterion (12) is guaranteed.

Requirements on M. To apply QNing, the optimization method M needs to have linear convergence
rates for strongly-convex problems. More precisely, for any strongly-convex objective h, the method M
should be able to generate a sequence of iterates (wt)t≥0 such that

h(wt) − h∗ ≤ CM(1 − τM)t(h(w0) − h∗) for some constants CM > 0 and 1 > τM > 0,

(14)

8

where w0 is the initial point given to M. The notion of linearly-convergent methods extends naturally to
non-deterministic methods where (14) is satisﬁed in expectation:

E[h(wt) − h∗] ≤ CM(1 − τM)t(h(w0) − h∗).

(15)

The linear convergence condition typically holds for many primal gradient-based optimization techniques,
including classical full gradient descent methods, block-coordinate descent algorithms [48, 53], or variance
reduced incremental algorithms [15, 57, 61]. In particular, our method provides a generic way to combine
incremental algorithms with Quasi-Newton methods which are suitable for large-scale optimization problems.
For the simplicity of the presentation, we only consider the deterministic variant (14) in the analysis. However,
it is possible to show that the same complexity results still hold for non-deterministic methods in expectation,
as discussed in Section 4.5. We emphasize that we do not assume any convergence guarantee of M on
non-strongly convex problems since our sub-problems are always strongly convex.

Warm starts for the sub-problems. Employing an adequate initialization for solving each sub-problem
plays an important rule in our analysis. The warm start strategy we proposed here ensures that the stopping
criterion in each subproblem can be achieved in a constant number of iterations:
Consider the minimization of a sub-problem

n

min
w∈Rd

h(w) (cid:44) f (w) +

kw − xk2o

.

κ
2

Then, our warm start strategy depends on the nature of f :

• when f is smooth, we initialize with w0 = x;

• when f = f0 + ψ is composite, we initialize with

w0 = arg min

f0(x) + h∇f0(x), w − xi +

(cid:26)

w∈Rd

kw − xk2 + ψ(w)

,

(cid:27)

L + κ
2

which performs an additional proximal step comparing to the smooth case.

Handling composite objective functions.
In machine learning or signal processing, convex composite
objectives (1) with a non-smooth penalty ψ are typically formulated to encourage solutions with speciﬁc
characteristics; in particular, the ‘1-norm is known to provide sparsity. Smoothing techniques [47] may allow
us to solve the optimization problem up to some chosen accuracy, but they provide solutions that do not
inherit the properties induced by the non-smoothness of the objective. To illustrate what we mean by this
statement, we may consider smoothing the ‘1-norm, leading to a solution vector with small coeﬃcients, but
not with exact zeroes. When the goal is to perform model selection—that is, understanding which variables
are important to explain a phenomenon, exact sparsity is seen as an asset, and optimization techniques
dedicated to composite problems such as FISTA [2] are often preferred (see [40]).

Then, one might be concerned that our scheme operates on the smoothed objective F , leading to
iterates (xk)k≥0 that may suﬀer from the above “non-sparse” issue, assuming that ψ is the ‘1-norm. Yet, our
approach does not directly output the iterates (xk)k≥0 but their proximal mappings (zk)k≥0. In particular,
the ‘1-regularization is encoded in the proximal mapping (11), thus the approximate proximal point zk may
be sparse. For this reason, our theoretical analysis presented in Section 4 studies the convergence of the
sequence (f (zk))k≥0 to the solution f ∗.

4 Convergence and complexity analysis

In this section, we study the convergence of the QNing algorithm—that is, the rate of convergence of the
quantities (F (xk) − F ∗)k≥0 and (f (zk) − f ∗)k≥0, and also the computational complexity due to solving the

9

sub-problems (11). We start by stating the main properties of the gradient approximation in Section 4.1.
Then, we analyze the convergence of the outer loop algorithm in Section 4.2, and Section 4.3 is devoted to
the properties of the line search strategy. After that, we provide the cost of solving the sub-problems in
Section 4.4 and derive the global complexity analysis in Section 4.5.

4.1 Properties of the gradient approximation

The next lemma is classical and provides approximation guarantees about the quantities returned by the
ApproxGradient procedure (Algorithm 2); see [5, 23]. We recall here the proof for completeness.

Lemma 1 (Approximation quality of the gradient approximation). Consider a vector x in Rd, a
positive scalar ε and an approximate proximal point

z ≈ arg min

h(w) (cid:44) f (w) +

n

w∈Rd

kw − xk2o

,

κ
2

such that

h(z) − h∗ ≤ ε,

where h∗ = minw∈Rd h(w). As in Algorithm 2, we deﬁne the gradient estimate g = κ(x − z) and the function
value estimate Fa = h(z). Then, the following inequalities hold

Moreover, Fa is related to f by the following relationship

F (x) ≤ Fa ≤ F (x) + ε,

kz − p(x)k ≤

r 2ε
κ
√

,

kg − ∇F (x)k ≤

2κε.

f (z) = Fa −

1
2κ

kgk2.

(16)

(17)

(18)

(19)

Proof. (16) and (19) are straightforward by deﬁnition of h(z). Since f is convex, the function h is κ-strongly
convex, and (17) follows from

kz − p(x)k2 ≤ h(z) − h(p(x)) = h(z) − h∗ ≤ ε,

where we recall that p(x) minimizes h. Finally, we obtain (18) from

g − ∇F (x) = κ(x − z) − κ(x − p(x)) = κ(p(x) − z),

by using the deﬁnitions of g and the property (6).

This lemma allows us to quantify the quality of the gradient and function value approximations, which
is crucial to control the error accumulation of inexact proximal point methods. Moreover, the relation (19)
establishes a link between the approximate function value of F and the function value of the original
objective f ; as a consequence, it is possible to relate the convergence rate of f from the convergence rate
of F . Finally, the following result is a direct consequence of Lemma 1:

Lemma 2 (Bounding the exact gradient by its approximation). Consider the same quantities
introduced in Lemma 1. Then,

kgk2 − 2κε ≤ k∇F (x)k2 ≤ 2(kgk2 + 2κε).

(20)

κ
2

1
2

10

Proof. The right-hand side of Eq. (20) follows from

k∇F (x)k2 ≤ 2(k∇F (x) − gk2 + kgk2)
≤ 2(2κε + kgk2)

(from (18)).

Interchanging ∇F (x) and g gives the left-hand side inequality.

Corollary 1. If ε ≤ c

κ kgk2 with c < 1

4 , then

1 − 4c
2

≤

k∇F (x)k2
kgk2

≤ 2(1 + 2c).

This corollary is important since it allows to replace the unknown exact gradient k∇F (x)k by its

approximation kgk, at the cost of a constant factor, as long as the condition ε ≤ c

κ kgk2 is satisﬁed.

4.2 Convergence analysis of the outer loop

We are now in shape to establish the convergence of the QNing meta-algorithm, without considering yet the
cost of solving the sub-problems (11). At iteration k, an approximate proximal point is evaluated:

(gk, Fk, zk) = ApproxGradient(xk, M) .

The following lemma characterizes the expected descent in terms of objective function value.

Lemma 3 (Approximate descent property). At iteration k, if the sub-problem (22) is solved up to
accuracy εk in the sense of Lemma 1 and the next iterate xk+1 satisﬁes the descent condition (13), then,

F (xk+1) ≤ F (xk) −

k∇F (xk)k2 +

εk.

1
8κ

3
2

Proof. From (16) and (13),

F (xk+1) ≤ Fk+1 ≤ Fk −

kgkk2

1
4κ
(cid:18) 1
8κ

≤ F (xk) + εk −

k∇F (xk)k2 −

(from (16) and (20))

(cid:19)

εk
2

= F (xk) −

k∇F (xk)k2 +

εk.

1
8κ

3
2

This lemma gives us a ﬁrst intuition about the natural choice of the accuracy εk, which should be in the

same order as k∇F (xk)k2. In particular, if

then we have

εk ≤

k∇F (xk)k2,

1
16κ

F (xk+1) ≤ F (xk) −

k∇F (xk)k2,

1
32κ

which is a typical inequality used for analyzing gradient descent methods. Before presenting the conver-
gence result, we remark that condition (24) cannot be used directly since it requires knowing the exact
gradient k∇F (xk)k. A more practical choice consists of replacing it by the approximate gradient.

Lemma 4 (Practical choice of εk). The following condition implies inequality (24):

(21)

(22)

(23)

(24)

(25)

(26)

εk ≤

kgkk2.

1
36κ

11

Proof. From Corollary 1, Equation (26) implies

kgkk2 ≤

k∇F (xk)k2 =

k∇F (xk)k2

and thus

εk ≤

kgkk2 ≤

k∇F (xk)k2.

1
36κ

1
16κ

2
1 − 4
36

9
4

This is the ﬁrst stopping criterion (12) in Algorithm 2. Finally, we obtain the following convergence result
for strongly convex problems, which is classical in the literature of inexact gradient methods (see Section 4.1
of [9] for a similar result).

Proposition 2 (Convergence of Algorithm 1, strongly-convex objectives). Assume that f is µ-
strongly convex. Let (xk)k≥0 be the sequences generated by Algorithm 1 where the stopping criterion (12) is
used. Then,

F (xk) − F ∗ ≤

1 −

(F (x0) − F ∗), with

q =

(cid:18)

(cid:19)k

1
16q

µ + κ
µ

.

Proof. The proof follows directly from (25) and the standard analysis of the gradient descent algorithm for
the µF -strongly convex and LF -smooth function F by remarking that LF = κ and µF = µκ

µ+κ .

Corollary 2. Under the conditions of Proposition 2, we have

f (zk) − f ∗ ≤

1 −

(f (x0) − f ∗).

(cid:18)

(cid:19)k

1
16q

(27)

Proof. From (19) and (26), we have

f (zk) = Fk −

kgkk2 ≤ F (xk) + εk −

kgkk2 ≤ F (xk).

1
2κ

1
2κ

Moreover, F (x0) is upper-bounded by f (x0) following (7).

It is worth pointing out that our analysis establishes a linear convergence rate whereas one would expect
a superlinear convergence rate as for classical variable metric methods. The tradeoﬀ lies in the choice of
the accuracy εk. In order to achieve superlinear convergence, the approximation error εk needs to decrease
superlinearly, as shown in [14]. However, a fast decreasing sequence εk requires an increasing eﬀort in solving
the sub-problems, which will dominate the global complexity. In other words, the global complexity may
become worse even though we achieve faster convergence in the outer-loop. This will become clearer when we
discuss the inner loop complexity in Section 4.4.

Next, we show that under a bounded level set condition, QNing enjoys the classical sublinear O(1/k)

convergence rate when the objective is convex but not strongly convex.

Proposition 3 (Convergence of Algorithm 1 for convex, but not strongly-convex objectives).
Let f be a convex function with bounded level sets. Then, there exists a constant R > 0, which depends on the
initialization point x0, such that the sequences (xk)k≥0 and (zk)k≥0 generated by Algorithm 1 with stopping
criterion (12), satisﬁes

F (xk) − F ∗ ≤

and

f (zk) − f ∗ ≤

32κR2
k

32κR2
k

.

Proof. We defer the proof and the proper deﬁnition of the bounded level set assumption to Appendix A.

So far, we have assumed in our analysis that the iterates satisfy the descent condition (13), which means
the line search strategy will always terminate. We prove this is indeed the case in the next section and
provide some additional conditions under which a non-zero step size will be selected.

12

4.3 Conditions for non-zero step sizes ηk and termination of the line search

At iteration k, a line search is performed on the stepsize ηk to ﬁnd the next iterate

xk+1 = xk − (ηkHk + (1 − ηk)H0)gk,

such that xk+1 satisﬁes the descent condition (13). We ﬁrst show that the descent condition holds when
ηk = 0 before giving a more general result.

Lemma 5. If the sub-problems are solved up to accuracy εk ≤ 1
holds when ηk = 0.

36κ kgkk2, then the descent condition (13)

Proof. When ηk = 0, xk+1 = xk − 1

κ gk = zk. Then,

Fk+1 ≤ F (xk+1) +

(from Eq. (16))

≤ F (xk+1) +

k∇F (xk+1)k2

(from Eq. (21) )

1
36κ
1
36κ
1
2κ

kgk+1k2
2
1 − 4
36
k∇F (zk+1)k2

< F (xk+1) +

≤ f (xk+1) = f (zk)
1
2κ

= Fk −

kgkk2

(from Eq. (7))

(from Eq. (19)).

Therefore, it is theoretically sound to take the trivial step size ηk = 0, which implies the termination of
our line search strategy. In other words, the descent condition always holds by taking an inexact gradient
step on the Moreau envelope F , which corresponds to the update of the proximal point algorithm. However,
the purpose of using variable metric method is to exploit the curvature of the function, which is not the case
when ηk = 0. Thus, the trivial step size should be only considered as a backup plan and we show in the
following some suﬃcient conditions for taking non-zero step sizes and even stronger, unit step sizes.

Lemma 6 (A suﬃcient condition for satisfying the descent condition (13)). If the sub-problems
are solved up to accuracy εk ≤ 1
36κ kgkk2, then the suﬃcient condition (13) holds for any xk+1 = xk − Akgk
where Ak is a positive deﬁnite matrix satisfying 1−α

κ I (cid:22) Ak (cid:22) 1+α

κ I with α ≤ 1
3 .

As a consequence, a line search strategy consisting of ﬁnding the largest ηk of the form γi, with
i = 1, . . . , +∞ and γ in (0, 1) always terminates in a bounded number of iterations if the sequence of variable
metric (Hk)k≥0 is bounded, i.e. there exists 0 < m < M such that for any k, mI (cid:22) Hk (cid:22) M I. This is the
case for L-BFGS update:

Lemma 7 (Boundedness of L-BFGS metric matrix, see Chap 8,9 of [51]). The variable metric
matrices (Bk)k constructed by the L-BFGS rule are positive deﬁnite and bounded.

Proof of Lemma 6. First, we recall that zk = xk − 1

κ gk and we rewrite

Fk+1 = Fk+1 − F (xk+1)
}

|

{z
(cid:44)E1

+ F (xk+1) − F (zk)
{z
}
(cid:44)E2

|

+F (zk).

We are going to bound the two error terms E1 and E2 by some factors of kgkk2. Noting that the subproblems
are solved up to εk ≤ c
36 , we obtain by construction

κ kgkk2 with c = 1

E1 = Fk+1 − F (xk+1) ≤ εk+1 ≤

kgk+1k2 ≤

k∇F (xk+1)k2,

(28)

2c
(1 − 4c)κ

c
κ

13

where the last inequality comes from Corollary 1. Moreover,

k∇F (xk+1)k ≤ k∇F (zk)k + k∇F (xk+1) − ∇F (zk)k

≤ k∇F (zk)k + κkxk+1 − zkk.

Since xk+1 − zk = ( 1

κ − Ak)gk, we have kxk+1 − zkk ≤ α

κ kgkk. This implies that

and thus

Second, by the κ-smoothness of F , we have

k∇F (xk+1)k ≤ k∇F (zk)k + αkgkk,

E1 ≤

4c
(1 − 4c)κ

(cid:0)k∇F (zk)k2 + α2kgkk2(cid:1) .

E2 = F (xk+1) − F (zk)

≤ h∇F (zk), xk+1 − zki +

kxk+1 − zkk2

κ
2

≤

≤

1
4κ
1
4κ

k∇F (zk)k2 + κkxk+1 − zkk2 +

kxk+1 − zkk2

κ
2

k∇F (zk)k2 +

kgkk2,

3α2
2κ

where the last inequality follows from kxk+1 − zkk ≤ α

κ kgkk. Combining (30) and (31) yields

E1 + E2 ≤

(cid:20) 4c
1 − 4c

+

(cid:21) 1
κ

1
4

k∇F (zk)k2 +

(cid:20) 4c
1 − 4c

+

(cid:21) α2
κ

3
2

kgkk2.

When c ≤ 1

36 and α ≤ 1

3 , we have

Therefore,

E1 + E2 ≤

k∇F (zk)k2 +

kgkk2.

1
2κ

1
4κ

Fk+1 ≤ F (zk) + E1 + E2

≤ F (zk) +

k∇F (zk)k2 +

kgkk2

1
4κ

1
2κ
1
4κ
kgkk2,

≤ f (zk) +

kgkk2

= Fk −

1
4κ

(29)

(30)

(31)

(32)

(33)

where the last equality follows from (19), this completes the proof.

Note that in practice, we consider a set of step sizes ηk = γi for i ≤ imax or ηk = 0, which naturally
upper-bounds the number of line search iterations to imax. More precisely, all experiments performed in this
paper use γ = 1/2 and imax = 3. Moreover, we observe that the unit stepsize is very often suﬃcient for the
descent condition to hold, as empirically studied in Appendix C.2.

The following result shows that under a speciﬁc assumption on the Moreau envelope F , the unit stepsize
is indeed selected when the iterate are close to the optimum. The condition, called Dennis-Moré criterion
[17], is classical in the literature of Quasi-Newton methods. Even though we cannot formally show that
the criterion holds for the Moreau envelope F , since it requires F to be twice continuously diﬀerentiable,
which is not true in general, see [32], it provides a suﬃcient condition for the unit step size. Therefore, the
lemma below should not be seen as an formal explanation for the choice of step size ηk = 1, but simply as a
reasonable condition that leads to this choice.

14

Lemma 8 (A suﬃcient condition for unit stepsize). Assume that f is strongly convex and F is twice-
continuously diﬀerentiable with Lipschitz continuous Hessian ∇2F . If the sub-problems are solved up to
accuracy εk ≤

128κ(µ+κ)2 kgkk2 and the Dennis-Moré criterion [17] is satisﬁed, i.e.

µ2

lim
k→∞

k(B−1

k − ∇2F (x∗)−1)gkk

= 0,

kgkk

(DM)

where x∗ is the minimizer of the problem and Bk = H −1
condition (13) is satisﬁed with ηk = 1 when k is large enough.

k

is the variable metric matrix, then the descent

We remark that the Dennis-Moré criterion we use here is slightly diﬀerent from the standard one since
our criterion is based on approximate gradients gk. If the gk’s are indeed the exact gradients and the variable
metric Bk are bounded, then our criterion is equivalent to the standard Dennis-Moré criterion. The proof of
the lemma is close to that of similar lemmas appearing in the proximal Quasi-Newton literature [31], and is
relegated to the appendix. Interestingly, this proof also suggests that a stronger stopping criterion εk such
that εk = o(kgkk2) could lead to superlinear convergence. However, such a choice of εk would signiﬁcantly
increase the complexity for solving the sub-problems, and overall degrade the global complexity.

4.4 Complexity analysis of the inner loop

In this section, we evaluate the complexity of solving the sub-problems (11) up to the desired accuracy using
a linearly convergent method M. Our main result is that all sub-problems can be solved in a constant
number TM of iterations (in expectation if the method is non-deterministic) using the proposed warm start
strategy. Let us consider the sub-problem with an arbitrary prox center x,

n

min
w∈Rd

h(w) = f (w) +

kw − xk2o

.

κ
2

The number of iterations needed is determined by the ratio between the initial gap h(w0) − h∗ and the desired
accuracy. We are going to bound this ratio by a constant factor.

Lemma 9 (Warm start for primal methods - smooth case). If f is diﬀerentiable with L-Lipschitz
continuous gradients, we initialize the method M with w0 = x. Then, we have the guarantee that

(34)

(35)

h(w0) − h∗ ≤

L + κ
2κ2 k∇F (x)k2.

Proof. Denote by w∗ the minimizer of h. Then, we have the optimality condition ∇f (w∗) + κ(w∗ − x) = 0.
As a result,

h(w0) − h∗ = f (x) −

f (w∗) +

(cid:16)

κ
2

kw∗ − xk2(cid:17)
L
2

≤ f (w∗) + h∇f (w∗), x − w∗i +

kx − w∗k2 −

f (w∗) +

(cid:16)

kw∗ − xk2(cid:17)

κ
2

The inequality in the above proof relies on the smoothness of f , which does not hold for composite

problems. The next lemma addresses this issue.

=

=

kw∗ − xk2

L + κ
2
L + κ
2κ2 k∇F (x)k2.

15

Lemma 10 (Warm start for primal methods - composite case). Consider the composite optimization
problem f = f0 + ψ, where f0 is L-smooth. By initializing with

w0 = arg min

f0(x) + h∇f0(x), w − xi +

(36)

kw − xk2 + ψ(w)

,

(cid:27)

L + κ
2

(cid:26)

w∈Rd

we have,

h(w0) − h∗ ≤

L + κ
2κ2 k∇F (x)k2.

Proof. We use the inequality corresponding to Lemma 2.3 in [2]: for any w,

h(w) − h(w0) ≥

kw0 − xk2 + L0hw0 − x, x − wi,

(37)

L0
2

with L0 = L + κ. Then, we apply this inequality to w = w∗, and

h(w0) − h∗ ≤ −

kw0 − xk2 − L0hw0 − x, x − w∗i ≤

kx − w∗k2 =

L0
2

L + κ
2κ2 k∇F (x)k2.

L0
2

We get an initialization of the same quality in the composite case as in the smooth case, by performing an
additional proximal step. It is important to remark that the above analysis do not require strong convexity
of f , which allows us to derive the desired inner-loop complexity.

Proposition 4 (Inner-loop complexity for Algorithm 1). Consider Algorithm 1 with the warm start
strategy described in Lemma 9 or in Lemma 10. Assume that the optimization method M applied in the inner
loop produces a sequence (wt)t≥0 for each sub-problem (34) such that

h(wt) − h∗ ≤ CM(1 − τM)t(h(w0) − h∗) for some constants CM, τM > 0.

(38)

Then, the stopping criterion ε ≤ 1

72κ kgk2 is achieved in at most TM iterations with

TM =

log

38CM

(cid:18)

1
τM

(cid:19)

.

L + κ
κ

Proof. Consider at iteration k, we apply M to approximate the proximal mapping according to x. With the
given TM (which we abbreviate by T ), we have

h(wT ) − h∗ ≤ CM(1 − τM)T (h(w0) − h∗)

≤ CMe−τMT (h(w0) − h∗)
≤ CMe−τMT L + κ

2κ2 k∇F (x)k2

=

≤

1
76κ
1
36κ

k∇F (x)k2

kgk2,

(By Lemma 9 and Lemma 10)

where the last inequality follows from Lemma 2.

Next, we extend the previous result obtained with deterministic methods M to randomized ones, where
linear convergence is only achieved in expectation. The proof is a simple application of Lemma C.1 in [33]
(see also [12] for related results on the expected complexity of randomized algorithms).

16

Remark 1 (When M is non-deterministic). Assume that the optimization method M applied to each
sub-problem (34) produces a sequence (wt)t≥0 such that

E[h(wt) − h∗] ≤ CM(1 − τM)t(h(w0) − h∗) for some constants CM, τM > 0.

We deﬁne the stopping time TM by

(cid:26)

TM = inf

t ≥ 1 | h(wt) − h∗ ≤

kgtk2

, where

gt = κ(x − wt),

(39)

(cid:27)

1
36κ

which is the random variable corresponding to the minimum number of iterations to guarantee the stopping
condition (12). Then, when the warm start strategy described in Lemma 9 or in Lemma 10 is applied, the
expected number of iterations satisﬁes

E[TM] ≤

log

76CM

(cid:18)

1
τM

(cid:19)

L + κ
τMκ

+ 1.

Remark 2 (Checking the stopping criterium). It is worth to notice that the stopping criterium (12),
i.e. h(w) − h∗ ≤ κ
36 kw − xk2, can not be directly checked since h∗ is unknown. Nevertheless, an upper bound
on the optimality gap h(w) − h∗ is usually available. In particular,

• When f is smooth, which implies h is smooth, we have

(40)

(41)

h(w) − h∗ ≤

k∇h(w)k2.

1
2(µ + κ)

• Otherwise, we can evaluate the Fenchel conjugate function, which is a natural lower bound of h∗, see

Section D.2.3 in [37].

4.5 Global complexity of QNing

Finally, we can use the previous results to upper-bound the complexity of the QNing algorithm in terms of
iterations of the method M for minimizing f up to ε.

Proposition 5 (Worst-case global complexity for Algorithm 1). Given a linearly-convergent method M
satisfying (14), we apply M to solve the sub-problems of Algorithm 1 with the warm start strategy given in
Lemma 9 or Lemma 10 up to accuracy εk ≤ 1
36κ kgkk2. Then, the number of iterations of the method M to
guarantee the optimality condition f (zk) − f ∗ ≤ ε is

• for µ-strongly-convex problems:

(cid:18)

O

TM ×

µ + κ
µ

log

(cid:18) f (x0) − f ∗
ε

(cid:19)(cid:19)

= O

(cid:18) µ + κ
τMµ

log

(cid:18) f (x0) − f ∗
ε

(cid:19)

(cid:18)

log

38CM

(cid:19)(cid:19)

.

L + κ
κ

• for convex problems with bounded level sets:

(cid:18)

O

TM ×

(cid:19)

2κR2
ε

= O

(cid:18) 2κR2
τMε

(cid:18)

log

38CM

(cid:19)(cid:19)

.

L + κ
κ

Proof. The total number of calls of method M is simply TM times the number of outer-loop iterations times
the potential number of line search steps at each iteration (which is hidden in the O(.) notation since this
number can be made arbitrarily small).

Remark 3. For non-deterministic methods, applying (40) yields a global complexity in expectation similar to
the previous result with additional constant 2/τM in the last log factor.

17

As we shall see, the global complexity of our algorithm is mainly controlled by the smoothing parameter κ.
Unfortunately, under the current analysis, our algorithm QNing does not lead to an improved convergence
rate in terms of the worst-case complexity bounds. It is worthwhile to underline, though, that this result
is not surprising since it is often the case for L-BFGS-type methods, for which an important gap remains
between theory and practice. Indeed, L-BFGS often outperforms the vanilla gradient descent method in
many practical cases, but never in theory, which turns out to be the bottleneck in our analysis.

We give below the worst-case global complexity of QNing when applied to two optimization methods M of
interest. Proposition 5 and its application to the two examples show that, in terms of worse-case complexity,
the QNing scheme leaves the convergence rate almost unchanged.

Example 1. Consider gradient descent with ﬁxed constant step-size 1/L as the optimization method M.
Directly applying gradient descent (GD) to minimize f requires

iterations to achieve ε accuracy. The complexity to achieve the same accuracy with QNing-GD is in the worst
case

Example 2. Consider the stochastic variance-reduced gradient (SVRG) as the optimization method M.
SVRG minimizes f to ε accuracy in

O(L/µ log(1/ε))

˜O((L + κ)/µ log(1/ε)).

(cid:18)

(cid:26)

O

max

n,

log

(cid:27)

L
µ

(cid:19)(cid:19)

(cid:18) 1
ε

(cid:18)

˜O

max

(cid:26) µ + κ
µ

n,

L + κ
µ

(cid:27)

log

(cid:19)(cid:19)

.

(cid:18) 1
ε

iterations in expectation. QNing-SVRG achieves the same result with the worst-case expected complexity

Choice of κ. Minimizing the above worst-case complexity respect to κ suggests that κ should be chosen as
small as possible. However, such statement is based on the pessimistic theoretical analysis of L-BFGS-type
method, which is not better than standard gradient descent methods. Noting that for smooth functions,
L-BFGS method often outperforms Nesterov’s accelerated gradient method, it is reasonable to expect they
achieve a similar complexity bound. In other words, the choice of κ may be substantially diﬀerent if one is
able to show that L-BFGS-type method enjoys an accelerated convergence rate.

In order to illustrate the diﬀerence, we heuristically assume that L-BFGS method enjoys a similar
convergence rarte as Nesterov’s accelerated gradient method. Then, the global complexity of our algorithm
QNing matches the complexity of the related Catalyst acceleration scheme [33], which will be

˜O

(cid:18) 1
τM

r µ + κ
µ

log

(cid:19)(cid:19)

,

(cid:18) 1
ε

for µ-strongly-convex problems. In such case, the complexity of QNing-GD and QNing-SVRG will be

 

˜O

L + κ
p(µ + κ)µ

!

log(1/ε)

and

˜O

max

 

(r µ + κ

n,

L + κ
p(µ + κ)µ

µ

)

(cid:19)!

,

(cid:18) 1
ε

log

which do enjoy acceleration by taking κ = O(L) and κ = O(L/n) respectively. In the following section, we
will experiment with this heuristic, as if L-BFGS method enjoys an accelerated convergence rate. More
precisely, we will choose the smoothing parameter κ as in the related Catalyst acceleration scheme [33], and
we present empirical evidence in support of this heuristic.

18

5 Experiments and practical details

In this section, we present the experimental results obtained by applying QNing to several ﬁrst-order
optimization algorithms. We start the section by presenting various benchmarks and practical parameter-
tuning choices. Then, we study the performance of QNing applied to SVRG (Section 5.3) and to the proximal
gradient algorithm ISTA (Section 5.4), which reduces to gradient descent (GD) in the smooth case. We
demonstrate that QNing can be viewed as an acceleration scheme: by applying QNing to an optimization
algorithm M, we achieve better performance than when applying M directly to the problem. Besides, we
also compare QNing to existing stochastic variants of L-BFGS algorithm in Section 5.3. Finally, we study the
behavior of QNing under diﬀerent choice of parameters in Section 5.5. The code used for all the experiments
is available at https://github.com/hongzhoulin89/Catalyst-QNing/.

5.1 Formulations and datasets

We consider three common optimization problems in machine learning and signal processing, including logistic
regression, Lasso and linear regression with Elastic-Net regularization. These three formulations all admit
the composite ﬁnite-sum structure but diﬀer in terms of smoothness and strong-convexness. Speciﬁcally, the
three formulations are listed below.

• ‘2

2-regularized Logistic Regression:

min
x∈Rd

1
n

n
X

i=1

log (cid:0)1 + exp(−bi aT

i x)(cid:1) +

kxk2,

µ
2

which leads to a µ-strongly convex smooth optimization problem.

• ‘1-regularized Linear Regression (LASSO):

min
x∈Rd

1
2n

n
X

i=1

(bi − aT

i x)2 + λkxk1,

which is convex and non-smooth, but not strongly convex.

• ‘1 − ‘2

2-regularized Linear Regression (Elastic-Net):

min
x∈Rd

1
2n

n
X

i=1

(bi − aT

i x)2 + λkxk1 +

kxk2,

µ
2

which is based on the Elastic-Net regularization [64] leading to non-smooth strongly-convex problems.

For each formulation, we consider a training set (ai, bi)n

i=1 of n data points, where the bi’s are scalars in
{−1, +1} and the ai’s are feature vectors in Rd. Then, the goal is to ﬁt a linear model x in Rd such that
the scalar bi can be well predicted by the inner-product a>
i x, or by its sign. Since we normalize the feature
vectors ai, a natural upper-bound on the Lipschitz constant L of the unregularized objective can be easily
obtained with Llogistic = 1/4, Lelastic-net = 1 and Llasso = 1.

In the experiments, we consider relatively ill-conditioned problems with the regularization parameter
µ = 1/(100n). The ‘1-regularization parameter is set to λ = 1/n for the Elastic-Net formulation; for the
Lasso problem, we consider a logarithmic grid 10i/n, with i = −3, −2, . . . , 3, and we select the parameter λ
that provides a sparse optimal solution closest to 10% non-zero coeﬃcients.

Datasets. We consider ﬁve standard machine learning datasets with diﬀerent characteristics in terms of
size and dimension, which are described below:

19

name
n
d

covtype
581 012
54

alpha
250 000
500

real-sim MNIST-CKN CIFAR-CKN
72 309
20 958

60 000
2 304

50 000
9 216

The ﬁrst three data sets are standard machine learning data sets from LIBSVM [13]. We normalize the
features, which provides a natural estimate of the Lipschitz constant as mentioned previously. The last two
data sets are coming from computer vision applications. MNIST and CIFAR-10 are two image classiﬁcation
data sets involving 10 classes. The feature representation of each image was computed using an unsupervised
convolutional kernel network [39]. We focus here on the task of classifying class #1 vs. other classes.

5.2 Choice of hyper-parameters and variants

We now discuss the choice of default parameters used in the experiments as well as the diﬀerent variants.
First, to deal with the high-dimensional nature of the data, we systematically use the L-BFGS metric Hk
and maintain the positive deﬁniteness by skipping updates when necessary (see [20]).

Choice of method M. We apply QNing to proximal SVRG algorithm [61] and proximal gradient algorithm.
The proximal SVRG algorithm is an incremental algorithm that is able to exploit the ﬁnite-sum structure of
the objective and can deal with the composite regularization. We also consider the gradient descent algorithm
and its proximal variant ISTA, which allows us to perform a comparison with the natural baselines FISTA [2]
and L-BFGS.

Stopping criterion for the inner loop. The default stopping criterion consists of solving each sub-
problem with accuracy εk ≤ 1
36 kgkk2. Although we have shown that such accuracy is attainable in some
constant T = ˜O(n) number of iterations for SVRG with the choice κ = L/2n, a natural heuristic proposed
in Catalyst [34] consists of performing exactly one pass over the data T = n in the inner loop without
checking any stopping criterion. In particular, for gradient descent or ISTA, one pass over the data means a
single gradient step, because the evaluation of the full gradient requires passing through the entire dataset.
When applying QNing to SVRG and ISTA, we call the default algorithm using stopping criterion (24)
QNing-SVRG, QNing-ISTA and the one-pass variant QNing-SVRG1, QNing-ISTA1, respectively.

Choice of regularization parameter κ. We choose κ as in the Catalyst algorithm [34], which is κ = L
for gradient descent/ISTA and κ = L/2n for SVRG. Indeed, convergence of L-BFGS is hard to characterize
and its theoretical rate of convergence can be pessimistic as shown in our theoretical analysis. Noting that
for smooth functions, L-BFGS often outperforms Nesterov’s accelerated gradient method, it is reasonable to
expect QNing achieves a similar complexity bound as Catalyst. Later in Section 5.5, we make a comparison
between diﬀerent values of κ to demonstrate the eﬀectiveness of this strategy.

Choice of limited memory parameter l. The default setting is l = 100. We show later in Section 5.5 a
comparison with diﬀerent values to study the inﬂuence of this parameter.

Implementation of the line search. As mentioned earlier, we consider the stepsizes ηk in the set
{1, 1/2, 1/4, 1/8, 0} and select the largest one that satisﬁes the descent condition.

Evaluation metric. For all experiments, we use the number of gradient evaluations as a measure of
complexity, assuming this is the computational bottleneck of all methods considered. This is indeed the case
here since the L-BFGS step cost O(ld) ﬂoating-point operations [51], whereas evaluating the gradient of the
full objective costs O(nd), with l (cid:28) n.

20

5.3 QNing-SVRG for minimizing large sums of functions

We now apply QNing to SVRG and compare diﬀerent variants.

• SVRG: the Prox-SVRG algorithm of [61] with default parameters m = 1 and η = 1/L, where L is the

upper-bound on Lipschitz constant of the gradient, as described in the Section 5.1.

• Catalyst-SVRG: The Catalyst meta-algorithm of [34] applied to Prox-SVRG, using the variant (C3)

that performs best among the diﬀerent variants of Catalyst.

• L-BFGS/Orthant: Since implementing eﬀectively L-BFGS with a line-search algorithm is a bit
involved, we use the implementation of Mark Schmidt2, which has been widely used in other com-
parisons [57]. In particular, the Orthant-wise method follows the algorithm developed in [1]. We use
L-BFGS for the logistic regression experiment and the Orthant-wise method [1] for elastic-net and lasso
experiments. The limited memory parameter l is set to 100.

• QNing-SVRG: the algorithm according to the theory by solving the sub-problems until εk ≤ 1

36 kgkk2.

• QNing-SVRG1: the one-pass heuristic.

The result of the comparison is presented in Figure 1 and leads to the conclusions below, showing that

QNing-SVRG1 is a safe heuristic, which never decreases the speed of the method SVRG:

• L-BFGS/Orthant is less competitive than other approaches that exploit the sum structure of the
objective, except on the dataset real-sim; the diﬀerence in performance with the SVRG-based approaches
can be important (see dataset alpha).

• QNing-SVRG1 is signiﬁcantly faster than or on par with SVRG and QNing-SVRG.

• QNing-SVRG is signiﬁcantly faster than, or on par with, or only slightly slower than SVRG.

• QNing-SVRG1 is signiﬁcantly faster, or on par with Catalyst-SVRG. This justiﬁes our choice of κ

which assumes “a priori” that L-BFGS performs as well as Nesterov’s method.

So far, we have shown that applying QNing with SVRG provides a signiﬁcant speedup compared to the
original SVRG algorithm or other acceleration scheme such as Catalyst. Now we compare our algorithm to
other variable metric approaches including Proximal L-BFGS [31] and Stochastic L-BFGS [44]:

• Proximal L-BFGS: We apply the Matlab package PNOPT3 implemented by [31]. The sub-problems
are solved by the default algorithm up to desired accuracy. We consider one sub-problem as one gradient
evaluation in our plot, even though it often requires multiple passes.

• Stochastic L-BFGS (for smooth objectives): We apply the Matlab package StochBFGS4 implemented

by [44]. We consider the ’prev’ variant which has the best practical performance.

The result of the comparison is presented in Figure 2 and we observe that QNing-SVRG1 is signiﬁcantly

faster than Proximal L-BFGS and Stochastic L-BFGS:

• Proximal L-BFGS often outperforms Orthant-based methods but it is less competitive than QNing.

• Stochastic L-BFGS is sensitive to parameters and data since the variable metric is based on stochastic
information which may have high variance. It performs well on dataset covtype but becomes less
competitive on other datasets. Moreover, it only applies to smooth problems.

The previous results are complemented by Appendix C.1, which also presents some comparison in terms

of outer-loop iterations, regardless of the cost of the inner-loop.

2available here http://www.cs.ubc.ca/~schmidtm/Software/minFunc.html
3available here https://web.stanford.edu/group/SOL/software/pnopt
4available here https://perso.telecom-paristech.fr/rgower/software.html

21

Figure 1: Experimental study of the performance of QNing-SVRG for minimizing large sums of functions.
We plot the value F (xk)/F ∗ − 1 as a function of the number of gradient evaluations, on a logarithmic scale;
the optimal value F ∗ is estimated with a duality gap.

22

Figure 2: Comparison to proximal L-BFGS and Stochastic L-BFGS. We plot the value F (xk)/F ∗ − 1 as a
function of the number of gradient evaluations, on a logarithmic scale; the optimal value F ∗ is estimated
with a duality gap.

23

5.4 QNing-ISTA and comparison with L-BFGS

The previous experiments have included a comparison between L-BFGS and approaches that are able to
exploit the sum structure of the objective. It is then interesting to study the behavior of QNing when applied
to a basic proximal gradient descent algorithm such as ISTA. Speciﬁcally, we now consider

• GD/ISTA: the classical proximal gradient descent algorithm ISTA [2] with back-tracking line-search

to automatically adjust the Lipschitz constant of the gradient objective;

• Acc-GD/FISTA: the accelerated variant of ISTA from [2].

• QNing-ISTA, and QNing-ISTA1, as in the previous section replacing SVRG by GD/ISTA.

Figure 3: Experimental study of the performance of QNing-ISTA. We plot the value F (xk)/F ∗ − 1 as a
function of the number of gradient evaluations, on a logarithmic scale; the optimal value F ∗ is estimated
with a duality gap.

The results are reported in Figure 3 and lead to the following conclusions

24

• L-BFGS is slightly better on average than QNing-ISTA1 for smooth problems, which is not surprising

since we use a state-of-the-art implementation with a well-calibrated line search.

• QNing-ISTA1 is always signiﬁcantly faster than ISTA and QNing-ISTA.

• The QNing-ISTA approaches are signiﬁcantly faster than FISTA in 12 cases out of 15.

• There is no clear conclusion regarding the performance of the Orthant-wise method vs other approaches.
For three datasets, covtype, alpha and mnist, QNing-ISTA is signiﬁcantly better than Orthant-wise.
However, on the other two datasets, the behavior is diﬀerent Orthant-wise method outperforms
QNing-ISTA.

5.5 Experimental study of hyper-parameters l and κ

In this section, we study the inﬂuence of the limited memory parameter l and of the regularization parameter κ
in QNing. More precisely, we start with the parameter l and try the method QNing-SVRG1 with the
values l = 1, 2, 5, 10, 20, 100. Note that all previous experiments were conducted with l = 100, which is the
most expensive in terms of memory and computational cost for the L-BFGS step. The results are presented
in Figure 4. Interestingly, the experiment suggests that having a large value for l is not necessarily the
best choice, especially for composite problems where the solution is sparse, where l = 10 seems to perform
reasonably well.

The next experiment consists of studying the robustness of QNing to the smoothing parameter κ. We
present in Figure 5 an experiment by trying the values κ = 10iκ0, for i = −3, −2, . . . , 2, 3, where κ0 is the
default parameter that we used in the previous experiments. The conclusion is clear: QNing clearly slows
down when using a larger smoothing parameter than κ0, but it is robust to small values of κ (and in fact it
even performs better for smaller values than κ0).

6 Discussions and concluding remarks

A few questions naturally arise regarding the QNing scheme: one may wonder whether or not our convergence
rates may be improved, or if the Moreau envelope could be replaced by another smoothing technique. In this
section, we discuss these two points and present concluding remarks.

6.1 Discussion of convergence rates

In this paper, we have established the linear convergence of QNing for strongly convex objectives when
sub-problems are solved with enough accuracy. Since QNing uses Quasi-Newton steps, one might have
expected a superlinear convergence rate as several Quasi-Newton algorithms often enjoy [11]. The situation
is as follows. Consider the BFGS algorithm (without limited memory), as shown in [14], if the sequence
(εk)k≥0 decreases super-linearly, then, it is possible to design a scheme similar to QNing that indeed enjoys
a super-linear convergence rate. There is a major downside though: a super-linearly decreasing sequence
(εk)k≥0 implies an exponentially growing number of iterations in the inner-loops, which will degrade the
global complexity of the algorithm. This issue makes the approach proposed in [14] impractical.

Another potential strategy for obtaining a faster convergence rate consists in interleaving a Nesterov-type
extrapolation step in the QNing algorithm. Indeed, the convergence rate of QNing scales linearly in the
condition number µF /LF , which suggests that a faster convergence rate could be obtained using a Nesterov-
type acceleration scheme. Empirically, we did not observe any beneﬁt of such a strategy, probably because
of the pessimistic nature of the convergence rates that are typically obtained for Quasi-Newton approaches
based on L-BFGS. Obtaining a linear convergence rate for an L-BFGS algorithm is still an important sanity
check, but to the best of our knowledge, the gap in performance between these worst-case rates and practice
has always been huge for this class of algorithms.

25

Figure 4: Experimental study of inﬂuence of the limited-memory parameter l for QNing-SVRG1. We plot the
value F (xk)/F ∗ − 1 as a function of the number of gradient evaluations, on a logarithmic scale; the optimal
value F ∗ is estimated with a duality gap.

26

Figure 5: Experimental study of inﬂuence of the smoothing parameter κ for QNing-SVRG1. κ0 denotes the
default choice used in the previous experiments. We plot the value F (xk)/F ∗ − 1 as a function of the number
of gradient evaluations, on a logarithmic scale; the optimal value F ∗ is estimated with a duality gap.

27

6.2 Other types of smoothing

The Moreau envelope we considered is a particular instance of inﬁmal convolution smoothing [3], whose
family also encompasses the so-called Nesterov smoothing [3]. Other ways to smooth a function include
randomization techniques [18] or speciﬁc strategies tailored for the objective at hand.

One of the main purposes of applying the Moreau envelope is to provide a better conditioning. As recalled
in Proposition 1, the gradient of the smoothed function F is κ−Lipschitz continuous regardless of whether
the original function is continuously diﬀerentiable or not. Furthermore, the conditioning of F is improved
with respect to the original function, with a condition number depending on the amount of smoothing. As
highlighted in [3], this property is also shared by other types of inﬁmal convolutions. Therefore, QNing could
potentially be extended to such types of smoothing in place of the Moreau envelope. A major advantage of
our approach, though, is its outstanding simplicity.

6.3 Concluding remarks

To conclude, we have proposed a generic mechanism, QNing, to accelerate existing ﬁrst-order optimization
algorithms with Quasi-Newton-type methods. QNing’s main features are the compatibility with variable
metric update rule and composite optimization. Its ability of combining with incremental approaches makes
it a promising tool for solving large-scale machine learning problems. A few questions remain however open
regarding the use of the method in a pure stochastic optimization setting, and the gap in performance between
worst-case convergence analysis and practice is signiﬁcant. We are planning to address the ﬁrst question
about stochastic optimization in future work; the second question is unfortunately diﬃcult and is probably
one of the main open questions in the literature about L-BFGS methods.

The authors would like to thank the editor and the reviewers for their constructive and detailed comments.
This work was supported by the ERC grant SOLARIS (number 714381), a grant from ANR (MACARON
project ANR-14-CE23-0003-01), and the program “Learning in Machines and Brains” (CIFAR).

Acknowledgements

References

[1] G. Andrew and J. Gao. Scalable training of L1-regularized log-linear models. In International Conferences

on Machine Learning (ICML), 2007.

[2] A. Beck and M. Teboulle. A fast iterative shrinkage-thresholding algorithm for linear inverse problems.

SIAM Journal on Imaging Sciences, 2(1):183–202, 2009.

[3] A. Beck and M. Teboulle. Smoothing and ﬁrst order methods: A uniﬁed framework. SIAM Journal on

Optimization, 22(2):557–580, 2012.

[4] S. Becker and J. Fadili. A quasi-newton proximal splitting method. In Proceedings of Advances in Neural

Information Processing Systems (NIPS), pages 2618–2626, 2012.

[5] D. P. Bertsekas. Convex Optimization Algorithms. Athena Scientiﬁc, 2015.

[6] J.-F. Bonnans, J. C. Gilbert, C. Lemaréchal, and C. A. Sagastizábal. Numerical Optimization: Theoretical

and Practical Aspects. Springer, 2006.

[7] J. Burke and M. Qian. On the superlinear convergence of the variable metric proximal point algorithm
using Broyden and BFGS matrix secant updating. Mathematical Programming, 88(1):157–181, 2000.

[8] R. Byrd, S. Hansen, J. Nocedal, and Y. Singer. A stochastic quasi-Newton method for large-scale

optimization. SIAM Journal on Optimization, 26(2):1008–1031, 2016.

28

[9] R. H. Byrd, G. M. Chin, J. Nocedal, and Y. Wu. Sample size selection in optimization methods for

machine learning. Mathematical Programming, 134(1):127–155, 2012.

[10] R. H. Byrd, J. Nocedal, and F. Oztoprak. An inexact successive quadratic approximation method for

L-1 regularized optimization. Mathematical Programming, 157(2):375–396, 2015.

[11] R. H. Byrd, J. Nocedal, and Y.-X. Yuan. Global convergence of a case of quasi-Newton methods on

convex problems. SIAM Journal on Numerical Analysis, 24(5):1171–1190, 1987.

[12] C. Cartis and K. Scheinberg. Global convergence rate analysis of unconstrained optimization methods

based on probabilistic models. Mathematical Programming, 169:337–375, 2018.

[13] C. Chang and C. Lin. Libsvm: a library for support vector machines. ACM transactions on intelligent

systems and technology (TIST), 2(3):27, 2011.

[14] X. Chen and M. Fukushima. Proximal quasi-Newton methods for nondiﬀerentiable convex optimization.

Mathematical Programming, 85(2):313–334, 1999.

[15] A. Defazio, F. Bach, and S. Lacoste-Julien. Saga: A fast incremental gradient method with support for
non-strongly convex composite objectives. In Proceedings of Advances in Neural Information Processing
Systems (NIPS), 2014.

[16] A. Defazio, J. Domke, and T. S. Caetano. Finito: A faster, permutable incremental gradient method for

big data problems. In International Conferences on Machine Learning (ICML), 2014.

[17] J. E. Dennis and J. J. Moré. A characterization of superlinear convergence and its application to

quasi-newton methods. Mathematics of computation, 28(126):549–560, 1974.

[18] J. C. Duchi, P. L. Bartlett, and M. J. Wainwright. Randomized smoothing for stochastic optimization.

SIAM Journal on Optimization, 22(2):674–701, 2012.

[19] M. Elad. Sparse and Redundant Representations. Springer, 2010.

[20] M. P. Friedlander and M. Schmidt. Hybrid deterministic-stochastic methods for data ﬁtting. SIAM

Journal on Scientiﬁc Computing, 34(3):A1380–A1405, 2012.

[21] R. Frostig, R. Ge, S. M. Kakade, and A. Sidford. Un-regularizing: approximate proximal point and
faster stochastic algorithms for empirical risk minimization. In International Conferences on Machine
Learning (ICML), 2015.

[22] M. Fuentes, J. Malick, and C. Lemaréchal. Descentwise inexact proximal algorithms for smooth

optimization. Computational Optimization and Applications, 53(3):755–769, 2012.

[23] M. Fukushima and L. Qi. A globally and superlinearly convergent algorithm for nonsmooth convex

minimization. SIAM Journal on Optimization, 6(4):1106–1120, 1996.

[24] S. Ghadimi, G. Lan, and H. Zhang. Generalized Uniformly Optimal Methods for Nonlinear Programming.

[25] H. Ghanbari and K. Scheinberg.

Proximal quasi-newton methods for convex optimization.

arxiv:1508.07384, 2015.

arXiv:1607.03081, 2016.

[26] R. M. Gower, D. Goldfarb, and P. Richtárik. Stochastic block BFGS: Squeezing more curvature out of

data. In International Conferences on Machine Learning (ICML), 2016.

[27] O. Güler. New proximal point algorithms for convex minimization. SIAM Journal on Optimization,

2(4):649–664, 1992.

29

[28] J.-B. Hiriart-Urruty and C. Lemaréchal. Convex Analysis and Minimization Algorithms I. Springer,

[29] J.-B. Hiriart-Urruty and C. Lemaréchal. Convex analysis and minimization algorithms. II. Springer,

[30] C. Lee and S. J. Wright.

Inexact successive quadratic approximation for regularized optimization.

arXiv:1803.01298, 2018.

[31] J. Lee, Y. Sun, and M. Saunders. Proximal Newton-type methods for convex optimization. In Proceedings

of Advances in Neural Information Processing Systems (NIPS), 2012.

[32] C. Lemaréchal and C. Sagastizábal. Practical aspects of the Moreau–Yosida regularization: Theoretical

preliminaries. SIAM Journal on Optimization, 7(2):367–385, 1997.

[33] H. Lin, J. Mairal, and Z. Harchaoui. A universal catalyst for ﬁrst-order optimization. In Proceedings of

Advances in Neural Information Processing Systems (NIPS), 2015.

[34] H. Lin, J. Mairal, and Z. Harchaoui. Catalyst acceleration for ﬁrst-order convex optimization: from

theory to practice. Journal of Machine Learning Research (JMLR), 18(212):1–54, 2018.

[35] D. C. Liu and J. Nocedal. On the limited memory BFGS method for large scale optimization. Mathematical

Programming, 45(1-3):503–528, 1989.

[36] X. Liu, C.-J. Hsieh, J. D. Lee, and Y. Sun. An inexact subsampled proximal newton-type method for

large-scale machine learning. arXiv:1708.08552, 2017.

[37] J. Mairal. Sparse coding for machine learning, image processing and computer vision. PhD thesis,

Cachan, Ecole normale supérieure, 2010.

[38] J. Mairal. Incremental majorization-minimization optimization with application to large-scale machine

learning. SIAM Journal on Optimization, 25(2):829–855, 2015.

[39] J. Mairal. End-to-end kernel learning with supervised convolutional kernel networks. In Proceedings of

Advances in Neural Information Processing Systems (NIPS), 2016.

[40] J. Mairal, F. Bach, and J. Ponce. Sparse modeling for image and vision processing. Foundations and

Trends in Computer Graphics and Vision, 8(2-3):85–283, 2014.

[41] R. Miﬄin. A quasi-second-order proximal bundle algorithm. Mathematical Programming, 73(1):51–72,

[42] A. Mokhtari and A. Ribeiro. Global convergence of online limited memory bfgs. Journal of Machine

Learning Research (JMLR), 16(1):3151–3181, 2015.

[43] J.-J. Moreau. Fonctions convexes duales et points proximaux dans un espace hilbertien. CR Acad. Sci.

Paris Sér. A Math, 255:2897–2899, 1962.

[44] P. Moritz, R. Nishihara, and M. I. Jordan. A linearly-convergent stochastic L-BFGS algorithm. In

International Conference on Artiﬁcial Intelligence and Statistics (AISTATS), 2016.

[45] Y. Nesterov. A method of solving a convex programming problem with convergence rate O(1/k2). Soviet

Mathematics Doklady, 27(2):372–376, 1983.

[46] Y. Nesterov. Introductory Lectures on Convex Optimization: A Basic Course. Springer, 2004.

[47] Y. Nesterov. Smooth minimization of non-smooth functions. Mathematical programming, 103(1):127–152,

1996.

1996.

1996.

2005.

30

[48] Y. Nesterov. Eﬃciency of coordinate descent methods on huge-scale optimization problems. SIAM

Journal on Optimization, 22(2):341–362, 2012.

[49] Y. Nesterov. Gradient methods for minimizing composite functions. Mathematical Programming,

[50] J. Nocedal. Updating quasi-Newton matrices with limited storage. Mathematics of Computation,

140(1):125–161, 2013.

35(151):773–782, 1980.

[51] J. Nocedal and S. Wright. Numerical optimization. Springer Science & Business Media, 2006.

[52] M. Razaviyayn, M. Hong, and Z.-Q. Luo. A uniﬁed convergence analysis of block successive minimization

methods for nonsmooth optimization. SIAM Journal on Optimization, 23(2):1126–1153, 2013.

[53] P. Richtárik and M. Takáč. Iteration complexity of randomized block-coordinate descent methods for

minimizing a composite function. Mathematical Programming, 144(1-2):1–38, 2014.

[54] R. T. Rockafellar. Monotone operators and the proximal point algorithm. SIAM Journal on Control

and Optimization, 14(5):877–898, 1976.

[55] K. Scheinberg and X. Tang. Practical inexact proximal quasi-Newton method with global complexity

analysis. Mathematical Programming, 160(1):495–529, 2016.

[56] M. Schmidt, D. Kim, and S. Sra. Projected Newton-type methods in machine learning, pages 305–330.

MIT Press, 2011.

[57] M. Schmidt, N. L. Roux, and F. Bach. Minimizing ﬁnite sums with the stochastic average gradient.

Mathematical Programming, 160(1):83–112, 2017.

[58] N. N. Schraudolph, J. Yu, and S. Günter. A stochastic quasi-newton method for online convex optimization.

In International Conference on Artiﬁcial Intelligence and Statistics (AISTATS), 2007.

[59] S. Shalev-Shwartz and T. Zhang. Accelerated proximal stochastic dual coordinate ascent for regularized

loss minimization. Mathematical Programming, 155(1):105–145, 2016.

[60] L. Stella, A. Themelis, and P. Patrinos. Forward–backward quasi-newton methods for nonsmooth

optimization problems. Computational Optimization and Applications, 67(3):443–487, 2017.

[61] L. Xiao and T. Zhang. A proximal stochastic gradient method with progressive variance reduction.

SIAM Journal on Optimization, 24(4):2057–2075, 2014.

[62] K. Yosida. Functional analysis. Berlin-Heidelberg, 1980.

[63] J. Yu, S. Vishwanathan, S. Günter, and N. N. Schraudolph. A quasi-Newton approach to non-smooth

convex optimization. In International Conferences on Machine Learning (ICML), 2008.

[64] H. Zou and T. Hastie. Regularization and variable selection via the elastic net. Journal of the Royal

Statistical Society: Series B (Statistical Methodology), 67(2):301–320, 2005.

A Proof of Proposition 3

First, we show that the Moreau envelope F inherits the bounded level set property from f .

Deﬁnition 2. We say that a convex function f has bounded level sets if f attains its minimum at x∗ in Rd
and for any x, there exists Rx > 0 such that

∀y ∈ Rd

s.t.

f (y) ≤ f (x)

then ky − x∗k ≤ Rx.

31

Lemma 11. If f has bounded level sets, then its Moreau envelope F has bounded level sets as well.

Proof. First, from Proposition 1, the minimum of F is attained at x∗. Next, we reformulate the bounded
level set property by contraposition: for any x, there exists Rx > 0 such that

∀y ∈ Rd

s.t. ky − x∗k > Rx

then f (y) > f (x).

Given x in Rd, we show that

∀y ∈ Rd

s.t. ky − x∗k >

+ Rx

then F (y) > F (x).

r

2(f (x) − f ∗)
κ

Let y satisﬁes the above inequality, by deﬁnition,

F (y) = f (p(y)) +

kp(y) − yk2.

κ
2

From the triangle inequality,

ky − p(y)k + kp(y) − x∗k ≥ ky − x∗k >

r

2(f (x) − f ∗)
κ

+ Rx.

Then either ky − p(y)k >

or kp(y) − x∗k > Rx.

q 2(f (x)−f ∗)
κ
q 2(f (x)−f ∗)
κ

, then

• If ky − p(y)k >

F (y) = f (p(y)) +

kp(y) − yk2 > f (p(y)) + f (x) − f ∗ ≥ f (x) ≥ F (x).

• If kp(y) − x∗k > Rx, then

F (y) = f (p(y)) +

kp(y) − yk2 ≥ f (p(y)) > f (x) ≥ F (x).

κ
2

κ
2

This completes the proof.

We are now in shape to prove the proposition.

Proof. From (25), we have

F (xk+1) ≤ F (xk) −

k∇F (xk)k2.

1
32κ

Thus F (xk) is decreasing. From the bounded level set property of F , there exists R > 0 such that kxk−x∗k ≤ R
for any k. By the convexity of F , we have

F (xk) − F ∗ ≤ h∇F (xk), xk − x∗i ≤ k∇F (xk)kkxk − x∗k ≤ Rk∇F (xk)k.

Therefore,

F (xk+1) − F ∗ ≤ F (xk) − F ∗ −

≤ F (xk) − F ∗ −

k∇F (xk)k2

1
32κ
(F (xk) − F ∗)2
32κR2

.

Let us deﬁne rk (cid:44) f (xk) − f ∗. Thus,

1
rk+1

≥

1
32κR2 )

rk(1 − rk

≥

1
rk

(cid:16)

1 +

(cid:17)

rk
32κR2

=

+

1
rk

1
32κR2 .

Then, after exploiting the telescoping sum,

1
rk+1

≥

+

1
r0

k + 1
32κR2 ≥

k + 1
32κR2 .

32

B Proof of Lemma 8

Proof. Let us denote δk = −B−1
when c ≤

µ2

128(µ+κ)2 , the following two inequalities hold:

k gk and let the subproblems solved to accuracy εk ≤ c

κ kgkk2. We show that

and

Then summing up the above inequalities yields

F (xk + δk) ≤ F (xk) −

kgkk2 + o(kgkk2),

Fk+1 ≤ F (xk + δk) +

kgkk2 + o(kgkk2).

3
8κ

1
16κ

Fk+1 ≤ F (xk) −

kgkk2 + o(kgkk2)

5
16κ
kgkk2,

1
4κ

≤ Fk −

(42)

(43)

where the last inequality holds since F (xk) ≤ Fk and o(kgkk2) ≤ 1
the desired descent condition (13).

4κ kgkk2 when k is large enough. This is

We ﬁrst prove (42) which relies on the somoothness and Lipschitz Hessian assumption of F . More

concretely,

F (xk + δk) − F (xk) ≤ ∇F (xk)T δk +

δT
k ∇2F (xk)δk +

kδkk3

1
2

= (∇F (xk) − gk)T δk + gT

k δk +

k (∇2F (xk) − Bk)δk +
δT

=

1
gT
k δk
2
| {z }
E1

+ (∇F (xk) − gk)T δk
{z
}
E2

|

+

δT
k (∇2F (xk) − Bk)δk
{z
}
E3

+

+

L2
6

kδkk3

δT
k Bkδk
}
{z
2 gT
k δk

1
2
|
=− 1
L2
6
|

.

kδkk3
{z
}
E4

L2
6

1
2

1
2
|

We are going upper bound each term one by one. First,

where the last inequality uses (DM) and the κ-smoothness of F which implies ∇2F (x∗) (cid:22) κI. Second,

E1 =

1
2

k gk

gkB−1

1
gT
k δk = −
2
1
gk∇2F (x∗)−1gk −
2
1
2κ

kgkk2 + o(kgkk2),

1
2

= −

≤ −

gk(B−1

k − ∇2F (x∗)−1)gk

E2 = (∇F (xk) − gk)T δk ≤ k∇F (xk) − gkkkδkk

2ckgkkkB−1
2ckgkk (cid:2)k∇2F (x∗)−1gkk + k (cid:0)B−1

(from (18))

k gkk

k − ∇2F (x∗)−1(cid:1) gkk(cid:3)

≤

≤

≤

=

√

√

√

1
8κ

2c

1
µF

kgkk2 + o(kgkk2)

kgkk2 + o(kgkk2).

33

Third,

E3 =

1
2

kδkkk(∇2F (xk) − Bk)δkk

k (∇2F (xk) − Bk)δk ≤
δT

1
2
1
kδkk (cid:0)k(∇2F (xk) − ∇2F (x∗))δkk + k(∇2F (x∗) − Bk)δkk(cid:1)
2
L2
2

kxk − x∗kkδkk2 + k∇2F (x∗)kk(B−1

k − ∇2F (x∗)−1)gkk

≤

≤

= o(kgkk2),

where the last line comes from (DM) and the fact that kxk − x∗k → 0. Last, since

δk = −∇2F (x∗)−1gk
}

|

{z
=O(kgkk)

+

(∇2F (x∗)−1 − B−1
|

{z
=o(kgkk) by Dennis-Moré condition

k )gk
}

and kgkk → 0, we have

E4 =

kδkk3 = o(kgkk2).

L2
6

Summing up above four inequalities yields (42). Next, we prove the other desired inequality (43). The main
eﬀort is to bound kgk+1k by a constant factor times kgkk. From the inexactness of the subproblem, we have

Fk+1 ≤ F (xk+1) +

kgk+1k2 ≤ F (xk+1) +

k∇F (xk+1)k2

2c
(1 − 4c)κ

c
κ

∇F (xk+1) − ∇F (xk) − ∇2F (x∗)(xk+1 − xk)
Z 1

(cid:0)∇2F (xk + τ (xk+1 − xk)) − ∇2F (x∗)(cid:1) (xk+1 − xk)dτ

=

0

k∇F (xk+1) − ∇F (xk) − ∇2F (x∗)(xk+1 − xk)k ≤ max {kxk − x∗k, kxk+1 − x∗k} kxk+1 − xkk = o(kgkk).

k∇F (xk+1)k ≤ k∇F (xk) + ∇2F (x∗)(xk+1 − xk)k + o(kgkk)

≤ k∇F (xk) − gkk + kgk + ∇2F (x∗)(xk+1 − xk)k
|
}
{z
=o(kgkk) by Dennis-Moré condition

+o(kgkk)

√

≤

2ckgkk + o(kgkk).

Moreover,

Therefore,

As a result,

Fk+1 ≤ F (xk+1) +

k∇gkk2 + o(kgkk2)

≤ F (xk+1) +

k∇gkk2 + o(kgkk2) when

c ≤

1
16

.

This completes the proof.

4c2
(1 − 4c)κ

1
16κ

34

C Additional experiments

In this section, we provide additional experimental results including experimental comparisons in terms of
outer loop iterations, and an empirical study regarding the choice of the unit step size ηk = 1.

C.1 Comparisons in terms of outer-loop iterations

In the main paper, we have used the number of gradient evaluations as a natural measure of complexity.
Here, we also provide a comparison in terms of outer-loop iterations, which does not take into account the
complexity of solving the sub-problems. While interesting, the comparison artiﬁcially gives an advantage to
the stopping criteria (12) since achieving it usually requires multiple passes.

Figure 6: Experimental study of the performance of QNing-SVRG respect to the number of outer iterations.

The result of the comparison is presented in Figure 6. We observe that the theoretical grounded variant
QNing-SVRG always outperform the one-pass heuristic QNing-SVRG1. This is not surprising since the
sub-problems are solved more accurately in the theoretical grounded variant. However, once we take the

35

complexity of the sub-problems into account, QNing-SVRG never outperforms QNing-SVRG1. This suggests
that it is not beneﬁcial to solve the sub-problem up to high accuracy as long as the algorithm converge.

C.2 Empirical frequency of choosing the unit stepsize

In this section, we evaluate how often the unit stepsize is taken in the line search. When the unit stepsize is
taken, the variable metric step provides suﬃcient decrease, which is the key for acceleration. The statistics
of QNing-SVRG1 (one-pass variant) and QNing-SVRG (the sub-problems are solved until the stopping
criteria (12) is satisfed ) are given in Table 1 and Table 2, respectively. As we can see, for most of the
iterations (> 90%), the unit stepsize is taken.

Table 1: Relative frequency of picking the unit stepsize ηk = 1 of QNing-SVRG1

Logistic

Elastic-net

Lasso

covtype
alpha

24/27
8/8

real-sim 60/60
53/53
58/58

mnist
cifar-10

6/6

89% 54/56
100%
100% 71/76
100% 80/80
100% 75/75

19/21
96%
6/6
100%
93%
14/14
100% 100/100
42/44
100%

90%
100%
100%
100%
95%

The ﬁrst column is in the form N/D, where N is the number of times over the iterations
the unit stepsize was picked and D is the total number of iterations. The total number
of iterations D varies a lot since we stop our algorithm as soon as the relative function
gap is smaller than 10−10 or the maximum number of iterations 100 is reached. It
implicitly indicates how easy the problem is.

Table 2: Relative frequency of picking the unit stepsize ηk = 1 of QNing-SVRG

Logistic

Elastic-net

Lasso

covtype
alpha

18/20
6/6
real-sim 27/27
27/27
25/25

mnist
cifar-10

4/4

90% 23/25
100%
100% 20/23
100% 28/28
100% 29/29

92% 16/16
100%
87%
100% 28/28
100% 31/31

3/3
8/8

100%
100%
100%
100%
100%

The setting are the same as in Table 1.

36

