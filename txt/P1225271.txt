Action Schema Networks: Generalised Policies with Deep Learning

Sam Toyer1, Felipe Trevizan1,2, Sylvie Thi´ebaux1 and Lexing Xie1,3
1 Research School of Computer Science, Australian National University 2 Data61, CSIRO 3 Data to Decisions CRC
first.last@anu.edu.au

7
1
0
2
 
c
e
D
 
2
2
 
 
]
I

A
.
s
c
[
 
 
2
v
1
7
2
4
0
.
9
0
7
1
:
v
i
X
r
a

Abstract

In this paper, we introduce the Action Schema Network (AS-
Net): a neural network architecture for learning generalised
policies for probabilistic planning problems. By mimicking
the relational structure of planning problems, ASNets are able
to adopt a weight sharing scheme which allows the network
to be applied to any problem from a given planning domain.
This allows the cost of training the network to be amortised
over all problems in that domain. Further, we propose a train-
ing method which balances exploration and supervised train-
ing on small problems to produce a policy which remains
robust when evaluated on larger problems. In experiments,
we show that ASNet’s learning capability allows it to signiﬁ-
cantly outperform traditional non-learning planners in several
challenging domains.

1

Introduction

Automated planning is the task of ﬁnding a sequence of ac-
tions which will achieve a goal within a user-supplied model
of an environment. Over the past four decades, there has
been a wealth of research into the use of machine learn-
ing for automated planning (Jim´enez et al. 2012), motivated
in part by the belief that these two essential ingredients of
intelligence—planning and learning—ought to strengthen
one other (Zimmerman and Kambhampati 2003). Neverthe-
less, the dominant paradigm among state-of-the-art classi-
cal and probabilistic planners is still based on heuristic state
space search. The domain-independent heuristics used for
this purpose are capable of exploiting common structures
in planning problems, but do not learn from experience.
Top planners in both the deterministic and learning tracks
of the International Planning Competition often use ma-
chine learning to conﬁgure portfolios (Vallati et al. 2015),
but only a small fraction of planners make meaningful use
of learning to produce domain-speciﬁc heuristics or control
knowledge (de la Rosa, Celorrio, and Borrajo 2008). Plan-
ners which transfer knowledge between problems in a do-
main have been similarly underrepresented in the probabilis-
tic track of the competition.

In parallel with developments in planning, we’ve seen a
resurgence of interest in neural nets, driven largely by their
success at problems like image recognition (Krizhevsky,

Copyright c(cid:13) 2018, Association for the Advancement of Artiﬁcial
Intelligence (www.aaai.org). All rights reserved.

Figure 1: In a CNN, successive convolutions grow the re-
ceptive ﬁeld of a neuron at higher layers; analogously for
ASNet, a neuron for a particular action a or proposition p
sees a larger portion of the current state at higher layers.

Sutskever, and Hinton 2012) and learning to play video
games (Mnih et al. 2013). This paper brings some gains of
deep learning to planning by proposing a new neural net-
work architecture, the ASNet, which is specialised to the
structure of planning problems much as Convolutional Neu-
ral Networks (CNNs) are specialised to the structure of im-
ages. The basic idea is illustrated in Figure 1: rather than
operating on a virtual graph of pixels with edges deﬁned by
adjacency relationships, an ASNet operates on a graph of
actions and propositions (i.e. Boolean variables), with edges
deﬁned by relations of the form “action a affects proposition
p” or “proposition p inﬂuences the outcome of action a”.
This structure allows an ASNet to be trained on one problem
from a given planning domain and applied to other, different
problems without re-training.

We make three new contributions. (1) A neural network
architecture for probabilistic planning that automatically
generalises to any problem from a given planning domain.
(2) A representation that allows weight sharing among ac-
tions modules belonging to the same action schema, and
among proposition modules associated with the same pred-
icate. This representation is augmented by input features

from domain-independent planning heuristics. (3) A train-
ing method that balances exploration and supervision from
existing planners. In experiments, we show that this strategy
is sufﬁcient to learn effective generalised policies. Code and
models for this work are available online. 1

2 Background
This work considers probabilistic planning problems repre-
sented as Stochastic Shortest Path problems (SSPs) (Bert-
sekas and Tsitsiklis 1996). Formally, an SSP is a tuple
(S, A, T , C, G, s0) where S is a ﬁnite set of states, A is a
ﬁnite set of actions, T : S × A × S → [0, 1] is a transition
function, C : S × A → (0, ∞) is a cost function, G ⊆ S is
a set of goal states, and s0 is an initial state. At each state s,
an agent chooses an action a from a set of enabled actions
A(s) ⊆ A, incurring a cost of C(s, a) and causing it to tran-
sition into another state s(cid:48) ∈ S with probability T (s, a, s(cid:48)).
The solution of an SSP is a policy π : A×S → [0, 1] such
that π(a | s) is the probability that action a will be applied in
state s. An optimal policy π∗ is any policy that minimises
the total expected cost of reaching G from s0. We do not as-
sume that the goal is reachable with probability 1 from s0
(i.e. we allow problems with unavoidable dead ends), and
a ﬁxed-cost penalty is incurred every time a dead end is
reached (Mausam and Kolobov 2012).

A factored SSP is a compact representation of an SSP as
a tuple (P, A, s0, s(cid:63), C). P is a ﬁnite set of binary propo-
sitions and the state space S is the set of all binary strings
of size |P|. Thus, a state s is a value assignment to all the
propositions p ∈ P. A partial state is a value assignment to
a subset of propositions; a partial state s is consistent with
a partial state s(cid:48) if the value assignments of s(cid:48) are contained
in s (s(cid:48) ⊆ s for short). The goal is represented by a partial
state s(cid:63), and G = {s ∈ S|s(cid:63) ⊆ s}. Each action a ∈ A con-
sists in a precondition pre a represented by a partial state, a
set of effects eﬀ a each represented by a partial state, and a
probability distribution Pr a over effects in eﬀ a.2 The ac-
tions applicable in state s are A(s) = {a ∈ A | pre a ⊆ s}.
Moreover, T (s, a, s(cid:48)) = (cid:80)
e∈eﬀ a|s(cid:48)=res(s,e) Pr a(e) where
res(s, e) ∈ S is the result of changing the value of proposi-
tions of s to make it consistent with effect e.

A lifted SSP compactly represents a set of factored SSPs
sharing the same structure. Formally, a lifted SSP is a tu-
ple (F, A, C) where F is a ﬁnite set of predicates, and
A is a ﬁnite set of action schemas. Each predicate, when
grounded, i.e., instantiated by a tuple of names representing
objects, yields a factored SSP proposition. Similarly, each
action schema, instantiated by a tuple of names, yields a fac-
tored SSP action. The Probabilistic Planning Domain Deﬁ-
nition Language (PPDDL) is the standard language to de-
scribe lifted and factored SSPs (Younes and Littman 2004).
PPDDL splits the description into a general domain and a
speciﬁc problem. The domain gives the predicates F, action

1https://github.com/qxcv/asnets
2 Factored SSPs sometimes support conditional effects and neg-
ative or disjunctive preconditions and goals. We do not use these
here to simplify notation. However, ASNet can easily be extended
to support these constructs.

schemas A and cost function C specifying a lifted SSP. The
problem additionally gives the set of objects O, initial state
s0 and goal s(cid:63), describing a speciﬁc SSP whose propositions
and actions are obtained by grounding the domain predicates
and action schemas using the objects in O. For instance the
domain description might specify a predicate at(?l) and an
action schema walk(?from, ?to), while the problem descrip-
tion might specify objects home and work. Grounding us-
ing these objects would produce propositions at(home) and
at(work), as well as ground actions walk(work, home) and
walk(home, work).

Observe that different factored SSPs can be obtained by
changing only the problem part of the PPDDL description
while reusing its domain. In the next section, we show how
to take advantage of action schema reuse to learn policies
that can then be applied to any factored SSP obtained by
instantiating the same domain.

3 Action Schema Networks
Neural networks are expensive to train, so we would like to
amortise that cost over many problems by learning a gener-
alised policy which can be applied to any problem from a
given domain. ASNet proposes a novel, domain-specialised
structure that uses the same set of learnt weights θ regard-
less of the “shape” of the problem. The use of such a weight
sharing scheme is key to ASNet’s ability to generalise to
different problems drawn from the same domain, even when
those problems have different goals or different numbers of
actions and propositions.

3.1 Network structure
At a high level, an ASNet is composed of alternating action
layers and proposition layers, where action layers are com-
posed of a single action module for each ground action, and
proposition layers likewise are composed of a single propo-
sition module for each ground proposition; this choice of
structure was inspired by the alternating action and propo-
sition layers of Graphplan (Blum and Furst 1997). In the
same way that hidden units in one layer of a CNN connect
only to nearby hidden units in the next layer, action modules
in one layer of an ASNet connect only to directly related
proposition modules in the next layer, and vice versa. The
last layer of an ASNet is always an action layer with each
module deﬁning an action selection probability, thus allow-
ing the ASNet to scale to problems with different numbers of
actions. For simplicity, we also assume that the ﬁrst (input)
layer is always an action layer.

Action module details. Consider an action module for
a ∈ A in the lth action layer. The module takes as input a
feature vector ul
a, and produces a new hidden representation
a + bl

a = f (W l
φl

a · ul

a) ,

a ∈ Rdh×dl

where W l
a is a learnt weight matrix for the mod-
a ∈ Rdh is a learnt bias vector, f (·) is a nonlinearity
ule, bl
(e.g. tanh, sigmoid, or ReLU), dh is a (ﬁxed) intermediate
representation size, and dl
a is the size of the inputs to the
action module. The feature vector ul
a, which serves as in-
put to the action module, is constructed by enumerating the

propositions p1, p2, . . . , pM which are related to the action
a, and then concatenating their hidden representations. For-
mally, we say that a proposition p ∈ P is related to an action
a ∈ A, denoted R(a, p), if p appears in pre a or in an effect
e where Pr a(e) > 0. Concatenation of representations for
the related propositions produces a vector

ul
a =

(cid:104)

T

ψl−1
1

· · · ψl−1
M

T (cid:105)T

,

j

a has dimension dl

where ψl−1
is the hidden representation produced by the
proposition module for proposition pj ∈ P in the preceding
proposition layer. Each of these constituent hidden represen-
tations has dimension dh, so ul
a = dh · M .
Our notion of propositional relatedness ensures that, if
ground actions a1 and a2 in a problem are instances of the
same action schema in a PPDDL domain, then their inputs
ul
1 and ul
2 will have the same “structure”. To see why, note
that we can determine which propositions are related to a
given ground action a by retrieving the corresponding ac-
tion schema, enumerating the predicates which appear in the
precondition or the effects of the action schema, then instan-
tiating those predicates with the same parameters used to
instantiate a. If we apply this procedure to a1 and a2, we
will obtain lists of related propositions p1, p2, . . . , pM and
q1, q2, . . . , qM , respectively, where pj and qj are proposi-
tions with the same predicate which appear in the same po-
sition in the deﬁnitions of a1 and a2 (i.e. the same location
in the precondition, or the same position in an effect).

c = bl

d = bl

s and bl

c = W l

d = W l

s and bias vector bl

Such structural similarity is key to ASNet’s generalisation
abilities. At each layer l, and for each pair of ground actions
c and d instantiated from the same action schema s, we use
the same weight matrix W l
s—that is, we
have W l
s. Hence, modules
for actions which appear in the same layer and correspond to
the same action schema will use the same weights, but mod-
ules which appear in different layers or which correspond
to different schemas will learn different weights. Although
different problems instantiated from the same PPDDL do-
main may have different numbers of ground actions, those
ground actions will still be derived from the same, ﬁxed set
of schemas in the domain, so we can apply the same set of
action module weights to any problem from the domain.

The ﬁrst and last layers of an ASNet consist of action

modules, but their construction is subtly different:
1. The output of a module for action a in the ﬁnal layer is
a single number πθ(a | s) representing the probability of
selecting action a in the current state s under the learnt
policy πθ, rather than a vector-valued hidden representa-
tion. To guarantee that disabled actions are never selected,
and ensure that action probabilities are normalised to 1,
we pass these outputs through a masked softmax activa-
tion which ensures that πθ(a | s) = 0 if a /∈ A(s). During
training, we sample actions from πθ(a | s). During eval-
uation, we select the action with the highest probability.

2. Action modules in the ﬁrst layer of a ASNet are passed an
input vector composed of features derived from the cur-
rent state, rather than hidden representations for related
propositions. Speciﬁcally, modules in the ﬁrst layer are

given a binary vector indicating the truth values of related
propositions, and whether those propositions appear in the
goal. In practice, it is helpful to concatenate these propo-
sitional features with heuristic features, as described in
Section 3.2.
Proposition module details. Proposition modules only
appear in the intermediate layers of an ASNet, but are oth-
erwise similar to action modules. Speciﬁcally, a proposition
module for proposition p ∈ P in the lth proposition layer of
the network will compute a hidden representation
p = f (W l
ψl

p + bl

p · vl

p) ,

where vl
p ∈ Rdh×dl
before, and W l
and biases for the module.

p is a feature vector, f is the same nonlinearity used
p ∈ Rdh are learnt weights

p and bl

To construct the input vl

p, we ﬁrst ﬁnd the predicate
pred(p) ∈ F for proposition p ∈ P, then enumerate all
action schemas A1, . . . , AL ∈ A which reference pred(p)
in a precondition or effect. We can deﬁne a feature vector






vl
p =

pool({φl
a

T

| op(a) = A1 ∧ R(a, p)})

...




 ,

pool({φl
a

T

| op(a) = AL ∧ R(a, p)})

p of vl

where op(a) ∈ A denotes the action schema for ground ac-
tion a, and pool is a pooling function that combines several
dh-dimensional feature vectors into a single dh-dimensional
one. Hence, when all pooled vectors are concatenated, the
dimensionality dl
p becomes dh · L. In this paper, we
assume that pool performs max pooling (i.e. keeps only the
largest input). If a proposition module had to pool over the
outputs of many action modules, such pooling could po-
tentially obscure useful information. While the issue could
be overcome with a more sophisticated pooling mechanism
(like neural attention), we did not ﬁnd that max pooling
posed a major problem in the experiments in Section 5, even
on large Probabilistic Blocks World instances where some
proposition modules must pool over thousands of inputs.

Pooling operations are essential to ensure that proposi-
tion modules corresponding to the same predicate have the
same structure. Unlike action modules corresponding to the
same action schema, proposition modules corresponding to
the same predicate may have a different number of inputs
depending on the initial state and number of objects in a
problem, so it does not sufﬁce to concatenate inputs. As an
example, consider a single-vehicle logistics problem where
the location of the vehicle is tracked with propositions of
the form at(ι), and the vehicle may be moved with actions
of the form move(ιfrom, ιto). A location ι1 with one incom-
ing road and no outgoing roads will have only one related
move action, but a location ι2 with two incoming roads and
no outgoing roads will have two related move actions, one
for each road. This problem is not unique to planning: a sim-
ilar trick is employed in network architectures for graphs
where vertices can have varying in-degree (Jain et al. 2016;
Kearnes et al. 2016).

As with the action modules, we share weights between
proposition modules for propositions corresponding to the

same predicate. Speciﬁcally, at proposition layer l, and for
propositions q and r with pred(q) = pred(r), we tie the
q = W l
corresponding weights W l
r. Together
with the weight sharing scheme for action modules, this en-
ables us to learn a single set of weights

r and bl

q = bl

θ ={W l
∪{W l

a, bl
p, bl

a | 1 ≤ l ≤ n + 1, a ∈ A}
p | 1 ≤ l ≤ n, p ∈ F}

for an n-layer model which can be applied to any problem
in a given PPDDL domain.

3.2 Heuristic features for expressiveness
One limitation of the ASNet is the ﬁxed receptive ﬁeld of the
network; in other words, the longest chain of related actions
and propositions which it can reason about. For instance,
suppose we have I locations ι1, . . . , ιI arranged in a line in
our previous logistics example. The agent can move from
ιk−1 to ιk (for k = 2, . . . , I) with the move(ιk−1, ιk) action,
which makes at(ιk−1) false and at(ιk) true. The proposi-
tions at(ι1) and at(ιI ) will thus be related only by a chain
of move actions of length I −1; hence, a proposition module
in the lth proposition layer will only be affected by at propo-
sitions for locations at most l + 1 moves away. Deeper net-
works can reason about longer chains of actions, but that an
ASNet’s (ﬁxed) depth necessarily limits its reasoning power
when chains of actions can be arbitrarily long.

We compensate for this receptive ﬁeld limitation by sup-
plying the network with features obtained using domain-
independent planning heuristics. In this paper, we derive
these features from disjunctive action landmarks produced
by LM-cut (Helmert and Domshlak 2009), but features de-
rived from different heuristics could be employed in the
same way. A disjunctive action landmark is a set of actions
in which at least one action must be applied along any opti-
mal path to the goal in a deterministic, delete-relaxed version
of the planning problem. These landmarks do not necessarily
capture all useful actions, but in practice we ﬁnd that provid-
ing information about these landmarks is often sufﬁcient to
compensate for network depth limitations.

In this paper, a module for action a in the ﬁrst network

layer is given a feature vector

a = (cid:2)cT
u1

vT

gT (cid:3)T

.

c ∈ {0, 1}3 indicates whether ai is the sole action in at least
one LM-cut landmark (c1 = 1), an action in a landmark
of two or more actions (c2 = 1), or does not appear in a
landmark (c3 = 1). v ∈ {0, 1}M represents the M related
propositions: vj is 1 iff pj is currently true. g ∈ {0, 1}M
encodes related portions of the goal state, and gj is 1 iff pj
is true in the partial state s(cid:63) deﬁning the goal.

4 Training with exploration and supervision
We learn the ASNet weights θ by choosing a set of small
training problems Ptrain, then alternating between guided ex-
ploration to build up a state memory M, and supervised
learning to ensure that the network chooses good actions
for the states in M. Algorithm 1 describes a single epoch

for i = 1, . . . , Texplore do
for all ζ ∈ Ptrain do

Algorithm 1 Updating ASNet weights θ using state memory
M and training problem set Ptrain
1: procedure ASNET-TRAIN-EPOCH(θ, M)
2:
3:
4:
5:
6:
7:
8:

s0, . . . , sN ← RUN-POL(s0(ζ), πθ)
M ← M ∪ {s0, . . . , sN }
for j = 0, . . . , N do
j , . . . , s∗
s∗
M ← M ∪ {s∗

M ← POL-ENVELOPE(sj, π∗)
M }

(cid:46) Exploration

j , . . . , s∗

for i = 1, . . . , Ttrain do

(cid:46) Learning

B ← SAMPLE-MINIBATCH(M)
Update θ using dLθ(B)

(Equation 1)

dθ

9:
10:

11:

of exploration and supervised learning. We repeatedly ap-
ply this procedure until performance on Ptrain ceases to im-
prove, or until a ﬁxed time limit is reached. Note that this
strategy is only intended to learn the weights of an ASNet—
module connectivity is not learnt, but rather obtained from
a grounded representation using the notion of relatedness
which we described earlier.

In the exploration phase of each training epoch, we repeat-
edly run the ASNet policy πθ from the initial state of each
problem ζ ∈ Ptrain, collecting N + 1 states s0, . . . , sN vis-
ited along each of the sampled trajectories. Each such trajec-
tory terminates when it reaches a goal, exceeds a ﬁxed limit
L on length, or reaches a dead end. In addition, for each
visited state sj, we compute an optimal policy π∗ rooted at
sj, then produce a set of states s∗
M which constitute
π∗’s policy envelope—that is, the states which π∗ visits with
nonzero probability. Both the trajectories drawn from the
ASNet policy πθ and policy envelopes for the optimal policy
π∗ are added to the state memory M. Saving states which
can be visited under an optimal policy ensures that M al-
ways contains states along promising trajectories reachable
from s0. On the other hand, saving trajectories from the ex-
ploration policy ensures that ASNet will be able to improve
on the states which it visits most often, even if they are not
on an optimal goal trajectory.

j , . . . , s∗

In the training phase, small subsets of the states in M
are repeatedly sampled at random to produce minibatches
for training ASNet. The objective to be minimised for each
minibatch B is the cross-entropy classiﬁcation loss

Lθ(B) =

(cid:88)

(cid:88)

s∈B

a∈A

(cid:2)(1 − ys,a) · log(1 − πθ(a | s))

(1)

+ ys,a · log πθ(a | s)(cid:3) .

The label ys,a is 1 if the expected cost of choosing action a
and then following an optimal policy thereafter is minimal
among all enabled actions; otherwise, ys,a = 0. This en-
courages the network to imitate an optimal policy. For each
sampled batch B, we compute the gradient dLθ(B)
and use it
to update the weights θ in a direction which decreases Lθ(B)
with Adam (Kingma and Ba 2015).

dθ

The cost of computing an optimal policy during super-
vised learning is often non-trival. It is natural to ask whether

it is more efﬁcient to train ASNets using unguided policy
gradient reinforcement learning, as FPG does (Buffet and
Aberdeen 2009). Unfortunately, we found that policy gradi-
ent RL was too noisy and inefﬁcient to train deep networks
on nontrivial problems; in practice, the cost of computing an
optimal policy for small training problems more than pays
for itself by enabling us to use sample-efﬁcient supervised
learning instead of reinforcement learning. In the experi-
ments, we investigate the question of whether suboptimal
policies are still sufﬁcient for supervised training of ASNets.
Past work on generalised policy learning has employed
learnt policies as control knowledge for search algorithms,
in part because doing so can compensate for ﬂaws in the pol-
icy. For example, Yoon, Fern, and Givan (2007) suggest em-
ploying policy rollout or limited discrepancy search to avoid
the occasional bad action recommended by a policy. While
we could use an ASNet similarly, we are more interested in
its ability to learn a reliable policy on its own. Hence, during
evaluation, we always choose the action which maximises
πθ(a | s). As noted above, this is different from the explo-
ration process employed during training, where we instead
sample from πθ(a | s).

5 Experiments and discussion
In this section, we compare ASNet against state-of-the-art
planners on three planning domains.

5.1 Experimental setup
We compare ASNet against three heuristic-search-based
probabilistic planners: LRTDP (Bonet and Geffner 2003),
ILAO* (Hansen and Zilberstein 2001) and SSiPP (Trevizan
and Veloso 2014). Two domain-independent heuristics are
considered for each of the three planners—LM-cut (admissi-
ble) and the additive heuristic hadd (inadmissible) (Teichteil-
K¨onigsbuch, Vidal, and Infantes 2011)—resulting in 6 base-
lines. During evaluation, we enforce a 9000s time cutoff for
all the baselines and ASNets, as well as a 10Gb memory
cutoff.

Since LRTDP and ILAO* are optimal planners, we exe-
cute them until convergence ((cid:15) = 10−4) for each problem us-
ing 30 different random seeds. Notice that, for hadd, LRTDP
and ILAO* might converge to a suboptimal solution. If an
execution of LRTDP or ILAO* does not converge before the
given time/memory cutoff, we consider the planner as hav-
ing failed to reach the goal. SSiPP is used as a replanner and,
for each problem, it is trained until 60s before the time cut-
off and then evaluated; this procedure is repeated 30 times
for each problem using different random seeds. The train-
ing phase of SSiPP consists in simulating a trajectory from
s0 and, during this process, SSiPP improves its lower bound
on the optimal solution. If 100 consecutive trajectories reach
the goal during training, then SSiPP is evaluated regardless
of the training time left. For the 6 baselines, we report the
average running time per problem.

For each domain, we train a single ASNet, then evaluate
it on each problem 30 times with different random seeds.
The hyperparmeters for each ASNet were kept ﬁxed across
domains: three action layers and two proposition layers in

each network, a hidden representation size of 16 for each in-
ternal action and proposition module, and an ELU (Clevert,
Unterthiner, and Hochreiter 2016) as the nonlinearity f . The
optimiser was conﬁgured with a learning rate of 0.0005 and
a batch size of 128, and a hard limit of two hours (7200s)
was placed on training. We also applied (cid:96)2 regularisation
with a coefﬁcient of 0.001 on all weights, and dropout on
the outputs of each layer except the last with p = 0.25. Each
epoch of training alternated between 25 rounds of explo-
ration shared equally among all training problems, and 300
batches of network optimisation (i.e. Texplore = 25/|Ptrain|
and Ttrain = 300). Sampled trajectory lengths are L = 300
for both training and evaluation. LRTDP with the LM-cut
heuristic is used for computing the optimal policies during
training, with a dead-end penalty of 500. We also repeated
this procedure for LRTDP using hadd (inadmissible heuris-
tic) to compare the effects of using optimal and suboptimal
policies for training. Further, we report how well ASNet per-
forms when it is guided by hadd, but not given the LM-cut-
derived heuristic features described in Section 3.2. For the
ASNets, we report the average training time plus time to
solve the problem to highlight when it pays off to spend the
one-off cost of training an ASNet for a domain.

All ASNets were trained and evaluated on a virtual ma-
chine equipped with 62GB of memory and an x86-64 pro-
cessor clocked at 2.3GHz. For training and evaluation, each
ASNet was restricted to use a single, dedicated processor
core, but resources were otherwise shared. The baseline
planners were run in a cluster of x86-64 processors clocked
at 2.6GHz and each planner again used only a single core.

5.2 Domains
We evaluate ASNets and the baselines on the following
probabilistic planning domains:

CosaNostra Pizza: as a Deliverator for CosaNostra
Pizza, your job is to safely transport pizza from a shop to
a waiting customer, then return to the shop. There is a se-
ries of toll booths between you and the customer: at each
booth, you can either spend a time step paying the operator,
or save a step by driving through without paying. However,
if you don’t pay, the (angry) operator will try to drop a boom
on your car when you pass through their booth on the way
back to the shop, crushing the car with 50% probability. The
optimal policy is to pay operators when travelling to the cus-
tomer to ensure a safe return, but not pay on the return trip
as you will not revisit the booth. Problem size is the number
of toll booths between the shop and the customer. ASNets
are trained on sizes 1-5, and tested on sizes 6+.

Probabilistic Blocks World is an extension of the well-
known deterministic blocks world domain in which a robotic
arm has to move blocks on a table into a goal conﬁguration.
The actions to pick up a block or to put a block on top of
another fail with probability 0.25; failure causes the target
block to drop onto the table, meaning that it must be picked
up and placed again. We randomly generate three different
problems for each number of blocks considered during test-
ing. ASNet is trained on ﬁve randomly generated problems
of each size from 5–9, for 25 training problems total.

Triangle Tire World (Little and Thi´ebaux 2007): each

Figure 2: Comparison of planner running times on the evaluation domains. TR refers to the time used for training (zero for
baselines). ASNet runs with (adm.) used optimal policies for training while (inadm.) used potentially suboptimal policies, and
runs with (no LM) did not use heuristic input features. The table at right shows, for selected problems, the coverage and average
solution cost for the best ASNet and baseline. We use TTW for Triangle Tire World, CN for CosaNostra Pizza, and PBW for
Probabilistic Blocks World. In PBW, running times are averaged over the three problems of each size. In TTW and PBW, ASNet
(no LM) occludes ASNet (inadm.). ASNet (adm.) is also occluded in TTW, but is absent entirely from PBW as the optimal
planner used to generate training data could not solve all training problems in time.

problem consists of a set of locations arranged in a triangle,
with connections between adjacent locations. The objective
is to move a vehicle from one corner of the triangle to an-
other. However, each move has a 50% chance of producing
a ﬂat tire, which must be replaced at the next visited loca-
tion. The vehicle thus requires a sequence of moves between
locations where replacement tires are available. Tires are ar-
ranged such that the most reliable policy is one which travels
the longest path to the goal, along the outside edge of the tri-
angle. This task can be made more challenging by scaling up
the number of locations. Per Little and Thi´ebaux (2007), a
problem of size n has (n + 1)(2n + 1) locations. We use
sizes 1-3 for training, and test with sizes from 4 onward.

5.3 Results
Figure 2 shows the time taken to train and evaluate ASNet
using optimal (adm.) and suboptimal (inadm.) policies as
training data. In addition, it shows coverage (proportion of
runs which reached the goal) and average solution cost when
the goal is reached for selected problems for the best ASNet
and best baseline. The following is a summary of our results:
When is it worth using ASNet? All ASNets obtained 30
out of 30 coverage for all Triangle Tire World problems, and
the ASNets with heuristic input features similarly obtained
perfect coverage on CosaNostra. In contrast, the baselines
failed to scale up to the larger problems. This shows that AS-
Net is well-suited to problems where local knowledge of the
environment can help to avoid common traps, for instance:
in CosaNostra, the agent must learn to pay toll booth oper-
ators when carrying a pizza and not pay otherwise; and in
Triangle Tire World, the agent must learn to sense and fol-
low the outer edge of the triangle. Not only could ASNets
learn these tricks, but the average solution cost obtained by
ASNets for CosaNostra and Triangle Tire World was close
to that of the optimal baselines (when they converged), sug-
gesting that the optimal solution was found.

Probabilistic Blocks World is more challenging as there

is no single pattern that can solve all problems. Even for the
deterministic version of Blocks World, a generalised policy
requires the planner to learn a recursive property for whether
each block is in a goal position (Slaney and Thi´ebaux 2001).
The ASNet appears to have successfully learnt to do this
when trained by a suboptimal teacher and given landmarks
as input, and surpassed all baselines in coverage (reaching
the goal on 30/30 runs on each instance). Moreover, the av-
erage solution cost of ASNet (inadm.) is similar to the op-
timal baselines (when they converge) and up to 3.7 times
less than SSiPP (inadm.), the baseline with the best cover-
age. The ASNet (inadm.) policy typically obtained a mean
solution cost somewhere between the US and GN1 strate-
gies presented by Slaney and Thi´ebaux: it is suboptimal, but
still better than unstacking and rebuilding all towers from
scratch. Note that the ASNet could not obtain a policy within
the allotted time when trained by an optimal teacher.

Are the heuristic features necessary? In some cases,
ASNet’s performance can be improved by omitting (expen-
sive) LM-cut heuristic input features. For instance, in Trian-
gle Tire World, ASNet (inadm.) took 2.4x as much time as
ASNet (no LM) to solve problems of size 15, and 4.3x as
much time to solve problems of size 20, despite executing
policies of near-identical average cost. Notice that this dif-
ference cannot be seen in Figure 2 because the training time
(TR) is much larger than the time to solve a test instance.

Interestingly, ASNet (no LM) was able to obtain 100%
coverage on the Probabilistic Blocks World problems in
Figure 2, despite not receiving landmark inputs. To gain
stronger assurance that it had learnt a robust policy, we tested
on 10 more instances with 10, 15, 20, 25, 30 and 35 blocks
(60 more instances total). ASNet (no LM) could not solve all
the additional test instances. In contrast, ASNet (inadm.)—
which was given landmarks as input—reliably solved all test
problems in the extended set, thus showing that heuristic in-
puts are necessary to express essential recursive properties
like whether a block is in its goal position.

Heuristic inputs also appear to be necessary in CosaNos-
tra, where ASNet (no LM) could not achieve full coverage
on the test set. We suspect that this is because an ASNet
without heuristic inputs cannot determine which direction
leads to the pizza shop and which direction leads to the cus-
tomer when it is in the middle of a long chain of toll booths.
How do suboptimal training policies affect ASNet?
Our results suggest that use of a suboptimal policies is suf-
ﬁcient to train ASNet, as demonstrated in all three domains.
Intuitively, the use of suboptimal policies for training ought
to be beneﬁcial because the time that would have been spent
computing an optimal policy can instead be used for more
epochs of exploration and supervised learning. This is some-
what evident in CosaNostra—where a suboptimal training
policy allows for slightly faster convergence—but it is more
clear in Probabilistic Blocks World, where the ASNet can
only converge within our chosen time limit with the inad-
missible policy. While training on fewer problems allowed
the network to converge within the time limit, it did not yield
as robust a policy, suggesting that the use of a suboptimal
teacher is sometimes a necessity.

Is ASNet performing ﬁxed-depth lookahead search?
No. This can be seen by comparing SSiPP and ASNet.
SSiPP solves ﬁxed-depth sub-problems (a generalization of
lookahead for SSPs) and is unable to scale up as well as AS-
Nets when using an equivalent depth parametrisation. Trian-
gle Tire World is particularly interesting because SSiPP can
outperform other baselines by quickly ﬁnding dead ends and
avoiding them. However, unlike an ASNet, SSiPP is unable
to generalize the solution of one sub-problem to the next and
needs to solve all of them from scratch.

6 Related work
Generalised policies are a topic of interest in planning (Zim-
merman and Kambhampati 2003; Jim´enez et al. 2012; Hu
and De Giacomo 2011). The earliest work in this area ex-
pressed policies as decision lists (Khardon 1999), but these
were insufﬁciently expressive to directly capture recursive
properties, and thus required user-deﬁned support predi-
cates. Later planners partially lifted this restriction by ex-
pressing learnt rules with concept language or taxonomic
syntax, which can capture such properties directly (Mar-
tin and Geffner 2000; Yoon, Fern, and Givan 2002; Yoon,
Fern, and Givan 2004). Other work employed features from
domain-independent heuristics to capture recursive prop-
erties (de la Rosa et al. 2011; Yoon, Fern, and Givan
2006), just as we do with LM-cut landmarks. Srivastava et
al. (2011) have also proposed a substantially different gen-
eralised planning strategy that provides strong guarantees
on plan termination and goal attainment, albeit only for a
restricted class of deterministic problems. Unlike the de-
cision lists (Yoon, Fern, and Givan 2002; Yoon, Fern, and
Givan 2004) and relational decision trees (de la Rosa et al.
2011) employed in past work, our model’s input features are
ﬁxed before training, so we do not fall prey to the rule util-
ity problem (Zimmerman and Kambhampati 2003). Further,
our model can be trained to minimise any differentiable loss,
and could be modiﬁed to use policy gradient reinforcement
learning without changing the model. While our approach

cannot give the same theoretical guarantees as Srivastava et
al., we are able to handle a more general class of problems
with less domain-speciﬁc information.

Neural networks have been used to learn policies for prob-
abilistic planning problems. The Factored Policy Gradient
(FPG) planner trains a multi-layer perceptron with reinforce-
ment learning to solve a factored MDP (Buffet and Aberdeen
2009), but it cannot generalise across problems and must
thus be trained anew on each evaluation problem. Concur-
rent with this work, Groshev et al. (2017) propose generalis-
ing “reactive” policies and heuristics by applying a CNN to
a 2D visual representation of the problem, and demonstrate
an effective learnt heuristic for Sokoban. However, their ap-
proach requires the user to deﬁne an appropriate visual en-
coding of states, whereas ASNets are able to work directly
from a PPDDL description.

The integration of planning and neural networks has also
been investigated in the context of deep reinforcement learn-
ing. For instance, Value Iteration Networks (Tamar et al.
2016; Niu et al. 2017) (VINs) learn to formulate and solve
a probabilistic planning problem within a larger deep neu-
ral network. A VIN’s internal model can allow it to learn
more robust policies than would be possible with ordinary
feedforward neural networks. In contrast to VINs, ASNets
are intended to learn reactive policies for known planning
problems, and operate on factored problem representations
instead of (exponentially larger) explicit representations like
those used by VINs.

In a similar vein, Kansky et al. present a model-based RL
technique known as schema networks (Kansky et al. 2017).
A schema network can learn a transition model for an en-
vironment which has been decomposed into entities, but
where those entities’ interactions are initially unknown. The
entity–relation structure of schema networks is reminiscent
of the action–proposition structure of an ASNet; however,
the relations between ASNet modules are obtained through
grounding, whereas schema networks learn which entities
are related from scratch. As with VINs, schema networks
tend to yield agents which generalise well across a class of
similar environments. However, unlike VINs and ASNets—
which both learn policies directly—schema networks only
learn a model of an environment, and planning on that model
must be performed separately.

Extension of convolutional networks to other graph struc-
tures has received signiﬁcant attention recently, as such net-
works often have helpful invariances (e.g. invariance to the
order in which nodes and edges are given to the network) and
fewer parameters to learn than fully connected networks.
Applications include reasoning about spatio-temporal rela-
tionships between variable numbers of entities (Jain et al.
2016), molecular ﬁngerprinting (Kearnes et al. 2016), visual
question answering (Teney, Liu, and Hengel 2017), and rea-
soning about knowledge graphs (Kipf and Welling 2017).
To the best of our knowledge, this paper is the ﬁrst such
technique that successfully solves factored representations
of automated planning problems.

7 Conclusion
We have introduced the ASNet, a neural network architec-
ture which is able to learn generalised policies for proba-
bilistic planning problems. In much the same way that CNNs
can generalise to images of arbitrary size by performing only
repeated local operations, an ASNet can generalise to dif-
ferent problems from the same domain by performing only
convolution-like operations on representations of actions or
propositions which are related to one another. In problems
where some propositions are only related by long chains of
actions, ASNet’s modelling capacity is limited by its depth,
but it is possible to avoid this limitation by supplying the
network with heuristic input features, thereby allowing the
network to solve a range of problems.

While we have only considered supervised learning of
generalised policies, the ASNet architecture could in princi-
ple be used to learn heuristics or embeddings, or be trained
with reinforcement learning. ASNet only requires a model
of which actions affect which portion of a state, so it could
also be used in other settings beyond SSPs, such as MDPs
with Imprecise Probabilities (MDPIPs) (White III and El-
deib 1994) and MDPs with Set-Valued Transitions (MDP-
STs) (Trevizan, Cozman, and Barros 2007). We hope that
future work will be able to explore these alternatives and
use ASNets to further enrich planning with the capabilities
of deep learning.

References
[Bertsekas and Tsitsiklis 1996] Bertsekas, D., and Tsitsiklis, J. N.

1996. Neuro-Dynamic Programming. Athena Scientiﬁc.

[Blum and Furst 1997] Blum, A. L., and Furst, M. L. 1997. Fast

planning through planning graph analysis. AIJ.

[Bonet and Geffner 2003] Bonet, B., and Geffner, H. 2003. Labeled
RTDP: improving the convergence of real-time dynamic program-
ming. In AAAI.

[Buffet and Aberdeen 2009] Buffet, O., and Aberdeen, D. 2009.

The factored policy-gradient planner. AIJ.

[Clevert, Unterthiner, and Hochreiter 2016] Clevert, D.-A.; Un-
terthiner, T.; and Hochreiter, S. 2016. Fast and accurate deep
network learning by exponential linear units (ELUs). ICLR.

[de la Rosa et al. 2011] de la Rosa, T.; Jim´enez, S.; Fuentetaja, R.;
and Borrajo, D. 2011. Scaling up heuristic planning with relational
decision trees. JAIR.

[de la Rosa, Celorrio, and Borrajo 2008] de la Rosa, T.; Celorrio,
S. J.; and Borrajo, D. 2008. Learning relational decision trees
for guiding heuristic planning. In ICAPS.

[Groshev et al. 2017] Groshev, E.; Tamar, A.; Srivastava, S.; and
Abbeel, P. 2017. Learning generalized reactive policies using deep
neural networks. arXiv:1708.07280.

[Hansen and Zilberstein 2001] Hansen, E. A., and Zilberstein, S.
2001. LAO: A heuristic search algorithm that ﬁnds solutions with
loops. Artiﬁcial Intelligence.

[Helmert and Domshlak 2009] Helmert, M., and Domshlak, C.
2009. Landmarks, critical paths and abstractions: what’s the dif-
ference anyway? In ICAPS.

[Jain et al. 2016] Jain, A.; Zamir, A. R.; Savarese, S.; and Saxena,
2016. Structural-RNN: Deep learning on spatio-temporal

A.
graphs. In CVPR.

[Jim´enez et al. 2012] Jim´enez, S.; de la Rosa, T.; Fern´andez, S.;
Fern´andez, F.; and Borrajo, D. 2012. A review of machine learning
for automated planning. Knowl. Eng. Rev.

[Kansky et al. 2017] Kansky, K.; Silver, T.; M´ely, D. A.; Eldawy,
M.; L´azaro-Gredilla, M.; Lou, X.; Dorfman, N.; Sidor, S.; Phoenix,
S.; and George, D. 2017. Schema networks: Zero-shot transfer with
a generative causal model of intuitive physics. In ICML.

[Kearnes et al. 2016] Kearnes, S.; McCloskey, K.; Berndl, M.;
Pande, V.; and Riley, P. 2016. Molecular graph convolutions:
moving beyond ﬁngerprints. Journal of Computer-Aided Molec-
ular Design.

[Khardon 1999] Khardon, R. 1999. Learning action strategies for

planning domains. AIJ.

[Kingma and Ba 2015] Kingma, D., and Ba, J. 2015. Adam: A

method for stochastic optimization. In ICLR.

[Kipf and Welling 2017] Kipf, T. N., and Welling, M. 2017. Semi-
In

supervised classiﬁcation with graph convolutional networks.
ICLR.

[Krizhevsky, Sutskever, and Hinton 2012] Krizhevsky,

Sutskever, I.; and Hinton, G. E.
tion with deep convolutional neural networks. In NIPS.

2012.

A.;
Imagenet classiﬁca-

[Little and Thi´ebaux 2007] Little, I., and Thi´ebaux, S. 2007. Prob-

abilistic planning vs. replanning. In ICAPS workshops.
[Martin and Geffner 2000] Martin, M., and Geffner, H.

2000.
Learning generalized policies in planning using concept languages.
In KRR.

[Mausam and Kolobov 2012] Mausam, and Kolobov, A.

2012.

Planning with Markov Decision Processes. Morgan & Claypool.
[Mnih et al. 2013] Mnih, V.; Kavukcuoglu, K.; Silver, D.; Graves,
A.; Antonoglou, I.; Wierstra, D.; and Riedmiller, M. 2013. Playing
Atari with deep reinforcement learning. In NIPS workshops.

[Niu et al. 2017] Niu, S.; Chen, S.; Guo, H.; Targonski, C.; Smith,
M. C.; and Kovaˇcevi´c, J. 2017. Generalized value iteration net-
works: Life beyond lattices. arXiv:1706.02416.

[Slaney and Thi´ebaux 2001] Slaney, J., and Thi´ebaux, S.

2001.

Blocks world revisited. AIJ.

[Srivastava et al. 2011] Srivastava, S.; Immerman, N.; Zilberstein,
S.; and Zhang, T. 2011. Directed search for generalized plans
using classical planners. In ICAPS.

[Tamar et al. 2016] Tamar, A.; Wu, Y.; Thomas, G.; Levine, S.; and

Abbeel, P. 2016. Value iteration networks. In NIPS.

[Teichteil-K¨onigsbuch, Vidal, and Infantes 2011] Teichteil-

K¨onigsbuch, F.; Vidal, V.; and Infantes, G.
2011. Extending
Classical Planning Heuristics to Probabilistic Planning with
Dead-Ends. In AAAI.

[Teney, Liu, and Hengel 2017] Teney, D.; Liu, L.; and Hengel, A.
v. d. 2017. Graph-structured representations for visual question
answering. In CVPR.

[Trevizan and Veloso 2014] Trevizan, F., and Veloso, M.

2014.
Depth-based Short-sighted Stochastic Shortest Path Problems. Ar-
tiﬁcial Intelligence.

[Trevizan, Cozman, and Barros 2007] Trevizan, F.; Cozman, F. G.;
and Barros, L. N. 2007. Planning under risk and knightian uncer-
tainty. In IJCAI.

[Hu and De Giacomo 2011] Hu, Y., and De Giacomo, G. 2011.
Generalized planning: Synthesizing plans that work for multiple
environments. In IJCAI.

[Vallati et al. 2015] Vallati, M.; Chrpa, L.; Grze´s, M.; McCluskey,
T. L.; Roberts, M.; Sanner, S.; et al. 2015. The 2014 International
Planning Competition: Progress and trends. AI Mag.

B Coverage and cost for probabilistic

experiments

To complement the time ﬁgures and basic overview of cov-
erage given in the main paper, Table 2, Table 3, Table 4 and
show coverage and solution cost for the evaluated proba-
bilistic problems.

[White III and Eldeib 1994] White III, C. C., and Eldeib, H. K.
1994. Markov decision processes with imprecise transition proba-
bilities. Operations Research 42(4):739–749.

[Yoon, Fern, and Givan 2002] Yoon, S.; Fern, A.; and Givan, R.

2002. Inductive policy selection for ﬁrst-order MDPs. In UAI.

[Yoon, Fern, and Givan 2004] Yoon, S.; Fern, A.; and Givan, R.
2004. Learning reactive policies for probabilistic planning do-
mains. In IPC Probabilistic Track.

[Yoon, Fern, and Givan 2006] Yoon, S. W.; Fern, A.; and Givan, R.
2006. Learning heuristic functions from relaxed plans. In ICAPS.

[Yoon, Fern, and Givan 2007] Yoon, S. W.; Fern, A.; and Givan, R.
2007. Using learned policies in heuristic-search planning. In IJ-
CAI.

[Younes and Littman 2004] Younes, H. L., and Littman, M. L.
2004. PPDDL1.0: an extension to PDDL for expressing planning
domains with probabilistic effects.

[Zimmerman and Kambhampati 2003] Zimmerman, T., and Kamb-
hampati, S. 2003. Learning-assisted automated planning: looking
back, taking stock, going forward. AI Mag.

A Supplementary material

A.1 Monster experiments

To illustrate when LM-cut ﬂags are not sufﬁcient, we created
a simple domain called Monster, in which the agent must
choose between two n-step paths to reach the goal. This do-
main domain uses the same at(ι) predicate and move(ι1, ι2)
operators from the running logistics example in the main
paper. However, at the beginning of each episode, a mon-
ster is randomly placed at the ﬁnal location along one of the
two paths, and it has a 99% chance of attacking the agent if
the agent moves to the its location. Since there is still a 1%
chance of not attacking the agent, an all-outcome determini-
sation cannot indicate which path has the monster on it, and
so the agent must look ahead at least n steps to be safe. Oth-
erwise, if the agent chooses at random, there is a 50% chance
that they will choose the wrong path, and subsequently hit a
dead end with high probability.

We perform an experiment on this domain in which we
train ASNets with increasing depth on problems with paths
from length 1-5. We then test on those same problems to
determine what the agent was able to learn. Table 1 shows
the full results. As expected, the only runs with full coverage
are those where the ASNet has sufﬁcient depth to see the
monster; all others force the ASNet to choose arbitrarily.

Proposition
layers
1
2
3
4

1
30/30
30/30
30/30
30/30

Path length
3
14/30
14/30
30/30
30/30

4
14/30
14/30
14/30
30/30

2
14/30
30/30
30/30
30/30

5
14/30
14/30
14/30
14/30

Table 1: Coverage (out of 30) for Monster problem with dif-
ferent layer counts.

d
d
a
h

0
3
/
0
3

0
3
/
0
3

t
u
c
-

M
L

0
3
/
0
3

0
3
/
0
3

)
0
8
.
0
±
3
3
.
3
2
(

)
6
7
.
0
±
3
2
.
3
2
(

)
6
7
.
0
±
0
1
.
4
2
(

)
1
7
.
0
±
3
8
.
3
2
(

)
9
6
.
0
±
7
1
.
3
2
(

)
9
6
.
0
±
7
1
.
3
2
(

)
6
6
.
0
±
7
3
.
3
2
(

)
6
6
.
0
±
7
3
.
3
2
(

)
6
6
.
0
±
7
3
.
3
2
(

P
P
i
S
S

P
D
T
R
L

O
A
L
I

d
d
a
h

0
3
/
0
3

t
u
c
-

M
L

0
3
/
0
3

M
L
o
n

,

d
d
a
h

t
u
c
-

M
L

0
3
/
0
3

)
9
7
.
0
±
3
8
.
9
2
(

)
5
8
.
0
±
3
4
.
9
2
(

)
3
6
.
0
±
3
2
.
0
3
(

)
5
7
.
0
±
7
2
.
9
2
(

)
1
8
.
0
±
7
8
.
8
2
(

)
1
8
.
0
±
7
8
.
8
2
(

)
1
8
.
0
±
7
8
.
8
2
(

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
6
2

0
3
/
1

)
0
0
.
1
7
(

-

-

-

-

-

-

-

-

-

-

-

t
u
c
-

M
L

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
7

0
3
/
1

)
0
0
.
0
6
(

0
3
/
1

)
0
0
.
4
5
(

-

-

-

-

-

-

-

-

-

-

)
7
8
.
0
±
0
9
.
6
3
(

)
6
9
.
0
±
0
7
.
5
3
(

)
5
0
.
1
±
3
3
.
4
4
(

)
6
8
.
0
±
3
4
.
1
4
(

)
5
0
.
1
±
7
7
.
0
5
(

)
6
6
.
3
±
0
0
.
8
4
(

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

t
e
N
S
A

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

)
4
9
.
0
±
7
8
.
4
3
(

)
4
9
.
0
±
7
8
.
4
3
(

)
4
9
.
0
±
7
8
.
4
3
(

)
1
9
.
0
±
7
7
.
0
4
(

)
1
9
.
0
±
7
7
.
0
4
(

)
1
9
.
0
±
7
7
.
0
4
(

)
2
1
.
1
±
3
8
.
6
4
(

)
2
1
.
1
±
3
8
.
6
4
(

)
2
1
.
1
±
3
8
.
6
4
(

)
1
1
.
1
±
0
0
.
9
5
(

)
1
1
.
1
±
0
0
.
9
5
(

)
1
1
.
1
±
0
0
.
9
5
(

)
7
2
.
1
±
3
9
.
2
5
(

)
7
2
.
1
±
3
9
.
2
5
(

)
7
2
.
1
±
3
9
.
2
5
(

)
8
0
.
1
±
7
7
.
4
6
(

)
8
0
.
1
±
7
7
.
4
6
(

)
8
0
.
1
±
7
7
.
4
6
(

)
1
2
.
1
±
7
0
.
1
7
(

)
1
2
.
1
±
7
0
.
1
7
(

)
1
2
.
1
±
7
0
.
1
7
(

)
1
2
.
1
±
0
9
.
6
7
(

)
1
2
.
1
±
0
9
.
6
7
(

)
1
2
.
1
±
0
9
.
6
7
(

)
5
3
.
1
±
0
8
.
2
8
(

)
5
3
.
1
±
0
8
.
2
8
(

)
5
3
.
1
±
0
8
.
2
8
(

)
7
3
.
1
±
7
6
.
8
8
(

)
7
3
.
1
±
7
6
.
8
8
(

)
7
3
.
1
±
7
6
.
8
8
(

)
9
2
.
1
±
3
8
.
4
9
(

)
9
2
.
1
±
3
8
.
4
9
(

)
9
2
.
1
±
3
8
.
4
9
(

)
1
2
.
1
±
0
8
.
0
0
1
(

)
1
2
.
1
±
0
8
.
0
0
1
(

)
1
2
.
1
±
0
8
.
0
0
1
(

)
4
4
.
1
±
0
5
.
6
0
1
(

)
4
4
.
1
±
0
5
.
6
0
1
(

)
4
4
.
1
±
0
5
.
6
0
1
(

)
6
5
.
1
±
0
5
.
2
1
1
(

)
6
5
.
1
±
0
5
.
2
1
1
(

)
6
5
.
1
±
0
5
.
2
1
1
(

)
8
4
.
1
±
3
4
.
8
1
1
(

)
8
4
.
1
±
3
4
.
8
1
1
(

)
8
4
.
1
±
3
4
.
8
1
1
(

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

4
-
e
r
i
t
-
e
l
g
n
a
i
r
t

5
-
e
r
i
t
-
e
l
g
n
a
i
r
t

6
-
e
r
i
t
-
e
l
g
n
a
i
r
t

7
-
e
r
i
t
-
e
l
g
n
a
i
r
t

8
-
e
r
i
t
-
e
l
g
n
a
i
r
t

m
e
l
b
o
r
P

0
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

9
-
e
r
i
t
-
e
l
g
n
a
i
r
t

1
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

2
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

3
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

4
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

5
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

6
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

7
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

8
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

9
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

0
2
-
e
r
i
t
-
e
l
g
n
a
i
r
t

n
e
v
i
g
s
i

t
s
o
c

r
o
f

I

C
%
5
9
d
n
a

l
a
o
g
e
h
t
h
c
a
e
r
o
t

t
s
o
c
n
a
e

M

.
s
r
e
n
n
a
l
p
d
n
a

s

m
e
l
b
o
r
p
f
o
n
o
i
t
c
e
l
e
s

a

r
o
f

)
l
a
o
g
e
h
t
h
c
a
e
r
o
t

s
l
a
i
r
t

l
u
f
s
s
e
c
c
u
s

f
o
r
e
b
m
u
n
(

e
g
a
r
e
v
o
C

:
2
e
l
b
a
T

.
s
t
e
k
c
a
r
b
n
i

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
7
1

0
3
/
7
2

0
3
/
5
1

0
3
/
2

-

-

-

-

-

t
u
c
-

M
L

0
3
/
3

0
3
/
0
3

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
8
2

0
3
/
0
3

0
3
/
9
2

0
3
/
7
2

0
3
/
1
2

0
3
/
6
1

)
5
9
.
2
8
±
8
3
.
8
1
4
(

)
3
9
.
3
8
±
1
3
.
3
7
3
(

0
3
/
1

)
0
0
.
6
6
3
(

0
3
/
3

0
3
/
6

)
6
7
.
9
9
1
±
7
6
.
3
8
2
(

)
0
8
.
7
3
1
±
3
3
.
7
8
2
(

t
u
c
-

M
L

0
3
/
0
3

0
3
/
3
1

0
3
/
0
3

0
3
/
0
3

0
3
/
4
1

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

-

-

-

-

-

-

-

-

-

)
8
5
.
1
±
3
5
.
5
2
(

)
3
7
.
0
8
±
7
7
.
4
8
1
(

)
1
8
.
1
±
0
0
.
7
2
(

)
9
7
.
3
±
7
6
.
4
2
(

)
3
8
.
1
±
3
8
.
6
2
(

)
5
7
.
1
±
3
0
.
7
2
(

)
0
6
.
1
±
7
3
.
6
2
(

)
0
6
.
1
±
7
3
.
6
2
(

)
1
9
.
1
±
7
8
.
2
3
(

)
7
4
.
7
4
1
±
8
0
.
0
8
4
(

)
0
7
.
1
±
7
1
.
3
3
(

)
1
8
.
1
±
0
8
.
8
1
(

)
1
0
.
2
±
7
6
.
2
3
(

)
1
2
.
2
±
3
4
.
1
3
(

)
9
7
.
1
±
7
5
.
2
3
(

)
9
7
.
1
±
7
5
.
2
3
(

)
2
7
.
1
±
3
3
.
0
2
(

)
1
1
.
9
±
3
5
.
7
2
(

)
5
6
.
1
±
7
4
.
0
2
(

)
1
0
.
2
±
7
6
.
1
2
(

)
8
7
.
1
±
3
0
.
1
2
(

)
9
9
.
1
±
7
2
.
9
1
(

)
9
9
.
1
±
7
2
.
9
1
(

)
7
5
.
1
±
3
0
.
5
2
(

)
6
7
.
4
2
±
7
4
.
8
7
(

)
3
2
.
1
±
3
0
.
4
2
(

)
1
7
.
1
±
7
8
.
6
2
(

)
0
9
.
1
±
0
5
.
5
2
(

)
7
9
.
1
±
0
6
.
4
2
(

)
7
9
.
1
±
0
6
.
4
2
(

)
9
7
.
1
±
7
2
.
5
3
(

)
2
1
.
3
7
1
±
0
5
.
4
8
4
(

)
4
6
.
1
±
7
2
.
4
3
(

)
6
9
.
1
±
7
3
.
6
3
(

)
1
0
.
2
±
7
8
.
3
3
(

)
1
0
.
2
±
7
8
.
3
3
(

)
1
7
.
1
±
0
6
.
8
2
(

)
1
5
.
3
3
±
0
2
.
7
2
1
(

)
7
7
.
1
±
3
1
.
8
2
(

)
1
0
.
2
±
0
9
.
9
2
(

)
7
1
.
2
±
3
7
.
8
2
(

)
6
9
.
1
±
3
2
.
8
2
(

)
7
4
.
1
±
7
2
.
1
5
(

)
2
1
.
0
1
±
3
2
.
4
9
(

)
2
9
.
1
±
0
1
.
0
5
(

)
3
8
.
2
±
7
8
.
8
4
(

)
5
3
.
2
±
3
2
.
9
4
(

)
2
5
.
2
±
7
7
.
6
4
(

)
0
0
.
2
±
0
6
.
8
5
(

)
5
5
.
3
3
±
0
0
.
5
8
1
(

)
9
4
.
2
±
0
1
.
7
5
(

)
3
6
.
2
±
7
6
.
7
5
(

)
5
4
.
2
±
0
5
.
5
5
(

)
1
3
.
2
±
3
2
.
5
5
(

)
7
0
.
2
±
0
0
.
6
4
(

)
1
4
.
0
5
±
0
2
.
9
4
2
(

)
3
8
.
1
±
3
1
.
5
4
(

)
9
4
.
2
±
0
4
.
6
4
(

)
3
3
.
2
±
0
5
.
8
4
(

)
0
6
.
2
±
3
5
.
6
4
(

)
7
8
.
2
±
0
0
.
0
7
(

)
6
1
.
3
±
3
5
.
3
8
(

)
9
2
.
3
±
0
2
.
8
7
(

)
6
3
.
3
±
0
7
.
0
7
(

)
4
5
.
2
±
3
6
.
9
6
(

)
1
5
.
2
±
3
3
.
0
7
(

)
9
3
.
2
±
3
9
.
5
6
(

)
3
7
.
2
±
0
1
.
9
7
(

)
7
1
.
2
±
7
8
.
3
7
(

)
1
1
.
2
±
7
7
.
6
7
(

)
1
1
.
2
±
7
7
.
6
7
(

)
4
4
.
3
±
7
2
.
6
7
(

)
2
8
.
2
±
0
6
.
4
7
(

)
0
6
.
2
±
0
3
.
7
7
(

)
1
8
.
2
±
3
5
.
9
6
(

)
6
4
.
1
9
±
6
9
.
3
2
3
(

)
0
6
.
4
±
4
9
.
0
0
1
(

)
9
8
.
2
±
7
4
.
9
9
(

)
9
9
.
2
±
7
2
.
8
9
(

)
9
9
.
7
2
±
3
6
.
5
4
1
(

)
6
1
.
3
±
8
7
.
0
0
1
(

)
4
6
.
2
±
7
7
.
1
9
(

)
7
4
.
2
±
0
5
.
1
9
(

)
1
3
.
5
3
±
1
4
.
3
6
1
(

)
9
9
.
5
±
3
7
.
5
9
(

)
0
0
.
2
±
0
9
.
5
8
(

)
9
5
.
2
±
0
7
.
9
8
(

)
1
3
.
3
6
±
7
3
.
0
4
3
(

)
7
4
.
4
4
±
0
5
.
7
0
1
(

)
7
7
.
2
±
3
2
.
7
1
1
(

)
1
0
.
3
±
3
4
.
6
1
1
(

t
u
c
-

M
L

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

)
6
5
.
3
±
7
2
.
3
1
1
(

)
6
3
.
3
±
0
2
.
1
1
1
(

)
8
8
.
2
±
0
0
.
9
1
1
(

)
3
3
.
3
±
0
3
.
7
1
1
(

)
4
0
.
3
±
7
8
.
8
3
1
(

)
7
3
.
3
±
0
8
.
8
3
1
(

)
1
4
.
3
±
0
7
.
7
3
1
(

)
2
1
.
3
±
0
0
.
7
3
1
(

)
2
6
.
3
±
3
3
.
9
3
1
(

)
1
3
.
3
±
7
2
.
9
3
1
(

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

-

-

-

-

-

-

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

.

n
i
a
m
o
d
d
l
r
o
W

s
k
c
o
l
B
c
i
t
s
i
l
i
b
a
b
o
r
P
e
h
t

r
o
f

d
e
t
a
e
p
e
r

2
e
l
b
a
T

:
3

e
l
b
a
T

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

1
s
-
9
n
-
w
b
-
b
o
r
p

2
s
-
9
n
-
w
b
-
b
o
r
p

3
s
-
9
n
-
w
b
-
b
o
r
p

1
s
-
0
1
n
-
w
b
-
b
o
r
p

2
s
-
0
1
n
-
w
b
-
b
o
r
p

3
s
-
0
1
n
-
w
b
-
b
o
r
p

1
s
-
5
1
n
-
w
b
-
b
o
r
p

2
s
-
5
1
n
-
w
b
-
b
o
r
p

3
s
-
5
1
n
-
w
b
-
b
o
r
p

1
s
-
0
2
n
-
w
b
-
b
o
r
p

2
s
-
0
2
n
-
w
b
-
b
o
r
p

3
s
-
0
2
n
-
w
b
-
b
o
r
p

1
s
-
5
2
n
-
w
b
-
b
o
r
p

2
s
-
5
2
n
-
w
b
-
b
o
r
p

3
s
-
5
2
n
-
w
b
-
b
o
r
p

1
s
-
0
3
n
-
w
b
-
b
o
r
p

2
s
-
0
3
n
-
w
b
-
b
o
r
p

3
s
-
0
3
n
-
w
b
-
b
o
r
p

1
s
-
5
3
n
-
w
b
-
b
o
r
p

2
s
-
5
3
n
-
w
b
-
b
o
r
p

3
s
-
5
3
n
-
w
b
-
b
o
r
p

P
P
i
S
S

P
D
T
R
L

O
A
L
I

t
e
N
S
A

M
L
o
n

,

d
d
a
h

t
u
c
-

M
L

m
e
l
b
o
r
P

P
P
i
S
S

P
D
T
R
L

O
A
L
I

M
L
o
n

,

d
d
a
h

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

t
u
c
-

M
L

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

-

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

t
u
c
-

M
L

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

-

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

)
0
±
0
0
.
6
4
(

)
0
±
0
0
.
9
4
(

t
u
c
-

M
L

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
3
4
(

)
0
±
0
0
.
3
4
(

)
0
±
0
0
.
3
4
(

)
0
±
0
0
.
3
4
(

)
0
±
0
0
.
3
4
(

)
0
±
0
0
.
3
4
(

-

-

-

-

-

-

-

)
0
±
0
0
.
6
4
(

)
0
±
0
0
.
6
4
(

)
0
±
0
0
.
9
4
(

)
0
±
0
0
.
9
4
(

)
0
±
0
0
.
4
6
(

)
0
±
0
0
.
4
6
(

t
e
N
S
A

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

t
u
c
-

M
L

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
1
n
-
a
r
t
s
o
n
a
s
o
c

1
1
n
-
a
r
t
s
o
n
a
s
o
c

2
1
n
-
a
r
t
s
o
n
a
s
o
c

3
1
n
-
a
r
t
s
o
n
a
s
o
c

4
1
n
-
a
r
t
s
o
n
a
s
o
c

5
1
n
-
a
r
t
s
o
n
a
s
o
c

0
2
n
-
a
r
t
s
o
n
a
s
o
c

m
e
l
b
o
r
P

.

n
i
a
m
o
d

a
z
z
i

P
a
r
t
s
o
N
a
s
o
C
e
h
t

r
o
f

d
e
t
a
e
p
e
r

2

e
l
b
a
T

:
4

e
l
b
a
T

Action Schema Networks: Generalised Policies with Deep Learning

Sam Toyer1, Felipe Trevizan1,2, Sylvie Thi´ebaux1 and Lexing Xie1,3
1 Research School of Computer Science, Australian National University 2 Data61, CSIRO 3 Data to Decisions CRC
first.last@anu.edu.au

7
1
0
2
 
c
e
D
 
2
2
 
 
]
I

A
.
s
c
[
 
 
2
v
1
7
2
4
0
.
9
0
7
1
:
v
i
X
r
a

Abstract

In this paper, we introduce the Action Schema Network (AS-
Net): a neural network architecture for learning generalised
policies for probabilistic planning problems. By mimicking
the relational structure of planning problems, ASNets are able
to adopt a weight sharing scheme which allows the network
to be applied to any problem from a given planning domain.
This allows the cost of training the network to be amortised
over all problems in that domain. Further, we propose a train-
ing method which balances exploration and supervised train-
ing on small problems to produce a policy which remains
robust when evaluated on larger problems. In experiments,
we show that ASNet’s learning capability allows it to signiﬁ-
cantly outperform traditional non-learning planners in several
challenging domains.

1

Introduction

Automated planning is the task of ﬁnding a sequence of ac-
tions which will achieve a goal within a user-supplied model
of an environment. Over the past four decades, there has
been a wealth of research into the use of machine learn-
ing for automated planning (Jim´enez et al. 2012), motivated
in part by the belief that these two essential ingredients of
intelligence—planning and learning—ought to strengthen
one other (Zimmerman and Kambhampati 2003). Neverthe-
less, the dominant paradigm among state-of-the-art classi-
cal and probabilistic planners is still based on heuristic state
space search. The domain-independent heuristics used for
this purpose are capable of exploiting common structures
in planning problems, but do not learn from experience.
Top planners in both the deterministic and learning tracks
of the International Planning Competition often use ma-
chine learning to conﬁgure portfolios (Vallati et al. 2015),
but only a small fraction of planners make meaningful use
of learning to produce domain-speciﬁc heuristics or control
knowledge (de la Rosa, Celorrio, and Borrajo 2008). Plan-
ners which transfer knowledge between problems in a do-
main have been similarly underrepresented in the probabilis-
tic track of the competition.

In parallel with developments in planning, we’ve seen a
resurgence of interest in neural nets, driven largely by their
success at problems like image recognition (Krizhevsky,

Copyright c(cid:13) 2018, Association for the Advancement of Artiﬁcial
Intelligence (www.aaai.org). All rights reserved.

Figure 1: In a CNN, successive convolutions grow the re-
ceptive ﬁeld of a neuron at higher layers; analogously for
ASNet, a neuron for a particular action a or proposition p
sees a larger portion of the current state at higher layers.

Sutskever, and Hinton 2012) and learning to play video
games (Mnih et al. 2013). This paper brings some gains of
deep learning to planning by proposing a new neural net-
work architecture, the ASNet, which is specialised to the
structure of planning problems much as Convolutional Neu-
ral Networks (CNNs) are specialised to the structure of im-
ages. The basic idea is illustrated in Figure 1: rather than
operating on a virtual graph of pixels with edges deﬁned by
adjacency relationships, an ASNet operates on a graph of
actions and propositions (i.e. Boolean variables), with edges
deﬁned by relations of the form “action a affects proposition
p” or “proposition p inﬂuences the outcome of action a”.
This structure allows an ASNet to be trained on one problem
from a given planning domain and applied to other, different
problems without re-training.

We make three new contributions. (1) A neural network
architecture for probabilistic planning that automatically
generalises to any problem from a given planning domain.
(2) A representation that allows weight sharing among ac-
tions modules belonging to the same action schema, and
among proposition modules associated with the same pred-
icate. This representation is augmented by input features

from domain-independent planning heuristics. (3) A train-
ing method that balances exploration and supervision from
existing planners. In experiments, we show that this strategy
is sufﬁcient to learn effective generalised policies. Code and
models for this work are available online. 1

2 Background
This work considers probabilistic planning problems repre-
sented as Stochastic Shortest Path problems (SSPs) (Bert-
sekas and Tsitsiklis 1996). Formally, an SSP is a tuple
(S, A, T , C, G, s0) where S is a ﬁnite set of states, A is a
ﬁnite set of actions, T : S × A × S → [0, 1] is a transition
function, C : S × A → (0, ∞) is a cost function, G ⊆ S is
a set of goal states, and s0 is an initial state. At each state s,
an agent chooses an action a from a set of enabled actions
A(s) ⊆ A, incurring a cost of C(s, a) and causing it to tran-
sition into another state s(cid:48) ∈ S with probability T (s, a, s(cid:48)).
The solution of an SSP is a policy π : A×S → [0, 1] such
that π(a | s) is the probability that action a will be applied in
state s. An optimal policy π∗ is any policy that minimises
the total expected cost of reaching G from s0. We do not as-
sume that the goal is reachable with probability 1 from s0
(i.e. we allow problems with unavoidable dead ends), and
a ﬁxed-cost penalty is incurred every time a dead end is
reached (Mausam and Kolobov 2012).

A factored SSP is a compact representation of an SSP as
a tuple (P, A, s0, s(cid:63), C). P is a ﬁnite set of binary propo-
sitions and the state space S is the set of all binary strings
of size |P|. Thus, a state s is a value assignment to all the
propositions p ∈ P. A partial state is a value assignment to
a subset of propositions; a partial state s is consistent with
a partial state s(cid:48) if the value assignments of s(cid:48) are contained
in s (s(cid:48) ⊆ s for short). The goal is represented by a partial
state s(cid:63), and G = {s ∈ S|s(cid:63) ⊆ s}. Each action a ∈ A con-
sists in a precondition pre a represented by a partial state, a
set of effects eﬀ a each represented by a partial state, and a
probability distribution Pr a over effects in eﬀ a.2 The ac-
tions applicable in state s are A(s) = {a ∈ A | pre a ⊆ s}.
Moreover, T (s, a, s(cid:48)) = (cid:80)
e∈eﬀ a|s(cid:48)=res(s,e) Pr a(e) where
res(s, e) ∈ S is the result of changing the value of proposi-
tions of s to make it consistent with effect e.

A lifted SSP compactly represents a set of factored SSPs
sharing the same structure. Formally, a lifted SSP is a tu-
ple (F, A, C) where F is a ﬁnite set of predicates, and
A is a ﬁnite set of action schemas. Each predicate, when
grounded, i.e., instantiated by a tuple of names representing
objects, yields a factored SSP proposition. Similarly, each
action schema, instantiated by a tuple of names, yields a fac-
tored SSP action. The Probabilistic Planning Domain Deﬁ-
nition Language (PPDDL) is the standard language to de-
scribe lifted and factored SSPs (Younes and Littman 2004).
PPDDL splits the description into a general domain and a
speciﬁc problem. The domain gives the predicates F, action

1https://github.com/qxcv/asnets
2 Factored SSPs sometimes support conditional effects and neg-
ative or disjunctive preconditions and goals. We do not use these
here to simplify notation. However, ASNet can easily be extended
to support these constructs.

schemas A and cost function C specifying a lifted SSP. The
problem additionally gives the set of objects O, initial state
s0 and goal s(cid:63), describing a speciﬁc SSP whose propositions
and actions are obtained by grounding the domain predicates
and action schemas using the objects in O. For instance the
domain description might specify a predicate at(?l) and an
action schema walk(?from, ?to), while the problem descrip-
tion might specify objects home and work. Grounding us-
ing these objects would produce propositions at(home) and
at(work), as well as ground actions walk(work, home) and
walk(home, work).

Observe that different factored SSPs can be obtained by
changing only the problem part of the PPDDL description
while reusing its domain. In the next section, we show how
to take advantage of action schema reuse to learn policies
that can then be applied to any factored SSP obtained by
instantiating the same domain.

3 Action Schema Networks
Neural networks are expensive to train, so we would like to
amortise that cost over many problems by learning a gener-
alised policy which can be applied to any problem from a
given domain. ASNet proposes a novel, domain-specialised
structure that uses the same set of learnt weights θ regard-
less of the “shape” of the problem. The use of such a weight
sharing scheme is key to ASNet’s ability to generalise to
different problems drawn from the same domain, even when
those problems have different goals or different numbers of
actions and propositions.

3.1 Network structure
At a high level, an ASNet is composed of alternating action
layers and proposition layers, where action layers are com-
posed of a single action module for each ground action, and
proposition layers likewise are composed of a single propo-
sition module for each ground proposition; this choice of
structure was inspired by the alternating action and propo-
sition layers of Graphplan (Blum and Furst 1997). In the
same way that hidden units in one layer of a CNN connect
only to nearby hidden units in the next layer, action modules
in one layer of an ASNet connect only to directly related
proposition modules in the next layer, and vice versa. The
last layer of an ASNet is always an action layer with each
module deﬁning an action selection probability, thus allow-
ing the ASNet to scale to problems with different numbers of
actions. For simplicity, we also assume that the ﬁrst (input)
layer is always an action layer.

Action module details. Consider an action module for
a ∈ A in the lth action layer. The module takes as input a
feature vector ul
a, and produces a new hidden representation
a + bl

a = f (W l
φl

a · ul

a) ,

a ∈ Rdh×dl

where W l
a is a learnt weight matrix for the mod-
a ∈ Rdh is a learnt bias vector, f (·) is a nonlinearity
ule, bl
(e.g. tanh, sigmoid, or ReLU), dh is a (ﬁxed) intermediate
representation size, and dl
a is the size of the inputs to the
action module. The feature vector ul
a, which serves as in-
put to the action module, is constructed by enumerating the

propositions p1, p2, . . . , pM which are related to the action
a, and then concatenating their hidden representations. For-
mally, we say that a proposition p ∈ P is related to an action
a ∈ A, denoted R(a, p), if p appears in pre a or in an effect
e where Pr a(e) > 0. Concatenation of representations for
the related propositions produces a vector

ul
a =

(cid:104)

T

ψl−1
1

· · · ψl−1
M

T (cid:105)T

,

j

a has dimension dl

where ψl−1
is the hidden representation produced by the
proposition module for proposition pj ∈ P in the preceding
proposition layer. Each of these constituent hidden represen-
tations has dimension dh, so ul
a = dh · M .
Our notion of propositional relatedness ensures that, if
ground actions a1 and a2 in a problem are instances of the
same action schema in a PPDDL domain, then their inputs
ul
1 and ul
2 will have the same “structure”. To see why, note
that we can determine which propositions are related to a
given ground action a by retrieving the corresponding ac-
tion schema, enumerating the predicates which appear in the
precondition or the effects of the action schema, then instan-
tiating those predicates with the same parameters used to
instantiate a. If we apply this procedure to a1 and a2, we
will obtain lists of related propositions p1, p2, . . . , pM and
q1, q2, . . . , qM , respectively, where pj and qj are proposi-
tions with the same predicate which appear in the same po-
sition in the deﬁnitions of a1 and a2 (i.e. the same location
in the precondition, or the same position in an effect).

c = bl

d = bl

s and bl

c = W l

d = W l

s and bias vector bl

Such structural similarity is key to ASNet’s generalisation
abilities. At each layer l, and for each pair of ground actions
c and d instantiated from the same action schema s, we use
the same weight matrix W l
s—that is, we
have W l
s. Hence, modules
for actions which appear in the same layer and correspond to
the same action schema will use the same weights, but mod-
ules which appear in different layers or which correspond
to different schemas will learn different weights. Although
different problems instantiated from the same PPDDL do-
main may have different numbers of ground actions, those
ground actions will still be derived from the same, ﬁxed set
of schemas in the domain, so we can apply the same set of
action module weights to any problem from the domain.

The ﬁrst and last layers of an ASNet consist of action

modules, but their construction is subtly different:
1. The output of a module for action a in the ﬁnal layer is
a single number πθ(a | s) representing the probability of
selecting action a in the current state s under the learnt
policy πθ, rather than a vector-valued hidden representa-
tion. To guarantee that disabled actions are never selected,
and ensure that action probabilities are normalised to 1,
we pass these outputs through a masked softmax activa-
tion which ensures that πθ(a | s) = 0 if a /∈ A(s). During
training, we sample actions from πθ(a | s). During eval-
uation, we select the action with the highest probability.

2. Action modules in the ﬁrst layer of a ASNet are passed an
input vector composed of features derived from the cur-
rent state, rather than hidden representations for related
propositions. Speciﬁcally, modules in the ﬁrst layer are

given a binary vector indicating the truth values of related
propositions, and whether those propositions appear in the
goal. In practice, it is helpful to concatenate these propo-
sitional features with heuristic features, as described in
Section 3.2.
Proposition module details. Proposition modules only
appear in the intermediate layers of an ASNet, but are oth-
erwise similar to action modules. Speciﬁcally, a proposition
module for proposition p ∈ P in the lth proposition layer of
the network will compute a hidden representation
p = f (W l
ψl

p + bl

p · vl

p) ,

where vl
p ∈ Rdh×dl
before, and W l
and biases for the module.

p is a feature vector, f is the same nonlinearity used
p ∈ Rdh are learnt weights

p and bl

To construct the input vl

p, we ﬁrst ﬁnd the predicate
pred(p) ∈ F for proposition p ∈ P, then enumerate all
action schemas A1, . . . , AL ∈ A which reference pred(p)
in a precondition or effect. We can deﬁne a feature vector






vl
p =

pool({φl
a

T

| op(a) = A1 ∧ R(a, p)})

...




 ,

pool({φl
a

T

| op(a) = AL ∧ R(a, p)})

p of vl

where op(a) ∈ A denotes the action schema for ground ac-
tion a, and pool is a pooling function that combines several
dh-dimensional feature vectors into a single dh-dimensional
one. Hence, when all pooled vectors are concatenated, the
dimensionality dl
p becomes dh · L. In this paper, we
assume that pool performs max pooling (i.e. keeps only the
largest input). If a proposition module had to pool over the
outputs of many action modules, such pooling could po-
tentially obscure useful information. While the issue could
be overcome with a more sophisticated pooling mechanism
(like neural attention), we did not ﬁnd that max pooling
posed a major problem in the experiments in Section 5, even
on large Probabilistic Blocks World instances where some
proposition modules must pool over thousands of inputs.

Pooling operations are essential to ensure that proposi-
tion modules corresponding to the same predicate have the
same structure. Unlike action modules corresponding to the
same action schema, proposition modules corresponding to
the same predicate may have a different number of inputs
depending on the initial state and number of objects in a
problem, so it does not sufﬁce to concatenate inputs. As an
example, consider a single-vehicle logistics problem where
the location of the vehicle is tracked with propositions of
the form at(ι), and the vehicle may be moved with actions
of the form move(ιfrom, ιto). A location ι1 with one incom-
ing road and no outgoing roads will have only one related
move action, but a location ι2 with two incoming roads and
no outgoing roads will have two related move actions, one
for each road. This problem is not unique to planning: a sim-
ilar trick is employed in network architectures for graphs
where vertices can have varying in-degree (Jain et al. 2016;
Kearnes et al. 2016).

As with the action modules, we share weights between
proposition modules for propositions corresponding to the

same predicate. Speciﬁcally, at proposition layer l, and for
propositions q and r with pred(q) = pred(r), we tie the
q = W l
corresponding weights W l
r. Together
with the weight sharing scheme for action modules, this en-
ables us to learn a single set of weights

r and bl

q = bl

θ ={W l
∪{W l

a, bl
p, bl

a | 1 ≤ l ≤ n + 1, a ∈ A}
p | 1 ≤ l ≤ n, p ∈ F}

for an n-layer model which can be applied to any problem
in a given PPDDL domain.

3.2 Heuristic features for expressiveness
One limitation of the ASNet is the ﬁxed receptive ﬁeld of the
network; in other words, the longest chain of related actions
and propositions which it can reason about. For instance,
suppose we have I locations ι1, . . . , ιI arranged in a line in
our previous logistics example. The agent can move from
ιk−1 to ιk (for k = 2, . . . , I) with the move(ιk−1, ιk) action,
which makes at(ιk−1) false and at(ιk) true. The proposi-
tions at(ι1) and at(ιI ) will thus be related only by a chain
of move actions of length I −1; hence, a proposition module
in the lth proposition layer will only be affected by at propo-
sitions for locations at most l + 1 moves away. Deeper net-
works can reason about longer chains of actions, but that an
ASNet’s (ﬁxed) depth necessarily limits its reasoning power
when chains of actions can be arbitrarily long.

We compensate for this receptive ﬁeld limitation by sup-
plying the network with features obtained using domain-
independent planning heuristics. In this paper, we derive
these features from disjunctive action landmarks produced
by LM-cut (Helmert and Domshlak 2009), but features de-
rived from different heuristics could be employed in the
same way. A disjunctive action landmark is a set of actions
in which at least one action must be applied along any opti-
mal path to the goal in a deterministic, delete-relaxed version
of the planning problem. These landmarks do not necessarily
capture all useful actions, but in practice we ﬁnd that provid-
ing information about these landmarks is often sufﬁcient to
compensate for network depth limitations.

In this paper, a module for action a in the ﬁrst network

layer is given a feature vector

a = (cid:2)cT
u1

vT

gT (cid:3)T

.

c ∈ {0, 1}3 indicates whether ai is the sole action in at least
one LM-cut landmark (c1 = 1), an action in a landmark
of two or more actions (c2 = 1), or does not appear in a
landmark (c3 = 1). v ∈ {0, 1}M represents the M related
propositions: vj is 1 iff pj is currently true. g ∈ {0, 1}M
encodes related portions of the goal state, and gj is 1 iff pj
is true in the partial state s(cid:63) deﬁning the goal.

4 Training with exploration and supervision
We learn the ASNet weights θ by choosing a set of small
training problems Ptrain, then alternating between guided ex-
ploration to build up a state memory M, and supervised
learning to ensure that the network chooses good actions
for the states in M. Algorithm 1 describes a single epoch

for i = 1, . . . , Texplore do
for all ζ ∈ Ptrain do

Algorithm 1 Updating ASNet weights θ using state memory
M and training problem set Ptrain
1: procedure ASNET-TRAIN-EPOCH(θ, M)
2:
3:
4:
5:
6:
7:
8:

s0, . . . , sN ← RUN-POL(s0(ζ), πθ)
M ← M ∪ {s0, . . . , sN }
for j = 0, . . . , N do
j , . . . , s∗
s∗
M ← M ∪ {s∗

M ← POL-ENVELOPE(sj, π∗)
M }

(cid:46) Exploration

j , . . . , s∗

for i = 1, . . . , Ttrain do

(cid:46) Learning

B ← SAMPLE-MINIBATCH(M)
Update θ using dLθ(B)

(Equation 1)

dθ

9:
10:

11:

of exploration and supervised learning. We repeatedly ap-
ply this procedure until performance on Ptrain ceases to im-
prove, or until a ﬁxed time limit is reached. Note that this
strategy is only intended to learn the weights of an ASNet—
module connectivity is not learnt, but rather obtained from
a grounded representation using the notion of relatedness
which we described earlier.

In the exploration phase of each training epoch, we repeat-
edly run the ASNet policy πθ from the initial state of each
problem ζ ∈ Ptrain, collecting N + 1 states s0, . . . , sN vis-
ited along each of the sampled trajectories. Each such trajec-
tory terminates when it reaches a goal, exceeds a ﬁxed limit
L on length, or reaches a dead end. In addition, for each
visited state sj, we compute an optimal policy π∗ rooted at
sj, then produce a set of states s∗
M which constitute
π∗’s policy envelope—that is, the states which π∗ visits with
nonzero probability. Both the trajectories drawn from the
ASNet policy πθ and policy envelopes for the optimal policy
π∗ are added to the state memory M. Saving states which
can be visited under an optimal policy ensures that M al-
ways contains states along promising trajectories reachable
from s0. On the other hand, saving trajectories from the ex-
ploration policy ensures that ASNet will be able to improve
on the states which it visits most often, even if they are not
on an optimal goal trajectory.

j , . . . , s∗

In the training phase, small subsets of the states in M
are repeatedly sampled at random to produce minibatches
for training ASNet. The objective to be minimised for each
minibatch B is the cross-entropy classiﬁcation loss

Lθ(B) =

(cid:88)

(cid:88)

s∈B

a∈A

(cid:2)(1 − ys,a) · log(1 − πθ(a | s))

(1)

+ ys,a · log πθ(a | s)(cid:3) .

The label ys,a is 1 if the expected cost of choosing action a
and then following an optimal policy thereafter is minimal
among all enabled actions; otherwise, ys,a = 0. This en-
courages the network to imitate an optimal policy. For each
sampled batch B, we compute the gradient dLθ(B)
and use it
to update the weights θ in a direction which decreases Lθ(B)
with Adam (Kingma and Ba 2015).

dθ

The cost of computing an optimal policy during super-
vised learning is often non-trival. It is natural to ask whether

it is more efﬁcient to train ASNets using unguided policy
gradient reinforcement learning, as FPG does (Buffet and
Aberdeen 2009). Unfortunately, we found that policy gradi-
ent RL was too noisy and inefﬁcient to train deep networks
on nontrivial problems; in practice, the cost of computing an
optimal policy for small training problems more than pays
for itself by enabling us to use sample-efﬁcient supervised
learning instead of reinforcement learning. In the experi-
ments, we investigate the question of whether suboptimal
policies are still sufﬁcient for supervised training of ASNets.
Past work on generalised policy learning has employed
learnt policies as control knowledge for search algorithms,
in part because doing so can compensate for ﬂaws in the pol-
icy. For example, Yoon, Fern, and Givan (2007) suggest em-
ploying policy rollout or limited discrepancy search to avoid
the occasional bad action recommended by a policy. While
we could use an ASNet similarly, we are more interested in
its ability to learn a reliable policy on its own. Hence, during
evaluation, we always choose the action which maximises
πθ(a | s). As noted above, this is different from the explo-
ration process employed during training, where we instead
sample from πθ(a | s).

5 Experiments and discussion
In this section, we compare ASNet against state-of-the-art
planners on three planning domains.

5.1 Experimental setup
We compare ASNet against three heuristic-search-based
probabilistic planners: LRTDP (Bonet and Geffner 2003),
ILAO* (Hansen and Zilberstein 2001) and SSiPP (Trevizan
and Veloso 2014). Two domain-independent heuristics are
considered for each of the three planners—LM-cut (admissi-
ble) and the additive heuristic hadd (inadmissible) (Teichteil-
K¨onigsbuch, Vidal, and Infantes 2011)—resulting in 6 base-
lines. During evaluation, we enforce a 9000s time cutoff for
all the baselines and ASNets, as well as a 10Gb memory
cutoff.

Since LRTDP and ILAO* are optimal planners, we exe-
cute them until convergence ((cid:15) = 10−4) for each problem us-
ing 30 different random seeds. Notice that, for hadd, LRTDP
and ILAO* might converge to a suboptimal solution. If an
execution of LRTDP or ILAO* does not converge before the
given time/memory cutoff, we consider the planner as hav-
ing failed to reach the goal. SSiPP is used as a replanner and,
for each problem, it is trained until 60s before the time cut-
off and then evaluated; this procedure is repeated 30 times
for each problem using different random seeds. The train-
ing phase of SSiPP consists in simulating a trajectory from
s0 and, during this process, SSiPP improves its lower bound
on the optimal solution. If 100 consecutive trajectories reach
the goal during training, then SSiPP is evaluated regardless
of the training time left. For the 6 baselines, we report the
average running time per problem.

For each domain, we train a single ASNet, then evaluate
it on each problem 30 times with different random seeds.
The hyperparmeters for each ASNet were kept ﬁxed across
domains: three action layers and two proposition layers in

each network, a hidden representation size of 16 for each in-
ternal action and proposition module, and an ELU (Clevert,
Unterthiner, and Hochreiter 2016) as the nonlinearity f . The
optimiser was conﬁgured with a learning rate of 0.0005 and
a batch size of 128, and a hard limit of two hours (7200s)
was placed on training. We also applied (cid:96)2 regularisation
with a coefﬁcient of 0.001 on all weights, and dropout on
the outputs of each layer except the last with p = 0.25. Each
epoch of training alternated between 25 rounds of explo-
ration shared equally among all training problems, and 300
batches of network optimisation (i.e. Texplore = 25/|Ptrain|
and Ttrain = 300). Sampled trajectory lengths are L = 300
for both training and evaluation. LRTDP with the LM-cut
heuristic is used for computing the optimal policies during
training, with a dead-end penalty of 500. We also repeated
this procedure for LRTDP using hadd (inadmissible heuris-
tic) to compare the effects of using optimal and suboptimal
policies for training. Further, we report how well ASNet per-
forms when it is guided by hadd, but not given the LM-cut-
derived heuristic features described in Section 3.2. For the
ASNets, we report the average training time plus time to
solve the problem to highlight when it pays off to spend the
one-off cost of training an ASNet for a domain.

All ASNets were trained and evaluated on a virtual ma-
chine equipped with 62GB of memory and an x86-64 pro-
cessor clocked at 2.3GHz. For training and evaluation, each
ASNet was restricted to use a single, dedicated processor
core, but resources were otherwise shared. The baseline
planners were run in a cluster of x86-64 processors clocked
at 2.6GHz and each planner again used only a single core.

5.2 Domains
We evaluate ASNets and the baselines on the following
probabilistic planning domains:

CosaNostra Pizza: as a Deliverator for CosaNostra
Pizza, your job is to safely transport pizza from a shop to
a waiting customer, then return to the shop. There is a se-
ries of toll booths between you and the customer: at each
booth, you can either spend a time step paying the operator,
or save a step by driving through without paying. However,
if you don’t pay, the (angry) operator will try to drop a boom
on your car when you pass through their booth on the way
back to the shop, crushing the car with 50% probability. The
optimal policy is to pay operators when travelling to the cus-
tomer to ensure a safe return, but not pay on the return trip
as you will not revisit the booth. Problem size is the number
of toll booths between the shop and the customer. ASNets
are trained on sizes 1-5, and tested on sizes 6+.

Probabilistic Blocks World is an extension of the well-
known deterministic blocks world domain in which a robotic
arm has to move blocks on a table into a goal conﬁguration.
The actions to pick up a block or to put a block on top of
another fail with probability 0.25; failure causes the target
block to drop onto the table, meaning that it must be picked
up and placed again. We randomly generate three different
problems for each number of blocks considered during test-
ing. ASNet is trained on ﬁve randomly generated problems
of each size from 5–9, for 25 training problems total.

Triangle Tire World (Little and Thi´ebaux 2007): each

Figure 2: Comparison of planner running times on the evaluation domains. TR refers to the time used for training (zero for
baselines). ASNet runs with (adm.) used optimal policies for training while (inadm.) used potentially suboptimal policies, and
runs with (no LM) did not use heuristic input features. The table at right shows, for selected problems, the coverage and average
solution cost for the best ASNet and baseline. We use TTW for Triangle Tire World, CN for CosaNostra Pizza, and PBW for
Probabilistic Blocks World. In PBW, running times are averaged over the three problems of each size. In TTW and PBW, ASNet
(no LM) occludes ASNet (inadm.). ASNet (adm.) is also occluded in TTW, but is absent entirely from PBW as the optimal
planner used to generate training data could not solve all training problems in time.

problem consists of a set of locations arranged in a triangle,
with connections between adjacent locations. The objective
is to move a vehicle from one corner of the triangle to an-
other. However, each move has a 50% chance of producing
a ﬂat tire, which must be replaced at the next visited loca-
tion. The vehicle thus requires a sequence of moves between
locations where replacement tires are available. Tires are ar-
ranged such that the most reliable policy is one which travels
the longest path to the goal, along the outside edge of the tri-
angle. This task can be made more challenging by scaling up
the number of locations. Per Little and Thi´ebaux (2007), a
problem of size n has (n + 1)(2n + 1) locations. We use
sizes 1-3 for training, and test with sizes from 4 onward.

5.3 Results
Figure 2 shows the time taken to train and evaluate ASNet
using optimal (adm.) and suboptimal (inadm.) policies as
training data. In addition, it shows coverage (proportion of
runs which reached the goal) and average solution cost when
the goal is reached for selected problems for the best ASNet
and best baseline. The following is a summary of our results:
When is it worth using ASNet? All ASNets obtained 30
out of 30 coverage for all Triangle Tire World problems, and
the ASNets with heuristic input features similarly obtained
perfect coverage on CosaNostra. In contrast, the baselines
failed to scale up to the larger problems. This shows that AS-
Net is well-suited to problems where local knowledge of the
environment can help to avoid common traps, for instance:
in CosaNostra, the agent must learn to pay toll booth oper-
ators when carrying a pizza and not pay otherwise; and in
Triangle Tire World, the agent must learn to sense and fol-
low the outer edge of the triangle. Not only could ASNets
learn these tricks, but the average solution cost obtained by
ASNets for CosaNostra and Triangle Tire World was close
to that of the optimal baselines (when they converged), sug-
gesting that the optimal solution was found.

Probabilistic Blocks World is more challenging as there

is no single pattern that can solve all problems. Even for the
deterministic version of Blocks World, a generalised policy
requires the planner to learn a recursive property for whether
each block is in a goal position (Slaney and Thi´ebaux 2001).
The ASNet appears to have successfully learnt to do this
when trained by a suboptimal teacher and given landmarks
as input, and surpassed all baselines in coverage (reaching
the goal on 30/30 runs on each instance). Moreover, the av-
erage solution cost of ASNet (inadm.) is similar to the op-
timal baselines (when they converge) and up to 3.7 times
less than SSiPP (inadm.), the baseline with the best cover-
age. The ASNet (inadm.) policy typically obtained a mean
solution cost somewhere between the US and GN1 strate-
gies presented by Slaney and Thi´ebaux: it is suboptimal, but
still better than unstacking and rebuilding all towers from
scratch. Note that the ASNet could not obtain a policy within
the allotted time when trained by an optimal teacher.

Are the heuristic features necessary? In some cases,
ASNet’s performance can be improved by omitting (expen-
sive) LM-cut heuristic input features. For instance, in Trian-
gle Tire World, ASNet (inadm.) took 2.4x as much time as
ASNet (no LM) to solve problems of size 15, and 4.3x as
much time to solve problems of size 20, despite executing
policies of near-identical average cost. Notice that this dif-
ference cannot be seen in Figure 2 because the training time
(TR) is much larger than the time to solve a test instance.

Interestingly, ASNet (no LM) was able to obtain 100%
coverage on the Probabilistic Blocks World problems in
Figure 2, despite not receiving landmark inputs. To gain
stronger assurance that it had learnt a robust policy, we tested
on 10 more instances with 10, 15, 20, 25, 30 and 35 blocks
(60 more instances total). ASNet (no LM) could not solve all
the additional test instances. In contrast, ASNet (inadm.)—
which was given landmarks as input—reliably solved all test
problems in the extended set, thus showing that heuristic in-
puts are necessary to express essential recursive properties
like whether a block is in its goal position.

Heuristic inputs also appear to be necessary in CosaNos-
tra, where ASNet (no LM) could not achieve full coverage
on the test set. We suspect that this is because an ASNet
without heuristic inputs cannot determine which direction
leads to the pizza shop and which direction leads to the cus-
tomer when it is in the middle of a long chain of toll booths.
How do suboptimal training policies affect ASNet?
Our results suggest that use of a suboptimal policies is suf-
ﬁcient to train ASNet, as demonstrated in all three domains.
Intuitively, the use of suboptimal policies for training ought
to be beneﬁcial because the time that would have been spent
computing an optimal policy can instead be used for more
epochs of exploration and supervised learning. This is some-
what evident in CosaNostra—where a suboptimal training
policy allows for slightly faster convergence—but it is more
clear in Probabilistic Blocks World, where the ASNet can
only converge within our chosen time limit with the inad-
missible policy. While training on fewer problems allowed
the network to converge within the time limit, it did not yield
as robust a policy, suggesting that the use of a suboptimal
teacher is sometimes a necessity.

Is ASNet performing ﬁxed-depth lookahead search?
No. This can be seen by comparing SSiPP and ASNet.
SSiPP solves ﬁxed-depth sub-problems (a generalization of
lookahead for SSPs) and is unable to scale up as well as AS-
Nets when using an equivalent depth parametrisation. Trian-
gle Tire World is particularly interesting because SSiPP can
outperform other baselines by quickly ﬁnding dead ends and
avoiding them. However, unlike an ASNet, SSiPP is unable
to generalize the solution of one sub-problem to the next and
needs to solve all of them from scratch.

6 Related work
Generalised policies are a topic of interest in planning (Zim-
merman and Kambhampati 2003; Jim´enez et al. 2012; Hu
and De Giacomo 2011). The earliest work in this area ex-
pressed policies as decision lists (Khardon 1999), but these
were insufﬁciently expressive to directly capture recursive
properties, and thus required user-deﬁned support predi-
cates. Later planners partially lifted this restriction by ex-
pressing learnt rules with concept language or taxonomic
syntax, which can capture such properties directly (Mar-
tin and Geffner 2000; Yoon, Fern, and Givan 2002; Yoon,
Fern, and Givan 2004). Other work employed features from
domain-independent heuristics to capture recursive prop-
erties (de la Rosa et al. 2011; Yoon, Fern, and Givan
2006), just as we do with LM-cut landmarks. Srivastava et
al. (2011) have also proposed a substantially different gen-
eralised planning strategy that provides strong guarantees
on plan termination and goal attainment, albeit only for a
restricted class of deterministic problems. Unlike the de-
cision lists (Yoon, Fern, and Givan 2002; Yoon, Fern, and
Givan 2004) and relational decision trees (de la Rosa et al.
2011) employed in past work, our model’s input features are
ﬁxed before training, so we do not fall prey to the rule util-
ity problem (Zimmerman and Kambhampati 2003). Further,
our model can be trained to minimise any differentiable loss,
and could be modiﬁed to use policy gradient reinforcement
learning without changing the model. While our approach

cannot give the same theoretical guarantees as Srivastava et
al., we are able to handle a more general class of problems
with less domain-speciﬁc information.

Neural networks have been used to learn policies for prob-
abilistic planning problems. The Factored Policy Gradient
(FPG) planner trains a multi-layer perceptron with reinforce-
ment learning to solve a factored MDP (Buffet and Aberdeen
2009), but it cannot generalise across problems and must
thus be trained anew on each evaluation problem. Concur-
rent with this work, Groshev et al. (2017) propose generalis-
ing “reactive” policies and heuristics by applying a CNN to
a 2D visual representation of the problem, and demonstrate
an effective learnt heuristic for Sokoban. However, their ap-
proach requires the user to deﬁne an appropriate visual en-
coding of states, whereas ASNets are able to work directly
from a PPDDL description.

The integration of planning and neural networks has also
been investigated in the context of deep reinforcement learn-
ing. For instance, Value Iteration Networks (Tamar et al.
2016; Niu et al. 2017) (VINs) learn to formulate and solve
a probabilistic planning problem within a larger deep neu-
ral network. A VIN’s internal model can allow it to learn
more robust policies than would be possible with ordinary
feedforward neural networks. In contrast to VINs, ASNets
are intended to learn reactive policies for known planning
problems, and operate on factored problem representations
instead of (exponentially larger) explicit representations like
those used by VINs.

In a similar vein, Kansky et al. present a model-based RL
technique known as schema networks (Kansky et al. 2017).
A schema network can learn a transition model for an en-
vironment which has been decomposed into entities, but
where those entities’ interactions are initially unknown. The
entity–relation structure of schema networks is reminiscent
of the action–proposition structure of an ASNet; however,
the relations between ASNet modules are obtained through
grounding, whereas schema networks learn which entities
are related from scratch. As with VINs, schema networks
tend to yield agents which generalise well across a class of
similar environments. However, unlike VINs and ASNets—
which both learn policies directly—schema networks only
learn a model of an environment, and planning on that model
must be performed separately.

Extension of convolutional networks to other graph struc-
tures has received signiﬁcant attention recently, as such net-
works often have helpful invariances (e.g. invariance to the
order in which nodes and edges are given to the network) and
fewer parameters to learn than fully connected networks.
Applications include reasoning about spatio-temporal rela-
tionships between variable numbers of entities (Jain et al.
2016), molecular ﬁngerprinting (Kearnes et al. 2016), visual
question answering (Teney, Liu, and Hengel 2017), and rea-
soning about knowledge graphs (Kipf and Welling 2017).
To the best of our knowledge, this paper is the ﬁrst such
technique that successfully solves factored representations
of automated planning problems.

7 Conclusion
We have introduced the ASNet, a neural network architec-
ture which is able to learn generalised policies for proba-
bilistic planning problems. In much the same way that CNNs
can generalise to images of arbitrary size by performing only
repeated local operations, an ASNet can generalise to dif-
ferent problems from the same domain by performing only
convolution-like operations on representations of actions or
propositions which are related to one another. In problems
where some propositions are only related by long chains of
actions, ASNet’s modelling capacity is limited by its depth,
but it is possible to avoid this limitation by supplying the
network with heuristic input features, thereby allowing the
network to solve a range of problems.

While we have only considered supervised learning of
generalised policies, the ASNet architecture could in princi-
ple be used to learn heuristics or embeddings, or be trained
with reinforcement learning. ASNet only requires a model
of which actions affect which portion of a state, so it could
also be used in other settings beyond SSPs, such as MDPs
with Imprecise Probabilities (MDPIPs) (White III and El-
deib 1994) and MDPs with Set-Valued Transitions (MDP-
STs) (Trevizan, Cozman, and Barros 2007). We hope that
future work will be able to explore these alternatives and
use ASNets to further enrich planning with the capabilities
of deep learning.

References
[Bertsekas and Tsitsiklis 1996] Bertsekas, D., and Tsitsiklis, J. N.

1996. Neuro-Dynamic Programming. Athena Scientiﬁc.

[Blum and Furst 1997] Blum, A. L., and Furst, M. L. 1997. Fast

planning through planning graph analysis. AIJ.

[Bonet and Geffner 2003] Bonet, B., and Geffner, H. 2003. Labeled
RTDP: improving the convergence of real-time dynamic program-
ming. In AAAI.

[Buffet and Aberdeen 2009] Buffet, O., and Aberdeen, D. 2009.

The factored policy-gradient planner. AIJ.

[Clevert, Unterthiner, and Hochreiter 2016] Clevert, D.-A.; Un-
terthiner, T.; and Hochreiter, S. 2016. Fast and accurate deep
network learning by exponential linear units (ELUs). ICLR.

[de la Rosa et al. 2011] de la Rosa, T.; Jim´enez, S.; Fuentetaja, R.;
and Borrajo, D. 2011. Scaling up heuristic planning with relational
decision trees. JAIR.

[de la Rosa, Celorrio, and Borrajo 2008] de la Rosa, T.; Celorrio,
S. J.; and Borrajo, D. 2008. Learning relational decision trees
for guiding heuristic planning. In ICAPS.

[Groshev et al. 2017] Groshev, E.; Tamar, A.; Srivastava, S.; and
Abbeel, P. 2017. Learning generalized reactive policies using deep
neural networks. arXiv:1708.07280.

[Hansen and Zilberstein 2001] Hansen, E. A., and Zilberstein, S.
2001. LAO: A heuristic search algorithm that ﬁnds solutions with
loops. Artiﬁcial Intelligence.

[Helmert and Domshlak 2009] Helmert, M., and Domshlak, C.
2009. Landmarks, critical paths and abstractions: what’s the dif-
ference anyway? In ICAPS.

[Jain et al. 2016] Jain, A.; Zamir, A. R.; Savarese, S.; and Saxena,
2016. Structural-RNN: Deep learning on spatio-temporal

A.
graphs. In CVPR.

[Jim´enez et al. 2012] Jim´enez, S.; de la Rosa, T.; Fern´andez, S.;
Fern´andez, F.; and Borrajo, D. 2012. A review of machine learning
for automated planning. Knowl. Eng. Rev.

[Kansky et al. 2017] Kansky, K.; Silver, T.; M´ely, D. A.; Eldawy,
M.; L´azaro-Gredilla, M.; Lou, X.; Dorfman, N.; Sidor, S.; Phoenix,
S.; and George, D. 2017. Schema networks: Zero-shot transfer with
a generative causal model of intuitive physics. In ICML.

[Kearnes et al. 2016] Kearnes, S.; McCloskey, K.; Berndl, M.;
Pande, V.; and Riley, P. 2016. Molecular graph convolutions:
moving beyond ﬁngerprints. Journal of Computer-Aided Molec-
ular Design.

[Khardon 1999] Khardon, R. 1999. Learning action strategies for

planning domains. AIJ.

[Kingma and Ba 2015] Kingma, D., and Ba, J. 2015. Adam: A

method for stochastic optimization. In ICLR.

[Kipf and Welling 2017] Kipf, T. N., and Welling, M. 2017. Semi-
In

supervised classiﬁcation with graph convolutional networks.
ICLR.

[Krizhevsky, Sutskever, and Hinton 2012] Krizhevsky,

Sutskever, I.; and Hinton, G. E.
tion with deep convolutional neural networks. In NIPS.

2012.

A.;
Imagenet classiﬁca-

[Little and Thi´ebaux 2007] Little, I., and Thi´ebaux, S. 2007. Prob-

abilistic planning vs. replanning. In ICAPS workshops.
[Martin and Geffner 2000] Martin, M., and Geffner, H.

2000.
Learning generalized policies in planning using concept languages.
In KRR.

[Mausam and Kolobov 2012] Mausam, and Kolobov, A.

2012.

Planning with Markov Decision Processes. Morgan & Claypool.
[Mnih et al. 2013] Mnih, V.; Kavukcuoglu, K.; Silver, D.; Graves,
A.; Antonoglou, I.; Wierstra, D.; and Riedmiller, M. 2013. Playing
Atari with deep reinforcement learning. In NIPS workshops.

[Niu et al. 2017] Niu, S.; Chen, S.; Guo, H.; Targonski, C.; Smith,
M. C.; and Kovaˇcevi´c, J. 2017. Generalized value iteration net-
works: Life beyond lattices. arXiv:1706.02416.

[Slaney and Thi´ebaux 2001] Slaney, J., and Thi´ebaux, S.

2001.

Blocks world revisited. AIJ.

[Srivastava et al. 2011] Srivastava, S.; Immerman, N.; Zilberstein,
S.; and Zhang, T. 2011. Directed search for generalized plans
using classical planners. In ICAPS.

[Tamar et al. 2016] Tamar, A.; Wu, Y.; Thomas, G.; Levine, S.; and

Abbeel, P. 2016. Value iteration networks. In NIPS.

[Teichteil-K¨onigsbuch, Vidal, and Infantes 2011] Teichteil-

K¨onigsbuch, F.; Vidal, V.; and Infantes, G.
2011. Extending
Classical Planning Heuristics to Probabilistic Planning with
Dead-Ends. In AAAI.

[Teney, Liu, and Hengel 2017] Teney, D.; Liu, L.; and Hengel, A.
v. d. 2017. Graph-structured representations for visual question
answering. In CVPR.

[Trevizan and Veloso 2014] Trevizan, F., and Veloso, M.

2014.
Depth-based Short-sighted Stochastic Shortest Path Problems. Ar-
tiﬁcial Intelligence.

[Trevizan, Cozman, and Barros 2007] Trevizan, F.; Cozman, F. G.;
and Barros, L. N. 2007. Planning under risk and knightian uncer-
tainty. In IJCAI.

[Hu and De Giacomo 2011] Hu, Y., and De Giacomo, G. 2011.
Generalized planning: Synthesizing plans that work for multiple
environments. In IJCAI.

[Vallati et al. 2015] Vallati, M.; Chrpa, L.; Grze´s, M.; McCluskey,
T. L.; Roberts, M.; Sanner, S.; et al. 2015. The 2014 International
Planning Competition: Progress and trends. AI Mag.

B Coverage and cost for probabilistic

experiments

To complement the time ﬁgures and basic overview of cov-
erage given in the main paper, Table 2, Table 3, Table 4 and
show coverage and solution cost for the evaluated proba-
bilistic problems.

[White III and Eldeib 1994] White III, C. C., and Eldeib, H. K.
1994. Markov decision processes with imprecise transition proba-
bilities. Operations Research 42(4):739–749.

[Yoon, Fern, and Givan 2002] Yoon, S.; Fern, A.; and Givan, R.

2002. Inductive policy selection for ﬁrst-order MDPs. In UAI.

[Yoon, Fern, and Givan 2004] Yoon, S.; Fern, A.; and Givan, R.
2004. Learning reactive policies for probabilistic planning do-
mains. In IPC Probabilistic Track.

[Yoon, Fern, and Givan 2006] Yoon, S. W.; Fern, A.; and Givan, R.
2006. Learning heuristic functions from relaxed plans. In ICAPS.

[Yoon, Fern, and Givan 2007] Yoon, S. W.; Fern, A.; and Givan, R.
2007. Using learned policies in heuristic-search planning. In IJ-
CAI.

[Younes and Littman 2004] Younes, H. L., and Littman, M. L.
2004. PPDDL1.0: an extension to PDDL for expressing planning
domains with probabilistic effects.

[Zimmerman and Kambhampati 2003] Zimmerman, T., and Kamb-
hampati, S. 2003. Learning-assisted automated planning: looking
back, taking stock, going forward. AI Mag.

A Supplementary material

A.1 Monster experiments

To illustrate when LM-cut ﬂags are not sufﬁcient, we created
a simple domain called Monster, in which the agent must
choose between two n-step paths to reach the goal. This do-
main domain uses the same at(ι) predicate and move(ι1, ι2)
operators from the running logistics example in the main
paper. However, at the beginning of each episode, a mon-
ster is randomly placed at the ﬁnal location along one of the
two paths, and it has a 99% chance of attacking the agent if
the agent moves to the its location. Since there is still a 1%
chance of not attacking the agent, an all-outcome determini-
sation cannot indicate which path has the monster on it, and
so the agent must look ahead at least n steps to be safe. Oth-
erwise, if the agent chooses at random, there is a 50% chance
that they will choose the wrong path, and subsequently hit a
dead end with high probability.

We perform an experiment on this domain in which we
train ASNets with increasing depth on problems with paths
from length 1-5. We then test on those same problems to
determine what the agent was able to learn. Table 1 shows
the full results. As expected, the only runs with full coverage
are those where the ASNet has sufﬁcient depth to see the
monster; all others force the ASNet to choose arbitrarily.

Proposition
layers
1
2
3
4

1
30/30
30/30
30/30
30/30

Path length
3
14/30
14/30
30/30
30/30

4
14/30
14/30
14/30
30/30

2
14/30
30/30
30/30
30/30

5
14/30
14/30
14/30
14/30

Table 1: Coverage (out of 30) for Monster problem with dif-
ferent layer counts.

d
d
a
h

0
3
/
0
3

0
3
/
0
3

t
u
c
-

M
L

0
3
/
0
3

0
3
/
0
3

)
0
8
.
0
±
3
3
.
3
2
(

)
6
7
.
0
±
3
2
.
3
2
(

)
6
7
.
0
±
0
1
.
4
2
(

)
1
7
.
0
±
3
8
.
3
2
(

)
9
6
.
0
±
7
1
.
3
2
(

)
9
6
.
0
±
7
1
.
3
2
(

)
6
6
.
0
±
7
3
.
3
2
(

)
6
6
.
0
±
7
3
.
3
2
(

)
6
6
.
0
±
7
3
.
3
2
(

P
P
i
S
S

P
D
T
R
L

O
A
L
I

d
d
a
h

0
3
/
0
3

t
u
c
-

M
L

0
3
/
0
3

M
L
o
n

,

d
d
a
h

t
u
c
-

M
L

0
3
/
0
3

)
9
7
.
0
±
3
8
.
9
2
(

)
5
8
.
0
±
3
4
.
9
2
(

)
3
6
.
0
±
3
2
.
0
3
(

)
5
7
.
0
±
7
2
.
9
2
(

)
1
8
.
0
±
7
8
.
8
2
(

)
1
8
.
0
±
7
8
.
8
2
(

)
1
8
.
0
±
7
8
.
8
2
(

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
6
2

0
3
/
1

)
0
0
.
1
7
(

-

-

-

-

-

-

-

-

-

-

-

t
u
c
-

M
L

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
7

0
3
/
1

)
0
0
.
0
6
(

0
3
/
1

)
0
0
.
4
5
(

-

-

-

-

-

-

-

-

-

-

)
7
8
.
0
±
0
9
.
6
3
(

)
6
9
.
0
±
0
7
.
5
3
(

)
5
0
.
1
±
3
3
.
4
4
(

)
6
8
.
0
±
3
4
.
1
4
(

)
5
0
.
1
±
7
7
.
0
5
(

)
6
6
.
3
±
0
0
.
8
4
(

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

t
e
N
S
A

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

)
4
9
.
0
±
7
8
.
4
3
(

)
4
9
.
0
±
7
8
.
4
3
(

)
4
9
.
0
±
7
8
.
4
3
(

)
1
9
.
0
±
7
7
.
0
4
(

)
1
9
.
0
±
7
7
.
0
4
(

)
1
9
.
0
±
7
7
.
0
4
(

)
2
1
.
1
±
3
8
.
6
4
(

)
2
1
.
1
±
3
8
.
6
4
(

)
2
1
.
1
±
3
8
.
6
4
(

)
1
1
.
1
±
0
0
.
9
5
(

)
1
1
.
1
±
0
0
.
9
5
(

)
1
1
.
1
±
0
0
.
9
5
(

)
7
2
.
1
±
3
9
.
2
5
(

)
7
2
.
1
±
3
9
.
2
5
(

)
7
2
.
1
±
3
9
.
2
5
(

)
8
0
.
1
±
7
7
.
4
6
(

)
8
0
.
1
±
7
7
.
4
6
(

)
8
0
.
1
±
7
7
.
4
6
(

)
1
2
.
1
±
7
0
.
1
7
(

)
1
2
.
1
±
7
0
.
1
7
(

)
1
2
.
1
±
7
0
.
1
7
(

)
1
2
.
1
±
0
9
.
6
7
(

)
1
2
.
1
±
0
9
.
6
7
(

)
1
2
.
1
±
0
9
.
6
7
(

)
5
3
.
1
±
0
8
.
2
8
(

)
5
3
.
1
±
0
8
.
2
8
(

)
5
3
.
1
±
0
8
.
2
8
(

)
7
3
.
1
±
7
6
.
8
8
(

)
7
3
.
1
±
7
6
.
8
8
(

)
7
3
.
1
±
7
6
.
8
8
(

)
9
2
.
1
±
3
8
.
4
9
(

)
9
2
.
1
±
3
8
.
4
9
(

)
9
2
.
1
±
3
8
.
4
9
(

)
1
2
.
1
±
0
8
.
0
0
1
(

)
1
2
.
1
±
0
8
.
0
0
1
(

)
1
2
.
1
±
0
8
.
0
0
1
(

)
4
4
.
1
±
0
5
.
6
0
1
(

)
4
4
.
1
±
0
5
.
6
0
1
(

)
4
4
.
1
±
0
5
.
6
0
1
(

)
6
5
.
1
±
0
5
.
2
1
1
(

)
6
5
.
1
±
0
5
.
2
1
1
(

)
6
5
.
1
±
0
5
.
2
1
1
(

)
8
4
.
1
±
3
4
.
8
1
1
(

)
8
4
.
1
±
3
4
.
8
1
1
(

)
8
4
.
1
±
3
4
.
8
1
1
(

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

4
-
e
r
i
t
-
e
l
g
n
a
i
r
t

5
-
e
r
i
t
-
e
l
g
n
a
i
r
t

6
-
e
r
i
t
-
e
l
g
n
a
i
r
t

7
-
e
r
i
t
-
e
l
g
n
a
i
r
t

8
-
e
r
i
t
-
e
l
g
n
a
i
r
t

m
e
l
b
o
r
P

0
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

9
-
e
r
i
t
-
e
l
g
n
a
i
r
t

1
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

2
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

3
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

4
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

5
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

6
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

7
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

8
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

9
1
-
e
r
i
t
-
e
l
g
n
a
i
r
t

0
2
-
e
r
i
t
-
e
l
g
n
a
i
r
t

n
e
v
i
g
s
i

t
s
o
c

r
o
f

I

C
%
5
9
d
n
a

l
a
o
g
e
h
t
h
c
a
e
r
o
t

t
s
o
c
n
a
e

M

.
s
r
e
n
n
a
l
p
d
n
a

s

m
e
l
b
o
r
p
f
o
n
o
i
t
c
e
l
e
s

a

r
o
f

)
l
a
o
g
e
h
t
h
c
a
e
r
o
t

s
l
a
i
r
t

l
u
f
s
s
e
c
c
u
s

f
o
r
e
b
m
u
n
(

e
g
a
r
e
v
o
C

:
2
e
l
b
a
T

.
s
t
e
k
c
a
r
b
n
i

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
7
1

0
3
/
7
2

0
3
/
5
1

0
3
/
2

-

-

-

-

-

t
u
c
-

M
L

0
3
/
3

0
3
/
0
3

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
8
2

0
3
/
0
3

0
3
/
9
2

0
3
/
7
2

0
3
/
1
2

0
3
/
6
1

)
5
9
.
2
8
±
8
3
.
8
1
4
(

)
3
9
.
3
8
±
1
3
.
3
7
3
(

0
3
/
1

)
0
0
.
6
6
3
(

0
3
/
3

0
3
/
6

)
6
7
.
9
9
1
±
7
6
.
3
8
2
(

)
0
8
.
7
3
1
±
3
3
.
7
8
2
(

t
u
c
-

M
L

0
3
/
0
3

0
3
/
3
1

0
3
/
0
3

0
3
/
0
3

0
3
/
4
1

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

-

-

-

-

-

-

-

-

-

)
8
5
.
1
±
3
5
.
5
2
(

)
3
7
.
0
8
±
7
7
.
4
8
1
(

)
1
8
.
1
±
0
0
.
7
2
(

)
9
7
.
3
±
7
6
.
4
2
(

)
3
8
.
1
±
3
8
.
6
2
(

)
5
7
.
1
±
3
0
.
7
2
(

)
0
6
.
1
±
7
3
.
6
2
(

)
0
6
.
1
±
7
3
.
6
2
(

)
1
9
.
1
±
7
8
.
2
3
(

)
7
4
.
7
4
1
±
8
0
.
0
8
4
(

)
0
7
.
1
±
7
1
.
3
3
(

)
1
8
.
1
±
0
8
.
8
1
(

)
1
0
.
2
±
7
6
.
2
3
(

)
1
2
.
2
±
3
4
.
1
3
(

)
9
7
.
1
±
7
5
.
2
3
(

)
9
7
.
1
±
7
5
.
2
3
(

)
2
7
.
1
±
3
3
.
0
2
(

)
1
1
.
9
±
3
5
.
7
2
(

)
5
6
.
1
±
7
4
.
0
2
(

)
1
0
.
2
±
7
6
.
1
2
(

)
8
7
.
1
±
3
0
.
1
2
(

)
9
9
.
1
±
7
2
.
9
1
(

)
9
9
.
1
±
7
2
.
9
1
(

)
7
5
.
1
±
3
0
.
5
2
(

)
6
7
.
4
2
±
7
4
.
8
7
(

)
3
2
.
1
±
3
0
.
4
2
(

)
1
7
.
1
±
7
8
.
6
2
(

)
0
9
.
1
±
0
5
.
5
2
(

)
7
9
.
1
±
0
6
.
4
2
(

)
7
9
.
1
±
0
6
.
4
2
(

)
9
7
.
1
±
7
2
.
5
3
(

)
2
1
.
3
7
1
±
0
5
.
4
8
4
(

)
4
6
.
1
±
7
2
.
4
3
(

)
6
9
.
1
±
7
3
.
6
3
(

)
1
0
.
2
±
7
8
.
3
3
(

)
1
0
.
2
±
7
8
.
3
3
(

)
1
7
.
1
±
0
6
.
8
2
(

)
1
5
.
3
3
±
0
2
.
7
2
1
(

)
7
7
.
1
±
3
1
.
8
2
(

)
1
0
.
2
±
0
9
.
9
2
(

)
7
1
.
2
±
3
7
.
8
2
(

)
6
9
.
1
±
3
2
.
8
2
(

)
7
4
.
1
±
7
2
.
1
5
(

)
2
1
.
0
1
±
3
2
.
4
9
(

)
2
9
.
1
±
0
1
.
0
5
(

)
3
8
.
2
±
7
8
.
8
4
(

)
5
3
.
2
±
3
2
.
9
4
(

)
2
5
.
2
±
7
7
.
6
4
(

)
0
0
.
2
±
0
6
.
8
5
(

)
5
5
.
3
3
±
0
0
.
5
8
1
(

)
9
4
.
2
±
0
1
.
7
5
(

)
3
6
.
2
±
7
6
.
7
5
(

)
5
4
.
2
±
0
5
.
5
5
(

)
1
3
.
2
±
3
2
.
5
5
(

)
7
0
.
2
±
0
0
.
6
4
(

)
1
4
.
0
5
±
0
2
.
9
4
2
(

)
3
8
.
1
±
3
1
.
5
4
(

)
9
4
.
2
±
0
4
.
6
4
(

)
3
3
.
2
±
0
5
.
8
4
(

)
0
6
.
2
±
3
5
.
6
4
(

)
7
8
.
2
±
0
0
.
0
7
(

)
6
1
.
3
±
3
5
.
3
8
(

)
9
2
.
3
±
0
2
.
8
7
(

)
6
3
.
3
±
0
7
.
0
7
(

)
4
5
.
2
±
3
6
.
9
6
(

)
1
5
.
2
±
3
3
.
0
7
(

)
9
3
.
2
±
3
9
.
5
6
(

)
3
7
.
2
±
0
1
.
9
7
(

)
7
1
.
2
±
7
8
.
3
7
(

)
1
1
.
2
±
7
7
.
6
7
(

)
1
1
.
2
±
7
7
.
6
7
(

)
4
4
.
3
±
7
2
.
6
7
(

)
2
8
.
2
±
0
6
.
4
7
(

)
0
6
.
2
±
0
3
.
7
7
(

)
1
8
.
2
±
3
5
.
9
6
(

)
6
4
.
1
9
±
6
9
.
3
2
3
(

)
0
6
.
4
±
4
9
.
0
0
1
(

)
9
8
.
2
±
7
4
.
9
9
(

)
9
9
.
2
±
7
2
.
8
9
(

)
9
9
.
7
2
±
3
6
.
5
4
1
(

)
6
1
.
3
±
8
7
.
0
0
1
(

)
4
6
.
2
±
7
7
.
1
9
(

)
7
4
.
2
±
0
5
.
1
9
(

)
1
3
.
5
3
±
1
4
.
3
6
1
(

)
9
9
.
5
±
3
7
.
5
9
(

)
0
0
.
2
±
0
9
.
5
8
(

)
9
5
.
2
±
0
7
.
9
8
(

)
1
3
.
3
6
±
7
3
.
0
4
3
(

)
7
4
.
4
4
±
0
5
.
7
0
1
(

)
7
7
.
2
±
3
2
.
7
1
1
(

)
1
0
.
3
±
3
4
.
6
1
1
(

t
u
c
-

M
L

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

)
6
5
.
3
±
7
2
.
3
1
1
(

)
6
3
.
3
±
0
2
.
1
1
1
(

)
8
8
.
2
±
0
0
.
9
1
1
(

)
3
3
.
3
±
0
3
.
7
1
1
(

)
4
0
.
3
±
7
8
.
8
3
1
(

)
7
3
.
3
±
0
8
.
8
3
1
(

)
1
4
.
3
±
0
7
.
7
3
1
(

)
2
1
.
3
±
0
0
.
7
3
1
(

)
2
6
.
3
±
3
3
.
9
3
1
(

)
1
3
.
3
±
7
2
.
9
3
1
(

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

-

-

-

-

-

-

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

.

n
i
a
m
o
d
d
l
r
o
W

s
k
c
o
l
B
c
i
t
s
i
l
i
b
a
b
o
r
P
e
h
t

r
o
f

d
e
t
a
e
p
e
r

2
e
l
b
a
T

:
3

e
l
b
a
T

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

1
s
-
9
n
-
w
b
-
b
o
r
p

2
s
-
9
n
-
w
b
-
b
o
r
p

3
s
-
9
n
-
w
b
-
b
o
r
p

1
s
-
0
1
n
-
w
b
-
b
o
r
p

2
s
-
0
1
n
-
w
b
-
b
o
r
p

3
s
-
0
1
n
-
w
b
-
b
o
r
p

1
s
-
5
1
n
-
w
b
-
b
o
r
p

2
s
-
5
1
n
-
w
b
-
b
o
r
p

3
s
-
5
1
n
-
w
b
-
b
o
r
p

1
s
-
0
2
n
-
w
b
-
b
o
r
p

2
s
-
0
2
n
-
w
b
-
b
o
r
p

3
s
-
0
2
n
-
w
b
-
b
o
r
p

1
s
-
5
2
n
-
w
b
-
b
o
r
p

2
s
-
5
2
n
-
w
b
-
b
o
r
p

3
s
-
5
2
n
-
w
b
-
b
o
r
p

1
s
-
0
3
n
-
w
b
-
b
o
r
p

2
s
-
0
3
n
-
w
b
-
b
o
r
p

3
s
-
0
3
n
-
w
b
-
b
o
r
p

1
s
-
5
3
n
-
w
b
-
b
o
r
p

2
s
-
5
3
n
-
w
b
-
b
o
r
p

3
s
-
5
3
n
-
w
b
-
b
o
r
p

P
P
i
S
S

P
D
T
R
L

O
A
L
I

t
e
N
S
A

M
L
o
n

,

d
d
a
h

t
u
c
-

M
L

m
e
l
b
o
r
P

P
P
i
S
S

P
D
T
R
L

O
A
L
I

M
L
o
n

,

d
d
a
h

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

t
u
c
-

M
L

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

-

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

t
u
c
-

M
L

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

-

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

)
0
±
0
0
.
6
4
(

)
0
±
0
0
.
9
4
(

t
u
c
-

M
L

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

-

-

-

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
4
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
7
3
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
0
4
(

)
0
±
0
0
.
3
4
(

)
0
±
0
0
.
3
4
(

)
0
±
0
0
.
3
4
(

)
0
±
0
0
.
3
4
(

)
0
±
0
0
.
3
4
(

)
0
±
0
0
.
3
4
(

-

-

-

-

-

-

-

)
0
±
0
0
.
6
4
(

)
0
±
0
0
.
6
4
(

)
0
±
0
0
.
9
4
(

)
0
±
0
0
.
9
4
(

)
0
±
0
0
.
4
6
(

)
0
±
0
0
.
4
6
(

t
e
N
S
A

d
d
a
h

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

t
u
c
-

M
L

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
3
/
0
3

0
1
n
-
a
r
t
s
o
n
a
s
o
c

1
1
n
-
a
r
t
s
o
n
a
s
o
c

2
1
n
-
a
r
t
s
o
n
a
s
o
c

3
1
n
-
a
r
t
s
o
n
a
s
o
c

4
1
n
-
a
r
t
s
o
n
a
s
o
c

5
1
n
-
a
r
t
s
o
n
a
s
o
c

0
2
n
-
a
r
t
s
o
n
a
s
o
c

m
e
l
b
o
r
P

.

n
i
a
m
o
d

a
z
z
i

P
a
r
t
s
o
N
a
s
o
C
e
h
t

r
o
f

d
e
t
a
e
p
e
r

2

e
l
b
a
T

:
4

e
l
b
a
T

