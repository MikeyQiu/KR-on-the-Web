9
1
0
2
 
l
u
J
 
0
1
 
 
]
L
C
.
s
c
[
 
 
2
v
8
0
4
7
0
.
5
0
9
1
:
v
i
X
r
a

Functorial Question Answering

Giovanni de Felice†, Konstantinos Meichanetzidis†?, Alexis Toumi†

† Department of Computer Science, University of Oxford. ? Cambridge Quantum Computing Ltd.

July 11, 2019

We study the relational variant of the categorical compositional

distributional (DisCoCat) models of Coecke et al. [1], where we re-

place vector spaces and linear maps by sets and relations. We show

that RelCoCat models factorise through Cartesian bicategories, as a

corollary we get logspace reductions from semantics and entailment

to evaluation and containment of conjunctive queries respectively.

Finally, we define question answering as an NP − complete problem.

Introduction

In this paper, we give a semantics to pregroup grammars in regular logic: the
fragment of first-order logic generated by relational symbols, equality (=),

truth (>), conjunction (∧) and existential quantification (∃). Regular logic plays
a foundational role in the theory of relational databases, where it corresponds

to conjunctive queries. Chandra and Merlin [2] showed that conjunctive query
evaluation and containment are logspace equivalent to graph homomorphism:

they are NP − complete. Bonchi et al.
free Cartesian bicategory CB(Σ): arrows are conjunctive queries, structure-
preserving functors K : CB(Σ) → Rel are precisely relational databases.

[3] reformulated this in terms of the

We define concrete RelCoCat (categorical compositional relational) models
as strong monoidal functors F : G → Rel from the rigid monoidal category G
generated by a pregroup grammar. We show that RelCoCat models factorise as

F = K◦L for K : CB(Σ) → Rel a relational database and a functor L : G → CB(Σ),
which we call an abstract RelCoCat model. As a corollary, the computational
problems for RelCoCat Semantics and Entailment reduce to conjunctive query
evaluation and containment respectively. Building on previous work [4], we

then show that the QuestionAnswering problem is NP − complete.

1

Related Work

Logical semantics for pregroups has been developped in a line of work by Preller

[5, 6, 7], however the corresponding reasoning problems were undecidable.

Entailment in distributional models has been considered in [8], but sentences

could only be compared if they have the same grammatical structure.

1 Lambek Pregroups and Free Rigid Categories

Pregroup grammar is an algebraic model of natural language grammar intro-

duced by Lambek [9], it is weakly equivalent to context-free grammars [10].

In this section, we give a definition of the Parsing problem in terms of the
homsets of the free rigid monoidal category generated by a pregroup dictionary.
Given a natural number n ∈ N, we abuse notation and let n = { i ∈ N | i < n }.
Given sets X and Y , X + Y and X × Y denote the disjoint sum and the Cartesian
product respectively. Let List(X) = S
n∈N X n be the free monoid with unit (cid:15) ∈ X 0
the empty list and product denoted by concatenation.

Deﬁnition 1.1. A pregroup is a strict monoidal category with unit (cid:15) and product denoted
by concatenation, which is thin — i.e. with at most one arrow (denoted ≤) between any
two objects — and where each object t has left and right adjoints denoted ?t and t?, i.e.

• t(?t) ≤ (cid:15) ≤ (?t)t

• (t?)t ≤ (cid:15) ≤ t(t?)

(left adjunction)

(right adjunction)

A pregroup grammar is a tuple G = (V, B, ∆) where V is a finite set called
the vocabulary, B is a poset of basic types and ∆ ⊆ V × P (B) is a finite set of
pairs called the dictionary, where P (B) is the free pregroup generated by B as
defined in [9]. We write ∆(u) = { t(0) . . . t(n − 1) | t ∈ Q

∆(u(i)) } for u ∈ V n.

i<n

Deﬁnition 1.2. Grammaticality

Input:

Output:

G = (V, B, ∆),
∃ t ∈ ∆(u) · t ≤ s

u ∈ List(V ),

s ∈ P (B)

Example 1.3. Take the basic types B = { s, q, d, n, i, o } for sentence, question, deter-
minant, noun, subject and object respectively, with n ≤ i and n ≤ o. The dictionary
∆ assigns (?i)s(o?) to transitive verbs and (?d)n to common nouns. The word “who” is
assigned both (?n)n(s?)i and q(s?)i. From the pregroup axioms it follows that:

q(s?)i (?i)s(o?) d (?d)n (?n)n(s?)i (?i)s(o?) n ≤ q

2

i.e. u = “Who inﬂuenced the philosopher who discovered calculus?” is grammatical.

Lemma 1.4 (Switching lemma [9]). For all t ≤ s ∈ P (B) there is some t0 ∈ P (B) and a
pair of reductions t ≤ t0 and t0 ≤ s with no expansions and no contractions respectively.

Corollary 1.5 ([10]). Grammaticality ∈ P

Proof. The proof goes by translating pregroup grammars to context-free grammars.

As thin categories, pregroups cannot distinguish between distinct pars-

ings of the same phrase, e.g. “men and (women who read)” and “(men and

women) who read”. This motivated Preller, Lambek [11] to introduce free com-

pact 2-categories, capturing proof-relevance in pregroup grammars. We will

use compact 2-categories with one 0-cell, first introduced in Joyal, Street [12]

from which we use the planar string diagram notation. We refer the reader to
Selinger’s survey [13] where they are called rigid monoidal categories.

Deﬁnition 1.6. A (strict) monoidal category (C, ⊗, (cid:15)) is rigid when each object t ∈ Ob(C)
has left and right adjoints ?t and t? and two pairs of arrows t ⊗ ?t → (cid:15) → ?t ⊗ t and
t? ⊗ t → (cid:15) → t ⊗ t? depicted by cups and caps, subject to the following snake equations:

t

?t

t

=

t

=

t

t?

t

We say a strong monoidal functor is rigid when it sends cups to cups and caps to caps.

Given a pregroup grammar G = (V, B, ∆), the dictionary ∆ ⊆ V × P (B)
defines an autonomous signature with generating objects V + B and arrows
. We write G for the free rigid category that it generates, also
{ w → t }(w,t)∈∆
called the lexical category in [6]. An arrow r : u → s for an utterance u ∈ List(V )
is a proof that u is a grammatical sentence, i.e. a dictionnary entry for each
word followed by a diagram which encodes the reduction. Hence, the free rigid

category G allows us to encode parsing as a function problem.

Lemma 1.7. Given a pregroup grammar G = (V, B, ∆), an utterance u ∈ List(V ) and a
type s ∈ P (B), we have (G, u, s) ∈ Grammaticality ⇐⇒ ∃ r ∈ G(u, s).

Proof. This follows from the switching lemma for compact 2-categories as proved in [11].

Arrows r ∈ G(u, s) are of the form r : u → t → s for some type t ∈ ∆(u) with t ≤ s.

3

Deﬁnition 1.8. Parsing

Input:

Output:

G = (V, B, ∆),
r ∈ G(u, s)

u ∈ List(V ),

s ∈ P (B)

Proposition 1.9 ([14]). Parsing is poly-time computable in the size of the basic types
B, the dictionary ∆ ⊆ V × P (B) and the length of the inputs (u, s) ∈ List(V ) × P (B).

Proof. The parsing algorithm has time complexity n3 in general, restricted cases of interest
in linguistic applications may be parsed in linear time, see [15].

Note that our definition of the lexical category G differs slightly from [6]
in that we take not only basic types b ∈ B but also words w ∈ V as generating
objects. This allows us to capture both type assignment and reduction as a

single arrow as well as to define the semantics of pregroup grammars as a

functor, see definition 3.2 where we will also make use of the following lemma.

Lemma 1.10. For any pregroup grammar G = (V, B, ∆) there is an equivalent grammar
G0 = (V, B0, ∆0) such that ∆ ⊆ ∆0 and B0 is a discrete poset, i.e. a ≤ b =⇒ a = b.

Proof. For each (w, tat0) ∈ ∆ with a ≤ b ∈ B we add (w, tbt0) as a dictionnary entry.
This yields a dictionnary ∆0 of size polynomial in |B| × |∆| and basic types B0 given by
the underlying set of the poset B such that G and G0 = (V, B0, ∆0) are equivalent.

Example 1.11. The following planar diagram r : u → q corresponds to the parsing
of example 1.3, where we have we have omitted the types for readability. We keep our

notation consistent with the literature by depicting dictionnary entries w → t as triangles
labeled by w ∈ V with output t ∈ P (B).

Who

inﬂ

a

phil

who

disc

calc

2 Conjunctive Queries and Free Cartesian Bicategories

A relational signature is a set of symbols Σ equipped with a function ar : Σ → N.
Given a finite set U , we define the set of Σ-models MΣ(U ) = { K ⊆ ‘
R∈Σ U ar(R) },
i.e. a Σ-model K gives an interpretation K(R) ⊆ U ar(R) for every symbol R ∈ Σ.
Let MΣ be the set of all finite Σ-models and U (K) the underlying universe of

4

K ∈ MΣ. Given two Σ-models K, K0, a homomorphism f : K → K0 is a function
f : U (K) → U (K0) such that ∀ R ∈ Σ ∀ ~x ∈ U ar(R)

· ~x ∈ K(R) =⇒ f (~x) ∈ K0(R).

Deﬁnition 2.1. Homomorphism

Input:

Output:

K, K0 ∈ MΣ
f : K → K0

Proposition 2.2. [16] Homomorphism is NP − complete.

Proof. Membership may be shown to follow from Fagin’s theorem: homomorphisms are

deﬁned by an existential second-order logic formula. Hardness follows by reduction from

graph homomorphism: take Σ = { • } and ar(•) = 2 then a Σ-model is a graph.

Regular logic formulae are defined by the following context-free grammar:

ϕ ::= > | x = x0 | ϕ ∧ ϕ | ∃ x · ϕ | R(~x)

where x, x0 ∈ X , R ∈ Σ and ~x ∈ X ar(R) for some countable set of variables X . We
denote the variables of ϕ by var(ϕ) ⊆ X , its free variables by fv(ϕ) ⊆ var(ϕ) and
its atomic formulae by atoms(ϕ) ⊆ ‘
var(ϕ)ar(R). Conjunctive queries ϕ ∈ QΣ
R∈Σ
are the prenex normal form ϕ = ∃ x0 · · · ∃ xk · ϕ0 of regular logic formulae, for the
bound variables { x0, . . . , xk } = var(ϕ) \ fv(ϕ) and ϕ0 = V atoms(ϕ). Given a model
K ∈ MΣ, let eval(ϕ, K) = { v ∈ U (K)fv(ϕ) | (K, v) (cid:15) ϕ } where the satisfaction
relation ((cid:15)) is defined in the usual way.

Deﬁnition 2.3. Evaluation

Input:

Output:

ϕ ∈ QΣ, K ∈ MΣ
eval(ϕ, K) ⊆ U (K)fv(ϕ)

Deﬁnition 2.4. Containment

ϕ, ϕ0 ∈ QΣ

Input:
Output: ϕ ⊆ ϕ0 ≡ ∀ K ∈ MΣ · eval(ϕ, K) ⊆ eval(ϕ0, K)

Deﬁnition 2.5. Given a query ϕ ∈ QΣ, the canonical model CM (ϕ) ∈ MΣ is given by
U (CM (ϕ)) = var(ϕ) and CM (ϕ)(R) = { ~x ∈ var(ϕ)ar(R) | R(~x) ∈ atoms(ϕ) } for R ∈ Σ.

Theorem 2.6 (Chandra-Merlin [2]). Evaluation and Containment are logspace equiva-
lent to Homomorphism, hence NP − complete.

Proof. Given a query ϕ ∈ QΣ and a model K ∈ MΣ, query evaluation eval(ϕ, K) is given
by the set of homomorphisms CM (ϕ) → K. Given ϕ, ϕ0 ∈ MΣ, we have ϕ ⊆ ϕ0 iﬀ there

5

is a homomorphism f : CM (ϕ) → CM (ϕ0) such that f (fv(ϕ)) = fv(ϕ0). Given a model
K ∈ MΣ, we construct ϕ ∈ QΣ with fv(ϕ) = ∅, var(ϕ) = U (K) and atoms(ϕ) = K.

Bonchi, Seeber and Sobocinski [3] introduced graphical conjunctive queries

(GCQ), a graphical calculus where query containment is captured by the axioms

of the free Cartesian bicategory CB(Σ) generated by the relational signature Σ.

Deﬁnition 2.7 (Carboni-Walters [17]). A Cartesian bicategory is a symmetric monoidal
category enriched in partial orders such that:

1. every object is equipped with a special commutative Frobenius algebra,

2. the monoid and comonoid structure of each Frobenius algebra are adjoint,

3. every arrow is a lax comonoid homomorphism.

A morphism of Cartesian bicategories is a strong monoidal functor which preserves the

partial order, the monoid and the comonoid structure.

Theorem 2.8. ([3, prop. 9,10]) Let CB(Σ) be the free Cartesian bicategory generated by
one object and arrows { R : 0 → ar(R) }R∈Σ
, see [3, def. 21]. There is a two-way semantics-
preserving translation Θ : QΣ → CB(Σ), Λ : CB(Σ) → QΣ, i.e. for all ϕ, ϕ0 ∈ QΣ we have
ϕ ⊆ ϕ0 ⇐⇒ Θ(ϕ) ≤ Θ(ϕ0), and for all arrows d, d0 ∈ CB(Σ), d ≤ d0 ⇐⇒ Λ(d) ⊆ Λ(d0).

Proof. The translation is deﬁned by induction from the syntax of regular logic formulae

to that of GCQ diagrams and back. Note that given ϕ ∈ QΣ with |fv(ϕ)| = n, we have
Θ(ϕ) ∈ CB(Σ)(0, n) and similarly we have fv(Λ(d)) = m + n for d ∈ CB(Σ)(m, n), i.e.
open wires correspond to free variables.

The category Rel of sets and relations with Cartesian product as tensor,
singleton as unit, the diagonal and its transpose as monoid and comonoid,

subset as partial order, is a Cartesian bicategory. Given a set U , the subcategory
Rel|U ,−→ Rel with natural numbers m, n ∈ N as objects and relations R ⊆ U m+n as
arrows is also a Cartesian bicategory. It is furthermore a PROP, i.e. a symmetric

monoidal category with addition of natural numbers as tensor on objects.

Proposition 2.9. ([3, prop. 23]) Models K ∈ MΣ(U ) are in bijective correspondence
with identity-on-objects morphisms of Cartesian bicategories K : CB(Σ) → Rel|U .

Proof. By the universal property of the free Cartesian bicategory, an identity-on-objects

morphism K : CB(Σ) → Rel|U is uniquely determined by its image on generators
{ K(R) ⊆ U ar(R) }R∈Σ

: this is precisely the data for a Σ-model.

6

Corollary 2.10. Let [CB(Σ), Rel] denote the set of morphisms of Cartesian bicategories,
there are bijective correspondences:

CB(Σ)(0, 0) (1)

’ { ϕ ∈ QΣ | fv(ϕ) = ∅ }

(2)
’ MΣ

(3)
’ [CB(Σ), Rel]

Proof. (1) follows from theorem 2.8, (2) from theorem 2.6 and (3) is proposition 2.9.

3 RelCoCat Semantics and Natural Language Entailment

A concrete RelCoCat model is a rigid monoidal functor F : G → Rel for G the
rigid monoidal category generated by a pregroup grammar G = (V, B, ∆). We
require that the image for words w ∈ V be the singleton F (w) = 1, hence the
image for a dictionnary entry (w, t) ∈ ∆ is given by a subset F (w → t) ⊆ F (t).
We also assume the image of F lies in Rel|U for some finite universe U , which
may be taken to be the union of the universe for each basic type U = S
b∈B F (b).

Lemma 3.1. A RelCoCat model F : G → Rel|U is uniquely determined by its image
on basic types and on dictionnary entries, i.e. by a function ar : B → N and a subset
F (w → t) ⊆ U ar(t) for each (w, t) ∈ ∆. Thus, F induces a model K ∈ M∆(U ) over the
dictionnary seen as a signature where entries (w, t) ∈ ∆ are symbols of arity F (t) ∈ N.

Proof. This follows from lemma 1.10 and the universal property of the free rigid category:

the functor F : G → Rel|U is uniquely deﬁned by its image on generators, i.e. on the basic
types b ∈ B and the dictionnary entries (w, t) ∈ ∆ seen as generating arrows w → t.

Hence, a concrete RelCoCat model F : G → Rel is fully specified by a finite
, called a pregroup lexicon in [6]. This allows

set of triples { w : t :: F (w → t) }(w,t)∈∆
us to define Semantics as a function problem with RelCoCat models as input.

Deﬁnition 3.2. Semantics

r ∈ G(u, s), F : G → Rel|U

Input:
Output: F (r) ⊆ U F (s)

Lemma 3.3. Every concrete RelCoCat model F : G → Rel|U factorises as F = K ◦ L
for a relational model K ∈ M∆(U ) and a rigid monoidal functor L : G → CB(∆).

Proof. By propositions 2.9 and 3.1, F : G → Rel|U induces a morphism of Cartesian
bicategories K : CB(∆) → Rel|U . The functor L : G → CB(∆) sends each dictionnary
entry to itself as a relational symbol, by construction we have K ◦ L = F .

7

Proposition 3.4. There is a logspace reduction from Semantics to conjunctive query
Evaluation, hence Semantics ∈ NP.

Proof. The factorisation K ◦ L = F of lemma 3.3 and the translation Λ of theorem 2.8
are in logspace, they give a query ϕ = Λ(L(r)) ∈ Q∆ such that eval(ϕ, K) = F (r).

We conjecture that the constraint language induced by a pregroup grammar

meets the tractability condition for the CSP dichotomy theorem [18].

Conjecture 3.5. Fix G = (V, B, ∆), Semantics is poly-time computable in the size of
(u, s) ∈ List(V ) × P (B) and in the size of the universe U .

We can also consider abstract RelCoCat models, i.e. a rigid monoidal functors
L : G → C for a finitely presented Cartesian bicategory C. For example, take C
to be generated by the signature Σ = { Leib, Spin, phil, . . . } as 1-arrows with
codomain given by the function ar : Σ → N and the following set of 2-arrows:

read

≤

infl

Leib

≤

disc

calc

phil

≤

The 2-arrows of C encode existential rules of the form ∀ x0 · · · ∀ xk · ϕ → ϕ0
for two conjunctive queries ϕ, ϕ0 with fv(ϕ) = fv(ϕ0) = { x0, . . . , xk }, also called
tuple-generating dependencies in database theory, see [19] for a survey. The

composition of 2-arrows in C then allow us to compute entailment, e.g.:

Leib

read

Spin

≤

Leib

infl

Spin

≤

Spin

infl

Leib

≤

Spin

infl

Leib

Leib

≤

Spin

infl

phil

disc

calc

where the second and third inequations follow from the axioms of definition 2.7

(adjointness and lax comonoidality), the first and last from the generators.

8

Deﬁnition 3.6. Entailment

r ∈ G(u, s),
Input:
Output: L(r) ≤ L(r0)

r0 ∈ G(u0, s), L : G → C

Proposition 3.7. Entailment is undecidable for ﬁnitely presented Cartesian bicategories.
When C is freely generated, the problem reduces to conjunctive query Containment.

Proof. Entailment of conjunctive queries under existential rules is undecidable, see [20].

When C = CB(Σ) is freely generated by a relational signature Σ, i.e. with no existential
rules, theorem 2.8 yields a logspace reduction to Containment: Entailment ∈ NP.

Abstract RelCoCat models in free Cartesian bicategories make Entailment a
decidable problem, they also allow us to reformulate lemma 3.3 as follows:

every concrete model F : G → Rel factorises as F = K ◦ L for an abstract model
L : G → CB(Σ) and a relational model K : CB(Σ) → Rel. In the next section,
we use this fact to define QuestionAnswering as a computational problem.

4 Question Answering as an NP-complete Problem

We consider the following computational problem: given a natural language

corpus and a question, does the corpus contain an answer? We show how to

translate a corpus into a relational database so that question answering re-

duces to query evaluation. We fix an abstract RelCoCat model L : G → CB(Σ)
with L(s) = 0, i.e. grammatical sentences are mapped to closed formulae. We
assume that L(q) = L(a) for q and a the question and answer types respectively,
i.e. both are mapped to queries with the same number of free variable.

Lexical items such as “influence” and “Leibniz” are mapped to their own

symbol in the relational signature Σ, whereas functional words such as relative

pronouns are sent to the Frobenius algebra of CB(Σ), see [21].

We define a corpus as a set of sentences u ∈ List(V ) with parsing r : u → s
in G, i.e. a subset C ⊆ ‘
u∈List(V ) G(u, s). If we apply L independently to each
sentence, the resulting queries have disjoint sets of variables. In order to obtain

the desired database, we need to map variables to some designated entities: a

standard natural language processing task called entity linking (EL).

Let ϕC = V

Λ(L(r)) be the conjunction of each sentence in the corpus,
where Λ is the translation from diagrams to conjunctive queries of theorem 2.8.

r∈C

We define an entity linking for C as a function µ : var(ϕC) → E for some finite

9

set E of entities. Thus, we get the following algorithm for translating the
corpus C with entity linking µ : var(ϕC) → E into a model:

1. translate each parsed sentence r ∈ C into a conjunctive query Λ(L(r)) ∈ Q∆,

2. compute their conjunction ϕC = V

r∈C

Λ(L(r)) and the substitution µ(ϕC),

3. construct the corresponding canonical model K = CM (µ(ϕC)) ∈ MΣ(E).

Deﬁnition 4.1. QuestionAnswering

Input:

Output:

u∈List(V ) G(u, s), µ : var(ϕC) → E, ϕ ∈ QΣ

C ⊆ ‘
eval(ϕ, K) ⊆ Efv(ϕ) where K = CM (µ(ϕC))

Theorem 4.2. QuestionAnswering is NP − complete.

Proof. Membership follows immediately by reduction to Evaluation. Hardness follows
by reduction from graph homomorphism, we only give a sketch of proof and refer to [4]

where EL is called matching. Any graph can be encoded in a corpus given by a set of

subject-verb-object sentences, where EL maps nouns to their corresponding node.

Example 4.3. We take L : G → CB(Σ) to map the question word “Who” to the compact-
closed structure, the determinant “a” to the unit and the common noun “philosopher” to

the symbol phil ∈ Σ composed with the comonoid. We can now ﬁnd the nouns that answer
the question r ∈ G(u, q) of example 1.11 as the evaluation of the following query:

L(r) =

Who

inﬂ

a

phil

who

disc

calc

?

Λ(L(r)) = ∃ x1 ∃ x2 · inf l(x0, x1) ∧ phil(x1) ∧ disc(x1, x2) ∧ calc(x2)

If “Spinoza inﬂuenced the philosopher Leibniz” and “Leibniz discovered calculus” are

in the corpus C, we have L(Spinoza → n) ∈ QuestionAnswering(C, µ, Λ(L(r))).

We conclude with related work and potential directions for future work:

• text summarisation through conjunctive query minimisation [22],

• semantics of “How many?” questions and counting problems [23],

• many-sorted RelCoCat models with graphical regular logic [24],

10

• from Boolean semantics to generalised relations in arbitrairy topoi [25],

• from regular logic to description logics in bicategories of relations [26],

• comonadic semantics for bounded short-term memory [27],

• quantum speedup for question answering via Grover’s search [28].

Acknowledgments

The authors would like to thank Bob Coecke, Dan Marsden, Antonin Delpeuch, Vincent Wang,

Jacob Leygonie, Dusko Pavlovic, Rui Soares Barbosa and Samson Abramsky for inspiring dis-

cussions in the process of writing this article, as well as anonymous Reviewers of ACT2019 for

constructive comments that improved the presentation of this work. K.M. is supported by the

EPSRC NQIT Hub and Cambridge Quantum Computing Ltd. A.T. acknowledges Simon Harrison

for financial DPhil support.

References

[1] Stephen Clark, Bob Coecke, and Mehrnoosh Sadrzadeh. A Compositional Distributional

Model of Meaning. In Proceedings of the Second Symposium on Quantum Interaction (QI-2008),
pages 133–140, 2008.

[2] Ashok K. Chandra and Philip M. Merlin. Optimal implementation of conjunctive queries in

relational data bases. In Proceedings of the Ninth Annual ACM Symposium on Theory of Com-
puting - STOC ’77, pages 77–90, Boulder, Colorado, United States, 1977. ACM Press.

[3] Filippo Bonchi, Jens Seeber, and Pawel Sobocinski. Graphical Conjunctive Queries.

arXiv:1804.07626 [cs], April 2018.

[4] Bob Coecke, Giovanni de Felice, Dan Marsden, and Alexis Toumi. Towards Composi-

tional Distributional Discourse Analysis. Electronic Proceedings in Theoretical Computer Sci-
ence, 283:1–12, November 2018.

[5] Anne Preller and Mehrnoosh Sadrzadeh. Semantic Vector Models and Functional Models

for Pregroup Grammars. Journal of Logic, Language and Information, 20(4):419–443, 2011.

[6] Anne Preller. Natural language semantics in biproduct dagger categories. J. Applied Logic,

12(1):88–108, 2014.

[7] Anne Preller. From Logical to Distributional Models. Electronic Proceedings in Theoretical

Computer Science, 171:113–131, December 2014.

[8] Mehrnoosh Sadrzadeh, Dimitri Kartsaklis, and Esma Balkır.

Sentence entailment in

compositional distributional semantics. Annals of Mathematics and Artificial Intelligence,
82(4):189–218, April 2018.

[9] Joachim Lambek. Type Grammar Revisited. In Alain Lecomte, François Lamarche, and Guy

Perrier, editors, Logical Aspects of Computational Linguistics, pages 1–27, Berlin, Heidelberg,
1999. Springer Berlin Heidelberg.

11

[10] Wojciech Buszkowski and Katarzyna Moroz. Pregroup Grammars and Context-free Gram-

mars. Computational Algebraic Approaches to Natural Language, Polimetrica, 121, 2008.

[11] Anne Preller and Joachim Lambek. Free compact 2-categories. Mathematical Structures in

Computer Science, 17(2):309–340, 2007.

[12] André Joyal and Ross Street. Planar diagrams and tensor algebra. 1988.

[13] P. Selinger. A Survey of Graphical Languages for Monoidal Categories. New Structures for

[14] R Oehrle. A parsing algorithm for pregroup grammars. Proceedings of Categorial Grammars

Physics, pages 289–355, 2010.

2004, pages 59–75, January 2004.

Symbolic Logic, 87(2/3):171–197, 2007.

[15] Anne Preller. Linear Processing with Pregroups. Studia Logica: An International Journal for

[16] Michael R. Garey and David S. Johnson. Computers and Intractability; A Guide to the Theory of

NP-Completeness. W. H. Freeman & Co., New York, NY, USA, 1990.

[17] A. Carboni and R. F. C. Walters. Cartesian bicategories I. Journal of Pure and Applied Algebra,

[18] Andrei A. Bulatov. A dichotomy theorem for nonuniform CSPs. arXiv:1703.03021 [cs], March

49(1):11–32, November 1987.

2017.

[19] Michaël Thomazo. Conjunctive Query Answering Under Existential Rules - Decidability, Com-

plexity, and Algorithms. PhD thesis, October 2013.

[20] J. F. Baget and M. L. Mugnier. Extensions of Simple Conceptual Graphs: The Complexity

of Rules and Constraints. Journal of Artificial Intelligence Research, 16:425–465, June 2002.

[21] Mehrnoosh Sadrzadeh, Stephen Clark, and Bob Coecke. The Frobenius anatomy of word

meanings I: Subject and object relative pronouns. Journal of Logic and Computation, 23:1293–
1317, 2013.

[22] Chandra Chekuri and Anand Rajaraman. Conjunctive query containment revisited. Theo-

retical Computer Science, page 19, 2000.

[23] Giorgio Stefanoni, Boris Motik, and Egor V. Kostylev. Estimating the Cardinality of Con-

junctive Queries over RDF Data Using Graph Summarisation.

In Proceedings of the 2018
World Wide Web Conference on World Wide Web, WWW 2018, Lyon, France, April 23-27, 2018, pages
1043–1052, 2018.

[24] Brendan Fong and David I. Spivak. Graphical Regular Logic. arXiv:1812.05765 [cs, math],

December 2018.

[25] Bob Coecke, Fabrizio Genovese, Martha Lewis, Dan Marsden, and Alex Toumi. Generalized

relations in linguistics & cognition. Theoretical Computer Science, 2018.

[26] Evan Patterson. Knowledge Representation in Bicategories of Relations. arXiv:1706.00526

[cs, math], June 2017.

[27] Samson Abramsky and Nihil Shah. Relating Structure and Power: Comonadic Semantics

for Computational Resources. arXiv:1806.09031 [cs], June 2018.

[28] William Zeng and Bob Coecke. Quantum Algorithms for Compositional Natural Language

Processing. Electronic Proceedings in Theoretical Computer Science, 221:67–75, August 2016.

12

