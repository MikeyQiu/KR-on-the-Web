9
1
0
2
 
p
e
S
 
6
2
 
 
]
I

A
.
s
c
[
 
 
1
v
8
3
2
2
1
.
9
0
9
1
:
v
i
X
r
a

Preprint

V-MPO: ON-POLICY MAXIMUM A POSTERIORI
POLICY OPTIMIZATION FOR DISCRETE AND
CONTINUOUS CONTROL

H. Francis Song∗, Abbas Abdolmaleki∗, Jost Tobias Springenberg, Aidan Clark,
Hubert Soyer, Jack W. Rae, Seb Noury, Arun Ahuja, Siqi Liu, Dhruva Tirumala,
Nicolas Heess, Dan Belov, Martin Riedmiller, Matthew M. Botvinick
DeepMind, London, UK
{songf,aabdolmaleki,springenberg,aidanclark,
soyer,jwrae,snoury,arahuja,liusiqi,dhruvat,
heess,danbelov,riedmiller,botvinick}@google.com

ABSTRACT

Some of the most successful applications of deep reinforcement learning to chal-
lenging domains in discrete and continuous control have used policy gradient
methods in the on-policy setting. However, policy gradients can suffer from large
variance that may limit performance, and in practice require carefully tuned entropy
regularization to prevent policy collapse. As an alternative to policy gradient algo-
rithms, we introduce V-MPO, an on-policy adaptation of Maximum a Posteriori
Policy Optimization (MPO) that performs policy iteration based on a learned state-
value function. We show that V-MPO surpasses previously reported scores for both
the Atari-57 and DMLab-30 benchmark suites in the multi-task setting, and does so
reliably without importance weighting, entropy regularization, or population-based
tuning of hyperparameters. On individual DMLab and Atari levels, the proposed
algorithm can achieve scores that are substantially higher than has previously been
reported. V-MPO is also applicable to problems with high-dimensional, continuous
action spaces, which we demonstrate in the context of learning to control simulated
humanoids with 22 degrees of freedom from full state observations and 56 degrees
of freedom from pixel observations, as well as example OpenAI Gym tasks where
V-MPO achieves substantially higher asymptotic scores than previously reported.

1

INTRODUCTION

Deep reinforcement learning (RL) with neural network function approximators has achieved superhu-
man performance in several challenging domains (Mnih et al., 2015; Silver et al., 2016; 2018). Some
of the most successful recent applications of deep RL to difﬁcult environments such as Dota 2 (Ope-
nAI, 2018a), Capture the Flag (Jaderberg et al., 2019), Starcraft II (DeepMind, 2019), and dexterous
object manipulation (OpenAI, 2018b) have used policy gradient-based methods such as Proximal
Policy Optimization (PPO) (Schulman et al., 2017) and the Importance-Weighted Actor-Learner
Architecture (IMPALA) (Espeholt et al., 2018), both in the approximately on-policy setting.

Policy gradients, however, can suffer from large variance that may limit performance, especially for
high-dimensional action spaces (Wu et al., 2018). In practice, moreover, policy gradient methods
typically employ carefully tuned entropy regularization in order to prevent policy collapse. As an
alternative to policy gradient-based algorithms, in this work we introduce an approximate policy
iteration algorithm that adapts Maximum a Posteriori Policy Optimization (MPO) (Abdolmaleki et al.,
2018a;b) to the on-policy setting. The modiﬁed algorithm, V-MPO, relies on a learned state-value
function V (s) instead of the state-action value function used in MPO. Like MPO, rather than directly
updating the parameters in the direction of the policy gradient, V-MPO ﬁrst constructs a target
distribution for the policy update subject to a sample-based KL constraint, then calculates the gradient
that partially moves the parameters toward that target, again subject to a KL constraint.

∗Equal contribution

1

Preprint

As we are particularly interested in scalable RL algorithms that can be applied to multi-task settings
where a single agent must perform a wide variety of tasks, we show for the case of discrete actions
that the proposed algorithm surpasses previously reported performance in the multi-task setting for
both the Atari-57 (Bellemare et al., 2012) and DMLab-30 (Beattie et al., 2016) benchmark suites,
and does so reliably without population-based tuning of hyperparameters (Jaderberg et al., 2017a).
For a few individual levels in DMLab and Atari we also show that V-MPO can achieve scores that
are substantially higher than has previously been reported, especially in the challenging Ms. Pacman.

V-MPO is also applicable to problems with high-dimensional, continuous action spaces. We demon-
strate this in the context of learning to control both a 22-dimensional simulated humanoid from full
state observations—where V-MPO reliably achieves higher asymptotic performance than previous
algorithms—and a 56-dimensional simulated humanoid from pixel observations (Tassa et al., 2018;
Merel et al., 2019). In addition, for several OpenAI Gym tasks (Brockman et al., 2016) we show that
V-MPO achieves higher asymptotic performance than has previously been reported.

2 BACKGROUND AND SETTING

We consider the discounted RL setting, where we seek to optimize a policy π for a Markov Decision
Process described by states s, actions a, initial state distribution ρenv
0 (s0), transition probabilities
P env(st+1|st, at), reward function r(st, at), and discount factor γ ∈ (0, 1). In deep RL, the policy
πθ(at|st), which speciﬁes the probability that the agent takes action at in state st at time t, is
described by a neural network with parameters θ. We consider problems where both the states
s and actions a may be discrete or continuous. Two functions play a central role in RL: the
(cid:2) (cid:80)∞
k=0 γkr(st+k, at+k)(cid:3) and the state-action value
state-value function V π(st) = Eat,st+1,at+1,...
(cid:2)V π(st+1)(cid:3),
function Qπ(st, at) = Est+1,at+1,...
where s0 ∼ ρenv

(cid:2) (cid:80)∞
0 (s0), at ∼ π(at|st), and st+1 ∼ P env(st+1|st, at).

k=0 γkr(st+k, at+k)(cid:3) = r(st, at) + γEst+1

(cid:2) (cid:80)∞

In the usual formulation of the RL problem, the goal is to ﬁnd a policy π that maximizes the expected
t=0 γtr(st, at)(cid:3). In policy gradient algorithms (Williams,
return given by J(π) = Es0,a0,s1,a1,...
1992; Sutton et al., 2000; Mnih et al., 2016), for example, this objective is directly optimized by
estimating the gradient of the expected return. An alternative approach to ﬁnding optimal policies
derives from research that treats RL as a problem in probabilistic inference, including Maximum
a Posteriori Policy Optimization (MPO) (Levine, 2018; Abdolmaleki et al., 2018a;b). Here our
objective is subtly different, namely, given a suitable criterion for what are good actions to take in a
certain state, how do we ﬁnd a policy that achieves this goal?

As was the case for the original MPO algorithm, the following derivation is valid for any such
criterion. However, the policy improvement theorem (Sutton & Barto, 1998) tells us that a policy
update performed by exact policy iteration, π(s) = arg maxa[Qπ(s, a) − V π(s)], can improve the
policy if there is at least one state-action pair with a positive advantage and nonzero probability of
visiting the state. Motivated by this classic result, in this work we speciﬁcally choose an exponential
function of the advantages Aπ(s, a) = Qπ(s, a) − V π(s).
Notation. In the following we use (cid:80)
over states s and actions a depending on the setting. A sum with indices only, such as (cid:80)
a sum over all possible states and actions, while (cid:80)
states and actions from a batch of trajectories (the “dataset”) D.

s,a to indicate both discrete and continuous sums (i.e., integrals)
s,a, denotes
s,a∼D, for example, denotes a sum over sample

3 RELATED WORK

V-MPO shares many similarities, and thus relevant related work, with the original MPO algorithm (Ab-
dolmaleki et al., 2018a;b). In particular, the general idea of using KL constraints to limit the size of
policy updates is present in both Trust Region Policy Optimization (TRPO; Schulman et al., 2015) and
Proximal Policy Optimization (PPO) (Schulman et al., 2017); we note, however, that this corresponds
to the E-step constraint in V-MPO. Meanwhile, the introduction of the M-step KL constraint and the
use of top-k advantages distinguishes V-MPO from Relative Entropy Policy Search (REPS) (Peters
et al., 2008). Interestingly, previous attempts to use REPS with neural network function approximators
reported very poor performance, being particularly prone to local optima (Duan et al., 2016). In

2

Preprint

4 METHOD

contrast, we ﬁnd that the principles of EM-style policy optimization, when combined with appropriate
constraints, can reliably train powerful neural networks, including transformers, for RL tasks.

Like V-MPO, Supervised Policy Update (SPU) (Vuong et al., 2019) seeks to exactly solve an
optimization problem and ﬁt the parametric policy to this solution. As we argue in Appendix D,
however, SPU uses this nonparametric distribution quite differently from V-MPO; as a result, the
ﬁnal algorithm is closer to a policy gradient algorithm such as PPO.

V-MPO is an approximate policy iteration (Sutton & Barto, 1998) algorithm with a speciﬁc prescrip-
tion for the policy improvement step. In general, policy iteration uses the fact that the true state-value
function V π corresponding to policy π can be used to obtain an improved policy π(cid:48). Thus we can

1. Generate trajectories τ from an old “target” policy πθold(a|s) whose parameters θold are ﬁxed.
To control the amount of data generated by a particular policy, we use a target network
which is ﬁxed for Ttarget learning steps (Fig. 5a in the Appendix).

2. Evaluate the policy πθold (a|s) by learning the value function V πθold (s) from empirical returns
and estimating the corresponding advantages Aπθold (s, a) for the actions that were taken.

3. Estimate an improved “online” policy πθ(a|s) based on Aπθold (s, a).

The ﬁrst two steps are standard, and describing V-MPO’s approach to step (3) is the essential
contribution of this work. At a high level, our strategy is to ﬁrst construct a nonparametric target
distribution for the policy update, then partially move the parametric policy towards this distribution
subject to a KL constraint. Ultimately, we use gradient descent to optimize a single, relatively simple
loss, which we provide here in complete form in order to ground the derivation of the algorithm.

Consider a batch of data D consisting of a number of trajectories, with |D|
total state-
Each trajectory consists of an unroll of length n of the form τ =
action samples.
(cid:2)(st, at, rt+1), . . . , (st+n−1, at+n−1, rt+n), st+n
(cid:3) including the bootstrapped state st+n, where
rt+1 = r(st, at). The total loss is the sum of a policy evaluation loss and a policy improvement loss,
L(φ, θ, η, α) = LV (φ) + LV-MPO(θ, η, α),
(1)
where φ are the parameters of the value network, θ the parameters of the policy network, and η and α
are Lagrange multipliers. In practice, the policy and value networks share most of their parameters in
the form of a shared convolutional network (a ResNet) and recurrent LSTM core, and are optimized
together (Fig. 5b in the Appendix) (Mnih et al., 2016). We note, however, that the value network
parameters φ are considered ﬁxed for the policy improvement loss, and gradients are not propagated.

The policy evaluation loss for the value function, LV (φ), is the standard regression to n-step returns
and is given by Eq. 6 below. The policy improvement loss LV-MPO(θ, η, α) is given by

Here the policy loss is the weighted maximum likelihood loss

LV-MPO(θ, η, α) = Lπ(θ) + Lη(η) + Lα(θ, α).

Lπ(θ) = −

ψ(s, a) log πθ(a|s),

ψ(s, a) =

(cid:88)

s,a∼ ˜D

(cid:1)

exp (cid:0) Atarget(s,a)
s,a∼ ˜D exp (cid:0) Atarget(s,a)

η

η

(cid:1) ,

(cid:80)

where the advantages Atarget(s, a) for the target network policy πθtarget(a|s) are estimated according to
the standard method described below. The tilde over the dataset, ˜D, indicates that we take samples
corresponding to the top half advantages in the batch of data. The η, or “temperature”, loss is

Lη(η) = η(cid:15)η + η log

(cid:34)

1
| ˜D|

(cid:88)

exp

s,a∼ ˜D

(cid:18) Atarget(s, a)
η

(cid:19)(cid:35)

.

The KL constraint, which can be viewed as a form of trust-region loss, is given by

Lα(θ, α) =

(cid:88)

(cid:104)

α(cid:0)(cid:15)α − sg (cid:2)(cid:2)DKL

(cid:0)πθtarget(a|s)(cid:107)πθ(a|s)(cid:1)(cid:3)(cid:3)(cid:17)

+ sg[[α]]DKL

(cid:0)πθtarget(a|s)(cid:107)πθ(a|s)(cid:1)(cid:105)

,

1
|D|

s∈D

(2)

(3)

(4)

(5)

3

Preprint

where sg[[·]] indicates a stop gradient, i.e., that the enclosed term is assumed constant with respect to
all variables. Note that here we use the full batch D, not ˜D.

We used the Adam optimizer (Kingma & Ba, 2015) with default TensorFlow hyperparameters to
optimize the total loss in Eq. 1. In particular, the learning rate was ﬁxed at 10−4 for all experiments.

4.1 POLICY EVALUATION

In the present setting, policy evaluation means learning an approximate state-value function V π(s)
given a policy π(a|s), which we keep ﬁxed for Ttarget learning steps (i.e., batches of trajectories). We
note that the value function corresponding to the target policy is instantiated in the “online” network
receiving gradient updates; bootstrapping uses the online value function, as it is the best available
estimate of the value function for the target policy. Thus in this section π refers to πθold, while the
value function update is performed on the current φ, which may share parameters with the current θ.
We ﬁt a parametric value function V π

φ (s) with parameters φ by minimizing the squared loss

LV (φ) =

1
2|D|

(cid:88)

st∼D

(cid:0)V π

φ (st) − G(n)

t

(cid:1)2

,

(6)

t

where G(n)
is the standard n-step target for the value function at state st at time t (Sutton & Barto,
1998). This return uses the actual rewards in the trajectory and bootstraps from the value function for
the rest: for each (cid:96) = t, . . . , t + n − 1 in an unroll, G(n)
φ (st+n).
The advantages, which are the key quantity of interest for the policy improvement step in V-MPO,
are then given by Aπ(st, at) = G(n)

φ (st) for each st, at in the batch of trajectories.

γk−(cid:96)rk + γt+n−(cid:96)V π

(cid:96) = (cid:80)t+n−1

t − V π

k=(cid:96)

PopArt normalization. As we are interested in the multi-task setting where a single agent must learn a
large number of tasks with differing reward scales, we used PopArt (van Hasselt et al., 2016; Hessel
et al., 2018) for the value function, even when training on a single task. Speciﬁcally, the value
function outputs a separate value for each task in normalized space, which is converted to actual
returns by a shift and scaling operation, the statistics of which are learned during training. We used
a scale lower bound of 10−2, scale upper bound of 106, and learning rate of 10−4 for the statistics.
The lower bound guards against numerical issues when rewards are extremely sparse.

Importance-weighting for off-policy data. It is possible to importance-weight the samples using
V-trace to correct for off-policy data (Espeholt et al., 2018), for example when data is taken from
a replay buffer. For simplicity, however, no importance-weighting was used for the experiments
presented in this work, which were mostly on-policy.

4.2 POLICY IMPROVEMENT IN V-MPO

In this section we show how, given the advantage function Aπθold (s, a) for the state-action distribution
pθold (s, a) = πθold(a|s)p(s) induced by the old policy πθold(a|s), we can estimate an improved policy
πθ(a|s). More formally, let I denote the binary event that the new policy is an improvement (in a
sense to be deﬁned below) over the previous policy: I = 1 if the policy is successfully improved
and 0 otherwise. Then we would like to ﬁnd the mode of the posterior distribution over parameters θ
conditioned on this event, i.e., we seek the maximum a posteriori (MAP) estimate

θ∗ = arg max

(cid:2) log pθ(I = 1) + log p(θ)(cid:3),

θ

(7)

where we have written p(I = 1|θ) as pθ(I = 1) to emphasize the parametric nature of the dependence
(cid:0)ψ(Z)(cid:107)p(Z|X)(cid:1) for
on θ. We use the well-known identity log p(X) = Eψ(Z)
any latent distribution ψ(Z), where DKL(ψ(Z)(cid:107)p(Z|X)) is the Kullback-Leibler divergence between
ψ(Z) and p(Z|X) with respect to Z, and the ﬁrst term is a lower bound because the KL divergence
is always non-negative. Then considering s, a as latent variables,

(cid:2) log p(X,Z)

(cid:3) + DKL

ψ(Z)

log pθ(I = 1) =

ψ(s, a) log

(cid:88)

s,a

pθ(I = 1, s, a)
ψ(s, a)

+ DKL

(cid:0)ψ(s, a)(cid:107)pθ(s, a|I = 1)(cid:1).

(8)

Policy improvement in V-MPO consists of the following two steps which have direct correspondences
to the expectation maximization (EM) algorithm (Neal & Hinton, 1998): In the expectation (E) step,

4

Preprint

4.2.1 E-STEP

we choose the variational distribution ψ(s, a) such that the lower bound on log pθ(I = 1) is as tight
as possible, by minimizing the KL term. In the maximization (M) step we then ﬁnd parameters θ that
maximize the corresponding lower bound, together with the prior term in Eq. 7.

In the E-step, our goal is to choose the variational distribution ψ(s, a) such that the lower bound on
log pθ(I = 1) is as tight as possible, which is the case when the KL term in Eq. 8 is zero. Given the
old parameters θold, this simply leads to ψ(s, a) = pθold(s, a|I = 1), or

ψ(s, a) =

pθold(s, a)pθold(I = 1|s, a)
pθold (I = 1)

,

(cid:88)

s,a

pθold(I = 1) =

pθold(s, a)pθold(I = 1|s, a).

(9)

Intuitively, this solution weights the probability of each state-action pair with its relative improvement
probability pθold(I = 1|s, a). We now choose a distribution pθold(I = 1|s, a) that leads to our desired
outcome. As we prefer actions that lead to a higher advantage in each state, we suppose that this
probability is given by

pθold(I = 1|s, a) ∝ exp

(cid:18) Aπθold (s, a)
η

(cid:19)

(10)

for some temperature η > 0, from which we obtain the equation on the right in Eq. 3. This probability
depends on the old parameters θold and not on the new parameters θ. Meanwhile, the value of η
allows us to control the diversity of actions that contribute to the weighting, but at the moment is
arbitrary. It turns out, however, that we can tune η as part of the optimization, which is desirable
since the optimal value of η changes across iterations. The convex loss that achieves this, Eq. 4, is
derived in Appendix A by minimizing the KL term in Eq. 8 subject to a hard constraint on ψ(s, a).

Top-k advantages. We found that learning improves substantially if we take only the samples
corresponding to the highest 50% of advantages in each batch for the E-step, corresponding to the
use of ˜D rather than D in Eqs. 3, 4. Importantly, these must be consistent between the maximum
likelihood weights in Eq. 3 and the temperature loss in Eq. 4, since, mathematically, this is justiﬁed
by choosing the corresponding policy improvement probability in Eq. 10 to only use the top half of
the advantages. This is similar to the technique used in Covariance Matrix Adaptation - Evolutionary
Strategy (CMA-ES) (Hansen et al., 1997; Abdolmaleki et al., 2017), and is a special case of the more
general feature that any rank-preserving transformation is allowed under this formalism.

Importance weighting for off-policy corrections. As for the value function, importance weights can be
used in the policy improvement step to correct for off-policy data. While not used for the experiments
presented in this work, details for how to carry out this correction are given in Appendix E.

4.2.2 M-STEP: CONSTRAINED SUPERVISED LEARNING OF THE PARAMETRIC POLICY

In the E-step we found the nonparametric variational state-action distribution ψ(s, a), Eq. 9, that
gives the tightest lower bound to pθ(I = 1) in Eq. 8. In the M-step we maximize this lower bound
together with the prior term log p(θ) with respect to the parameters θ, which effectively leads to a
constrained weighted maximum likelihood problem. Thus the introduction of the nonparametric
distribution in Eq. 9 separates the RL procedure from the neural network ﬁtting.

We would like to ﬁnd new parameters θ that minimize

L(θ) = −

ψ(s, a) log

− log p(θ).

(11)

(cid:88)

s,a

pθ(I = 1, s, a)
ψ(s, a)

Note, however, that so far we have worked with the joint state-action distribution ψ(s, a) while
we are in fact optimizing for the policy, which is the conditional distribution πθ(a|s). Writing
pθ(s, a) = πθ(a|s)p(s) since only the policy is parametrized by θ and dropping terms that are not
parametrized by θ, the ﬁrst term of Eq. 11 is seen to be the weighted maximum likelihood policy loss

Lπ(θ) = −

ψ(s, a) log πθ(a|s).

(12)

In the sample-based computation of this loss, we assume that any state-action pairs not in the batch
of trajectories have zero weight, leading to the normalization in Eq. 3.

(cid:88)

s,a

5

Preprint

As in the original MPO algorithm, a useful prior is to keep the new policy πθ(a|s) close to the old
(cid:0)πθold (a|s)(cid:107)πθ(a|s)(cid:1)(cid:3). While intuitive, we motivate
policy πθold(a|s): log p(θ) ≈ −αEs∼p(s)
this more formally in Appendix B. It is again more convenient to specify a bound on the KL divergence
instead of tuning α directly, so we solve the constrained optimization problem

(cid:2)DKL

θ∗ = arg min

−

θ

(cid:88)

s,a

ψ(s, a) log πθ(a|s)

s.t.

E
s∼p(s)

(cid:104)
DKL

(cid:0)πθold(a|s)(cid:107)πθ(a|s)(cid:1)(cid:105)

< (cid:15)α.

(13)

Intuitively, the constraint in the E-step expressed by Eq. 19 in Appendix A for tuning the temperature
only constrains the nonparametric distribution; it is the constraint in Eq. 13 that directly limits the
change in the parametric policy, in particular for states and actions that were not in the batch of
samples and which rely on the generalization capabilities of the neural network function approximator.

To make the constrained optimization problem amenable to gradient descent, we use Lagrangian
relaxation to write the unconstrained objective as

J (θ, α) = Lπ(θ) + α

(cid:18)

(cid:15)α − E

s∼p(s)

(cid:104)
DKL

(cid:0)πθold(a|s)(cid:107)πθ(a|s)(cid:1)(cid:105)(cid:19)

,

(14)

which we can optimize by following a coordinate-descent strategy, alternating between the optimiza-
tion over θ and α. Thus, in addition to the policy loss we arrive at the constraint loss

Lα(θ, α) = α

(cid:18)

(cid:15)α − E

s∼p(s)

(cid:104)

sg (cid:2)(cid:2)DKL

(cid:0)πθold(cid:107)πθ

(cid:1)(cid:3)(cid:3)(cid:105)(cid:19)

+ sg[[α]] E

s∼p(s)

(cid:104)
DKL

(cid:0)πθold(cid:107)πθ

(cid:1)(cid:105)

.

(15)

Replacing the sum over states with samples gives Eq. 5. Since η and α are Lagrange multipliers that
must be positive, after each gradient update we project the resulting η and α to a small positive value
which we choose to be ηmin = αmin = 10−8 throughout the results presented below.

For continuous action spaces parametrized by Gaussian distributions, we use decoupled KL constraints
for the M-step in Eq. 15 as in Abdolmaleki et al. (2018b); the precise form is given in Appendix C.

5 EXPERIMENTS

Details on the network architecture and hyperparameters used for each task are given in Appendix F.

5.1 DISCRETE ACTIONS: DMLAB, ATARI

DMLab. DMLab-30 (Beattie et al., 2016) is a collection of visually rich, partially observable 3D
environments played from the ﬁrst-person point of view. Like IMPALA, for DMLab we used pixel
control as an auxiliary loss for representation learning (Jaderberg et al., 2017b; Hessel et al., 2018).
However, we did not employ the optimistic asymmetric reward scaling used by previous IMPALA
experiments to aid exploration on a subset of the DMLab levels, by weighting positive rewards more
than negative rewards (Espeholt et al., 2018; Hessel et al., 2018; Kapturowski et al., 2019). Unlike in
Hessel et al. (2018) we also did not use population-based training (PBT) (Jaderberg et al., 2017a).
Additional details for the settings used in DMLab can be found in Table 5 of the Appendix.

Fig. 1a shows the results for multi-task DMLab-30, comparing the V-MPO learning curves to data
obtained from Hessel et al. (2018) for the PopArt IMPALA agent with pixel control. We note that the
result for V-MPO at 10B environment frames across all levels matches the result for the Recurrent
Replay Distributed DQN (R2D2) agent (Kapturowski et al., 2019) trained on individual levels for
10B environment steps per level. Fig. 2 shows example individual levels in DMLab where V-MPO
achieves scores that are substantially higher than has previously been reported, for both R2D2 and
IMPALA. The pixel-control IMPALA agents shown here were carefully tuned for DMLab and are
similar to the “experts” used in Schmitt et al. (2018); in all cases these results match or exceed
previously published results for IMPALA (Espeholt et al., 2018; Kapturowski et al., 2019).

Atari. The Atari Learning Environment (ALE) (Bellemare et al., 2012) is a collection of 57 Atari
2600 games that has served as an important benchmark for recent deep RL methods. We used the
standard preprocessing scheme and a maximum episode length of 30 minutes (108,000 frames), see
Table 6 in the Appendix. For the multi-task setting we followed Hessel et al. (2018) in setting the
discount to zero on loss of life; for the example single tasks we did not employ this trick, since it

6

Preprint

(a) Multi-task DMLab-30.

(b) Multi-task Atari-57.

Figure 1: (a) Multi-task DMLab-30. IMPALA results show 3 runs of 8 agents each; within a run
hyperparameters were evolved via PBT. For V-MPO each line represents a set of hyperparameters
that are ﬁxed throughout training. The ﬁnal result of R2D2+ trained for 10B environment steps
on individual levels (Kapturowski et al., 2019) is also shown for comparison (orange line). (b)
Multi-task Atari-57. In the IMPALA experiment, hyperparameters were evolved with PBT. For
V-MPO each of the 24 lines represents a set of hyperparameters that were ﬁxed throughout training,
and all runs achieved a higher score than the best IMPALA run. Data for IMPALA (“Pixel-PopArt-
IMPALA” for DMLab-30 and “PopArt-IMPALA” for Atari-57) was obtained from the authors of
Hessel et al. (2018). Each environment frame corresponds to 4 agent steps due to the action repeat.

Figure 2: Example levels from DMLab-30, compared to IMPALA and more recent results from
R2D2+, the larger, DMLab-speciﬁc version of R2D2 (Kapturowski et al., 2019). The IMPALA
results include hyperparameter evolution with PBT.

can prevent the agent from achieving the highest score possible by sacriﬁcing lives. Similarly, while
in the multi-task setting we followed previous work in clipping the maximum reward to 1.0, no
such clipping was applied in the single-task setting in order to preserve the original reward structure.
Additional details for the settings used in Atari can be found in Table 6 in the Appendix.

Fig. 1b shows the results for multi-task Atari-57, demonstrating that it is possible for a single agent
to achieve “superhuman“ median performance on Atari-57 in approximately 4 billion (∼70 million
per level) environment frames.

We also compare the performance of V-MPO on a few individual Atari levels to R2D2 (Kapturowski
et al., 2019), which previously achieved some of the highest scores reported for Atari. Again,
V-MPO can match or exceed previously reported scores while requiring fewer interactions with
the environment. In Ms. Pacman, the ﬁnal performance approaches 300,000 with a 30-minute
timeout (and the maximum 1M without), effectively solving the game. Inspired by the argument in
Kapturowski et al. (2019) that in a fully observable environment LSTMs enable the agent to utilize
more useful representations than is available in the immediate observation, for the single-task setting
we used a Transformer-XL (TrXL) (Dai et al., 2019) to replace the LSTM core. Unlike previous
work for single Atari levels, we did not employ any reward clipping (Mnih et al., 2015; Espeholt
et al., 2018) or nonlinear value function rescaling (Kapturowski et al., 2019).

7

Preprint

Figure 3: Example levels from Atari. In Breakout, V-MPO achieves the maximum score of 864
in every episode. No reward clipping was applied, and the maximum length of an episode was 30
minutes (108,000 frames). Supplementary video for Ms. Pacman: https://bit.ly/2lWQBy5

(a)

(b)

(c)

(d)

Figure 4: (a) Humanoid “run” from full state (Tassa et al., 2018) and (b) humanoid “gaps” from
pixel observations (Merel et al., 2019). Purple curves are the same runs but without parametric
KL constraints. Det. eval.: deterministic evaluation. Supplementary video for humanoid gaps:
https://bit.ly/2L9KZdS. (c)-(d) Example OpenAI Gym tasks.

5.2 CONTINUOUS CONTROL

To demonstrate V-MPO’s effectiveness in high-dimensional, continuous action spaces, here we
present examples of learning to control both a simulated humanoid with 22 degrees of freedom from
full state observations and one with 56 degrees of freedom from pixel observations (Tassa et al., 2018;
Merel et al., 2019). As shown in Fig. 4a, for the 22-dimensional humanoid V-MPO reliably achieves
higher asymptotic returns than has previously been reported, including for Deep Deterministic Policy
Gradients (DDPG) (Lillicrap et al., 2015), Stochastic Value Gradients (SVG) (Heess et al., 2015),
and MPO. These algorithms are far more sample-efﬁcient but reach a lower ﬁnal performance.

In the “gaps” task the 56-dimensional humanoid must run forward to match a target velocity of 4 m/s
and jump over the gaps between platforms by learning to actuate joints with position-control (Merel
et al., 2019). Previously, only an agent operating in the space of pre-learned motor primitives was
able to solve the task from pixel observations (Merel et al., 2018; 2019); here we show that V-MPO
can learn a challenging visuomotor task from scratch (Fig. 4b). For this task we also demonstrate the
importance of the parametric KL constraint, without which the agent learns poorly.

In Figs. 4c-d we also show that V-MPO achieves the highest asymptotic performance reported for
two OpenAI Gym tasks (Brockman et al., 2016). Again, MPO and Stochastic Actor-Critic (Haarnoja
et al., 2018) are far more sample-efﬁcient but reach a lower ﬁnal performance.

6 CONCLUSION

In this work we have introduced a scalable on-policy deep reinforcement learning algorithm, V-MPO,
that is applicable to both discrete and continuous control domains. For the results presented in this
work neither importance weighting nor entropy regularization was used; moreover, since the size of
neural network parameter updates is limited by KL constraints, we were also able to use the same
learning rate for all experiments. This suggests that a scalable, performant RL algorithm may not
require some of the tricks that have been developed over the past several years. Interestingly, both

8

Preprint

ACKNOWLEDGMENTS

REFERENCES

the original MPO algorithm for replay-based off-policy learning (Abdolmaleki et al., 2018a;b) and
V-MPO for on-policy learning are derived from similar principles, providing evidence for the beneﬁts
of this approach as an alternative to popular policy gradient-based methods.

We thank Lorenzo Blanco, Trevor Cai, Greg Wayne, Chloe Hillier, and Vicky Langston for their
assistance and support.

Abbas Abdolmaleki, Bob Price, Nuno Lau, Luis P Reis, and Gerhard Neumann. Deriving and
Improving CMA-ES with Information Geometric Trust Regions. Proceedings of the Genetic and
Evolutionary Computation Conference, 2017.

Abbas Abdolmaleki, Jost Tobias Springenberg, Jonas Degrave, Steven Bohez, Yuval Tassa, Dan
Belov, Nicolas Heess, and Martin Riedmiller. Relative Entropy Regularized Policy Iteration. arXiv
preprint, 2018a. URL https://arxiv.org/pdf/1812.02256.pdf.

Abbas Abdolmaleki, Jost Tobias Springenberg, Yuval Tassa, Remi Munos, Nicolas Heess, and Martin
Riedmiller. Maximum a Posteriori Policy Optimisation. Int. Conf. Learn. Represent., 2018b. URL
https://arxiv.org/pdf/1806.06920.pdf.

Anonymous Authors. Off-Policy Actor-Critic with Shared Experience Replay. Under review, Int.

Conf. Learn. Represent., 2019.

Charles Beattie, Joel Z Leibo, Denis Teplyashin, Tom Ward, Marcus Wainwright, Heinrich K¨uttler,
Andrew Lefrancq, Simon Green, V´ıctor Vald´es, Amir Sadik, et al. Deepmind Lab. arXiv preprint
arXiv:1612.03801, 2016.

Marc G. Bellemare, Yavar Naddaf, Joel Veness, and Michael Bowling. The Arcade Learning
Environment: An Evaluation Platform for General Agents. Journal of Artiﬁcial Intelligence
Research, 47, 2012.

Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and
Wojciech Zaremba. OpenAI Gym. arXiv preprint, 2016. URL http://arxiv.org/abs/
1606.01540.

Peter Buchlovsky, David Budden, Dominik Grewe, Chris Jones, John Aslanides, Frederic Besse,
Andy Brock, Aidan Clark, Sergio Gomez Colmenarejo, Aedan Pope, Fabio Viola, and Dan Belov.
TF-Replicator: Distributed Machine Learning for Researchers. arXiv preprint, 2019. URL
http://arxiv.org/abs/1902.00465.

Zihang Dai, Zhilin Yang, Yiming Yang, Jaime G. Carbonell, Quoc V. Le, and Ruslan Salakhutdinov.
Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context. arXiv preprint,
2019. URL http://arxiv.org/abs/1901.02860.

DeepMind.
URL
strategy-game-starcraft-ii/.

AlphaStar: Mastering the Real-Time Strategy Game StarCraft
II, 2019.
https://deepmind.com/blog/alphastar-mastering-real-time-

Yan Duan, Xi Chen, Rein Houthooft, John Schulman, and Pieter Abbeel. Benchmarking Deep
Reinforcement Learning for Continuous Control. arXiv preprint, 2016. URL http://arxiv.
org/abs/1604.06778.

Lasse Espeholt, Hubert Soyer, Remi Munos, Karen Simonyan, Volodymir Mnih, Tom Ward, Yotam
Doron, Vlad Firoiu, Tim Harley, Iain Dunning, Shane Legg, and Koray Kavukcuoglu. IMPALA:
Scalable Distributed Deep-RL with Importance Weighted Actor-Learner Architectures. arXiv
preprint, 2018. URL http://arxiv.org/abs/1802.01561.

Google. Cloud TPU, 2018. URL https://cloud.google.com/tpu/.

9

Preprint

Tuomas Haarnoja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. Soft Actor-Critic: Off-Policy
Maximum Entropy Deep Reinforcement Learning with a Stochastic Actor. arXiv preprint, 2018.
URL http://arxiv.org/abs/1801.01290.

Nikolaus Hansen, Andreas Ostermeier, and Andreas Ostermeier. Convergence Properties of Evolution
Strategies with the Derandomized Covariance Matrix Adaptation: CMA-ES. 1997. URL http:
//www.cmap.polytechnique.fr/˜nikolaus.hansen/CMAES2.pdf.

Nicolas Heess, Greg Wayne, David Silver, Timothy P. Lillicrap, Yuval Tassa, and Tom Erez. Learning
continuous control policies by stochastic value gradients. arXiv preprint, 2015. URL http:
//arxiv.org/abs/1510.09142.

Matteo Hessel, Hubert Soyer, Lasse Espeholt, Wojciech Czarnecki, Simon Schmitt, and Hado van
Hasselt. Multi-task Deep Reinforcement Learning with PopArt. arXiv preprint, 2018. URL
https://arxiv.org/pdf/1809.04474.pdf.

Max Jaderberg, Valentin Dalibard, Simon Osindero, Wojciech M. Czarnecki, Jeff Donahue, Ali
Razavi, Oriol Vinyals, Tim Green, Iain Dunning, Karen Simonyan, Chrisantha Fernando, and
Koray Kavukcuoglu. Population Based Training of Neural Networks. arXiv preprint, 2017a. URL
http://arxiv.org/abs/1711.09846.

Max Jaderberg, Volodymyr Mnih, Wojciech Marian Czarnecki, Tom Schaul, Joel Z Leibo, David
Silver, and Koray Kavukcuoglu. Reinforcement Learning with Unsupervised Auxiliary Tasks. Int.
Conf. Learn. Represent., 2017b. URL https://openreview.net/pdf?id=SJ6yPD5xg.

Max Jaderberg, Wojciech M. Czarnecki, Iain Dunning, Luke Marris, Guy Lever, Antonio Garcia
Casta˜neda, Charles Beattie, Neil C. Rabinowitz, Ari S. Morcos, Avraham Ruderman, Nico-
las Sonnerat, Tim Green, Louise Deason, Joel Z. Leibo, David Silver, Demis Hassabis, Ko-
ray Kavukcuoglu, and Thore Graepel. Human-level performance in 3d multiplayer games
with population-based reinforcement learning. Science, 364:859–865, 2019. URL https:
//science.sciencemag.org/content/364/6443/859.

Steven Kapturowski, Georg Ostrovski, John Quan, R´emi Munos, and Will Dabney. Recurrent
Experience Replay in Distributed Reinforcement Learning. Int. Conf. Learn. Represent., 2019.
URL https://openreview.net/pdf?id=r1lyTjAqYX.

Diederik P. Kingma and Jimmy Lei Ba. Adam: A method for stochastic optimization. Int. Conf.

Learn. Represent., 2015. URL https://arxiv.org/abs/1412.6980.

Sergey Levine. Reinforcement Learning and Control as Probabilistic Inference: Tutorial and Review.

arXiv preprint, 2018. URL http://arxiv.org/abs/1805.00909.

Timothy P. Lillicrap, Jonathan J. Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa,
David Silver, and Daan Wierstra. Continuous control with deep reinforcement learning. arXiv
preprint, 2015. URL http://arxiv.org/abs/1509.02971.

Josh Merel, Leonard Hasenclever, Alexandre Galashov, Arun Ahuja, Vu Pham, Greg Wayne,
Yee Whye Teh, and Nicolas Heess. Neural probabilistic motor primitives for humanoid con-
trol. arXiv preprint, 2018. URL http://arxiv.org/abs/1811.11711.

Josh Merel, Arun Ahuja, Vu Pham, Saran Tunyasuvunakool, Siqi Liu, Dhruva Tirumala, Nicolas
Int. Conf. Learn.

Heess, and Greg Wayne. Hierarchical Visuomotor Control of Humanoids.
Represent., 2019. URL https://openreview.net/pdf?id=BJfYvo09Y7.

Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare,
Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, Stig Petersen, Charles
Beattie, Amir Sadik, Ioannis Antonoglou, Helen King, Dharshan Kumaran, Daan Wierstra, Shane
Legg, and Demis Hassabis. Human-Level Control through Deep Reinforcement Learning. Nature,
518:529–533, 2015. URL http://dx.doi.org/10.1038/nature14236.

Volodymyr Mnih, Adri`a Puigdom`enech Badia, Mehdi Mirza, Alex Graves, Tim Harley, Timothy P
Lillicrap, David Silver, and Koray Kavukcuoglu. Asynchronous Methods for Deep Reinforcement
Learning. arXiv:1602.01783, 2016. URL http://arxiv.org/abs/1602.01783.

10

Preprint

Radford M. Neal and Geoffrey E. Hinton. A View of the EM Algorithm that Justiﬁes Incremental,
Sparse, and Other Variants. In M.I. Jordan (ed.), Learn. Graph. Model. NATO ASI Ser. vol. 89.
Springer, Dordrecht, 1998.

OpenAI. OpenAI Five, 2018a. URL https://openai.com/blog/openai-five/.

OpenAI. Learning Dexterity, 2018b. URL https://openai.com/blog/learning-

dexterity/.

Jan Peters, M Katharina, and Yasemin Alt¨un. Relative Entropy Policy Search. Proceedings of the

Twenty-Fourth AAAI Conference on Artiﬁcial Intelligence, pp. 1607–1612, 2008.

Alec Radford, Jeff Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever.
URL https:

Language Models are Unsupervised Multitask Learners.
//d4mucfpksywv.cloudfront.net/better-language-models/language_
models_are_unsupervised_multitask_learners.pdf.

2019.

Simon Schmitt, Jonathan J. Hudson, Augustin Z´ıdek, Simon Osindero, Carl Doersch, Wojciech M.
Czarnecki, Joel Z. Leibo, Heinrich K¨uttler, Andrew Zisserman, Karen Simonyan, and S. M. Ali
Eslami. Kickstarting Deep Reinforcement Learning. arXiv preprint, 2018. URL http://arxiv.
org/abs/1803.03835.

John Schulman, Sergey Levine, Philipp Moritz, Michael I. Jordan, and Pieter Abbeel. Trust Region
Policy Optimization. arXiv preprint, 2015. URL http://arxiv.org/abs/1502.05477.

John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy op-
timization algorithms. arXiv preprint, 2017. URL http://arxiv.org/abs/1707.06347.

David Silver, Aja Huang, Chris J. Maddison, Arthur Guez, Laurent Sifre, George van den Driessche,
Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, Sander Dieleman,
Dominik Grewe, John Nham, Nal Kalchbrenner, Ilya Sutskever, Timothy Lillicrap, Madeleine
Leach, Koray Kavukcuoglu, Thore Graepel, and Demis Hassabis. Mastering the game of Go
with deep neural networks and tree search. Nature, 529:484–489, 2016. URL http://www.
nature.com/doifinder/10.1038/nature16961.

David Silver, Thomas Hubert, Julian Schrittwieser, Ioannis Antonoglou, Matthew Lai, Arthur
Guez, Marc Lanctot, Laurent Sifre, Dharshan Kumaran, Thore Graepel, Timothy Lillicrap, Karen
Simonyan, and Demis Hassabis. A general reinforcement learning algorithm that masters chess,
shogi, and go through self-play. Science, 362:1140–1144, 2018. URL https://science.
sciencemag.org/content/362/6419/1140.

Richard S. Sutton and Andrew G. Barto. Reinforcement Learning: An Introduction. MIT Press,

Cambridge, MA, 1998.

Richard S Sutton, David A. McAllester, Satinder P. Singh, and Yishay Mansour. Policy gradient
methods for reinforcement learning with function approximation. In S. A. Solla, T. K. Leen,
and K. M¨uller (eds.), Advances in Neural Information Processing Systems 12, pp. 1057–
URL http://papers.nips.cc/paper/1713-policy-
1063. MIT Press, 2000.
gradient-methods-for-reinforcement-learning-with-function-
approximation.pdf.

Yuval Tassa, Yotam Doron, Alistair Muldal, Tom Erez, Yazhe Li, Diego de Las Casas, David
Budden, Abbas Abdolmaleki, Josh Merel, Andrew Lefrancq, Timothy P. Lillicrap, and Martin A.
Riedmiller. DeepMind Control Suite. arXiv preprint, 2018. URL http://arxiv.org/abs/
1801.00690.

Hado van Hasselt, Arthur Guez, Matteo Hessel, and David Silver. Learning functions across many
orders of magnitudes. arXiv preprint, 2016. URL http://arxiv.org/abs/1602.07714.

Quan Vuong, Keith Ross, and Yiming Zhang. Supervised Policy Update for Deep Reinforcement

Learning. arXiv preprint, 2019. URL http://arxiv.org/abs/1805.11706.

11

Preprint

Ronald J. Williams. Simple statistical gradient-following methods for connectionist reinforce-
ment learning. Mach. Learn., 8:229–256, 1992. URL http://dx.doi.org/10.1007/
BF00992696.

Cathy Wu, Aravind Rajeswaran, Yan Duan, Vikash Kumar, Alexandre M. Bayen, Sham Kakade,
Igor Mordatch, and Pieter Abbeel. Variance reduction for policy gradient with action-dependent
factorized baselines. arXiv preprint, 2018. URL http://arxiv.org/abs/1803.07246.

A DERIVATION OF THE V-MPO TEMPERATURE LOSS

In this section we derive the E-step temperature loss in Eq. 23. To this end, we explicitly commit to
the more speciﬁc improvement criterion in Eq. 10 by plugging into the original objective in Eq. 8.
We seek ψ(s, a) that minimizes

J (ψ(s, a)) = DKL

(cid:0)ψ(s, a)(cid:107)pθold(s, a|I = 1)(cid:1)
(cid:88)

ψ(s, a)Aπθold (s, a) + η

∝ −

(cid:88)

s,a

ψ(s, a) log

+ λ

ψ(s, a)

ψ(s, a)
pθold(s, a)

(cid:88)

s,a

s,a

where λ = η log pθold (I = 1) after multiplying through by η, which up to this point in the deriva-
tion is given. We wish to automatically tune η so as to enforce a bound (cid:15)η on the KL term
(cid:0)ψ(s, a)(cid:107)pθold(s, a)(cid:1) multiplying it in Eq. 17, in which case the temperature optimization can
DKL
also be viewed as a nonparametric trust region for the variational distribution with respect to the old
distribution. We therefore consider the constrained optimization problem

ψ(s, a) = arg max
ψ(s,a)

(cid:88)

s,a

ψ(s, a)Aπθold (s, a)

s.t.

ψ(s, a) log

< (cid:15)η and

ψ(s, a) = 1.

ψ(s, a)
pθold(s, a)

(cid:88)

s,a

(cid:88)

s,a

We can now use Lagrangian relaxation to transform the constrained optimization problem into one
that maximizes the unconstrained objective

J (ψ(s, a), η, λ) =

ψ(s, a)Aπθold (s, a)+η

(cid:15)η−

ψ(s, a) log

(cid:32)

(cid:88)

s,a

ψ(s, a)
pθold(s, a)

(cid:33)

(cid:32)

(cid:33)

+λ

1−

ψ(s, a)

(cid:88)

s,a

(cid:88)

s,a

(20)
(Note we are re-using the variables η and λ for the new optimization problem.)

with η ≥ 0.
Differentiating J with respect to ψ(s, a) and setting equal to zero, we obtain

ψ(s, a) = pθold(s, a) exp

(cid:18) Aπθold (s, a)
η

(cid:19)

(cid:18)

exp

− 1 −

(cid:19)

.

λ
η

Normalizing over s, a (using the freedom given by λ) then gives

ψ(s, a) =

pθold(s, a) exp (cid:0) A
s,a pθold(s, a) exp (cid:0) A

πθold (s,a)
η
πθold (s,a)
η

(cid:1)

,

(cid:1)

(cid:80)

which reproduces the general solution Eq. 9 for our speciﬁc choice of policy improvement in Eq. 10.
However, the value of η can now be found by optimizing the corresponding dual function. Plugging
Eq. 22 into the unconstrained objective in Eq. 20 gives rise to the η-dependent term

Lη(η) = η(cid:15)η + η log

pθold(s, a) exp

(cid:34)

(cid:88)

s,a

(cid:18) Aπθold (s, a)
η

(cid:19)(cid:35)

.

Replacing the expectation with samples from pθold (s, a) in the batch of trajectories D leads to the loss
in Eq. 4.

12

(16)

(17)

(18)

(19)

(21)

(22)

(23)

Preprint

B M-STEP KL CONSTRAINT

Here we give a somewhat more formal motivation for the prior log p(θ). Consider a normal prior
N (θ; µ, Σ) with mean µ and covariance Σ. We choose Σ−1 = αF (θold) where α is a scal-
ing parameter and F (θold) is the Fisher information for πθ(cid:48)(a|s) evaluated at θ(cid:48) = θold. Then
log p(θ) ≈ −α × 1
2 (θ − θold)T F (θold)(θ − θold) + {term independent of θ}, where the ﬁrst term
is precisely the second-order approximation to the KL divergence DKL(θold(cid:107)θ). We now follow
TRPO (Schulman et al., 2015) in heuristically approximating this as the state-averaged expression,
(cid:0)πθold (a|s)(cid:107)πθ(a|s)(cid:1)(cid:3). We note that the KL divergence in either direction has the same
Es∼p(s)
second-order expansion, so our choice of KL is an empirical one (Abdolmaleki et al., 2018a).

(cid:2)DKL

C DECOUPLED KL CONSTRAINTS FOR CONTINUOUS CONTROL

As in Abdolmaleki et al. (2018b), for continuous action spaces parametrized by Gaussian distributions
we use decoupled KL constraints for the M-step. This uses the fact that the KL divergence between
two d-dimensional multivariate normal distributions with means µ1, µ2 and covariances Σ1, Σ2 can
be written as

DKL

(cid:0)N (µ1, Σ1)(cid:107)N (µ2, Σ2)(cid:1) =

1 (µ2 −µ1)+Tr(Σ−1

2 Σ1)−d+log

(cid:20)
(µ2 −µ1)T Σ−1

1
2

(cid:21)

|Σ2|
|Σ1|

, (24)

where | · | is the matrix determinant. Since the ﬁrst distribution and hence Σ1 in the KL divergence
of Eq. 14 depends on the old target network parameters, we see that we can separate the overall KL
divergence into a mean component and a covariance component:
(cid:0)πθold(cid:107)πθ

(µθ − µθold),

(cid:1) =

(25)

Dµ
KL

DΣ
KL

(cid:0)πθold(cid:107)πθ

(cid:1) =

1
2
1
2
(cid:1) → DC

(µθ − µθold)T Σ−1
θold
(cid:20)

Tr(Σ−1

θ Σθold
(cid:0)πθold(cid:107)πθ

KL

) − d + log

(cid:21)
.

|Σθ|
|Σθold|

(cid:1) for C = µ, Σ and corresponding α →

(26)

With the replacement DKL
αµ, αΣ in Eq. 15, we obtain the total loss

(cid:0)πθold (cid:107)πθ

LV-MPO(θ, η, αµ, αΣ) = Lπ(θ) + Lη(η) + Lαµ (θ, αµ) + LαΣ (θ, αΣ),
where Lπ(θ) and Lη(η) are the same as before. Note, however, that unlike in Abdolmaleki
et al. (2018a) we do not decouple the policy loss.

(27)

We generally set (cid:15)Σ to be much smaller than (cid:15)µ (see Table 7). Intuitively, this allows the policy to
learn quickly in action space while preventing premature collapse of the policy, and, conversely,
increasing “exploration” without moving in action space.

D RELATION TO SUPERVISED POLICY UPDATE

Like V-MPO, Supervised Policy Update (SPU) (Vuong et al., 2019) adopts the strategy of ﬁrst
solving a nonparametric constrained optimization problem exactly, then ﬁtting a neural network to
the resulting solution via a supervised loss function. There is, however, an important difference from
V-MPO, which we describe here.

In SPU, the KL loss, which is the sole loss in SPU, leads to a parametric optimization problem that is
equivalent to the nonparametric optimization problem posed initially. To see this, we observe that the
SPU loss seeks parameters (note the direction of the KL divergence)

θ∗ = arg min

dπθk (s)DKL

(cid:0)πθ(a|s)(cid:107)πλ(a|s)(cid:1)

= arg min

dπθk (s)

πθ(a|s) log

= arg min

dπθk (s)

(cid:20)
πθ(a|s) log

(cid:88)

a
(cid:88)

a

(cid:20)

πθ(a|s)
πθk (a|s) exp (cid:0)Aπθk (s, a)/λ(cid:1)/Zλ(s)
πθ(a|s)
πθk (a|s)

πθ(a|s)Aπθk (s, a)

1
λ

−

(cid:21)

(cid:21)

+ { constant terms }.

(cid:88)

s
(cid:88)

s
(cid:88)

s

θ

θ

θ

(28)

(29)

(30)

13

Preprint

(31)

(32)

(33)

(34)

(35)

Multiplying by λ since it can be treated as a constant up to this point, we then see that this corresponds
exactly to the (Lagrangian form) of the problem

θ∗ = arg max

dπθk (s)

πθ(a|s)Aπθk (s, a)

(cid:88)

s

θ

(cid:88)

a

dπθk (s)DKL

(cid:0)πθ(a|s)(cid:107)πθk (a|s)(cid:1) < (cid:15),

(cid:88)

s.t.

s

which is the original nonparametric problem posed in Vuong et al. (2019).

E IMPORTANCE-WEIGHTING FOR OFF-POLICY CORRECTIONS

The network that generates the data may lag behind the target network in common distributed,
asynchronous implementations (Espeholt et al., 2018). We can compensate for this by multiplying
the exponentiated advantages by importance weights ρ(s, a):

ψ(s, a) =

ρ(s, a)pθD (s, a) exp (cid:0) A
s,a ρ(s, a)pθD (s, a) exp (cid:0) A

πθD (s,a)
η
πθD (s,a)
η

(cid:1)

,

(cid:1)

(cid:80)

Lη(η) = η(cid:15)η + η log

ρ(s, a)pθD (s, a) exp

(cid:34)

(cid:88)

s,a

(cid:18) AπθD (s, a)
η

(cid:19)(cid:35)

,

where θD are the parameters of the behavior policy that generated D and which may be different
from θtarget. The clipped importance weights ρ(s, a) are given by
(cid:19)

(cid:18)

ρ(s, a) = min

1,

πθold (a|s)
πθD (a|s)

.

As was the case with V-trace for the value function, we did not ﬁnd it necessary to use importance
weighting and all experiments presented in this work did not use them for the sake of simplicity.

F NETWORK ARCHITECTURE AND HYPERPARAMETERS

For DMLab the visual observations were 72×96 RGB images, while for Atari the observations were 4
stacked frames of 84×84 grayscale images. The ResNet used to process visual observations is similar
to the 3-section ResNet used in Hessel et al. (2018), except the number of channels was multiplied by
4 in each section, so that the number of channels were (64, 128, 128) (Anonymous Authors, 2019).
For individual DMLab levels we used the same number of channels as Hessel et al. (2018), i.e., (16,
32, 32). Each section consisted of a convolution and 3 × 3 max-pooling operation (stride 2), followed
by residual blocks of size 2, i.e., a convolution followed by a ReLU nonlinearity, repeated twice,
and a skip connection from the input residual block input to the output. The entire stack was passed
through one more ReLU nonlinearity. All convolutions had a kernel size of 3 and a stride of 1. For
the humanoid control tasks from vision, the number of channels in each section were (16, 32, 32).

Since some of the levels in DMLab require simple language processing, for DMLab the agents
contained an additional 256-unit LSTM receiving an embedding of hashed words as input. The output
of the language LSTM was then concatenated with the output of the visual processing pathway as
well as the previous reward and action, then fed to the main LSTM.

For multi-task DMLab we used a 3-layer LSTM, each with 256 units, and an unroll length of 95
with batch size 128. For the single-task setting we used a 2-layer LSTM. For multi-task Atari and
the 56-dimensional humanoid-gaps control task a single 256-unit LSTM was used, while for the
22-dimensional humanoid-run task the core consisted only of a 2-layer MLP with 512 and 256 units
(no LSTM). For single-task Atari a Transformer-XL was used in place of the LSTM. Note that we
followed Radford et al. (2019) in placing the layer normalization on only the inputs to each sub-block.
For Atari the unroll length was 63 with a batch size of 128. For both humanoid control tasks the
batch size was 64, but the unroll length was 40 for the 22-dimensional humanoid and 63 for the
56-dimensional humanoid.

14

Preprint

Figure 5: (a) Actor-learner architecture with a target network, which is used to generate agent
experience in the environment and is updated every Ttarget learning steps from the online network. (b)
Schematic of the agents, with the policy (θ) and value (φ) networks sharing most of their parameters
through a shared input encoder and LSTM [or Transformer-XL (TrXL) for single Atari levels]. The
agent also receives the action and reward from the previous step as an input to the LSTM. For DMLab
an additional LSTM is used to process simple language instructions.

In all cases the policy logits (for discrete actions) and Gaussian distribution parameters (for continuous
actions) consisted of a 256-unit MLP followed by a linear readout, and similarly for the value function.

The initial values for the Lagrange multipliers in the V-MPO loss are given in Table 1

Implementation note. We implemented V-MPO in an actor-learner framework (Espeholt et al., 2018)
that utilizes TF-Replicator (Buchlovsky et al., 2019) for distributed training on TPU 8-core and
16-core conﬁgurations (Google, 2018). One practical consequence of this is that a full batch of data
D was in fact split into 8 or 16 minibatches, one per core/replica, and the overall result obtained by
averaging the computations performed for each minibatch. More speciﬁcally, the determination of the
highest advantages and the normalization of the nonparametric distribution, Eq. 3, is performed within
minibatches. While it is possible to perform the full-batch computation by utilizing cross-replica
communication, we found this to be unnecessary.

HYPERPARAMETER

VALUE

Initial η
Initial α
Initial αµ
Initial αΣ

DMLab Atari Continuous control

1.0
5.0
-
-

1.0
5.0
-
-

1.0
-
1.0
1.0

Table 1: Values for common V-MPO parameters.

DMLab action set. Ignoring the “jump” and “crouch” actions which we do not use, an action in the
native DMLab action space consists of 5 integers whose meaning and allowed values are given in
Table 2. Following previous work on DMLab (Hessel et al., 2018), we used the reduced action set
given in Table 3 with an action repeat of 4.

15

Preprint

ACTION NAME

LOOK LEFT RIGHT PIXELS PER FRAME
LOOK DOWN UP PIXELS PER FRAME
STRAFE LEFT RIGHT
MOVE BACK FORWARD
FIRE

RANGE

[-512, 512]
[-512, 512]
[-1, 1]
[-1, 1]
[0, 1]

Table 2: Native action space for DMLab. See https://github.com/deepmind/lab/blob/
master/docs/users/actions.md for more details.

ACTION

Forward (FW)
Backward (BW)

Strafe left
Strafe right

Small look left (LL)
Small look right (LR)
Large look left (LL )
Large look right (LR)

Look down
Look up

FW + small LL
FW + small LR
FW + large LL
FW + large LR

Fire

[
[

[
[

0,
0,

0,
0,

[-10,
[ 10,
[-60,
[ 60,

[-10,
[ 10,
[-60,
[ 60,

[

0,

NATIVE DMLAB ACTION

0,
0,

0,
1, 0]
0, -1, 0]

0, -1,
1,
0,

0, 0]
0, 0]

0, 0]
0, 0]
0, 0]
0, 0]

0, 0]
0, 0]

1, 0]
1, 0]
1, 0]
1, 0]

0, 1]

0,
0,
0,
0,

0,
0,
0,
0,

0,

0,
0,
0,
0,

0,
0,

0,
0,
0,
0,

0,

[
[

0,
10,
0, -10,

Table 3: Reduced action set for DMLab from Hessel et al. (2018).

Figure 6: Example frame from the humanoid gaps task, with the agent’s 64×64 ﬁrst-person view
on the right. The proprioceptive information provided to the agent in addition to the primary pixel
observation consisted of joint angles and velocities, root-to-end-effector vectors, root-frame velocity,
rotational velocity, root-frame acceleration, and the 3D orientation relative to the z-axis.

16

Preprint

LEVEL NAME

alien
amidar
assault
asterix
asteroids
atlantis
bank heist
battle zone
beam rider
berzerk
bowling
boxing
breakout
centipede
chopper command
crazy climber
defender
demon attack
double dunk
enduro
ﬁshing derby
freeway
frostbite
gopher
gravitar
hero
ice hockey
jamesbond
kangaroo
krull
kung fu master
montezuma revenge
ms pacman
name this game
phoenix
pitfall
pong
private eye
qbert
riverraid
road runner
robotank
seaquest
skiing
solaris
space invaders
star gunner
surround
tennis
time pilot
tutankham
up n down
venture
video pinball
wizard of wor
yars revenge
zaxxon

Median

EPISODE REWARD

IMPALA

V-MPO

HUMAN-NORMALIZED

IMPALA

V-MPO

1163.00 ± 148.43
192.50 ± 9.16
4215.30 ± 294.51
4180.00 ± 303.91
3473.00 ± 381.30
997530.00 ± 3552.89
1329.00 ± 2.21
43900.00 ± 4738.04
4598.00 ± 618.09
1018.00 ± 72.63
63.60 ± 0.84
93.10 ± 0.94
484.30 ± 57.24
6037.90 ± 994.99
4250.00 ± 417.91
100440.00 ± 9421.56
41585.00 ± 4194.42
77880.00 ± 8798.44
-0.80 ± 0.31
1187.90 ± 76.10
21.60 ± 3.46
32.10 ± 0.17
250.00 ± 0.00
11720.00 ± 1687.71
1095.00 ± 232.75
13159.50 ± 68.90
4.80 ± 1.31
1015.00 ± 91.39
1780.00 ± 18.97
9738.00 ± 360.95
44340.00 ± 2898.70
0.00 ± 0.00
1953.00 ± 227.12
5708.00 ± 354.92
37030.00 ± 6415.95
-4.90 ± 2.34
20.80 ± 0.19
100.00 ± 0.00
5512.50 ± 741.08
8237.00 ± 97.09
28440.00 ± 1215.99
29.60 ± 2.15
1888.00 ± 63.26
-16244.00 ± 592.28
1794.00 ± 279.04
793.50 ± 90.61
44860.00 ± 5157.74
2.50 ± 1.04
-0.10 ± 0.09
10890.00 ± 787.46
218.50 ± 13.53
175083.00 ± 16341.05
0.00 ± 0.00
59898.40 ± 23875.14
6960.00 ± 1730.97
12825.70 ± 2065.90
11520.00 ± 646.81

2332.00 ± 290.16
423.60 ± 20.53
1225.90 ± 60.64
9955.00 ± 2043.48
2982.00 ± 164.35
940310.00 ± 6085.96
1563.00 ± 15.81
61400.00 ± 5958.52
3868.20 ± 666.55
1424.00 ± 150.93
27.60 ± 0.62
100.00 ± 0.00
400.70 ± 18.82
3015.00 ± 404.97
4340.00 ± 714.45
116760.00 ± 5312.12
98395.00 ± 17552.17
20243.00 ± 5434.41
12.60 ± 1.94
1453.80 ± 104.37
33.80 ± 2.10
33.20 ± 0.28
260.00 ± 0.00
7576.00 ± 973.13
3125.00 ± 191.87
29196.50 ± 752.06
10.60 ± 2.00
3805.00 ± 595.92
12790.00 ± 629.52
7359.00 ± 1064.84
38620.00 ± 2346.48
0.00 ± 0.00
2856.00 ± 324.54
9295.00 ± 679.83
19560.00 ± 1843.44
-2.80 ± 1.40
21.00 ± 0.00
100.00 ± 0.00
15297.50 ± 1244.47
11160.00 ± 733.06
51060.00 ± 1560.72
46.80 ± 3.42
9953.00 ± 973.02
-15438.10 ± 1573.39
2194.00 ± 417.91
1771.50 ± 201.95
60120.00 ± 1953.60
4.00 ± 0.62
23.10 ± 0.26
22330.00 ± 2443.11
254.60 ± 9.99
82913.00 ± 12142.08
0.00 ± 0.00
198845.20 ± 98768.54
7890.00 ± 1595.77
41271.70 ± 4726.72
18820.00 ± 754.69

13.55 ± 2.15
10.89 ± 0.53
768.46 ± 56.68
47.87 ± 3.66
5.90 ± 0.82
6086.50 ± 21.96
177.94 ± 0.30
119.27 ± 13.60
25.56 ± 3.73
35.68 ± 2.90
29.43 ± 0.61
775.00 ± 7.86
1675.69 ± 198.77
39.76 ± 10.02
52.29 ± 6.35
357.94 ± 37.61
244.78 ± 26.52
4273.35 ± 483.72
809.09 ± 14.08
138.05 ± 8.84
213.77 ± 6.54
108.45 ± 0.58
4.33 ± 0.00
531.92 ± 78.32
29.01 ± 7.32
40.71 ± 0.23
132.23 ± 10.83
360.12 ± 33.38
57.93 ± 0.64
762.53 ± 33.81
196.11 ± 12.90
0.00 ± 0.00
24.77 ± 3.42
59.33 ± 6.17
559.60 ± 98.99
3.35 ± 0.04
117.56 ± 0.54
0.11 ± 0.00
40.24 ± 5.58
43.72 ± 0.62
362.91 ± 15.52
282.47 ± 22.22
4.33 ± 0.15
6.69 ± 4.64
5.03 ± 2.52
42.45 ± 5.96
461.05 ± 53.80
75.76 ± 6.31
152.90 ± 0.61
440.77 ± 47.40
132.59 ± 8.66
1564.09 ± 146.43
0.00 ± 0.00
339.02 ± 135.13
152.55 ± 41.28
18.90 ± 4.01
125.67 ± 7.08

30.50 ± 4.21
24.38 ± 1.20
193.13 ± 11.67
117.50 ± 24.64
4.85 ± 0.35
5732.81 ± 37.62
209.61 ± 2.14
169.52 ± 17.11
21.16 ± 4.02
51.87 ± 6.02
3.27 ± 0.45
832.50 ± 0.00
1385.42 ± 65.36
9.31 ± 4.08
53.66 ± 10.86
423.09 ± 21.21
604.01 ± 110.99
1104.56 ± 298.77
1418.18 ± 88.19
168.95 ± 12.13
236.79 ± 3.96
112.16 ± 0.93
4.56 ± 0.00
339.62 ± 45.16
92.88 ± 6.04
94.53 ± 2.52
180.17 ± 16.50
1379.11 ± 217.65
427.02 ± 21.10
539.67 ± 99.75
170.66 ± 10.44
0.00 ± 0.00
38.36 ± 4.88
121.64 ± 11.81
290.05 ± 28.44
3.39 ± 0.02
118.13 ± 0.00
0.11 ± 0.00
113.86 ± 9.36
62.24 ± 4.65
651.67 ± 19.92
459.79 ± 35.29
23.54 ± 2.32
13.01 ± 12.33
8.64 ± 3.77
106.76 ± 13.28
620.24 ± 20.38
84.85 ± 3.74
302.58 ± 1.69
1129.42 ± 147.07
155.70 ± 6.40
738.18 ± 108.80
0.00 ± 0.00
1125.46 ± 559.03
174.73 ± 38.06
74.16 ± 9.18
205.53 ± 8.26

117.56

155.70

Table 4: Multi-task Atari-57 scores by level after 11.4B total (200M per level) environment frames. All
entries show mean ± standard deviation. Data for IMPALA (“PopArt-IMPALA”) was obtained from
the authors of Hessel et al. (2018). Human-normalized scores are calculated as (E−R)/(H−R)×100,
where E is the episode reward, R the episode reward obtained by a random agent, and H is the
episode reward obtained by a human.
17

Preprint

SETTING

SINGLE-TASK MULTI-TASK

Agent discount
Image height
Image width
Number of action repeats
Number of LSTM layers
Pixel-control cost
Ttarget
(cid:15)η
(cid:15)α (log-uniform)

0.99
72
96
4

2

3

2 × 10−3
10

0.1
[0.001, 0.01)

0.5
[0.01, 0.1)

Table 5: Settings for DMLab.

SETTING

SINGLE-TASK MULTI-TASK

Environment discount on end of life
Agent discount
Clipped reward range
Max episode length
Image height
Image width
Grayscale
Number of stacked frames
Number of action repeats
TrXL: Key/Value size
TrXL: Number of heads
TrXL: Number of layers
TrXL: MLP size
Ttarget
(cid:15)η
(cid:15)α (log-uniform)

1
0.997
no clipping

0
0.99
[−1, 1]
30 mins (108,000 frames)
84
84
True
4
4

32
4
8
512
1000

·
·
·
·
100

2 × 10−2

[0.005, 0.01)

[0.001, 0.01)

Table 6: Settings for Atari. TrXL: Transformer-XL.

SETTING

HUMANOID-PIXELS

HUMANOID-STATE

OPENAI GYM

Agent discount
Unroll length
Image height
Image width
Target update period
(cid:15)η
(cid:15)αµ (log-uniform)
(cid:15)αΣ (log-uniform)

63
64
64

0.99
63
·
·
100

39
·
·

0.1
[0.01, 1.0)
[5 × 10−6, 5 × 10−5)

0.01

[0.05, 0.5]
[10−5, 5 × 10−5)

[0.005, 0.01]
[5 × 10−6, 5 × 10−5)

Table 7: Settings for continuous control. For the humanoid gaps task from pixels the physics time
step was 5 ms and the control time step 30 ms.

18

Preprint

Figure 7: 17-dimensional Humanoid-V1 task in OpenAI Gym.

19

