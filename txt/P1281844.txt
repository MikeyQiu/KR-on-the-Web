Lattice CNNs for Matching Based Chinese Question Answering

Yuxuan Lai1, Yansong Feng1,*, Xiaohan Yu1
Zheng Wang2, Kun Xu3, Dongyan Zhao1
1Institute of Computer Science and Technology, Peking University, China
2School of Computing and Communications, Lancaster University, UK 3Tencent AI Lab
1{erutan, fengyansong, yuxiaohan, zhaodongyan}@pku.edu.cn
2z.wang@lancaster.ac.uk 3syxu828@gmail.com

9
1
0
2
 
b
e
F
 
5
2
 
 
]
L
C
.
s
c
[
 
 
1
v
7
8
0
9
0
.
2
0
9
1
:
v
i
X
r
a

Abstract

Short text matching often faces the challenges that there are
great word mismatch and expression diversity between the
two texts, which would be further aggravated in languages
like Chinese where there is no natural space to segment words
explicitly. In this paper, we propose a novel lattice based
CNN model (LCNs) to utilize multi-granularity information
inherent in the word lattice while maintaining strong ability
to deal with the introduced noisy information for matching
based question answering in Chinese. We conduct extensive
experiments on both document based question answering and
knowledge based question answering tasks, and experimental
results show that the LCNs models can signiﬁcantly outper-
form the state-of-the-art matching models and strong base-
lines by taking advantages of better ability to distill rich but
discriminative information from the word lattice input. 1

Introduction

Short text matching plays a critical role in many natural
language processing tasks, such as question answering, in-
formation retrieval, and so on. However, matching text se-
quences for Chinese or similar languages often suffers from
word segmentation, where there are often no perfect Chi-
nese word segmentation tools that suit every scenario. Text
matching usually requires to capture the relatedness between
two sequences in multiple granularities. For example, in Fig-
ure 1, the example phrase is generally tokenized as “China
citizen life quality high”, but when we plan to match it
with “Chinese live well”, it would be more helpful to have
the example segmented into “Chinese livelihood live” than
its common segmentation. 2

Existing efforts use neural network models to improve
the matching based on the fact that distributed represen-
tations can generalize discrete word features in traditional
bag-of-words methods. And there are also works fusing
word level and character level information, which, to some

Copyright c(cid:13) 2019, Association for the Advancement of Artiﬁcial
Intelligence (www.aaai.org). All rights reserved.

1Code and appendix can be found in https://github.com/Erutan-

pku/LCN-for-Chinese-QA .

2For clarity, “Italic” are examples organised in Chinese Pinyin
followed by its translation in English, and “” represents a separator
between Chinese words.

extent, could relieve the mismatch between different seg-
mentations, but these solutions still suffer from the orig-
inal word sequential structures. They usually depend on
an existing word tokenization, which has to make seg-
mentation choices at one time, e.g., “ZhongGuo”(China)
and “ZhongGuoRen”(Chinese) when processing “Zhong-
GuoRenMin”(Chinese people). And the blending just con-
ducts at one position in their frameworks.

Speciﬁc tasks such as question answering (QA) could
pose further challenges for short text matching. In docu-
ment based question answering (DBQA), the matching de-
gree is expected to reﬂect how likely a sentence can an-
swer a given question, where questions and candidate an-
swer sentences usually come from different sources, and
may exhibit signiﬁcantly different styles or syntactic struc-
tures, e.g. queries in web search and sentences in web
pages. This could further aggravate the mismatch problems.
In knowledge based question answering (KBQA), one of
the key tasks is to match relational expressions in ques-
tions with knowledge base (KB) predicate phrases3, such as
“ZhuCeDi”(place of incorporation). Here the diversity be-
tween the two kinds of expressions is even more signiﬁcant,
where there may be dozens of different verbal expressions
in natural language questions corresponding to only one KB
predicate phrase. Those expression problems make KBQA a
further tough task. Previous works (Yih, He, and Meek 2014;
Yih et al. 2015) adopt letter-trigrams for the diverse expres-
sions, which is similar to character level of Chinese. And the
lattices are combinations of words and characters, so with
lattices, we can utilize words information at the same time.
Recent advances have put efforts in modeling multi-
granularity information for matching. (Seo et al. 2016;
Wang, Hamza, and Florian 2017) blend words and charac-
ters to a simple sequence (in word level), and (Chen et al.
2018) utilize multiple convoluational kernel sizes to capture
different n-grams. But most characters in Chinese can be
seen as words on their own, so combining characters with
corresponding words directly may lose the meanings that
those characters can express alone. Because of the sequen-
tial inputs, they will either lose word level information when

3There are usually not enough training data to build a relation
extractor for each predicate in a KB, thus the task of KB predicate
identiﬁcation is often formulated as a matching task, which is to se-
lect predicates that match the given questions from the candidates.

Figure 1: A word lattice for the phrase “Chinese people have
high quality of life.”

conducting on character sequences or have to make segmen-
tation choices.

In this paper, we propose a multi-granularity method for
short text matching in Chinese question answering which
utilizes lattice based CNNs to extract sentence level features
over word lattice. Speciﬁcally, instead of relying on charac-
ter or word level sequences, LCNs take word lattices as in-
put, where every possible word and character will be treated
equally and have their own context so that they can interact
at every layer. For each word in each layer, LCNs can cap-
ture different context words in different granularity via pool-
ing methods. To the best of our knowledge, we are the ﬁrst to
introduce word lattice into the text matching tasks. Because
of the similar IO structures to original CNNs and the high
efﬁciency, LCNs can be easily adapted to more scenarios
where ﬂexible sentence representation modeling is required.
We evaluate our LCNs models on two question answering
tasks, document based question answering and knowledge
based question answering, both in Chinese. Experimental
results show that LCNs signiﬁcantly outperform the state-
of-the-art matching methods and other competitive CNNs
baselines in both scenarios. We also ﬁnd that LCNs can
better capture the multi-granularity information from plain
sentences, and, meanwhile, maintain better de-noising ca-
pability than vanilla graphic convolutional neural networks
thanks to its dynamic convolutional kernels and gated pool-
ing mechanism.

Lattice CNNs
Our Lattice CNNs framework is built upon the siamese ar-
chitecture (Bromley et al. 1994), one of the most successful
frameworks in text matching, which takes the word lattice
format of a pair of sentences as input, and outputs the match-
ing score.

Siamese Architecture
The siamese architecture and its variant have been widely
adopted in sentence matching (Mitra, Diaz, and Craswell
2017; Wang, Hamza, and Florian 2017) and matching based
question answering (Yu et al. 2014; Yih, He, and Meek 2014;
Yu et al. 2017), that has a symmetrical component to ex-
tract high level features from different input channels, which
share parameters and map inputs to the same vector space.
Then, the sentence representations are merged and com-
pared to output the similarities.

For our models, we use multi-layer CNNs for sentence
representation. Residual connections (He et al. 2016) are

used between convolutional layers to enrich features and
make it easier to train. Then, max-pooling summarizes
the global features to get the sentence level representa-
tions, which are merged via element-wise multiplication.
The matching score is produced by a multi-layer perceptron
(MLP) with one hidden layer based on the merged vector.
The fusing and matching procedure is formulated as follows:

s = σ(W2 ReLU(W1(fqu (cid:12) fcan) + bT

1 ) + bT
2 )

(1)

where fqu and fcan are feature vectors of question and can-
didate (sentence or predicate) separately encoded by CNNs,
σ is the sigmoid function, W2, W1, bT
2 are parameters,
and (cid:12) is element-wise multiplication. The training objective
is to minimize the binary cross-entropy loss, deﬁned as:

1 , bT

L = −

[yilog(si) + (1 − yi)log(1 − si)]

(2)

N
(cid:88)

i=1

where yi is the {0,1} label for the ith training pair.

Note that the CNNs in the sentence representation com-
ponent can be either original CNNs with sequence input or
lattice based CNNs with lattice input. Intuitively, in an orig-
inal CNN layer, several kernels scan every n-gram in a se-
quence and result in one feature vector, which can be seen
as the representation for the center word and will be fed into
the following layers. However, each word may have differ-
ent context words in different granularities in a lattice and
may be treated as the center in various kernel spans with
same length. Therefore, different from the original CNNs,
there could be several feature vectors produced for a given
word, which is the key challenge to apply the standard CNNs
directly to a lattice input.

For the example shown in Figure 2, the word “citizen” is
the center word of four text spans with length 3: “China -
citizen - life”, “China - citizen - alive”, “country - citizen -
life”, “country - citizen - alive”, so four feature vectors will
be produced for width-3 convolutional kernels for “citizen”.

Word Lattice
As shown in Figure 1, a word lattice is a directed graph
G = (cid:104)V, E(cid:105), where V represents a node set and E rep-
resents a edge set. For a sentence in Chinese, which is
a sequence of Chinese characters S = c1:n, all of its
possible substrings that can be considered as words are
treated as vertexes, i.e. V = {ci:j|ci:j is word}. Then,
all neighbor words are connected by directed edges accord-
ing to their positions in the original sentence, i.e. E =
{e(ci:j, cj:k)|∀i, j, k s.t. ci:j, cj:k ∈ V }.

Here, one of the key issues is how we decide a sequence
of characters can be considered as a word. We approach this
through an existing lookup vocabulary, which contains fre-
quent words in BaiduBaike4. Note that most Chinese char-
acters can be considered as words on their own, thus are in-
cluded in this vocabulary when they have been used as words
on their own in this corpus.

However, doing so will inevitably introduce noisy words
(e.g., “middle” in Figure 1) into word lattices, which will

4https://baike.baidu.com

Figure 2: An illustration of our LCN-gated, when “people” is being considered as the center of convolutional spans.

be smoothed by pooling procedures in our model. And the
constructed graphs could be disconnected because of a few
out-of-vocabulary characters. Thus, we append (cid:104)unk(cid:105) labels
to replace those characters to connect the graph.

Obviously, word lattices are collections of characters and
all possible words. Therefore, it is not necessary to make ex-
plicit decisions regarding speciﬁc word segmentations, but
just embed all possible information into the lattice and take
them to the next CNN layers. The inherent graph structure of
a word lattice allows all possible words represented explic-
itly, no matter the overlapping and nesting cases, and all of
them can contribute directly to the sentence representations.

Lattice based CNN Layer
As we mentioned in previous section, we can not directly ap-
ply standard CNNs to take word lattice as input, since there
could be multiple feature vectors produced for a given word.
Inspired by previous lattice LSTM models(Su et al. 2017;
Zhang and Yang 2018), here we propose a lattice based CNN
layers to allow standard CNNs to work over word lattice in-
put. Speciﬁcally, we utilize pooling mechanisms to merge
the feature vectors produced by multiple CNN kernels over
different context compositions.

Formally, the output feature vector of a lattice CNN layer
with kernel size n at word w in a word lattice G = (cid:104)V, E(cid:105)
can be formulated as Eq 3 :

Fw = g{f (Wc(vw1 : ... : vwn ) + bT

∀i, wi ∈ V, (wi, wi+1) ∈ E, w(cid:100) n+1

c )|
2 (cid:101) = w}

(3)

where f is the activation function, vwi is the input vector
corresponding to word wi in this layer, (vw1 : ... : vwn )
means the concatenation of these vectors, and Wc, bc are
parameters with size [m(cid:48), n × m], and [m(cid:48)], respectively. m
is the input dim and m(cid:48) is the output dim. g is one of the
following pooling functions: max-pooling, ave-pooling, or
gated-pooling, which execute the element-wise maximum,
element-wise average, and the gated operation, respectively.
The gated operation can be formulated as:

α1, ..., αt = softmax{vT

gated-pooling{v1, ..., vt} =

αi × vi

g v1 + bg, ..., vT
g vt + bg}
n
(cid:88)

(4)

(5)

i=1

where vg, bg are parameters, and αi are gated weights nor-
malized by a softmax function. Intuitively, the gates repre-
sent the importance of the n-gram contexts, and the weighted
sum can control the transmission of noisy context words. We
perform padding when necessary.

For example, in Figure 2, when we consider “citizen”
as the center word, and the kernel size is 3, there will be
ﬁve words and four context compositions involved, as men-
tioned in the previous section, each marked in different col-
ors. Then, 3 kernels scan on all compositions and produce
four 3-dim feature vectors. The gated weights are computed
based on those vectors via a dense layer, which can reﬂect
the importance of each context compositions. The output
vector of the center word is their weighted sum, where noisy
contexts are expected to have lower weights to be smoothed.
This pooling over different contexts allows LCNs to work
over word lattice input.

Word lattice can be seen as directed graphs and mod-
eled by Directed Graph Convolutional networks (DGCs)
(Marcheggiani and Titov 2017), which use poolings on
neighboring vertexes that ignore the semantic structure of n-
grams. But to some situations, their formulations can be very
similar to ours (See Appendix5 for derivation). For example,
if we set the kernel size in LCNs to 3, use linear activations
and suppose the pooling mode is average in both LCNs and
DGCs, at each word in each layer, the DGCs compute the
average of the ﬁrst order neighbors together with the cen-
ter word, while the LCNs compute the average of the pre
and post words separately and add them to the center word.
Empirical results are exhibited in Experiments section.

Finally, given a sentence that has been constructed into a
word-lattice form, for each node in the lattice, an LCN layer
will produce one feature vector similar to original CNNs,
which makes it easier to stack multiple LCN layers to obtain
more abstract feature representations.

Experiments
Our experiments are designed to answer: (1) whether multi-
granularity information in word lattice helps in match-
ing based QA tasks, (2) whether LCNs capture the multi-
granularity information through lattice well, and (3) how to

5https://github.com/Erutan-pku/LCN-for-Chinese-

QA/blob/master/paper appendix.pdf

balance the noisy and informative words introduced by word
lattice.

Datasets
We conduct experiments on two Chinese question answering
datasets from NLPCC-2016 evaluation task (Duan 2016).

DBQA is a document based question answering dataset.
There are 8.8k questions with 182k question-sentence pairs
for training and 6k questions with 123k question-sentence
pairs in the test set. In average, each question has 20.6 candi-
date sentences and 1.04 golden answers. The average length
for questions is 15.9 characters, and each candidate sentence
has averagely 38.4 characters. Both questions and sentences
are natural language sentences, possibly sharing more sim-
ilar word choices and expressions compared to the KBQA
case. But the candidate sentences are extracted from web
pages, and are often much longer than the questions, with
many irrelevant clauses.

KBRE is a knowledge based relation extraction dataset.
We follow the same preprocess as (Lai et al. 2017) to clean
the dataset6 and replace entity mentions in questions to a
special token. There are 14.3k questions with 273k question-
predicate pairs in the training set and 9.4k questions with
156k question-predicate pairs for testing. Each question con-
tains only one golden predicate. Each question averagely
has 18.1 candidate predicates and 8.1 characters in length,
while a KB predicate is only 3.4 characters long on average.
Note that a KB predicate is usually a concise phrase, with
quite different word choices compared to the natural lan-
guage questions, which poses different challenges to solve.
The vocabulary we use to construct word lattices contains
156k words, including 9.1k single character words. In av-
erage, each DBQA question contains 22.3 tokens (words or
characters) in its lattice, each DBQA candidate sentence has
55.8 tokens, each KBQA question has 10.7 tokens and each
KBQA predicate contains 5.1 tokens.

Evaluation Metrics
For both datasets, we follow the evaluation metrics used in
the original evaluation tasks (Duan 2016). For DBQA, P@1
(Precision@1), MAP (Mean Average Precision) and MRR
(Mean Reciprocal Rank) are adopted. For KBRE, since only
one golden candidate is labeled for each question, only P@1
and MRR are used.

Implementation Details
The word embeddings are trained on the Baidu Baike web-
pages with Google’s word2vector7, which are 300-dim and
ﬁne tuned during training. In DBQA, we also follow pre-
vious works (Fu, Qiu, and Huang 2016; Xie 2017) to con-
catenate additional 1d-indicators with word vectors which
denote whether the words are concurrent in both questions
and candidate sentences. In each CNN layer, there are 256,
512, and 256 kernels with width 1, 2, and 3, respectively.
The size of the hidden layer for MLP is 1024. All activation

6About 3% of the questions in the original dataset are removed
for they can not link to correct entities/relations due to label errors.

7https://code.google.com/archive/p/word2vec/

are ReLU, the dropout rate is 0.5, with a batch size of 64.
We optimize with adadelta (Zeiler 2012) with learning rate
= 1.0 and decay factor = 0.95. We only tune the number
of convolutional layers from [1, 2, 3] and ﬁx other hyper-
parameters. We sample at most 10 negative sentences per
question in DBQA and 5 in KBRE. We implement our mod-
els in Keras8 with Tensorﬂow9 backend.

Baselines
Our ﬁrst set of baselines uses original CNNs with character
(CNN-char) or word inputs. For each sentence, two Chinese
word segmenters are used to obtain three different word se-
quences: jieba (CNN-jieba)10, and Stanford Chinese word
segmenter11 in CTB (CNN-CTB) and PKU (CNN-PKU)
mode.

Our second set of baselines combines different word
segmentations. Speciﬁcally, we concatenate the sentence
embeddings from different segment results, which gives
four different word+word models: jieba+PKU, PKU+CTB,
CTB+jieba, and PKU+CTB+jieba.

Inspired by previous works (Seo et al. 2016; Wang,
Hamza, and Florian 2017), we also concatenate word and
character embeddings at the input level. Specially, when the
basic sequence is in word level, each word may be con-
structed by multiple characters through a pooling operation
(Word+Char). Our pilot experiments show that average-
pooling is the best for DBQA while max-pooling after a
dense layer is the best for KBQA. When the basic se-
quence is in character level, we simply concatenate the char-
acter embedding with its corresponding word embedding
(Char+Word), since each character belongs to one word
only. Again, when the basic sequence is in character level,
we can also concatenate the character embedding with a
pooled representation of all words that contain this charac-
ter in the word lattice (Char+Lattice), where we use max
pooling as suggested by our pilot experiments.

DGCs (Marcheggiani and Titov 2017; Vashishth et al.
2018) are strong baselines that perform CNNs over directed
graphs to produce high level representation for each vertex
in the graph, which can be used to build a sentence represen-
tation via certain pooling operation. We therefore choose to
compare with DGC-max (with maximum pooling), DGC-
ave (with average pooling), and DGC-gated (with gated
pooling), where the gate value is computed using the con-
catenation of the vertex vector and the center vertex vector
through a dense layer.

We also implement several state-of-the-art matching mod-
els using the open-source project MatchZoo (Fan et al.
2017), where we tune hyper-parameters using grid search,
e.g., whether using word or character inputs. Arc1, Arc2,
CDSSM are traditional CNNs based matching models pro-
posed by (Hu et al. 2014; Shen et al. 2014). Arc1 and
CDSSM compute the similarity via sentence representations
and Arc2 uses the word pair similarities. MV-LSTM (Wan

8https://keras.io
9https://www.tensorﬂow.org
10https://pypi.python.org/pypi/jieba/
11https://nlp.stanford.edu/software/segmenter.shtml

DBQA

KBRE

MAP MRR

P@1

P@1

MRR

MatchZoo
.4011
.4785
.5349
.7723
.8162

22.39% 32.18% .5144
30.47% 76.07% .8518
36.45% 68.90% .7974
65.61% 86.21% .9137
71.71% 86.87% .9271

.4006
.4780
.5344
.7715
.8154

State-of-the-Art DBQA

.8592
.8586
.8763
.8768 —
Single Granularity CNNs
.8281
.8339
.8341
.8803

.8289
.8343
.8347
.8809

Word Combine CNNs

79.06% —
—

—
—

75.10% 86.85% .9152
76.00% 89.87% .9370
76.04% 88.92% .9302
82.09% 93.06% .9570

Word+Char CNNs

.8486
.8435
.8499
.8494

.8566
.8728
.8810

.8868
.8811
.8790

.8864
.8870
.8895

.8490
.8440
.8504
.8498

.8570
.8735
.8815

.8873
.8818
.8795

.8869
.8875
.8902

DGCs

LCNs

77.62% 90.57% .9417
77.09% 90.48% .9410
78.06% 90.29% .9399
78.04% 91.16% .9450

78.94% 91.64% .9489
80.76% 92.78% .9561
81.97% 93.12% .9582

83.02% 93.49% .9602
82.01% 92.79% .9553
81.69% 92.88% .9562

83.14% 93.60% .9609
83.06% 93.54% .9604
83.24% 93.32% .9592

Arc1
Arc2
CDSSM
MP
MV-LSTM

(Fu et al. 2016)
(Xie 2017)*

CNN-jieba
CNN-PKU
CNN-CTB
CNN-char

jieba+PKU
PKU+CTB
CTB+jieba
PKU+CTB+jieba

Word+Char
Char+Word
Char+Lattice

DGC-ave
DGC-max
DGC-gated

LCN-ave
LCN-max
LCN-gated

Table 1: The performance of all models on the two datasets.
The best results in each group are bolded. * is the best pub-
lished DBQA result.

et al. 2016) computes the matching score by examining
the interaction between the representations from two sen-
tences obtained by a shared BiLSTM encoder. MatchPyra-
mid(MP) (Pang et al. 2016) utilizes 2D convolutions and
pooling strategies over word pair similarity matrices to com-
pute the matching scores.

We also compare with the state-of-the-art models in

DBQA (Fu, Qiu, and Huang 2016; Xie 2017).

Results

Here, we mainly describe the main results on the DBQA
dataset, while we ﬁnd very similar trends on the KBRE
dataset. Table 1 summarizes the main results on the two
datasets. We can see that the simple MatchZoo models
perform the worst. Although Arc1 and CDSSM are also
constructed in the siamese architecture with CNN layers,
they do not employ multiple kernel sizes and residual con-
nections, and fail to capture the relatedness in a multi-
granularity fashion.

(Fu, Qiu, and Huang 2016) is similar to our word level
models (CNN-jieba/PKU/CTB), but outperforms our mod-
els by around 3%, since it beneﬁts from an extra interaction

layer with ﬁne tuned hyper-parameters. (Xie 2017) further
incorporates human designed features including POS-tag in-
teraction and TF-IDF scores, achieving state-of-the-art per-
formance in the literature of this DBQA dataset. However,
both of them perform worse than our simple CNN-char
model, which is a strong baseline because characters, that
describe the text in a ﬁne granularity, can relieve word mis-
match problem to some extent. And our best LCNs model
further outperforms (Xie 2017) by .0134 in MRR.

For single granularity CNNs, CNN-char performs better
than all word level models, because they heavily suffer from
word mismatching given one ﬁxed word segmentation re-
sult. And the models that utilize different word segmenta-
tions can relieve this problem and gain better performance,
which can be further improved by the combination of words
and characters.

The DGCs and LCNs, being able to work on lattice in-
put, outperform all previous models that have sequential in-
puts, 12 indicating that the word lattice is a more promising
form than a single word sequence, and should be better cap-
tured by taking the inherent graph structure into account. Al-
though they take the same input, LCNs still perform better
than the best DGCs by a margin, showing the advantages of
the CNN kernels over multiple n-grams in the lattice struc-
tures and the gated pooling strategy.

To fairly compare with previous KBQA works, we com-
bine our LCN-ave settings with the entity linking results of
the state-of-the-art KBQA model(Lai et al. 2017). The P@1
for question answering of single LCN-ave is 86.31%, which
outperforms both the best single model (84.55%) and the
best ensembled model (85.40%) in literature.

Analysis and Discussions
Effectiveness of Multi-Granularity information As
shown in Table 1, the combined word level models (e.g.
CTB+jieba or PKU+CTB) perform better than any word
level CNNs with single word segmentation result (e.g.
CNN-CTB or CNN-PKU). The main reason is that there
are often no perfect Chinese word segmenters and a sin-
gle improper segmentation decision may harm the matching
performance, since that could further make the word mis-
matching issue worse, while the combination of different
word segmentation results can somehow relieve this situa-
tion.

Furthermore, the models combining words and charac-
ters all perform better than PKU+CTB+jieba, because they
could be complementary in different granularities. Speciﬁ-
cally, Word+Char is still worse than CNN-char, because
Chinese characters have rich meanings and compressing
several characters to a single word vector will inevitably
lose information. Furthermore, the combined sequence of
Word+Char still exploits in a word level, which still suffers
from the single segmentation decision. On the other side,
the Char+Word model is also slightly worse than CNN-
char. We think one reason is that the reduplicated word em-
beddings concatenated with each character vector confuse

12The best LCN models can reduce the error rates (= 1 - P@1)

over Char+Lattice by 7.04% in DBQA and 6.98% in KBRE.

the CNNs, and perhaps lead to overﬁtting. But, we can still
see that Char+Word performs better than Word+Char, be-
cause the former exploits in a character level and the ﬁne-
granularity information actually helps to relieve word mis-
match. Note that Char+Lattice outperforms Char+Word,
and even slightly better than CNN-char. This illustrates that
multiple word segmentations are still helpful to further im-
prove the character level strong baseline CNN-char, which
may still beneﬁt from word level information in a multi-
granularity fashion.
In conclusion,

the combination between different se-
quences and information of different granularities can help
improve text matching, showing that it is necessary to con-
sider the fashion which considers both characters and more
possible words, which perhaps the word lattice can provide.

Poolings in DGCs and LCNs For DGCs with different
kinds of pooling operations, average pooling (DGC-ave)
performs the best, which delivers similar performance with
LCN-ave. While DGC-max performs a little worse, be-
cause it ignores the importance of different edges and the
maximum operation is more sensitive to noise than the av-
erage operation. The DGC-gated performs the worst. Com-
pared with LCN-gated that learns the gate value adaptively
from multiple n-gram context, it is harder for DGC to learn
the importance of each edge via the node and the center node
in the word lattice. It is not surprising that LCN-gated per-
forms much better than GDC-gated, indicating again that n-
grams in word lattice play an important role in context mod-
eling, while DGCs are designed for general directed graphs
which may not be perfect to work with word lattice.

For LCNs with different pooling operations, LCN-max
and LCN-ave lead to similar performances, and perform
better on KBRE, while LCN-gated is better on DBQA. This
may be due to the fact that sentences in DBQA are relatively
longer with more irrelevant information which require to ﬁl-
ter noisy context, while on KBRE with much shorter predi-
cate phrases, LCN-gated may slightly overﬁt due to its more
complex model structure. Overall, we can see that LCNs per-
form better than DGCs, thanks to the advantage of better
capturing multiple n-grams context in word lattice.

How LCNs utilizes Multi-Granularity To investigate
how LCNs utilize multi-granularity more intuitively, we
analyze the MRR score against granularities of overlaps
between questions and answers in DBQA dataset, which
is shown in Figure 3. It is demonstrated that CNN-char
performs better than CNN-CTB impressively in ﬁrst few
groups where most of the overlaps are single characters
which will cause serious word mismatch. With the grow-
ing of the length of overlaps, CNN-CTB is catching up
and ﬁnally overtakes CNN-char even though its overall per-
formance is much lower. This results show that word in-
formation is complementary to characters to some extent.
The LCN-gated is approaching the CNN-char in ﬁrst few
groups, and outperforms both character and word level mod-
els in next groups, where word level information becomes
more powerful. This demonstrates that LCNs can effectively
take advantages of different granularities, and the combi-
nation will not be harmful even when the matching clues

Figure 3: MRR score against granularities of overlaps be-
tween questions and answers, which is the average length of
longest common substrings. About 2.3% questions are ig-
nored for they have no overlaps and the rests are separated
in 12 groups orderly and equally. Group 1 has the least aver-
age overlap length while group 12 has the largest.

MRR
CNN-char
.8809
LCN-C+2& .8851
.8874
LCN-C+2
.8869
LCN-C+20
.8902
LCN-gated

P@1

l.qu
82.09% 15.9
82.41% 19.9
82.89% 20.4
82.81% 21.4
83.24% 22.3

l.can
38.4
48.0
49.5
51.0
55.8

Table 2: Comparisons of various ways to create word lattice.
l.qu and l.sen are the average token numbers in questions
and sentences respectively. The 3 models in the middle con-
struct lattices by adding words to CNN-char. +2& considers
the intersection of words of CTB and PKU mode while +2
considers the union. +20 uses the top 10 results of the two
segmenters.

present in extreme cases.

How to Create Word Lattice

In previous experiments,
we construct word lattice via an existing lookup vocabu-
lary, which will introduce some noisy words inevitably. Here
we construct from various word segmentations with differ-
ent strategies to investigate the balance between the noisy
words and additional information introduced by word lat-
tice. We only use the DBQA dataset because word lattices
here are more complex, so the construction strategies have
more inﬂuence. Pilot experiments show that word lattices
constructed based on character sequence perform better, so
the strategies in Table 2 are based on CNN-char.

From Table 2, it is shown that all kinds of lattice are bet-
ter than CNN-char, which also evidence the usage of word
information. And among all LCN models, more complex
lattice produces better performance in principle, which in-
dicates that LCNs can handle the noisy words well and the
inﬂuence of noisy words can not cancel the positive infor-
mation brought by complex lattices. It is also noticeable that
LCN-gated is better than LCN-C+20 by a considerable mar-
gin, which shows that the words not in general tokenization
(e.g. “livelihood” in Fig 1) are potentially useful.

Related Work
Deep learning models have been widely adopted in natural
language sentence matching. Representation based models
(Shen et al. 2014; Yu et al. 2014; Yih, He, and Meek 2014;
Yu et al. 2017) encode and compare matching branches in
hidden space. Interaction based models (Pang et al. 2016;
Wan et al. 2016; Wang, Hamza, and Florian 2017) incorpo-
rates interactions features between all word pairs and adopts
2D-convolution to extract matching features. Our models are
built upon the representation based architecture, which is
better for short text matching.

In recent years, many researchers have become interested
in utilizing all sorts of external or multi-granularity informa-
tion in matching tasks. (Yin and Sch¨utze 2015) exploit hid-
den units in different depths to realize interaction between
substrings with different lengths. (Wang, Hamza, and Flo-
rian 2017) join multiple pooling methods in merging sen-
tence level features, (Chen et al. 2018) exploit interactions
between different lengths of text spans. For those more sim-
ilar to our work, (Wang, Hamza, and Florian 2017) also
incorporate characters, which is fed into LSTMs and con-
catenate the outcomes with word embeddings, and (Yu et
al. 2017) utilize words together with predicate level tokens
in KBRE task. However, none of them exploit the multi-
granularity information in word lattice in languages like
Chinese that do not have space to segment words naturally.
Furthermore, our model has no conﬂicts with most of them
except (Wang, Hamza, and Florian 2017) and could gain fur-
ther improvement.

GCNs(Bruna et al. 2014; Defferrard, Bresson, and Van-
dergheynst 2016) and graph-RNNs(Peng et al. 2017; Song et
al. 2018) have extended CNNs and RNNs to model graph in-
formation, and DGCs generalize GCNs on directed graphs in
the ﬁelds of semantic-role labeling (Marcheggiani and Titov
2017), document dating (Vashishth et al. 2018), and SQL
query embedding(Xu et al. 2018). However, DGCs control
information ﬂowing from neighbor vertexes via edge types,
while we focus on capturing different contexts for each word
in word lattice via convolutional kernels and poolings.

Previous works involved Chinese lattice into RNNs for
Chinese-English translation(Su et al. 2017), Chinese named
entity recognition(Zhang and Yang 2018), and Chinese word
segmentation(Yang, Zhang, and Liang 2018). To the best of
our knowledge, we are the ﬁrst to conduct CNNs on word
lattice, and the ﬁrst to involve word lattice in matching tasks.
And we motivate to utilize multi-granularity information in
word lattices to relieve word mismatch and diverse expres-
sions in Chinese question answering, while they mainly fo-
cus on error propagations from segmenters.

Conclusions
In this paper, we propose a novel neural network matching
method (LCNs) for matching based question answering in
Chinese. Rather than relying on a word sequence only, our
model takes word lattice as input. By performing CNNs over
multiple n-gram context to exploit multi-granularity infor-
mation, LCNs can relieve the word mismatch challenges.
Thorough experiments show that our model can better ex-

Figure 4: Example, a question (in word) and 3 sentences se-
lected by 3 systems. Bold means exactly sequence match
between question and answer. Words with wave lines are
mentioned in Section Case Study.

Parameters and Efﬁciency LCNs only introduce inap-
preciable parameters in gated pooling besides the increasing
vocabulary, which will not bring a heavy burden. The train-
ing speed is about 2.8 batches per second, 5 times slower
than original CNNs, and the whole training of a 2-layer
LCN-gated on DBQA dataset only takes about 37.5 min-
utes13. The efﬁciency may be further improved if the net-
work structure builds dynamically with supported frame-
works. The fast speed and little parameter increment give
LCNs a promising future in more NLP tasks.

Case Study
Figure 4 shows a case study comparing models in differ-
ent input levels. The word level model is relatively coarse
in utilizing informations, and ﬁnds a sentence with the
longest overlap (5 words, 12 characters). However, it does
not realize that the question is about numbers of people,
and the “DaoHang”(navigate) in question is a verb, but
noun in the sentence. The character level model ﬁnds a
long sentence which covers most of the characters in ques-
tion, which shows the power of ﬁne-granularity matching.
But without the help of words, it is hard to distinguish the
“Ren”(people) in “DuoShaoRen”(how many people) and
“ChuangShiRen”(founder), so it loses the most important
information. While in lattice, although overlaps are limited,
“WangZhan”(website, “Wang” web, “Zhan” station) can
match “WangZhi”(Internet addresses, “Wang” web, “Zhi”
addresses) and also relate to “DaoHang”(navigate), from
which it may infer that “WangZhan”(website) refers to
“tao606 seller website navigation”(a website name). More-
over, “YongHu”(user) can match “Ren”(people). With co-
operations between characters and words, it catches the key
points of the question and eliminates the other two candi-
dates, as a result, it ﬁnds the correct answer.

13Environment: CPU, 2*XEON E5-2640 v4. GPU: 1*NVIDIA

GeForce 1080Ti

plore the word lattice via convolutional operations and rich
context-aware pooling, thus outperforms the state-of-the-art
models and competitive baselines by a large margin. Further
analyses exhibit that lattice input takes advantages of word
and character level information, and the vocabulary based
lattice constructor outperforms the strategies that combine
characters and different word segmentations together.

Acknowledgments
This work is supported by Natural Science Foundation of
China (Grant No. 61672057, 61672058, 61872294); the UK
Engineering and Physical Sciences Research Council un-
der grants EP/M01567X/1 (SANDeRs) and EP/M015793/1
(DIVIDEND); and the Royal Society International Collab-
oration Grant (IE161012). For any correspondence, please
contact Yansong Feng.

References
[Bromley et al. 1994] Bromley, J.; Guyon, I.; LeCun, Y.;
S¨ackinger, E.; and Shah, R. 1994. Signature veriﬁcation
using a” siamese” time delay neural network. In NIPS 1994,
737–744.
[Bruna et al. 2014] Bruna, J.; Zaremba, W.; Szlam, A.; and
Lecun, Y. 2014. Spectral networks and locally connected
networks on graphs. In ICLR 2014.
[Chen et al. 2018] Chen, H.; Han, F. X.; Niu, D.; Liu, D.; Lai,
K.; Wu, C.; and Xu, Y. 2018. Mix: Multi-channel informa-
tion crossing for text matching. In KDD 2018, 110–119.
[Defferrard, Bresson, and Vandergheynst 2016] Defferrard,
M.; Bresson, X.; and Vandergheynst, P. 2016. Convolu-
tional neural networks on graphs with fast localized spectral
ﬁltering. In NIPS 2016, 3844–3852.
[Duan 2016] Duan, N. 2016. Overview of the nlpcc-iccpol
2016 shared task: open domain chinese question answering.
In NLPCC 2016. 942–948.
[Fan et al. 2017] Fan, Y.; Pang, L.; Hou, J.; Guo, J.; Lan, Y.;
and Cheng, X. 2017. Matchzoo: A toolkit for deep text
matching. arXiv preprint arXiv:1707.07270.
[Fu, Qiu, and Huang 2016] Fu, J.; Qiu, X.; and Huang, X.
2016. Convolutional deep neural networks for document-
based question answering. In NLPCC 2016, 790–797.
[He et al. 2016] He, K.; Zhang, X.; Ren, S.; and Sun, J. 2016.
Deep residual learning for image recognition. 770–778.
[Hu et al. 2014] Hu, B.; Lu, Z.; Li, H.; and Chen, Q. 2014.
Convolutional neural network architectures for matching
natural language sentences. In NIPS 2014, 2042–2050.
[Lai et al. 2017] Lai, Y.; Jia, Y.; Lin, Y.; Feng, Y.; and Zhao,
D. 2017. A chinese question answering system for single-
relation factoid questions. In NLPCC 2017, 124–135.
[Marcheggiani and Titov 2017] Marcheggiani, D., and Titov,
I.
Encoding sentences with graph convolu-
tional networks for semantic role labeling. arXiv preprint
arXiv:1703.04826.
[Mitra, Diaz, and Craswell 2017] Mitra, B.; Diaz, F.; and
Craswell, N. 2017. Learning to match using local and dis-

2017.

In WWW

tributed representations of text for web search.
2017, 1291–1299.
[Pang et al. 2016] Pang, L.; Lan, Y.; Guo, J.; Xu, J.; Wan, S.;
and Cheng, X. 2016. Text matching as image recognition.
In AAAI 2016, 2793–2799.
[Peng et al. 2017] Peng, N.; Poon, H.; Quirk, C.; Toutanova,
K.; and Yih, W.-t. 2017. Cross-sentence n-ary relation ex-
traction with graph lstms. TACL 2017 5(1):101–115.
[Seo et al. 2016] Seo, M.; Kembhavi, A.; Farhadi, A.; and
Hajishirzi, H. 2016. Bidirectional attention ﬂow for ma-
chine comprehension. arXiv preprint arXiv:1611.01603.
[Shen et al. 2014] Shen, Y.; He, X.; Gao, J.; Deng, L.; and
Mesnil, G. 2014. Learning semantic representations us-
ing convolutional neural networks for web search. In WWW
2014, 373–374.
[Song et al. 2018] Song, L.; Zhang, Y.; Wang, Z.; and Gildea,
D. 2018. A graph-to-sequence model for amr-to-text gener-
ation. arXiv preprint arXiv:1805.02473.
[Su et al. 2017] Su, J.; Tan, Z.; Xiong, D.; Ji, R.; Shi, X.; and
Liu, Y. 2017. Lattice-based recurrent neural network en-
coders for neural machine translation. In AAAI 2017, 3302–
3308.
[Vashishth et al. 2018] Vashishth, S.; Dasgupta, S. S.; Ray,
S. N.; and Talukdar, P. 2018. Dating documents using graph
convolution networks. In ACL 2018, 1605–1615.
[Wan et al. 2016] Wan, S.; Lan, Y.; Guo, J.; Xu, J.; Pang, L.;
and Cheng, X. 2016. A deep architecture for semantic
matching with multiple positional sentence representations.
In AAAI 2016, volume 16, 2835–2841.
[Wang, Hamza, and Florian 2017] Wang, Z.; Hamza, W.;
and Florian, R.
Bilateral multi-perspective
matching for natural language sentences. arXiv preprint
arXiv:1702.03814.
[Xie 2017] Xie, Z. 2017. Enhancing document-based ques-
tion answering via interaction between question words and
pos tags. In NLPCC 2017, 136–147.
[Xu et al. 2018] Xu, K.; Wu, L.; Wang, Z.; Feng, Y.; and
Sheinin, V. 2018. Sql-to-text generation with graph-to-
sequence model. In EMNLP 2018, 931–936.
[Yang, Zhang, and Liang 2018] Yang, J.; Zhang, Y.; and
Liang, S. 2018. Subword encoding in lattice lstm for chinese
word segmentation. arXiv preprint arXiv:1810.12594.
[Yih et al. 2015] Yih, W. T.; Chang, M. W.; He, X.; and Gao,
J. 2015. Semantic parsing via staged query graph gener-
In ACL
ation: Question answering with knowledge base.
2015, 1321–1331.
[Yih, He, and Meek 2014] Yih, W. T.; He, X.; and Meek, C.
2014. Semantic parsing for single-relation question answer-
ing. In ACL 2014, 643–648.
[Yin and Sch¨utze 2015] Yin, W., and Sch¨utze, H.
2015.
Multigrancnn: An architecture for general matching of text
chunks on multiple levels of granularity. In ACL 2015, 63–
73.
[Yu et al. 2014] Yu, L.; Hermann, K. M.; Blunsom, P.; and

2017.

Pulman, S. 2014. Deep learning for answer sentence selec-
tion. arXiv preprint arXiv:1412.1632.
[Yu et al. 2017] Yu, M.; Yin, W.; Hasan, K. S.; Santos, C. d.;
Xiang, B.; and Zhou, B. 2017.
Improved neural relation
detection for knowledge base question answering. arXiv
preprint arXiv:1704.06194.
[Zeiler 2012] Zeiler, M. D. 2012. Adadelta: an adaptive
learning rate method. arXiv preprint arXiv:1212.5701.
[Zhang and Yang 2018] Zhang, Y., and Yang, J.
Chinese ner using lattice
arXiv:1805.02023.

2018.
arXiv preprint

lstm.

