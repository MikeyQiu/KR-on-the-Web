8
1
0
2
 
r
p
A
 
3
 
 
]
L
C
.
s
c
[
 
 
1
v
7
5
8
0
0
.
4
0
8
1
:
v
i
X
r
a

Published as a conference paper at ICLR 2018

BI-DIRECTIONAL BLOCK SELF-ATTENTION FOR FAST
AND MEMORY-EFFICIENT SEQUENCE MODELING

Tao Shen†, Tianyi Zhou‡, Guodong Long†, Jing Jiang†& Chengqi Zhang†
†Centre for Artiﬁcial Intelligence, School of Software, University of Technology Sydney
‡Paul G. Allen School of Computer Science & Engineering, University of Washington
tao.shen@student.uts.edu.au,tianyizh@uw.edu
{guodong.long,jing.jiang,chengqi.zhang}@uts.edu.au

ABSTRACT

Recurrent neural networks (RNN), convolutional neural networks (CNN) and self-
attention networks (SAN) are commonly used to produce context-aware represen-
tations. RNN can capture long-range dependency but is hard to parallelize and
not time-efﬁcient. CNN focuses on local dependency but does not perform well
on some tasks. SAN can model both such dependencies via highly parallelizable
computation, but memory requirement grows rapidly in line with sequence length.
In this paper, we propose a model, called “bi-directional block self-attention net-
work (Bi-BloSAN)”, for RNN/CNN-free sequence encoding. It requires as little
memory as RNN but with all the merits of SAN. Bi-BloSAN splits the entire se-
quence into blocks, and applies an intra-block SAN to each block for modeling
local context, then applies an inter-block SAN to the outputs for all blocks to
capture long-range dependency. Thus, each SAN only needs to process a short
sequence, and only a small amount of memory is required. Additionally, we use
feature-level attention to handle the variation of contexts around the same word,
and use forward/backward masks to encode temporal order information. On nine
benchmark datasets for different NLP tasks, Bi-BloSAN achieves or improves
upon state-of-the-art accuracy, and shows better efﬁciency-memory trade-off than
existing RNN/CNN/SAN.

1

INTRODUCTION

Context dependency provides critical information for most natural language processing (NLP) tasks.
In deep neural networks (DNN), context dependency is usually modeled by a context fusion module,
whose goal is to learn a context-aware representation for each token from the input sequence. Re-
current neural networks (RNN), convolutional neural networks (CNN) and self-attention networks
(SAN) are commonly used as context fusion modules. However, each has its own merits and defects,
so which network to use is an open problem and mainly depends on the speciﬁc task.

RNN is broadly used given its capability in capturing long-range dependency through recurrent
computation. It has been applied to various NLP tasks, e.g., question answering (Wang et al., 2017),
neural machine translation (Bahdanau et al., 2015), sentiment analysis (Qian et al., 2017), natural
language inference (Liu et al., 2016), etc. However, training the basic RNN encounters the gradient
dispersion problem, and is difﬁcult to parallelize. Long short-term memory (LSTM) (Hochreiter &
Schmidhuber, 1997) effectively avoids the vanishing gradient. Gated recurrent unit (GRU) (Chung
et al., 2014) and simple recurrent unit (SRU) (Lei & Zhang, 2017) improve the efﬁciency by reducing
parameters and removing partial temporal-dependency, respectively. However, they still suffer from
expensive time cost, especially when applied to long sequences.

CNN becomes popular recently on some NLP tasks because of its the highly parallelizable convo-
lution computation (Dong et al., 2017). Unlike RNN, CNN can simultaneously apply convolutions
deﬁned by different kernels to multiple chunks of a sequence (Kim, 2014). It is mainly used for
sentence-encoding tasks (Lei et al., 2015; Kalchbrenner et al., 2014). Recently, hierarchical CNNs,
e.g. ByteNet (Kalchbrenner et al., 2016), and ConvS2S (Gehring et al., 2017), are proposed to cap-
ture relatively long-range dependencies by using stacking CNNs to increase the number of input

1

Published as a conference paper at ICLR 2018

elements represented in a state. Nonetheless, as mentioned by Vaswani et al. (2017), the number of
CNNs required to relate signals from two arbitrary input grows in the distance between positions,
linearly for ConvS2S and logarithmically for ByteNet. This makes it difﬁcult to learn dependencies
between distant positions.

Recently, self-attention networks (SAN) have been successfully applied to several NLP tasks. It
produces context-aware representation by applying attention to each pair of tokens from the input
sequence. Compared to RNN/CNN, SAN is ﬂexible in modeling both long-range and local depen-
dencies. The major computation in SAN is the highly parallelizable matrix multiplication without
any temporal iteration, which can be easily accelerated by existing tools. Unlike most works that
attach SAN to RNN/CNN as an additional module, two recent works show that SAN independent
of any RNN/CNN module can achieve state-of-the-art performance on several NLP tasks. The ﬁrst,
multi-head attention (Vaswani et al., 2017), is a major component of a seq2seq model “Transformer”
that outperforms previous methods in neural machine translation. It projects the input sequence into
multiple subspaces, applies a SAN to the representation in each subspace, and concatenates the out-
puts. The second, directional self-attention network (DiSAN) (Shen et al., 2017), computes align-
ment scores at feature level, rather than at token level, and applies forward/backward masks to the
alignment score matrix to encode temporal order information. DiSAN achieves the best or state-of-
the-art test accuracy on several NLP tasks by using less computational time and fewer parameters.
More related works can be found in Appendix D.

However, one drawback of SAN is its large memory requirement to store the alignment scores of all
the token pairs; the number grows quadratically with the sequence length. By contrast, RNN/CNN
demand far less memory. The goal of this paper is to develop a novel SAN for RNN/CNN-free
sequence encoding, which requires as little memory as RNN but inherits all the advantages of SAN,
i.e., highly parallelizable computation, the capability/ﬂexibility in modeling both long-range/local
dependencies, and state-of-the-art performance on multiple NLP tasks.

We propose an attention mechanism, called “bi-
directional block self-attention (Bi-BloSA)”, for fast
and memory-efﬁcient context fusion. The basic idea
is to split a sequence into several length-equal blocks
(with padding if necessary), and apply an intra-block
SAN to each block independently. The outputs for
all the blocks are then processed by an inter-block
SAN. The intra-block SAN captures the local depen-
dency within each block, while the inter-block SAN
captures the long-range/global dependency. Hence,
every SAN only needs to process a short sequence.
Compared to a single SAN applied to the whole se-
quence, such two-layer stacked SAN saves a signiﬁ-
cant amount of memory. A feature fusion gate com-
bines the outputs of intra-block and inter-block SAN
with the original input, to produce the ﬁnal context-
aware representations of all the tokens. Similar to di-
rectional self-attention (DiSA) (Shen et al., 2017), Bi-
BloSA uses forward/backward masks to encode the
temporal order information, and feature-level atten-
tion to handle the variation of contexts around the
same word. Further, a RNN/CNN-free sequence encoding model we build based on Bi-BloSA,
called “bi-directional block self-attention network (Bi-BloSAN)”, uses an attention mechanism to
compress the output of Bi-BloSA into a vector representation.

Figure 1: A comparison of Bi-BloSAN and
other RNN/CNN/SAN in terms of train-
ing time, training memory consumption
and test accuracy on SNLI (Bowman et al.,
2015). The details of all the models are pro-
vided in Section 4.

In experiments1, we implement Bi-BloSAN and popular sequence encoding models on several NLP
tasks, e.g., language inference, sentiment analysis, semantic relatedness, reading comprehension,
question-type classiﬁcation, etc. The baseline models include Bi-LSTM, Bi-GRU, Bi-SRU, CNNs,
multi-head attention and DiSAN. A thorough comparison on nine benchmark datasets demonstrates
the advantages of Bi-BloSAN in terms of training speed, inference accuracy and memory consump-
tion. Figure 1 shows that Bi-BloSAN obtains the best accuracy by costing similar training time

1Source code and scripts for experiments are at https://github.com/taoshen58/BiBloSA

2

Published as a conference paper at ICLR 2018

to DiSAN, and as little memory as Bi-LSTM, Bi-GRU and multi-head attention. This shows that
Bi-BloSAN achieves a better efﬁciency-memory trade-off than existing RNN/CNN/SAN models.

Our notations follow these conventions: 1) lowercase denotes a vector; 2) bold lowercase denotes a
sequence of vectors (stored as a matrix); and 3) uppercase denotes a matrix or a tensor.

2 BACKGROUND

2.1 WORD EMBEDDING

Word embedding is the basic processing unit in most DNN for sequence modeling.
It transfers
each discrete token into a representation vector of real values. Given a sequence of tokens (e.g.,
words or characters) w = [w1, w2, . . . , wn] ∈ RN ×n, where wi is a one-hot vector, N is the
vocabulary size and n is the sequence length. A pre-trained token embedding (e.g. word2vec
(Mikolov et al., 2013b)) is applied to w, which outputs a sequence of low dimensional vectors
x = [x1, x2, . . . , xn] ∈ Rde×n. This process can be formally written as x = W (e)w, where
W (e) ∈ Rde×N is the embedding weight matrix that can be ﬁne-tuned during the training phase.

2.2 VANILLA ATTENTION AND MULTI-DIMENSIONAL ATTENTION

Vanilla Attention: Given an input sequence x = [x1, x2, . . . , xn] composed of token embeddings
and a vector representation of a query q ∈ Rdq , vanilla attention (Bahdanau et al., 2015) computes
the alignment score between q and each token xi (reﬂecting the attention of q to xi) using a com-
patibility function f (xi, q). A softmax function then transforms the alignment scores a ∈ Rn to a
probability distribution p(z|x, q), where z is an indicator of which token is important to q. A large
p(z = i|x, q) means that xi contributes important information to q. This process can be written as

The output s is the expectation of sampling a token according to its importance, i.e.,

a = [f (xi, q)]n
p(z|x, q) = softmax(a).

i=1 ,

s =

p(z = i|x, q)xi = Ei∼p(z|x,q)(xi).

n
(cid:88)

i=1

Multiplicative attention (or dot-product attention) (Vaswani et al., 2017; Sukhbaatar et al., 2015;
Rush et al., 2015) and additive attention (or multi-layer perceptron attention) (Bahdanau et al., 2015;
Shang et al., 2015) are two commonly used attention mechanisms. They differ in the choice of
compatibility function f (xi, q). Multiplicative attention uses the cosine similarity for f (xi, q), i.e.,

f (xi, q) =

(cid:68)
W (1)xi, W (2)q

(cid:69)

,

where W (1) ∈ Rdh×de , W (2) ∈ Rdh×dq are the learnable parameters. Additive attention is deﬁned as

f (xi, q) = wT σ(W (1)xi + W (2)q + b(1)) + b,
(5)
where w ∈ Rdh , b(1) and b are the biases, and σ(·) is an activation function. Additive attention
usually achieves better empirical performance than multiplicative attention, but is expensive in time
cost and memory consumption.

Multi-dimensional Attention: Unlike vanilla attention, in multi-dimensional (multi-dim) attention
(Shen et al., 2017), the alignment score is computed for each feature, i.e., the score of a token pair
is a vector rather than a scalar, so the score might be large for some features but small for others.
Therefore, it is more expressive than vanilla attention, especially for the words whose meaning varies
in different contexts.

Multi-dim attention has de indicators z1, . . . , zde for de features. Each indicator has a probability
distribution that is generated by applying softmax to the n alignment scores of the corresponding
feature. Hence, for each feature k in each token i, we have Pki (cid:44) p(zk = i|x, q) where P ∈ Rde×n.

(1)
(2)

(3)

(4)

3

Published as a conference paper at ICLR 2018

A large Pki means that the feature k in token i is important to q. The output of multi-dim attention
is written as

(cid:104)(cid:88)n

s =

Pkixki

i=1

(cid:105)de

k=1

= (cid:2)Ei∼p(zk|x,q)(xki)(cid:3)de

k=1 .

(6)

For simplicity, we ignore the subscript k where no confusion is caused. Then, Eq.(6) can be rewritten
as an element-wise product, i.e., s = (cid:80)n
i=1 P·i (cid:12) xi. Here, P·i is computed by the additive attention
in Eq.(5) where wT is replaced with a weight matrix W ∈ Rdh×de , which leads to a score vector for
each token pair.

2.3 TWO TYPES OF SELF-ATTENTION

token2token self-attention (Hu et al., 2017; Vaswani et al., 2017; Shen et al., 2017) produces
context-aware representations by exploring the dependency between two tokens xi and xj from
the same sequence x. In particular, q in Eq.(5) is replaced with xj, i.e.,

f (xi, xj) = W T σ(W (1)xi + W (2)xj + b(1)) + b.
Similar to the P in multi-dim attention, each input token xj is associated with a probability matrix
(cid:44) p(zk = i|x, xj). The output representation for xj is sj = (cid:80)n
P j such that P j
·i (cid:12) xi and
ki
the ﬁnal output of token2token self-attention is s = [s1, s2, . . . , sn].

i=1 P j

(7)

source2token self-attention (Lin et al., 2017; Shen et al., 2017; Liu et al., 2016) explores the im-
portance of each token to the entire sentence given a speciﬁc task. In particular, q is removed from
Eq.(5), and the following equation is used as the compatibility function.

f (xi) = W T σ(W (1)xi + b(1)) + b.
(8)
The probability matrix P is deﬁned as Pki (cid:44) p(zk = i|x). The ﬁnal output of source2token self-
attention has the same form as multi-dim attention, i.e., s = (cid:80)n

i=1 P·i (cid:12) xi

2.4 MASKED SELF-ATTENTION

Temporal order information is difﬁcult to en-
code in token2token self-attention introduced
above because the alignment score between two
tokens is symmetric. Masked self-attention
(Shen et al., 2017) applies a mask M ∈ Rn×n
to the alignment score matrix (or tensor due to
feature-level score) computed by Eq.(7), so it
allows one-way attention from one token to an-
other. Speciﬁcally, the bias b in Eq.(7) is re-
placed with a constant vector Mij1, where the
1 is an all-one vector. In addition, W is ﬁxed to
a scalar c and tanh(·/c) is used as the activation
function σ(·), i.e.,

Figure 2: Masked self-attention mechanism. fij de-
notes f (xi, xj) in Eq.(9).

f (xi, xj) = c · tanh

(cid:16)

(cid:17)
[W (1)xi + W (2)xj + b(1)]/c

+ Mij1,

(9)

where W (1) ∈ Rde×de , W (2) ∈ Rde×dq . The procedures to calculate the attention output from
f (xi, xj) are identical to those in token2token self-attention. We use s = gm(x, M ) to denote the
complete process of masked self-attention with s = [s1, s2, . . . , sn] as the output sequence. An
illustration of masked self-attention is given in Figure 2.
In order to model bi-directional order information, forward mask M f w and backward mask M bw are
respectively substituted into Eq.(9), which results in forward and backward self-attentions. These
two masks are deﬁned as

M f w

ij =

(cid:26) 0,

i < j

−∞, otherwise

M bw

ij =

(cid:26) 0,

i > j

−∞, otherwise

(10)

The outputs of forward and backward self-attentions are denoted by sf w = gm(x, M f w) and
sbw = gm(x, M bw), respectively.

4

Published as a conference paper at ICLR 2018

3 PROPOSED MODEL

In this section, we ﬁrst introduce the “masked block self-attention (mBloSA)” (Section 3.1) as a
fundamental self-attention module. Then, we present the “bi-directional block self-attention net-
work (Bi-BloSAN)” (Section 3.2) for sequence encoding, which uses the “bi-directional block self-
attention (Bi-BloSA)” (mBloSA with forward and backward masks) as its context fusion module.

3.1 MASKED BLOCK SELF-ATTENTION

As shown in Figure 3, masked block self-attention (mBloSA) has three parts from its bottom to top,
i.e., 1) intra-block self-attention, 2) inter-block self-attention, and 3) the context fusion.

Figure 3: Masked block self-attention (mBloSA) mechanism.

Intra-block self-attention: We ﬁrstly split the input sequence of token/word embeddings into m
blocks of equal length r, i.e., [xl]m
l=1 = [x1, x2, . . . , xm] where x1 = [x1, x2, . . . , xr], x2 =
[xr+1, xr+2, . . . , x2r] and xm = [xn−r+1, xn−r+2, . . . , xn]. Padding can be applied to the last block
Intra-block self-attention applies the masked self-attentions gm(·, M ) with shared
if necessary.
parameters to all the blocks , i.e.,

hl = gm(xl, M ), l = 1, 2, . . . , m.

(11)

Its goal is to capture the local context dependency inside each block. Similar to xl, the output rep-
resentations of the tokens in the l-th block are denoted by hl = [hr(l−1)+1, hr(l−1)+2, . . . , hr×l]. Note,
the block length r is a hyper-parameter and m = n/r. In Appendix A, we introduce an approach to
selecting the optimal r, which results in the maximum memory utility rate in expectation.
Inter-block self-attention: To generate a vector representation vl of each block, a source2token
self-attention gs2t(·) is applied to the output hl of the intra-block self-attention on each block, i.e.,

vl = gs2t(hl), l = 1, 2, . . . , m.

(12)

Note we apply the parameter-shared gs2t(·) to hl for different blocks. This provides us with a
sequence v = [v1, v2, . . . , vm] of local-context representations at block level.
Inter-block self-

5

Published as a conference paper at ICLR 2018

attention then applies a masked self-attention to v in order to capture the long-range/global depen-
dency among the blocks, i.e.,

o = gm(v, M ).

To combine the local and global context features at block level, a gate is used to merge the input
and the output of the masked self-attention dynamically. This is similar to the gates in LSTM. The
output sequence e = [e1, . . . , em] of the gate is computed by

G = sigmoid

(cid:16)

W (g1)o + W (g2)v + b(g)(cid:17)

,

e = G (cid:12) o + (1 − G) (cid:12) v

Context fusion: Given the long-range context representations e = [e1, . . . , em] ∈ Rde×m at block
level, we duplicate el for r times to get el = [el, el, . . . , el] (each token in block l has the global
context feature representation el). Let E (cid:44) [el]m
l=1 ∈ Rde×n. Now, we have the input sequence
x of word embeddings, the local context features h produced by intra-block self-attention, and
the long-range/global context features E produced by inter-block self-attention. A feature fusion
gate (Gong & Bowman, 2017) is employed to combine them, and generates the ﬁnal context-aware
representations of all tokens, i.e.,

F = σ

(cid:16)

W (f 1)[x; h; E] + b(f 1)(cid:17)

,

G = sigmoid

(cid:16)

W (f 2)[x; h; E] + b(f 2)(cid:17)

,

(13)

(14)

(15)

(16)

(17)

(18)
where σ(·) is an activation function, and u = [u1, u2, . . . , un] ∈ Rde×n is the mBloSA output,
which consists of the context-aware representations of the n tokens.

u = G (cid:12) F + (1 − G) (cid:12) x,

3.2 BI-DIRECTIONAL BLOCK SELF-ATTENTION NETWORK FOR SEQUENCE ENCODING

We propose a sequence encoding model
“Bi-directional block self-attention net-
work (Bi-BloSAN)” with mBloSA as its
major components.
Its architecture is
shown in Figure 4.
In Bi-BloSAN, two
fully connected layers (with untied param-
eters) are applied to the input sequence of
token embeddings. Their outputs are pro-
cessed by two mBloSA modules respec-
tively. One uses the forward mask M f w
and another uses the backward mask M bw.
Their outputs uf w and ubw are concate-
nated as ubi = [uf w; ubw] ∈ R2de×n.
The idea of bi-directional attention follows
the same spirit as Bi-LSTM and DiSAN. It
encodes temporal order information lacking in existing SAN models. The context fusion module in
Bi-BloSAN, with the input x and the output ubi, is called “Bi-BloSA”. In order to obtain a se-
quence encoding, a source2token self-attention transforms the sequence ubi of concatenated token
representations into a vector representation s.

Figure 4: Bi-directional block self-attention network (Bi-
BloSAN) for sequence encoding.

4 EXPERIMENTS

We conduct the experiments of Bi-BloSAN and several popular RNN/CNN/SAN-based sequence
encoding models on nine benchmark datasets for multiple different NLP tasks. Note that, in some
baseline models, a source2token self-attention is on the top of the models to generate an encoding
for the entire sequence. All the models used for comparisons are listed as follows.

• Bi-LSTM: 600D Bi-directional LSTM (300D forward LSTM + 300D backward LSTM)

(Graves et al., 2013).

6

Published as a conference paper at ICLR 2018

• Bi-GRU: 600D Bi-directional GRU (Chung et al., 2014).
• Bi-SRU: 600D Bi-directional SRU (Lei & Zhang, 2017) (with sped-up recurrence but no

CUDA level optimization for fair comparison).

• Multi-CNN: 600D CNN sentence embedding model (Kim, 2014) (200D for each of 3, 4,

5-gram).

• Hrchy-CNN: 3-layer 300D CNN (Gehring et al., 2017) with kernel length 5, to which gated
linear units (Dauphin et al., 2016) and residual connection (He et al., 2016) are applied.
• Multi-head: 600D Multi-head attention (Vaswani et al., 2017) (8 heads, each has 75 hidden
units). The positional encoding method used in Vaswani et al. (2017) is applied to the input
sequence to encode temporal order information.

• DiSAN: 600D Directional self-attention network (Shen et al., 2017) (300D forward masked

self-attention + 300D backward masked self-attention).

All experimental codes are implemented in Python with Tensorﬂow and run on a single Nvidia GTX
1080Ti graphic card. Both time cost and memory load data are collected under Tensorﬂow1.3 with
CUDA8 and cuDNN6021. In the rest of this section, we conduct the experiments on natural language
inference in Section 4.1, reading comprehension in Section 4.2, semantic relatedness in Section 4.3
and sentence classiﬁcations in Section 4.4. Finally, we analyze the time cost and memory load of
the different models vs. the sequence length in Section 4.5.

4.1 NATURAL LANGUAGE INFERENCE

Natural language inference (NLI) aims to reason the semantic relationship between a pair of sen-
tences, i.e., a premise sentence and a hypothesis sentence. This relationship could be entailment,
neutral or contradiction. In the experiment, we compare Bi-BloSAN to other baselines on the Stan-
ford Natural Language Inference (Bowman et al., 2015) (SNLI)2 dataset, which contains standard
training/dev/test split of 549,367/9,842/9,824 samples.

Table 1: Experimental results for different methods on SNLI. |θ|: the number of parameters (excluding word
embedding part). Train Accu and Test Accu: the accuracies on training and test sets respectively.

Model

|θ|

Train Accu Test Accu

Unlexicalized features (Bowman et al., 2015)
+ Unigram and bigram features (Bowman et al., 2015)

100D LSTM encoders (Bowman et al., 2015)
300D LSTM encoders (Bowman et al., 2016)
1024D GRU encoders (Vendrov et al., 2016)
300D Tree-based CNN encoders (Mou et al., 2016)
300D SPINN-PI encoders (Bowman et al., 2016)
600D Bi-LSTM encoders (Liu et al., 2016)
300D NTI-SLSTM-LSTM encoders (Munkhdalai & Yu, 2017b)
600D Bi-LSTM encoders+intra-attention (Liu et al., 2016)
300D NSE encoders (Munkhdalai & Yu, 2017a)
600D (300+300) Deep Gated Attn. (Chen et al., 2017)

Bi-LSTM (Graves et al., 2013)
Bi-GRU (Chung et al., 2014)
Bi-SRU (Lei & Zhang, 2017)
Multi-CNN (Kim, 2014)
Hrchy-CNN (Gehring et al., 2017)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

480D Bi-BloSAN

49.4
99.7

84.8
83.9
98.8
83.3
89.2
86.4
82.5
84.5
86.2
90.5

90.4
91.9
88.4
89.3
91.3
89.6
91.1

91.7

0.2m
3.0m
15.0m
3.5m
3.7m
2.0m
4.0m
2.8m
3.0m
11.6m

2.9m
2.5m
2.0m
1.4m
3.4m
2.0m
2.3m

2.8m

50.4
78.2

77.6
80.6
81.4
82.1
83.2
83.3
83.4
84.2
84.6
85.5

85.0
84.9
84.8
83.2
83.9
84.2
85.6

85.7

Following the method of applying sentence-encoding to NLI task given in Bowman et al. (2016),
two parameter-tied sentence-encoding models are applied to the premise and the hypothesis sen-
tences respectively, to generate the premise encoding sp and the hypothesis encoding sh. A relation

2https://nlp.stanford.edu/projects/snli/

7

Published as a conference paper at ICLR 2018

representation concatenating sp, sh, sp − sh and sp (cid:12) sh is passed into a 300D fully connected layer,
whose output is given to a 3-unit output layer with softmax to calculate the probability distribution
over the three classes.

Training Setup: The optimization objective is the cross-entropy loss plus L2 regularization penalty.
We minimize the objective by Adadelta (Zeiler, 2012) optimizer which is empirically more stable
than Adam (Kingma & Ba, 2015) on SNLI. The batch size is set to 64 for all methods. The train-
ing phase takes 50 epochs to converge. All weight matrices are initialized by Glorot Initialization
(Glorot & Bengio, 2010), and the biases are initialized with 0. We use 300D GloVe 6B pre-trained
vectors (Pennington et al., 2014) to initialize the word embeddings in x. The Out-of-Vocabulary
words in the training set are randomly initialized by uniform distribution between (−0.05, 0.05).
The word embeddings are ﬁne-tuned during the training. The Dropout (Srivastava et al., 2014) keep
probability and the L2 regularization weight decay factor γ are set to 0.75 and 5×10−5, respectively.
The number of hidden units is 300. The unspeciﬁed activation functions in all models are set to Relu
(Glorot et al., 2011).

In Table 1, we report the number of parameters, and training/test accuracies of all baselines plus
the methods from the ofﬁcial leaderboard. For fair comparison, we use 480D Bi-BloSAN, which
leads to the similar parameter number with that of baseline encoders. Bi-BloSAN achieves the best
test accuracy (similar to DiSAN) among all the sentence encoding models on SNLI. In particular,
compared to the RNN models, Bi-BloSAN outperforms Bi-LSTM encoder, Bi-LSTM with atten-
tion and deep gated attention by 2.4%, 1.5% and 0.2%, respectively. Bi-BloSAN can even perform
better than the semantic tree based models: SPINN-PI encoder (+2.5%)&Tree-based CNN encoder
(+3.6%), and the memory network based model: NSE encoder (+1.1%). Additionally, Bi-BloSAN
achieves the best performance among the baselines which are based on RNN/CNN/SAN. It outper-
forms Bi-LSTM (+0.7%), Bi-GRU (+0.8%), Bi-SRU (+0.9%), multi-CNN (+2.5%), Hrchy-CNN
(+1.8%) and multi-head attention (+1.5%).

Table 2: Time cost and memory consumption of the different methods on SNLI. Time(s)/epoch: average
training time (second) per epoch. Memory(MB): Training GPU memory consumption (Megabyte). Inference
Time(s): average inference time (second) for all dev data on SNLI with test batch size of 100.
Model

Inference Time(s) Test Accuracy

Time(s)/epoch Memory(MB)

Bi-LSTM (Graves et al., 2013)
Bi-GRU (Chung et al., 2014)
Bi-SRU (Lei & Zhang, 2017)
Multi-CNN (Kim, 2014)
Hrchy-CNN (Gehring et al., 2017)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

480D Bi-BloSAN

2080
1728
1630
284
343
345
587

508

1245
1259
731
529
2341
1245
2267

1243

9.2
9.3
8.2
2.4
2.9
3.0
7.0

3.4

85.0
84.9
84.8
83.2
83.9
84.2
85.6

85.7

In addition, we compare time cost and memory consumption of all the baselines in Table 2. Com-
pared to DiSAN with the same test accuracy, Bi-BloSAN is much faster and more memory efﬁcient.
In terms of training and inference time, Bi-BloSAN is 3 ∼ 4× faster than the RNN models (Bi-
LSTM, Bi-GRU, etc.). It is as fast as CNNs and multi-head attention but substantially outperforms
them in test accuracy. In terms of training memory, Bi-BloSAN requires similar GPU memory to
the RNN-based models and multi-head attention, which is much less than that needed by DiSAN.

Finally, we conduct an ablation study of Bi-BloSAN in Table 3.
In particular, we evaluate the
contribution of each part of Bi-BloSAN by the change of test accuracy after removing the part.
The removed part could be: 1) local context representations h, 2) global context representations
E, 3) the context fusion module (mBloSA) or 4) all fundamental modules appeared in this paper.
The results show that both the local and global context representations play signiﬁcant roles in Bi-
BloSAN. They make Bi-BloSAN surpass the state-of-the-art models. Moreover, mBloSA improves
the test accuracy from 83.1% to 85.7%. Source2token self-attention performs much better than
vanilla attention, and improves the test accuracy by 3.3%.

8

Published as a conference paper at ICLR 2018

Table 3: An ablation study of Bi-BloSAN. “Local” denotes the local context representations h and “Global”
denotes the global context representations E. “Bi-BloSAN w/o mBloSA” equals to word embeddings directly
followed by a source2token attention and “Bi-BloSAN w/o mBloSA & source2token self-attn.” equals to word
embeddings plus a vanilla attention without q.

Model

|θ|

Test Accuracy

Bi-BloSAN
Bi-BloSAN w/o Local
Bi-BloSAN w/o Global
Bi-BloSAN w/o mBloSA
Bi-BloSAN w/o mBloSA & source2token self-attn.

2.8m
2.5m
1.8m
0.54m
0.45m

85.7
85.2
85.3
83.1
79.8

4.2 READING COMPREHENSION

Given a passage and a corresponding question, the goal of reading comprehension is to ﬁnd the
correct answer from the passage for the question. We use the Stanford Question Answering Dataset
(Rajpurkar et al., 2016) (SQuAD)3 to evaluate all models. SQuAD consists of questions posed by
crowdworkers on a set of Wikipedia articles, where the answer to each question is a segment of text,
or a span, from the corresponding passage.

Since Bi-BloSAN and other baselines are designed for sequence encoding, such as sentence embed-
ding, we change the task from predicting the answer span to locating the sentence containing the
correct answer. We build a network structure to test the power of sequence encoding in different
models to ﬁnd the correct answers. The details are given in Appendix B.

Training Setup: We use Adadelta optimizer to minimize the cross-entropy loss plus L2 regular-
ization penalty, with batch size of 32. The network parameters and word embeddings initialization
methods are same as those for SNLI, except that both the word embedding dimension and the num-
ber of hidden units are set to 100. We use 0.8 dropout keep probability and 10−4 L2 regularization
weight decay factor.

We evaluate the Bi-BloSAN and the baselines except DiSAN because the memory required by
DiSAN largely exceeds the GPU memory of GTX 1080Ti (11GB). The number of parameters, per
epoch training time and the prediction accuracy on development set are given in Table 4.

Table 4: Experimental results for different methods on modiﬁed SQuAD task.
|θ|
Time(s)/Epoch Dev Accuracy
Context Fusion Method

Bi-LSTM (Graves et al., 2013)
Bi-GRU (Chung et al., 2014)
Bi-SRU (Lei & Zhang, 2017)
Multi-CNN (Kim, 2014)
Multi-head (Vaswani et al., 2017)

Bi-BloSAN

0.71m
0.57m
0.32m
0.60m
0.45m

0.82m

857
782
737
114
140

293

68.01
67.98
67.32
63.58
64.82

68.38

Compared to RNN/CNN models, Bi-BloSAN achieves state-of-the-art prediction accuracy in this
modiﬁed task. Bi-BloSAN shows its competitive context fusion and sequence encoding capability
compared to Bi-LSTM, Bi-GRU, Bi-SRU but is much more time-efﬁcient. In addition, Bi-BloSAN
signiﬁcantly outperforms multi-CNN and multi-head attention.

4.3 SEMANTIC RELATEDNESS

The goal of semantic relatedness is to predict the similarity degree of a given pair of sentences. Un-
like the classiﬁcation problems introduced above, predicting the semantic relatedness of sentences
is a regression problem. We use s1 and s2 to denote the encodings of the two sentences, and as-
sume that the similarity degree is between [1, K]. Following the method introduced by Tai et al.
(2015), the concatenation of s1 (cid:12)s2 and |s1 −s2| is used as the representation of sentence related-

3https://rajpurkar.github.io/SQuAD-explorer/

9

Published as a conference paper at ICLR 2018

ness. This representation is fed into a 300D fully connected layer, followed by a K-unit output layer
with softmax to calculate a probability distribution ˆp. The details of this regression problem can
be found in Appendix C. We evaluate all models on Sentences Involving Compositional Knowledge
(SICK)4 dataset, where the similarity degree is denoted by a real number in the range of [1, 5]. SICK
comprises 9,927 sentence pairs with 4,500/500/4,927 instances for training/dev/test sets.

Training Setup: The optimization objective of this regression problem is the KL-divergence plus
the L2 regularization penalty. We minimize the objective using Adadelta with batch size of 64.
The network parameters and word embeddings are initialized as in SNLI experiment. The keep
probability of dropout is set to 0.7, and the L2 regularization weight decay factor is set to 10−4.

Table 5: Experimental results for different methods on SICK sentence relatedness dataset. The reported
accuracies are the mean of ﬁve runs (standard deviations in parentheses).

Model

Pearson’s r

Spearman’s ρ

MSE

Meaning Factory (Bjerva et al., 2014)
ECNU (Zhao et al., 2014)
DT-RNN (Socher et al., 2014)
SDT-RNN (Socher et al., 2014)
Constituency Tree-LSTM (Tai et al., 2015)
Dependency Tree-LSTM (Tai et al., 2015)

Bi-LSTM (Graves et al., 2013)
Multi-CNN (Kim, 2014)
Hrchy-CNN (Gehring et al., 2017)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

0.8268
0.8414
0.7923 (0.0070)
0.7900 (0.0042)
0.8582 (0.0038)
0.8676 (0.0030)

0.8473 (0.0013)
0.8374 (0.0021)
0.8436 (0.0014)
0.8521 (0.0013)
0.8695 (0.0012)

0.7721
/
0.7319 (0.0071)
0.7304 (0.0042)
0.7966 (0.0053)
0.8083 (0.0042)

0.7913 (0.0019)
0.7793 (0.0028)
0.7874 (0.0022)
0.7942 (0.0050)
0.8139 (0.0012)

0.3224
/
0.3822 (0.0137)
0.3848 (0.0042)
0.2734 (0.0108)
0.2532 (0.0052)

0.3276 (0.0087)
0.3395 (0.0086)
0.3162 (0.0058)
0.3258 (0.0149)
0.2879 (0.0036)

Bi-BloSAN

0.8616 (0.0012)

0.8038 (0.0012)

0.3008 (0.0091)

The performances of all models are shown in Table 5, which shows that Bi-BloSAN achieves state-
of-the-art prediction quality. Although Dependency Tree-LSTM and DiSAN obtain the best perfor-
mance, the Tree-LSTM needs external semantic parsing tree as the recursive input and expensive
recursion computation, and DiSAN requires much larger memory for self-attention calculation. By
contrast, Bi-BloSAN, as a RNN/CNN-free model, shows appealing advantage in terms of memory
and time efﬁciency. Note that, performance of Bi-BloSAN is still better than some common models,
including Bi-LSTM, CNNs and multi-head attention.

4.4 SENTENCE CLASSIFICATIONS

The goal of sentence classiﬁcation is to correctly predict the class label of a given sentence in various
scenarios. We evaluate the models on six sentence classiﬁcation benchmarks for various NLP tasks,
such as sentiment analysis and question-type classiﬁcation. They are listed as follows.

• CR5: Customer reviews (Hu & Liu, 2004) of various products (cameras etc.). This task is

to predict whether the review is positive or negative.

• MPQA6: Opinion polarity detection subtask of the MPQA dataset (Wiebe et al., 2005).

• SUBJ7: Subjectivity dataset (Pang & Lee, 2004), which includes a set of sentences. The

corresponding label indicates whether each sentence is subjective or objective.

• TREC8: TREC question-type classiﬁcation dataset (Li & Roth, 2002) which coarsely clas-

siﬁes the question sentences into six types.

4http://clic.cimec.unitn.it/composes/sick.html
5https://www.cs.uic.edu/˜liub/FBS/sentiment-analysis.html
6http://mpqa.cs.pitt.edu
7https://www.cs.cornell.edu/people/pabo/movie-review-data/
8http://cogcomp.org/Data/QA/QC/

10

Published as a conference paper at ICLR 2018

• SST-19: Stanford Sentiment Treebank (Socher et al., 2013), which is a dataset consisting of
movie reviews with ﬁve ﬁne-grained sentiment labels, i.e., very positive, positive, neutral,
negative and very negative.

• SST-2: Stanford Sentiment Treebank (Socher et al., 2013) with binary sentiment labels.
Compared to SST-1, SST-2 removes the neutral instances, and labels the rest with either
negative or positive.

Note that only SST-1 and SST-2 have the standard training/dev/test split, and TREC has the train-
ing/dev split. We implement 10-fold cross validation on SUBJ, CR and MPQA because the original
datasets do not provide any split. We do not use the Movie Reviews (Pang & Lee, 2005) dataset
because the SST-1/2 are extensions of it.

Training Setup: We use the cross-entropy loss plus L2 regularization penalty as the optimization
objective. We minimize it by Adam with training batch size of 32 (except DiSAN, which uses batch
size of 16 due to the limit of GPU memory). The network parameters and word embeddings are
initialized as in SNLI experiment. To avoid overﬁtting on small datasets, we decrease the dropout
keep probability and the L2 regularization weight decay factor γ to 0.6 and 10−4, respectively.

Table 6: Experimental results for different methods on various sentence classiﬁcation benchmarks. The re-
ported accuracies on CR, MPQA and SUBJ are the mean of 10-fold cross validation, the accuracies on TREC
are the mean of dev accuracies of ﬁve runs, and the accuracies on SST-1 and SST-2 are the mean of test accu-
racies of ﬁve runs. All standard deviations are in parentheses.

Model

MPQA

SUBJ

TREC

SST-1

SST-2

cBoW (Mikolov et al., 2013a)
Skip-thought (Kiros et al., 2015)
DCNN (Kalchbrenner et al., 2014)
AdaSent (Zhao et al., 2015)
SRU (Lei & Zhang, 2017)
Wide CNNs (Lei & Zhang, 2017)

CR

79.9
81.3
/

86.4
87.5
/

91.3
93.6
/

87.3
92.2
93.0

83.6 (1.6) 90.4 (0.7) 92.2 (1.2) 91.1 (1.0)
84.8 (1.3) 89.7 (1.1) 93.4 (0.8) 93.9 (0.6) 89.1 (0.3)
82.2 (2.2) 88.8 (1.2) 92.9 (0.7) 93.2 (0.5) 85.3 (0.4)

/
/
86.8
/

/
/
48.5
/
/
/

Bi-LSTM (Graves et al., 2013)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

84.6 (1.6) 90.2 (0.9) 94.7 (0.7) 94.4 (0.3) 87.7 (0.6) 49.9 (0.8)
82.6 (1.9) 89.8 (1.2) 94.0 (0.8) 93.4 (0.4) 83.9 (0.4) 48.2 (0.6)
84.8 (2.0) 90.1 (0.4) 94.2 (0.6) 94.2 (0.1) 87.8 (0.3) 51.0 (0.7)

Bi-BloSAN

84.8 (0.9) 90.4 (0.8) 94.5 (0.5) 94.8 (0.2) 87.4 (0.2) 50.6 (0.5)

The prediction accuracies of different models on the six benchmark datasets are given in Table 6.
Bi-BloSAN achieves the best prediction accuracies on CR, MPQA and TREC, and state-of-the-
art performances on SUBJ, SST-1 and SST-2 datasets (slightly worse than the best performances).
Although Bi-BloSAN performs a little bit worse than the RNN models on SUBJ and SST-1, it
is much more time-efﬁcient than them. Additionally, on the SST-2 dataset, Bi-BloSAN performs
slightly worse than DiSAN in terms of prediction accuracy (−0.4%) but obtains a signiﬁcantly
higher memory utility rate.

We visualize the progress of training models on CR dataset in Figure 5. The convergence speed of
Bi-BloSAN is∼ 6× and∼ 2× faster than Bi-LSTM and DiSAN respectively. Although Bi-BloSAN
is less time-efﬁcient than CNN and multi-head attention, it has much better prediction quality.

4.5 ANALYSES OF TIME COST AND MEMORY CONSUMPTION

To compare the efﬁciency-memory trade-off for each model on sequences of different lengths, we
generate random tensor data, and feed them into the different sequence encoding models. The
models we evaluate include Bi-LSTM, Bi-GRU, Bi-SRU, CNN, multi-head attention, DiSAN and
Bi-BloSAN. The shape of the random data is [batch size, sequence length, features number]. We ﬁx
the batch size to 64 and the features number to 300, then change the sequence length from 16 to 384
with a step size 16.

We ﬁrst discuss the time cost vs. the sequence length. As shown in Figure 6(a), the inference time of
Bi-BloSAN is similar to those of multi-head attention and multi-CNN, but Bi-BloSAN outperforms

9http://nlp.stanford.edu/sentiment/

11

Published as a conference paper at ICLR 2018

Figure 5: Validation accuracy vs. training time (second) of Bi-LSTM, CNN, multi-head attention, DiSAN and
Bi-BloSAN for 800 training steps on CR dataset. (The Bi-LSTM for 800 steps consumes 279s in total.)

(a)

(b)

Figure 6: (a) Inference time cost and (b) GPU memory consumption of the sequence encoding models vs. the
sequence length with the batch size of 64 and the features number of 300.

both by a large margin on prediction quality in previous experiments. Moreover, Bi-BloSAN is
much faster than the RNN models (Bi-LSTM, Bi-GRU, BI-SRU). In addition, although DiSAN
requires less training time than the RNN models in the experiments above, it is much slower during
the inference phase because the large memory allocation consumes a great amount of time. By
contrast, the block structure of Bi-BloSAN signiﬁcantly reduces the inference time.

The GPU memory consumption vs. the sequence length for each model is visualized in Figure 6(b).
DiSAN is not scalable because its memory grows explosively with the sequence length. Bi-BloSAN
is more memory-efﬁcient and scalable than DiSAN as the growth of its memory is nearly linear.
Although Bi-BloSAN consumes more memory than the RNN models, it experimentally has better
time efﬁciency and prediction quality. Since multi-head attention uses multiplicative attention, it
requires less memory than all additive attention based models, such as DiSAN and Bi-BloSAN, but
multiplicative attention based models usually perform worse than additive attention based models.

5 CONCLUSIONS

This paper presents an attention network, called bi-directional block self-attention network (Bi-
BloSAN), for fast, memory-efﬁcient and RNN/CNN-free sequence modeling. To overcome large
memory consumption of existing self-attention networks, Bi-BloSAN splits the sequence into sev-
eral blocks and employs intra-block and inter-block self-attentions to capture both local and long-

12

Published as a conference paper at ICLR 2018

range context dependencies, respectively. To encode temporal order information, Bi-BloSAN ap-
plies forward and backward masks to the alignment scores between tokens for asymmetric self-
attentions.

Our experiments on nine benchmark datasets for various different NLP tasks show that Bi-BloSAN
can achieve the best or state-of-the-art performance with better efﬁciency-memory trade-off than ex-
isting RNN/CNN/SAN models. Bi-BloSAN is much more time-efﬁcient than the RNN models (e.g.,
Bi-LSTM, Bi-GRU, etc.), requires much less memory than DiSAN, and signiﬁcantly outperforms
the CNN models and multi-head attention on prediction quality.

6 ACKNOWLEDGMENTS

This research was funded by the Australian Government through the Australian Research Coun-
cil (ARC) under grants 1) LP160100630 partnership with Australia Government Department of
Health and 2) LP150100671 partnership with Australia Research Alliance for Children and Youth
(ARACY) and Global Business College Australia (GBCA). We also acknowledge the support of
NVIDIA Corporation with the donation of GPU used for this research.

REFERENCES

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly learning to

align and translate. In ICLR, 2015.

Johannes Bjerva, Johan Bos, Rob Van der Goot, and Malvina Nissim. The meaning factory: Formal semantics
for recognizing textual entailment and determining semantic similarity. In SemEval@ COLING, pp. 642–
646, 2014.

Samuel R. Bowman, Gabor Angeli, Christopher Potts, and Christopher D. Manning. A large annotated corpus

for learning natural language inference. In EMNLP, 2015.

Samuel R Bowman, Jon Gauthier, Abhinav Rastogi, Raghav Gupta, Christopher D Manning, and Christopher

Potts. A fast uniﬁed model for parsing and sentence understanding. In ACL, 2016.

Qian Chen, Xiaodan Zhu, Zhen-Hua Ling, Si Wei, Hui Jiang, and Diana Inkpen. Recurrent neural network-
based sentence encoder with gated attention for natural language inference. In RepEval@ EMNLP, 2017.

Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, and Yoshua Bengio. Empirical evaluation of gated re-

current neural networks on sequence modeling. In NIPS, 2014.

Yann N Dauphin, Angela Fan, Michael Auli, and David Grangier. Language modeling with gated convolutional

networks. arXiv preprint arXiv:1612.08083, 2016.

Xuanyi Dong, Junshi Huang, Yi Yang, and Shuicheng Yan. More is less: A more complicated network with

less inference complexity. In Computer Vision and Pattern Recognition, 2017.

Jonas Gehring, Michael Auli, David Grangier, Denis Yarats, and Yann N Dauphin. Convolutional sequence to

sequence learning. arXiv preprint arXiv:1705.03122, 2017.

Xavier Glorot and Yoshua Bengio. Understanding the difﬁculty of training deep feedforward neural networks.
In Proceedings of the Thirteenth International Conference on Artiﬁcial Intelligence and Statistics, pp. 249–
256, 2010.

Xavier Glorot, Antoine Bordes, and Yoshua Bengio. Deep sparse rectiﬁer neural networks. In Proceedings of

the Fourteenth International Conference on Artiﬁcial Intelligence and Statistics, pp. 315–323, 2011.

Yichen Gong and Samuel R Bowman. Ruminating reader: Reasoning with gated multi-hop attention. arXiv

preprint arXiv:1704.07415, 2017.

Alex Graves, Navdeep Jaitly, and Abdel-rahman Mohamed. Hybrid speech recognition with deep bidirectional
lstm. In Automatic Speech Recognition and Understanding (ASRU), 2013 IEEE Workshop on, pp. 273–278.
IEEE, 2013.

Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In

Proceedings of the IEEE conference on computer vision and pattern recognition, pp. 770–778, 2016.

13

Published as a conference paper at ICLR 2018

Sepp Hochreiter and J¨urgen Schmidhuber. Long short-term memory. Neural computation, 9(8):1735–1780,

1997.

Minghao Hu, Yuxing Peng, and Xipeng Qiu. Reinforced mnemonic reader for machine comprehension. arXiv

preprint arXiv:1705.02798, 2017.

Minqing Hu and Bing Liu. Mining and summarizing customer reviews.

In Proceedings of the tenth ACM

SIGKDD international conference on Knowledge discovery and data mining, pp. 168–177. ACM, 2004.

Nal Kalchbrenner, Edward Grefenstette, and Phil Blunsom. A convolutional neural network for modelling

sentences. arXiv preprint arXiv:1404.2188, 2014.

Nal Kalchbrenner, Lasse Espeholt, Karen Simonyan, Aaron van den Oord, Alex Graves, and Koray

Kavukcuoglu. Neural machine translation in linear time. arXiv preprint arXiv:1610.10099, 2016.

Yoon Kim. Convolutional neural networks for sentence classiﬁcation. In EMNLP, 2014.

Yoon Kim, Carl Denton, Luong Hoang, and Alexander M Rush. Structured attention networks. In ICLR, 2017.

Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In ICLR, 2015.

Ryan Kiros, Yukun Zhu, Ruslan R Salakhutdinov, Richard Zemel, Raquel Urtasun, Antonio Torralba, and Sanja

Fidler. Skip-thought vectors. In NIPS, 2015.

Filippos Kokkinos and Alexandros Potamianos. Structural attention neural networks for improved sentiment

analysis. arXiv preprint arXiv:1701.01811, 2017.

Tao Lei and Yu Zhang. Training rnns as fast as cnns. arXiv preprint arXiv:1709.02755, 2017.

Tao Lei, Regina Barzilay, and Tommi Jaakkola. Molding cnns for text: non-linear, non-consecutive convolu-

tions. In EMNLP, 2015.

Xin Li and Dan Roth. Learning question classiﬁers. In ACL, 2002.

Zheng Li, Yu Zhang, Ying Wei, Yuxiang Wu, and Qiang Yang. End-to-end adversarial memory network for

cross-domain sentiment classiﬁcation. In IJCAI, pp. 2237–2243, 2017.

Zhouhan Lin, Minwei Feng, Cicero Nogueira dos Santos, Mo Yu, Bing Xiang, Bowen Zhou, and Yoshua

Bengio. A structured self-attentive sentence embedding. In ICLR, 2017.

Yang Liu, Chengjie Sun, Lei Lin, and Xiaolong Wang. Learning natural language inference using bidirectional

lstm model and inner-attention. arXiv preprint arXiv:1605.09090, 2016.

Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey Dean. Efﬁcient estimation of word representations in

vector space. arXiv preprint arXiv:1301.3781, 2013a.

Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jeff Dean. Distributed representations of words

and phrases and their compositionality. In NIPS, 2013b.

Lili Mou, Rui Men, Ge Li, Yan Xu, Lu Zhang, Rui Yan, and Zhi Jin. Natural language inference by tree-based

convolution and heuristic matching. In ACL, 2016.

Tsendsuren Munkhdalai and Hong Yu. Neural semantic encoders. In EACL, 2017a.

Tsendsuren Munkhdalai and Hong Yu. Neural tree indexers for text understanding. In EACL, 2017b.

Bo Pang and Lillian Lee. A sentimental education: Sentiment analysis using subjectivity summarization based

on minimum cuts. In ACL, 2004.

to rating scales. In ACL, 2005.

tion. In EMNLP, 2014.

ACL, 2017.

Bo Pang and Lillian Lee. Seeing stars: Exploiting class relationships for sentiment categorization with respect

Jeffrey Pennington, Richard Socher, and Christopher D. Manning. Glove: Global vectors for word representa-

Qiao Qian, Minlie Huang, and Xiaoyan Zhu. Linguistically regularized lstms for sentiment classiﬁcation. In

Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. Squad: 100,000+ questions for machine

comprehension of text. In EMNLP, 2016.

14

Published as a conference paper at ICLR 2018

Alexander M Rush, Sumit Chopra, and Jason Weston. A neural attention model for abstractive sentence sum-

marization. In EMNLP, 2015.

Lifeng Shang, Zhengdong Lu, and Hang Li. Neural responding machine for short-text conversation. In ACL,

2015.

Tao Shen, Tianyi Zhou, Guodong Long, Jing Jiang, Shirui Pan, and Chengqi Zhang. Disan: Directional self-

attention network for rnn/cnn-free language understanding. arXiv preprint arXiv:1709.04696, 2017.

Richard Socher, Alex Perelygin, Jean Y Wu, Jason Chuang, Christopher D Manning, Andrew Y Ng, Christo-
pher Potts, et al. Recursive deep models for semantic compositionality over a sentiment treebank. In EMNLP,
2013.

Richard Socher, Andrej Karpathy, Quoc V Le, Christopher D Manning, and Andrew Y Ng. Grounded com-
positional semantics for ﬁnding and describing images with sentences. Transactions of the Association for
Computational Linguistics, 2:207–218, 2014.

Nitish Srivastava, Geoffrey E Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. Dropout:
a simple way to prevent neural networks from overﬁtting. Journal of Machine Learning Research, 15(1):
1929–1958, 2014.

Sainbayar Sukhbaatar, Jason Weston, Rob Fergus, et al. End-to-end memory networks. In NIPS, 2015.

Kai Sheng Tai, Richard Socher, and Christopher D Manning. Improved semantic representations from tree-

structured long short-term memory networks. In ACL, 2015.

Zhiyang Teng and Yue Zhang. Bidirectional tree-structured lstm with head lexicalization. In ACL, 2017.

Ashish Vaswani, Shazeer, Noam, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser,

and Illia Polosukhin. Attention is all you need. In NIPS, 2017.

Ivan Vendrov, Ryan Kiros, Sanja Fidler, and Raquel Urtasun. Order-embeddings of images and language. In

ICLR, 2016.

Wenhui Wang, Nan Yang, Furu Wei, Baobao Chang, and Ming Zhou. Gated self-matching networks for reading

comprehension and question answering. In ACL, 2017.

Zhiguo Wang, Haitao Mi, Wael Hamza, and Radu Florian. Multi-perspective context matching for machine

comprehension. arXiv preprint arXiv:1612.04211, 2016.

Janyce Wiebe, Theresa Wilson, and Claire Cardie. Annotating expressions of opinions and emotions in lan-

guage. Language resources and evaluation, 39(2):165–210, 2005.

Zichao Yang, Diyi Yang, Chris Dyer, Xiaodong He, Alexander J Smola, and Eduard H Hovy. Hierarchical

attention networks for document classiﬁcation. In HLT-NAACL, 2016.

Matthew D Zeiler. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701, 2012.

Han Zhao, Zhengdong Lu, and Pascal Poupart. Self-adaptive hierarchical sentence model. In IJCAI, 2015.

Jiang Zhao, Tiantian Zhu, and Man Lan. Ecnu: One stone two birds: Ensemble of heterogenous measures for

semantic relatedness and textual entailment. In SemEval@ COLING, pp. 271–277, 2014.

A THE SELECTION OF BLOCK LENGTH

In mBloSA, the length r of each block is a hyper-parameter that determines memory consumption
of mBloSA. To minimize the memory consumption, we propose an approach that calculates the
optimized block length r as follows.

We ﬁrst introduce the method for determining r for a dataset that has ﬁxed sentence length n. Given
the sentence length n and the block number m = n/r, we have the following facts: 1) the ma-
jor memory consumption in mBloSA is dominated by the masked self-attentions gm(·, M ); 2) the
memory consumption of the masked self-attention is proportional to the square of the sentence
length; and 3) mBloSA contains m masked self-attention with a sequence length of r, and 1 masked

15

Published as a conference paper at ICLR 2018

self-attention with a sequence length of m. Therefore, the memory ξ required by mBloSA can be
calculated by

ξ ∝ r2 · m + m2 · 1
n
r
By setting the gradient of ξ w.r.t. r to zero, we know that the memory consumption ξ is minimum
√
when r = 3

= r2 ·

(19)

n
r

+ (

2n.

)2.

Second, we propose a method for selecting r given a dataset with the sentence lengths that follow a
normal distribution N (µ, σ2). We consider the case where mini-batch SGD with a batch size of B or
its variant is used for training. We need to calculate the upper bound of the expectation of the maxi-
mal sentence length for each mini-batch. Let us ﬁrst consider B random variables [X1, X2, . . . , XB]
in the distribution N (0, σ2). The goal is to ﬁnd the upper bound of the expectation of random vari-
able Z + µ, where Z is deﬁned as

(20)

(21)

(22)

By Jensen’s inequality,

Z = max

Xi, for i = 1, 2, . . . , B.

i

etE[Z] ≤ E[etZ] = E[max

etXi]

i

≤

B
(cid:88)

i=1

E[etXi] = net2 σ2

2

Eq.(21) leads to

Let t =

√

2 ln B
σ

tσ2
2
and we obtain the following upper bound.

ln B
t

E[Z] ≤

+

.

√

(23)
Hence, the upper bound of the expectation of the maximal sentence length among all the B sentences
in each mini-batch is σ

2 ln B + µ. Therefore, the block length r is computed by
√

2 ln B

√

E[Z] ≤ σ

√
r = 3

2n = 3(cid:113)

2(σ

2 ln B + µ).

B NETWORK SETUP FOR MACHINE COMPREHENSION

Each sample in the Stanford Question Answering Dataset (SQuAD) (Rajpurkar et al., 2016) is com-
posed of three parts, i.e., a passage consisting of multiple sentences, a question sentence and a span
in the passage indicating the position of the answer. In order to evaluate the performance of sen-
tence embedding models, we change the task from predicting the span of the answer to ﬁnding the
sentence containing the correct answer.
Given a passage consisting of m sentences [s1, s2, . . . , sm] where sk = [xk1, xk2, . . . , xkn], and
the embedded question token sequence q = [q1, q2, . . . , ql], the goal is to predict which sentence in
the m sentences contains the correct answer to the question q.

The neural net we use to evaluate different sequence encoding models is given in Figure 7. First, we
process each sentence from the passage by a context fusion layer with shared parameters, followed
by a source2token self-attention with shared parameters, which outputs a vector representation of the
sentence. Therefore, the m sentences are represented by m vectors [u1, u2, . . . , um]. The question
sentence q is compressed into a vector representation q using source2token self-attention. Second,
we combine each sentence uk with q by concatenating uk, q, uk −q and uk (cid:12) q, i.e.,

ck = [uk; q; uk −q; uk (cid:12) q], for k = 1, 2, . . . , m.
(24)
Then c = [c1, c2, . . . , cm] is fed into another context fusion layer that explores sentence-level de-
pendencies. Finally, the resultant output representation of each sentence is separately fed into a fully
connected layer to compute a scalar score indicating the possibility of the sentence containing the
answer. A softmax function is applied to the scores of all m sentences, to generate a probability
distribution ˆp ∈ Rm for cross-entropy loss function. The sentence with the largest probability is
predicted as the sentence containing the answer.

16

Published as a conference paper at ICLR 2018

Figure 7: The structure of a neural network for machine comprehension. The candidates of the context fusion
layer include Bi-LSTM, Bi-GRU, Bi-SRU, multi-CNN, multi-head attention and Bi-BloSA. Unlike the original
multi-CNN for sentence embedding, we use padding and remove the max-pooling along the time axis to obtain
an output of the same length as input. DiSA is not considered due to memory limitation.

C LOSS OF REGRESSION PROBLEM

Following the setting introduced by Tai et al. (2015) and given a predicted probability distribution ˆp
as the output of a feedforward network, the regression model predicts the similarity degree as

ˆy = βT ˆp,

where β = [1, 2, . . . , K]. The ground-truth similarity degree y should be mapped to a probability
distribution p = [pi]K
i=1 as the training target, where p needs to fulﬁll y = βT p. The mapping can
be deﬁned as

(cid:40)y − (cid:98)y(cid:99),

pi =

(cid:98)y(cid:99) − y + 1,
0

i = (cid:98)y(cid:99) + 1
i = (cid:98)y(cid:99)
otherwise

,

i = 1, 2, . . . , K.

We use KL-divergence between p and ˆp as our loss function, i.e.,

(25)

(26)

(27)

L =

KL(p(k)||ˆp(k)),

1
M

M
(cid:88)

k=1

where the p(k) and ˆp(k) represent the target and predicted probability distributions of the k-th sample,
respectively.

D RELATED WORKS

Recently, several structured attention mechanisms (Kim et al., 2017; Kokkinos & Potamianos, 2017)
are proposed for capturing structural information from input sequence(s). When applied to self-
attention, structured attentions share a similar idea to self-alignment attention (Hu et al., 2017) and
multi-head attention (Vaswani et al., 2017) with one head, which aims to model the dependencies
between the tokens. Similar to the attention from multiple perspectives in multi-head attention,
multi-perspective context matching (Wang et al., 2016) explores the dependencies between passage
and question from multiple perspectives for reading comprehension, while self-attentive structure
(Lin et al., 2017) embeds sentences from various perspectives to produce matrix representations
In recursive models, self-attention over children nodes (Teng & Zhang, 2017)
of the sentences.
can provide effective input for their parent node that has no standard input (Tai et al., 2015) as
long as it is a non-leaf node in a semantic constituency parsing tree. Li et al. (2017) applies the
multi-hop attention mechanism to transfer learning for cross-domain sentiment analysis without any
RNN/CNN structure.

17

Published as a conference paper at ICLR 2018

Bi-BloSA and hierarchical attention network (Yang et al., 2016) have similar structure, i.e., both
stack two-layer attention mechanisms from bottom to top. However, they are different in three re-
spects: 1) Bi-BloSA aims to learn context-aware representation for each token, while hierarchical
attention is designed for document embedding; 2) the input of Bi-BloSA is a sentence, while the
intput of hierarchical attention is a document composed of multiple sentences; and 3) the hierar-
chical attention performs vanilla attention twice, i.e., token-level attention on each sentence and
sentence-level attention. Bi-BloSA, however, applies masked self-attention twice, i.e., intra-block
self-attention and inter-block self-attention. Additionally, Bi-BloSA uses a feature fusion gate for
each token to combine local and global context, and positional masks to encode temporal order
information.

18

8
1
0
2
 
r
p
A
 
3
 
 
]
L
C
.
s
c
[
 
 
1
v
7
5
8
0
0
.
4
0
8
1
:
v
i
X
r
a

Published as a conference paper at ICLR 2018

BI-DIRECTIONAL BLOCK SELF-ATTENTION FOR FAST
AND MEMORY-EFFICIENT SEQUENCE MODELING

Tao Shen†, Tianyi Zhou‡, Guodong Long†, Jing Jiang†& Chengqi Zhang†
†Centre for Artiﬁcial Intelligence, School of Software, University of Technology Sydney
‡Paul G. Allen School of Computer Science & Engineering, University of Washington
tao.shen@student.uts.edu.au,tianyizh@uw.edu
{guodong.long,jing.jiang,chengqi.zhang}@uts.edu.au

ABSTRACT

Recurrent neural networks (RNN), convolutional neural networks (CNN) and self-
attention networks (SAN) are commonly used to produce context-aware represen-
tations. RNN can capture long-range dependency but is hard to parallelize and
not time-efﬁcient. CNN focuses on local dependency but does not perform well
on some tasks. SAN can model both such dependencies via highly parallelizable
computation, but memory requirement grows rapidly in line with sequence length.
In this paper, we propose a model, called “bi-directional block self-attention net-
work (Bi-BloSAN)”, for RNN/CNN-free sequence encoding. It requires as little
memory as RNN but with all the merits of SAN. Bi-BloSAN splits the entire se-
quence into blocks, and applies an intra-block SAN to each block for modeling
local context, then applies an inter-block SAN to the outputs for all blocks to
capture long-range dependency. Thus, each SAN only needs to process a short
sequence, and only a small amount of memory is required. Additionally, we use
feature-level attention to handle the variation of contexts around the same word,
and use forward/backward masks to encode temporal order information. On nine
benchmark datasets for different NLP tasks, Bi-BloSAN achieves or improves
upon state-of-the-art accuracy, and shows better efﬁciency-memory trade-off than
existing RNN/CNN/SAN.

1

INTRODUCTION

Context dependency provides critical information for most natural language processing (NLP) tasks.
In deep neural networks (DNN), context dependency is usually modeled by a context fusion module,
whose goal is to learn a context-aware representation for each token from the input sequence. Re-
current neural networks (RNN), convolutional neural networks (CNN) and self-attention networks
(SAN) are commonly used as context fusion modules. However, each has its own merits and defects,
so which network to use is an open problem and mainly depends on the speciﬁc task.

RNN is broadly used given its capability in capturing long-range dependency through recurrent
computation. It has been applied to various NLP tasks, e.g., question answering (Wang et al., 2017),
neural machine translation (Bahdanau et al., 2015), sentiment analysis (Qian et al., 2017), natural
language inference (Liu et al., 2016), etc. However, training the basic RNN encounters the gradient
dispersion problem, and is difﬁcult to parallelize. Long short-term memory (LSTM) (Hochreiter &
Schmidhuber, 1997) effectively avoids the vanishing gradient. Gated recurrent unit (GRU) (Chung
et al., 2014) and simple recurrent unit (SRU) (Lei & Zhang, 2017) improve the efﬁciency by reducing
parameters and removing partial temporal-dependency, respectively. However, they still suffer from
expensive time cost, especially when applied to long sequences.

CNN becomes popular recently on some NLP tasks because of its the highly parallelizable convo-
lution computation (Dong et al., 2017). Unlike RNN, CNN can simultaneously apply convolutions
deﬁned by different kernels to multiple chunks of a sequence (Kim, 2014). It is mainly used for
sentence-encoding tasks (Lei et al., 2015; Kalchbrenner et al., 2014). Recently, hierarchical CNNs,
e.g. ByteNet (Kalchbrenner et al., 2016), and ConvS2S (Gehring et al., 2017), are proposed to cap-
ture relatively long-range dependencies by using stacking CNNs to increase the number of input

1

Published as a conference paper at ICLR 2018

elements represented in a state. Nonetheless, as mentioned by Vaswani et al. (2017), the number of
CNNs required to relate signals from two arbitrary input grows in the distance between positions,
linearly for ConvS2S and logarithmically for ByteNet. This makes it difﬁcult to learn dependencies
between distant positions.

Recently, self-attention networks (SAN) have been successfully applied to several NLP tasks. It
produces context-aware representation by applying attention to each pair of tokens from the input
sequence. Compared to RNN/CNN, SAN is ﬂexible in modeling both long-range and local depen-
dencies. The major computation in SAN is the highly parallelizable matrix multiplication without
any temporal iteration, which can be easily accelerated by existing tools. Unlike most works that
attach SAN to RNN/CNN as an additional module, two recent works show that SAN independent
of any RNN/CNN module can achieve state-of-the-art performance on several NLP tasks. The ﬁrst,
multi-head attention (Vaswani et al., 2017), is a major component of a seq2seq model “Transformer”
that outperforms previous methods in neural machine translation. It projects the input sequence into
multiple subspaces, applies a SAN to the representation in each subspace, and concatenates the out-
puts. The second, directional self-attention network (DiSAN) (Shen et al., 2017), computes align-
ment scores at feature level, rather than at token level, and applies forward/backward masks to the
alignment score matrix to encode temporal order information. DiSAN achieves the best or state-of-
the-art test accuracy on several NLP tasks by using less computational time and fewer parameters.
More related works can be found in Appendix D.

However, one drawback of SAN is its large memory requirement to store the alignment scores of all
the token pairs; the number grows quadratically with the sequence length. By contrast, RNN/CNN
demand far less memory. The goal of this paper is to develop a novel SAN for RNN/CNN-free
sequence encoding, which requires as little memory as RNN but inherits all the advantages of SAN,
i.e., highly parallelizable computation, the capability/ﬂexibility in modeling both long-range/local
dependencies, and state-of-the-art performance on multiple NLP tasks.

We propose an attention mechanism, called “bi-
directional block self-attention (Bi-BloSA)”, for fast
and memory-efﬁcient context fusion. The basic idea
is to split a sequence into several length-equal blocks
(with padding if necessary), and apply an intra-block
SAN to each block independently. The outputs for
all the blocks are then processed by an inter-block
SAN. The intra-block SAN captures the local depen-
dency within each block, while the inter-block SAN
captures the long-range/global dependency. Hence,
every SAN only needs to process a short sequence.
Compared to a single SAN applied to the whole se-
quence, such two-layer stacked SAN saves a signiﬁ-
cant amount of memory. A feature fusion gate com-
bines the outputs of intra-block and inter-block SAN
with the original input, to produce the ﬁnal context-
aware representations of all the tokens. Similar to di-
rectional self-attention (DiSA) (Shen et al., 2017), Bi-
BloSA uses forward/backward masks to encode the
temporal order information, and feature-level atten-
tion to handle the variation of contexts around the
same word. Further, a RNN/CNN-free sequence encoding model we build based on Bi-BloSA,
called “bi-directional block self-attention network (Bi-BloSAN)”, uses an attention mechanism to
compress the output of Bi-BloSA into a vector representation.

Figure 1: A comparison of Bi-BloSAN and
other RNN/CNN/SAN in terms of train-
ing time, training memory consumption
and test accuracy on SNLI (Bowman et al.,
2015). The details of all the models are pro-
vided in Section 4.

In experiments1, we implement Bi-BloSAN and popular sequence encoding models on several NLP
tasks, e.g., language inference, sentiment analysis, semantic relatedness, reading comprehension,
question-type classiﬁcation, etc. The baseline models include Bi-LSTM, Bi-GRU, Bi-SRU, CNNs,
multi-head attention and DiSAN. A thorough comparison on nine benchmark datasets demonstrates
the advantages of Bi-BloSAN in terms of training speed, inference accuracy and memory consump-
tion. Figure 1 shows that Bi-BloSAN obtains the best accuracy by costing similar training time

1Source code and scripts for experiments are at https://github.com/taoshen58/BiBloSA

2

Published as a conference paper at ICLR 2018

to DiSAN, and as little memory as Bi-LSTM, Bi-GRU and multi-head attention. This shows that
Bi-BloSAN achieves a better efﬁciency-memory trade-off than existing RNN/CNN/SAN models.

Our notations follow these conventions: 1) lowercase denotes a vector; 2) bold lowercase denotes a
sequence of vectors (stored as a matrix); and 3) uppercase denotes a matrix or a tensor.

2 BACKGROUND

2.1 WORD EMBEDDING

Word embedding is the basic processing unit in most DNN for sequence modeling.
It transfers
each discrete token into a representation vector of real values. Given a sequence of tokens (e.g.,
words or characters) w = [w1, w2, . . . , wn] ∈ RN ×n, where wi is a one-hot vector, N is the
vocabulary size and n is the sequence length. A pre-trained token embedding (e.g. word2vec
(Mikolov et al., 2013b)) is applied to w, which outputs a sequence of low dimensional vectors
x = [x1, x2, . . . , xn] ∈ Rde×n. This process can be formally written as x = W (e)w, where
W (e) ∈ Rde×N is the embedding weight matrix that can be ﬁne-tuned during the training phase.

2.2 VANILLA ATTENTION AND MULTI-DIMENSIONAL ATTENTION

Vanilla Attention: Given an input sequence x = [x1, x2, . . . , xn] composed of token embeddings
and a vector representation of a query q ∈ Rdq , vanilla attention (Bahdanau et al., 2015) computes
the alignment score between q and each token xi (reﬂecting the attention of q to xi) using a com-
patibility function f (xi, q). A softmax function then transforms the alignment scores a ∈ Rn to a
probability distribution p(z|x, q), where z is an indicator of which token is important to q. A large
p(z = i|x, q) means that xi contributes important information to q. This process can be written as

The output s is the expectation of sampling a token according to its importance, i.e.,

a = [f (xi, q)]n
p(z|x, q) = softmax(a).

i=1 ,

s =

p(z = i|x, q)xi = Ei∼p(z|x,q)(xi).

n
(cid:88)

i=1

Multiplicative attention (or dot-product attention) (Vaswani et al., 2017; Sukhbaatar et al., 2015;
Rush et al., 2015) and additive attention (or multi-layer perceptron attention) (Bahdanau et al., 2015;
Shang et al., 2015) are two commonly used attention mechanisms. They differ in the choice of
compatibility function f (xi, q). Multiplicative attention uses the cosine similarity for f (xi, q), i.e.,

f (xi, q) =

(cid:68)
W (1)xi, W (2)q

(cid:69)

,

where W (1) ∈ Rdh×de , W (2) ∈ Rdh×dq are the learnable parameters. Additive attention is deﬁned as

f (xi, q) = wT σ(W (1)xi + W (2)q + b(1)) + b,
(5)
where w ∈ Rdh , b(1) and b are the biases, and σ(·) is an activation function. Additive attention
usually achieves better empirical performance than multiplicative attention, but is expensive in time
cost and memory consumption.

Multi-dimensional Attention: Unlike vanilla attention, in multi-dimensional (multi-dim) attention
(Shen et al., 2017), the alignment score is computed for each feature, i.e., the score of a token pair
is a vector rather than a scalar, so the score might be large for some features but small for others.
Therefore, it is more expressive than vanilla attention, especially for the words whose meaning varies
in different contexts.

Multi-dim attention has de indicators z1, . . . , zde for de features. Each indicator has a probability
distribution that is generated by applying softmax to the n alignment scores of the corresponding
feature. Hence, for each feature k in each token i, we have Pki (cid:44) p(zk = i|x, q) where P ∈ Rde×n.

(1)
(2)

(3)

(4)

3

Published as a conference paper at ICLR 2018

A large Pki means that the feature k in token i is important to q. The output of multi-dim attention
is written as

(cid:104)(cid:88)n

s =

Pkixki

i=1

(cid:105)de

k=1

= (cid:2)Ei∼p(zk|x,q)(xki)(cid:3)de

k=1 .

(6)

For simplicity, we ignore the subscript k where no confusion is caused. Then, Eq.(6) can be rewritten
as an element-wise product, i.e., s = (cid:80)n
i=1 P·i (cid:12) xi. Here, P·i is computed by the additive attention
in Eq.(5) where wT is replaced with a weight matrix W ∈ Rdh×de , which leads to a score vector for
each token pair.

2.3 TWO TYPES OF SELF-ATTENTION

token2token self-attention (Hu et al., 2017; Vaswani et al., 2017; Shen et al., 2017) produces
context-aware representations by exploring the dependency between two tokens xi and xj from
the same sequence x. In particular, q in Eq.(5) is replaced with xj, i.e.,

f (xi, xj) = W T σ(W (1)xi + W (2)xj + b(1)) + b.
Similar to the P in multi-dim attention, each input token xj is associated with a probability matrix
(cid:44) p(zk = i|x, xj). The output representation for xj is sj = (cid:80)n
P j such that P j
·i (cid:12) xi and
ki
the ﬁnal output of token2token self-attention is s = [s1, s2, . . . , sn].

i=1 P j

(7)

source2token self-attention (Lin et al., 2017; Shen et al., 2017; Liu et al., 2016) explores the im-
portance of each token to the entire sentence given a speciﬁc task. In particular, q is removed from
Eq.(5), and the following equation is used as the compatibility function.

f (xi) = W T σ(W (1)xi + b(1)) + b.
(8)
The probability matrix P is deﬁned as Pki (cid:44) p(zk = i|x). The ﬁnal output of source2token self-
attention has the same form as multi-dim attention, i.e., s = (cid:80)n

i=1 P·i (cid:12) xi

2.4 MASKED SELF-ATTENTION

Temporal order information is difﬁcult to en-
code in token2token self-attention introduced
above because the alignment score between two
tokens is symmetric. Masked self-attention
(Shen et al., 2017) applies a mask M ∈ Rn×n
to the alignment score matrix (or tensor due to
feature-level score) computed by Eq.(7), so it
allows one-way attention from one token to an-
other. Speciﬁcally, the bias b in Eq.(7) is re-
placed with a constant vector Mij1, where the
1 is an all-one vector. In addition, W is ﬁxed to
a scalar c and tanh(·/c) is used as the activation
function σ(·), i.e.,

Figure 2: Masked self-attention mechanism. fij de-
notes f (xi, xj) in Eq.(9).

f (xi, xj) = c · tanh

(cid:16)

(cid:17)
[W (1)xi + W (2)xj + b(1)]/c

+ Mij1,

(9)

where W (1) ∈ Rde×de , W (2) ∈ Rde×dq . The procedures to calculate the attention output from
f (xi, xj) are identical to those in token2token self-attention. We use s = gm(x, M ) to denote the
complete process of masked self-attention with s = [s1, s2, . . . , sn] as the output sequence. An
illustration of masked self-attention is given in Figure 2.
In order to model bi-directional order information, forward mask M f w and backward mask M bw are
respectively substituted into Eq.(9), which results in forward and backward self-attentions. These
two masks are deﬁned as

M f w

ij =

(cid:26) 0,

i < j

−∞, otherwise

M bw

ij =

(cid:26) 0,

i > j

−∞, otherwise

(10)

The outputs of forward and backward self-attentions are denoted by sf w = gm(x, M f w) and
sbw = gm(x, M bw), respectively.

4

Published as a conference paper at ICLR 2018

3 PROPOSED MODEL

In this section, we ﬁrst introduce the “masked block self-attention (mBloSA)” (Section 3.1) as a
fundamental self-attention module. Then, we present the “bi-directional block self-attention net-
work (Bi-BloSAN)” (Section 3.2) for sequence encoding, which uses the “bi-directional block self-
attention (Bi-BloSA)” (mBloSA with forward and backward masks) as its context fusion module.

3.1 MASKED BLOCK SELF-ATTENTION

As shown in Figure 3, masked block self-attention (mBloSA) has three parts from its bottom to top,
i.e., 1) intra-block self-attention, 2) inter-block self-attention, and 3) the context fusion.

Figure 3: Masked block self-attention (mBloSA) mechanism.

Intra-block self-attention: We ﬁrstly split the input sequence of token/word embeddings into m
blocks of equal length r, i.e., [xl]m
l=1 = [x1, x2, . . . , xm] where x1 = [x1, x2, . . . , xr], x2 =
[xr+1, xr+2, . . . , x2r] and xm = [xn−r+1, xn−r+2, . . . , xn]. Padding can be applied to the last block
Intra-block self-attention applies the masked self-attentions gm(·, M ) with shared
if necessary.
parameters to all the blocks , i.e.,

hl = gm(xl, M ), l = 1, 2, . . . , m.

(11)

Its goal is to capture the local context dependency inside each block. Similar to xl, the output rep-
resentations of the tokens in the l-th block are denoted by hl = [hr(l−1)+1, hr(l−1)+2, . . . , hr×l]. Note,
the block length r is a hyper-parameter and m = n/r. In Appendix A, we introduce an approach to
selecting the optimal r, which results in the maximum memory utility rate in expectation.
Inter-block self-attention: To generate a vector representation vl of each block, a source2token
self-attention gs2t(·) is applied to the output hl of the intra-block self-attention on each block, i.e.,

vl = gs2t(hl), l = 1, 2, . . . , m.

(12)

Note we apply the parameter-shared gs2t(·) to hl for different blocks. This provides us with a
sequence v = [v1, v2, . . . , vm] of local-context representations at block level.
Inter-block self-

5

Published as a conference paper at ICLR 2018

attention then applies a masked self-attention to v in order to capture the long-range/global depen-
dency among the blocks, i.e.,

o = gm(v, M ).

To combine the local and global context features at block level, a gate is used to merge the input
and the output of the masked self-attention dynamically. This is similar to the gates in LSTM. The
output sequence e = [e1, . . . , em] of the gate is computed by

G = sigmoid

(cid:16)

W (g1)o + W (g2)v + b(g)(cid:17)

,

e = G (cid:12) o + (1 − G) (cid:12) v

Context fusion: Given the long-range context representations e = [e1, . . . , em] ∈ Rde×m at block
level, we duplicate el for r times to get el = [el, el, . . . , el] (each token in block l has the global
context feature representation el). Let E (cid:44) [el]m
l=1 ∈ Rde×n. Now, we have the input sequence
x of word embeddings, the local context features h produced by intra-block self-attention, and
the long-range/global context features E produced by inter-block self-attention. A feature fusion
gate (Gong & Bowman, 2017) is employed to combine them, and generates the ﬁnal context-aware
representations of all tokens, i.e.,

F = σ

(cid:16)

W (f 1)[x; h; E] + b(f 1)(cid:17)

,

G = sigmoid

(cid:16)

W (f 2)[x; h; E] + b(f 2)(cid:17)

,

(13)

(14)

(15)

(16)

(17)

(18)
where σ(·) is an activation function, and u = [u1, u2, . . . , un] ∈ Rde×n is the mBloSA output,
which consists of the context-aware representations of the n tokens.

u = G (cid:12) F + (1 − G) (cid:12) x,

3.2 BI-DIRECTIONAL BLOCK SELF-ATTENTION NETWORK FOR SEQUENCE ENCODING

We propose a sequence encoding model
“Bi-directional block self-attention net-
work (Bi-BloSAN)” with mBloSA as its
major components.
Its architecture is
shown in Figure 4.
In Bi-BloSAN, two
fully connected layers (with untied param-
eters) are applied to the input sequence of
token embeddings. Their outputs are pro-
cessed by two mBloSA modules respec-
tively. One uses the forward mask M f w
and another uses the backward mask M bw.
Their outputs uf w and ubw are concate-
nated as ubi = [uf w; ubw] ∈ R2de×n.
The idea of bi-directional attention follows
the same spirit as Bi-LSTM and DiSAN. It
encodes temporal order information lacking in existing SAN models. The context fusion module in
Bi-BloSAN, with the input x and the output ubi, is called “Bi-BloSA”. In order to obtain a se-
quence encoding, a source2token self-attention transforms the sequence ubi of concatenated token
representations into a vector representation s.

Figure 4: Bi-directional block self-attention network (Bi-
BloSAN) for sequence encoding.

4 EXPERIMENTS

We conduct the experiments of Bi-BloSAN and several popular RNN/CNN/SAN-based sequence
encoding models on nine benchmark datasets for multiple different NLP tasks. Note that, in some
baseline models, a source2token self-attention is on the top of the models to generate an encoding
for the entire sequence. All the models used for comparisons are listed as follows.

• Bi-LSTM: 600D Bi-directional LSTM (300D forward LSTM + 300D backward LSTM)

(Graves et al., 2013).

6

Published as a conference paper at ICLR 2018

• Bi-GRU: 600D Bi-directional GRU (Chung et al., 2014).
• Bi-SRU: 600D Bi-directional SRU (Lei & Zhang, 2017) (with sped-up recurrence but no

CUDA level optimization for fair comparison).

• Multi-CNN: 600D CNN sentence embedding model (Kim, 2014) (200D for each of 3, 4,

5-gram).

• Hrchy-CNN: 3-layer 300D CNN (Gehring et al., 2017) with kernel length 5, to which gated
linear units (Dauphin et al., 2016) and residual connection (He et al., 2016) are applied.
• Multi-head: 600D Multi-head attention (Vaswani et al., 2017) (8 heads, each has 75 hidden
units). The positional encoding method used in Vaswani et al. (2017) is applied to the input
sequence to encode temporal order information.

• DiSAN: 600D Directional self-attention network (Shen et al., 2017) (300D forward masked

self-attention + 300D backward masked self-attention).

All experimental codes are implemented in Python with Tensorﬂow and run on a single Nvidia GTX
1080Ti graphic card. Both time cost and memory load data are collected under Tensorﬂow1.3 with
CUDA8 and cuDNN6021. In the rest of this section, we conduct the experiments on natural language
inference in Section 4.1, reading comprehension in Section 4.2, semantic relatedness in Section 4.3
and sentence classiﬁcations in Section 4.4. Finally, we analyze the time cost and memory load of
the different models vs. the sequence length in Section 4.5.

4.1 NATURAL LANGUAGE INFERENCE

Natural language inference (NLI) aims to reason the semantic relationship between a pair of sen-
tences, i.e., a premise sentence and a hypothesis sentence. This relationship could be entailment,
neutral or contradiction. In the experiment, we compare Bi-BloSAN to other baselines on the Stan-
ford Natural Language Inference (Bowman et al., 2015) (SNLI)2 dataset, which contains standard
training/dev/test split of 549,367/9,842/9,824 samples.

Table 1: Experimental results for different methods on SNLI. |θ|: the number of parameters (excluding word
embedding part). Train Accu and Test Accu: the accuracies on training and test sets respectively.

Model

|θ|

Train Accu Test Accu

Unlexicalized features (Bowman et al., 2015)
+ Unigram and bigram features (Bowman et al., 2015)

100D LSTM encoders (Bowman et al., 2015)
300D LSTM encoders (Bowman et al., 2016)
1024D GRU encoders (Vendrov et al., 2016)
300D Tree-based CNN encoders (Mou et al., 2016)
300D SPINN-PI encoders (Bowman et al., 2016)
600D Bi-LSTM encoders (Liu et al., 2016)
300D NTI-SLSTM-LSTM encoders (Munkhdalai & Yu, 2017b)
600D Bi-LSTM encoders+intra-attention (Liu et al., 2016)
300D NSE encoders (Munkhdalai & Yu, 2017a)
600D (300+300) Deep Gated Attn. (Chen et al., 2017)

Bi-LSTM (Graves et al., 2013)
Bi-GRU (Chung et al., 2014)
Bi-SRU (Lei & Zhang, 2017)
Multi-CNN (Kim, 2014)
Hrchy-CNN (Gehring et al., 2017)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

480D Bi-BloSAN

49.4
99.7

84.8
83.9
98.8
83.3
89.2
86.4
82.5
84.5
86.2
90.5

90.4
91.9
88.4
89.3
91.3
89.6
91.1

91.7

0.2m
3.0m
15.0m
3.5m
3.7m
2.0m
4.0m
2.8m
3.0m
11.6m

2.9m
2.5m
2.0m
1.4m
3.4m
2.0m
2.3m

2.8m

50.4
78.2

77.6
80.6
81.4
82.1
83.2
83.3
83.4
84.2
84.6
85.5

85.0
84.9
84.8
83.2
83.9
84.2
85.6

85.7

Following the method of applying sentence-encoding to NLI task given in Bowman et al. (2016),
two parameter-tied sentence-encoding models are applied to the premise and the hypothesis sen-
tences respectively, to generate the premise encoding sp and the hypothesis encoding sh. A relation

2https://nlp.stanford.edu/projects/snli/

7

Published as a conference paper at ICLR 2018

representation concatenating sp, sh, sp − sh and sp (cid:12) sh is passed into a 300D fully connected layer,
whose output is given to a 3-unit output layer with softmax to calculate the probability distribution
over the three classes.

Training Setup: The optimization objective is the cross-entropy loss plus L2 regularization penalty.
We minimize the objective by Adadelta (Zeiler, 2012) optimizer which is empirically more stable
than Adam (Kingma & Ba, 2015) on SNLI. The batch size is set to 64 for all methods. The train-
ing phase takes 50 epochs to converge. All weight matrices are initialized by Glorot Initialization
(Glorot & Bengio, 2010), and the biases are initialized with 0. We use 300D GloVe 6B pre-trained
vectors (Pennington et al., 2014) to initialize the word embeddings in x. The Out-of-Vocabulary
words in the training set are randomly initialized by uniform distribution between (−0.05, 0.05).
The word embeddings are ﬁne-tuned during the training. The Dropout (Srivastava et al., 2014) keep
probability and the L2 regularization weight decay factor γ are set to 0.75 and 5×10−5, respectively.
The number of hidden units is 300. The unspeciﬁed activation functions in all models are set to Relu
(Glorot et al., 2011).

In Table 1, we report the number of parameters, and training/test accuracies of all baselines plus
the methods from the ofﬁcial leaderboard. For fair comparison, we use 480D Bi-BloSAN, which
leads to the similar parameter number with that of baseline encoders. Bi-BloSAN achieves the best
test accuracy (similar to DiSAN) among all the sentence encoding models on SNLI. In particular,
compared to the RNN models, Bi-BloSAN outperforms Bi-LSTM encoder, Bi-LSTM with atten-
tion and deep gated attention by 2.4%, 1.5% and 0.2%, respectively. Bi-BloSAN can even perform
better than the semantic tree based models: SPINN-PI encoder (+2.5%)&Tree-based CNN encoder
(+3.6%), and the memory network based model: NSE encoder (+1.1%). Additionally, Bi-BloSAN
achieves the best performance among the baselines which are based on RNN/CNN/SAN. It outper-
forms Bi-LSTM (+0.7%), Bi-GRU (+0.8%), Bi-SRU (+0.9%), multi-CNN (+2.5%), Hrchy-CNN
(+1.8%) and multi-head attention (+1.5%).

Table 2: Time cost and memory consumption of the different methods on SNLI. Time(s)/epoch: average
training time (second) per epoch. Memory(MB): Training GPU memory consumption (Megabyte). Inference
Time(s): average inference time (second) for all dev data on SNLI with test batch size of 100.
Model

Inference Time(s) Test Accuracy

Time(s)/epoch Memory(MB)

Bi-LSTM (Graves et al., 2013)
Bi-GRU (Chung et al., 2014)
Bi-SRU (Lei & Zhang, 2017)
Multi-CNN (Kim, 2014)
Hrchy-CNN (Gehring et al., 2017)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

480D Bi-BloSAN

2080
1728
1630
284
343
345
587

508

1245
1259
731
529
2341
1245
2267

1243

9.2
9.3
8.2
2.4
2.9
3.0
7.0

3.4

85.0
84.9
84.8
83.2
83.9
84.2
85.6

85.7

In addition, we compare time cost and memory consumption of all the baselines in Table 2. Com-
pared to DiSAN with the same test accuracy, Bi-BloSAN is much faster and more memory efﬁcient.
In terms of training and inference time, Bi-BloSAN is 3 ∼ 4× faster than the RNN models (Bi-
LSTM, Bi-GRU, etc.). It is as fast as CNNs and multi-head attention but substantially outperforms
them in test accuracy. In terms of training memory, Bi-BloSAN requires similar GPU memory to
the RNN-based models and multi-head attention, which is much less than that needed by DiSAN.

Finally, we conduct an ablation study of Bi-BloSAN in Table 3.
In particular, we evaluate the
contribution of each part of Bi-BloSAN by the change of test accuracy after removing the part.
The removed part could be: 1) local context representations h, 2) global context representations
E, 3) the context fusion module (mBloSA) or 4) all fundamental modules appeared in this paper.
The results show that both the local and global context representations play signiﬁcant roles in Bi-
BloSAN. They make Bi-BloSAN surpass the state-of-the-art models. Moreover, mBloSA improves
the test accuracy from 83.1% to 85.7%. Source2token self-attention performs much better than
vanilla attention, and improves the test accuracy by 3.3%.

8

Published as a conference paper at ICLR 2018

Table 3: An ablation study of Bi-BloSAN. “Local” denotes the local context representations h and “Global”
denotes the global context representations E. “Bi-BloSAN w/o mBloSA” equals to word embeddings directly
followed by a source2token attention and “Bi-BloSAN w/o mBloSA & source2token self-attn.” equals to word
embeddings plus a vanilla attention without q.

Model

|θ|

Test Accuracy

Bi-BloSAN
Bi-BloSAN w/o Local
Bi-BloSAN w/o Global
Bi-BloSAN w/o mBloSA
Bi-BloSAN w/o mBloSA & source2token self-attn.

2.8m
2.5m
1.8m
0.54m
0.45m

85.7
85.2
85.3
83.1
79.8

4.2 READING COMPREHENSION

Given a passage and a corresponding question, the goal of reading comprehension is to ﬁnd the
correct answer from the passage for the question. We use the Stanford Question Answering Dataset
(Rajpurkar et al., 2016) (SQuAD)3 to evaluate all models. SQuAD consists of questions posed by
crowdworkers on a set of Wikipedia articles, where the answer to each question is a segment of text,
or a span, from the corresponding passage.

Since Bi-BloSAN and other baselines are designed for sequence encoding, such as sentence embed-
ding, we change the task from predicting the answer span to locating the sentence containing the
correct answer. We build a network structure to test the power of sequence encoding in different
models to ﬁnd the correct answers. The details are given in Appendix B.

Training Setup: We use Adadelta optimizer to minimize the cross-entropy loss plus L2 regular-
ization penalty, with batch size of 32. The network parameters and word embeddings initialization
methods are same as those for SNLI, except that both the word embedding dimension and the num-
ber of hidden units are set to 100. We use 0.8 dropout keep probability and 10−4 L2 regularization
weight decay factor.

We evaluate the Bi-BloSAN and the baselines except DiSAN because the memory required by
DiSAN largely exceeds the GPU memory of GTX 1080Ti (11GB). The number of parameters, per
epoch training time and the prediction accuracy on development set are given in Table 4.

Table 4: Experimental results for different methods on modiﬁed SQuAD task.
|θ|
Time(s)/Epoch Dev Accuracy
Context Fusion Method

Bi-LSTM (Graves et al., 2013)
Bi-GRU (Chung et al., 2014)
Bi-SRU (Lei & Zhang, 2017)
Multi-CNN (Kim, 2014)
Multi-head (Vaswani et al., 2017)

Bi-BloSAN

0.71m
0.57m
0.32m
0.60m
0.45m

0.82m

857
782
737
114
140

293

68.01
67.98
67.32
63.58
64.82

68.38

Compared to RNN/CNN models, Bi-BloSAN achieves state-of-the-art prediction accuracy in this
modiﬁed task. Bi-BloSAN shows its competitive context fusion and sequence encoding capability
compared to Bi-LSTM, Bi-GRU, Bi-SRU but is much more time-efﬁcient. In addition, Bi-BloSAN
signiﬁcantly outperforms multi-CNN and multi-head attention.

4.3 SEMANTIC RELATEDNESS

The goal of semantic relatedness is to predict the similarity degree of a given pair of sentences. Un-
like the classiﬁcation problems introduced above, predicting the semantic relatedness of sentences
is a regression problem. We use s1 and s2 to denote the encodings of the two sentences, and as-
sume that the similarity degree is between [1, K]. Following the method introduced by Tai et al.
(2015), the concatenation of s1 (cid:12)s2 and |s1 −s2| is used as the representation of sentence related-

3https://rajpurkar.github.io/SQuAD-explorer/

9

Published as a conference paper at ICLR 2018

ness. This representation is fed into a 300D fully connected layer, followed by a K-unit output layer
with softmax to calculate a probability distribution ˆp. The details of this regression problem can
be found in Appendix C. We evaluate all models on Sentences Involving Compositional Knowledge
(SICK)4 dataset, where the similarity degree is denoted by a real number in the range of [1, 5]. SICK
comprises 9,927 sentence pairs with 4,500/500/4,927 instances for training/dev/test sets.

Training Setup: The optimization objective of this regression problem is the KL-divergence plus
the L2 regularization penalty. We minimize the objective using Adadelta with batch size of 64.
The network parameters and word embeddings are initialized as in SNLI experiment. The keep
probability of dropout is set to 0.7, and the L2 regularization weight decay factor is set to 10−4.

Table 5: Experimental results for different methods on SICK sentence relatedness dataset. The reported
accuracies are the mean of ﬁve runs (standard deviations in parentheses).

Model

Pearson’s r

Spearman’s ρ

MSE

Meaning Factory (Bjerva et al., 2014)
ECNU (Zhao et al., 2014)
DT-RNN (Socher et al., 2014)
SDT-RNN (Socher et al., 2014)
Constituency Tree-LSTM (Tai et al., 2015)
Dependency Tree-LSTM (Tai et al., 2015)

Bi-LSTM (Graves et al., 2013)
Multi-CNN (Kim, 2014)
Hrchy-CNN (Gehring et al., 2017)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

0.8268
0.8414
0.7923 (0.0070)
0.7900 (0.0042)
0.8582 (0.0038)
0.8676 (0.0030)

0.8473 (0.0013)
0.8374 (0.0021)
0.8436 (0.0014)
0.8521 (0.0013)
0.8695 (0.0012)

0.7721
/
0.7319 (0.0071)
0.7304 (0.0042)
0.7966 (0.0053)
0.8083 (0.0042)

0.7913 (0.0019)
0.7793 (0.0028)
0.7874 (0.0022)
0.7942 (0.0050)
0.8139 (0.0012)

0.3224
/
0.3822 (0.0137)
0.3848 (0.0042)
0.2734 (0.0108)
0.2532 (0.0052)

0.3276 (0.0087)
0.3395 (0.0086)
0.3162 (0.0058)
0.3258 (0.0149)
0.2879 (0.0036)

Bi-BloSAN

0.8616 (0.0012)

0.8038 (0.0012)

0.3008 (0.0091)

The performances of all models are shown in Table 5, which shows that Bi-BloSAN achieves state-
of-the-art prediction quality. Although Dependency Tree-LSTM and DiSAN obtain the best perfor-
mance, the Tree-LSTM needs external semantic parsing tree as the recursive input and expensive
recursion computation, and DiSAN requires much larger memory for self-attention calculation. By
contrast, Bi-BloSAN, as a RNN/CNN-free model, shows appealing advantage in terms of memory
and time efﬁciency. Note that, performance of Bi-BloSAN is still better than some common models,
including Bi-LSTM, CNNs and multi-head attention.

4.4 SENTENCE CLASSIFICATIONS

The goal of sentence classiﬁcation is to correctly predict the class label of a given sentence in various
scenarios. We evaluate the models on six sentence classiﬁcation benchmarks for various NLP tasks,
such as sentiment analysis and question-type classiﬁcation. They are listed as follows.

• CR5: Customer reviews (Hu & Liu, 2004) of various products (cameras etc.). This task is

to predict whether the review is positive or negative.

• MPQA6: Opinion polarity detection subtask of the MPQA dataset (Wiebe et al., 2005).

• SUBJ7: Subjectivity dataset (Pang & Lee, 2004), which includes a set of sentences. The

corresponding label indicates whether each sentence is subjective or objective.

• TREC8: TREC question-type classiﬁcation dataset (Li & Roth, 2002) which coarsely clas-

siﬁes the question sentences into six types.

4http://clic.cimec.unitn.it/composes/sick.html
5https://www.cs.uic.edu/˜liub/FBS/sentiment-analysis.html
6http://mpqa.cs.pitt.edu
7https://www.cs.cornell.edu/people/pabo/movie-review-data/
8http://cogcomp.org/Data/QA/QC/

10

Published as a conference paper at ICLR 2018

• SST-19: Stanford Sentiment Treebank (Socher et al., 2013), which is a dataset consisting of
movie reviews with ﬁve ﬁne-grained sentiment labels, i.e., very positive, positive, neutral,
negative and very negative.

• SST-2: Stanford Sentiment Treebank (Socher et al., 2013) with binary sentiment labels.
Compared to SST-1, SST-2 removes the neutral instances, and labels the rest with either
negative or positive.

Note that only SST-1 and SST-2 have the standard training/dev/test split, and TREC has the train-
ing/dev split. We implement 10-fold cross validation on SUBJ, CR and MPQA because the original
datasets do not provide any split. We do not use the Movie Reviews (Pang & Lee, 2005) dataset
because the SST-1/2 are extensions of it.

Training Setup: We use the cross-entropy loss plus L2 regularization penalty as the optimization
objective. We minimize it by Adam with training batch size of 32 (except DiSAN, which uses batch
size of 16 due to the limit of GPU memory). The network parameters and word embeddings are
initialized as in SNLI experiment. To avoid overﬁtting on small datasets, we decrease the dropout
keep probability and the L2 regularization weight decay factor γ to 0.6 and 10−4, respectively.

Table 6: Experimental results for different methods on various sentence classiﬁcation benchmarks. The re-
ported accuracies on CR, MPQA and SUBJ are the mean of 10-fold cross validation, the accuracies on TREC
are the mean of dev accuracies of ﬁve runs, and the accuracies on SST-1 and SST-2 are the mean of test accu-
racies of ﬁve runs. All standard deviations are in parentheses.

Model

MPQA

SUBJ

TREC

SST-1

SST-2

cBoW (Mikolov et al., 2013a)
Skip-thought (Kiros et al., 2015)
DCNN (Kalchbrenner et al., 2014)
AdaSent (Zhao et al., 2015)
SRU (Lei & Zhang, 2017)
Wide CNNs (Lei & Zhang, 2017)

CR

79.9
81.3
/

86.4
87.5
/

91.3
93.6
/

87.3
92.2
93.0

83.6 (1.6) 90.4 (0.7) 92.2 (1.2) 91.1 (1.0)
84.8 (1.3) 89.7 (1.1) 93.4 (0.8) 93.9 (0.6) 89.1 (0.3)
82.2 (2.2) 88.8 (1.2) 92.9 (0.7) 93.2 (0.5) 85.3 (0.4)

/
/
86.8
/

/
/
48.5
/
/
/

Bi-LSTM (Graves et al., 2013)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

84.6 (1.6) 90.2 (0.9) 94.7 (0.7) 94.4 (0.3) 87.7 (0.6) 49.9 (0.8)
82.6 (1.9) 89.8 (1.2) 94.0 (0.8) 93.4 (0.4) 83.9 (0.4) 48.2 (0.6)
84.8 (2.0) 90.1 (0.4) 94.2 (0.6) 94.2 (0.1) 87.8 (0.3) 51.0 (0.7)

Bi-BloSAN

84.8 (0.9) 90.4 (0.8) 94.5 (0.5) 94.8 (0.2) 87.4 (0.2) 50.6 (0.5)

The prediction accuracies of different models on the six benchmark datasets are given in Table 6.
Bi-BloSAN achieves the best prediction accuracies on CR, MPQA and TREC, and state-of-the-
art performances on SUBJ, SST-1 and SST-2 datasets (slightly worse than the best performances).
Although Bi-BloSAN performs a little bit worse than the RNN models on SUBJ and SST-1, it
is much more time-efﬁcient than them. Additionally, on the SST-2 dataset, Bi-BloSAN performs
slightly worse than DiSAN in terms of prediction accuracy (−0.4%) but obtains a signiﬁcantly
higher memory utility rate.

We visualize the progress of training models on CR dataset in Figure 5. The convergence speed of
Bi-BloSAN is∼ 6× and∼ 2× faster than Bi-LSTM and DiSAN respectively. Although Bi-BloSAN
is less time-efﬁcient than CNN and multi-head attention, it has much better prediction quality.

4.5 ANALYSES OF TIME COST AND MEMORY CONSUMPTION

To compare the efﬁciency-memory trade-off for each model on sequences of different lengths, we
generate random tensor data, and feed them into the different sequence encoding models. The
models we evaluate include Bi-LSTM, Bi-GRU, Bi-SRU, CNN, multi-head attention, DiSAN and
Bi-BloSAN. The shape of the random data is [batch size, sequence length, features number]. We ﬁx
the batch size to 64 and the features number to 300, then change the sequence length from 16 to 384
with a step size 16.

We ﬁrst discuss the time cost vs. the sequence length. As shown in Figure 6(a), the inference time of
Bi-BloSAN is similar to those of multi-head attention and multi-CNN, but Bi-BloSAN outperforms

9http://nlp.stanford.edu/sentiment/

11

Published as a conference paper at ICLR 2018

Figure 5: Validation accuracy vs. training time (second) of Bi-LSTM, CNN, multi-head attention, DiSAN and
Bi-BloSAN for 800 training steps on CR dataset. (The Bi-LSTM for 800 steps consumes 279s in total.)

(a)

(b)

Figure 6: (a) Inference time cost and (b) GPU memory consumption of the sequence encoding models vs. the
sequence length with the batch size of 64 and the features number of 300.

both by a large margin on prediction quality in previous experiments. Moreover, Bi-BloSAN is
much faster than the RNN models (Bi-LSTM, Bi-GRU, BI-SRU). In addition, although DiSAN
requires less training time than the RNN models in the experiments above, it is much slower during
the inference phase because the large memory allocation consumes a great amount of time. By
contrast, the block structure of Bi-BloSAN signiﬁcantly reduces the inference time.

The GPU memory consumption vs. the sequence length for each model is visualized in Figure 6(b).
DiSAN is not scalable because its memory grows explosively with the sequence length. Bi-BloSAN
is more memory-efﬁcient and scalable than DiSAN as the growth of its memory is nearly linear.
Although Bi-BloSAN consumes more memory than the RNN models, it experimentally has better
time efﬁciency and prediction quality. Since multi-head attention uses multiplicative attention, it
requires less memory than all additive attention based models, such as DiSAN and Bi-BloSAN, but
multiplicative attention based models usually perform worse than additive attention based models.

5 CONCLUSIONS

This paper presents an attention network, called bi-directional block self-attention network (Bi-
BloSAN), for fast, memory-efﬁcient and RNN/CNN-free sequence modeling. To overcome large
memory consumption of existing self-attention networks, Bi-BloSAN splits the sequence into sev-
eral blocks and employs intra-block and inter-block self-attentions to capture both local and long-

12

Published as a conference paper at ICLR 2018

range context dependencies, respectively. To encode temporal order information, Bi-BloSAN ap-
plies forward and backward masks to the alignment scores between tokens for asymmetric self-
attentions.

Our experiments on nine benchmark datasets for various different NLP tasks show that Bi-BloSAN
can achieve the best or state-of-the-art performance with better efﬁciency-memory trade-off than ex-
isting RNN/CNN/SAN models. Bi-BloSAN is much more time-efﬁcient than the RNN models (e.g.,
Bi-LSTM, Bi-GRU, etc.), requires much less memory than DiSAN, and signiﬁcantly outperforms
the CNN models and multi-head attention on prediction quality.

6 ACKNOWLEDGMENTS

This research was funded by the Australian Government through the Australian Research Coun-
cil (ARC) under grants 1) LP160100630 partnership with Australia Government Department of
Health and 2) LP150100671 partnership with Australia Research Alliance for Children and Youth
(ARACY) and Global Business College Australia (GBCA). We also acknowledge the support of
NVIDIA Corporation with the donation of GPU used for this research.

REFERENCES

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly learning to

align and translate. In ICLR, 2015.

Johannes Bjerva, Johan Bos, Rob Van der Goot, and Malvina Nissim. The meaning factory: Formal semantics
for recognizing textual entailment and determining semantic similarity. In SemEval@ COLING, pp. 642–
646, 2014.

Samuel R. Bowman, Gabor Angeli, Christopher Potts, and Christopher D. Manning. A large annotated corpus

for learning natural language inference. In EMNLP, 2015.

Samuel R Bowman, Jon Gauthier, Abhinav Rastogi, Raghav Gupta, Christopher D Manning, and Christopher

Potts. A fast uniﬁed model for parsing and sentence understanding. In ACL, 2016.

Qian Chen, Xiaodan Zhu, Zhen-Hua Ling, Si Wei, Hui Jiang, and Diana Inkpen. Recurrent neural network-
based sentence encoder with gated attention for natural language inference. In RepEval@ EMNLP, 2017.

Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, and Yoshua Bengio. Empirical evaluation of gated re-

current neural networks on sequence modeling. In NIPS, 2014.

Yann N Dauphin, Angela Fan, Michael Auli, and David Grangier. Language modeling with gated convolutional

networks. arXiv preprint arXiv:1612.08083, 2016.

Xuanyi Dong, Junshi Huang, Yi Yang, and Shuicheng Yan. More is less: A more complicated network with

less inference complexity. In Computer Vision and Pattern Recognition, 2017.

Jonas Gehring, Michael Auli, David Grangier, Denis Yarats, and Yann N Dauphin. Convolutional sequence to

sequence learning. arXiv preprint arXiv:1705.03122, 2017.

Xavier Glorot and Yoshua Bengio. Understanding the difﬁculty of training deep feedforward neural networks.
In Proceedings of the Thirteenth International Conference on Artiﬁcial Intelligence and Statistics, pp. 249–
256, 2010.

Xavier Glorot, Antoine Bordes, and Yoshua Bengio. Deep sparse rectiﬁer neural networks. In Proceedings of

the Fourteenth International Conference on Artiﬁcial Intelligence and Statistics, pp. 315–323, 2011.

Yichen Gong and Samuel R Bowman. Ruminating reader: Reasoning with gated multi-hop attention. arXiv

preprint arXiv:1704.07415, 2017.

Alex Graves, Navdeep Jaitly, and Abdel-rahman Mohamed. Hybrid speech recognition with deep bidirectional
lstm. In Automatic Speech Recognition and Understanding (ASRU), 2013 IEEE Workshop on, pp. 273–278.
IEEE, 2013.

Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In

Proceedings of the IEEE conference on computer vision and pattern recognition, pp. 770–778, 2016.

13

Published as a conference paper at ICLR 2018

Sepp Hochreiter and J¨urgen Schmidhuber. Long short-term memory. Neural computation, 9(8):1735–1780,

1997.

Minghao Hu, Yuxing Peng, and Xipeng Qiu. Reinforced mnemonic reader for machine comprehension. arXiv

preprint arXiv:1705.02798, 2017.

Minqing Hu and Bing Liu. Mining and summarizing customer reviews.

In Proceedings of the tenth ACM

SIGKDD international conference on Knowledge discovery and data mining, pp. 168–177. ACM, 2004.

Nal Kalchbrenner, Edward Grefenstette, and Phil Blunsom. A convolutional neural network for modelling

sentences. arXiv preprint arXiv:1404.2188, 2014.

Nal Kalchbrenner, Lasse Espeholt, Karen Simonyan, Aaron van den Oord, Alex Graves, and Koray

Kavukcuoglu. Neural machine translation in linear time. arXiv preprint arXiv:1610.10099, 2016.

Yoon Kim. Convolutional neural networks for sentence classiﬁcation. In EMNLP, 2014.

Yoon Kim, Carl Denton, Luong Hoang, and Alexander M Rush. Structured attention networks. In ICLR, 2017.

Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In ICLR, 2015.

Ryan Kiros, Yukun Zhu, Ruslan R Salakhutdinov, Richard Zemel, Raquel Urtasun, Antonio Torralba, and Sanja

Fidler. Skip-thought vectors. In NIPS, 2015.

Filippos Kokkinos and Alexandros Potamianos. Structural attention neural networks for improved sentiment

analysis. arXiv preprint arXiv:1701.01811, 2017.

Tao Lei and Yu Zhang. Training rnns as fast as cnns. arXiv preprint arXiv:1709.02755, 2017.

Tao Lei, Regina Barzilay, and Tommi Jaakkola. Molding cnns for text: non-linear, non-consecutive convolu-

tions. In EMNLP, 2015.

Xin Li and Dan Roth. Learning question classiﬁers. In ACL, 2002.

Zheng Li, Yu Zhang, Ying Wei, Yuxiang Wu, and Qiang Yang. End-to-end adversarial memory network for

cross-domain sentiment classiﬁcation. In IJCAI, pp. 2237–2243, 2017.

Zhouhan Lin, Minwei Feng, Cicero Nogueira dos Santos, Mo Yu, Bing Xiang, Bowen Zhou, and Yoshua

Bengio. A structured self-attentive sentence embedding. In ICLR, 2017.

Yang Liu, Chengjie Sun, Lei Lin, and Xiaolong Wang. Learning natural language inference using bidirectional

lstm model and inner-attention. arXiv preprint arXiv:1605.09090, 2016.

Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey Dean. Efﬁcient estimation of word representations in

vector space. arXiv preprint arXiv:1301.3781, 2013a.

Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jeff Dean. Distributed representations of words

and phrases and their compositionality. In NIPS, 2013b.

Lili Mou, Rui Men, Ge Li, Yan Xu, Lu Zhang, Rui Yan, and Zhi Jin. Natural language inference by tree-based

convolution and heuristic matching. In ACL, 2016.

Tsendsuren Munkhdalai and Hong Yu. Neural semantic encoders. In EACL, 2017a.

Tsendsuren Munkhdalai and Hong Yu. Neural tree indexers for text understanding. In EACL, 2017b.

Bo Pang and Lillian Lee. A sentimental education: Sentiment analysis using subjectivity summarization based

on minimum cuts. In ACL, 2004.

to rating scales. In ACL, 2005.

tion. In EMNLP, 2014.

ACL, 2017.

Bo Pang and Lillian Lee. Seeing stars: Exploiting class relationships for sentiment categorization with respect

Jeffrey Pennington, Richard Socher, and Christopher D. Manning. Glove: Global vectors for word representa-

Qiao Qian, Minlie Huang, and Xiaoyan Zhu. Linguistically regularized lstms for sentiment classiﬁcation. In

Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. Squad: 100,000+ questions for machine

comprehension of text. In EMNLP, 2016.

14

Published as a conference paper at ICLR 2018

Alexander M Rush, Sumit Chopra, and Jason Weston. A neural attention model for abstractive sentence sum-

marization. In EMNLP, 2015.

Lifeng Shang, Zhengdong Lu, and Hang Li. Neural responding machine for short-text conversation. In ACL,

2015.

Tao Shen, Tianyi Zhou, Guodong Long, Jing Jiang, Shirui Pan, and Chengqi Zhang. Disan: Directional self-

attention network for rnn/cnn-free language understanding. arXiv preprint arXiv:1709.04696, 2017.

Richard Socher, Alex Perelygin, Jean Y Wu, Jason Chuang, Christopher D Manning, Andrew Y Ng, Christo-
pher Potts, et al. Recursive deep models for semantic compositionality over a sentiment treebank. In EMNLP,
2013.

Richard Socher, Andrej Karpathy, Quoc V Le, Christopher D Manning, and Andrew Y Ng. Grounded com-
positional semantics for ﬁnding and describing images with sentences. Transactions of the Association for
Computational Linguistics, 2:207–218, 2014.

Nitish Srivastava, Geoffrey E Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. Dropout:
a simple way to prevent neural networks from overﬁtting. Journal of Machine Learning Research, 15(1):
1929–1958, 2014.

Sainbayar Sukhbaatar, Jason Weston, Rob Fergus, et al. End-to-end memory networks. In NIPS, 2015.

Kai Sheng Tai, Richard Socher, and Christopher D Manning. Improved semantic representations from tree-

structured long short-term memory networks. In ACL, 2015.

Zhiyang Teng and Yue Zhang. Bidirectional tree-structured lstm with head lexicalization. In ACL, 2017.

Ashish Vaswani, Shazeer, Noam, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser,

and Illia Polosukhin. Attention is all you need. In NIPS, 2017.

Ivan Vendrov, Ryan Kiros, Sanja Fidler, and Raquel Urtasun. Order-embeddings of images and language. In

ICLR, 2016.

Wenhui Wang, Nan Yang, Furu Wei, Baobao Chang, and Ming Zhou. Gated self-matching networks for reading

comprehension and question answering. In ACL, 2017.

Zhiguo Wang, Haitao Mi, Wael Hamza, and Radu Florian. Multi-perspective context matching for machine

comprehension. arXiv preprint arXiv:1612.04211, 2016.

Janyce Wiebe, Theresa Wilson, and Claire Cardie. Annotating expressions of opinions and emotions in lan-

guage. Language resources and evaluation, 39(2):165–210, 2005.

Zichao Yang, Diyi Yang, Chris Dyer, Xiaodong He, Alexander J Smola, and Eduard H Hovy. Hierarchical

attention networks for document classiﬁcation. In HLT-NAACL, 2016.

Matthew D Zeiler. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701, 2012.

Han Zhao, Zhengdong Lu, and Pascal Poupart. Self-adaptive hierarchical sentence model. In IJCAI, 2015.

Jiang Zhao, Tiantian Zhu, and Man Lan. Ecnu: One stone two birds: Ensemble of heterogenous measures for

semantic relatedness and textual entailment. In SemEval@ COLING, pp. 271–277, 2014.

A THE SELECTION OF BLOCK LENGTH

In mBloSA, the length r of each block is a hyper-parameter that determines memory consumption
of mBloSA. To minimize the memory consumption, we propose an approach that calculates the
optimized block length r as follows.

We ﬁrst introduce the method for determining r for a dataset that has ﬁxed sentence length n. Given
the sentence length n and the block number m = n/r, we have the following facts: 1) the ma-
jor memory consumption in mBloSA is dominated by the masked self-attentions gm(·, M ); 2) the
memory consumption of the masked self-attention is proportional to the square of the sentence
length; and 3) mBloSA contains m masked self-attention with a sequence length of r, and 1 masked

15

Published as a conference paper at ICLR 2018

self-attention with a sequence length of m. Therefore, the memory ξ required by mBloSA can be
calculated by

ξ ∝ r2 · m + m2 · 1
n
r
By setting the gradient of ξ w.r.t. r to zero, we know that the memory consumption ξ is minimum
√
when r = 3

= r2 ·

(19)

n
r

+ (

2n.

)2.

Second, we propose a method for selecting r given a dataset with the sentence lengths that follow a
normal distribution N (µ, σ2). We consider the case where mini-batch SGD with a batch size of B or
its variant is used for training. We need to calculate the upper bound of the expectation of the maxi-
mal sentence length for each mini-batch. Let us ﬁrst consider B random variables [X1, X2, . . . , XB]
in the distribution N (0, σ2). The goal is to ﬁnd the upper bound of the expectation of random vari-
able Z + µ, where Z is deﬁned as

(20)

(21)

(22)

By Jensen’s inequality,

Z = max

Xi, for i = 1, 2, . . . , B.

i

etE[Z] ≤ E[etZ] = E[max

etXi]

i

≤

B
(cid:88)

i=1

E[etXi] = net2 σ2

2

Eq.(21) leads to

Let t =

√

2 ln B
σ

tσ2
2
and we obtain the following upper bound.

ln B
t

E[Z] ≤

+

.

√

(23)
Hence, the upper bound of the expectation of the maximal sentence length among all the B sentences
in each mini-batch is σ

2 ln B + µ. Therefore, the block length r is computed by
√

2 ln B

√

E[Z] ≤ σ

√
r = 3

2n = 3(cid:113)

2(σ

2 ln B + µ).

B NETWORK SETUP FOR MACHINE COMPREHENSION

Each sample in the Stanford Question Answering Dataset (SQuAD) (Rajpurkar et al., 2016) is com-
posed of three parts, i.e., a passage consisting of multiple sentences, a question sentence and a span
in the passage indicating the position of the answer. In order to evaluate the performance of sen-
tence embedding models, we change the task from predicting the span of the answer to ﬁnding the
sentence containing the correct answer.
Given a passage consisting of m sentences [s1, s2, . . . , sm] where sk = [xk1, xk2, . . . , xkn], and
the embedded question token sequence q = [q1, q2, . . . , ql], the goal is to predict which sentence in
the m sentences contains the correct answer to the question q.

The neural net we use to evaluate different sequence encoding models is given in Figure 7. First, we
process each sentence from the passage by a context fusion layer with shared parameters, followed
by a source2token self-attention with shared parameters, which outputs a vector representation of the
sentence. Therefore, the m sentences are represented by m vectors [u1, u2, . . . , um]. The question
sentence q is compressed into a vector representation q using source2token self-attention. Second,
we combine each sentence uk with q by concatenating uk, q, uk −q and uk (cid:12) q, i.e.,

ck = [uk; q; uk −q; uk (cid:12) q], for k = 1, 2, . . . , m.
(24)
Then c = [c1, c2, . . . , cm] is fed into another context fusion layer that explores sentence-level de-
pendencies. Finally, the resultant output representation of each sentence is separately fed into a fully
connected layer to compute a scalar score indicating the possibility of the sentence containing the
answer. A softmax function is applied to the scores of all m sentences, to generate a probability
distribution ˆp ∈ Rm for cross-entropy loss function. The sentence with the largest probability is
predicted as the sentence containing the answer.

16

Published as a conference paper at ICLR 2018

Figure 7: The structure of a neural network for machine comprehension. The candidates of the context fusion
layer include Bi-LSTM, Bi-GRU, Bi-SRU, multi-CNN, multi-head attention and Bi-BloSA. Unlike the original
multi-CNN for sentence embedding, we use padding and remove the max-pooling along the time axis to obtain
an output of the same length as input. DiSA is not considered due to memory limitation.

C LOSS OF REGRESSION PROBLEM

Following the setting introduced by Tai et al. (2015) and given a predicted probability distribution ˆp
as the output of a feedforward network, the regression model predicts the similarity degree as

ˆy = βT ˆp,

where β = [1, 2, . . . , K]. The ground-truth similarity degree y should be mapped to a probability
distribution p = [pi]K
i=1 as the training target, where p needs to fulﬁll y = βT p. The mapping can
be deﬁned as

(cid:40)y − (cid:98)y(cid:99),

pi =

(cid:98)y(cid:99) − y + 1,
0

i = (cid:98)y(cid:99) + 1
i = (cid:98)y(cid:99)
otherwise

,

i = 1, 2, . . . , K.

We use KL-divergence between p and ˆp as our loss function, i.e.,

(25)

(26)

(27)

L =

KL(p(k)||ˆp(k)),

1
M

M
(cid:88)

k=1

where the p(k) and ˆp(k) represent the target and predicted probability distributions of the k-th sample,
respectively.

D RELATED WORKS

Recently, several structured attention mechanisms (Kim et al., 2017; Kokkinos & Potamianos, 2017)
are proposed for capturing structural information from input sequence(s). When applied to self-
attention, structured attentions share a similar idea to self-alignment attention (Hu et al., 2017) and
multi-head attention (Vaswani et al., 2017) with one head, which aims to model the dependencies
between the tokens. Similar to the attention from multiple perspectives in multi-head attention,
multi-perspective context matching (Wang et al., 2016) explores the dependencies between passage
and question from multiple perspectives for reading comprehension, while self-attentive structure
(Lin et al., 2017) embeds sentences from various perspectives to produce matrix representations
In recursive models, self-attention over children nodes (Teng & Zhang, 2017)
of the sentences.
can provide effective input for their parent node that has no standard input (Tai et al., 2015) as
long as it is a non-leaf node in a semantic constituency parsing tree. Li et al. (2017) applies the
multi-hop attention mechanism to transfer learning for cross-domain sentiment analysis without any
RNN/CNN structure.

17

Published as a conference paper at ICLR 2018

Bi-BloSA and hierarchical attention network (Yang et al., 2016) have similar structure, i.e., both
stack two-layer attention mechanisms from bottom to top. However, they are different in three re-
spects: 1) Bi-BloSA aims to learn context-aware representation for each token, while hierarchical
attention is designed for document embedding; 2) the input of Bi-BloSA is a sentence, while the
intput of hierarchical attention is a document composed of multiple sentences; and 3) the hierar-
chical attention performs vanilla attention twice, i.e., token-level attention on each sentence and
sentence-level attention. Bi-BloSA, however, applies masked self-attention twice, i.e., intra-block
self-attention and inter-block self-attention. Additionally, Bi-BloSA uses a feature fusion gate for
each token to combine local and global context, and positional masks to encode temporal order
information.

18

8
1
0
2
 
r
p
A
 
3
 
 
]
L
C
.
s
c
[
 
 
1
v
7
5
8
0
0
.
4
0
8
1
:
v
i
X
r
a

Published as a conference paper at ICLR 2018

BI-DIRECTIONAL BLOCK SELF-ATTENTION FOR FAST
AND MEMORY-EFFICIENT SEQUENCE MODELING

Tao Shen†, Tianyi Zhou‡, Guodong Long†, Jing Jiang†& Chengqi Zhang†
†Centre for Artiﬁcial Intelligence, School of Software, University of Technology Sydney
‡Paul G. Allen School of Computer Science & Engineering, University of Washington
tao.shen@student.uts.edu.au,tianyizh@uw.edu
{guodong.long,jing.jiang,chengqi.zhang}@uts.edu.au

ABSTRACT

Recurrent neural networks (RNN), convolutional neural networks (CNN) and self-
attention networks (SAN) are commonly used to produce context-aware represen-
tations. RNN can capture long-range dependency but is hard to parallelize and
not time-efﬁcient. CNN focuses on local dependency but does not perform well
on some tasks. SAN can model both such dependencies via highly parallelizable
computation, but memory requirement grows rapidly in line with sequence length.
In this paper, we propose a model, called “bi-directional block self-attention net-
work (Bi-BloSAN)”, for RNN/CNN-free sequence encoding. It requires as little
memory as RNN but with all the merits of SAN. Bi-BloSAN splits the entire se-
quence into blocks, and applies an intra-block SAN to each block for modeling
local context, then applies an inter-block SAN to the outputs for all blocks to
capture long-range dependency. Thus, each SAN only needs to process a short
sequence, and only a small amount of memory is required. Additionally, we use
feature-level attention to handle the variation of contexts around the same word,
and use forward/backward masks to encode temporal order information. On nine
benchmark datasets for different NLP tasks, Bi-BloSAN achieves or improves
upon state-of-the-art accuracy, and shows better efﬁciency-memory trade-off than
existing RNN/CNN/SAN.

1

INTRODUCTION

Context dependency provides critical information for most natural language processing (NLP) tasks.
In deep neural networks (DNN), context dependency is usually modeled by a context fusion module,
whose goal is to learn a context-aware representation for each token from the input sequence. Re-
current neural networks (RNN), convolutional neural networks (CNN) and self-attention networks
(SAN) are commonly used as context fusion modules. However, each has its own merits and defects,
so which network to use is an open problem and mainly depends on the speciﬁc task.

RNN is broadly used given its capability in capturing long-range dependency through recurrent
computation. It has been applied to various NLP tasks, e.g., question answering (Wang et al., 2017),
neural machine translation (Bahdanau et al., 2015), sentiment analysis (Qian et al., 2017), natural
language inference (Liu et al., 2016), etc. However, training the basic RNN encounters the gradient
dispersion problem, and is difﬁcult to parallelize. Long short-term memory (LSTM) (Hochreiter &
Schmidhuber, 1997) effectively avoids the vanishing gradient. Gated recurrent unit (GRU) (Chung
et al., 2014) and simple recurrent unit (SRU) (Lei & Zhang, 2017) improve the efﬁciency by reducing
parameters and removing partial temporal-dependency, respectively. However, they still suffer from
expensive time cost, especially when applied to long sequences.

CNN becomes popular recently on some NLP tasks because of its the highly parallelizable convo-
lution computation (Dong et al., 2017). Unlike RNN, CNN can simultaneously apply convolutions
deﬁned by different kernels to multiple chunks of a sequence (Kim, 2014). It is mainly used for
sentence-encoding tasks (Lei et al., 2015; Kalchbrenner et al., 2014). Recently, hierarchical CNNs,
e.g. ByteNet (Kalchbrenner et al., 2016), and ConvS2S (Gehring et al., 2017), are proposed to cap-
ture relatively long-range dependencies by using stacking CNNs to increase the number of input

1

Published as a conference paper at ICLR 2018

elements represented in a state. Nonetheless, as mentioned by Vaswani et al. (2017), the number of
CNNs required to relate signals from two arbitrary input grows in the distance between positions,
linearly for ConvS2S and logarithmically for ByteNet. This makes it difﬁcult to learn dependencies
between distant positions.

Recently, self-attention networks (SAN) have been successfully applied to several NLP tasks. It
produces context-aware representation by applying attention to each pair of tokens from the input
sequence. Compared to RNN/CNN, SAN is ﬂexible in modeling both long-range and local depen-
dencies. The major computation in SAN is the highly parallelizable matrix multiplication without
any temporal iteration, which can be easily accelerated by existing tools. Unlike most works that
attach SAN to RNN/CNN as an additional module, two recent works show that SAN independent
of any RNN/CNN module can achieve state-of-the-art performance on several NLP tasks. The ﬁrst,
multi-head attention (Vaswani et al., 2017), is a major component of a seq2seq model “Transformer”
that outperforms previous methods in neural machine translation. It projects the input sequence into
multiple subspaces, applies a SAN to the representation in each subspace, and concatenates the out-
puts. The second, directional self-attention network (DiSAN) (Shen et al., 2017), computes align-
ment scores at feature level, rather than at token level, and applies forward/backward masks to the
alignment score matrix to encode temporal order information. DiSAN achieves the best or state-of-
the-art test accuracy on several NLP tasks by using less computational time and fewer parameters.
More related works can be found in Appendix D.

However, one drawback of SAN is its large memory requirement to store the alignment scores of all
the token pairs; the number grows quadratically with the sequence length. By contrast, RNN/CNN
demand far less memory. The goal of this paper is to develop a novel SAN for RNN/CNN-free
sequence encoding, which requires as little memory as RNN but inherits all the advantages of SAN,
i.e., highly parallelizable computation, the capability/ﬂexibility in modeling both long-range/local
dependencies, and state-of-the-art performance on multiple NLP tasks.

We propose an attention mechanism, called “bi-
directional block self-attention (Bi-BloSA)”, for fast
and memory-efﬁcient context fusion. The basic idea
is to split a sequence into several length-equal blocks
(with padding if necessary), and apply an intra-block
SAN to each block independently. The outputs for
all the blocks are then processed by an inter-block
SAN. The intra-block SAN captures the local depen-
dency within each block, while the inter-block SAN
captures the long-range/global dependency. Hence,
every SAN only needs to process a short sequence.
Compared to a single SAN applied to the whole se-
quence, such two-layer stacked SAN saves a signiﬁ-
cant amount of memory. A feature fusion gate com-
bines the outputs of intra-block and inter-block SAN
with the original input, to produce the ﬁnal context-
aware representations of all the tokens. Similar to di-
rectional self-attention (DiSA) (Shen et al., 2017), Bi-
BloSA uses forward/backward masks to encode the
temporal order information, and feature-level atten-
tion to handle the variation of contexts around the
same word. Further, a RNN/CNN-free sequence encoding model we build based on Bi-BloSA,
called “bi-directional block self-attention network (Bi-BloSAN)”, uses an attention mechanism to
compress the output of Bi-BloSA into a vector representation.

Figure 1: A comparison of Bi-BloSAN and
other RNN/CNN/SAN in terms of train-
ing time, training memory consumption
and test accuracy on SNLI (Bowman et al.,
2015). The details of all the models are pro-
vided in Section 4.

In experiments1, we implement Bi-BloSAN and popular sequence encoding models on several NLP
tasks, e.g., language inference, sentiment analysis, semantic relatedness, reading comprehension,
question-type classiﬁcation, etc. The baseline models include Bi-LSTM, Bi-GRU, Bi-SRU, CNNs,
multi-head attention and DiSAN. A thorough comparison on nine benchmark datasets demonstrates
the advantages of Bi-BloSAN in terms of training speed, inference accuracy and memory consump-
tion. Figure 1 shows that Bi-BloSAN obtains the best accuracy by costing similar training time

1Source code and scripts for experiments are at https://github.com/taoshen58/BiBloSA

2

Published as a conference paper at ICLR 2018

to DiSAN, and as little memory as Bi-LSTM, Bi-GRU and multi-head attention. This shows that
Bi-BloSAN achieves a better efﬁciency-memory trade-off than existing RNN/CNN/SAN models.

Our notations follow these conventions: 1) lowercase denotes a vector; 2) bold lowercase denotes a
sequence of vectors (stored as a matrix); and 3) uppercase denotes a matrix or a tensor.

2 BACKGROUND

2.1 WORD EMBEDDING

Word embedding is the basic processing unit in most DNN for sequence modeling.
It transfers
each discrete token into a representation vector of real values. Given a sequence of tokens (e.g.,
words or characters) w = [w1, w2, . . . , wn] ∈ RN ×n, where wi is a one-hot vector, N is the
vocabulary size and n is the sequence length. A pre-trained token embedding (e.g. word2vec
(Mikolov et al., 2013b)) is applied to w, which outputs a sequence of low dimensional vectors
x = [x1, x2, . . . , xn] ∈ Rde×n. This process can be formally written as x = W (e)w, where
W (e) ∈ Rde×N is the embedding weight matrix that can be ﬁne-tuned during the training phase.

2.2 VANILLA ATTENTION AND MULTI-DIMENSIONAL ATTENTION

Vanilla Attention: Given an input sequence x = [x1, x2, . . . , xn] composed of token embeddings
and a vector representation of a query q ∈ Rdq , vanilla attention (Bahdanau et al., 2015) computes
the alignment score between q and each token xi (reﬂecting the attention of q to xi) using a com-
patibility function f (xi, q). A softmax function then transforms the alignment scores a ∈ Rn to a
probability distribution p(z|x, q), where z is an indicator of which token is important to q. A large
p(z = i|x, q) means that xi contributes important information to q. This process can be written as

The output s is the expectation of sampling a token according to its importance, i.e.,

a = [f (xi, q)]n
p(z|x, q) = softmax(a).

i=1 ,

s =

p(z = i|x, q)xi = Ei∼p(z|x,q)(xi).

n
(cid:88)

i=1

Multiplicative attention (or dot-product attention) (Vaswani et al., 2017; Sukhbaatar et al., 2015;
Rush et al., 2015) and additive attention (or multi-layer perceptron attention) (Bahdanau et al., 2015;
Shang et al., 2015) are two commonly used attention mechanisms. They differ in the choice of
compatibility function f (xi, q). Multiplicative attention uses the cosine similarity for f (xi, q), i.e.,

f (xi, q) =

(cid:68)
W (1)xi, W (2)q

(cid:69)

,

where W (1) ∈ Rdh×de , W (2) ∈ Rdh×dq are the learnable parameters. Additive attention is deﬁned as

f (xi, q) = wT σ(W (1)xi + W (2)q + b(1)) + b,
(5)
where w ∈ Rdh , b(1) and b are the biases, and σ(·) is an activation function. Additive attention
usually achieves better empirical performance than multiplicative attention, but is expensive in time
cost and memory consumption.

Multi-dimensional Attention: Unlike vanilla attention, in multi-dimensional (multi-dim) attention
(Shen et al., 2017), the alignment score is computed for each feature, i.e., the score of a token pair
is a vector rather than a scalar, so the score might be large for some features but small for others.
Therefore, it is more expressive than vanilla attention, especially for the words whose meaning varies
in different contexts.

Multi-dim attention has de indicators z1, . . . , zde for de features. Each indicator has a probability
distribution that is generated by applying softmax to the n alignment scores of the corresponding
feature. Hence, for each feature k in each token i, we have Pki (cid:44) p(zk = i|x, q) where P ∈ Rde×n.

(1)
(2)

(3)

(4)

3

Published as a conference paper at ICLR 2018

A large Pki means that the feature k in token i is important to q. The output of multi-dim attention
is written as

(cid:104)(cid:88)n

s =

Pkixki

i=1

(cid:105)de

k=1

= (cid:2)Ei∼p(zk|x,q)(xki)(cid:3)de

k=1 .

(6)

For simplicity, we ignore the subscript k where no confusion is caused. Then, Eq.(6) can be rewritten
as an element-wise product, i.e., s = (cid:80)n
i=1 P·i (cid:12) xi. Here, P·i is computed by the additive attention
in Eq.(5) where wT is replaced with a weight matrix W ∈ Rdh×de , which leads to a score vector for
each token pair.

2.3 TWO TYPES OF SELF-ATTENTION

token2token self-attention (Hu et al., 2017; Vaswani et al., 2017; Shen et al., 2017) produces
context-aware representations by exploring the dependency between two tokens xi and xj from
the same sequence x. In particular, q in Eq.(5) is replaced with xj, i.e.,

f (xi, xj) = W T σ(W (1)xi + W (2)xj + b(1)) + b.
Similar to the P in multi-dim attention, each input token xj is associated with a probability matrix
(cid:44) p(zk = i|x, xj). The output representation for xj is sj = (cid:80)n
P j such that P j
·i (cid:12) xi and
ki
the ﬁnal output of token2token self-attention is s = [s1, s2, . . . , sn].

i=1 P j

(7)

source2token self-attention (Lin et al., 2017; Shen et al., 2017; Liu et al., 2016) explores the im-
portance of each token to the entire sentence given a speciﬁc task. In particular, q is removed from
Eq.(5), and the following equation is used as the compatibility function.

f (xi) = W T σ(W (1)xi + b(1)) + b.
(8)
The probability matrix P is deﬁned as Pki (cid:44) p(zk = i|x). The ﬁnal output of source2token self-
attention has the same form as multi-dim attention, i.e., s = (cid:80)n

i=1 P·i (cid:12) xi

2.4 MASKED SELF-ATTENTION

Temporal order information is difﬁcult to en-
code in token2token self-attention introduced
above because the alignment score between two
tokens is symmetric. Masked self-attention
(Shen et al., 2017) applies a mask M ∈ Rn×n
to the alignment score matrix (or tensor due to
feature-level score) computed by Eq.(7), so it
allows one-way attention from one token to an-
other. Speciﬁcally, the bias b in Eq.(7) is re-
placed with a constant vector Mij1, where the
1 is an all-one vector. In addition, W is ﬁxed to
a scalar c and tanh(·/c) is used as the activation
function σ(·), i.e.,

Figure 2: Masked self-attention mechanism. fij de-
notes f (xi, xj) in Eq.(9).

f (xi, xj) = c · tanh

(cid:16)

(cid:17)
[W (1)xi + W (2)xj + b(1)]/c

+ Mij1,

(9)

where W (1) ∈ Rde×de , W (2) ∈ Rde×dq . The procedures to calculate the attention output from
f (xi, xj) are identical to those in token2token self-attention. We use s = gm(x, M ) to denote the
complete process of masked self-attention with s = [s1, s2, . . . , sn] as the output sequence. An
illustration of masked self-attention is given in Figure 2.
In order to model bi-directional order information, forward mask M f w and backward mask M bw are
respectively substituted into Eq.(9), which results in forward and backward self-attentions. These
two masks are deﬁned as

M f w

ij =

(cid:26) 0,

i < j

−∞, otherwise

M bw

ij =

(cid:26) 0,

i > j

−∞, otherwise

(10)

The outputs of forward and backward self-attentions are denoted by sf w = gm(x, M f w) and
sbw = gm(x, M bw), respectively.

4

Published as a conference paper at ICLR 2018

3 PROPOSED MODEL

In this section, we ﬁrst introduce the “masked block self-attention (mBloSA)” (Section 3.1) as a
fundamental self-attention module. Then, we present the “bi-directional block self-attention net-
work (Bi-BloSAN)” (Section 3.2) for sequence encoding, which uses the “bi-directional block self-
attention (Bi-BloSA)” (mBloSA with forward and backward masks) as its context fusion module.

3.1 MASKED BLOCK SELF-ATTENTION

As shown in Figure 3, masked block self-attention (mBloSA) has three parts from its bottom to top,
i.e., 1) intra-block self-attention, 2) inter-block self-attention, and 3) the context fusion.

Figure 3: Masked block self-attention (mBloSA) mechanism.

Intra-block self-attention: We ﬁrstly split the input sequence of token/word embeddings into m
blocks of equal length r, i.e., [xl]m
l=1 = [x1, x2, . . . , xm] where x1 = [x1, x2, . . . , xr], x2 =
[xr+1, xr+2, . . . , x2r] and xm = [xn−r+1, xn−r+2, . . . , xn]. Padding can be applied to the last block
Intra-block self-attention applies the masked self-attentions gm(·, M ) with shared
if necessary.
parameters to all the blocks , i.e.,

hl = gm(xl, M ), l = 1, 2, . . . , m.

(11)

Its goal is to capture the local context dependency inside each block. Similar to xl, the output rep-
resentations of the tokens in the l-th block are denoted by hl = [hr(l−1)+1, hr(l−1)+2, . . . , hr×l]. Note,
the block length r is a hyper-parameter and m = n/r. In Appendix A, we introduce an approach to
selecting the optimal r, which results in the maximum memory utility rate in expectation.
Inter-block self-attention: To generate a vector representation vl of each block, a source2token
self-attention gs2t(·) is applied to the output hl of the intra-block self-attention on each block, i.e.,

vl = gs2t(hl), l = 1, 2, . . . , m.

(12)

Note we apply the parameter-shared gs2t(·) to hl for different blocks. This provides us with a
sequence v = [v1, v2, . . . , vm] of local-context representations at block level.
Inter-block self-

5

Published as a conference paper at ICLR 2018

attention then applies a masked self-attention to v in order to capture the long-range/global depen-
dency among the blocks, i.e.,

o = gm(v, M ).

To combine the local and global context features at block level, a gate is used to merge the input
and the output of the masked self-attention dynamically. This is similar to the gates in LSTM. The
output sequence e = [e1, . . . , em] of the gate is computed by

G = sigmoid

(cid:16)

W (g1)o + W (g2)v + b(g)(cid:17)

,

e = G (cid:12) o + (1 − G) (cid:12) v

Context fusion: Given the long-range context representations e = [e1, . . . , em] ∈ Rde×m at block
level, we duplicate el for r times to get el = [el, el, . . . , el] (each token in block l has the global
context feature representation el). Let E (cid:44) [el]m
l=1 ∈ Rde×n. Now, we have the input sequence
x of word embeddings, the local context features h produced by intra-block self-attention, and
the long-range/global context features E produced by inter-block self-attention. A feature fusion
gate (Gong & Bowman, 2017) is employed to combine them, and generates the ﬁnal context-aware
representations of all tokens, i.e.,

F = σ

(cid:16)

W (f 1)[x; h; E] + b(f 1)(cid:17)

,

G = sigmoid

(cid:16)

W (f 2)[x; h; E] + b(f 2)(cid:17)

,

(13)

(14)

(15)

(16)

(17)

(18)
where σ(·) is an activation function, and u = [u1, u2, . . . , un] ∈ Rde×n is the mBloSA output,
which consists of the context-aware representations of the n tokens.

u = G (cid:12) F + (1 − G) (cid:12) x,

3.2 BI-DIRECTIONAL BLOCK SELF-ATTENTION NETWORK FOR SEQUENCE ENCODING

We propose a sequence encoding model
“Bi-directional block self-attention net-
work (Bi-BloSAN)” with mBloSA as its
major components.
Its architecture is
shown in Figure 4.
In Bi-BloSAN, two
fully connected layers (with untied param-
eters) are applied to the input sequence of
token embeddings. Their outputs are pro-
cessed by two mBloSA modules respec-
tively. One uses the forward mask M f w
and another uses the backward mask M bw.
Their outputs uf w and ubw are concate-
nated as ubi = [uf w; ubw] ∈ R2de×n.
The idea of bi-directional attention follows
the same spirit as Bi-LSTM and DiSAN. It
encodes temporal order information lacking in existing SAN models. The context fusion module in
Bi-BloSAN, with the input x and the output ubi, is called “Bi-BloSA”. In order to obtain a se-
quence encoding, a source2token self-attention transforms the sequence ubi of concatenated token
representations into a vector representation s.

Figure 4: Bi-directional block self-attention network (Bi-
BloSAN) for sequence encoding.

4 EXPERIMENTS

We conduct the experiments of Bi-BloSAN and several popular RNN/CNN/SAN-based sequence
encoding models on nine benchmark datasets for multiple different NLP tasks. Note that, in some
baseline models, a source2token self-attention is on the top of the models to generate an encoding
for the entire sequence. All the models used for comparisons are listed as follows.

• Bi-LSTM: 600D Bi-directional LSTM (300D forward LSTM + 300D backward LSTM)

(Graves et al., 2013).

6

Published as a conference paper at ICLR 2018

• Bi-GRU: 600D Bi-directional GRU (Chung et al., 2014).
• Bi-SRU: 600D Bi-directional SRU (Lei & Zhang, 2017) (with sped-up recurrence but no

CUDA level optimization for fair comparison).

• Multi-CNN: 600D CNN sentence embedding model (Kim, 2014) (200D for each of 3, 4,

5-gram).

• Hrchy-CNN: 3-layer 300D CNN (Gehring et al., 2017) with kernel length 5, to which gated
linear units (Dauphin et al., 2016) and residual connection (He et al., 2016) are applied.
• Multi-head: 600D Multi-head attention (Vaswani et al., 2017) (8 heads, each has 75 hidden
units). The positional encoding method used in Vaswani et al. (2017) is applied to the input
sequence to encode temporal order information.

• DiSAN: 600D Directional self-attention network (Shen et al., 2017) (300D forward masked

self-attention + 300D backward masked self-attention).

All experimental codes are implemented in Python with Tensorﬂow and run on a single Nvidia GTX
1080Ti graphic card. Both time cost and memory load data are collected under Tensorﬂow1.3 with
CUDA8 and cuDNN6021. In the rest of this section, we conduct the experiments on natural language
inference in Section 4.1, reading comprehension in Section 4.2, semantic relatedness in Section 4.3
and sentence classiﬁcations in Section 4.4. Finally, we analyze the time cost and memory load of
the different models vs. the sequence length in Section 4.5.

4.1 NATURAL LANGUAGE INFERENCE

Natural language inference (NLI) aims to reason the semantic relationship between a pair of sen-
tences, i.e., a premise sentence and a hypothesis sentence. This relationship could be entailment,
neutral or contradiction. In the experiment, we compare Bi-BloSAN to other baselines on the Stan-
ford Natural Language Inference (Bowman et al., 2015) (SNLI)2 dataset, which contains standard
training/dev/test split of 549,367/9,842/9,824 samples.

Table 1: Experimental results for different methods on SNLI. |θ|: the number of parameters (excluding word
embedding part). Train Accu and Test Accu: the accuracies on training and test sets respectively.

Model

|θ|

Train Accu Test Accu

Unlexicalized features (Bowman et al., 2015)
+ Unigram and bigram features (Bowman et al., 2015)

100D LSTM encoders (Bowman et al., 2015)
300D LSTM encoders (Bowman et al., 2016)
1024D GRU encoders (Vendrov et al., 2016)
300D Tree-based CNN encoders (Mou et al., 2016)
300D SPINN-PI encoders (Bowman et al., 2016)
600D Bi-LSTM encoders (Liu et al., 2016)
300D NTI-SLSTM-LSTM encoders (Munkhdalai & Yu, 2017b)
600D Bi-LSTM encoders+intra-attention (Liu et al., 2016)
300D NSE encoders (Munkhdalai & Yu, 2017a)
600D (300+300) Deep Gated Attn. (Chen et al., 2017)

Bi-LSTM (Graves et al., 2013)
Bi-GRU (Chung et al., 2014)
Bi-SRU (Lei & Zhang, 2017)
Multi-CNN (Kim, 2014)
Hrchy-CNN (Gehring et al., 2017)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

480D Bi-BloSAN

49.4
99.7

84.8
83.9
98.8
83.3
89.2
86.4
82.5
84.5
86.2
90.5

90.4
91.9
88.4
89.3
91.3
89.6
91.1

91.7

0.2m
3.0m
15.0m
3.5m
3.7m
2.0m
4.0m
2.8m
3.0m
11.6m

2.9m
2.5m
2.0m
1.4m
3.4m
2.0m
2.3m

2.8m

50.4
78.2

77.6
80.6
81.4
82.1
83.2
83.3
83.4
84.2
84.6
85.5

85.0
84.9
84.8
83.2
83.9
84.2
85.6

85.7

Following the method of applying sentence-encoding to NLI task given in Bowman et al. (2016),
two parameter-tied sentence-encoding models are applied to the premise and the hypothesis sen-
tences respectively, to generate the premise encoding sp and the hypothesis encoding sh. A relation

2https://nlp.stanford.edu/projects/snli/

7

Published as a conference paper at ICLR 2018

representation concatenating sp, sh, sp − sh and sp (cid:12) sh is passed into a 300D fully connected layer,
whose output is given to a 3-unit output layer with softmax to calculate the probability distribution
over the three classes.

Training Setup: The optimization objective is the cross-entropy loss plus L2 regularization penalty.
We minimize the objective by Adadelta (Zeiler, 2012) optimizer which is empirically more stable
than Adam (Kingma & Ba, 2015) on SNLI. The batch size is set to 64 for all methods. The train-
ing phase takes 50 epochs to converge. All weight matrices are initialized by Glorot Initialization
(Glorot & Bengio, 2010), and the biases are initialized with 0. We use 300D GloVe 6B pre-trained
vectors (Pennington et al., 2014) to initialize the word embeddings in x. The Out-of-Vocabulary
words in the training set are randomly initialized by uniform distribution between (−0.05, 0.05).
The word embeddings are ﬁne-tuned during the training. The Dropout (Srivastava et al., 2014) keep
probability and the L2 regularization weight decay factor γ are set to 0.75 and 5×10−5, respectively.
The number of hidden units is 300. The unspeciﬁed activation functions in all models are set to Relu
(Glorot et al., 2011).

In Table 1, we report the number of parameters, and training/test accuracies of all baselines plus
the methods from the ofﬁcial leaderboard. For fair comparison, we use 480D Bi-BloSAN, which
leads to the similar parameter number with that of baseline encoders. Bi-BloSAN achieves the best
test accuracy (similar to DiSAN) among all the sentence encoding models on SNLI. In particular,
compared to the RNN models, Bi-BloSAN outperforms Bi-LSTM encoder, Bi-LSTM with atten-
tion and deep gated attention by 2.4%, 1.5% and 0.2%, respectively. Bi-BloSAN can even perform
better than the semantic tree based models: SPINN-PI encoder (+2.5%)&Tree-based CNN encoder
(+3.6%), and the memory network based model: NSE encoder (+1.1%). Additionally, Bi-BloSAN
achieves the best performance among the baselines which are based on RNN/CNN/SAN. It outper-
forms Bi-LSTM (+0.7%), Bi-GRU (+0.8%), Bi-SRU (+0.9%), multi-CNN (+2.5%), Hrchy-CNN
(+1.8%) and multi-head attention (+1.5%).

Table 2: Time cost and memory consumption of the different methods on SNLI. Time(s)/epoch: average
training time (second) per epoch. Memory(MB): Training GPU memory consumption (Megabyte). Inference
Time(s): average inference time (second) for all dev data on SNLI with test batch size of 100.
Model

Inference Time(s) Test Accuracy

Time(s)/epoch Memory(MB)

Bi-LSTM (Graves et al., 2013)
Bi-GRU (Chung et al., 2014)
Bi-SRU (Lei & Zhang, 2017)
Multi-CNN (Kim, 2014)
Hrchy-CNN (Gehring et al., 2017)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

480D Bi-BloSAN

2080
1728
1630
284
343
345
587

508

1245
1259
731
529
2341
1245
2267

1243

9.2
9.3
8.2
2.4
2.9
3.0
7.0

3.4

85.0
84.9
84.8
83.2
83.9
84.2
85.6

85.7

In addition, we compare time cost and memory consumption of all the baselines in Table 2. Com-
pared to DiSAN with the same test accuracy, Bi-BloSAN is much faster and more memory efﬁcient.
In terms of training and inference time, Bi-BloSAN is 3 ∼ 4× faster than the RNN models (Bi-
LSTM, Bi-GRU, etc.). It is as fast as CNNs and multi-head attention but substantially outperforms
them in test accuracy. In terms of training memory, Bi-BloSAN requires similar GPU memory to
the RNN-based models and multi-head attention, which is much less than that needed by DiSAN.

Finally, we conduct an ablation study of Bi-BloSAN in Table 3.
In particular, we evaluate the
contribution of each part of Bi-BloSAN by the change of test accuracy after removing the part.
The removed part could be: 1) local context representations h, 2) global context representations
E, 3) the context fusion module (mBloSA) or 4) all fundamental modules appeared in this paper.
The results show that both the local and global context representations play signiﬁcant roles in Bi-
BloSAN. They make Bi-BloSAN surpass the state-of-the-art models. Moreover, mBloSA improves
the test accuracy from 83.1% to 85.7%. Source2token self-attention performs much better than
vanilla attention, and improves the test accuracy by 3.3%.

8

Published as a conference paper at ICLR 2018

Table 3: An ablation study of Bi-BloSAN. “Local” denotes the local context representations h and “Global”
denotes the global context representations E. “Bi-BloSAN w/o mBloSA” equals to word embeddings directly
followed by a source2token attention and “Bi-BloSAN w/o mBloSA & source2token self-attn.” equals to word
embeddings plus a vanilla attention without q.

Model

|θ|

Test Accuracy

Bi-BloSAN
Bi-BloSAN w/o Local
Bi-BloSAN w/o Global
Bi-BloSAN w/o mBloSA
Bi-BloSAN w/o mBloSA & source2token self-attn.

2.8m
2.5m
1.8m
0.54m
0.45m

85.7
85.2
85.3
83.1
79.8

4.2 READING COMPREHENSION

Given a passage and a corresponding question, the goal of reading comprehension is to ﬁnd the
correct answer from the passage for the question. We use the Stanford Question Answering Dataset
(Rajpurkar et al., 2016) (SQuAD)3 to evaluate all models. SQuAD consists of questions posed by
crowdworkers on a set of Wikipedia articles, where the answer to each question is a segment of text,
or a span, from the corresponding passage.

Since Bi-BloSAN and other baselines are designed for sequence encoding, such as sentence embed-
ding, we change the task from predicting the answer span to locating the sentence containing the
correct answer. We build a network structure to test the power of sequence encoding in different
models to ﬁnd the correct answers. The details are given in Appendix B.

Training Setup: We use Adadelta optimizer to minimize the cross-entropy loss plus L2 regular-
ization penalty, with batch size of 32. The network parameters and word embeddings initialization
methods are same as those for SNLI, except that both the word embedding dimension and the num-
ber of hidden units are set to 100. We use 0.8 dropout keep probability and 10−4 L2 regularization
weight decay factor.

We evaluate the Bi-BloSAN and the baselines except DiSAN because the memory required by
DiSAN largely exceeds the GPU memory of GTX 1080Ti (11GB). The number of parameters, per
epoch training time and the prediction accuracy on development set are given in Table 4.

Table 4: Experimental results for different methods on modiﬁed SQuAD task.
|θ|
Time(s)/Epoch Dev Accuracy
Context Fusion Method

Bi-LSTM (Graves et al., 2013)
Bi-GRU (Chung et al., 2014)
Bi-SRU (Lei & Zhang, 2017)
Multi-CNN (Kim, 2014)
Multi-head (Vaswani et al., 2017)

Bi-BloSAN

0.71m
0.57m
0.32m
0.60m
0.45m

0.82m

857
782
737
114
140

293

68.01
67.98
67.32
63.58
64.82

68.38

Compared to RNN/CNN models, Bi-BloSAN achieves state-of-the-art prediction accuracy in this
modiﬁed task. Bi-BloSAN shows its competitive context fusion and sequence encoding capability
compared to Bi-LSTM, Bi-GRU, Bi-SRU but is much more time-efﬁcient. In addition, Bi-BloSAN
signiﬁcantly outperforms multi-CNN and multi-head attention.

4.3 SEMANTIC RELATEDNESS

The goal of semantic relatedness is to predict the similarity degree of a given pair of sentences. Un-
like the classiﬁcation problems introduced above, predicting the semantic relatedness of sentences
is a regression problem. We use s1 and s2 to denote the encodings of the two sentences, and as-
sume that the similarity degree is between [1, K]. Following the method introduced by Tai et al.
(2015), the concatenation of s1 (cid:12)s2 and |s1 −s2| is used as the representation of sentence related-

3https://rajpurkar.github.io/SQuAD-explorer/

9

Published as a conference paper at ICLR 2018

ness. This representation is fed into a 300D fully connected layer, followed by a K-unit output layer
with softmax to calculate a probability distribution ˆp. The details of this regression problem can
be found in Appendix C. We evaluate all models on Sentences Involving Compositional Knowledge
(SICK)4 dataset, where the similarity degree is denoted by a real number in the range of [1, 5]. SICK
comprises 9,927 sentence pairs with 4,500/500/4,927 instances for training/dev/test sets.

Training Setup: The optimization objective of this regression problem is the KL-divergence plus
the L2 regularization penalty. We minimize the objective using Adadelta with batch size of 64.
The network parameters and word embeddings are initialized as in SNLI experiment. The keep
probability of dropout is set to 0.7, and the L2 regularization weight decay factor is set to 10−4.

Table 5: Experimental results for different methods on SICK sentence relatedness dataset. The reported
accuracies are the mean of ﬁve runs (standard deviations in parentheses).

Model

Pearson’s r

Spearman’s ρ

MSE

Meaning Factory (Bjerva et al., 2014)
ECNU (Zhao et al., 2014)
DT-RNN (Socher et al., 2014)
SDT-RNN (Socher et al., 2014)
Constituency Tree-LSTM (Tai et al., 2015)
Dependency Tree-LSTM (Tai et al., 2015)

Bi-LSTM (Graves et al., 2013)
Multi-CNN (Kim, 2014)
Hrchy-CNN (Gehring et al., 2017)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

0.8268
0.8414
0.7923 (0.0070)
0.7900 (0.0042)
0.8582 (0.0038)
0.8676 (0.0030)

0.8473 (0.0013)
0.8374 (0.0021)
0.8436 (0.0014)
0.8521 (0.0013)
0.8695 (0.0012)

0.7721
/
0.7319 (0.0071)
0.7304 (0.0042)
0.7966 (0.0053)
0.8083 (0.0042)

0.7913 (0.0019)
0.7793 (0.0028)
0.7874 (0.0022)
0.7942 (0.0050)
0.8139 (0.0012)

0.3224
/
0.3822 (0.0137)
0.3848 (0.0042)
0.2734 (0.0108)
0.2532 (0.0052)

0.3276 (0.0087)
0.3395 (0.0086)
0.3162 (0.0058)
0.3258 (0.0149)
0.2879 (0.0036)

Bi-BloSAN

0.8616 (0.0012)

0.8038 (0.0012)

0.3008 (0.0091)

The performances of all models are shown in Table 5, which shows that Bi-BloSAN achieves state-
of-the-art prediction quality. Although Dependency Tree-LSTM and DiSAN obtain the best perfor-
mance, the Tree-LSTM needs external semantic parsing tree as the recursive input and expensive
recursion computation, and DiSAN requires much larger memory for self-attention calculation. By
contrast, Bi-BloSAN, as a RNN/CNN-free model, shows appealing advantage in terms of memory
and time efﬁciency. Note that, performance of Bi-BloSAN is still better than some common models,
including Bi-LSTM, CNNs and multi-head attention.

4.4 SENTENCE CLASSIFICATIONS

The goal of sentence classiﬁcation is to correctly predict the class label of a given sentence in various
scenarios. We evaluate the models on six sentence classiﬁcation benchmarks for various NLP tasks,
such as sentiment analysis and question-type classiﬁcation. They are listed as follows.

• CR5: Customer reviews (Hu & Liu, 2004) of various products (cameras etc.). This task is

to predict whether the review is positive or negative.

• MPQA6: Opinion polarity detection subtask of the MPQA dataset (Wiebe et al., 2005).

• SUBJ7: Subjectivity dataset (Pang & Lee, 2004), which includes a set of sentences. The

corresponding label indicates whether each sentence is subjective or objective.

• TREC8: TREC question-type classiﬁcation dataset (Li & Roth, 2002) which coarsely clas-

siﬁes the question sentences into six types.

4http://clic.cimec.unitn.it/composes/sick.html
5https://www.cs.uic.edu/˜liub/FBS/sentiment-analysis.html
6http://mpqa.cs.pitt.edu
7https://www.cs.cornell.edu/people/pabo/movie-review-data/
8http://cogcomp.org/Data/QA/QC/

10

Published as a conference paper at ICLR 2018

• SST-19: Stanford Sentiment Treebank (Socher et al., 2013), which is a dataset consisting of
movie reviews with ﬁve ﬁne-grained sentiment labels, i.e., very positive, positive, neutral,
negative and very negative.

• SST-2: Stanford Sentiment Treebank (Socher et al., 2013) with binary sentiment labels.
Compared to SST-1, SST-2 removes the neutral instances, and labels the rest with either
negative or positive.

Note that only SST-1 and SST-2 have the standard training/dev/test split, and TREC has the train-
ing/dev split. We implement 10-fold cross validation on SUBJ, CR and MPQA because the original
datasets do not provide any split. We do not use the Movie Reviews (Pang & Lee, 2005) dataset
because the SST-1/2 are extensions of it.

Training Setup: We use the cross-entropy loss plus L2 regularization penalty as the optimization
objective. We minimize it by Adam with training batch size of 32 (except DiSAN, which uses batch
size of 16 due to the limit of GPU memory). The network parameters and word embeddings are
initialized as in SNLI experiment. To avoid overﬁtting on small datasets, we decrease the dropout
keep probability and the L2 regularization weight decay factor γ to 0.6 and 10−4, respectively.

Table 6: Experimental results for different methods on various sentence classiﬁcation benchmarks. The re-
ported accuracies on CR, MPQA and SUBJ are the mean of 10-fold cross validation, the accuracies on TREC
are the mean of dev accuracies of ﬁve runs, and the accuracies on SST-1 and SST-2 are the mean of test accu-
racies of ﬁve runs. All standard deviations are in parentheses.

Model

MPQA

SUBJ

TREC

SST-1

SST-2

cBoW (Mikolov et al., 2013a)
Skip-thought (Kiros et al., 2015)
DCNN (Kalchbrenner et al., 2014)
AdaSent (Zhao et al., 2015)
SRU (Lei & Zhang, 2017)
Wide CNNs (Lei & Zhang, 2017)

CR

79.9
81.3
/

86.4
87.5
/

91.3
93.6
/

87.3
92.2
93.0

83.6 (1.6) 90.4 (0.7) 92.2 (1.2) 91.1 (1.0)
84.8 (1.3) 89.7 (1.1) 93.4 (0.8) 93.9 (0.6) 89.1 (0.3)
82.2 (2.2) 88.8 (1.2) 92.9 (0.7) 93.2 (0.5) 85.3 (0.4)

/
/
86.8
/

/
/
48.5
/
/
/

Bi-LSTM (Graves et al., 2013)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

84.6 (1.6) 90.2 (0.9) 94.7 (0.7) 94.4 (0.3) 87.7 (0.6) 49.9 (0.8)
82.6 (1.9) 89.8 (1.2) 94.0 (0.8) 93.4 (0.4) 83.9 (0.4) 48.2 (0.6)
84.8 (2.0) 90.1 (0.4) 94.2 (0.6) 94.2 (0.1) 87.8 (0.3) 51.0 (0.7)

Bi-BloSAN

84.8 (0.9) 90.4 (0.8) 94.5 (0.5) 94.8 (0.2) 87.4 (0.2) 50.6 (0.5)

The prediction accuracies of different models on the six benchmark datasets are given in Table 6.
Bi-BloSAN achieves the best prediction accuracies on CR, MPQA and TREC, and state-of-the-
art performances on SUBJ, SST-1 and SST-2 datasets (slightly worse than the best performances).
Although Bi-BloSAN performs a little bit worse than the RNN models on SUBJ and SST-1, it
is much more time-efﬁcient than them. Additionally, on the SST-2 dataset, Bi-BloSAN performs
slightly worse than DiSAN in terms of prediction accuracy (−0.4%) but obtains a signiﬁcantly
higher memory utility rate.

We visualize the progress of training models on CR dataset in Figure 5. The convergence speed of
Bi-BloSAN is∼ 6× and∼ 2× faster than Bi-LSTM and DiSAN respectively. Although Bi-BloSAN
is less time-efﬁcient than CNN and multi-head attention, it has much better prediction quality.

4.5 ANALYSES OF TIME COST AND MEMORY CONSUMPTION

To compare the efﬁciency-memory trade-off for each model on sequences of different lengths, we
generate random tensor data, and feed them into the different sequence encoding models. The
models we evaluate include Bi-LSTM, Bi-GRU, Bi-SRU, CNN, multi-head attention, DiSAN and
Bi-BloSAN. The shape of the random data is [batch size, sequence length, features number]. We ﬁx
the batch size to 64 and the features number to 300, then change the sequence length from 16 to 384
with a step size 16.

We ﬁrst discuss the time cost vs. the sequence length. As shown in Figure 6(a), the inference time of
Bi-BloSAN is similar to those of multi-head attention and multi-CNN, but Bi-BloSAN outperforms

9http://nlp.stanford.edu/sentiment/

11

Published as a conference paper at ICLR 2018

Figure 5: Validation accuracy vs. training time (second) of Bi-LSTM, CNN, multi-head attention, DiSAN and
Bi-BloSAN for 800 training steps on CR dataset. (The Bi-LSTM for 800 steps consumes 279s in total.)

(a)

(b)

Figure 6: (a) Inference time cost and (b) GPU memory consumption of the sequence encoding models vs. the
sequence length with the batch size of 64 and the features number of 300.

both by a large margin on prediction quality in previous experiments. Moreover, Bi-BloSAN is
much faster than the RNN models (Bi-LSTM, Bi-GRU, BI-SRU). In addition, although DiSAN
requires less training time than the RNN models in the experiments above, it is much slower during
the inference phase because the large memory allocation consumes a great amount of time. By
contrast, the block structure of Bi-BloSAN signiﬁcantly reduces the inference time.

The GPU memory consumption vs. the sequence length for each model is visualized in Figure 6(b).
DiSAN is not scalable because its memory grows explosively with the sequence length. Bi-BloSAN
is more memory-efﬁcient and scalable than DiSAN as the growth of its memory is nearly linear.
Although Bi-BloSAN consumes more memory than the RNN models, it experimentally has better
time efﬁciency and prediction quality. Since multi-head attention uses multiplicative attention, it
requires less memory than all additive attention based models, such as DiSAN and Bi-BloSAN, but
multiplicative attention based models usually perform worse than additive attention based models.

5 CONCLUSIONS

This paper presents an attention network, called bi-directional block self-attention network (Bi-
BloSAN), for fast, memory-efﬁcient and RNN/CNN-free sequence modeling. To overcome large
memory consumption of existing self-attention networks, Bi-BloSAN splits the sequence into sev-
eral blocks and employs intra-block and inter-block self-attentions to capture both local and long-

12

Published as a conference paper at ICLR 2018

range context dependencies, respectively. To encode temporal order information, Bi-BloSAN ap-
plies forward and backward masks to the alignment scores between tokens for asymmetric self-
attentions.

Our experiments on nine benchmark datasets for various different NLP tasks show that Bi-BloSAN
can achieve the best or state-of-the-art performance with better efﬁciency-memory trade-off than ex-
isting RNN/CNN/SAN models. Bi-BloSAN is much more time-efﬁcient than the RNN models (e.g.,
Bi-LSTM, Bi-GRU, etc.), requires much less memory than DiSAN, and signiﬁcantly outperforms
the CNN models and multi-head attention on prediction quality.

6 ACKNOWLEDGMENTS

This research was funded by the Australian Government through the Australian Research Coun-
cil (ARC) under grants 1) LP160100630 partnership with Australia Government Department of
Health and 2) LP150100671 partnership with Australia Research Alliance for Children and Youth
(ARACY) and Global Business College Australia (GBCA). We also acknowledge the support of
NVIDIA Corporation with the donation of GPU used for this research.

REFERENCES

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly learning to

align and translate. In ICLR, 2015.

Johannes Bjerva, Johan Bos, Rob Van der Goot, and Malvina Nissim. The meaning factory: Formal semantics
for recognizing textual entailment and determining semantic similarity. In SemEval@ COLING, pp. 642–
646, 2014.

Samuel R. Bowman, Gabor Angeli, Christopher Potts, and Christopher D. Manning. A large annotated corpus

for learning natural language inference. In EMNLP, 2015.

Samuel R Bowman, Jon Gauthier, Abhinav Rastogi, Raghav Gupta, Christopher D Manning, and Christopher

Potts. A fast uniﬁed model for parsing and sentence understanding. In ACL, 2016.

Qian Chen, Xiaodan Zhu, Zhen-Hua Ling, Si Wei, Hui Jiang, and Diana Inkpen. Recurrent neural network-
based sentence encoder with gated attention for natural language inference. In RepEval@ EMNLP, 2017.

Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, and Yoshua Bengio. Empirical evaluation of gated re-

current neural networks on sequence modeling. In NIPS, 2014.

Yann N Dauphin, Angela Fan, Michael Auli, and David Grangier. Language modeling with gated convolutional

networks. arXiv preprint arXiv:1612.08083, 2016.

Xuanyi Dong, Junshi Huang, Yi Yang, and Shuicheng Yan. More is less: A more complicated network with

less inference complexity. In Computer Vision and Pattern Recognition, 2017.

Jonas Gehring, Michael Auli, David Grangier, Denis Yarats, and Yann N Dauphin. Convolutional sequence to

sequence learning. arXiv preprint arXiv:1705.03122, 2017.

Xavier Glorot and Yoshua Bengio. Understanding the difﬁculty of training deep feedforward neural networks.
In Proceedings of the Thirteenth International Conference on Artiﬁcial Intelligence and Statistics, pp. 249–
256, 2010.

Xavier Glorot, Antoine Bordes, and Yoshua Bengio. Deep sparse rectiﬁer neural networks. In Proceedings of

the Fourteenth International Conference on Artiﬁcial Intelligence and Statistics, pp. 315–323, 2011.

Yichen Gong and Samuel R Bowman. Ruminating reader: Reasoning with gated multi-hop attention. arXiv

preprint arXiv:1704.07415, 2017.

Alex Graves, Navdeep Jaitly, and Abdel-rahman Mohamed. Hybrid speech recognition with deep bidirectional
lstm. In Automatic Speech Recognition and Understanding (ASRU), 2013 IEEE Workshop on, pp. 273–278.
IEEE, 2013.

Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In

Proceedings of the IEEE conference on computer vision and pattern recognition, pp. 770–778, 2016.

13

Published as a conference paper at ICLR 2018

Sepp Hochreiter and J¨urgen Schmidhuber. Long short-term memory. Neural computation, 9(8):1735–1780,

1997.

Minghao Hu, Yuxing Peng, and Xipeng Qiu. Reinforced mnemonic reader for machine comprehension. arXiv

preprint arXiv:1705.02798, 2017.

Minqing Hu and Bing Liu. Mining and summarizing customer reviews.

In Proceedings of the tenth ACM

SIGKDD international conference on Knowledge discovery and data mining, pp. 168–177. ACM, 2004.

Nal Kalchbrenner, Edward Grefenstette, and Phil Blunsom. A convolutional neural network for modelling

sentences. arXiv preprint arXiv:1404.2188, 2014.

Nal Kalchbrenner, Lasse Espeholt, Karen Simonyan, Aaron van den Oord, Alex Graves, and Koray

Kavukcuoglu. Neural machine translation in linear time. arXiv preprint arXiv:1610.10099, 2016.

Yoon Kim. Convolutional neural networks for sentence classiﬁcation. In EMNLP, 2014.

Yoon Kim, Carl Denton, Luong Hoang, and Alexander M Rush. Structured attention networks. In ICLR, 2017.

Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In ICLR, 2015.

Ryan Kiros, Yukun Zhu, Ruslan R Salakhutdinov, Richard Zemel, Raquel Urtasun, Antonio Torralba, and Sanja

Fidler. Skip-thought vectors. In NIPS, 2015.

Filippos Kokkinos and Alexandros Potamianos. Structural attention neural networks for improved sentiment

analysis. arXiv preprint arXiv:1701.01811, 2017.

Tao Lei and Yu Zhang. Training rnns as fast as cnns. arXiv preprint arXiv:1709.02755, 2017.

Tao Lei, Regina Barzilay, and Tommi Jaakkola. Molding cnns for text: non-linear, non-consecutive convolu-

tions. In EMNLP, 2015.

Xin Li and Dan Roth. Learning question classiﬁers. In ACL, 2002.

Zheng Li, Yu Zhang, Ying Wei, Yuxiang Wu, and Qiang Yang. End-to-end adversarial memory network for

cross-domain sentiment classiﬁcation. In IJCAI, pp. 2237–2243, 2017.

Zhouhan Lin, Minwei Feng, Cicero Nogueira dos Santos, Mo Yu, Bing Xiang, Bowen Zhou, and Yoshua

Bengio. A structured self-attentive sentence embedding. In ICLR, 2017.

Yang Liu, Chengjie Sun, Lei Lin, and Xiaolong Wang. Learning natural language inference using bidirectional

lstm model and inner-attention. arXiv preprint arXiv:1605.09090, 2016.

Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey Dean. Efﬁcient estimation of word representations in

vector space. arXiv preprint arXiv:1301.3781, 2013a.

Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jeff Dean. Distributed representations of words

and phrases and their compositionality. In NIPS, 2013b.

Lili Mou, Rui Men, Ge Li, Yan Xu, Lu Zhang, Rui Yan, and Zhi Jin. Natural language inference by tree-based

convolution and heuristic matching. In ACL, 2016.

Tsendsuren Munkhdalai and Hong Yu. Neural semantic encoders. In EACL, 2017a.

Tsendsuren Munkhdalai and Hong Yu. Neural tree indexers for text understanding. In EACL, 2017b.

Bo Pang and Lillian Lee. A sentimental education: Sentiment analysis using subjectivity summarization based

on minimum cuts. In ACL, 2004.

to rating scales. In ACL, 2005.

tion. In EMNLP, 2014.

ACL, 2017.

Bo Pang and Lillian Lee. Seeing stars: Exploiting class relationships for sentiment categorization with respect

Jeffrey Pennington, Richard Socher, and Christopher D. Manning. Glove: Global vectors for word representa-

Qiao Qian, Minlie Huang, and Xiaoyan Zhu. Linguistically regularized lstms for sentiment classiﬁcation. In

Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. Squad: 100,000+ questions for machine

comprehension of text. In EMNLP, 2016.

14

Published as a conference paper at ICLR 2018

Alexander M Rush, Sumit Chopra, and Jason Weston. A neural attention model for abstractive sentence sum-

marization. In EMNLP, 2015.

Lifeng Shang, Zhengdong Lu, and Hang Li. Neural responding machine for short-text conversation. In ACL,

2015.

Tao Shen, Tianyi Zhou, Guodong Long, Jing Jiang, Shirui Pan, and Chengqi Zhang. Disan: Directional self-

attention network for rnn/cnn-free language understanding. arXiv preprint arXiv:1709.04696, 2017.

Richard Socher, Alex Perelygin, Jean Y Wu, Jason Chuang, Christopher D Manning, Andrew Y Ng, Christo-
pher Potts, et al. Recursive deep models for semantic compositionality over a sentiment treebank. In EMNLP,
2013.

Richard Socher, Andrej Karpathy, Quoc V Le, Christopher D Manning, and Andrew Y Ng. Grounded com-
positional semantics for ﬁnding and describing images with sentences. Transactions of the Association for
Computational Linguistics, 2:207–218, 2014.

Nitish Srivastava, Geoffrey E Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. Dropout:
a simple way to prevent neural networks from overﬁtting. Journal of Machine Learning Research, 15(1):
1929–1958, 2014.

Sainbayar Sukhbaatar, Jason Weston, Rob Fergus, et al. End-to-end memory networks. In NIPS, 2015.

Kai Sheng Tai, Richard Socher, and Christopher D Manning. Improved semantic representations from tree-

structured long short-term memory networks. In ACL, 2015.

Zhiyang Teng and Yue Zhang. Bidirectional tree-structured lstm with head lexicalization. In ACL, 2017.

Ashish Vaswani, Shazeer, Noam, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser,

and Illia Polosukhin. Attention is all you need. In NIPS, 2017.

Ivan Vendrov, Ryan Kiros, Sanja Fidler, and Raquel Urtasun. Order-embeddings of images and language. In

ICLR, 2016.

Wenhui Wang, Nan Yang, Furu Wei, Baobao Chang, and Ming Zhou. Gated self-matching networks for reading

comprehension and question answering. In ACL, 2017.

Zhiguo Wang, Haitao Mi, Wael Hamza, and Radu Florian. Multi-perspective context matching for machine

comprehension. arXiv preprint arXiv:1612.04211, 2016.

Janyce Wiebe, Theresa Wilson, and Claire Cardie. Annotating expressions of opinions and emotions in lan-

guage. Language resources and evaluation, 39(2):165–210, 2005.

Zichao Yang, Diyi Yang, Chris Dyer, Xiaodong He, Alexander J Smola, and Eduard H Hovy. Hierarchical

attention networks for document classiﬁcation. In HLT-NAACL, 2016.

Matthew D Zeiler. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701, 2012.

Han Zhao, Zhengdong Lu, and Pascal Poupart. Self-adaptive hierarchical sentence model. In IJCAI, 2015.

Jiang Zhao, Tiantian Zhu, and Man Lan. Ecnu: One stone two birds: Ensemble of heterogenous measures for

semantic relatedness and textual entailment. In SemEval@ COLING, pp. 271–277, 2014.

A THE SELECTION OF BLOCK LENGTH

In mBloSA, the length r of each block is a hyper-parameter that determines memory consumption
of mBloSA. To minimize the memory consumption, we propose an approach that calculates the
optimized block length r as follows.

We ﬁrst introduce the method for determining r for a dataset that has ﬁxed sentence length n. Given
the sentence length n and the block number m = n/r, we have the following facts: 1) the ma-
jor memory consumption in mBloSA is dominated by the masked self-attentions gm(·, M ); 2) the
memory consumption of the masked self-attention is proportional to the square of the sentence
length; and 3) mBloSA contains m masked self-attention with a sequence length of r, and 1 masked

15

Published as a conference paper at ICLR 2018

self-attention with a sequence length of m. Therefore, the memory ξ required by mBloSA can be
calculated by

ξ ∝ r2 · m + m2 · 1
n
r
By setting the gradient of ξ w.r.t. r to zero, we know that the memory consumption ξ is minimum
√
when r = 3

= r2 ·

(19)

n
r

+ (

2n.

)2.

Second, we propose a method for selecting r given a dataset with the sentence lengths that follow a
normal distribution N (µ, σ2). We consider the case where mini-batch SGD with a batch size of B or
its variant is used for training. We need to calculate the upper bound of the expectation of the maxi-
mal sentence length for each mini-batch. Let us ﬁrst consider B random variables [X1, X2, . . . , XB]
in the distribution N (0, σ2). The goal is to ﬁnd the upper bound of the expectation of random vari-
able Z + µ, where Z is deﬁned as

(20)

(21)

(22)

By Jensen’s inequality,

Z = max

Xi, for i = 1, 2, . . . , B.

i

etE[Z] ≤ E[etZ] = E[max

etXi]

i

≤

B
(cid:88)

i=1

E[etXi] = net2 σ2

2

Eq.(21) leads to

Let t =

√

2 ln B
σ

tσ2
2
and we obtain the following upper bound.

ln B
t

E[Z] ≤

+

.

√

(23)
Hence, the upper bound of the expectation of the maximal sentence length among all the B sentences
in each mini-batch is σ

2 ln B + µ. Therefore, the block length r is computed by
√

2 ln B

√

E[Z] ≤ σ

√
r = 3

2n = 3(cid:113)

2(σ

2 ln B + µ).

B NETWORK SETUP FOR MACHINE COMPREHENSION

Each sample in the Stanford Question Answering Dataset (SQuAD) (Rajpurkar et al., 2016) is com-
posed of three parts, i.e., a passage consisting of multiple sentences, a question sentence and a span
in the passage indicating the position of the answer. In order to evaluate the performance of sen-
tence embedding models, we change the task from predicting the span of the answer to ﬁnding the
sentence containing the correct answer.
Given a passage consisting of m sentences [s1, s2, . . . , sm] where sk = [xk1, xk2, . . . , xkn], and
the embedded question token sequence q = [q1, q2, . . . , ql], the goal is to predict which sentence in
the m sentences contains the correct answer to the question q.

The neural net we use to evaluate different sequence encoding models is given in Figure 7. First, we
process each sentence from the passage by a context fusion layer with shared parameters, followed
by a source2token self-attention with shared parameters, which outputs a vector representation of the
sentence. Therefore, the m sentences are represented by m vectors [u1, u2, . . . , um]. The question
sentence q is compressed into a vector representation q using source2token self-attention. Second,
we combine each sentence uk with q by concatenating uk, q, uk −q and uk (cid:12) q, i.e.,

ck = [uk; q; uk −q; uk (cid:12) q], for k = 1, 2, . . . , m.
(24)
Then c = [c1, c2, . . . , cm] is fed into another context fusion layer that explores sentence-level de-
pendencies. Finally, the resultant output representation of each sentence is separately fed into a fully
connected layer to compute a scalar score indicating the possibility of the sentence containing the
answer. A softmax function is applied to the scores of all m sentences, to generate a probability
distribution ˆp ∈ Rm for cross-entropy loss function. The sentence with the largest probability is
predicted as the sentence containing the answer.

16

Published as a conference paper at ICLR 2018

Figure 7: The structure of a neural network for machine comprehension. The candidates of the context fusion
layer include Bi-LSTM, Bi-GRU, Bi-SRU, multi-CNN, multi-head attention and Bi-BloSA. Unlike the original
multi-CNN for sentence embedding, we use padding and remove the max-pooling along the time axis to obtain
an output of the same length as input. DiSA is not considered due to memory limitation.

C LOSS OF REGRESSION PROBLEM

Following the setting introduced by Tai et al. (2015) and given a predicted probability distribution ˆp
as the output of a feedforward network, the regression model predicts the similarity degree as

ˆy = βT ˆp,

where β = [1, 2, . . . , K]. The ground-truth similarity degree y should be mapped to a probability
distribution p = [pi]K
i=1 as the training target, where p needs to fulﬁll y = βT p. The mapping can
be deﬁned as

(cid:40)y − (cid:98)y(cid:99),

pi =

(cid:98)y(cid:99) − y + 1,
0

i = (cid:98)y(cid:99) + 1
i = (cid:98)y(cid:99)
otherwise

,

i = 1, 2, . . . , K.

We use KL-divergence between p and ˆp as our loss function, i.e.,

(25)

(26)

(27)

L =

KL(p(k)||ˆp(k)),

1
M

M
(cid:88)

k=1

where the p(k) and ˆp(k) represent the target and predicted probability distributions of the k-th sample,
respectively.

D RELATED WORKS

Recently, several structured attention mechanisms (Kim et al., 2017; Kokkinos & Potamianos, 2017)
are proposed for capturing structural information from input sequence(s). When applied to self-
attention, structured attentions share a similar idea to self-alignment attention (Hu et al., 2017) and
multi-head attention (Vaswani et al., 2017) with one head, which aims to model the dependencies
between the tokens. Similar to the attention from multiple perspectives in multi-head attention,
multi-perspective context matching (Wang et al., 2016) explores the dependencies between passage
and question from multiple perspectives for reading comprehension, while self-attentive structure
(Lin et al., 2017) embeds sentences from various perspectives to produce matrix representations
In recursive models, self-attention over children nodes (Teng & Zhang, 2017)
of the sentences.
can provide effective input for their parent node that has no standard input (Tai et al., 2015) as
long as it is a non-leaf node in a semantic constituency parsing tree. Li et al. (2017) applies the
multi-hop attention mechanism to transfer learning for cross-domain sentiment analysis without any
RNN/CNN structure.

17

Published as a conference paper at ICLR 2018

Bi-BloSA and hierarchical attention network (Yang et al., 2016) have similar structure, i.e., both
stack two-layer attention mechanisms from bottom to top. However, they are different in three re-
spects: 1) Bi-BloSA aims to learn context-aware representation for each token, while hierarchical
attention is designed for document embedding; 2) the input of Bi-BloSA is a sentence, while the
intput of hierarchical attention is a document composed of multiple sentences; and 3) the hierar-
chical attention performs vanilla attention twice, i.e., token-level attention on each sentence and
sentence-level attention. Bi-BloSA, however, applies masked self-attention twice, i.e., intra-block
self-attention and inter-block self-attention. Additionally, Bi-BloSA uses a feature fusion gate for
each token to combine local and global context, and positional masks to encode temporal order
information.

18

8
1
0
2
 
r
p
A
 
3
 
 
]
L
C
.
s
c
[
 
 
1
v
7
5
8
0
0
.
4
0
8
1
:
v
i
X
r
a

Published as a conference paper at ICLR 2018

BI-DIRECTIONAL BLOCK SELF-ATTENTION FOR FAST
AND MEMORY-EFFICIENT SEQUENCE MODELING

Tao Shen†, Tianyi Zhou‡, Guodong Long†, Jing Jiang†& Chengqi Zhang†
†Centre for Artiﬁcial Intelligence, School of Software, University of Technology Sydney
‡Paul G. Allen School of Computer Science & Engineering, University of Washington
tao.shen@student.uts.edu.au,tianyizh@uw.edu
{guodong.long,jing.jiang,chengqi.zhang}@uts.edu.au

ABSTRACT

Recurrent neural networks (RNN), convolutional neural networks (CNN) and self-
attention networks (SAN) are commonly used to produce context-aware represen-
tations. RNN can capture long-range dependency but is hard to parallelize and
not time-efﬁcient. CNN focuses on local dependency but does not perform well
on some tasks. SAN can model both such dependencies via highly parallelizable
computation, but memory requirement grows rapidly in line with sequence length.
In this paper, we propose a model, called “bi-directional block self-attention net-
work (Bi-BloSAN)”, for RNN/CNN-free sequence encoding. It requires as little
memory as RNN but with all the merits of SAN. Bi-BloSAN splits the entire se-
quence into blocks, and applies an intra-block SAN to each block for modeling
local context, then applies an inter-block SAN to the outputs for all blocks to
capture long-range dependency. Thus, each SAN only needs to process a short
sequence, and only a small amount of memory is required. Additionally, we use
feature-level attention to handle the variation of contexts around the same word,
and use forward/backward masks to encode temporal order information. On nine
benchmark datasets for different NLP tasks, Bi-BloSAN achieves or improves
upon state-of-the-art accuracy, and shows better efﬁciency-memory trade-off than
existing RNN/CNN/SAN.

1

INTRODUCTION

Context dependency provides critical information for most natural language processing (NLP) tasks.
In deep neural networks (DNN), context dependency is usually modeled by a context fusion module,
whose goal is to learn a context-aware representation for each token from the input sequence. Re-
current neural networks (RNN), convolutional neural networks (CNN) and self-attention networks
(SAN) are commonly used as context fusion modules. However, each has its own merits and defects,
so which network to use is an open problem and mainly depends on the speciﬁc task.

RNN is broadly used given its capability in capturing long-range dependency through recurrent
computation. It has been applied to various NLP tasks, e.g., question answering (Wang et al., 2017),
neural machine translation (Bahdanau et al., 2015), sentiment analysis (Qian et al., 2017), natural
language inference (Liu et al., 2016), etc. However, training the basic RNN encounters the gradient
dispersion problem, and is difﬁcult to parallelize. Long short-term memory (LSTM) (Hochreiter &
Schmidhuber, 1997) effectively avoids the vanishing gradient. Gated recurrent unit (GRU) (Chung
et al., 2014) and simple recurrent unit (SRU) (Lei & Zhang, 2017) improve the efﬁciency by reducing
parameters and removing partial temporal-dependency, respectively. However, they still suffer from
expensive time cost, especially when applied to long sequences.

CNN becomes popular recently on some NLP tasks because of its the highly parallelizable convo-
lution computation (Dong et al., 2017). Unlike RNN, CNN can simultaneously apply convolutions
deﬁned by different kernels to multiple chunks of a sequence (Kim, 2014). It is mainly used for
sentence-encoding tasks (Lei et al., 2015; Kalchbrenner et al., 2014). Recently, hierarchical CNNs,
e.g. ByteNet (Kalchbrenner et al., 2016), and ConvS2S (Gehring et al., 2017), are proposed to cap-
ture relatively long-range dependencies by using stacking CNNs to increase the number of input

1

Published as a conference paper at ICLR 2018

elements represented in a state. Nonetheless, as mentioned by Vaswani et al. (2017), the number of
CNNs required to relate signals from two arbitrary input grows in the distance between positions,
linearly for ConvS2S and logarithmically for ByteNet. This makes it difﬁcult to learn dependencies
between distant positions.

Recently, self-attention networks (SAN) have been successfully applied to several NLP tasks. It
produces context-aware representation by applying attention to each pair of tokens from the input
sequence. Compared to RNN/CNN, SAN is ﬂexible in modeling both long-range and local depen-
dencies. The major computation in SAN is the highly parallelizable matrix multiplication without
any temporal iteration, which can be easily accelerated by existing tools. Unlike most works that
attach SAN to RNN/CNN as an additional module, two recent works show that SAN independent
of any RNN/CNN module can achieve state-of-the-art performance on several NLP tasks. The ﬁrst,
multi-head attention (Vaswani et al., 2017), is a major component of a seq2seq model “Transformer”
that outperforms previous methods in neural machine translation. It projects the input sequence into
multiple subspaces, applies a SAN to the representation in each subspace, and concatenates the out-
puts. The second, directional self-attention network (DiSAN) (Shen et al., 2017), computes align-
ment scores at feature level, rather than at token level, and applies forward/backward masks to the
alignment score matrix to encode temporal order information. DiSAN achieves the best or state-of-
the-art test accuracy on several NLP tasks by using less computational time and fewer parameters.
More related works can be found in Appendix D.

However, one drawback of SAN is its large memory requirement to store the alignment scores of all
the token pairs; the number grows quadratically with the sequence length. By contrast, RNN/CNN
demand far less memory. The goal of this paper is to develop a novel SAN for RNN/CNN-free
sequence encoding, which requires as little memory as RNN but inherits all the advantages of SAN,
i.e., highly parallelizable computation, the capability/ﬂexibility in modeling both long-range/local
dependencies, and state-of-the-art performance on multiple NLP tasks.

We propose an attention mechanism, called “bi-
directional block self-attention (Bi-BloSA)”, for fast
and memory-efﬁcient context fusion. The basic idea
is to split a sequence into several length-equal blocks
(with padding if necessary), and apply an intra-block
SAN to each block independently. The outputs for
all the blocks are then processed by an inter-block
SAN. The intra-block SAN captures the local depen-
dency within each block, while the inter-block SAN
captures the long-range/global dependency. Hence,
every SAN only needs to process a short sequence.
Compared to a single SAN applied to the whole se-
quence, such two-layer stacked SAN saves a signiﬁ-
cant amount of memory. A feature fusion gate com-
bines the outputs of intra-block and inter-block SAN
with the original input, to produce the ﬁnal context-
aware representations of all the tokens. Similar to di-
rectional self-attention (DiSA) (Shen et al., 2017), Bi-
BloSA uses forward/backward masks to encode the
temporal order information, and feature-level atten-
tion to handle the variation of contexts around the
same word. Further, a RNN/CNN-free sequence encoding model we build based on Bi-BloSA,
called “bi-directional block self-attention network (Bi-BloSAN)”, uses an attention mechanism to
compress the output of Bi-BloSA into a vector representation.

Figure 1: A comparison of Bi-BloSAN and
other RNN/CNN/SAN in terms of train-
ing time, training memory consumption
and test accuracy on SNLI (Bowman et al.,
2015). The details of all the models are pro-
vided in Section 4.

In experiments1, we implement Bi-BloSAN and popular sequence encoding models on several NLP
tasks, e.g., language inference, sentiment analysis, semantic relatedness, reading comprehension,
question-type classiﬁcation, etc. The baseline models include Bi-LSTM, Bi-GRU, Bi-SRU, CNNs,
multi-head attention and DiSAN. A thorough comparison on nine benchmark datasets demonstrates
the advantages of Bi-BloSAN in terms of training speed, inference accuracy and memory consump-
tion. Figure 1 shows that Bi-BloSAN obtains the best accuracy by costing similar training time

1Source code and scripts for experiments are at https://github.com/taoshen58/BiBloSA

2

Published as a conference paper at ICLR 2018

to DiSAN, and as little memory as Bi-LSTM, Bi-GRU and multi-head attention. This shows that
Bi-BloSAN achieves a better efﬁciency-memory trade-off than existing RNN/CNN/SAN models.

Our notations follow these conventions: 1) lowercase denotes a vector; 2) bold lowercase denotes a
sequence of vectors (stored as a matrix); and 3) uppercase denotes a matrix or a tensor.

2 BACKGROUND

2.1 WORD EMBEDDING

Word embedding is the basic processing unit in most DNN for sequence modeling.
It transfers
each discrete token into a representation vector of real values. Given a sequence of tokens (e.g.,
words or characters) w = [w1, w2, . . . , wn] ∈ RN ×n, where wi is a one-hot vector, N is the
vocabulary size and n is the sequence length. A pre-trained token embedding (e.g. word2vec
(Mikolov et al., 2013b)) is applied to w, which outputs a sequence of low dimensional vectors
x = [x1, x2, . . . , xn] ∈ Rde×n. This process can be formally written as x = W (e)w, where
W (e) ∈ Rde×N is the embedding weight matrix that can be ﬁne-tuned during the training phase.

2.2 VANILLA ATTENTION AND MULTI-DIMENSIONAL ATTENTION

Vanilla Attention: Given an input sequence x = [x1, x2, . . . , xn] composed of token embeddings
and a vector representation of a query q ∈ Rdq , vanilla attention (Bahdanau et al., 2015) computes
the alignment score between q and each token xi (reﬂecting the attention of q to xi) using a com-
patibility function f (xi, q). A softmax function then transforms the alignment scores a ∈ Rn to a
probability distribution p(z|x, q), where z is an indicator of which token is important to q. A large
p(z = i|x, q) means that xi contributes important information to q. This process can be written as

The output s is the expectation of sampling a token according to its importance, i.e.,

a = [f (xi, q)]n
p(z|x, q) = softmax(a).

i=1 ,

s =

p(z = i|x, q)xi = Ei∼p(z|x,q)(xi).

n
(cid:88)

i=1

Multiplicative attention (or dot-product attention) (Vaswani et al., 2017; Sukhbaatar et al., 2015;
Rush et al., 2015) and additive attention (or multi-layer perceptron attention) (Bahdanau et al., 2015;
Shang et al., 2015) are two commonly used attention mechanisms. They differ in the choice of
compatibility function f (xi, q). Multiplicative attention uses the cosine similarity for f (xi, q), i.e.,

f (xi, q) =

(cid:68)
W (1)xi, W (2)q

(cid:69)

,

where W (1) ∈ Rdh×de , W (2) ∈ Rdh×dq are the learnable parameters. Additive attention is deﬁned as

f (xi, q) = wT σ(W (1)xi + W (2)q + b(1)) + b,
(5)
where w ∈ Rdh , b(1) and b are the biases, and σ(·) is an activation function. Additive attention
usually achieves better empirical performance than multiplicative attention, but is expensive in time
cost and memory consumption.

Multi-dimensional Attention: Unlike vanilla attention, in multi-dimensional (multi-dim) attention
(Shen et al., 2017), the alignment score is computed for each feature, i.e., the score of a token pair
is a vector rather than a scalar, so the score might be large for some features but small for others.
Therefore, it is more expressive than vanilla attention, especially for the words whose meaning varies
in different contexts.

Multi-dim attention has de indicators z1, . . . , zde for de features. Each indicator has a probability
distribution that is generated by applying softmax to the n alignment scores of the corresponding
feature. Hence, for each feature k in each token i, we have Pki (cid:44) p(zk = i|x, q) where P ∈ Rde×n.

(1)
(2)

(3)

(4)

3

Published as a conference paper at ICLR 2018

A large Pki means that the feature k in token i is important to q. The output of multi-dim attention
is written as

(cid:104)(cid:88)n

s =

Pkixki

i=1

(cid:105)de

k=1

= (cid:2)Ei∼p(zk|x,q)(xki)(cid:3)de

k=1 .

(6)

For simplicity, we ignore the subscript k where no confusion is caused. Then, Eq.(6) can be rewritten
as an element-wise product, i.e., s = (cid:80)n
i=1 P·i (cid:12) xi. Here, P·i is computed by the additive attention
in Eq.(5) where wT is replaced with a weight matrix W ∈ Rdh×de , which leads to a score vector for
each token pair.

2.3 TWO TYPES OF SELF-ATTENTION

token2token self-attention (Hu et al., 2017; Vaswani et al., 2017; Shen et al., 2017) produces
context-aware representations by exploring the dependency between two tokens xi and xj from
the same sequence x. In particular, q in Eq.(5) is replaced with xj, i.e.,

f (xi, xj) = W T σ(W (1)xi + W (2)xj + b(1)) + b.
Similar to the P in multi-dim attention, each input token xj is associated with a probability matrix
(cid:44) p(zk = i|x, xj). The output representation for xj is sj = (cid:80)n
P j such that P j
·i (cid:12) xi and
ki
the ﬁnal output of token2token self-attention is s = [s1, s2, . . . , sn].

i=1 P j

(7)

source2token self-attention (Lin et al., 2017; Shen et al., 2017; Liu et al., 2016) explores the im-
portance of each token to the entire sentence given a speciﬁc task. In particular, q is removed from
Eq.(5), and the following equation is used as the compatibility function.

f (xi) = W T σ(W (1)xi + b(1)) + b.
(8)
The probability matrix P is deﬁned as Pki (cid:44) p(zk = i|x). The ﬁnal output of source2token self-
attention has the same form as multi-dim attention, i.e., s = (cid:80)n

i=1 P·i (cid:12) xi

2.4 MASKED SELF-ATTENTION

Temporal order information is difﬁcult to en-
code in token2token self-attention introduced
above because the alignment score between two
tokens is symmetric. Masked self-attention
(Shen et al., 2017) applies a mask M ∈ Rn×n
to the alignment score matrix (or tensor due to
feature-level score) computed by Eq.(7), so it
allows one-way attention from one token to an-
other. Speciﬁcally, the bias b in Eq.(7) is re-
placed with a constant vector Mij1, where the
1 is an all-one vector. In addition, W is ﬁxed to
a scalar c and tanh(·/c) is used as the activation
function σ(·), i.e.,

Figure 2: Masked self-attention mechanism. fij de-
notes f (xi, xj) in Eq.(9).

f (xi, xj) = c · tanh

(cid:16)

(cid:17)
[W (1)xi + W (2)xj + b(1)]/c

+ Mij1,

(9)

where W (1) ∈ Rde×de , W (2) ∈ Rde×dq . The procedures to calculate the attention output from
f (xi, xj) are identical to those in token2token self-attention. We use s = gm(x, M ) to denote the
complete process of masked self-attention with s = [s1, s2, . . . , sn] as the output sequence. An
illustration of masked self-attention is given in Figure 2.
In order to model bi-directional order information, forward mask M f w and backward mask M bw are
respectively substituted into Eq.(9), which results in forward and backward self-attentions. These
two masks are deﬁned as

M f w

ij =

(cid:26) 0,

i < j

−∞, otherwise

M bw

ij =

(cid:26) 0,

i > j

−∞, otherwise

(10)

The outputs of forward and backward self-attentions are denoted by sf w = gm(x, M f w) and
sbw = gm(x, M bw), respectively.

4

Published as a conference paper at ICLR 2018

3 PROPOSED MODEL

In this section, we ﬁrst introduce the “masked block self-attention (mBloSA)” (Section 3.1) as a
fundamental self-attention module. Then, we present the “bi-directional block self-attention net-
work (Bi-BloSAN)” (Section 3.2) for sequence encoding, which uses the “bi-directional block self-
attention (Bi-BloSA)” (mBloSA with forward and backward masks) as its context fusion module.

3.1 MASKED BLOCK SELF-ATTENTION

As shown in Figure 3, masked block self-attention (mBloSA) has three parts from its bottom to top,
i.e., 1) intra-block self-attention, 2) inter-block self-attention, and 3) the context fusion.

Figure 3: Masked block self-attention (mBloSA) mechanism.

Intra-block self-attention: We ﬁrstly split the input sequence of token/word embeddings into m
blocks of equal length r, i.e., [xl]m
l=1 = [x1, x2, . . . , xm] where x1 = [x1, x2, . . . , xr], x2 =
[xr+1, xr+2, . . . , x2r] and xm = [xn−r+1, xn−r+2, . . . , xn]. Padding can be applied to the last block
Intra-block self-attention applies the masked self-attentions gm(·, M ) with shared
if necessary.
parameters to all the blocks , i.e.,

hl = gm(xl, M ), l = 1, 2, . . . , m.

(11)

Its goal is to capture the local context dependency inside each block. Similar to xl, the output rep-
resentations of the tokens in the l-th block are denoted by hl = [hr(l−1)+1, hr(l−1)+2, . . . , hr×l]. Note,
the block length r is a hyper-parameter and m = n/r. In Appendix A, we introduce an approach to
selecting the optimal r, which results in the maximum memory utility rate in expectation.
Inter-block self-attention: To generate a vector representation vl of each block, a source2token
self-attention gs2t(·) is applied to the output hl of the intra-block self-attention on each block, i.e.,

vl = gs2t(hl), l = 1, 2, . . . , m.

(12)

Note we apply the parameter-shared gs2t(·) to hl for different blocks. This provides us with a
sequence v = [v1, v2, . . . , vm] of local-context representations at block level.
Inter-block self-

5

Published as a conference paper at ICLR 2018

attention then applies a masked self-attention to v in order to capture the long-range/global depen-
dency among the blocks, i.e.,

o = gm(v, M ).

To combine the local and global context features at block level, a gate is used to merge the input
and the output of the masked self-attention dynamically. This is similar to the gates in LSTM. The
output sequence e = [e1, . . . , em] of the gate is computed by

G = sigmoid

(cid:16)

W (g1)o + W (g2)v + b(g)(cid:17)

,

e = G (cid:12) o + (1 − G) (cid:12) v

Context fusion: Given the long-range context representations e = [e1, . . . , em] ∈ Rde×m at block
level, we duplicate el for r times to get el = [el, el, . . . , el] (each token in block l has the global
context feature representation el). Let E (cid:44) [el]m
l=1 ∈ Rde×n. Now, we have the input sequence
x of word embeddings, the local context features h produced by intra-block self-attention, and
the long-range/global context features E produced by inter-block self-attention. A feature fusion
gate (Gong & Bowman, 2017) is employed to combine them, and generates the ﬁnal context-aware
representations of all tokens, i.e.,

F = σ

(cid:16)

W (f 1)[x; h; E] + b(f 1)(cid:17)

,

G = sigmoid

(cid:16)

W (f 2)[x; h; E] + b(f 2)(cid:17)

,

(13)

(14)

(15)

(16)

(17)

(18)
where σ(·) is an activation function, and u = [u1, u2, . . . , un] ∈ Rde×n is the mBloSA output,
which consists of the context-aware representations of the n tokens.

u = G (cid:12) F + (1 − G) (cid:12) x,

3.2 BI-DIRECTIONAL BLOCK SELF-ATTENTION NETWORK FOR SEQUENCE ENCODING

We propose a sequence encoding model
“Bi-directional block self-attention net-
work (Bi-BloSAN)” with mBloSA as its
major components.
Its architecture is
shown in Figure 4.
In Bi-BloSAN, two
fully connected layers (with untied param-
eters) are applied to the input sequence of
token embeddings. Their outputs are pro-
cessed by two mBloSA modules respec-
tively. One uses the forward mask M f w
and another uses the backward mask M bw.
Their outputs uf w and ubw are concate-
nated as ubi = [uf w; ubw] ∈ R2de×n.
The idea of bi-directional attention follows
the same spirit as Bi-LSTM and DiSAN. It
encodes temporal order information lacking in existing SAN models. The context fusion module in
Bi-BloSAN, with the input x and the output ubi, is called “Bi-BloSA”. In order to obtain a se-
quence encoding, a source2token self-attention transforms the sequence ubi of concatenated token
representations into a vector representation s.

Figure 4: Bi-directional block self-attention network (Bi-
BloSAN) for sequence encoding.

4 EXPERIMENTS

We conduct the experiments of Bi-BloSAN and several popular RNN/CNN/SAN-based sequence
encoding models on nine benchmark datasets for multiple different NLP tasks. Note that, in some
baseline models, a source2token self-attention is on the top of the models to generate an encoding
for the entire sequence. All the models used for comparisons are listed as follows.

• Bi-LSTM: 600D Bi-directional LSTM (300D forward LSTM + 300D backward LSTM)

(Graves et al., 2013).

6

Published as a conference paper at ICLR 2018

• Bi-GRU: 600D Bi-directional GRU (Chung et al., 2014).
• Bi-SRU: 600D Bi-directional SRU (Lei & Zhang, 2017) (with sped-up recurrence but no

CUDA level optimization for fair comparison).

• Multi-CNN: 600D CNN sentence embedding model (Kim, 2014) (200D for each of 3, 4,

5-gram).

• Hrchy-CNN: 3-layer 300D CNN (Gehring et al., 2017) with kernel length 5, to which gated
linear units (Dauphin et al., 2016) and residual connection (He et al., 2016) are applied.
• Multi-head: 600D Multi-head attention (Vaswani et al., 2017) (8 heads, each has 75 hidden
units). The positional encoding method used in Vaswani et al. (2017) is applied to the input
sequence to encode temporal order information.

• DiSAN: 600D Directional self-attention network (Shen et al., 2017) (300D forward masked

self-attention + 300D backward masked self-attention).

All experimental codes are implemented in Python with Tensorﬂow and run on a single Nvidia GTX
1080Ti graphic card. Both time cost and memory load data are collected under Tensorﬂow1.3 with
CUDA8 and cuDNN6021. In the rest of this section, we conduct the experiments on natural language
inference in Section 4.1, reading comprehension in Section 4.2, semantic relatedness in Section 4.3
and sentence classiﬁcations in Section 4.4. Finally, we analyze the time cost and memory load of
the different models vs. the sequence length in Section 4.5.

4.1 NATURAL LANGUAGE INFERENCE

Natural language inference (NLI) aims to reason the semantic relationship between a pair of sen-
tences, i.e., a premise sentence and a hypothesis sentence. This relationship could be entailment,
neutral or contradiction. In the experiment, we compare Bi-BloSAN to other baselines on the Stan-
ford Natural Language Inference (Bowman et al., 2015) (SNLI)2 dataset, which contains standard
training/dev/test split of 549,367/9,842/9,824 samples.

Table 1: Experimental results for different methods on SNLI. |θ|: the number of parameters (excluding word
embedding part). Train Accu and Test Accu: the accuracies on training and test sets respectively.

Model

|θ|

Train Accu Test Accu

Unlexicalized features (Bowman et al., 2015)
+ Unigram and bigram features (Bowman et al., 2015)

100D LSTM encoders (Bowman et al., 2015)
300D LSTM encoders (Bowman et al., 2016)
1024D GRU encoders (Vendrov et al., 2016)
300D Tree-based CNN encoders (Mou et al., 2016)
300D SPINN-PI encoders (Bowman et al., 2016)
600D Bi-LSTM encoders (Liu et al., 2016)
300D NTI-SLSTM-LSTM encoders (Munkhdalai & Yu, 2017b)
600D Bi-LSTM encoders+intra-attention (Liu et al., 2016)
300D NSE encoders (Munkhdalai & Yu, 2017a)
600D (300+300) Deep Gated Attn. (Chen et al., 2017)

Bi-LSTM (Graves et al., 2013)
Bi-GRU (Chung et al., 2014)
Bi-SRU (Lei & Zhang, 2017)
Multi-CNN (Kim, 2014)
Hrchy-CNN (Gehring et al., 2017)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

480D Bi-BloSAN

49.4
99.7

84.8
83.9
98.8
83.3
89.2
86.4
82.5
84.5
86.2
90.5

90.4
91.9
88.4
89.3
91.3
89.6
91.1

91.7

0.2m
3.0m
15.0m
3.5m
3.7m
2.0m
4.0m
2.8m
3.0m
11.6m

2.9m
2.5m
2.0m
1.4m
3.4m
2.0m
2.3m

2.8m

50.4
78.2

77.6
80.6
81.4
82.1
83.2
83.3
83.4
84.2
84.6
85.5

85.0
84.9
84.8
83.2
83.9
84.2
85.6

85.7

Following the method of applying sentence-encoding to NLI task given in Bowman et al. (2016),
two parameter-tied sentence-encoding models are applied to the premise and the hypothesis sen-
tences respectively, to generate the premise encoding sp and the hypothesis encoding sh. A relation

2https://nlp.stanford.edu/projects/snli/

7

Published as a conference paper at ICLR 2018

representation concatenating sp, sh, sp − sh and sp (cid:12) sh is passed into a 300D fully connected layer,
whose output is given to a 3-unit output layer with softmax to calculate the probability distribution
over the three classes.

Training Setup: The optimization objective is the cross-entropy loss plus L2 regularization penalty.
We minimize the objective by Adadelta (Zeiler, 2012) optimizer which is empirically more stable
than Adam (Kingma & Ba, 2015) on SNLI. The batch size is set to 64 for all methods. The train-
ing phase takes 50 epochs to converge. All weight matrices are initialized by Glorot Initialization
(Glorot & Bengio, 2010), and the biases are initialized with 0. We use 300D GloVe 6B pre-trained
vectors (Pennington et al., 2014) to initialize the word embeddings in x. The Out-of-Vocabulary
words in the training set are randomly initialized by uniform distribution between (−0.05, 0.05).
The word embeddings are ﬁne-tuned during the training. The Dropout (Srivastava et al., 2014) keep
probability and the L2 regularization weight decay factor γ are set to 0.75 and 5×10−5, respectively.
The number of hidden units is 300. The unspeciﬁed activation functions in all models are set to Relu
(Glorot et al., 2011).

In Table 1, we report the number of parameters, and training/test accuracies of all baselines plus
the methods from the ofﬁcial leaderboard. For fair comparison, we use 480D Bi-BloSAN, which
leads to the similar parameter number with that of baseline encoders. Bi-BloSAN achieves the best
test accuracy (similar to DiSAN) among all the sentence encoding models on SNLI. In particular,
compared to the RNN models, Bi-BloSAN outperforms Bi-LSTM encoder, Bi-LSTM with atten-
tion and deep gated attention by 2.4%, 1.5% and 0.2%, respectively. Bi-BloSAN can even perform
better than the semantic tree based models: SPINN-PI encoder (+2.5%)&Tree-based CNN encoder
(+3.6%), and the memory network based model: NSE encoder (+1.1%). Additionally, Bi-BloSAN
achieves the best performance among the baselines which are based on RNN/CNN/SAN. It outper-
forms Bi-LSTM (+0.7%), Bi-GRU (+0.8%), Bi-SRU (+0.9%), multi-CNN (+2.5%), Hrchy-CNN
(+1.8%) and multi-head attention (+1.5%).

Table 2: Time cost and memory consumption of the different methods on SNLI. Time(s)/epoch: average
training time (second) per epoch. Memory(MB): Training GPU memory consumption (Megabyte). Inference
Time(s): average inference time (second) for all dev data on SNLI with test batch size of 100.
Model

Inference Time(s) Test Accuracy

Time(s)/epoch Memory(MB)

Bi-LSTM (Graves et al., 2013)
Bi-GRU (Chung et al., 2014)
Bi-SRU (Lei & Zhang, 2017)
Multi-CNN (Kim, 2014)
Hrchy-CNN (Gehring et al., 2017)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

480D Bi-BloSAN

2080
1728
1630
284
343
345
587

508

1245
1259
731
529
2341
1245
2267

1243

9.2
9.3
8.2
2.4
2.9
3.0
7.0

3.4

85.0
84.9
84.8
83.2
83.9
84.2
85.6

85.7

In addition, we compare time cost and memory consumption of all the baselines in Table 2. Com-
pared to DiSAN with the same test accuracy, Bi-BloSAN is much faster and more memory efﬁcient.
In terms of training and inference time, Bi-BloSAN is 3 ∼ 4× faster than the RNN models (Bi-
LSTM, Bi-GRU, etc.). It is as fast as CNNs and multi-head attention but substantially outperforms
them in test accuracy. In terms of training memory, Bi-BloSAN requires similar GPU memory to
the RNN-based models and multi-head attention, which is much less than that needed by DiSAN.

Finally, we conduct an ablation study of Bi-BloSAN in Table 3.
In particular, we evaluate the
contribution of each part of Bi-BloSAN by the change of test accuracy after removing the part.
The removed part could be: 1) local context representations h, 2) global context representations
E, 3) the context fusion module (mBloSA) or 4) all fundamental modules appeared in this paper.
The results show that both the local and global context representations play signiﬁcant roles in Bi-
BloSAN. They make Bi-BloSAN surpass the state-of-the-art models. Moreover, mBloSA improves
the test accuracy from 83.1% to 85.7%. Source2token self-attention performs much better than
vanilla attention, and improves the test accuracy by 3.3%.

8

Published as a conference paper at ICLR 2018

Table 3: An ablation study of Bi-BloSAN. “Local” denotes the local context representations h and “Global”
denotes the global context representations E. “Bi-BloSAN w/o mBloSA” equals to word embeddings directly
followed by a source2token attention and “Bi-BloSAN w/o mBloSA & source2token self-attn.” equals to word
embeddings plus a vanilla attention without q.

Model

|θ|

Test Accuracy

Bi-BloSAN
Bi-BloSAN w/o Local
Bi-BloSAN w/o Global
Bi-BloSAN w/o mBloSA
Bi-BloSAN w/o mBloSA & source2token self-attn.

2.8m
2.5m
1.8m
0.54m
0.45m

85.7
85.2
85.3
83.1
79.8

4.2 READING COMPREHENSION

Given a passage and a corresponding question, the goal of reading comprehension is to ﬁnd the
correct answer from the passage for the question. We use the Stanford Question Answering Dataset
(Rajpurkar et al., 2016) (SQuAD)3 to evaluate all models. SQuAD consists of questions posed by
crowdworkers on a set of Wikipedia articles, where the answer to each question is a segment of text,
or a span, from the corresponding passage.

Since Bi-BloSAN and other baselines are designed for sequence encoding, such as sentence embed-
ding, we change the task from predicting the answer span to locating the sentence containing the
correct answer. We build a network structure to test the power of sequence encoding in different
models to ﬁnd the correct answers. The details are given in Appendix B.

Training Setup: We use Adadelta optimizer to minimize the cross-entropy loss plus L2 regular-
ization penalty, with batch size of 32. The network parameters and word embeddings initialization
methods are same as those for SNLI, except that both the word embedding dimension and the num-
ber of hidden units are set to 100. We use 0.8 dropout keep probability and 10−4 L2 regularization
weight decay factor.

We evaluate the Bi-BloSAN and the baselines except DiSAN because the memory required by
DiSAN largely exceeds the GPU memory of GTX 1080Ti (11GB). The number of parameters, per
epoch training time and the prediction accuracy on development set are given in Table 4.

Table 4: Experimental results for different methods on modiﬁed SQuAD task.
|θ|
Time(s)/Epoch Dev Accuracy
Context Fusion Method

Bi-LSTM (Graves et al., 2013)
Bi-GRU (Chung et al., 2014)
Bi-SRU (Lei & Zhang, 2017)
Multi-CNN (Kim, 2014)
Multi-head (Vaswani et al., 2017)

Bi-BloSAN

0.71m
0.57m
0.32m
0.60m
0.45m

0.82m

857
782
737
114
140

293

68.01
67.98
67.32
63.58
64.82

68.38

Compared to RNN/CNN models, Bi-BloSAN achieves state-of-the-art prediction accuracy in this
modiﬁed task. Bi-BloSAN shows its competitive context fusion and sequence encoding capability
compared to Bi-LSTM, Bi-GRU, Bi-SRU but is much more time-efﬁcient. In addition, Bi-BloSAN
signiﬁcantly outperforms multi-CNN and multi-head attention.

4.3 SEMANTIC RELATEDNESS

The goal of semantic relatedness is to predict the similarity degree of a given pair of sentences. Un-
like the classiﬁcation problems introduced above, predicting the semantic relatedness of sentences
is a regression problem. We use s1 and s2 to denote the encodings of the two sentences, and as-
sume that the similarity degree is between [1, K]. Following the method introduced by Tai et al.
(2015), the concatenation of s1 (cid:12)s2 and |s1 −s2| is used as the representation of sentence related-

3https://rajpurkar.github.io/SQuAD-explorer/

9

Published as a conference paper at ICLR 2018

ness. This representation is fed into a 300D fully connected layer, followed by a K-unit output layer
with softmax to calculate a probability distribution ˆp. The details of this regression problem can
be found in Appendix C. We evaluate all models on Sentences Involving Compositional Knowledge
(SICK)4 dataset, where the similarity degree is denoted by a real number in the range of [1, 5]. SICK
comprises 9,927 sentence pairs with 4,500/500/4,927 instances for training/dev/test sets.

Training Setup: The optimization objective of this regression problem is the KL-divergence plus
the L2 regularization penalty. We minimize the objective using Adadelta with batch size of 64.
The network parameters and word embeddings are initialized as in SNLI experiment. The keep
probability of dropout is set to 0.7, and the L2 regularization weight decay factor is set to 10−4.

Table 5: Experimental results for different methods on SICK sentence relatedness dataset. The reported
accuracies are the mean of ﬁve runs (standard deviations in parentheses).

Model

Pearson’s r

Spearman’s ρ

MSE

Meaning Factory (Bjerva et al., 2014)
ECNU (Zhao et al., 2014)
DT-RNN (Socher et al., 2014)
SDT-RNN (Socher et al., 2014)
Constituency Tree-LSTM (Tai et al., 2015)
Dependency Tree-LSTM (Tai et al., 2015)

Bi-LSTM (Graves et al., 2013)
Multi-CNN (Kim, 2014)
Hrchy-CNN (Gehring et al., 2017)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

0.8268
0.8414
0.7923 (0.0070)
0.7900 (0.0042)
0.8582 (0.0038)
0.8676 (0.0030)

0.8473 (0.0013)
0.8374 (0.0021)
0.8436 (0.0014)
0.8521 (0.0013)
0.8695 (0.0012)

0.7721
/
0.7319 (0.0071)
0.7304 (0.0042)
0.7966 (0.0053)
0.8083 (0.0042)

0.7913 (0.0019)
0.7793 (0.0028)
0.7874 (0.0022)
0.7942 (0.0050)
0.8139 (0.0012)

0.3224
/
0.3822 (0.0137)
0.3848 (0.0042)
0.2734 (0.0108)
0.2532 (0.0052)

0.3276 (0.0087)
0.3395 (0.0086)
0.3162 (0.0058)
0.3258 (0.0149)
0.2879 (0.0036)

Bi-BloSAN

0.8616 (0.0012)

0.8038 (0.0012)

0.3008 (0.0091)

The performances of all models are shown in Table 5, which shows that Bi-BloSAN achieves state-
of-the-art prediction quality. Although Dependency Tree-LSTM and DiSAN obtain the best perfor-
mance, the Tree-LSTM needs external semantic parsing tree as the recursive input and expensive
recursion computation, and DiSAN requires much larger memory for self-attention calculation. By
contrast, Bi-BloSAN, as a RNN/CNN-free model, shows appealing advantage in terms of memory
and time efﬁciency. Note that, performance of Bi-BloSAN is still better than some common models,
including Bi-LSTM, CNNs and multi-head attention.

4.4 SENTENCE CLASSIFICATIONS

The goal of sentence classiﬁcation is to correctly predict the class label of a given sentence in various
scenarios. We evaluate the models on six sentence classiﬁcation benchmarks for various NLP tasks,
such as sentiment analysis and question-type classiﬁcation. They are listed as follows.

• CR5: Customer reviews (Hu & Liu, 2004) of various products (cameras etc.). This task is

to predict whether the review is positive or negative.

• MPQA6: Opinion polarity detection subtask of the MPQA dataset (Wiebe et al., 2005).

• SUBJ7: Subjectivity dataset (Pang & Lee, 2004), which includes a set of sentences. The

corresponding label indicates whether each sentence is subjective or objective.

• TREC8: TREC question-type classiﬁcation dataset (Li & Roth, 2002) which coarsely clas-

siﬁes the question sentences into six types.

4http://clic.cimec.unitn.it/composes/sick.html
5https://www.cs.uic.edu/˜liub/FBS/sentiment-analysis.html
6http://mpqa.cs.pitt.edu
7https://www.cs.cornell.edu/people/pabo/movie-review-data/
8http://cogcomp.org/Data/QA/QC/

10

Published as a conference paper at ICLR 2018

• SST-19: Stanford Sentiment Treebank (Socher et al., 2013), which is a dataset consisting of
movie reviews with ﬁve ﬁne-grained sentiment labels, i.e., very positive, positive, neutral,
negative and very negative.

• SST-2: Stanford Sentiment Treebank (Socher et al., 2013) with binary sentiment labels.
Compared to SST-1, SST-2 removes the neutral instances, and labels the rest with either
negative or positive.

Note that only SST-1 and SST-2 have the standard training/dev/test split, and TREC has the train-
ing/dev split. We implement 10-fold cross validation on SUBJ, CR and MPQA because the original
datasets do not provide any split. We do not use the Movie Reviews (Pang & Lee, 2005) dataset
because the SST-1/2 are extensions of it.

Training Setup: We use the cross-entropy loss plus L2 regularization penalty as the optimization
objective. We minimize it by Adam with training batch size of 32 (except DiSAN, which uses batch
size of 16 due to the limit of GPU memory). The network parameters and word embeddings are
initialized as in SNLI experiment. To avoid overﬁtting on small datasets, we decrease the dropout
keep probability and the L2 regularization weight decay factor γ to 0.6 and 10−4, respectively.

Table 6: Experimental results for different methods on various sentence classiﬁcation benchmarks. The re-
ported accuracies on CR, MPQA and SUBJ are the mean of 10-fold cross validation, the accuracies on TREC
are the mean of dev accuracies of ﬁve runs, and the accuracies on SST-1 and SST-2 are the mean of test accu-
racies of ﬁve runs. All standard deviations are in parentheses.

Model

MPQA

SUBJ

TREC

SST-1

SST-2

cBoW (Mikolov et al., 2013a)
Skip-thought (Kiros et al., 2015)
DCNN (Kalchbrenner et al., 2014)
AdaSent (Zhao et al., 2015)
SRU (Lei & Zhang, 2017)
Wide CNNs (Lei & Zhang, 2017)

CR

79.9
81.3
/

86.4
87.5
/

91.3
93.6
/

87.3
92.2
93.0

83.6 (1.6) 90.4 (0.7) 92.2 (1.2) 91.1 (1.0)
84.8 (1.3) 89.7 (1.1) 93.4 (0.8) 93.9 (0.6) 89.1 (0.3)
82.2 (2.2) 88.8 (1.2) 92.9 (0.7) 93.2 (0.5) 85.3 (0.4)

/
/
86.8
/

/
/
48.5
/
/
/

Bi-LSTM (Graves et al., 2013)
Multi-head (Vaswani et al., 2017)
DiSAN (Shen et al., 2017)

84.6 (1.6) 90.2 (0.9) 94.7 (0.7) 94.4 (0.3) 87.7 (0.6) 49.9 (0.8)
82.6 (1.9) 89.8 (1.2) 94.0 (0.8) 93.4 (0.4) 83.9 (0.4) 48.2 (0.6)
84.8 (2.0) 90.1 (0.4) 94.2 (0.6) 94.2 (0.1) 87.8 (0.3) 51.0 (0.7)

Bi-BloSAN

84.8 (0.9) 90.4 (0.8) 94.5 (0.5) 94.8 (0.2) 87.4 (0.2) 50.6 (0.5)

The prediction accuracies of different models on the six benchmark datasets are given in Table 6.
Bi-BloSAN achieves the best prediction accuracies on CR, MPQA and TREC, and state-of-the-
art performances on SUBJ, SST-1 and SST-2 datasets (slightly worse than the best performances).
Although Bi-BloSAN performs a little bit worse than the RNN models on SUBJ and SST-1, it
is much more time-efﬁcient than them. Additionally, on the SST-2 dataset, Bi-BloSAN performs
slightly worse than DiSAN in terms of prediction accuracy (−0.4%) but obtains a signiﬁcantly
higher memory utility rate.

We visualize the progress of training models on CR dataset in Figure 5. The convergence speed of
Bi-BloSAN is∼ 6× and∼ 2× faster than Bi-LSTM and DiSAN respectively. Although Bi-BloSAN
is less time-efﬁcient than CNN and multi-head attention, it has much better prediction quality.

4.5 ANALYSES OF TIME COST AND MEMORY CONSUMPTION

To compare the efﬁciency-memory trade-off for each model on sequences of different lengths, we
generate random tensor data, and feed them into the different sequence encoding models. The
models we evaluate include Bi-LSTM, Bi-GRU, Bi-SRU, CNN, multi-head attention, DiSAN and
Bi-BloSAN. The shape of the random data is [batch size, sequence length, features number]. We ﬁx
the batch size to 64 and the features number to 300, then change the sequence length from 16 to 384
with a step size 16.

We ﬁrst discuss the time cost vs. the sequence length. As shown in Figure 6(a), the inference time of
Bi-BloSAN is similar to those of multi-head attention and multi-CNN, but Bi-BloSAN outperforms

9http://nlp.stanford.edu/sentiment/

11

Published as a conference paper at ICLR 2018

Figure 5: Validation accuracy vs. training time (second) of Bi-LSTM, CNN, multi-head attention, DiSAN and
Bi-BloSAN for 800 training steps on CR dataset. (The Bi-LSTM for 800 steps consumes 279s in total.)

(a)

(b)

Figure 6: (a) Inference time cost and (b) GPU memory consumption of the sequence encoding models vs. the
sequence length with the batch size of 64 and the features number of 300.

both by a large margin on prediction quality in previous experiments. Moreover, Bi-BloSAN is
much faster than the RNN models (Bi-LSTM, Bi-GRU, BI-SRU). In addition, although DiSAN
requires less training time than the RNN models in the experiments above, it is much slower during
the inference phase because the large memory allocation consumes a great amount of time. By
contrast, the block structure of Bi-BloSAN signiﬁcantly reduces the inference time.

The GPU memory consumption vs. the sequence length for each model is visualized in Figure 6(b).
DiSAN is not scalable because its memory grows explosively with the sequence length. Bi-BloSAN
is more memory-efﬁcient and scalable than DiSAN as the growth of its memory is nearly linear.
Although Bi-BloSAN consumes more memory than the RNN models, it experimentally has better
time efﬁciency and prediction quality. Since multi-head attention uses multiplicative attention, it
requires less memory than all additive attention based models, such as DiSAN and Bi-BloSAN, but
multiplicative attention based models usually perform worse than additive attention based models.

5 CONCLUSIONS

This paper presents an attention network, called bi-directional block self-attention network (Bi-
BloSAN), for fast, memory-efﬁcient and RNN/CNN-free sequence modeling. To overcome large
memory consumption of existing self-attention networks, Bi-BloSAN splits the sequence into sev-
eral blocks and employs intra-block and inter-block self-attentions to capture both local and long-

12

Published as a conference paper at ICLR 2018

range context dependencies, respectively. To encode temporal order information, Bi-BloSAN ap-
plies forward and backward masks to the alignment scores between tokens for asymmetric self-
attentions.

Our experiments on nine benchmark datasets for various different NLP tasks show that Bi-BloSAN
can achieve the best or state-of-the-art performance with better efﬁciency-memory trade-off than ex-
isting RNN/CNN/SAN models. Bi-BloSAN is much more time-efﬁcient than the RNN models (e.g.,
Bi-LSTM, Bi-GRU, etc.), requires much less memory than DiSAN, and signiﬁcantly outperforms
the CNN models and multi-head attention on prediction quality.

6 ACKNOWLEDGMENTS

This research was funded by the Australian Government through the Australian Research Coun-
cil (ARC) under grants 1) LP160100630 partnership with Australia Government Department of
Health and 2) LP150100671 partnership with Australia Research Alliance for Children and Youth
(ARACY) and Global Business College Australia (GBCA). We also acknowledge the support of
NVIDIA Corporation with the donation of GPU used for this research.

REFERENCES

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly learning to

align and translate. In ICLR, 2015.

Johannes Bjerva, Johan Bos, Rob Van der Goot, and Malvina Nissim. The meaning factory: Formal semantics
for recognizing textual entailment and determining semantic similarity. In SemEval@ COLING, pp. 642–
646, 2014.

Samuel R. Bowman, Gabor Angeli, Christopher Potts, and Christopher D. Manning. A large annotated corpus

for learning natural language inference. In EMNLP, 2015.

Samuel R Bowman, Jon Gauthier, Abhinav Rastogi, Raghav Gupta, Christopher D Manning, and Christopher

Potts. A fast uniﬁed model for parsing and sentence understanding. In ACL, 2016.

Qian Chen, Xiaodan Zhu, Zhen-Hua Ling, Si Wei, Hui Jiang, and Diana Inkpen. Recurrent neural network-
based sentence encoder with gated attention for natural language inference. In RepEval@ EMNLP, 2017.

Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, and Yoshua Bengio. Empirical evaluation of gated re-

current neural networks on sequence modeling. In NIPS, 2014.

Yann N Dauphin, Angela Fan, Michael Auli, and David Grangier. Language modeling with gated convolutional

networks. arXiv preprint arXiv:1612.08083, 2016.

Xuanyi Dong, Junshi Huang, Yi Yang, and Shuicheng Yan. More is less: A more complicated network with

less inference complexity. In Computer Vision and Pattern Recognition, 2017.

Jonas Gehring, Michael Auli, David Grangier, Denis Yarats, and Yann N Dauphin. Convolutional sequence to

sequence learning. arXiv preprint arXiv:1705.03122, 2017.

Xavier Glorot and Yoshua Bengio. Understanding the difﬁculty of training deep feedforward neural networks.
In Proceedings of the Thirteenth International Conference on Artiﬁcial Intelligence and Statistics, pp. 249–
256, 2010.

Xavier Glorot, Antoine Bordes, and Yoshua Bengio. Deep sparse rectiﬁer neural networks. In Proceedings of

the Fourteenth International Conference on Artiﬁcial Intelligence and Statistics, pp. 315–323, 2011.

Yichen Gong and Samuel R Bowman. Ruminating reader: Reasoning with gated multi-hop attention. arXiv

preprint arXiv:1704.07415, 2017.

Alex Graves, Navdeep Jaitly, and Abdel-rahman Mohamed. Hybrid speech recognition with deep bidirectional
lstm. In Automatic Speech Recognition and Understanding (ASRU), 2013 IEEE Workshop on, pp. 273–278.
IEEE, 2013.

Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In

Proceedings of the IEEE conference on computer vision and pattern recognition, pp. 770–778, 2016.

13

Published as a conference paper at ICLR 2018

Sepp Hochreiter and J¨urgen Schmidhuber. Long short-term memory. Neural computation, 9(8):1735–1780,

1997.

Minghao Hu, Yuxing Peng, and Xipeng Qiu. Reinforced mnemonic reader for machine comprehension. arXiv

preprint arXiv:1705.02798, 2017.

Minqing Hu and Bing Liu. Mining and summarizing customer reviews.

In Proceedings of the tenth ACM

SIGKDD international conference on Knowledge discovery and data mining, pp. 168–177. ACM, 2004.

Nal Kalchbrenner, Edward Grefenstette, and Phil Blunsom. A convolutional neural network for modelling

sentences. arXiv preprint arXiv:1404.2188, 2014.

Nal Kalchbrenner, Lasse Espeholt, Karen Simonyan, Aaron van den Oord, Alex Graves, and Koray

Kavukcuoglu. Neural machine translation in linear time. arXiv preprint arXiv:1610.10099, 2016.

Yoon Kim. Convolutional neural networks for sentence classiﬁcation. In EMNLP, 2014.

Yoon Kim, Carl Denton, Luong Hoang, and Alexander M Rush. Structured attention networks. In ICLR, 2017.

Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In ICLR, 2015.

Ryan Kiros, Yukun Zhu, Ruslan R Salakhutdinov, Richard Zemel, Raquel Urtasun, Antonio Torralba, and Sanja

Fidler. Skip-thought vectors. In NIPS, 2015.

Filippos Kokkinos and Alexandros Potamianos. Structural attention neural networks for improved sentiment

analysis. arXiv preprint arXiv:1701.01811, 2017.

Tao Lei and Yu Zhang. Training rnns as fast as cnns. arXiv preprint arXiv:1709.02755, 2017.

Tao Lei, Regina Barzilay, and Tommi Jaakkola. Molding cnns for text: non-linear, non-consecutive convolu-

tions. In EMNLP, 2015.

Xin Li and Dan Roth. Learning question classiﬁers. In ACL, 2002.

Zheng Li, Yu Zhang, Ying Wei, Yuxiang Wu, and Qiang Yang. End-to-end adversarial memory network for

cross-domain sentiment classiﬁcation. In IJCAI, pp. 2237–2243, 2017.

Zhouhan Lin, Minwei Feng, Cicero Nogueira dos Santos, Mo Yu, Bing Xiang, Bowen Zhou, and Yoshua

Bengio. A structured self-attentive sentence embedding. In ICLR, 2017.

Yang Liu, Chengjie Sun, Lei Lin, and Xiaolong Wang. Learning natural language inference using bidirectional

lstm model and inner-attention. arXiv preprint arXiv:1605.09090, 2016.

Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey Dean. Efﬁcient estimation of word representations in

vector space. arXiv preprint arXiv:1301.3781, 2013a.

Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jeff Dean. Distributed representations of words

and phrases and their compositionality. In NIPS, 2013b.

Lili Mou, Rui Men, Ge Li, Yan Xu, Lu Zhang, Rui Yan, and Zhi Jin. Natural language inference by tree-based

convolution and heuristic matching. In ACL, 2016.

Tsendsuren Munkhdalai and Hong Yu. Neural semantic encoders. In EACL, 2017a.

Tsendsuren Munkhdalai and Hong Yu. Neural tree indexers for text understanding. In EACL, 2017b.

Bo Pang and Lillian Lee. A sentimental education: Sentiment analysis using subjectivity summarization based

on minimum cuts. In ACL, 2004.

to rating scales. In ACL, 2005.

tion. In EMNLP, 2014.

ACL, 2017.

Bo Pang and Lillian Lee. Seeing stars: Exploiting class relationships for sentiment categorization with respect

Jeffrey Pennington, Richard Socher, and Christopher D. Manning. Glove: Global vectors for word representa-

Qiao Qian, Minlie Huang, and Xiaoyan Zhu. Linguistically regularized lstms for sentiment classiﬁcation. In

Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. Squad: 100,000+ questions for machine

comprehension of text. In EMNLP, 2016.

14

Published as a conference paper at ICLR 2018

Alexander M Rush, Sumit Chopra, and Jason Weston. A neural attention model for abstractive sentence sum-

marization. In EMNLP, 2015.

Lifeng Shang, Zhengdong Lu, and Hang Li. Neural responding machine for short-text conversation. In ACL,

2015.

Tao Shen, Tianyi Zhou, Guodong Long, Jing Jiang, Shirui Pan, and Chengqi Zhang. Disan: Directional self-

attention network for rnn/cnn-free language understanding. arXiv preprint arXiv:1709.04696, 2017.

Richard Socher, Alex Perelygin, Jean Y Wu, Jason Chuang, Christopher D Manning, Andrew Y Ng, Christo-
pher Potts, et al. Recursive deep models for semantic compositionality over a sentiment treebank. In EMNLP,
2013.

Richard Socher, Andrej Karpathy, Quoc V Le, Christopher D Manning, and Andrew Y Ng. Grounded com-
positional semantics for ﬁnding and describing images with sentences. Transactions of the Association for
Computational Linguistics, 2:207–218, 2014.

Nitish Srivastava, Geoffrey E Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. Dropout:
a simple way to prevent neural networks from overﬁtting. Journal of Machine Learning Research, 15(1):
1929–1958, 2014.

Sainbayar Sukhbaatar, Jason Weston, Rob Fergus, et al. End-to-end memory networks. In NIPS, 2015.

Kai Sheng Tai, Richard Socher, and Christopher D Manning. Improved semantic representations from tree-

structured long short-term memory networks. In ACL, 2015.

Zhiyang Teng and Yue Zhang. Bidirectional tree-structured lstm with head lexicalization. In ACL, 2017.

Ashish Vaswani, Shazeer, Noam, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser,

and Illia Polosukhin. Attention is all you need. In NIPS, 2017.

Ivan Vendrov, Ryan Kiros, Sanja Fidler, and Raquel Urtasun. Order-embeddings of images and language. In

ICLR, 2016.

Wenhui Wang, Nan Yang, Furu Wei, Baobao Chang, and Ming Zhou. Gated self-matching networks for reading

comprehension and question answering. In ACL, 2017.

Zhiguo Wang, Haitao Mi, Wael Hamza, and Radu Florian. Multi-perspective context matching for machine

comprehension. arXiv preprint arXiv:1612.04211, 2016.

Janyce Wiebe, Theresa Wilson, and Claire Cardie. Annotating expressions of opinions and emotions in lan-

guage. Language resources and evaluation, 39(2):165–210, 2005.

Zichao Yang, Diyi Yang, Chris Dyer, Xiaodong He, Alexander J Smola, and Eduard H Hovy. Hierarchical

attention networks for document classiﬁcation. In HLT-NAACL, 2016.

Matthew D Zeiler. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701, 2012.

Han Zhao, Zhengdong Lu, and Pascal Poupart. Self-adaptive hierarchical sentence model. In IJCAI, 2015.

Jiang Zhao, Tiantian Zhu, and Man Lan. Ecnu: One stone two birds: Ensemble of heterogenous measures for

semantic relatedness and textual entailment. In SemEval@ COLING, pp. 271–277, 2014.

A THE SELECTION OF BLOCK LENGTH

In mBloSA, the length r of each block is a hyper-parameter that determines memory consumption
of mBloSA. To minimize the memory consumption, we propose an approach that calculates the
optimized block length r as follows.

We ﬁrst introduce the method for determining r for a dataset that has ﬁxed sentence length n. Given
the sentence length n and the block number m = n/r, we have the following facts: 1) the ma-
jor memory consumption in mBloSA is dominated by the masked self-attentions gm(·, M ); 2) the
memory consumption of the masked self-attention is proportional to the square of the sentence
length; and 3) mBloSA contains m masked self-attention with a sequence length of r, and 1 masked

15

Published as a conference paper at ICLR 2018

self-attention with a sequence length of m. Therefore, the memory ξ required by mBloSA can be
calculated by

ξ ∝ r2 · m + m2 · 1
n
r
By setting the gradient of ξ w.r.t. r to zero, we know that the memory consumption ξ is minimum
√
when r = 3

= r2 ·

(19)

n
r

+ (

2n.

)2.

Second, we propose a method for selecting r given a dataset with the sentence lengths that follow a
normal distribution N (µ, σ2). We consider the case where mini-batch SGD with a batch size of B or
its variant is used for training. We need to calculate the upper bound of the expectation of the maxi-
mal sentence length for each mini-batch. Let us ﬁrst consider B random variables [X1, X2, . . . , XB]
in the distribution N (0, σ2). The goal is to ﬁnd the upper bound of the expectation of random vari-
able Z + µ, where Z is deﬁned as

(20)

(21)

(22)

By Jensen’s inequality,

Z = max

Xi, for i = 1, 2, . . . , B.

i

etE[Z] ≤ E[etZ] = E[max

etXi]

i

≤

B
(cid:88)

i=1

E[etXi] = net2 σ2

2

Eq.(21) leads to

Let t =

√

2 ln B
σ

tσ2
2
and we obtain the following upper bound.

ln B
t

E[Z] ≤

+

.

√

(23)
Hence, the upper bound of the expectation of the maximal sentence length among all the B sentences
in each mini-batch is σ

2 ln B + µ. Therefore, the block length r is computed by
√

2 ln B

√

E[Z] ≤ σ

√
r = 3

2n = 3(cid:113)

2(σ

2 ln B + µ).

B NETWORK SETUP FOR MACHINE COMPREHENSION

Each sample in the Stanford Question Answering Dataset (SQuAD) (Rajpurkar et al., 2016) is com-
posed of three parts, i.e., a passage consisting of multiple sentences, a question sentence and a span
in the passage indicating the position of the answer. In order to evaluate the performance of sen-
tence embedding models, we change the task from predicting the span of the answer to ﬁnding the
sentence containing the correct answer.
Given a passage consisting of m sentences [s1, s2, . . . , sm] where sk = [xk1, xk2, . . . , xkn], and
the embedded question token sequence q = [q1, q2, . . . , ql], the goal is to predict which sentence in
the m sentences contains the correct answer to the question q.

The neural net we use to evaluate different sequence encoding models is given in Figure 7. First, we
process each sentence from the passage by a context fusion layer with shared parameters, followed
by a source2token self-attention with shared parameters, which outputs a vector representation of the
sentence. Therefore, the m sentences are represented by m vectors [u1, u2, . . . , um]. The question
sentence q is compressed into a vector representation q using source2token self-attention. Second,
we combine each sentence uk with q by concatenating uk, q, uk −q and uk (cid:12) q, i.e.,

ck = [uk; q; uk −q; uk (cid:12) q], for k = 1, 2, . . . , m.
(24)
Then c = [c1, c2, . . . , cm] is fed into another context fusion layer that explores sentence-level de-
pendencies. Finally, the resultant output representation of each sentence is separately fed into a fully
connected layer to compute a scalar score indicating the possibility of the sentence containing the
answer. A softmax function is applied to the scores of all m sentences, to generate a probability
distribution ˆp ∈ Rm for cross-entropy loss function. The sentence with the largest probability is
predicted as the sentence containing the answer.

16

Published as a conference paper at ICLR 2018

Figure 7: The structure of a neural network for machine comprehension. The candidates of the context fusion
layer include Bi-LSTM, Bi-GRU, Bi-SRU, multi-CNN, multi-head attention and Bi-BloSA. Unlike the original
multi-CNN for sentence embedding, we use padding and remove the max-pooling along the time axis to obtain
an output of the same length as input. DiSA is not considered due to memory limitation.

C LOSS OF REGRESSION PROBLEM

Following the setting introduced by Tai et al. (2015) and given a predicted probability distribution ˆp
as the output of a feedforward network, the regression model predicts the similarity degree as

ˆy = βT ˆp,

where β = [1, 2, . . . , K]. The ground-truth similarity degree y should be mapped to a probability
distribution p = [pi]K
i=1 as the training target, where p needs to fulﬁll y = βT p. The mapping can
be deﬁned as

(cid:40)y − (cid:98)y(cid:99),

pi =

(cid:98)y(cid:99) − y + 1,
0

i = (cid:98)y(cid:99) + 1
i = (cid:98)y(cid:99)
otherwise

,

i = 1, 2, . . . , K.

We use KL-divergence between p and ˆp as our loss function, i.e.,

(25)

(26)

(27)

L =

KL(p(k)||ˆp(k)),

1
M

M
(cid:88)

k=1

where the p(k) and ˆp(k) represent the target and predicted probability distributions of the k-th sample,
respectively.

D RELATED WORKS

Recently, several structured attention mechanisms (Kim et al., 2017; Kokkinos & Potamianos, 2017)
are proposed for capturing structural information from input sequence(s). When applied to self-
attention, structured attentions share a similar idea to self-alignment attention (Hu et al., 2017) and
multi-head attention (Vaswani et al., 2017) with one head, which aims to model the dependencies
between the tokens. Similar to the attention from multiple perspectives in multi-head attention,
multi-perspective context matching (Wang et al., 2016) explores the dependencies between passage
and question from multiple perspectives for reading comprehension, while self-attentive structure
(Lin et al., 2017) embeds sentences from various perspectives to produce matrix representations
In recursive models, self-attention over children nodes (Teng & Zhang, 2017)
of the sentences.
can provide effective input for their parent node that has no standard input (Tai et al., 2015) as
long as it is a non-leaf node in a semantic constituency parsing tree. Li et al. (2017) applies the
multi-hop attention mechanism to transfer learning for cross-domain sentiment analysis without any
RNN/CNN structure.

17

Published as a conference paper at ICLR 2018

Bi-BloSA and hierarchical attention network (Yang et al., 2016) have similar structure, i.e., both
stack two-layer attention mechanisms from bottom to top. However, they are different in three re-
spects: 1) Bi-BloSA aims to learn context-aware representation for each token, while hierarchical
attention is designed for document embedding; 2) the input of Bi-BloSA is a sentence, while the
intput of hierarchical attention is a document composed of multiple sentences; and 3) the hierar-
chical attention performs vanilla attention twice, i.e., token-level attention on each sentence and
sentence-level attention. Bi-BloSA, however, applies masked self-attention twice, i.e., intra-block
self-attention and inter-block self-attention. Additionally, Bi-BloSA uses a feature fusion gate for
each token to combine local and global context, and positional masks to encode temporal order
information.

18

