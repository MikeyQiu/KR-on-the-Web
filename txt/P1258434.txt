Chinese Poetry Generation with a Working Memory Model

Xiaoyuan Yi1, Maosong Sun1∗, Ruoyu Li2, Zonghan Yang1
1 State Key Lab on Intelligent Technology and Systems,
Beijing National Research Center for Information Science and Technology,
Department of Computer Science and Technology, Tsinghua University, Beijing, China
2 6ESTATES PTE LTD, Singapore

8
1
0
2
 
p
e
S
 
2
1
 
 
]
I

A
.
s
c
[
 
 
1
v
6
0
3
4
0
.
9
0
8
1
:
v
i
X
r
a

Abstract

As an exquisite and concise literary form, poetry
is a gem of human culture. Automatic poetry gen-
eration is an essential step towards computer cre-
ativity. In recent years, several neural models have
been designed for this task. However, among lines
of a whole poem, the coherence in meaning and
topics still remains a big challenge.
In this pa-
per, inspired by the theoretical concept in cognitive
psychology, we propose a novel Working Memory
model for poetry generation. Different from previ-
ous methods, our model explicitly maintains topics
and informative limited history in a neural memory.
During the generation process, our model reads the
most relevant parts from memory slots to gener-
ate the current line. After each line is generated,
it writes the most salient parts of the previous line
into memory slots. By dynamic manipulation of the
memory, our model keeps a coherent information
ﬂow and learns to express each topic ﬂexibly and
naturally. We experiment on three different genres
of Chinese poetry: quatrain, iambic and chinoiserie
lyric. Both automatic and human evaluation results
show that our model outperforms current state-of-
the-art methods.

1 Introduction
Poetry is a literary form with concise language, exquisite
expression and rich content, as well as some structural and
phonological requirements. During the thousands of years of
human history, poetry is always fascinating and popular, in-
ﬂuencing the development of different countries, nationalities
and cultures.

In Chinese, there are different genres of poetry.

In this
work, we mainly focus on three of them: quatrain (Jueju),
iambic (Ci) and chinoiserie lyric. Both for quatrain and
iambic, there are various tunes (sub-genres) and each tune de-
ﬁnes the length of each line, the tone of each character and the
number of lines (for iambic). With more than eight hundred
tunes, iambic is a quite complex genre (as shown in Figure 1).
By contrast, chinoiserie lyric is relatively free except for the

∗Corresponding author: M. Sun (sms@mail.tsinghua.edu.cn)

Figure 1: An iambic generated by our model with the tune Remem-
ber the Prince, taking liu (willow) and si jun (missing you) as input
topic words. Rhyming characters are underlined. The left part is
an artistic illustration of our model, where solid and dotted arrows
represent memory writing and reading respectively.

requirement on rhyme, which gets popular in recent twenty
years, driven by some famous singers [Fung, 2007].

We concentrate on automatic poetry generation. Besides
the requirements on form, to create a high-quality poem, how
to achieve better coherence is a key problem across different
genres. Generally, two factors must be taken into account.
For one thing, the topic needs to be expressed in a poem ﬂex-
ibly. For multiple topics, natural transition among different
topics can improve coherence. For another, lines in a poem
should be coherent in meaning, theme and artistic conception.
Recently, several neural models have been designed for dif-
ferent aspects of this task, such as poetry style transfer [Zhang
et al., 2017] and rhythmic constraints [Ghazvininejad et al.,
2016]. Nevertheless, this fundamental problem, coherence,
hasn’t been handled well, which is a major reason for the gap
between computer-generated poems and the human-authored
ones. The key point lies in that when generating a poem line,
existing models assume user inputs (topics) and the history
(preceding generated lines in the poem) can be packed into a
single small vector [Yan, 2016], or assume the model is able
to focus on the most important part of an unlimited history

[Wang et al., 2016a], which are implausible and against a hu-
man writing manner.

To tackle this problem, we refer to the concept in cogni-
tive psychology, where the working memory is a system with
a limited capacity that is responsible for holding informa-
tion available for reasoning, decision-making and behaviour
[Priti and Miyake, 1999]. Previous work has demonstrated
the importance of working memory in writing [McCutchen,
2000]. From the perspective of psycholinguistics, coherence
is achieved if the reader can connect the incoming sentence
to the content in working memory and to the major messages
and points of the text [Sanders et al., 2001].

Inspired by this, we propose a novel Working Memory
model1 for poetry generation. Rather than merges user topic
words as one vector as previous work [Yan, 2016], our model
maintains them in the memory explicitly and independently,
which play the role of ‘major messages’. When generating
each line, our model learns to read most relevant information
(topics or history) from the memory to guide current gener-
ation, according to what has been generated and which top-
ics have been expressed so far. For each generated line, our
model selects the most salient parts, which are informative
for succeeding generation, and writes them into the memory.
Instead of full history, our model keeps informative partial
history in multiple but limited memory slots. This dynamical
reading-and-writing way endows the model with the ability to
focus on relevant information and to ignore distractions dur-
ing the generation process, and therefore improves coherence
to a signiﬁcant extent. Besides, we design a special genre em-
bedding to control the tonal category of each character and
the length of each line, which makes our model structure-free
and able to generate various genres of poetry.

In summary, the contributions of this paper are as follows:
• To the best of our knowledge, for poetry generation,
we ﬁrst propose to exploit history with a dynamically
reading-and-writing memory.

• We utilize a special genre embedding to ﬂexibly control
the structural and phonological patterns, which enables
our model to generate various genres of poetry.

• On quatrain, iambic and chinoiserie lyric, our model
outperforms several strong baselines and achieves new
state-of-the-art performance.

2 Related Work
As a long-standing concern of AI, the research on automatic
poetry generation can be traced back decades. The ﬁrst step
of this area is based on rules and templates [Gerv´as, 2001].
Since the 1990s, statistical machine learning methods are
adopted to generate poetry, such as genetic algorithms [Ma-
nurung, 2003] and statistical machine translation (SMT) ap-
proach [He et al., 2012].

Stepping into the era of neural networks, different models
have been proposed to generate poetry and shown great ad-

1In fact, part of our model can be also considered as a kind of
Neural Turing Machine [Graves et al., 2014]. We take the per-
spective of working memory here to emphasize the inﬂuence of this
structure on human writing.

vantages. In general, previous neural models fall under three
methodologies in terms of how the history (preceding gener-
ated lines in the poem) is exploited.

The ﬁrst methodology is to pack all history into a single
history vector. Zhang and Lapata ﬁrst [2014] propose to
generate Chinese quatrains with Recurrent Neural Network
(RNN). Each generated line is vectorized by a Convolutional
Sentence Model and then packed into the history vector. To
enhance coherence, their model needs to be interpolated with
two extra SMT features, as the authors state. Yan [2016] gen-
erates Chinese quatrains using two RNNs. The last hidden
state in the ﬁrst RNN is used as the line vector, which is
packed into a history vector by the second RNN. In his model,
the poem generated in one pass will be reﬁned for several
times with an iterative polishing schema to improve quality.
The second one is to concatenate full history as a long se-
quence, which is exploited by a sequence-to-sequence model
with attention mechanism [Bahdanau et al., 2015].
[Wang
et al., 2016b] proposes a two-stage Chinese quatrains gener-
ation method which plans sub-keywords of the poem in ad-
vance by a language model, then generates each line with the
aid of the planned sub-keyword. However, such planning of
keywords takes a risk of losing ﬂexibility in topic expression.
The last one is to take the whole poem as a long sequence
and generate it word by word, where history propagates im-
plicitly along the RNN. This methodology is used to generate
both English poetry [Hopkins and Kiela, 2017; Ghazvinine-
jad et al., 2017] and Chinese poetry [Zhang et al., 2017;
Wang et al., 2016a]

These neural network-based approaches are promising, but
there is still a lot of room for improvement. A single vec-
tor doesn’t have enough capacity to maintain the full history.
Moreover, informative words and noises (e.g., stop words)
are mixed, which hinders the exploitation of history. When
the input or the output sequence is too long, the performance
of sequence-to-sequence model will still degrade, even with
an attention mechanism, which has been observed in related
tasks, e.g., Neural Machine Translation [Shen et al., 2016].
Consequently, we propose our Working Memory model with
multiple but limited memory slots.

Memory Network (MN) [Weston et al., 2015] and Neu-
ral Turing Machine (NTM) have shown great power in some
tasks, e.g., Question Answering (QA). The most relevant
work to our model is [Zhang et al., 2017], which saves hun-
dreds of human-authored poems in a static external memory
to improve the innovation of generated quatrains and achieve
style transfer. In fact, these MN and NTM models just learn
to write external texts (poems or articles) into memory. By
contrast, our model writes the generated history and hence
adopts a dynamic utilization of memory, which is closer to a
human manner as discussed in Section 1.

3 Model Description
3.1 Overview
Before presenting the proposed model, we ﬁrst formalize
our task. The inputs are user topics speciﬁed by K1 key-
words, {wk}K1
k=1. The output is a poem consisting of n lines,
{Li}n
i=1. Since we take the sequence-to-sequence framework

spectively. e(yt) is the word embedding of yt. The proba-
bility distribution of each character to be generated in Li is
calculated by2:

st = GRU (st−1, [e(yt−1); ot; gt; vi−1]),
p(yt|y1:t−1, L1:i−1, w1:K1 ) = sof tmax(W st),

(1)
(2)

where ot is the memory output and W is the projection pa-
rameter. vi−1 is a global trace vector, which records what has
been generated so far and provides implicit global informa-
tion for the model. Once Li is generated, it is updated by a
simple vanilla RNN:

vi = σ(vi−1,

ht), v0 = 0.

(3)

1
Tenc

Tenc(cid:88)

t=1

σ deﬁnes a non-linear layer and 0 is a vector with all 0-s.
Genre embedding. gt in Eq. (1) is a special genre em-
bedding. Since poetry must obey structural and phonological
rules, we use this genre embedding to control the genre of a
generated poem over each character. gt is the concatenation
of a phonology embedding and a length embedding, which
are learned during training. We deﬁne 36 phonology cate-
gories in terms of [Ge, 2009]. The phonology embedding
indicates the required category of yt. The length embedding
indicates the number of characters to be generated after yt in
Li and hence controls the length of Li.

Memory Reading. We begin by deﬁning an Addressing
Function, α = A( ˜M , q), which calculates the probabilities
that each slot of the memory is to be selected and operated.
Concretely, we have:

zk = bT σ( ˜M [k], q),
α[k] = sof tmax(zk),

where q is the query vector, b is the parameter, ˜M is the
memory to be addressed, ˜M [k] is the k-th slot (row) of ˜M
and α[k] is the k-th element in vector α.
Then, the working memory is read as:

αr = Ar(M, [st−1; vi−1]),

ot =

αr[k] ∗ M [k],

K
(cid:88)

k=1

where αr is the reading probability vector and the trace
vector vi−1 is used to help the Addressing Function avoid
reading redundant content. Joint reading from the three mem-
ory modules enables the model to ﬂexibly decide to express a
topic or to continue the history content.

Memory Writing. Here we use hidden states as vector
representations of characters. For topic memory, we feed
characters of each topic word wk into the encoder, then get
a topic vector by a non-linear transformation of the corre-
sponding hidden states. Then each topic vector is directly
ﬁlled into a slot. Before generating Li, the encoder hidden
states of characters in Li−1 are ﬁlled into local memory slots.

2For brevity, we omit biases and use ht to represent the combined

state of bidirectional encoder.

(4)
(5)

(6)

(7)

Figure 2: A graphical illustration of the Working Memory model,
which consists of an encoder, a decoder and the working memory.
The top half of this ﬁgure shows memory writing before generating
Li, and the bottom half shows the generation of Li.

and generate a poem line by line, the task can be converted
to the generation of an i-th line which is coherent in meaning
and related to the topics, given previous i-1 lines L1:i−1 and
the topic words w1:K1.

As illustrated in Figure 2, the working memory is com-
topic memory M1 ∈ RK1∗dh,
prised of three modules:
history memory M2 ∈ RK2∗dh and local memory M3 ∈
RK3∗dh , where each row of the matrices is a memory slot and
dh is slot size. K2 and K3 are the numbers of slots. Therefore
the whole working memory M = [M1; M2; M3], M ∈ RK∗dh
where [; ] means concatenation and K=K1+K2+K3.

Each topic word wk is written into the topic memory in
advance, which acts as the ‘major message’ and remains un-
changed during the generation process of a poem. Before
generating the i-th line Li, each character of Li−1 is writ-
ten into the local memory. There are often strong semantic
associations between two adjacent lines in Chinese poetry,
therefore we feed Li−1 into this local memory to provide full
short-distance history. Different from other two modules, the
model selects some salient characters of Li−2 to write into
the history memory. In this way, the history memory main-
tains informative partial long-distance history. These three
modules are read jointly.

Following this procedure, we detail our model.

3.2 Working Memory Model
Based on the sequence-to-sequence framework, we use GRU
[Cho et al., 2014] for decoder and bidirectional encoder. De-
note X a line in encoder (Li−1), X = (x1x2 . . . xTenc ), and
Y a generated line in decoder (Li), Y = (y1y2 . . . yTdec). ht
and st represent the encoder and decoder hidden states re-

Quatrains
Iambics
Lyrics

# of Poems
72,000
33,499
1,079

# of Lines
288,000
418,896
37,237

# of Characters
1,728,000
2,099,732
263,022

Table 1: Details of our corpus.

After Li is generated and before the generation of Li+1,
for each encoder state ht of Li−1, the model select a history
memory slot by writing addressing function and ﬁll ht into it.
Formally, we have:

αw = Aw( ˜M2, [ht; vi−1]),
β[k] = I(k = arg max

αw[j]),

j

˜M2[k] ← (1 − β[k]) ∗ ˜M2[k] + β[k] ∗ ht,

(10)

where I is an indicator function and αw is the writing prob-
abilities vector. ˜M2 is the concatenation of history memory
M2 and a null slot. If there is no need to write ht into history
memory, model learns to write it into the null slot, which is
ignored when reading memory by Eq. (6).

Since Eq. (9) is non-differentiable, it is only used for test-

ing. For training, we simply approximate β as:

β = tanh(γ ∗ (αw − 1 ∗ max(αw))) + 1,

(11)

where 1 is a vector with all 1-s and γ is a large positive
number. Eq. (11) is a rough approximation but it’s differen-
tiable, by which the model learns to focus on one slot with
a higher writing probability. We expect ht to be written into
only one slot, because we want to keep the representations of
salient characters independent as discussed in Section 2.

Before the generation, all memory slots are initialized with
0. For empty slots, a random bias is added to zk in Eq. (5) to
prevent multiple slots getting the same probability.

3.3 Topic Trace Mechanism
Though we use a global trace vector vi to save all generated
content, it seems not enough to help the model remember
whether each topic has been used or not. Therefore we design
a Topic Trace (TT) mechanism, which is a modiﬁed cover-
age model [Tu et al., 2016], to record the usage of topics in a
more explicit way:

1
K1

K1(cid:88)

k=1

ci = σ(ci−1,

M [k] ∗ αr[k]), c0 = 0,

ui = ui−1 + αr[1 : K1], ui ∈ RK1∗1, u0 = 0,
ai = [ci; ui].

(12)

(13)
(14)

ci maintains the content of used topics and ui explicitly
records the times of reading each topic. ai is the topic trace
vector. Then we rewrite Eq. (6) as:

αr = Ar(M, [st−1; vi−1; ai−1]).

(15)

Quatrains

Iambics

Lyrics

Models
iPoet
WM
iambicGen
WM
lyricGen
WM

BLEU PP
138
0.425
86
1.315
262
0.320
72
0.699
302
0.312
138
0.568

Table 2: Automatic evaluation results. BLEU scores are calculated
by the multi-bleu.perl script. PP means perplexity.

(8)
(9)

Strategies

WM0
WM0+GE
WM0+GE+TT

Quatrains
PP
127
87
86

BLEU
1.019
1.267
1.315

Iambics

Lyrics

BLE
0.561
0.672
0.699

PP
152
74
72

BLEU
0.530
0.542
0.568

PP
249
144
138

Table 3: Comparison of different strategies. GE: genre embedding.
TT: Topic Trace mechanism. WM0 is the model without GE or TT.

4 Experiments
4.1 Data and Setups
Table 1 shows details of our corpus. We use 1,000 quatrains,
843 iambics and 100 lyrics for validation; 1,000 quatrains,
900 iambics and 100 lyrics for testing. The rest are used for
training.

Since our model and most previous models take topic
words as input, we run TextRank [Mihalcea and Tarau, 2004]
on the whole corpus and extract four words from each poem.
In training, we build four <keyword(s), poem> pairs for each
poem using 1 to 4 keywords respectively, so as to improve the
model’s ability to cope with different numbers of keywords.
In testing, we randomly select one pair from the four and use
the phonological and structural pattern of ground truth.

We set K1 = 4 and K2 = 4. The sizes of word embed-
ding, phonology embedding, length embedding, hidden state,
global trace vector, topic trace vector are set to 256, 64, 32,
512, 512, 24 (20+4) respectively. Since we directly feed hid-
den states of bidirectional encoder into memory, the slot size
dh is 1024. The word embedding is initialized with word2vec
vectors pre-trained on the whole corpus. Different memory
modules share the same encoder. We use two different ad-
dressing functions for reading and writing respectively. For
all non-linear layers, tanh is used as the activation function.

Adam with shufﬂed mini-batches (batch size 64) is used for
optimization. To avoid overﬁtting, 25% dropout and (cid:96)2 regu-
larization are used. Optimization objective is standard cross
entropy errors of the predicted character distribution and the
actual one. Given several topic words as input, all models
generate each poem with beam search (beam size 20). For
fairness, all baselines share the same conﬁguration.

4.2 Models for Comparisons
Besides WM3 (our Working Memory model) and Human
(human-authored poems), on quatrains we compare iPoet
[Yan, 2016], Planning [Wang et al., 2016b] and FCPG

We will show that this Topic Trace mechanism can further

improve the performance of our model in Section 4.

3https://github.com/xiaoyuanYi/WMPoetry.

Models
Planning
iPoet
FCPG
WM
Human
iambicGen
WM
Human
lyricGen
WM
Human

Fluency Meaning Coherence Relevance Aesthetics
2.28
2.54
2.36
3.57∗∗
3.62
2.48
3.39∗∗
4.04
1.70
2.63∗∗
3.43++

2.31
2.45
2.28
3.47∗∗
3.58
3.08
3.87∗∗
4.09
1.99
2.66∗∗
3.26++

2.18
2.27
2.15
3.55∗∗
3.59
2.78
3.77∗∗
4.13++
1.81
2.46∗∗
3.41++

2.13
2.28
2.15
3.45∗∗
3.52
2.73
3.69∗∗
4.10++
1.65
2.49∗∗
3.20++

2.50
2.13
2.65
3.77∗∗
3.78
2.36
3.87∗∗
4.03
2.24
2.53
3.34++

Quatrains

Iambics

Lyrics

Table 4: Human evaluation results. Diacritic ** (p < 0.01) indicates WM signiﬁcantly outperforms baselines; ++ (p < 0.01) indicates
Human is signiﬁcantly better than all models. The Intraclass Correlation Coefﬁcient of the four groups of scores is 0.5, which indicates an
acceptable inter-annotator agreement.

[Zhang et al., 2017]. We choose these previous models as
baselines, because they all achieve satisfactory performance
and the authors have done thorough comparisons with other
models, such as RNNPG [Zhang and Lapata, 2014] and SMT
[He et al., 2012]. Moreover, the three models just belong to
the three methodologies mentioned in Section 2 respectively.
On iambics we compare iambicGen [Wang et al., 2016a].
To the best of our knowledge, this is the only one neural
model designed for Chinese iambic generation.

On chinoiserie lyrics, since there is no specially designed
model in the literature, we implement a standard sequence-
to-sequence model as the baseline, called lyricGen.

4.3 Evaluation Design
Automatic Evaluation. Referring to [Zhang and Lapata,
2014; Yan, 2016], we use BLEU and perplexity to evaluate
our model. BLEU and Perplexity are not perfect metrics for
generated poems, but they can still provide an aspect for eval-
uation and make sense to some extent in the context of pursu-
ing better coherence. Furthermore, automatic evaluation can
save much labour and help us determine the best conﬁgure.

Human Evaluation. We design ﬁve criteria: Fluency
(does the poem obey the grammatical, structural and phono-
logical rules?), Meaning (does the poem convey some cer-
tain messages?), Coherence (is the poem as a whole coherent
in meaning and theme?), Relevance (does the poem express
user topics well?), Aesthetics (does the poem have some po-
etic and artistic beauties?). Each criterion needs to be scored
in a 5-point scale ranging from 1 to 5.

From the testing set, for quatrains, iambics and lyrics we
randomly select 30, 30 and 20 sets of topic words respectively
to generate poems with these models. For Human, we select
poems containing the given words. Therefore, we obtain 150
quatrains (30*5), 90 iambics (30*3) and 60 lyrics (20*3). We
invite 16 experts4 on Chinese poetry to evaluate these poems,
who are divided into four groups. Each group completes the
evaluation of all poems and we use the average scores.

4The experts are Chinese literature students or members of a po-
etry association. They are required to focus on the quality as objec-
tively as possible, even if they recognize the human-authored ones.

Planning and FCPG are not suitable for automatic evalua-
tion, because FCPG is designed for innovation and Planning
will plan the sub-topics by itself, which increase the perplex-
ity. Thus we leave them for human evaluation.

4.4 Evaluation Results

As shown in Table 2, WM outperforms other models un-
der BLEU and perplexity evaluations. On quatrains, WM
gets almost three times higher BLEU score than iPoet does.
This signiﬁcant improvement partially lies in that more than
70% of the input topics are expressed5 in poems generated
by WM, beneﬁting from the topic memory. By contrast, this
expression ratio is only 28% for iPoet, since iPoet merges
words and history into two single vectors respectively, re-
sulting in implicit and indiscriminate exploitation of topics
and history. On iambics, WM also achieves notable perfor-
mance. Because iambicGen generates the whole iambic as a
long sequence by the decoder, it handles short iambics well
but fails to generate high-quality longer ones. For iambics
with less than 70 characters, perplexity of iambicGen is 235.
For those with more characters, perplexity of iambicGen in-
creases to 290. On chinoiserie lyrics, WM also gets better
results, though the performance is not so satisfactory (both
for WM and lyricGen), due to the small training set.

It is worth mentioning that the improvement partially re-
sults from the genre embedding. By incorporating structural
and phonological control into the model, WM greatly reduces
the uncertainty of generation. To demonstrate the effective-
ness of the working memory itself, we show the performance
of different strategies of WM in Table 3. As we can see, even
without genre embedding, our model still outperforms base-
lines prominently. Besides, Topic Trace mechanism further
improves performance.

Table 4 gives human evaluation results. WM achieves bet-
ter results than other models. On quatrains, WM gets close to
Human on Coherence and Relevance. Planning gets the worst
results on Fluency and Meaning. This is mainly because plan-
ning mechanism can’t guarantee the quality of planned sub-

5If a topic word or at least one of its relevant words is generated,

we say this topic is expressed.

Figure 3: (a) Over different numbers of history memory slots, BLEU and perplexity on iambics and lyrics. (b) On iambics, perplexity over
different numbers of lines in a poem. (c) The visualization of memory (in the x-axis) reading probabilities, αr, when generating the last line
(in the y-axis) of the iambic shown in Figure 1.

keywords and the ﬁxed keywords order loses some freedom
of topic expression, hurting ﬂuency and meaning. iPoet gets
the lowest score on Relevance, since it packs all topic words
into one vector, resulting in a low topic expression ratio. By
contrast, WM maintains keywords in the topic memory in-
dependently and the expression order is ﬂexibly decided by
the model in terms of the history. Beneﬁting from TT, an un-
expressed word still has the chance to be generated in later
lines. Thus WM gets a comparable score with Human on
Relevance. FCPG performs worst on Coherence. As dis-
cussed in Section 2, FCPG generates the whole poem as a
long sequence and the history is saved in RNN state implic-
itly, which therefore can’t be utilized effectively. On iambics
and lyrics, WM gets better results, but there is still a distinct
gap with Human.
Iambic is a quite complex form and the
longest iambic in our testing set consists of more than 150
characters (25 lines). It’s much harder for the model to gener-
ate a high-quality iambic. For lyrics, due to the limited small
data, the results are not as good as we expected. We put the
requirements of structure and phonology into Fluency crite-
rion. As a result, WM gets a much higher Fluency score than
baselines, beneﬁting from the genre embedding.

4.5 Analyses and Discussions
We test the performance of WM6 on different numbers of
slots. As shown in Figure 3 (a), both on iambics and lyrics,
as the number of slots increases, BLEU gets better ﬁrst and
then deteriorates and so does perplexity. Some lyrics consist
of more than 100 lines. More slots should have led to better
results on lyrics. However, with the small lyrics corpus, the
model can’t be trained adequately to operate many slots. Fig-
ure 3 (b) gives perplexity over different numbers of lines on
iambics. There is little difference for iambics with less than
10 lines. For longer iambics, the model with 6 slots gets bet-
ter results, though perplexity still increases with more lines.

With too many slots (e.g., inﬁnite slots), our history mem-
ory falls back to the second methodology discussed in Section
2. Without any slot, it falls back to the ﬁrst methodology. The
number of memory slots is an important parameter and should
be balanced carefully in accordance with the conditions.

6We removed Topic Trace here to observe the inﬂuence of the

number of slots itself.

In Figure 3 (c), we show an example of how our model
focuses on different parts of the memory when generating a
line. Our model ignores topic word liu (willow) when gener-
ating character hong (red), since the color of willow is green.
The model focuses on topic word si jun (missing you) when
generation character jian (letter), since in ancient China, peo-
ple often sent their love and missing by letters. Besides,
the model generates lei (tears) with a strong association with
meng (dream) in history memory. The word ‘dream’ is often
a symbol to express the pain that a girl is separated from her
lover and can only meet him in the dream.

5 Conclusion and Future Work
In this paper, we address the problem of pursuing better co-
herence in automatic poetry generation. To this end, a gener-
ated poem as a whole should be relevant to the topics, express
these topics naturally and be coherent in meaning and theme.
Inspired by the concept in cognitive psychology, we propose
a Working Memory model, which maintains user topics and
informative limited history in memory to guide the genera-
tion. By dynamical reading and writing during the generation
process, our model keeps a coherent information ﬂow and ig-
nores distractions. The experiment results on three different
genres of Chinese poetry demonstrate that our model effec-
tively improves the quality and coherence of generated poems
to a signiﬁcant extent.

Besides, combined with a genre embedding, our model is
able to generate various genres of poetry. The specially de-
signed Topic Trace mechanism helps the model remember
which topics have been used in a more explicit way, further
improving the performance.

There still exists a gap between our model and human po-
ets, which indicates that there are lots to do in the future. We
plan to design more effective addressing functions and incor-
porate external knowledge to reinforce the memory.

Acknowledgments
This work is supported by the National 973 Program
(No.2014CB340501).

References
[Bahdanau et al., 2015] Dzmitry Bahdanau, KyungHyun
Cho, and Yoshua Bengio. Neural machine translation
In Proceed-
by jointly learning to align and translate.
ings of the 2015 International Conference on Learning
Representations, San Diego, CA, 2015.

[Cho et al., 2014] Kyunghyun Cho, Bart Van Merri¨enboer,
Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares,
Holger Schwenk, and Yoshua Bengio. Learning phrase
representations using rnn encoder-decoder for statistical
machine translation. In Proceedings of the 2014 Confer-
ence on Empirical Methods in Natural Language Process-
ing, pages 1724–1734, Doha, Qatar, 2014.

[Fung, 2007] Anthony Y. H. Fung. The emerging (national)
popular music culture in china. Inter-Asia Cultural Stud-
ies, 8(3):425–437, 2007.

[Ge, 2009] Zai Ge. cilinzhengyun. Shanghai Ancient Books

Publishing House, 2009.

[Gerv´as, 2001] Pablo Gerv´as. An Expert System for the
Composition of Formal Spanish Poetry, pages 181–188.
Springer London, 2001.

[Ghazvininejad et al., 2016] Marjan Ghazvininejad, Xing
Shi, Yejin Choi, and Kevin Knight. Generating topical
In Proceedings of the 2016 Conference on Em-
poetry.
pirical Methods in Natural Language Processing, pages
1183–1191, Texas, USA, 2016.

[Ghazvininejad et al., 2017] Marjan Ghazvininejad, Xing
Shi, Jay Priyadarshi, and Kevin Knight. Hafez: an inter-
active poetry generation system. In Proceedings of ACL
2017, System Demonstrations, pages 43–48. Association
for Computational Linguistics, 2017.

[Graves et al., 2014] Alex Graves, Greg Wayne, and Ivo
arXiv preprint

Danihelka. Neural turing machines.
arXiv:1410.5401, 2014.

[Gulcehre et al., 2017] Caglar Gulcehre, Sarath Chandar,
Kyunghyun Cho, and Yoshua Bengio. Dynamic neural tur-
ing machine with soft and hard addressing schemes. arXiv
preprint arXiv:1607.00036, 2017.

[He et al., 2012] Jing He, Ming Zhou, and Long Jiang. Gen-
erating chinese classical poems with statistical machine
In Proceedings of the 26th AAAI
translation models.
Conference on Artiﬁcial Intelligence, pages 1650–1656,
Toronto, Canada, 2012.

[Hopkins and Kiela, 2017] Jack Hopkins and Douwe Kiela.
Automatically generating rhythmic verse with neural net-
In Proceedings of the 55th Annual Meeting of
works.
the Association for Computational Linguistics, pages 168–
178. Association for Computational Linguistics, 2017.
[Manurung, 2003] Hisar Maruli Manurung. An evolutionary
algorithm approach to poetry generation. PhD thesis, Uni-
versity of Edinburgh, 2003.

[McCutchen, 2000] Deborah McCutchen. Knowledge, pro-
cessing, and working memory: Implications for a theory
of writing. Educational Psychologist, 35(1):13–23, 2000.

[Mihalcea and Tarau, 2004] Rada Mihalcea and Paul Tarau.
Textrank: Bringing order into text. In Proceedings of the
2004 Conference on Empirical Methods in Natural Lan-
guage Processing, 2004.

[Priti and Miyake, 1999] Shah Priti and Akira Miyake. Mod-
els of working memory: Mechanisms of active mainte-
nance and executive control. Cambridge University Press,
1999.

[Sanders et al., 2001] Ted Sanders, Joost Schilperoord, and
Wilbert Spooren. Text representation: Linguistic and psy-
cholinguistic aspects., pages 258–267.
John Benjamins
Publishing, 2001.

[Shen et al., 2016] Shiqi Shen, Yong Cheng, Zhongjun He,
Wei He, Hua Wu, Maosong Sun, and Yang Liu. Mini-
mum risk training for neural machine translation. In Pro-
ceedings of the 54th Annual Meeting of the Association for
Computational Linguistics, pages 1683–1692. Association
for Computational Linguistics, 2016.

[Tu et al., 2016] Zhaopeng Tu, Zhengdong Lu, Yang Liu,
Xiaohua Liu, and Hang Li. Modeling coverage for neu-
ral machine translation. In Proceedings of the 54th Annual
Meeting of the Association for Computational Linguistics.
Association for Computational Linguistics, 2016.

[Wang et al., 2016a] Qixin Wang, Tianyi Luo, Dong Wang,
and Chao Xing. Chinese song iambics generation with
In Proceedings of the
neural attention-based model.
Twenty-Fifth International Joint Conference on Artiﬁcial
Intelligence, pages 2943–2949, New York, USA, 2016.
[Wang et al., 2016b] Zhe Wang, Wei He, Hua Wu nad
Haiyang Wu, Wei Li, Haifeng Wang, and Enhong Chen.
Chinese poetry generation with planning based neu-
the
ral network.
26th International Conference on Computational Linguis-
tics:Technical Papers, pages 1051–1060, Osaka, Japan,
2016.

In Proceedings of COLING 2016,

[Weston et al., 2015] Jason Weston, Sumit Chopra, and An-
In In International
toine Bordes. Memory networks.
Conference on Learning Representations, San Diego, CA,
2015.

[Yan, 2016] Rui Yan.

i,poet:automatic poetry composition
through recurrent neural networks with iterative polishing
schema. In Proceedings of the Twenty-Fifth International
Joint Conference on Artiﬁcial Intelligence, pages 2238–
2244, New York, USA, 2016.

[Zhang and Lapata, 2014] Xingxing Zhang and Mirella Lap-
ata. Chinese poetry generation with recurrent neural net-
In Proceedings of the 2014 Conference on Em-
works.
pirical Methods in Natural Language Processing, pages
670–680, Doha, Qatar, 2014.

[Zhang et al., 2017] Jiyuan Zhang, Yang Feng, Dong Wang,
Yang Wang, Andrew Abel, Shiyue Zhang, and Andi
Zhang. Flexible and creative chinese poetry generation
using neural memory. In Proceedings of the 55th Annual
Meeting of the Association for Computational Linguistics,
pages 1364–1373. Association for Computational Linguis-
tics, 2017.

