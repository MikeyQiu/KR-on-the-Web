TRAINING NEURAL AUDIO CLASSIFIERS WITH FEW DATA

Jordi Pons(cid:63) †

Joan Serr`a(cid:63)

Xavier Serra†

(cid:63) Telef´onica Research, Barcelona
† Music Technology Group, Universitat Pompeu Fabra, Barcelona

8
1
0
2
 
v
o
N
 
3
 
 
]

D
S
.
s
c
[
 
 
3
v
4
7
2
0
1
.
0
1
8
1
:
v
i
X
r
a

ABSTRACT
We investigate supervised learning strategies that improve the train-
ing of neural network audio classiﬁers on small annotated collec-
tions. In particular, we study whether (i) a naive regularization of
the solution space, (ii) prototypical networks, (iii) transfer learning,
or (iv) their combination, can foster deep learning models to better
leverage a small amount of training examples. To this end, we eval-
uate (i–iv) for the tasks of acoustic event recognition and acoustic
scene classiﬁcation, considering from 1 to 100 labeled examples per
class. Results indicate that transfer learning is a powerful strategy
in such scenarios, but prototypical networks show promising results
when one does not count with external or validation data.

Index Terms— prototypical networks, transfer learning, audio

classiﬁcation, small data.

1. INTRODUCTION

It exists a prominent corpus of research assuming that sizable
amounts of annotated audio data are available for training end-to-end
classiﬁers [1, 2, 3, 4]. These studies are mostly based on publicly-
available datasets, where each class typically contains more than
100 audio examples [5, 6, 7, 8, 9]. Contrastingly, only few works
study the problem of training neural audio classiﬁers with few audio
examples (for instance, less than 10 per class) [10, 11, 12, 13]. In
this work, we study how a number of neural network architectures
perform in such situation. Two primary reasons motivate our work:
(i) given that humans are able to learn novel concepts from few
examples, we aim to quantify up to what extent such behavior is
possible in current neural machine listening systems; and (ii) pro-
vided that data curation processes are tedious and expensive, it is
unreasonable to assume that sizable amounts of annotated audio are
always available for training neural network classiﬁers.

The challenge of training neural networks with few audio data
has been previously addressed. For example, Morﬁ and Stowell [12]
approached the problem via factorising an audio transcription task
into two intermediate sub-tasks: event and tag detection. An-
other way to approach the problem is by leveraging additional
data sources, like in unsupervised and semi-supervised frameworks
where non-labelled data is also utilized [14, 15, 16]. Transfer learn-
ing is a popular way to exploit such additional data sources [17, 18],
and it has been used to construct acoustic models for low-resource
languages [19, 20], to adapt generative adversarial networks to new
languages and noise types [21], or to transfer knowledge from the
visual to the audio domain [22]. An additional alternative is to use
data augmentation, which has proven to be very effective for audio
classiﬁcation tasks [2, 23]. However, in this work, we center our ef-
forts into exploiting additional data resources with transfer learning.

Work partially funded by the Maria de Maeztu Programme (MDM-2015-

0502). J. Pons and X. Serra are grateful to NVidia for the donated GPUs.

This, according to our view, has three main advantages: (i) differ-
ently to data augmentation, it allows leveraging external sources of
data; (ii) it exists a rich set of techniques for learning transferable
representations [16, 17, 18, 20, 22]; and (iii) transfer learning can
always be further extended with data augmentation.

In parallel to previous works, the machine learning community
has been developing methods for learning novel classes from few
training instances, an area known as few-shot learning [11, 24, 25,
26]. These methods aim to build a classiﬁer that generalizes to new
classes not seen during training, given only a small number of train-
ing examples for each new class. Differently to few-shot learning,
the models we study do not generalize to new classes. Instead, we as-
sume a ﬁxed taxonomy during both training and prediction. Still, we
derive inspiration from few-shot learning for their capacity to learn
from few training data. A popular approach to few-shot learning is
metric learning, which aims to learn representations that preserve the
class neighborhood structure so that simple distances can be mea-
sured in a learnt space [24, 26]. Such methods have been mostly
used for image classiﬁcation, and are very appealing due to their
simplicity and yet powerful performance on several benchmarks.

In our study we consider prototypical networks [24], a metric
learning approach that is based on computing distances against class-
based prototypes deﬁned in a learnt embedding space (one can think
of it as a nearest-neigbour classiﬁer trained end-to-end). Our aim
is to study if prototypical networks are capable to generalize better
than raw deep learning models when trained on small data. To the
best of our knowledge, only Tilk [11] has explored metric learning
methods for constructing neural audio classiﬁers. He used the last
layer features of a siamese network [27], an alternative metric learn-
ing approach, as input to an SVM classiﬁer. Therefore, our work
can be considered the ﬁrst one to employ prototypical networks for
audio. Besides, back in the 80’s, Kohonen [28] proposed a distance-
based model for speech recognition called learning vector quantiza-
tion (LVQ), which is closely related to prototypical networks. How-
ever, LVQ is not designed to learn from few data and, furthermore,
does not exploit the powerful non-linear mapping that neural net-
works can provide.

In this work, we investigate which strategies can provide a per-
formance boost when neural network audio classiﬁers are trained
with few data. These are evaluated under different low-data sit-
uations, which we describe in section 2. Firstly, we consider the
regularization of the traditional deep learning pipeline (section 3.1).
Next, we consider prototypical networks, with the aim to showcase
the potential of metric learning-based classiﬁers coming from the
few-shot learning literature (section 3.2). Finally, we consider trans-
fer learning as a canonical way to leverage external sources of audio
data (section 3.3). Results are presented in section 4 and, to con-
clude, we provide further discussion in section 5. We use publicly-
available data sets, and share the code to reproduce our experiments
at github.com/jordipons/neural-classiﬁers-with-few-audio.

2. METHODOLOGY

2.1. Data: Where is the validation set?

The focus of this work is to investigate which neural network-based
strategies perform best in the low-data regime. To do so, we simu-
late classiﬁcation scenarios having only n randomly selected training
audios per class, n ∈ {1, 2, 5, 10, 20, 50, 100}. Since results of the
same repeated experiment might vary depending on which audios
are selected, we run each experiment m times per fold of data, and
report average accuracy scores across runs and folds. Speciﬁcally:
m = 20 when n ∈ {1, 2}, m = 10 when n ∈ {5, 10}, and m = 5
when n ∈ {20, 50, 100}.

We run the study for both the tasks of acoustic event recog-
nition and acoustic scene classiﬁcation. For acoustic event recog-
nition, we employ the UrbanSound8K dataset (US8K) [8], featur-
ing 8,732 urban sounds divided into 10 classes and 10 folds (with
roughly 1000 instances per class). For acoustic scene classiﬁcation,
we resort to the TUT dataset (ASC-TUT) [7, 29], featuring 4,680
audio segments for training and 1,620 for evaluation, of 10 s each,
divided into 15 classes (with 312 instances per class). Furthermore,
and we consider this a crucial aspect of our work, we assume that
data is so scarce that it is unreasonable to presuppose the existence
of a validation set for deciding when to stop training. As a result of
such constraint, the following sections also describe the rules we use
to decide when to stop training. Besides reducing the train set size
and not utilizing any validation set, we keep the original partitions
to compare our results with previous works.

2.2. Baselines

To put results into context, we employ several baselines aiming to
describe lower and upper bounds for the two tasks we consider:

• Random guess: A model picking a class at random, which
scores 9.99% accuracy for US8K and 6.66% for ASC-TUT.

• Nearest-neighbor MFCCs: A model based on a simple
nearest-neighbor classiﬁer using the cosine distance over
MFCC features. The feature vector is constructed from
20 MFCCs, their ∆s, and ∆∆s. We compute their mean and
standard deviation through time, with the resulting feature
vector per audio clip being of size 120.

• Salamon and Bello [2] (SB-CNN): This model achieves
state-of-the-art results for US8K. When trained with all
US8K training data it achieves an average accuracy score of
73% across folds (79% with data augmentation). SB-CNN
is an AlexNet-like model that consists of 3 convolutional
layers with ﬁlters of 5×5, interleaved with max-pool layers.
The resulting feature map is connected to a softmax output
via a dense layer of 64 units. To assess how standard deep
learning models would perform when learning their weights
from scratch with small data, we train this baseline for all n.

• Han et al. [30] and Mun et al. [23]: These models achieve
state-of-the-art performance for ASC-TUT. When trained
with all ASC-TUT training data, they achieve an accuracy
score of 80.4% using an ensemble [30], and 83.3% using an
ensemble trained with GAN-based data augmentation [23].

2.3. Training details

Unless stated otherwise, the sections below follow the same experi-
mental setup. Following common practice [2, 31], inputs are set to

be log-mel spectrogram patches of 128 bins × 3 s (128 frames)1. For
US8K, when audio clips are shorter than 3 s, we ‘repeat-pad’ spec-
trograms in order to meet the model’s input size. That is, the origi-
nal short signal is repeated up to create a 3 s signal. During training,
data are randomly sampled from the original log-mel spectrograms
following the previous rules. However, during prediction, if sounds
are longer than 3 s, several predictions are computed by a moving
window of 1 s and then averaged. We use ReLUs and a batch size of
256. Learning proceeds via minimizing the cross-entropy loss with
vanilla stochastic gradient descent (SGD) at a rate of 0.1. We stabi-
lize learning with gradient clipping, that is, we rescale the gradients
so that their L2 norm does never exceed a threshold of 5.

3. AUDIO CLASSIFICATION WITH FEW DATA

3.1. Regularized models

In a ﬁrst set of experiments, we showcase the limitations of the com-
monly used deep learning pipeline when training data are scarce.
An ordinary approach to avoid overﬁtting in such cases is to use
regularization. Following this idea, we consider two architectures.
The ﬁrst one, VGG, is meant to keep the model highly expressive
while introducing as much regularization as possible. The second
one, TIMBRE, strongly regularizes the set of possible solutions via
domain-knowledge informed architectural choices.

• VGG [1, 18]: This is a computer vision architecture designed
to make minimal assumptions regarding which are the lo-
cal stationarities of the signal, so that any structure can be
learnt via hierarchically combining small-context representa-
tions. To this end, it is common to utilize a deep stack of small
3×3 ﬁlters (in our case 5 layers, each having only 32 ﬁlters),
combined with max-pool layers (in our case of 2×2). We fur-
ther employ a ﬁnal dense layer with a softmax activation that
adapts the feature map size to the number of output classes,
ELUs as non-linearities [18], and batch norm.

• TIMBRE [3, 31]: This model is designed to learn timbral
representations while keeping the model as small as possible.
We use a single-layer convolutional neural network (CNN)
with vertical ﬁlters of 108 bins × 7 frames. A softmax output
is computed from the maximum values present in each CNN
feature map and, therefore, the model has as many ﬁlters as
output classes. TIMBRE is possibly the smallest CNN one
can imagine for an audio classiﬁcation task, provided that it
only has a single ‘timbral’ ﬁlter per class [3].

Note that the studied VGG and TIMBRE models, of approxi-
mately 50 k and 10 k parameters, respectively, are much smaller than
the state-of-the-art SB-CNN model, which has approximately 250 k
parameters. Besides the regularization we introduce via minimizing
the model size, we employ L2-regularization, with a penalty factor
of 0.001, and make use of 50% dropout whenever a dense layer is
present (only VGG and SB-CNN models have dense layers). Finally,
and given that no validation set is available, we empirically ﬁnd that
(early) stopping training after 200 epochs provides good results for
all studied models that are not based on prototypical networks.

3.2. Prototypical networks

In the next set of experiments, we study how prototypical networks
can be exploited for audio classiﬁcation with few examples. As men-
tioned, prototypical networks are based on learning a latent metric

1STFT parameters: window size=hop size=1024 and fs=44.1 kHz.

space in which classiﬁcation can be performed by computing dis-
tances to prototype representations of each class. Prototypes µk are
mean vectors of the embedded support data belonging to class k.
That is, given input samples xi:

µk =

fφ(xi),

1
|Sk|

(cid:88)

xi∈Sk

where fφ is parametrized by a neural network. In our case, we use
a VGG as in section 3.1, but with 128 ﬁlters per layer and a ﬁnal
linear layer instead of a softmax. The prototype vector µk ∈ RD is
set to have an embedding size of D = 10. In this work, the support
set Sk to compute each class’ prototype is conformed by 5 randomly
selected patches from the train set belonging to class k. These same
sounds will be then reused to train fφ.

Prototypical networks produce a distribution over classes for a
query point xi based on a softmax over distances to the prototypes
in the embedding space:

pk(xi) =

e−d(fφ(xi),µk)
k(cid:48) e−d(fφ(xi),µk(cid:48) ) ,

(cid:80)

where d is any suitable distance measure. We here use the Euclidean
distance as we found it to outperform the cosine distance for our
tasks, see Appendix A.1. The training of fφ is based on minimiz-
ing the negative log-probability of the true class via SGD. Training
epochs are formed by batches of 5 random patches per class, and
we backpropagate until the train set accuracy does not improve for
200 epochs. Note that this stop criteria does not utilize a valida-
tion set, only the train set. Differently from the common supervised
learning pipeline, we found overﬁtting not to be an issue with proto-
typical networks, which is an important point to consider when train-
ing models with few data. Actually, monitoring how well the model
is able to separate the training data in the embedding space, through
measuring train set accuracy, was an effective way to assess how
discriminative such space is. Although this stop criteria could pro-
mote overﬁtting the train set, in section 4 we show that prototypical
networks’ generalization capabilities are still above the ones of the
raw deep learning pipeline. Further discussion on the generalization
capabilities of prototypical networks is available at Appendix A.2.

3.3. Transfer learning

In our ﬁnal set of experiments, we assess the effectiveness of canon-
ical transfer learning strategies. For that, we use a VGG model pre-
trained with Audioset [1, 9], a dataset conformed by 2 M YouTube
audios that was designed for training acoustic event recognition
models. As a result, note that our source and target tasks are the
same for US8K (all US8K classes have a direct correspondence in
Audioset), but are different for ASC-TUT (only 5 out of 15 classes
resemble Audioset classes). The pre-trained Audioset model2 is
composed of 6 convolutional layers with ﬁlters of 3×3, interleaved
with max-pooling layers of 2×2, followed by 3 dense layers of 4096,
4096, and 128 units, respectively. Inputs are log-mel spectrogram
patches of 64 bins × 1 s (96 frames)3. In order to match the same
conditions as previous experiments for inputs longer than 1 s, we
compute several predictions by a non-overlapping moving window
of 1 s that are ﬁnally averaged. When audios are shorter than 1 s, we
use ‘repeat-pad’ as in previous experiments (see section 2.3).

In order to study how the pre-trained Audioset model transfers

to our tasks, we consider three alternatives:

2github.com/tensorﬂow/models/tree/master/research/audioset
3STFT parameters: window size=400, hop size=160 and fs=16 kHz

• Nearest-neighbor with Audioset features: This baseline
classiﬁer serves to study how discriminative are the Audioset
features alone. It is based on the cosine distance, and utilizes
majority voting to aggregate the different predictions of the
model through time (one per second of audio).

• Transfer learning (ﬁne-tuning): The pre-trained Audioset
model is ﬁne-tuned, together with a dense softmax layer that
acts as the ﬁnal classiﬁer.

• Prototypical networks + transfer learning: We experiment
with the idea of using transfer learning in the context of pro-
totypical networks, and we ﬁne-tune the pre-trained model to-
gether with a dense linear layer (10 units) that deﬁnes the em-
bedding space where the distance-based classiﬁer operates.

For all transfer learning experiments, in order to avoid pre-
trained layers to quickly overﬁt the train set, ﬁne-tuning occurs at
a slower pace than training the classiﬁcation or embedding layer.
We use a learning rate of 0.00001 for the pre-trained layers, and a
learning rate of 0.1 for randomly initialized layers.

4. RESULTS

Fig. 1 summarizes the results we obtain for the two datasets consid-
ered in this work: US8K (ﬁrst row) and ASC-TUT (second row). On
the left-hand side, we compare the results of the regularized models
with the ones of prototypical networks. On the right-hand side, we
compare the results of transfer learning with the ones of prototypical
networks. For each study case, we depict a lower bound (random
guess) and an upper bound (previous works using all the train set,
see section 2.2). In addition, we include a basic baseline, consist-
ing of a nearest neighbor classiﬁer. All baselines and references are
depicted with dashed and dotted lines.

First of all, we elaborate on the results obtained by the standard
and regularized deep learning models, namely SB-CNN, VGG, and
TIMBRE (Fig. 1, left). All these models perform similarly when
few training data are available (n < 50). Even so, it is remarkable
the performance of the strongly-regularized TIMBRE model for the
US8K dataset, as this outperforms the other two and the MFCC base-
line when n ≤ 10. Notice, however, that the trend changes when
more data becomes avilable (n > 20). Under this data regime, the
expressive VGG model seems to better exploit the available data. Fi-
nally, it is also interesting to observe the limitations of the commonly
used deep learning pipeline when few training data are available, as
the SB-CNN and regularized models struggle to clearly outperform
a simple nearest-neighbor MFCC baseline for n ≤ 20.

In order to overcome the abovementioned limitations of standard
and regularized deep learning models, we investigate the use of pro-
totypical networks. Fig. 1 (left) depicts how they consistently out-
perform raw deep learning models, both for US8K and ASC-TUT.
Although performance gains are moderate for n < 5, prototypical
networks clearly outperform regularized models for 5 < n < 50
(raw results are available in Appendix A.4). Interestingly, though,
the performance of prototypical networks can saturate for n > 50,
as for US8K results. This suggests that prototypical networks may
not be as competitive as regular deep learning architectures when
sizable amounts of training data are available. However, such ten-
dency could be data-dependent, as it is not observed for ASC-TUT.
Note that the prototypical networks’ embedding space is deﬁned
by a larger VGG than the regularized VGG model. Hence, prototyp-
ical networks could seem to be more prone to overﬁtting than reg-
ularized models. However, we ﬁnd that prototypical networks do
generalize better than standard and regularized models in the low

Fig. 1. Accuracy (%) of the studied strategies when compared to prototypical networks. Dashed and dotted lines represent baselines, and
strong lines represent the considered strategies. For comparison, we repeat the curve for prototypical networks in both left and right plots.

data regime (Fig. 1, left). Since overﬁtting seems not to dramatically
affect prototypical networks’ results, we ﬁnd that highly expressive
models, like a large VGG, can deliver good results. We speculate that
this might be caused because the resulting latent space is competent
enough to discriminate each of the classes, whereas for smaller and
less expressive models this might not be the case.

In our study, we also investigate how transfer learning ap-
proaches compare with the previous solutions (Fig. 1, right). We
observe that, for n ≥ 10, transfer learning with basic ﬁne-tuning
performs equivalently to prototypical networks + transfer learning.
However, for n < 10, the former outperforms the latter. We spec-
ulate that this effect emerges when prototypes trained with small
data are not representative enough of their corresponding classes.
Remember that the support set to compute each class’ prototype is
conformed by 5 randomly selected patches from the train set. As
a result, for example, when n = 1 these 5 patches are sampled
from the same spectrogram and then reused for training fφ. Con-
sequently, the variety of the training examples used for computing
the prototypes can be very limited for n < 10, what might be harm-
ing the results of prototypical networks. Interestingly, though, for
n ≥ 10 we observe that prototypical networks + transfer learning
start performing equivalently to transfer learning with ﬁne-tuning.
Note that n = 10 is the ﬁrst scenario where prototypical networks
can be trained with data being variate enough, since 5 examples can
be used for computing the prototypes and 5 additional examples can
be used for training fφ (see section 3.2).

Finally, it is worth reminding that source and target tasks are
the same for US8K but are different for ASC-TUT. Possibly for that
reason, transfer learning consistently outperforms prototypical net-
works for US8K, but struggles to do so for ASC-TUT. For the latter
dataset, we see that prototypical networks (trained from scratch with
n ≤ 100 instances) are able to outperform transfer learning-based

approaches (pretrained with 2 M audios) for n > 20. This result
denotes that transfer learning has a strong potential when small data
are available (n ≤ 20). However, it can be easily overthrown by
prototypical networks if the number of training examples per class
becomes large enough, and target and source tasks do not match.

5. DISCUSSION

Among the strategies we have studied for training neural network
classiﬁers with few annotated audios, we have found prototypical
networks and transfer learning to be the ones providing the best re-
sults. However, choosing one or another might depend on the speci-
ﬁcities of the use case. Transfer learning-based classiﬁers are gen-
erally a good choice when operating in low-data regimes, but they
assume that a pre-trained model is readily available.
Importantly,
such model needs to be trained with data falling under a similar dis-
tribution to the few data samples we have available for solving the
task. Otherwise, there is no guarantee for transfer learning to de-
liver better results than, for instance, prototypical networks. When
data distributions do not match, we show that prototypical networks
trained from scratch can be the right choice.

In order to restrict ourselves to a realistic low-data scenario, our
results are computed without utilizing any validation set. As a re-
sult, the set of intuitions that generally help us deciding when to
stop training no longer hold. We have found early stopping to be a
valid approach when training regular deep learning classiﬁers. How-
ever, interestingly, we have found overﬁtting not to dramatically af-
fect prototypical networks’ results, possibly because these rely on a
robust distance-based classiﬁer. Since deciding in which epoch to
‘early-stop’ highly depends on many design choices, we have found
the ‘just overﬁt’ criteria of prototypical networks to be very simple
while delivering competitive results.

[17] Julius Kunze, Louis Kirsch, Ilia Kurenkov, Andreas Krug, Jens
Johannsmeier, and Sebastian Stober, “Transfer learning for
speech recognition on a budget,” in Workshop on Represen-
tation Learning for NLP, 2017.

[18] Keunwoo Choi, Gy¨orgy Fazekas, Mark Sandler,

and
Kyunghyun Cho, “Transfer learning for music classiﬁcation
and regression tasks,” ISMIR, 2017.

[19] Arnab Ghoshal, Pawel Swietojanski, and Steve Renals, “Mul-
tilingual training of deep neural networks,” in ICASSP, 2013.

[20] Jui-Ting Huang, Jinyu Li, Dong Yu, Li Deng, and Yifan Gong,
“Cross-language knowledge transfer using multilingual deep
neural network with shared hidden layers,” in ICASSP, 2013.

[21] Santiago Pascual, Maruchan Park, Joan Serr`a, Antonio Bona-
“Language and noise transfer
in

fonte, and Kang-Hun Ahn,
in speech enhancement generative adversarial network,”
ICASSP, 2018, pp. 5019–5023.

[22] Yusuf Aytar, Carl Vondrick, and Antonio Torralba, “Sound-
net: Learning sound representations from unlabeled video,” in
NIPS, 2016.

[23] Seongkyu Mun, Sangwook Park, David K Han, and Hanseok
Ko,
“Generative adversarial network based acoustic scene
training set augmentation and selection using svm hyper-
plane,” DCASE Workshop, 2017.

[24] Jake Snell, Kevin Swersky, and Richard Zemel, “Prototypical

networks for few-shot learning,” in NIPS, 2017.

[25] Sachin Ravi and Hugo Larochelle, “Optimization as a model

for few-shot learning,” ICLR, 2016.

[26] Oriol Vinyals, Charles Blundell, Tim Lillicrap, Daan Wierstra,
et al., “Matching networks for one shot learning,” in NIPS,
2016.

[27] Jane Bromley,

Isabelle Guyon, Yann LeCun, Eduard
S¨ackinger, and Roopak Shah, “Signature veriﬁcation using a”
siamese” time delay neural network,” in Advances in neural
information processing systems, 1994, pp. 737–744.

[28] Teuvo Kohonen, “The ’neural’ phonetic typewriter,” Com-

puter, vol. 21, no. 3, pp. 11–22, 1988.

[29] Annamaria Mesaros, Toni Heittola, Aleksandr Diment, Ben-
jamin Elizalde, Ankit Shah, Emmanuel Vincent, Bhiksha Raj,
and Tuomas Virtanen, “Dcase 2017 challenge setup: Tasks,
datasets and baseline system,” in DCASE Workshop, 2017.

[30] Yoonchang Han, Jeongsoo Park, and Kyogu Lee,

“Con-
volutional neural networks with binaural representations and
background subtraction for acoustic scene classiﬁcation,” the
Detection and Classiﬁcation of Acoustic Scenes and Events
(DCASE), pp. 1–5, 2017.

[31] Jordi Pons and Xavier Serra, “Randomly weighted CNNs for
(music) audio classiﬁcation,” arXiv:1805.00237, 2018.

6. REFERENCES

[1] Shawn Hershey, Sourish Chaudhuri, Daniel PW Ellis, Jort F
Gemmeke, Aren Jansen, R Channing Moore, Manoj Plakal,
Devin Platt, Rif A Saurous, Bryan Seybold, et al., “CNN ar-
chitectures for large-scale audio classiﬁcation,” in ICASSP,
2017.

[2] Justin Salamon and Juan Pablo Bello, “Deep convolutional
neural networks and data augmentation for environmental
sound classiﬁcation,” IEEE Signal Processing Letters, vol. 24,
no. 3, pp. 279–283, 2017.

[3] Jordi Pons, Olga Slizovskaia, Rong Gong, Emilia G´omez, and
Xavier Serra, “Timbre analysis of music audio signals with
convolutional neural networks,” in EUSIPCO, 2017.

[4] Jordi Pons, Oriol Nieto, Matthew Prockup, Erik M Schmidt,
Andreas F Ehmann, and Xavier Serra, “End-to-end learning
for music audio tagging at scale,” ISMIR, 2018.

[5] Eduardo Fonseca, Manoj Plakal, Frederic Font, Daniel P. W.
Ellis, Xavier Favory, Jordi Pons, and Xavier Serra, “General-
purpose tagging of freesound audio with audioset labels: task
description, dataset, and baseline,” arXiv:1807.09902, 2018.

[6] Eduardo Fonseca,

Jordi Pons, Xavier Favory, Frederic
Font Corbera, Dmitry Bogdanov, Andres Ferraro, Sergio Ora-
mas, Alastair Porter, and Xavier Serra, “Freesound datasets:
a platform for the creation of open audio datasets,” in ISMIR,
2017.

[7] Annamaria Mesaros, Toni Heittola, and Tuomas Virtanen, “Tut
database for acoustic scene classiﬁcation and sound event de-
tection,” in EUSIPCO, 2016.

[8] Justin Salamon, Christopher Jacoby, and Juan Pablo Bello, “A
in ACM-

dataset and taxonomy for urban sound research,”
Multimedia, 2014.

[9] Jort F Gemmeke, Daniel PW Ellis, Dylan Freedman, Aren
Jansen, Wade Lawrence, R Channing Moore, Manoj Plakal,
and Marvin Ritter, “Audio set: An ontology and human-labeled
dataset for audio events,” in ICASSP, 2017.

[10] Ivan Bocharov, A de Vries, and Tjalling Tjalkens, “K-shot
learning of acoustic context,” in NIPS Workshop on Machine
Learning for Audio Signal Processing, 2017.

[11] Bence Tilk, “Make SVM great again with siamese kernel for

few-shot learning,” Rejected ICLR submission, 2018.

[12] Veronica Morﬁ and Dan Stowell, “Deep learning for audio
arXiv:1807.03697,

transcription on low-resource datasets,”
2018.

[13] Veronica Morﬁ and Dan Stowell, “Data-efﬁcient weakly su-
pervised learning for low-resource audio event detection using
deep learning,” arXiv:1807.06972, 2018.

[14] Aren Jansen, Manoj Plakal, Ratheet Pandya, Daniel PW Ellis,
Shawn Hershey, Jiayang Liu, R Channing Moore, and Rif A
Saurous, “Unsupervised learning of semantic audio represen-
tations,” arXiv:1711.02209, 2017.

[15] Honglak Lee, Peter Pham, Yan Largman, and Andrew Y Ng,
“Unsupervised feature learning for audio classiﬁcation using
convolutional deep belief networks,” in NIPS, 2009.

[16] Yong Xu, Qiang Huang, Wenwu Wang, Peter Foster, Siddharth
Sigtia, Philip JB Jackson, and Mark D Plumbley, “Unsuper-
vised feature learning based on deep models for environmen-
tal audio tagging,” IEEE/ACM Transactions on Audio, Speech,
and Language Processing, vol. 25, no. 6, pp. 1230–1241, 2017.

A.1. Prototypical networks distance: Euclidean vs. cosine

A. APPENDIX

While previous researchers [25, 26] employed the cosine distance for few-shot learning, the original authors of prototypical networks found
the Euclidean distance to improve their results [24]. In the following, we study the impact of choosing one distance or another for the two
datasets considered in our work. We report the accuracy curves for protypical networks (trained from scratch) and prototypical networks
+ transfer learning when trained with different amounts of data. Fig. 2 (left) depicts US8K results, where we observe that Euclidean- and
cosine-based models perform equivalently. However, for n ≥ 20, cosine-based prototypical networks consistently achieve around 5% more
accuracy. Fig. 2 (right) depicts ASC-TUT results, where Euclidean- and cosine-based models perform similarly for n ≤ 10. However, for
n > 10, Euclidean-based models outperform cosine-based ones for a large margin. Consequently, for our experiments, we decide to utilize
Euclidean-based prototypical networks, like the original authors of prototypical networks [24].

Fig. 2. Accuracy (%) results comparing prototypical network-based models when using Euclidean or cosine distance.

A.2. Prototypical networks: Overﬁtting or generalization?

One particularly interesting outcome of our work is that prototypical networks can generalize although they explicitly overﬁt the train set. In
this section, we aim to provide further evidence of this behavior. To this end, we plot the evolution of the train set accuracy during training
(we measure train set accuracy in every epoch). For each dataset and prototypical networks-based model, we depict train set accuracy curves
when training with different amounts of data. These curves (Fig. 3) correspond to a single run and were randomly selected.

Fig. 3. Train set accuracy results (%) for prototypical networks-based models.

Although the test set results (depicted in Fig. 1) clearly show that prototypical networks can generalize, it is also manifest from the
train set results (depicted in Fig.3) that prototypical networks do overﬁt the train set. This effect is particularly notorious when prototypical
networks are trained from scratch (no transfer learning), as these tend to quickly overﬁt. In addition, note that the models trained with less
data (n = 1 or n = 2) tend to overﬁt quicker, as expected. This fact is particularly noticeable for prototypical networks + transfer learning
models, since the used initialization prevents them to quickly overﬁt. Consequently, the training curves for n = 1 and n = 2 are more visible.
In order to further exemplify this behavior, Fig. 4 depicts train set and test set accuracy curves when training for US8K and ASC-TUT
with different amounts of data. Train set accuracy curves clearly show how prototypical networks are overﬁtting the train set (they achieve
100% train set accuracy). However, interestingly, test set accuracy results do not decrease once overﬁtting starts. Although one would expect
its performance to decrease once overﬁtting occurs, we see that prototypical networks’ performance remains unaltered.

Fig. 4. Prototypical networks’ train set and test set accuracy results (%) when trained with different amounts of data (different n’s).

If no validation set is available, when to stop training?

The here described ‘overﬁtting effect’ of prototypical networks is particularly useful when only few data are available for training neural audio
classiﬁers. As a result of such data constraints, sometimes it can be difﬁcult to assume that a validation set is readily available. Consequently,
it might be hard to know when to stop training. However, as seen, prototypical networks can overﬁt the train set and still deliver sounding
results. For that reason, we propose to use the train set accuracy (measured every epoch) as a proxy to monitor how discriminative is the
embedding space, to stop training after the model does not improve its train set accuracy. Note, then, that a discriminative embedding capable
to separate all training examples is deﬁned by a model explicitly overﬁtting the train set. Which, accordingly, would achieve 100% train set
accuracy (a behavior that we repeatedly observe in Fig. 3 and Fig. 4). Although the stop condition we utilize is encouraging the model to
explicitly overﬁt the train set, prototypical networks can outperform the rest of the models on the test set (see Fig.1). Such robustness against
overﬁtting makes prototypical networks particularly convenient for use cases where no validation data is accessible.

In our work, we decided to stop training after the train set accuracy did not improve for 200 epochs. It is set to 200 for consistency
with the rest of the models, since these were trained for 200 epochs (see Section 3.1). However, note that for prototypical networks this
hyper-parameter is much more robust, as for any value greater than 50 results will remain equivalent (see test set accuracy results in Fig.4).

A.3. Negative result: Learning the logarithmic compression of the mel spectrogram

Currently, successful neural audio classiﬁers use log-mel spectrograms as input [1, 2, 3, 4]. Given a mel-spectrogram matrix X, the logarith-
mic compression is computed as follows: f (x) = log(α · X + β). Common pairs of (α, β) are (1, (cid:15)) [2], or (10000, 1) [4]. In this section,
we investigate the possibility of learning (α, β). To this end, we investigate two log-mel spectrogram variants:

• Log-learn: The logarithmic compression of the mel spectrogram X is optimized via SGD together with the rest of the parameters of
the model. We use exponential and softplus gates to control the pace of α and β, respectively. We set the initial pre-gate values to 7
and 1, what results in out-of-gate α and β initial values of 1096.63 and 1.31, respectively.

• Log-EPS: We set as baseline a log-mel spectrogram which does not learn the logarithmic compression. (α, β) are set to (1, (cid:15)), as done

by Salamon and Bello [2] for their SB-CNN model.

Tables 1 and 3 compare the results obtained by several models when varying the mel spectrogram compression: log-learn vs. log-EPS.
To clearly illustrate which are the performance gains obtained by log-learn, Tables 2 and 4 list the accuracy differences between log-learn and
log-EPS variants.

Prototypical
Prototypical
Net (log-learn) Net (log-EPS)

n
1
2
5
10
20
50
100

19.16%
25.85%
35.85%
44.90%
51.15%
60.39%
65.38%

SB-CNN
(log-learn)
19.84%
24.77%
32.85%
39.75%
45.03%
54.94%
60.34%

SB-CNN
(log-EPS)
18.29%
22.81%
29.89%
36.66%
42.34%
53.19%
60.43%

VGG
(log-learn)
18.27%
21.53%
26.48%
30.89%
32.04%
55.22%
64.65%

VGG
(log-EPS)
16.58%
22.03%
27.93%
32.40%
35.49%
58.62%
67.41%

TIMBRE
(log-learn)
21.27%
25.95%
34.02%
39.20%
42.38%
48.40%
50.14%

TIMBRE
(log-EPS)
18.97%
24.95%
34.20%
40.12%
37.70%
46.11%
49.57%

21.69%
30.02%
43.58%
51.14%
58.86%
62.14%
63.08%

Table 1. US8K dataset: accuracy results comparing log-EPS (standard log-mel spectrogram) & log-learn (learned log-mel spectrogram).

Prototypical
Networks
-2.53%
-4.17%
-7.73%
-6.24%
-7.71%
-1.75%
2.30%

n
1
2
5
10
20
50
100

TIMBRE
VGG
SB-CNN
2.30%
1.69%
1.55%
-0.50%
1.00%
1.96%
-1.45% -0.18%
2.96%
-1.51% -0.92%
3.09%
-3.45%
4.68%
2.69%
-3.40%
2.29%
1.75%
-0.09% -2.76%
0.57%

Table 2. US8K dataset: log-learn accuracy gains when compared to log-EPS.

Tables 1 and 2 reveal that log-lean and log-EPS results are almost identical for US8K. Although it seems that log-learn can help improving
the results for SB-CNN and TIMBRE architectures, for prototypical networks and VGG one can achieve worse results. For this reason, we
conclude that log-learn and log-EPS results are almost equivalent for US8K. However, for ASC-TUT dataset, log-learn results are much
worse than log-EPS ones. Tables 3 and 4 show that log-learn only improves the results of SB-CNN models when trained with little data
(1 ≤ n ≤ 10), but for the rest of the models the performance decreases substantially. Accordingly, we decide not to learn the logarithmic
compression of the mel spectrogram throughout our study.

Prototypical
Prototypical
Net (log-learn) Net (log-EPS)

n
1
2
5
10
20
50
100

19.94%
24.72%
31.77%
39.64%
43.28%
45.43%
47.70%

SB-CNN
(log-learn)
18.69%
21.34%
26.62%
30.22%
34.87%
45.27%
52.59%

SB-CNN
(log-EPS)
13.70%
18.08%
21.24%
27.81%
36.61%
52.32%
58.56%

VGG
(log-learn)
11.07%
11.54%
12.47%
13.71%
22.51%
37.14%
42.53%

VGG
(log-EPS)
17.01%
20.05%
20.36%
29.45%
44.58%
52.46%
57.71%

TIMBRE
(log-learn)
16.06%
19.72%
21.88%
24.17%
25.09%
31.66%
38.35%

TIMBRE
(log-EPS)
17.00%
20.21%
25.40%
27.74%
39.02%
46.61%
50.16%

18.16%
24.68%
35.36%
45.39%
53.78%
62.03%
67.78%

Table 3. ASC-TUT dataset: accuracy results comparing log-EPS (standard log-mel spectrogram) & log-learn (learned log-mel spectrogram).

Prototypical
Networks
1.78
0.04
-3.59
-5.70
-10.50
-16.60
-20.08

n
1
2
5
10
20
50
100

SB-CNN
4.99
3.26
5.38
2.41
-1.74
-7.05
-5.97

VGG
-5.94
-8.51
-7.89
-15.74
-22.07
-15.32
-15.18

TIMBRE
-0.94
-0.49
-3.52
-13.93
-13.93
-14.95
-11.81

Table 4. ASC-TUT dataset: log-learn accuracy gains when compared to log-EPS.

A.4. Raw accuracy results

Tables 5 and 6 list the raw accuracy results of the main ﬁgure of the paper (Fig. 1).

n
1
2
5
10
20
50
100

n
1
2
5
10
20
50
100

20.57%
23.03%
27.15%
31.40%
36.45%
40.89%
43.81%

26.33%
30.52%
33.31%
39.21%
41.99%
45.98%
48.66%

NN-MFCC SB-CNN

VGG
18.30% 16.58%
22.81% 22.03%
29.89% 27.94%
36.66% 32.41%
42.34% 35.49%
53.19% 58.62%
60.43% 67.41%

TIMBRE
18.98%
24.95%
34.21%
40.12%
37.70%
46.11%
49.57%

Prototypical
Net
21.69%
30.02%
43.58%
51.14%
58.86%
62.14%
63.08%

NN-Audioset
40.17%
46.00%
52.02%
56.91%
59.42%
62.85%
65.47%

Transfer learning
(ﬁne-tuning)
38.15%
48.44%
59.89%
63.81%
67.64%
71.95%
74.26%

Prototypical Net+
Transfer learning
31.48%
40.82%
54.61%
61.48%
67.07%
71.47%
73.28%

Table 5. US8K dataset: Fig.1 (top) raw results.

NN-MFCC SB-CNN

VGG
13.70% 17.01%
18.08% 20.05%
21.24% 20.36%
27.81% 29.45%
36.61% 44.58%
52.32% 52.46%
58.56% 57.71%

TIMBRE
17.00%
20.21%
25.40%
27.74%
39.02%
46.61%
50.16%

Prototypical
Net
18.16%
24.68%
35.36%
45.39%
53.78%
62.03%
67.78%

NN-Audioset
32.18%
39.58%
43.56%
49.09%
51.39%
54.28%
55.69%

Transfer learning
(ﬁne-tuning)
35.18%
40.13%
46.09%
50.53%
54.00%
58.79%
60.56%

Prototypical Net+
Transfer learning
24.25%
31.91%
44.41%
49.15%
53.09%
60.22%
60.39%

Table 6. ASC-TUT dataset: Fig.1 (bottom) raw results.

