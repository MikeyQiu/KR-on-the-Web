Learning to Find Good Correspondences

Kwang Moo Yi1,* Eduard Trulls 2,* Yuki Ono3 Vincent Lepetit4 Mathieu Salzmann2

Pascal Fua2

1Visual Computing Group, University of Victoria
4Institute for Computer Graphics and Vision, Graz University of Technology
3Sony Imaging Products & Solutions Inc.
kyi@uvic.ca, {firstname.lastname}@epfl.ch, yuki.ono@sony.com, lepetit@icg.tugraz.at

2Computer Vision Laboratory, ´Ecole Polytechnique F´ed´erale de Lausanne

8
1
0
2
 
y
a
M
 
1
2
 
 
]

V
C
.
s
c
[
 
 
2
v
1
7
9
5
0
.
1
1
7
1
:
v
i
X
r
a

Abstract

We develop a deep architecture to learn to ﬁnd good cor-
respondences for wide-baseline stereo. Given a set of pu-
tative sparse matches and the camera intrinsics, we train
our network in an end-to-end fashion to label the corre-
spondences as inliers or outliers, while simultaneously us-
ing them to recover the relative pose, as encoded by the
essential matrix. Our architecture is based on a multi-layer
perceptron operating on pixel coordinates rather than di-
rectly on the image, and is thus simple and small. We intro-
duce a novel normalization technique, called Context Nor-
malization, which allows us to process each data point sep-
arately while embedding global information in it, and also
makes the network invariant to the order of the correspon-
dences. Our experiments on multiple challenging datasets
demonstrate that our method is able to drastically improve
the state of the art with little training data.

1. Introduction

Recovering the relative camera motion between two im-
ages is one of the most basic tasks in Computer Vision, and
a key component of wide-baseline stereo and Structure from
Motion (SfM) pipelines. However, it remains a difﬁcult
problem when dealing with wide baselines, repetitive struc-
tures, and illumination changes, as depicted by Fig. 1. Most
algorithms rely on sparse keypoints [19, 2, 24] to establish
an initial set of correspondences across images, then try to
ﬁnd a subset of reliable matches—inliers—which conform
to a given geometric model, and use them to recover the
pose [11]. They rely on combinations of well-established
techniques, such as SIFT [19], RANSAC [10], and the 8-
point algorithm [18], which have been in use for decades.

With the advent of deep learning, there has been a push
towards reformulating local feature extraction using neural
networks [35, 26]. However, while these algorithms outper-

*First two authors contributed equally. K.M. Yi was at EPFL during
the development of this project. This work was partially supported by EU
FP7 project MAGELLAN under grant ICT-FP7-611526 and by systems
supplied by Compute Canada.

(a) RANSAC

(b) Our approach

Figure 1. We extract 2k SIFT keypoints from a challenging image
pair and display the inlier matches found with RANSAC (left) and
our approach (right). We draw them in green if they conform to
the ground-truth epipolar geometry, and in red otherwise.

form earlier ones on point-matching benchmarks, incorpo-
rating them into pose estimation pipelines may not neces-
sarily translate into a performance increase, as indicated by
two recent studies [25, 3]. This suggests that the limiting
factor may not lie in establishing the correspondences as
much as in choosing those that are best to recover the pose.
This problem has received comparatively little attention
and most algorithms still rely on non-differentiable hand-
crafted techniques to solve it. DSAC [4] is the only recent
attempt we know of to tackle sparse outlier rejection in a
differentiable manner. However, this method is designed to
mimic RANSAC rather than outperform it. Furthermore, it
is speciﬁc to 3D to 2D correspondences, rather than stereo.
By contrast, we propose a novel approach to ﬁnding geo-
metrically consistent correspondences with a deep network.
Given feature points in both images, and potential corre-
spondences between them, we train a deep network that
simultaneously solves a classiﬁcation problem—retain or
reject each correspondence—and a regression problem—
retrieving the camera motion—by exploiting epipolar con-
straints. To do so we introduce a differentiable way to com-

1

pute the pose through a simple weighted reformulation of
the 8-point algorithm, with the weights predicting the like-
lihood of a correspondence being correct. In practice, we
assume the camera intrinsics to be known, which is often
true because they are stored in the image meta-data, and ex-
press camera motion in terms of the essential matrix [11].

As shown in Fig. 2, our architecture relies on Multi Layer
Perceptrons (MLPs) that are applied independently on each
correspondence, rendering the network invariant to the or-
der of the input. This is inspired by PointNet [21], which
runs an MLP on each individual point from a 3D cloud and
then feeds the results to an additional network that gener-
ates a global feature, which is then appended to each point-
wise feature. By contrast, we simply normalize the distribu-
tion of the feature maps over all correspondences every time
they go through a perceptron. As the correspondences are
constrained by the camera motion, this procedure provides
context. We call this novel, non-parametric operation Con-
text Normalization, and found it simpler and more effective
than the global context features of [21] for our purposes.

Our method has the following advantages:

(i) it can
double the performance of the state of the art; (ii) be-
ing keypoint-based, it generalizes better than image-based
dense methods to unseen scenes, which we demonstrate
with a single model that outperforms current methods on
drastically different indoors and outdoors datasets; (iii) it
requires only weak supervision through essential matrices
for training; (iv) it can work effectively with very little train-
ing data, e.g., we can still outperform the state of the art on
challenging outdoor scenes with only 59 training images.

2. Related Work

Traditional handcrafted methods. The traditional ap-
proach for estimating the relative camera motion between
two images is to use sparse keypoints, such as SIFT [19],
to establish an initial set of correspondences, and reject out-
liers with RANSAC [10], using the 5-point algorithm [20]
or the 8-point algorithm [18] to retrieve the essential matrix.
Many works have focused on improving the outlier re-
jection step of this pipeline, i.e., RANSAC. MLESAC [29]
shows improvements when solving image geometry prob-
PROSAC [7] speeds up the estimation process.
lems.
USAC [22] combines multiple advancements together into a
uniﬁed framework. Least median of squares (LMEDS) [23]
is also commonly used to replace RANSAC. A comprehen-
sive study on this topic can be found in [6, 22]. In practice,
however, RANSAC still remains to be the de facto standard.
A major drawback of these approaches is that they rely
on small subsets of the data to generate the hypotheses, e.g.,
the 5-point algorithm considers only ﬁve correspondences
at a time. This is sub-optimal, as image pairs with large
baselines and imaging changes will contain a large percent-
age of outliers, thus making most of the hypotheses useless.

Figure 2. Our deep network takes N correspondences between two
2D points (4 × N values) as input, and produces one weight for
each correspondence, encoding its likelihood to be an inlier. Each
correspondence is processed independently by weight-sharing Per-
ceptrons (P), rendering the network invariant to permutations of
the input. Global information is embedded by Context Normaliza-
tion, a novel technique we detail in Section 3.2.

Recent works try to overcome this limitation by si-
multaneously rejecting outliers and estimating global mo-
tion. [17] assumes that global motion should be piece-wise
smooth. GMS [3] further exploits this assumption by di-
viding the image into multiple grids and forming initial
matches between the grid cells. Although they show im-
provements over traditional matching strategies, the piece-
wise smoothness assumption is often violated in practice.

Learning-based methods. Solving image correspon-
dence with deep networks has received a lot of interest re-
cently. In contrast with traditional methods, many of these
new techniques [32, 31, 37, 36] are dense, using the raw
image as input. They have shown promising results on con-
strained stereo problems, such as matching two frames from
a video sequence, but the general problem remains far from
solved. As evidenced by our experiments, this approach
can be harmful on scenes with occlusions or large baselines,
which are commonplace in photo-tourism applications.

Dense methods aside, DSAC [4] recently introduced a
differentiable outlier rejection scheme for monocular pose
estimation. However, it relies on a strategy to evaluate hy-
potheses that is particular to monocular pose estimation and
difﬁcult to extend to stereo. Furthermore, this technique
amounts to replacing RANSAC with a differentiable coun-
terpart for end-to-end training, which does not signiﬁcantly
improve the performance beyond RANSAC, as we do.

In [9], a dual architecture with separate networks for ex-
tracting sparse keypoints and forming the correspondences,
assuming a homography model, was proposed. Because of
its requirement for ground-truth annotations of object cor-
ners, this work was only demonstrated on synthetic, non-
realistic images. By contrast, our method only requires es-
sential matrices for training and thus, as demonstrated by
our experiments, is effective in real-world scenarios.

3. Method

Our goal is to establish valid and geometrically consis-
tent correspondences across images and use them to retrieve
the camera motion. We rely on local features, which can be

unreliable and require outlier rejection. Traditional methods
approach this problem by iteratively sampling small subsets
of matches, which makes it difﬁcult to exploit the global
context. By contrast, we develop a deep network that can
leverage all the available information in a single shot.

Speciﬁcally, we extract local features over two images,
create an overcomplete set of putative correspondences, and
feed them to the network depicted by Fig. 2. It assigns a
weight to each correspondence, which encodes their likeli-
hood of being an inlier. We further use it to set the inﬂuence
of each correspondence in a weighted reformulation of the
eight-point algorithm [18]. In other words, our method per-
forms joint inlier/outlier classiﬁcation and regression to the
essential matrix. The relative rotation and translation be-
tween cameras can then be recovered with a singular value
decomposition of the resulting essential matrix [11].

In the remainder of this section, we formalize the prob-
lem and describe the architecture of Fig. 2. We then refor-
mulate the eight-point algorithm for weighted correspon-
dences, and discuss our learning strategy with a hybrid loss.

3.1. Problem Formulation

Formally, let us consider a pair of images (I, I(cid:48)). We
extract local features (ki, fi)i∈[1,N ] from image I, where
ki = (ui, vi) contains keypoint locations, and fi is a vec-
tor encoding a descriptor for the image patch centered at
(ui, vi). The keypoint orientation and scale are used to ex-
tract these descriptors and discarded afterwards. Similarly,
we obtain (k(cid:48)
j)j∈[1,N (cid:48)] from I(cid:48), keeping N = N (cid:48) for
simplicity. Our formulation is thus amenable to traditional
features such as SIFT [19] or newer ones such as LIFT [35].
We then generate a list of N putative correspondences by
matching each keypoint in I to the nearest one in I(cid:48) based
on the descriptor distances. We denote this list as

j, f (cid:48)

More complex strategies [19, 5] could be used, but we
found this one sufﬁcient. As many traditional algorithms,
we use the camera intrinsics to normalize the coordinates to
[−1, 1], which makes the optimization numerically better-
behaved [11]. We discard the descriptors, so that the list of
N location quadruplets is the only input to our network.

As will be discussed in Section 3.3, it is straightforward
to extend the eight-point algorithm to take as input a set of
correspondences with accompanying weights

(2)

w = [w1, ..., wN ] ,
where wi ∈ [0, 1] is the score assigned to correspondence
qi, with wi = 0 standing for qi being an outlier. Then,
let g be a function that takes as input x and w and returns
the essential matrix E. Now, given a set of P image pairs
(Ik, I(cid:48)
k)k∈[1,P ] and their corresponding essential matrices
Ek, we extract the set of correspondences xk of Eq. (1),

and our problem becomes that of designing a deep network
that encodes a mapping f with parameters Φ, such that

∀ k , 1 ≤ k ≤ P , wk = fΦ (xk) ,
Ek ≈ g(xk, wk) .

(3)

3.2. Network Architecture

We now describe the network that implements the map-
ping of Eq. (3). Since the order of the correspondences is
arbitrary, permuting xk should result in an equivalent per-
mutation of wk = fΦ(xk). To achieve this, inspired by
PointNet [21], a deep network designed to operate on un-
ordered 3D point clouds, we exploit Multi-Layer Percep-
trons (MLP). As MLPs operate on individual correspon-
dences, unlike convolutional or dense networks, incorpo-
rating information from other perceptrons, i.e., the context,
is indispensable for it to work properly. The distinguishing
factor between PointNet and our method is how this is done.
In PointNet, the point-wise features are explicitly com-
bined by a separate network that generates a global con-
text feature, which is then concatenated to each point-wise
output. By contrast, as shown in Fig. 2, we introduce a
simple strategy to normalize the feature maps according to
their distribution, after every perceptron. This lets us pro-
cess each correspondence separately while framing it in the
global context deﬁned by the rest, which encodes camera
motion and scene geometry. We call this non-parametric
operation Context Normalization (CN).

i ∈ RCl

Formally, let ol

be the output of layer l for cor-
respondence i, where C l is the number of neurons in l. We
take the normalized version of ol
(ol

CN (cid:0)ol

(cid:1) =

i

i to be
i − µl)
σl

,

(4)

µl =

i , σl =
ol

1
N

N
(cid:88)

i=1

(cid:118)
(cid:117)
(cid:117)
(cid:116)

1
N

N
(cid:88)

i=1

(cid:0)ol

i − µl(cid:1)2

.

(5)

This operation is mechanically similar to other normal-
ization techniques [14, 1, 30], but is applied to a different di-
mension and plays a different role. We normalize each per-
ceptron’s output across correspondences, but separately for
each image pair. This allows the distribution of the feature
maps to encode scene geometry and camera motion, embed-
ding contextual information into context-agnostic MLPs.

By contrast, the other normalization techniques primar-
ily focus on convergence speed, with little impact on how
the networks operate. Batch Normalization [14] normalizes
the input to each neuron over a mini-batch, so that it follows
a consistent distribution while training. Layer Normaliza-
tion [1] transposes this operation to channels, thus being
independent on the number of observations for each neu-
ron. They do not, however, add contextual information to
the input. Batch Normalization assumes that every sample

x = [q1, ..., qN ] ,
i, v(cid:48)
qi = [ui, vi, u(cid:48)

i] .

where

(1)

follows the same global statistics, and reduces to subtracting
and dividing by ﬁxed scalar values at test time. Layer Nor-
malization is applied independently for each neuron, i.e., it
considers the features for one correspondence at a time.

More closely related is Instance Normalization [30],
which applies the same operation we do to full images to
normalize their contrast, for image stylization. However, it
is also limited to enhancing convergence, as in their appli-
cation context is already captured by spatial convolutions,
which are not amenable to the sparse data in our problem.

Note however that our technique is compatible with
Batch Normalization, and we do in fact use it to speed
up training. As shown in Fig. 2, our network is a 12-
layer ResNet [12], where each layer contains two sequential
blocks consisting of: a Perceptron with 128 neurons sharing
weights for each correspondence, a Context Normalization
layer, a Batch Normalization layer, and a ReLU. After the
last perceptron, we apply a ReLU followed by a tanh to
force the output in the range [0, 1). We use this truncated
tanh instead of, e.g., a sigmoid, so that the network can
easily output wi = 0 to completely remove an outlier.

3.3. Computing the Essential Matrix

We now deﬁne the function g of Eq. (3) that estimates the
essential matrix from a weighted set of correspondences.
If we are to integrate it into a Deep Learning framework,
it must be differentiable with respect to the weights. We
ﬁrst outline the 8-point algorithm [18] that tackles the un-
weighted scenario, and then extend it to the weighted case.

i, v(cid:48)

Traditional Formulation. Let x be a set of N correspon-
dences qi = [ui, vi, u(cid:48)
i]. When N ≥ 8, the essential ma-
trix E ∈ R3×3 can be computed by solving a singular value
problem [11] as follows. We construct a matrix X ∈ RN ×9
each row of which is computed from a different correspon-
dence and has the form [uu(cid:48), uv(cid:48), u, vu(cid:48), vv(cid:48), v, u(cid:48), v(cid:48), 1],
and we reorganize the coefﬁcients of E into a column vec-
tor Vec (E). This vector has to be the unit vector that
(cid:13)X(cid:62)X Vec (E)(cid:13)
minimizes (cid:107)X Vec (E)(cid:107), or equivalently (cid:13)
(cid:13).
Therefore, Vec (E) is the eigenvector associated to the
smallest eigenvalue of X(cid:62)X. Additionally, as the essen-
tial matrix needs to have rank 2, we ﬁnd the rank-2 matrix
ˆE that minimizes the Frobenius norm (cid:107)E − ˆE(cid:107)F [11].

Weighted reformulation.
In practice, the 8-point algo-
rithm can be severely affected by outliers and is used
in conjunction with an outlier rejection scheme.
In our
case, given the weights w produced by the network, we
can simply minimize (cid:13)
(cid:13) instead of
(cid:13)
(cid:13)X(cid:62)X Vec (E)(cid:13)
(cid:13), where diag is the diagonalization opera-
tor. This amounts to giving weight wi to the i-th row in X,
representing the contribution of the i-th correspondence.

(cid:13)X(cid:62) diag (w) X Vec (E)(cid:13)

Since X(cid:62) diag (w) X is symmetric, the function g that
computes Vec (E), and therefore E, from X is a self-adjoint

eigendecomposition, which has differentiable closed-form
solution with respect to w [15]. Note that g(x, w) only de-
pends on the inliers because any correspondence with zero
weight has strictly no inﬂuence on the result. To compute
the ﬁnal essential matrix ˆE, we follow the same procedure
as in the unweighted case, which is also differentiable.

3.4. Learning with Classiﬁcation and Regression

We train the network fΦ with a hybrid loss function

P
(cid:88)

k=1

L(Φ) =

(αLx(Φ, xk) + βLe(Φ, xk)) ,

(6)

where Φ are the network parameters and xk is the set of pu-
tative correspondences for image pair k. Lx is a classiﬁca-
tion loss aggregated over each individual correspondence,
and Le is a regression loss over the essential matrix, ob-
tained from the weighted 8-point algorithm of Section 3.3
with the weights produced by the network. α and β are the
hyper-parameters weighing the two loss terms.

Classiﬁcation loss Lx: rejecting outliers. Given a set of
N putative correspondences xk and their respective labels
yk = (cid:2)y1
(cid:3), where yi
k = 1 denotes
that the ith correspondence is an inlier, we deﬁne

k ∈ {0, 1} and yi

k, ..., yN
k

Lx(Φ, xk) =

kH (cid:0)yi
γi

k, S (cid:0)oi

k

(cid:1)(cid:1) ,

(7)

1
N

N
(cid:88)

i=1

where oi
k is the linear output of the last layer for the i-th
correspondence in training pair k, S is the logistic function
used in conjunction with the binary cross entropy H, and
γi
k is the per-label weight to balance positive and negative
examples.

To avoid exhaustive annotation, we generate the labels y
by exploiting the epipolar constraint. Given a point in one
image, if the corresponding point in the other image does
not lie on the epipolar line, the correspondence is spurious.
We can quantify this with the epipolar distance [11]

d(p, Ep(cid:48)) =

(cid:113)

(Ep)2

p(cid:48)T Ep
[1] + (Ep)2
[2]

,

(8)

where p = [u, v, 1]T and p(cid:48) = [u(cid:48), v(cid:48), 1]T indicate a pu-
tative correspondence between images I and I(cid:48) in homoge-
nous coordinates, and v[j] denotes the jth element of vec-
tor v. In practice, we use the symmetric epipolar distance
d(p, Ep(cid:48)) + d(p(cid:48), ET p), with a threshold of 10−2 in nor-
malized coordinates to determine valid correspondences.

Note that this is a weak supervisory signal because out-
liers can still have a small epipolar distance if they lie close
to the epipolar line. However, a fully-supervised labeling
would require annotating correspondences for every point
in both images, which is prohibitively expensive, or depth
data, which is not available in most scenarios. Our experi-
ments show that, in practice, weak supervision is sufﬁcient.

Figure 3. Matching pairs from our training sets. Left to right: ‘Buckingham’, ‘Notredame’, ‘Sacre Coeur’, ‘St. Peter’s’ and ‘Reichstag’,
from [28, 13]; and ‘Brown 1’ and ‘Harvard 1’ from [34] (please see the appendix for details). Note that we crop the images for presentation
purposes, but our algorithm is based on sparse correspondences and is thus not restricted in any way by image size or aspect ratio.

Regression loss Le: predicting the essential matrix.
The weak supervision applied by the classiﬁcation loss
proves robust in our experience, but it may still let outliers
in. We propose to improve it by using the weighted set of
correspondences to extract the essential matrix and penalize
deviations from the ground-truth. We therefore write
(cid:110)

(cid:107)E∗

k ± g (xk, wk)(cid:107)2(cid:111)

,

Le(Φ, xk) = min

(9)

where E∗
k is the ground-truth essential matrix, and g is the
function deﬁned in Section 3.3 that predicts an essential ma-
trix from a set of weighted correspondences. We have to
compute either the difference or the sum because the sign
of g(x, w) can be ﬂipped with respect to that of E∗. Note
that here we use the non-rank-constrained estimate of the
essential matrix E, instead of ˆE, as deﬁned in Section 3.3,
because minimizing Le already aims to get the correct rank.

Optimization. We use Adam [16] to minimize the loss
L(Φ), with a learning rate of 10−4 and mini-batches of 32
image pairs. The classiﬁcation loss can train accurate mod-
els by itself, and we observed that using the regression loss
early on can actually harm performance. We ﬁnd empiri-
cally that setting α = 1 and enabling the regression loss
after 20k batches with β = 0.1 works well. This allows us
to increase relative performance by 5 to 20%.

3.5. RANSAC at Test Time

The loss function must be differentiable with respect to
the network weights. However, this requirement disappears
at test time. We can thus apply RANSAC on the correspon-
dences labeled as inliers by our network to weed out any
remaining outliers. We will show that this performs much
better stand-alone RANSAC, which conﬁrms our intuition
that sampling is a sub-optimal way to approach “needle-in-
the-haystack” scenarios with a large ratio of outliers.

4. Experimental Results

We ﬁrst present the datasets and evaluation protocols,
and then justify our implementation choices. Finally, we
benchmark our approach against state-of-the-art techniques.

4.1. Datasets

Sparse feature matching is particularly effective in out-
door scenes, and we will see that this is where our approach
shines. By contrast, keypoint-based methods are less suit-
able for indoor scenes. Nevertheless, recent techniques have
tackled this problem, and we show that our approach still
outperforms the state of the art in this scenario.

Outdoor scenes. To evaluate our method in outdoor set-
tings, we aim to leverage many images featuring similar
scenes seen from different viewpoints. As such, photo-
tourism datasets are natural candidates. We rely on Ya-
hoo’s YFCC100M dataset [28], a collection of 100 mil-
lion publicly accessible Flickr images with accompanying
metadata, which were later curated [13] into 72 image col-
lections suitable for Structure from Motion (SfM). We pick
ﬁve sequences, depicted in Fig. 3. We use VisualSFM [33]
to recover the camera poses and generate the ground-truth.
We also consider the ‘Fountain’ and ‘HerzJesu’ se-
quences from [27]. They are very small and we only use
them for testing, to show that our networks trained on
photo-tourism datasets can successfully generalize.

Indoor scenes. We use the SUN3D dataset [34], which
comprises a series of indoor videos captured with a Kinect,
with 3D reconstructions. They feature ofﬁce-like scenes
with few distinctive features, many repetitive elements, and
substantial self-occlusions, which makes them extremely
challenging for sparse keypoint methods. We select 9 se-
quences for training and testing, and use 15 sequences pre-
viously chosen by [31] for testing only, to provide a fair
comparison. We subsample the videos by a factor of 10.

For every sequence we train on, we randomly split the
images into disjoint subsets for training (60%), validation
(20%) and test (20%). To select valid image pairs on the
‘Outdoors’ subset, we sample two images randomly and
check if they have a minimum number of 3D points in com-
mon from the SfM reconstruction, indicating that the prob-
lem is solvable. For the ‘Indoors’ set, we use the depth maps
to determine visibility. We use 1k image pairs for validation
and testing, and as many as possible for training.

Figure 4. mAP for multiple error thresholds and number of key-
points, using the four optimization strategies of Section 4.3.1.

4.2. Evaluation Protocols

Keypoint-based methods. They include well-established
and
algorithms, RANSAC [10], MLESAC [29],
LMEDS [23], as well as the very recent GMS [3].
For GMS, we incorporate an additional RANSAC step
as described for our method in Section 3.5, which we
empirically found mandatory to obtain good performance.
Note that GMS operates with a large (10k) pool of ORB
features [24], and thus behaves similarly to dense methods.
For all others, ours included, we evaluate both SIFT [19]
and LIFT [35] features. For SIFT we use the OpenCV li-
brary, and for LIFT the publicly available models, which
were trained on photo-tourism data different from ours.
Dense methods. We consider G3DR [36] and De-
MoN [31]. For G3DR, we implement their architecture and
train it using only the pose component of their loss function,
as they argue that pose estimation is more accurate without
the classiﬁcation loss [36]. For DeMoN, we use the publicly
available models, which were trained on SUN3D sequences
and on SfM reconstructions of outdoors sets.

Metrics. Given two images, it is possible to estimate rota-
tion exactly—in theory—and translation only up to a scale
factor [11]. We thus use the angular difference between the
estimated and ground-truth vectors, i.e., the closest arc dis-
tance, in degrees, for both, as our error metric. We do so as
follows. First, we generate a curve by classifying each pose
as accurate or not, i.e. we compute the precision, given a
threshold (0 to 180o), and build a normalized cumulative
curve as in [8, 3]. Second, we compute the area under this
curve (AUC) up to a maximum threshold of 5, 10 or 20o,
because after a point it does not matter how inaccurate pose
estimates are. As the curve measures precision, its AUC is
equivalent to mean average precision (mAP). We apply the
same threshold over rotation and translation, for simplicity.

4.3. Ablation Study

At the heart of our approach are two key ideas: to la-
bel the correspondences as inliers or outliers while simul-

Figure 5. mAP for multiple error thresholds and number of key-
points, comparing PointNet with our approach, with and without
Context Normalization (CN), as explained in Section 4.3.2.

taneously using them to estimate the essential matrix, and
to leverage a PointNet-like architecture, replacing its global
context feature with our Context Normalization, introduced
in Section 3.2. We examine the impact of these two choices.

4.3.1 Hybrid Approach vs Classiﬁcation vs Regression

To show the beneﬁts of our hybrid approach, we compare
four different settings of our algorithm:

• Ours: Our complete formulation with α and β in
Eq. (6) set to 1 and 0 initially and then to 1 and 0.1
after 20k batches. In other words, we ﬁrst seek to as-
sign reasonable weights to the correspondences before
also trying to make the essential matrix accurate.

• Essential: We disable the classiﬁcation loss by setting
α = 0 and β = 1 in Eq. (6). This amounts to direct
regression from correspondences to the essential ma-
trix by assigning weights to the correspondences and
performing least-squares ﬁtting.

• Classiﬁcation: We disable the essential loss, setting
α = 1 and β = 0 in Eq. (6). The network then tries to
classify correspondences into inliers and outliers.

• Direct: We regress the essential matrix directly by
average-pooling the output of our last ResNet block
and adding a fully-connected layer that outputs nine
values, which we take to be the output of g in Eq. (9).
In other words, we directly predict the coefﬁcients of
the essential matrix without resorting to a weighted
version of the 8-point algorithm, as in Essential.

We ran these four variants on the ‘Sacre Coeur’ collection
from YFCC100M, using SIFT keypoints, and report the re-
sults in Fig. 4. Essential and Direct, which do direct re-
gression without classiﬁcation, perform worse than Classi-
ﬁcation, as long as the number of keypoints is sufﬁcient.
Ours outperforms all the others by combining both classi-
ﬁcation and regression, by a margin of 12-24%. Note that

Figure 6. Results on known scenes: ‘Outdoors’ (left) and ‘Indoors’ (right). We split the images for each set with 60% for training, 20% for
validation and 20% for testing, and report results over 1000 image pairs (or every possible combination for smaller sets) for the test split.
We mark DeMoN with an asterisk as we use the pre-trained models provided by the authors.

Figure 7. Generalization results with models trained and tested on different scenes: ‘Outdoors’ (left) and ‘Indoors’ (right). We train a single
model combining one sequence from the ‘Indoors’ set and one from the ‘Outdoors’ set. For ‘Outdoors’, we test on every other available
sequence and average the results. For ‘Indoors’, we test on the 15 sequences chosen by [31] for this purpose and average the results.

the difference is larger for smaller error thresholds, suggest-
ing that both Essential and Direct are learning the general
trend of the dataset without providing truly accurate poses.

4.3.2 Context Normalization vs Context Feature

For comparison purposes, we reformulate our approach us-
ing the PointNet architecture [21]. The speciﬁcity of Point-
Net is that it extracts a global context feature from the input
features, which is then concatenated to each individual fea-
ture and re-injected into the network. By contrast, we sim-
ply embed it into each point-wise feature through Context
Normalization. For a fair comparison, we use an architec-
ture of similar complexity to ours, with 12 MLPs each for
the extraction of point features, global features, and the ﬁnal
output. We replace max pooling by average pooling to ex-
tract the global feature, which gave better results. We refer
to this architecture as PointNet, and train it using the hybrid
loss of Eq. (6), as we do for Ours. For completeness, we
also try our approach without Context Normalization.

We report results on the ‘Sacre Coeur’ sequence in
Fig. 5. In all three cases, we present results without and with
the ﬁnal RANSAC stage of Section 3.5. As expected, our
approach without Context Normalization performs poorly,
whereas, with it, it does much better than PointNet.

4.4. Post-processing with RANSAC

Note that traditional keypoint-based methods do not
work at all without RANSAC. By contrast, our network
outperforms RANSAC in a single forward pass, using only
the 8-point algorithm. However, at test time we can drop
the differentiability constraints, as explained in Section 3.5,
and apply RANSAC on our surviving inliers to further boost
performance. We do this for the remainder of this paper.

Moreover, our method is much faster than stand-alone

RANSAC because it can throw away most bad matches in a
single step. Given 2k matches, a forward pass through our
network takes 13 ms on GPU (or 25 ms on CPU) and returns
on average ~300 inliers—RANSAC then removes a further
~100 matches in 9 ms. By contrast, a RANSAC loop with
the full 2k matches needs 373 ms and returns ~300 inliers.
Our method, including RANSAC, is thus not only more ac-
curate but also 17x faster (please refer to the supplementary
material for comprehensive numbers).

4.5. Comparison to the Baselines

We now turn to comparing our method against the base-
lines discussed above. Given the results presented in Sec-
tion 4.3, we use Ours with context normalization turned
on, and apply RANSAC post-processing to all of the sparse
methods. We average the results over multiple sets—please
refer to the supplementary material for additional results.

We ﬁrst consider networks trained and tested on images
from the same scene, and then on different scenes. Note that
we split the images into disjoint sets for training an testing,
as explained in Section 4.1, so there is no overlap between
both sets in either case. For keypoint-based methods other
than GMS, we consider both SIFT and LIFT.

4.5.1 Performance on Known Scenes

the 5 collections of outdoor

Consider
images from
YFCC100M and the 9 indoor sequences from SUN3D, de-
scribed in Section 4.1 and depicted by Fig. 3. We report our
comparative results in Figs. 6 and 8. The training and test
sets are always disjoint, but drawn from the same collection.
For the ﬁve ‘Outdoors’ collections, whose images are
feature-rich, we achieve our best results using LIFT fea-
tures trained on photo-tourism datasets. Ours then delivers
an mAP that is more than twice that of previous state-of-the-

Figure 8. Matches from (top) GMS with 10k ORB features, (middle) RANSAC, and (bottom) our approach, with the same 2k SIFT
features. Matches are in green if their symmetric epipolar distance in normalized coordinates is below 0.01, and red otherwise.

art methods. However, even when using the more popular
SIFT, it still outperforms the other methods. Furthermore,
the gap grows wider for small error thresholds, indicating
that our approach performs better the more strict we are.

By contrast, the two ‘Indoors’ collections feature poorly
textured images with repetitive patterns, static environ-
ments, and consistent scales, which makes them ill-suited
for keypoint-based methods and more amenable to dense
methods. Nevertheless, our method signiﬁcantly outper-
forms all compared methods, including dense ones. On
these images, Ours performs better with SIFT than LIFT,
which is consistent with the fact that LIFT was trained on
photo-tourism images. Note that for the numbers reported
in Fig. 6 for DeMoN, we used their pre-trained models as it
is not possible to re-train it due to the lack of depth infor-
mation for the ‘Outdoors’ data. Note also that their training
sets include not one but many sequences from SUN3D [31].

4.5.2 Generalization to Unknown Scenes

Here, we evaluate the generalization capability of our
method by training and testing on different scenes. Fig. 7
reports results for the model trained with the combination
of the ‘Saint Peter’s’ sequence from ‘Outdoors’ and the
‘Brown 1’ sequence from ‘Indoors’. For ‘Outdoors’ we re-
port the average result for all sets excluding ‘Saint Peter’s’.
For ‘Indoors’, we report the average result for the 15 test-
only sequences selected by [31], for fair comparison.

We outperform all baselines on ‘Outdoors’ by a signif-
icant margin. Comparing Figs. 6 and 7 shows that our

models generalize very well to unknown scenes. Note that
the jump in the performance of several baselines between
Figs. 6 and 7 is solely due to the addition of two easy se-
quences, ‘Fountain’ and ‘Herzjesu’, for testing in Fig. 7.

On ‘Indoors’ we outperform the state of the art by a small
margin and lose some generalization power, probably lim-
ited by the capabilities of SIFT and LIFT for indoor scenes.
Nevertheless, we outperform the state of the art on both
subsets with a single model trained on only 2000 outdoors
and 500 indoors images and tested on completely different
scenes. Further results are given in the supplementary ma-
terial, where we show that we can still outperform the state
of the art with much smaller training sets, e.g., 59 images.

5. Conclusion

We have proposed a single-shot technique to recover the
relative motion between two images with a deep network.
In contrast with current trends, our method is sparse, in-
dicating that keypoint-based robust estimation can still be
relevant in the age of dense, black-box formulations. Our
approach outperforms the state of the art by a signiﬁcant
margin with few images and limited supervision.

Our solution requires known intrinsics. In the future, we
plan to investigate using the fundamental matrix instead of
the essential. While the formalism would remain largely
unchanged, we expect numerical stability problems in the
regression component of the hybrid loss, which may require
additional normalization layers or regularization terms.

References

[1] J. Ba, J. Kiros, and G. Hinton. Layer Normalization. arXiv

preprint arXiv:1607.06450, 2016. 3

[2] H. Bay, A. Ess, T. Tuytelaars, and L. Van Gool. SURF:
Speeded Up Robust Features. CVIU, 10(3):346–359, 2008.
1

[3] J. Bian, W. Lin, Y. Matsushita, S. Yeung, T. Nguyen, and
M. Cheng. GMS: Grid-Based Motion Statistics for Fast,
Ultra-Robust Feature Correspondence. In CVPR, 2017. 1,
2, 6

[4] E. Brachmann, A. Krull, S. Nowozin, J. Shotton, F. Michel,
DSAC – Differentiable

S. Gumhold, and C. Rother.
RANSAC for Camera Localization. ARXIV, 2016. 1, 2
[5] M. Cho, J. Sun, O. Duchenne, and J. Ponce. Finding Matches
in a Haystack: A Max-Pooling Strategy for Graph Matching
in the Presence of Outliers. In CVPR, 2014. 3

[6] S. Choi, T. Kim, and W. Yu. Performance Evaluation of

RANSAC Family. In BMVC, 2009. 2

[7] O. Chum and J. Matas. Matching with Prosac - Progressive
Sample Consensus. In CVPR, pages 220–226, June 2005. 2
[8] A. Crivellaro, M. Rad, Y. Verdie, K. Yi, P. Fua, and V. Lep-
etit. Robust 3D Object Tracking from Monocular Images
Using Stable Parts. PAMI, 2017. 6

[9] D. Detone, T. Malisiewicz, and A. Rabinovich. Toward
Geometric Deep SLAM. arXiv preprint arXiv:1707.07410,
2009. 2

[10] M. Fischler and R. Bolles. Random Sample Consensus:
A Paradigm for Model Fitting with Applications to Im-
age Analysis and Automated Cartography. Communications
ACM, 24(6):381–395, 1981. 1, 2, 6

[11] R. Hartley and A. Zisserman. Multiple View Geometry in
Computer Vision. Cambridge University Press, 2000. 1, 2,
3, 4, 6

[12] K. He, X. Zhang, S. Ren, and J. Sun. Deep Residual Learning

for Image Recognition. In CVPR, pages 770–778, 2016. 4

[13] J. Heinly, J. Schoenberger, E. Dunn, and J.-M. Frahm. Re-

constructing the World in Six Days. In CVPR, 2015. 5, 10

[14] S. Ioffe and C. Szegedy. Batch Normalization: Accelerat-
ing Deep Network Training by Reducing Internal Covariate
Shift. In ICML, 2015. 3

[15] C. Ionescu, O. Vantzos, and C. Sminchisescu. Matrix
backpropagation for Deep Networks with Structured Layers.
2015. 4, 13

[16] D. Kingma and J. Ba. Adam: A Method for Stochastic Opti-

misation. In ICLR, 2015. 5

[17] W.-Y. Lin, M.-M. Cheng, J. Lu, H. Yang, M. Do, and P. Torr.
Bilateral Functions for Global Motion Modeling. In ECCV,
2014. 2

[18] H. Longuet-Higgins. A Computer Algorithm for Recon-
structing a Scene from Two Projections. Nature, 293:133–
135, 1981. 1, 2, 3, 4

[19] D. Lowe. Distinctive Image Features from Scale-Invariant

Keypoints. IJCV, 20(2), 2004. 1, 2, 3, 6

[20] D. Nister. An Efﬁcient Solution to the Five-Point Relative

Pose Problem. In CVPR, June 2003. 2

[21] C. Qi, H. Su, K. Mo, and L. Guibas. Pointnet: Deep Learning
on Point Sets for 3D Classiﬁcation and Segmentation.
In
CVPR, 2017. 2, 3, 7

[22] R. Raguram, O. Chum, M. Pollefeys, J. Matas, and J.-M.
Frahm. USAC: A Universal Framework for Random Sample
Consensus. PAMI, 35(8):2022–2038, 2013. 2

[23] P. Rousseeuw and A. Leroy. Robust Regression and Outlier

Detection. Wiley, 1987. 2, 6

[24] E. Rublee, V. Rabaud, K. Konolidge, and G. Bradski. ORB:
An Efﬁcient Alternative to SIFT or SURF. In ICCV, 2011.
1, 6

[25] J. L. Sch¨onberger, H. Hardmeier, T. Sattler, and M. Pollefeys.
Comparative Evaluation of Hand-Crafted and Learned Local
Features. In CVPR, 2017. 1

[26] E. Simo-serra, E. Trulls, L. Ferraz, I. Kokkinos, P. Fua, and
F. moreno-noguer. Discriminative Learning of Deep Convo-
lutional Feature Point Descriptors. In ICCV, 2015. 1
[27] C. Strecha, W. Hansen, L. Van Gool, P. Fua, and U. Thoen-
nessen. On Benchmarking Camera Calibration and Multi-
View Stereo for High Resolution Imagery. In CVPR, 2008.
5, 10

[28] B. Thomee, D. Shamma, G. Friedland, B. Elizalde, K. Ni,
D. Poland, D. Borth, and L. Li. YFCC100M: the New Data
in Multimedia Research. In CACM, 2016. 5, 10

[29] P. Torr and A. Zisserman. MLESAC: A New Robust Estima-
tor with Application to Estimating Image Geometry. CVIU,
78:138–156, 2000. 2, 6

[30] D. Ulyanov, A. Vedaldi, and V. Lempitsky. Instance Normal-
ization: the Missing Ingredient for Fast Stylization. arXiv
Preprint, 2016. 3, 4

[31] B. Ummenhofer, H. Zhou, J. Uhrig, N. Mayer, E. Ilg,
A. Dosovitskiy, and T. Brox. Demon: Depth and Motion
Network for Learning Monocular Stereo. In CVPR, 2017. 2,
5, 6, 7, 8, 10

[32] S. Vijayanarasimhan, S. Ricco, C. Schmid, R. Sukthankar,
and K. Fragkiadaki. Sfm-Net: Learning of Structure and
Motion from Video. arXiv Preprint, 2017. 2

[33] C. Wu. Towards Linear-Time Incremental Structure from

Motion. In 3DV, 2013. 5

[34] J. Xiao, A. Owens, and A. Torralba. SUN3D: A Database of
Big Spaces Reconstructed Using SfM and Object Labels. In
ICCV, 2013. 5, 10

[35] K. Yi, E. Trulls, V. Lepetit, and P. Fua. LIFT: Learned In-

variant Feature Transform. In ECCV, 2016. 1, 3, 6

[36] A. R. Zamir, T. Wekel, P. Agrawal, J. Malik, and S. Savarese.
Generic 3D Representation via Pose Estimation and Match-
ing. In ECCV, 2016. 2, 6, 11

[37] T. Zhou, M. Brown, N. Snavely, and D. Lowe. Unsupervised
Learning of Depth and Ego-Motion from Video. In CVPR,
2017. 2

A. Supplementary Appendix for “Learning to Find Good Correspondences”

A.1. Dataset details

Here we detail the sequences used for training and testing in Table A.1. The image numbers reported for SUN3D [34]
are after subsampling the video sequences by a factor of 10. For SUN3D we choose 9 sequences for training, and use the
15 sequences previously used by [31], collectively marked with ‡, only for testing. We generate disjoint training, validation
and test subsets by splitting the images in each set in a 60-20-20 ratio, as explained in Section 4.1. For ‡ we take up to 500
images with a 0-0-100 ratio, as we do not train any model on them.

The last column assigns a label (a-u) to each set for convenience, which is used in Section A.3. Our best model is trained

concatenating the datasets marked with ♦ and (cid:52).

Yahoo YFCC100M [28, 13]

Images

3D points Avg. views

Label

152003
502017
152594
235668
19881

11.83
35.41
19.63
26.96
7.74

Scene

‘Buckingham’
‘Notre Dame’
‘Sacre Coeur’
‘Saint Peter’s’
‘Reichstag’

‘Fountain’
‘HerzJesu’

Multi-View Stereo [27]

SUN3D [34] (training and validation)

‘Harvard 1’ (harvard conf big/hv conf big 1)
‘Harvard 2’ (harvard computer lab/hv c1 1)
‘Harvard 3’ (harvard corridor lounge/hv lounge corridor2 1)
‘Harvard 4’ (harvard corridor lounge/hv lounge corridor3 whole floor)
‘Brown 1’ (brown bm 3/brown bm 3)
‘Brown 2’ (brown cs 4/brown cs4)
‘Hotel 1’ (hotel ucla ant/hotel room ucla scan1 2012 oct 05)
‘Hotel 2’ (hotel pedraza/hotel room pedraza 2012 nov 25)
‘Home’ (home pt/home pt scan1 2012 oct 19)

SUN3D [34] (test only, chosen by [31]) (‡)

hotel florence jx/florence hotel stair room all

brown cogsci 2/brown cogsci 2

brown cogsci 6/brown cogsci 6

brown cogsci 8/brown cogsci 8

brown cs 3/brown cs3

brown cs 7/brown cs7

harvard c4/hv c4 1

harvard c10/hv c10 2

harvard corridor lounge/hv lounge1 2

harvard robotics lab/hv s1 2

mit 32 g725/g725 1

mit 46 6conf/bcs floor6 conf 1

mit 46 6lounge/bcs floor6 long

mit w85g/g 0

mit w85h/h2 1

Table 1. Datasets.

1676
3767
1179
2506
75

11
8

455
543
540
629
841
877
1305
1065
2407

259
500
126
340
251
500
224
81
154
159
377
327
500
387
500

–
–

–
–
–
–
–
–
–
–
–

–
–
–
–
–
–
–
–
–
–
–
–
–
–
–

a
b
c
♦
d

e
f

–
–
–
–
(cid:52)
–
–
–
–

g
h
i
j
k
l
m
n
o
p
q
r
s
t
u

–
–

–
–
–
–
–
–
–
–
–

–
–
–
–
–
–
–
–
–
–
–
–
–
–
–

Figure 9. Results for the model trained and tested on ‘Reichstag’.

Figure 10. Results for the model trained on ‘Reichstag’ (d), and tested on every other ‘Outdoors’ sequence, i.e., a-c, e, f and ♦. We average
the results over each sequence.

A.2. Training with limited data

Due to space constraints, the paper only reports results with our best model, which is the concatenation of ‘St. Peter’s’ (♦)
and ‘Brown 1’ ((cid:52)). Here we replicate the experiments of Section 4.5.1 and Section 4.5.2, i.e., we train a model and evaluate
it ﬁrst on the same sequence and then on every other ‘Outdoors’ sequence, respectively, but now using only our smallest
training sequence. The dataset in question is ‘Reichstag’ (d) from the ‘Outdoors’ subset, which contains only 59 images for
training, 8 for validation and 8 for testing. Note that after accounting for visibility constraints, this still lets us extract over
1500 image pairs for training and about 35 for each validation and testing.

Fig. 9 shows results training and testing on (different subsets of) the same sequence, and Fig. 10 shows how the model
generalizes over every ‘Outdoors’ sequence other than itself, i.e., a-c, e, f, and ♦. We follow the same protocols as in
Section 4.5.1 and Section 4.5.2. The best results are obtained with LIFT features, which is consistent with our previous
observations. Our method outperforms all the baselines, with LIFT plus RANSAC and GMS plus RANSAC being the closest
competitors. More importantly, when generalizing to other scenes with so little training data (Fig. 10) we still outperform
GMS by 65%-200% relative at different error thresholds, and RANSAC by about 50% relative.

A.3. Per-sequence results

We could not show per-sequence results in the paper due to space constraints. Fig. 11 provides separate results for every
testing sequence for our approach and for every baseline at multiple error thresholds. Again, we use our models trained on
a single sequence from each data type, marked respectively with ♦ and (cid:52) (we do the same for G3DR [36]). The sequences
used for testing include ‘Outdoors’ datasets a-f in Table A.1, which are averaged in the column marked ∗, and ‘Indoors’
datasets g-u, which are averaged in ‡. We provide numbers on top of the bars for ∗ and ‡. Our approach outperforms every
baseline, with LIFT performing better than SIFT on the ‘Outdoors’ subset and the opposite for the ‘Indoors’ subset.

Note that DeMoN only achieves good performance for e and f in the ‘Outdoors’ sequences, and completely fails for
YFCC100M sequences. G3DR shows even worse performance, hinting that sparse methods are preferable when it comes to
photo-tourism datasets.

A.4. Ransac post-processing

As outlined in 4.4, RANSAC for post-processing allows us to greatly improve both the performance and the speed over
RANSAC. In Table A.4 we provide results for the generalization experiments of Section 4.5.2, for stand-alone RANSAC,

Figure 11. Results for every sequence in the ‘Outdoors’ subset (a-f) and the ‘Indoors’ subset (g-u). The entry labeled ∗ denotes the average
performance over the ‘Outdoors’ subset, and ‡ the average performance over the ‘Indoors’ subset. Labels are listed in Table A.1.

and our method using either the 8-point algorithm or RANSAC for post-processing, which were not originally included in
the paper due to spatial constraints. Note that this boost is only possible at test time, due to the differentiability requirement
for training.

RANSAC

Ours + 8-point

mAP@20o

mAP@20o
w.r.t. RANSAC

mAP@20o

Outdoors

Indoors

SIFT

0.221

LIFT

0.291

SIFT

0.097

LIFT

0.115

Average

—

0.264
0.148
+19.5% +17.9% +52.6% +24.3% +28.6%

0.143

0.343

—

Ours + RANSAC

w.r.t. RANSAC +109.0% +82.1% +149.5% +93.0% +108.4%

0.462

0.530

0.242

0.222

—

Table 2. RANSAC vs Ours with 8-point vs Ours with RANSAC. Both SIFT and LIFT use 2k keypoints.

A.5. Differentiating through eigendecomposition

To differentiate through the eigendecomposition, we rely on the TensorFlow implementation. Here, we provide a short
deﬁnition for completeness. For more details, we refer the interested readers to [15]. In [15], it is shown that for a matrix
X, which can be decomposed into X = UΣU(cid:62), where U is the matrix of eigenvectors and Σ is a diagonal matrix with
eigenvalues, the derivative w.r.t. the eigenvectors are

where Msym = 1

2 (M(cid:62) + M), and

and σi is the i-th eigenvalue.

dU = 2U (cid:0)K (cid:12) (U(cid:62)dXU)sym

(cid:1) ,

Kij =

(cid:40) 1

σi−σj
0,

,

i (cid:54)= j

,

i = j

(10)

(11)

