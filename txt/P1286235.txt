Online and Linear-Time Attention by Enforcing Monotonic Alignments

7
1
0
2
 
n
u
J
 
9
2
 
 
]

G
L
.
s
c
[
 
 
2
v
4
8
7
0
0
.
4
0
7
1
:
v
i
X
r
a

Colin Raffel 1 Minh-Thang Luong 1 Peter J. Liu 1 Ron J. Weiss 1 Douglas Eck 1

Abstract

Recurrent neural network models with an atten-
tion mechanism have proven to be extremely
effective on a wide variety of sequence-to-
sequence problems. However, the fact that soft
attention mechanisms perform a pass over the
entire input sequence when producing each el-
ement in the output sequence precludes their use
in online settings and results in a quadratic time
complexity. Based on the insight that the align-
ment between input and output sequence ele-
ments is monotonic in many problems of interest,
we propose an end-to-end differentiable method
for learning monotonic alignments which, at test
time, enables computing attention online and in
linear time. We validate our approach on sen-
tence summarization, machine translation, and
online speech recognition problems and achieve
results competitive with existing sequence-to-
sequence models.

1. Introduction

the

“sequence-to-sequence”

Recently,
framework
(Sutskever et al., 2014; Cho et al., 2014) has facilitated
the use of recurrent neural networks (RNNs) on sequence
transduction problems such as machine translation and
speech recognition. In this framework, an input sequence
is processed with an RNN to produce an “encoding”; this
encoding is then used by a second RNN to produce the
target sequence. As originally proposed, the encoding is
a single ﬁxed-length vector representation of the input
sequence. This requires the model to effectively compress
all important information about the input sequence into a
single vector. In practice, this often results in the model
having difﬁculty generalizing to longer sequences than
those seen during training (Bahdanau et al., 2015).

An effective solution to these shortcomings are attention

1Google Brain, Mountain View, California, USA. Correspon-

dence to: Colin Raffel <craffel@gmail.com>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

In a sequence-to-
mechanisms (Bahdanau et al., 2015).
sequence model with attention, the encoder produces a se-
quence of hidden states (instead of a single ﬁxed-length
vector) which correspond to entries in the input sequence.
The decoder is then allowed to refer back to any of the en-
coder states as it produces its output. Similar mechanisms
have been used as soft addressing schemes in memory-
augmented neural network architectures (Graves et al.,
2014; Sukhbaatar et al., 2015) and RNNs used for sequence
generation (Graves, 2013). Attention-based sequence-to-
sequence models have proven to be extremely effective on
a wide variety of problems, including machine translation
(Bahdanau et al., 2015; Luong et al., 2015), image cap-
tioning (Xu et al., 2015), speech recognition (Chorowski
et al., 2015; Chan et al., 2016), and sentence summariza-
tion (Rush et al., 2015). In addition, attention creates an
implicit soft alignment between entries in the output se-
quence and entries in the input sequence, which can give
useful insight into the model’s behavior.

A common criticism of soft attention is that the model must
perform a pass over the entire input sequence when pro-
ducing each element of the output sequence. This results
in the decoding process having complexity O(T U ), where
T and U are the input and output sequence lengths respec-
tively. Furthermore, because the entire sequence must be
processed prior to outputting any symbols, soft attention
cannot be used in “online” settings where output sequence
elements are produced when the input has only been par-
tially observed.

The focus of this paper is to propose an alternative at-
tention mechanism which has linear-time complexity and
can be used in online settings. To achieve this, we ﬁrst
note that in many problems, the input-output alignment is
roughly monotonic. For example, when transcribing an
audio recording of someone saying “good morning”, the
region of the speech utterance corresponding to “good”
will always precede the region corresponding to “morn-
ing”. Even when the alignment is not strictly monotonic,
it often only contains local input-output reorderings. Sep-
arately, despite the fact that soft attention allows for as-
signment of focus to multiple disparate entries of the input
sequence, in many cases the attention is assigned mostly to
a single entry. For examples of alignments with these char-
acteristics, we refer to e.g. (Chorowski et al. 2015 Figure

Online and Linear-Time Attention by Enforcing Monotonic Alignments

2; Chan et al. 2016 Figure 2; Rush et al. 2015 Figure 1;
Bahdanau et al. 2015 Figure 3), etc. Of course, this is not
true in all problems; for example, when using soft attention
for image captioning, the model will often change focus
arbitrarily between output steps and will spread attention
across large regions of the input image (Xu et al., 2015).

Motivated by these observations, we propose using hard
monotonic alignments for sequence-to-sequence problems
because, as we argue in section 2.2, they enable computing
attention online and in linear time. Towards this end, we
show that it is possible to train such an attention mecha-
nism with a quadratic-time algorithm which computes its
expected output. This allows us to continue using standard
backpropagation for training while still facilitating efﬁcient
online decoding at test-time. On all problems we studied,
we found these added beneﬁts only incur a small decrease
in performance compared to softmax-based attention.

The rest of this paper is structured as follows: In the follow-
ing section, we develop an interpretation of soft attention as
optimizing a stochastic process in expectation and formu-
late a corresponding stochastic process which allows for
online and linear-time decoding by relying on hard mono-
tonic alignments. In analogy with soft attention, we then
show how to compute the expected output of the mono-
tonic attention process and elucidate how the resulting al-
gorithm differs from standard softmax attention. After giv-
ing an overview of related work, we apply our approach to
the tasks of sentence summarization, machine translation,
and online speech recognition, achieving results competi-
tive with existing sequence-to-sequence models. Finally,
we present additional derivations, experimental details, and
ideas for future research in the appendix.

2. Online and Linear-Time Attention

To motivate our approach, we ﬁrst point out that softmax-
based attention is computing the expected output of a sim-
ple stochastic process. We then detail an alternative process
which enables online and linear-time decoding. Because
this process is nondifferentiable, we derive an algorithm for
computing its expected output, allowing us to train a model
with standard backpropagation while applying our online
and linear-time process at test time. Finally, we propose
an alternative energy function motivated by the differences
between monotonic attention and softmax-based attention.

2.1. Soft Attention

To begin with, we review the commonly-used form of
soft attention proposed originally in (Bahdanau et al.,
2015). Broadly, a sequence-to-sequence model produces
a sequence of outputs based on a processed input se-
quence. The model consists of two RNNs, referred to

as the “encoder” and “decoder”. The encoder RNN pro-
cesses the input sequence x = {x1, . . . , xT } to produce
a sequence of hidden states h = {h1, . . . , hT }. We re-
fer to h as the “memory” to emphasize its connection to
memory-augmented neural networks (Graves et al., 2014;
Sukhbaatar et al., 2015). The decoder RNN then produces
an output sequence y = {y1, . . . , yU }, conditioned on the
memory, until a special end-of-sequence token is produced.

When computing yi, a soft attention-based decoder uses a
learnable nonlinear function a(·) to produce a scalar value
ei,j for each entry hj in the memory based on hj and the de-
coder’s state at the previous timestep si−1. Typically, a(·)
is a single-layer neural network using a tanh nonlinearity,
but other functions such as a simple dot product between
si−1 and hj have been used (Luong et al., 2015; Graves
et al., 2014). These scalar values are normalized using the
softmax function to produce a probability distribution over
the memory, which is used to compute a context vector ci as
the weighted sum of h. Because items in the memory have
a sequential correspondence with items in the input, these
attention distributions create a soft alignment between the
output and input. Finally, the decoder updates its state to si
based on si−1 and ci and produces yi. In total, producing
yi involves

ei,j = a(si−1, hj)

αi,j = exp(ei,j)

exp(ei,k)

(cid:30) T

(cid:88)

k=1

ci =

αi,jhj

T
(cid:88)

j=1

si = f (si−1, yi−1, ci)
yi = g(si, ci)

(1)

(2)

(3)

(4)

(5)

where f (·) is a recurrent neural network (typically one or
more LSTM (Hochreiter & Schmidhuber, 1997) or GRU
(Chung et al., 2014) layers) and g(·) is a learnable nonlinear
function which maps the decoder state to the output space
(e.g. an afﬁne transformation followed by a softmax when
the target sequences consist of discrete symbols).

To motivate our monotonic alignment scheme, we observe
that eqs. (2) and (3) are computing the expected output of
a simple stochastic process, which can be formulated as
follows: First, a probability αi,j is computed independently
for each entry hj of the memory. Then, a memory index k
is sampled by k ∼ Categorical(αi) and ci is set to hk. We
visualize this process in ﬁg. 1. Clearly, eq. (3) shows that
soft attention replaces sampling k and assigning ci = hk
with direct computation of the expected value of ci.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

the

stochastic process underlying
Figure 1. Schematic of
softmax-based attention decoders.
Each node represents a
possible alignment between an entry of the output sequence
(vertical axis) and the memory (horizontal axis). At each output
timestep, the decoder inspects all memory entries (indicated in
gray) and attends to a single one (indicated in black). A black
node indicates that memory element hj is aligned to output yi. In
terms of which memory entry is chosen, there is no dependence
across output timesteps or between memory entries.

Figure 2. Schematic of our novel monotonic stochastic decoding
process. At each output timestep, the decoder inspects memory
entries (indicated in gray) from left-to-right starting from where
it left off at the previous output timestep and chooses a single
one (indicated in black). A black node indicates that memory
element hj is aligned to output yi. White nodes indicate that a
particular input-output alignment was not considered because it
violates monotonicity. Arrows indicate the order of processing
and dependence between memory entries and output timesteps.

2.2. A Hard Monotonic Attention Process

The discussion above makes clear that softmax-based at-
tention requires a pass over the entire memory to compute
the terms αi,j required to produce each element of the out-
put sequence. This precludes its use in online settings, and
results in a complexity of O(T U ) for generating the out-
put sequence. In addition, despite the fact that h represents
a transformation of a sequence (which ostensibly exhibits
dependencies between subsequent elements), the attention
probabilities are computed independent of temporal order
and the attention distribution at the previous timestep.

We address these shortcomings by ﬁrst formulating a
stochastic process which explicitly processes the memory
in a left-to-right manner. Speciﬁcally, for output timestep
i we begin processing memory entries from index ti−1,
where ti is the index of the memory entry chosen at output
timestep i (for convenience, letting t0 = 1). We sequen-
tially compute, for j = ti−1, ti−1 + 1, ti−1 + 2, . . .

ei,j = a(si−1, hj)
pi,j = σ(ei,j)
zi,j ∼ Bernoulli(pi,j)

(6)

(7)

(8)

where a(·) is a learnable deterministic “energy function”
and σ(·) is the logistic sigmoid function. As soon as we
sample zi,j = 1 for some j, we stop and set ci = hj
and ti = j, “choosing” memory entry j for the context
vector. Each zi,j can be seen as representing a discrete
choice of whether to ingest a new item from the memory
(zi,j = 0) or produce an output (zi,j = 1). For all sub-

sequent output timesteps, we repeat this process, always
starting from ti−1 (the memory index chosen at the previ-
ous timestep). If for any output timestep i we have zi,j = 0
for j ∈ {ti−1, . . . , T }, we simply set ci to a vector of ze-
ros. This process is visualized in ﬁg. 2 and is presented
more explicitly in algorithm 1 (appendix A).

Note that by construction, in order to compute pi,j, we only
need to have computed hk for k ∈ {1, . . . , j}. It follows
that our novel process can be computed in an online man-
ner; i.e. we do not need to wait to observe the entire input
sequence before we start producing the output sequence.
Furthermore, because we start inspecting memory elements
from where we left off at the previous output timestep (i.e.
at index ti−1), the resulting process only computes at most
max(T, U ) terms pi,j, giving it a linear runtime. Of course,
it also makes the strong assumption that the alignment be-
tween the input and output sequence is strictly monotonic.

2.3. Training in Expectation

The online alignment process described above involves
sampling, which precludes the use of standard backpropa-
gation. In analogy with softmax-based attention, we there-
fore propose training with respect to the expected value of
ci, which can be computed straightforwardly as follows.
We ﬁrst compute ei,j and pi,j exactly as in eqs. (6) and (7),
where pi,j are interpreted as the probability of choosing
memory element j at output timestep i. The attention dis-
tribution over the memory is then given by (see appendix C

Online and Linear-Time Attention by Enforcing Monotonic Alignments

for a derivation)

αi,j = pi,j

αi−1,k

(1 − pi,l)

(9)

(cid:32)

j
(cid:88)

k=1
(cid:18)

(cid:33)

(cid:19)

j−1
(cid:89)

l=k
αi,j−1
pi,j−1

= pi,j

(1 − pi,j−1)

+ αi−1,j

(10)

We provide a solution to the recurrence relation of eq. (10)
which allows computing αi,j for j ∈ {1, . . . , T } in parallel
with cumulative sum and cumulative product operations in
appendix C.1. Deﬁning qi,j = αi,j/pi,j gives the following
procedure for computing αi,j:

ei,j = a(si−1, hj)
pi,j = σ(ei,j)
qi,j = (1 − pi,j−1)qi,j−1 + αi−1,j
αi,j = pi,jqi,j

(11)

(12)

(13)

(14)

where we deﬁne the special cases of qi,0 = 0, pi,0 = 0
to maintain equivalence with eq. (9). As in softmax-
based attention, the αi,j values produce a weighting over
the memory, which are then used to compute the con-
text vector at each timestep as in eq. (3). However, note
that αi may not be a valid probability distribution because
(cid:80)
j αi,j ≤ 1. Using αi as-is, without normalization, ef-
fectively associates any additional probability not allocated
to memory entries to an additional all-zero memory loca-
tion. Normalizing αi so that (cid:80)T
j=1 αi,j = 1 has two issues:
First, we can’t perform this normalization at test time and
still achieve online decoding because the normalization de-
pends on αi,j for j ∈ {1, . . . , T }, and second, it would re-
sult in a mismatch compared to the probability distribution
induced by the hard monotonic attention process which sets
ci to a vector of zeros when zi,j = 0 for j ∈ {ti−1, . . . , T }.

Note that computing ci still has a quadratic complexity be-
cause we must compute αi,j for j ∈ {1, . . . , T } for each
output timestep i. However, because we are training di-
rectly with respect to the expected value of ci, we will train
our decoders using eqs. (11) to (14) and then use the on-
line, linear-time attention process of section 2.2 at test time.
Furthermore, if pi,j ∈ {0, 1} these approaches are equiva-
lent, so in order for the model to exhibit similar behavior at
training and test time, we need pi,j ≈ 0 or pi,j ≈ 1. We
address this in section 2.5.

2.4. Modiﬁed Energy Function

While various “energy functions” a(·) have been proposed,
the most common to our knowledge is the one proposed in
(Bahdanau et al., 2015):

a(si−1, hj) = v(cid:62) tanh(W si−1 + V hj + b)

(15)

where W and V are weight matrices, b is a bias vector,1
and v is a weight vector. We make two modiﬁcations to
eq. (15) for use with our monotonic decoder: First, while
the softmax is invariant to offset,2 the logistic sigmoid is
not. As a result, we make the simple modiﬁcation of adding
a scalar variable r after the tanh function, allowing the
model to learn the appropriate offset for the pre-sigmoid
activations. Note that eq. (13) tends to exponentially de-
cay attention over the memory because 1 − pi,j ∈ [0, 1];
we therefore initialized r to a negative value prior to train-
ing so that 1 − pi,j tends to be close to 1. Second, the
use of the sigmoid nonlinearity in eq. (12) implies that our
mechanism is particularly sensitive to the scale of the en-
ergy terms ei,j, or correspondingly, the scale of the energy
vector v. We found an effective solution to this issue was
to apply weight normalization (Salimans & Kingma, 2016)
to v, replacing it by gv/(cid:107)v(cid:107) where g is a scalar parame-
ter. Initializing g to the inverse square root of the attention
hidden dimension worked well for all problems we studied.

The above produces the energy function

a(si−1, hj) = g

tanh(W si−1 + V hj + b) + r (16)

v(cid:62)
(cid:107)v(cid:107)

The addition of the two scalar parameters g and r prevented
the issues described above in all our experiments while in-
curring a negligible increase in the number of parameters.

2.5. Encouraging Discreteness

As mentioned above, in order for our mechanism to exhibit
similar behavior when training in expectation and when us-
ing the hard monotonic attention process at test time, we
require that pi,j ≈ 0 or pi,j ≈ 1. A straightforward way to
encourage this behavior is to add noise before the sigmoid
in eq. (12), as was done e.g. in (Frey, 1997; Salakhutdinov
& Hinton, 2009; Foerster et al., 2016). We found that sim-
ply adding zero-mean, unit-variance Gaussian noise to the
pre-sigmoid activations was sufﬁcient in all of our exper-
iments. This approach is similar to the recently proposed
Gumbel-Softmax trick (Jang et al., 2016; Maddison et al.,
2016), except we did not ﬁnd it necessary to anneal the
temperature as suggested in (Jang et al., 2016).

Note that once we have a model which produces pi,j which
are effectively discrete, we can eschew the sampling in-
volved in the process of section 2.2 and instead simply set
zi,j = I(pi,j > τ ) where I is the indicator function and τ
is a threshold. We used this approach in all of our exper-
iments, setting τ = 0.5. Furthermore, at test time we do
not add pre-sigmoid noise, making decoding purely deter-

1b is occasionally omitted, but we found it often improves per-
formance and only incurs a modest increase in parameters, so we
include it.

2That is, softmax(e) = softmax(e + r) for any r ∈ R.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

ministic. Combining all of the above, we present our dif-
ferentiable approach to training the monotonic alignment
decoder in algorithm 2 (appendix A).

3. Related Work

(Luo et al., 2016) and (Zaremba & Sutskever, 2015) both
study a similar framework in which a decoder RNN can
decide whether to ingest another entry from the input se-
quence or emit an entry of the output sequence. Instead of
training in expectation, they maintain the discrete nature of
this decision while training and use reinforcement learning
(RL) techniques. We initially experimented with RL-based
training methods but were unable to ﬁnd an approach which
worked reliably on the different tasks we studied. Empir-
ically, we also show superior performance to (Luo et al.,
2016) on online speech recognition tasks; we did not at-
tempt any of the tasks from (Zaremba & Sutskever, 2015).
(Aharoni & Goldberg, 2016) also study hard monotonic
alignments, but their approach requires target alignments
computed via a separate statistical alignment algorithm in
order to be trained.

As an alternative approach to monotonic alignments, Con-
nectionist Temporal Classiﬁcation (CTC) (Graves et al.,
2006) and the RNN Transducer (Graves, 2012) both as-
sume that the output sequences consist of symbols, and add
an additional “null” symbol which corresponds to “produce
no output”. More closely to our model, (Yu et al., 2016b)
similarly add “shift” and “emit” operations to an RNN. Fi-
nally, the Segmental RNN (Kong et al., 2015) treats a seg-
mentation of the input sequence as a latent random variable.
In all cases, the alignment path is marginalized out via a
dynamic program in order to obtain a conditional probabil-
ity distribution over label sequences and train directly with
maximum likelihood. These models either require condi-
tional independence assumptions between output symbols
or don’t condition the decoder (language model) RNN on
the input sequence. We instead follow the framework of
attention and marginalize out alignment paths when com-
puting the context vectors ci which are subsequently fed
into the decoder RNN, which allows the decoder to condi-
tion on its past output as well as the input sequence. Our
approach can therefore be seen as a marriage of these CTC-
style techniques and attention. Separately, instead of per-
forming an approximate search for the most probable out-
put sequence at test time, we use hard alignments which
facilitates linear-time decoding.

A related idea is proposed in (Raffel & Lawson, 2017),
where “subsampling” probabilities are assigned to each en-
try in the memory and a stochastic process is formulated
which involves keeping or discarding entries from the input
sequence according to the subsampling probabilities. A dy-
namic program similar to the one derived in section 2.3 is

then used to compute the expected output which allows for
training with standard backpropagation. Our approach dif-
fers in that we utilize an RNN decoder to construct the out-
put sequence, and furthermore allows for output sequences
which are longer than the input.

Some similar ideas to those in section 2.3 were proposed
in the context of speech recognition in (Chorowski et al.,
2015): First, the prior attention distributions are convolved
with a bank of one-dimensional ﬁlters and then included in
the energy function calculation. Second, instead of com-
puting attention over the entire memory they only compute
it over a sliding window. This reduces the runtime com-
plexity at the expense of the strong assumption that mem-
ory locations attended to at subsequent output timesteps fall
within a small window of one another. Finally, they also
advocate replacing the softmax function with a sigmoid,
but they then normalize by the sum of these sigmoid acti-
vations across the memory window instead of interpreting
these probabilities in the left-to-right framework we use.
While these modiﬁcations encourage monotonic attention,
they do not explicitly enforce it, and so the authors do not
investigate online decoding.

In a similar vein, (Luong et al., 2015) explore only comput-
ing attention over a small window of the memory. In addi-
tion to simply monotonically increasing the window loca-
tion at each output timestep, they also consider learning
a policy for producing the center of the memory window
based on the current decoder state.

(Kim et al., 2017) also make the connection between soft
attention and selecting items from memory in expectation.
They consider replacing the softmax in standard soft atten-
tion with an elementwise sigmoid nonlinearity, but do not
formulate the interpretation of addressing memory from
left-to-right and the corresponding probability distributions
as we do in section 2.3.

(Jaitly et al., 2015) apply standard softmax attention in on-
line settings by splitting the input sequence into chunks and
producing output tokens using the attentive sequence-to-
sequence framework over each chunk. They then devise a
dynamic program for ﬁnding the approximate best align-
ment between the model output and the target sequence.
In contrast, our ingest/emit probabilities pi,j can be seen as
adaptively chunking the input sequence (rather than provid-
ing a ﬁxed setting of the chunk size) and we instead train by
exactly computing the expectation over alignment paths.

4. Experiments

To validate our proposed approach for learning mono-
tonic alignments, we applied it to a variety of sequence-
to-sequence problems: sentence summarization, machine
translation, and online speech recognition. In the follow-

Online and Linear-Time Attention by Enforcing Monotonic Alignments

ing subsections, we give an overview of the models used
and the results we obtained; for more details about hy-
perparamers and training speciﬁcs please see appendix D.
Incidentally, all experiments involved predicting discrete
symbols (e.g. phonemes, characters, or words); as a result,
the output of the decoder in each of our models was fed
into an afﬁne transformation followed by a softmax non-
linearity with a dimensionality corresponding to the num-
ber of possible symbols. At test time, we performed a
beam search over softmax predictions on all problems ex-
cept machine translation. All networks were trained using
standard cross-entropy loss with teacher forcing against tar-
get sequences using the Adam optimizer (Kingma & Ba,
2014). All of our decoders used the monotonic attention
mechanism of section 2.3 during training to address the
hidden states of the encoder. For comparison, we report
test-time results using both the hard linear-time decoding
method of section 2.2 and the “soft” monotonic attention
distribution. We also present the results of a synthetic
benchmark we used to measure the potential speedup of-
fered by our linear-time decoding process in appendix F.

Online Speech Recognition Online speech recognition
involves transcribing the words spoken in a speech utter-
ance in real-time, i.e. as a person is talking. This problem
is a natural application for monotonic alignments because
online decoding is an explicit requirement. In addition, this
precludes the use of bidirectional RNNs, which degrades
performance somewhat (Graves et al., 2013). We tested our
approach on two datasets: TIMIT (Garofolo et al., 1993)
and the Wall Street Journal corpus (Paul & Baker, 1992).

Speech recognition on the TIMIT dataset involves tran-
scribing the phoneme sequence underlying a given speech
utterance.
Speech utterances were represented as se-
quences of 40-ﬁlter (plus energy) mel-ﬁlterbank spectra,
computed every 10 milliseconds, with delta- and delta-
delta-features. Our encoder RNN consisted of three uni-
directional LSTM layers. Following (Chan et al., 2016),
after the ﬁrst and second LSTM layer we placed time re-
duction layers which skip every other sequence element.
Our decoder RNN was a single unidirectional LSTM. Our
output softmax had 62 dimensions, corresponding to the
60 phonemes from TIMIT plus special start-of-sequence
and end-of-sequence tokens. At test time, we utilized a
beam search over softmax predictions, with a beam width
of 10. We report the phone error rate (PER) after apply-
ing the standard mapping to 39 phonemes (Graves et al.,
2013). We used the standard train/validation/test split and
report results on the test set.

Our model’s performance, with a comparison to other on-
line approaches, is shown in table 1. We achieve better
performance than recently proposed sequence-to-sequence
models (Luo et al., 2016; Jaitly et al., 2015), though the

Table 1. Phone error rate on the TIMIT dataset for different online
methods.

Method

(Luo et al., 2016) (stacked LSTM)
(Jaitly et al., 2015) (end-to-end)
(Luo et al., 2016) (grid LSTM)
Hard Monotonic Attention (ours)
Soft Monotonic Attention (ours, ofﬂine)
(Graves et al., 2013) (CTC)

PER

21.5%
20.8%
20.5%
20.4%
20.1%
19.6%

small size of the TIMIT dataset and the resulting variabil-
ity of results precludes making substantiative claims about
one approach being best. We note that (Jaitly et al., 2015)
were able to improve performance by precomputing align-
ments using an HMM system and providing them as a su-
pervised signal to their decoder; we did not experiment
with this idea. CTC (Graves et al., 2013) still outperforms
all sequence-to-sequence models.
In addition, there re-
mains a substantial gap between these online results and
ofﬂine results using bidirectional LSTMs, e.g. (Chorowski
et al., 2015) achieves a 17.6% phone error rate using a
softmax-based attention mechanism and (Graves et al.,
2013) achieved 17.7% using a pre-trained RNN transducer
model. We are interested in investigating ways to close this
gap in future work.

Because of the size of the dataset, performance on TIMIT is
often highly dependent on appropriate regularization. We
therefore also evaluated our approach on the Wall Street
Journal (WSJ) speech recognition dataset, which is about
10 times larger. For the WSJ corpus, we present speech
utterances to the network as 80-ﬁlter mel-ﬁlterbank spec-
tra with delta- and delta-delta features, and normalized us-
ing per-speaker mean and variance computed ofﬂine. The
model architecture is a variation of that from (Zhang et al.,
2016), using an 8 layer encoder including:
two convo-
lutional layers which downsample the sequence in time,
followed by one unidirectional convolutional LSTM layer,
and ﬁnally a stack of three unidirectional LSTM layers in-
terleaved with linear projection layers and batch normal-
ization. The encoder output sequence is consumed by the
proposed online attention mechanism which is passed into
a decoder consisting of a single unidirectional LSTM layer
followed by a softmax layer.

Our output softmax predicted one of 49 symbols, consist-
ing of alphanumeric characters, punctuation marks, and
start-of sequence, end-of-sequence, “unknown”, “noise”,
and word delimiter tokens. We utilized label smoothing
during training (Chorowski & Jaitly, 2017), replacing the
targets at time yt with a convex weighted combination of
the surrounding ﬁve labels (full details in appendix D.1.2).
Performance was measured in terms of word error rate
(WER) on the test set after segmenting the model’s predic-

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Table 2. Word error rate on the WSJ dataset. All approaches used
a unidirectional encoder; results in grey indicate ofﬂine models.

Method

CTC (our model)
(Luo et al., 2016) (hard attention)
(Wang et al., 2016) (CTC)
Hard Monotonic Attention (our model)
Soft Monotonic Attention (our model)
Softmax Attention (our model)

WER

33.4%
27.0%
22.7%
17.4%
16.5%
16.0%

tions according to the word delimiter tokens. We used the
standard dataset split of si284 for training, dev93 for vali-
dation, and eval92 for testing. We did not use a language
model to improve decoding performance.

Our results on WSJ are shown in table 2. Our model, with
hard monotonic decoding, achieved a signiﬁcantly lower
WER than the other online methods. While these ﬁgures
show a clear advantage to our approach, our model ar-
chitecture differed signiﬁcantly from those of (Luo et al.,
2016; Wang et al., 2016). We therefore additionally mea-
sured performance against a baseline model which was
identical to our model except that it used softmax-based
attention (which makes it quadratic-time and ofﬂine) in-
stead of a monotonic alignment decoder. This resulted in
a small decrease of 1.4% WER, suggesting that our hard
monotonic attention approach achieves competitive perfor-
mance while being substantially more efﬁcient. To get a
qualitative picture of our model’s behavior compared to the
softmax-attention baseline, we plot each model’s input-
output alignments for two example speech utterances in
ﬁg. 4 (appendix B). Both models learn roughly the same
alignment, with some minor differences caused by ours be-
ing both hard and strictly monotonic.

Sentence Summarization Speech recognition exhibits
a strictly monotonic input-output alignment. We are in-
terested in testing whether our approach is also effective
on problems which only exhibit approximately monotonic
alignments. We therefore ran a “sentence summarization”
experiment using the Gigaword corpus, which involves pre-
dicting the headline of a news article from its ﬁrst sentence.

Overall, we used the model of (Liu & Pan, 2016), modi-
fying it only so that it used our monotonic alignment de-
coder instead of a soft attention decoder. Because online
decoding is not important for sentence summarization, we
utilized bidirectional RNNs in the encoder for this task
(as is standard). We expect that the bidirectional RNNs
will give the model local context which may help allow
for strictly monotonic alignments. The model both took
as input and produced as output one-hot representations of
the word IDs, with a vocabulary of the 200,000 most com-
mon words in the training set. Our encoder consisted of

Table 3. ROUGE F-measure scores for sentence summarization
on the Gigaword test set of (Rush et al., 2015).
(Rush et al.,
2015) reports ROUGE recall scores, so we report the F-1 scores
computed for that approach from (Chopra et al., 2016). As is
standard, we report unigram, bigram, and longest common subse-
quence metrics as R-1, R-2, and R-L respectively.

Method

R-1

R-2

R-L

(Zeng et al., 2016)
(Rush et al., 2015)
(Yu et al., 2016b)
(Chopra et al., 2016)
(Miao & Blunsom, 2016)
(Nallapati et al., 2016)
(Yu et al., 2016a)
(Suzuki & Nagata, 2017)
Hard Monotonic (ours)
Soft Monotonic (ours)
(Liu & Pan, 2016)

27.82
29.76
30.27
33.78
34.17
34.19
34.41
36.30
37.14
38.03
38.22

12.74
11.88
13.68
15.97
15.94
16.29
16.86
17.31
18.00
18.57
18.70

26.01
26.96
27.91
31.15
31.92
32.13
31.83
33.88
34.87
35.70
35.74

Figure 3. Example sentence-summary pair with attention align-
ments for our hard monotonic model and the softmax-based at-
tention model of (Liu & Pan, 2016). Attention matrices are dis-
played so that black corresponds to 1 and white corresponds to
0. The ground-truth summary is “greece pumps more money and
personnel into bird ﬂu defense”.

a word embedding matrix (which was initialized randomly
and trained as part of the model) followed by four bidirec-
tional LSTM layers. We used a single LSTM layer for the
decoder. For data preparation and evaluation, we followed
the approach of (Rush et al., 2015), measuring performance
using the ROUGE metric.

Our results, along with the scores achieved by other ap-
proaches, are presented in table 3. While the monotonic
alignment model outperformed existing models by a sub-
stantial margin, it fell slightly behind the model of (Liu
& Pan, 2016) which we used as a baseline. The higher
performance of our model and the model of (Liu & Pan,
2016) can be partially explained by the fact that their en-
coders have roughly twice as many layers as most models
proposed in the literature.

For qualitative evaluation, we plot an example input-output

Online and Linear-Time Attention by Enforcing Monotonic Alignments

pair and alignment matrices for our hard monotonic atten-
tion model and the softmax-attention baseline of (Liu &
Pan, 2016) in ﬁg. 3 (an additional example is shown in
ﬁg. 6, appendix B). Most apparent is that a given word
in the summary is not always aligned to the most obvi-
ous word in the input sentence; the hard monotonic de-
coder aligns the ﬁrst four words in the summary reason-
ably (greek ↔ greek, government ↔ ﬁnance, approves ↔
approved, more ↔ more), but the latter four words have
unexpected alignments (funds ↔ in, to ↔ for, bird ↔ mea-
sures, bird ↔ ﬂu). We believe this is due to the ability of
the multilayer bidirectional RNN encoder to reorder words
in the input sequence. This effect is also apparent in ﬁg. 6/
(appendix B), where the monotonic alignment decoder is
able to produce the phrase “human rights criticism” despite
the fact that the input sentence has the phrase “criticism
of human rights”. Separately, we note that the softmax
attention model’s alignments are extremely “soft” and non-
monotonic; this may be advantageous for this problem and
partially explain its slightly superior performance.

Machine Translation We also evaluated our approach
on machine translation, another task which does not exhibit
strictly monotonic alignments. In fact, for some language
pairs (e.g. English and Japanese, English and Korean), we
do not expect monotonicity at all. However, for other pairs
(e.g. English and French, English and Vietnamese) only
local word reorderings are required. Our translation ex-
periments therefore involved English to Vietnamese trans-
lation using the parallel corpus of TED talks (133K sen-
tence pairs) provided by the IWSLT 2015 Evaluation Cam-
paign (Cettolo et al., 2015). Following (Luong & Manning,
2015), we tokenize the corpus with the default Moses tok-
enizer, preserve casing, and replace words whose frequen-
cies are less than 5 by <unk>. As a result, our vocab-
ulary sizes are 17K and 7.7K for English and Vietnamese
respectively. We use the TED tst2012 (1553 sentences) as a
validation set for hyperparameter tuning and TED tst2013
(1268 sentences) as a test set. We report results in both
perplexity and BLEU.

Our baseline neural machine translation (NMT) system is
the softmax attention-based sequence-to-sequence model
described in (Luong et al., 2015). From that baseline, we
substitute the softmax-based attention mechanism with our
proposed monotonic alignment decoder. The model uti-
lizes two-layer unidirectional LSTM networks for both the
encoder and decoder.

In (Luong et al., 2015), the authors demonstrated that un-
der their proposed architecture, a dot product-based energy
function worked better than eq. (15). Since our architec-
ture is based on that of (Luong et al., 2015), to facilitate
comparison we also tested the following variant:

Table 4. Performance on the IWSLT 2015 English-Vietnamese
TED talks for our monotonic alignment model and the baseline
softmax-attention model of (Luong & Manning, 2015).

Method

(Luong & Manning, 2015)
Hard Monotonic, energy function eq. (16)
Hard Monotonic, energy function eq. (17)

BLEU

23.3
22.6
23.0

where g and r are scalars (initialized as in section 2.4) and
W is a weight matrix.

Our results are shown in Table 4. To get a better pic-
ture of each model’s behavior, we plot input-output align-
ments in ﬁg. 5 (appendix B). Most noticeable is that the
monotonic alignment model tends to focus attention later
in the input sequence than the baseline softmax-attention
model. We hypothesize that this is a way to compensate
for non-monotonic alignments when a unidirectional en-
coder is used; i.e. the model has effectively learned to fo-
cus on words at the end of phrases which require reorder-
ing, at which point the unidirectional encoder has observed
the whole phrase. This can be seen most clearly in the
example on the right, where translating “a huge famine”
to Vietnamese requires reordering (as suggested by the
softmax-attention model’s alignment), so the hard mono-
tonic alignment model focuses attention on the ﬁnal word
in the phrase (“famine”) while producing its translation.
We suspect our model’s small decrease in BLEU compared
to the baseline model may be due in part to this increased
modeling burden.

5. Discussion

Our results show that our differentiable approach to enforc-
ing monotonic alignments can produce models which, fol-
lowing the decoding process of section 2.2, provide efﬁ-
cient online decoding at test time without sacriﬁcing sub-
stantial performance on a wide variety of tasks. We believe
our framework presents a promising environment for fu-
ture work on online and linear-time sequence-to-sequence
models. We are interested in investigating various exten-
sions to this approach, which we outline in appendix E.
To facilitate experimentation with our proposed attention
mechanism, we have made an example TensorFlow (Abadi
et al., 2016) implementation of our approach available on-
line3 and added a reference implementation to Tensor-
Flow’s tf.contrib.seq2seq module. We also pro-
vide a “practitioner’s guide” in appendix G.

a(si−1, hj) = g(s(cid:62)

i−1W h) + r

(17)

3https://github.com/craffel/mad

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Acknowledgements

We thank Jan Chorowski, Mark Daoust, Pietro Kreit-
lon Carolino, Dieterich Lawson, Navdeep Jaitly, George
Tucker, Quoc V. Le, Kelvin Xu, Cinjon Resnick, Melody
Guan, Matthew D. Hoffman, Jeffrey Dean, Kevin Swersky,
Ashish Vaswani, and members of the Google Brain team
for helpful discussions and insight.

References

Abadi, Martin, Barham, Paul, Chen, Jianmin, Chen,
Zhifeng, Davis, Andy, Dean, Jeffrey, Devin, Matthieu,
Ghemawat, Sanjay, Irving, Geoffrey, Isard, Michael,
Kudlur, Manjunath, Levenberg, Josh, Monga, Rajat,
Moore, Sherry, Murray, Derek G., Steiner, Benoit,
Tucker, Paul, Vasudevan, Vijay, Warden, Pete, Wicke,
Martin, Yu, Yuan, and Zheng, Xiaoqiang. TensorFlow:
A system for large-scale machine learning. In Operating
Systems Design and Implementation, 2016.

Aharoni, Roee and Goldberg, Yoav. Sequence to sequence
arXiv

transduction with hard monotonic attention.
preprint arXiv:1611.01487, 2016.

Bahdanau, Dzmitry, Cho, Kyunghyun, and Bengio,
Yoshua. Neural machine translation by jointly learning
In International Conference on
to align and translate.
Learning Representations, 2015.

Cettolo, Mauro, Niehues, Jan, Stüker, Sebastian, Ben-
tivogli, Luisa, Cattoni, Roldano, and Federico, Marcello.
The IWSLT 2015 evaluation campaign. In International
Workshop on Spoken Language Translation, 2015.

Chan, William, Jaitly, Navdeep, Le, Quoc V., and Vinyals,
Oriol. Listen, attend and spell: A neural network for
large vocabulary conversational speech recognition. In
International Conference on Acoustics, Speech and Sig-
nal Processing, 2016.

Cho, Kyunghyun, van Merriënboer, Bart, Gülçehre, Ça˘glar,
Bahdanau, Dzmitry, Bougares, Fethi, Schwenk, Holger,
and Bengio, Yoshua. Learning phrase representations us-
ing RNN encoder–decoder for statistical machine trans-
lation. In Conference on Empirical Methods in Natural
Language Processing, 2014.

Chopra, Sumit, Auli, Michael, and Rush, Alexander M.
Abstractive sentence summarization with attentive recur-
rent neural networks. Conference of the North American
Chapter of the Association for Computational Linguis-
tics: Human Language Technologies, 2016.

Chorowski, Jan, Bahdanau, Dzmitry, Serdyuk, Dmitriy,
Cho, Kyunghyun, and Bengio, Yoshua. Attention-based
models for speech recognition. In Conference on Neural
Information Processing Systems, 2015.

Chung, Junyoung, Gulcehre, Caglar, Cho, Kyunghyun, and
Bengio, Yoshua. Empirical evaluation of gated recurrent
neural networks on sequence modeling. arXiv preprint
arXiv:1412.3555, 2014.

Foerster, Jakob, Assael, Yannis M., de Freitas, Nando, and
Whiteson, Shimon. Learning to communicate with deep
multi-agent reinforcement learning. In Advances in Neu-
ral Information Processing Systems, 2016.

Frey, Brendan J. Continuous sigmoidal belief networks
trained using slice sampling. Advances in neural infor-
mation processing systems, 1997.

Garofolo, John S., Lamel, Lori F., Fisher, William M., Fis-
cus, Jonathon G., and Pallett, David S. DARPA TIMIT
acoustic-phonetic continous speech corpus. 1993.

Graves, Alex. Sequence transduction with recurrent neural

networks. arXiv preprint arXiv:1211.3711, 2012.

Graves, Alex. Generating sequences with recurrent neural

networks. arXiv preprint arXiv:1308.0850, 2013.

Graves, Alex, Fernández, Santiago, Gomez, Faustino, and
Schmidhuber, Jürgen. Connectionist temporal classiﬁ-
cation: labelling unsegmented sequence data with recur-
rent neural networks. In International conference on Ma-
chine learning, 2006.

Graves, Alex, Mohamed, Abdel-rahman, and Hinton, Ge-
offrey. Speech recognition with deep recurrent neural
In International Conference on Acoustics,
networks.
Speech and Signal Processing, 2013.

Graves, Alex, Wayne, Greg, and Danihelka, Ivo. Neural
turing machines. arXiv preprint arXiv:1410.5401, 2014.

Hochreiter, Sepp and Schmidhuber, Jürgen. Long short-

term memory. Neural computation, 9(8), 1997.

Jaitly, Navdeep, Sussillo, David, Le, Quoc V., Vinyals,
Oriol, Sutskever, Ilya, and Bengio, Samy. A neural trans-
ducer. arXiv preprint arXiv:1511.04868, 2015.

Jang, Eric, Gu, Shixiang, and Poole, Ben. Categorical
reparameterization with gumbel-softmax. arXiv preprint
arXiv:1611.01144, 2016.

Chorowski, Jan and Jaitly, Navdeep. Towards better decod-
ing and language model integration in sequence to se-
quence models. arXiv preprint arXiv:1612.02695, 2017.

Kim, Yoon, Denton, Carl, Hoang, Luong, and Rush,
arXiv

Alexander M. Structured attention networks.
preprint arXiv:1702.00887, 2017.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Kingma, Diederik and Ba,

Jimmy.
method for stochastic optimization.
arXiv:1412.6980, 2014.

Adam:

A
arXiv preprint

Kong, Lingpeng, Dyer, Chris, and Smith, Noah A. Seg-
arXiv preprint

mental recurrent neural networks.
arXiv:1511.06018, 2015.

Liu, Peter J. and Pan, Xin. Text summarization with Ten-

sorFlow. http://goo.gl/16RNEu, 2016.

Luo, Yuping, Chiu, Chung-Cheng, Jaitly, Navdeep, and
Learning online alignments with
arXiv preprint

Sutskever,
continuous rewards policy gradient.
arXiv:1608.01281, 2016.

Ilya.

Luong, Minh-Thang and Manning, Christopher D. Stan-
ford neural machine translation systems for spoken lan-
In International Workshop on Spoken
guage domain.
Language Translation, 2015.

Luong, Minh-Thang, Pham, Hieu, and Manning, Christo-
pher D. Effective approaches to attention-based neural
machine translation. In Conference on Empirical Meth-
ods in Natural Language Processing, 2015.

concrete distribution:

Maddison, Chris J., Mnih, Andriy, and Teh, Yee Whye.
relax-
arXiv preprint

The
ation of discrete random variables.
arXiv:1611.00712, 2016.

A continuous

Miao, Yishu and Blunsom, Phil. Language as a latent vari-
able: Discrete generative models for sentence compres-
sion. arXiv preprint arXiv:1609.07317, 2016.

Nallapati, Ramesh,

Zhou, Bowen,

dos Santos,
and Xiang,
Cícero Nogueira, Gülçehre, Çaglar,
Bing. Abstractive text summarization using sequence-
In Conference on
to-sequence RNNs and beyond.
Computational Natural Language Learning, 2016.

Paul, Douglas B. and Baker, Janet M. The design for the
Wall Street Journal-based CSR corpus. In Workshop on
Speech and Natural Language, 1992.

Salimans, Tim and Kingma, Diederik P. Weight normaliza-
tion: A simple reparameterization to accelerate training
of deep neural networks. In Advances in Neural Infor-
mation Processing Systems, 2016.

Sukhbaatar, Sainbayar, Szlam, Arthur, Weston, Jason, and
Fergus, Rob. End-to-end memory networks. In Advances
in neural information processing systems, 2015.

Sutskever, Ilya, Vinyals, Oriol, and Le, Quoc V. Sequence
to sequence learning with neural networks. In Advances
in neural information processing systems, 2014.

Suzuki, Jun and Nagata, Masaaki. Cutting-off redundant
repeating generations for neural abstractive summariza-
tion. arXiv preprint arXiv:1701.00138, 2017.

Wang, Chong, Yogatama, Dani, Coates, Adam, Han, Tony,
Hannun, Awni, and Xiao, Bo. Lookahead convolution
In
layer for unidirectional recurrent neural networks.
Workshop Extended Abstracts of the 4th International
Conference on Learning Representations, 2016.

Xu, Kelvin, Ba, Jimmy, Kiros, Ryan, Cho, Kyunghyun,
Courville, Aaron, Salakhudinov, Ruslan, Zemel, Rich,
and Bengio, Yoshua. Show, attend and tell: Neural im-
age caption generation with visual attention. In Interna-
tional Conference on Machine Learning, 2015.

Yu, Lei, Blunsom, Phil, Dyer, Chris, Grefenstette, Edward,
and Kocisky, Tomas. The neural noisy channel. arXiv
preprint arXiv:1611.02554, 2016a.

Yu, Lei, Buys, Jan, and Blunsom, Phil. Online segment to
segment neural transduction. In Conference on Empiri-
cal Methods in Natural Language Processing, 2016b.

Zaremba, Wojciech and Sutskever,

Reinforce-
ment learning neural turing machines. arXiv preprint
arXiv:1505.00521, 362, 2015.

Ilya.

Zeng, Wenyuan, Luo, Wenjie, Fidler, Sanja, and Urta-
sun, Raquel. Efﬁcient summarization with read-again
and copy mechanism. arXiv preprint arXiv:1611.03382,
2016.

Raffel, Colin and Lawson, Dieterich. Training a sub-
arXiv preprint

sampling mechanism in expectation.
arXiv:1702.06914, 2017.

Zhang, Yu, Chan, William, and Jaitly, Navdeep. Very deep
convolutional networks for end-to-end speech recogni-
tion. arXiv preprint arXiv:1610.03022, 2016.

Rush, Alexander M., Chopra, Sumit, and Weston, Jason. A
neural attention model for abstractive sentence summa-
rization. In Conference on Empirical Methods in Natural
Language Processing, 2015.

Salakhutdinov, Ruslan and Hinton, Geoffrey. Semantic
hashing. International Journal of Approximate Reason-
ing, 50(7), 2009.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

A. Algorithms

Below are algorithms for the hard monotonic decoding process we used at test time (algorithm 1) and the approach for
computing its expected output that we used to train the network (algorithm 2). Terminology matches the main text, except
we use (cid:126)0 to signify a vector of zeros.

Algorithm 1 Hard Monotonic Attention Process

Input: memory h of length T
State: s0 = (cid:126)0, t0 = 1, i = 1, y0 = StartOfSequence
while yi−1 (cid:54)= EndOfSequence do

// Produce output tokens until end-of-sequence token is produced

// Keep track of whether we chose a memory entry or not

ﬁnished = 0
for j = ti−1 to T do
ei,j = a(si−1, hj)
pi,j = σ(ei,j)
zi,j ∼ Bernoulli(pi,j)
if zi,j = 1 then // If we sample 1, we stop scanning the memory
// Set the context vector to the chosen memory entry

// Start inspecting memory entries hj left-to-right from where we left off
// Compute attention energy for hj
// Compute probability of choosing hj

// Sample whether to ingest another memory entry or output new symbol

ci = hj
ti = j
ﬁnished = 1
break // Stop scanning the memory

// Remember where we left off for the next output timestep

// Keep track of the fact that we chose a memory entry

end if
end for
if ﬁnished = 0 then

ci = (cid:126)0

end if
si = f (si−1, yi−1, ci)
yi = g(si, ci)
i = i + 1

end while

// If we scanned the entire memory without selecting anything, set ci to a vector of zeros

// Update the state based on the new context vector using the RNN f

// Output a new symbol using the softmax layer g

Algorithm 2 Soft Monotonic Attention Decoder

Input: memory h of length T , target outputs ˆy = {StartOfSequence, ˆy1, ˆy2, . . . , EndOfSequence}
State: s0 = (cid:126)0, i = 1, α0,j = δj for j ∈ {1, . . . , T }
while ˆyi−1 (cid:54)= EndOfSequence do

// Produce output tokens until end of the target sequence

pi,0 = 0, qi,0 = 0
for j = 1 to T do

// Special cases so that the recurrence relation matches eq. (9)
// Inspect all memory entries hj

ei,j = a(si−1, hj)
ei,j = ei,j + N (0, 1)
pi,j = σ(ei,j)
qi,j = (1 − pi,j−1)qi,j−1 + αi−1,j
αi,j = pi,jqi,j

// Compute attention energy for hj using eq. (16)

// Add pre-sigmoid noise to encourage pi,j ≈ 0 or pi,j ≈ 1

// Compute probability of choosing hj

// Iterate recurrence relation derived in eq. (10)

// Compute the probability that ci = hj

// Compute weighted combination of memory for context vector

// Update the state based on the new context vector using the RNN f

// Compute predicted output for timestep i using the softmax layer g

j=1 αi,jhj

end for
ci = (cid:80)T
si = f (si−1, yi−1, ci)
yi = g(si, ci)
i = i + 1

end while

Online and Linear-Time Attention by Enforcing Monotonic Alignments

B. Figures

Below are example hard monotonic and softmax attention alignments for each of the different tasks we included in our
experiments. Attention matrices are displayed so that black corresponds to 1 and white corresponds to 0.

Figure 4. Attention alignments from hard monotonic attention and softmax-based attention models for a two example speech utterances.
From top to bottom, we show the hard monotonic alignment, the softmax-attention alignment, and the utterance feature sequence.
Differences in the alignments are highlighted with dashed red circles. Gaps in the alignment paths correspond to effectively ignoring
silences and pauses in the speech utterances.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Figure 5. English sentences, predicted Vietnamese sentences, and input-output alignments for our proposed hard monotonic alignment
model and the baseline model of (Luong & Manning, 2015). The Vietnamese model outputs for the left example can be translated back
to English as “And I on this stage because I am a model.” (monotonic) and “And I am on this stage because I am a structure.” (softmax).
The input word “model” can mean either a person or a thing; the monotonic alignment model correctly chose the former while the
softmax alignment model chose the latter. The monotonic alignment model erroneously skipped the ﬁrst verb in the sentence. For the
right example, translations of the model outputs back to English are “A large famine in North Korea.” (monotonic) and “An invasion
of a huge famine in <unk>.” (softmax). The monotonic alignment model managed to translate the proper noun North Korea, while
the softmax alignment model produced <unk>. Both models skipped the phrase “mid-1990s”; this type of error is common in neural
machine translation systems.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Figure 6. Additional example sentence-summary pair and attention alignment matrices for our hard monotonic model and the softmax-
based attention model of (Liu & Pan, 2016). The ground-truth summary is “china attacks us human rights”.

C. Monotonic Attention Distribution

Recall that our goal is to compute the expected value of ci under the stochastic process deﬁned by eqs. (6) to (8). To achieve
this, we will derive an expression for the probability that ci = hj for j ∈ {1, . . . , T }, which in accordance with eq. (2) we
denote αi,j. For i = 1, α1,j is the probability that memory element j was chosen (p1,j) multiplied by the probability that
memory elements k ∈ {1, 2, . . . , j − 1} were not chosen ((1 − pi,k)), giving

α1,j = p1,j

(1 − p1,k)

j−1
(cid:89)

k=1

αi,j = pi,j

αi−1,k

(1 − pi,l)

(cid:32)

j
(cid:88)

k=1

j−1
(cid:89)

l=k

(cid:33)

For i > 0, in order for ci = hj we must have that ci−1 = hk for some k ∈ {1, . . . , j} (which occurs with probability
αi−1,k) and that none of hk, . . . , hj−1 were chosen. Summing over possible values of k, we have

where for convenience we deﬁne (cid:81)m
n x = 1 when n > m. We provide a schematic and explanation of eq. (19) in ﬁg. 7.
Note that we can recover eq. (18) from eq. (19) by deﬁning the special case α0,j = δj (i.e. α0,1 = 1 and α0,j = 0 for
j ∈ {2, . . . , T }). Expanding eq. (19) reveals we can compute αi,j directly given αi−1,j and αi,j−1:

αi,j = pi,j

αi−1,k

(1−pi,l)

+αi−1,j

(cid:33)

(cid:33)

(cid:32) j−1
(cid:88)

(cid:32)

k=1

(cid:32)

(cid:18)

j−1
(cid:89)

l=k

j−1
(cid:88)

(cid:32)

k=1
αi,j−1
pi,j−1

j−2
(cid:89)

l=k

(cid:19)

= pi,j

(1 − pi,j−1)

+ αi−1,j

= pi,j

(1 − pi,j−1)

αi−1,k

(1 − pi,l)

+ αi−1,j

(cid:33)

(cid:33)

(18)

(19)

(20)

(21)

(22)

Deﬁning qi,j = αi,j/pi,j produces eqs. (13) and (14). Equation (22) also has an intuitive interpretation: The expression
(1 − pi,j−1)αi,j−1/pi,j−1 represents the probability that the model attended to memory item j − 1 at output timestep i,
adjusted for the fact that memory item j − 1 was not chosen by multiplying (1 − pi,j−1) and dividing pi,j−1. Adding
αi−1,j reﬂects the additional possibility that the model attended to memory item j at the previous output timestep, and
multiplying by pi,j enforces that memory item j was chosen at the current output timestep i.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Figure 7. Visualization of eq. (19). In this example, we are showing the computation of α3,4. Each grid shows each of the four terms
in the summation, corresponding to the possibilities that we attended to memory item k = 1, 2, 3, 4 at the previous output timestep
i − 1 = 2. Gray nodes with curved arrows represent the probability of not selecting to the lth memory entry (1 − pi,l). The black nodes
represent the possibility of attending to memory item j at timestep i.

C.1. Recurrence Relation Solution

While eqs. (10) and (22) allow us to compute αi,j directly from αi−1,j and αi,j−1, the dependence on αi,j−1 means that
we must compute the terms αi,1, αi,2, . . . , αi,T sequentially. This is in contrast to softmax attention, where these terms
can be computed in parallel because they are independent. Fortunately, there is a solution to the recurrence relation of
eq. (10) which allows the terms of αi to be computed directly via parallelizable cumulative sum and cumulative product
operations. Using eq. (13) which substitutes qi,j = αi,j/pi,j, we have

qi,j = (1 − pi,j−1)qi,j−1 + αi−1,j

qi,j − (1 − pi,j−1)qi,j−1 = αi−1,j

qi,j
k=1(1 − pi,k−1)
qi,j
k=1(1 − pi,k−1)

(cid:81)j

(cid:81)j

−

−

(cid:32)

j
(cid:88)

l=1

qi,l
k=1(1 − pi,k−1)

(cid:81)l

−

(cid:81)l−1

(1 − pi,j−1)qi,j−1
(cid:81)j
k=1(1 − pi,k−1)
qi,j−1
k=1(1 − pi,k−1)
(cid:33)

(cid:81)j−1

qi,l−1
k=1(1 − pi,k−1)

=

=

=

qi,j
k=1(1 − pi,k−1)

(cid:81)j

− qi,0 =

αi−1,j
k=1(1 − pi,k−1)
αi−1,j
k=1(1 − pi,k−1)

αi−1,l
k=1(1 − pi,k−1)

(cid:81)l

αi−1,l
k=1(1 − pi,k−1)

(cid:81)l

(cid:81)j

(cid:81)j

j
(cid:88)

l=1

j
(cid:88)

l=1
(cid:32) j
(cid:89)

k=1

qi,j =

(1 − pi,k−1)

(cid:33) (cid:32) j

(cid:33)

(cid:88)

l=1

(cid:81)l

αi−1,l
k=1(1 − pi,k−1)
(cid:18)

αi−1
cumprod(1 − pi)

(cid:19)

⇒ qi = cumprod(1 − pi)cumsum

(23)

(24)

(25)

(26)

(27)

(28)

(29)

(30)

where cumprod(x) = [1, x1, x1x2, . . . , (cid:81)|x|−1
i xi]. Note that we use the
“exclusive” variant of cumprod4 in keeping with our deﬁned special case pi,0 = 0. Unlike the recurrence relation of
eq. (10), these operations can be computed efﬁciently in parallel (Ladner & Fischer, 1980). The primary disadvantage
of this approach is that the product in the denominator of eq. (29) can cause numerical instabilities; we address this in
appendix G.

xi] and cumsum(x) = [x1, x1 + x2, . . . , (cid:80)|x|

i

4This can be computed e.g. in Tensorﬂow via tf.cumprod(x, exclusive=True)

Online and Linear-Time Attention by Enforcing Monotonic Alignments

D. Experiment Details

In this section, we give further details into the models and
training procedures used in section 4. Any further ques-
tions about implementation details should be directed to the
corresponding author. All models were implemented with
TensorFlow (Abadi et al., 2016).

D.1. Speech Recognition

D.1.1. TIMIT

Mel ﬁlterbank features were standardized to have zero
mean and unit variance across feature dimensions accord-
ing to their training set statistics and were fed directly into
an RNN encoder with three unidirectional LSTM layers,
each with 512 hidden units. After the ﬁrst and second
LSTM layers, we downsampled hidden state sequences by
skipping every other state before feeding into the subse-
quent layer. For the decoder, we used a single unidirec-
tional LSTM layer with 256 units, fed directly into the out-
put softmax layer. All weight matrices were initialized uni-
formly from [−0.075, 0.075]. The output tokens were em-
bedded via a learned embedding matrix with dimensional-
ity 30, initialized uniformly from [−(cid:112)3/30, (cid:112)3/30]. Our
decoder attention energy function used a hidden dimen-
sionality of 512, with the scalar bias r initialized to -1.
The model was regularized by adding weight noise with
a standard deviation of 0.5 after 2,000 training updates.
L2 weight regularization was also applied with a weight
of 10−6.

We trained the network using Adam (Kingma & Ba, 2014),
with β1 = 0.9, β2 = 0.999, and (cid:15) = 10−6. Utter-
ances were fed to the network with a minibatch size of
4. Our initial learning rate was 10−4, which we halved
after 40,000 training steps. We clipped gradients when
their global norm exceeded 2. We used three training repli-
cas. Beam search decoding was used to produce output
sequences with a beam width of 10.

D.1.2. WALL STREET JOURNAL

The input 80 mel ﬁlterbank / delta / delta-delta features
were organized as a T × 80 × 3 tensor, i.e. raw features,
deltas, and delta-deltas are concatenated along the “depth”
dimension. This was passed into a stack of two convolu-
tional layers with ReLU activations, each consisting of 32
3×3× depth kernels in time × frequency. These were both
strided by 2 × 2 in order to downsample the sequence in
time, minimizing the computation performed in the follow-
ing layers. Batch normalization (Ioffe & Szegedy, 2015)
was applied prior to the ReLU activation in each layer. All
encoder weight matrices and ﬁlters were initialized via a
truncated Gaussian with zero mean and a standard devia-
tion of 0.1.

This downsampled feature sequence was then passed into a
single unidirectional convolutional LSTM layer using 1x3
ﬁlter (i.e. only convolving across the frequency dimension
within each timestep). Finally, this was passed into a stack
of three unidirectional LSTM layers of size 256, inter-
leaved with a 256 dimensional linear projection, following
by batch normalization, and a ReLU activation. Decoder
weight matrices were initialized uniformly at random from
[−0.1, 0.1].

The decoder input is created by concatenating a 64 dimen-
sional embedding corresponding to the symbol emitted at
the previous timestep, and the 256 dimensional attention
context vector. The embedding was initialized uniformly
from [−1, 1]. This was passed into a single unidirectional
LSTM layer with 256 units. We used an attention energy
function hidden dimensionality of 128 and initialized the
bias scalar r to -4. Finally the concatenation of the atten-
tion context and LSTM output is passed into the softmax
output layer.

We applied label smoothing (Chorowski & Jaitly, 2017),
the target at time t, with (0.015ˆyt−2 +
replacing ˆyt,
0.035ˆyt−1 + ˆyt + 0.035ˆyt+1 + 0.015ˆyt+2)/1.1. We used
beam search decoding at test time with rank pruning at 8
hypotheses and a pruning threshold of 3.

The network was trained using teacher forcing on mini-
batches of 8 input utterances, optimized using Adam
(Kingma & Ba, 2014) with β1 = 0.9, β2 = 0.999, and
(cid:15) = 10−6. Gradients were clipped to a maximum global
norm of 1. We set the initial learning rate to 0.0002 and
decayed by a factor of 10 after 700,000, 1,000,000, and
1,300,000 training steps. L2 weight decay is used with a
weight of 10−6, and, beginning from step 20,000, Gaussian
weight noise with standard deviation of 0.075 was added to
weights for all LSTM layers and decoder embeddings. We
trained using 16 replicas.

D.2. Sentence Summarization

For data preparation, we used the same Gigaword data pro-
cessing scripts provided in (Rush et al., 2015) and tok-
enized into words by splitting on spaces. The vocabulary
was determined by selecting the most frequent 200,000 to-
kens. Only the tokens of the ﬁrst sentence of the article
were used as input to the model. An embedding layer was
used to embed tokens into a 200 dimensional space; em-
beddings were initialized using random normal distribution
with mean 0 and standard deviation 10−4.

We used a 4-layer bidirectional LSTM encoder with 4 lay-
ers and a single-layer unidirectional LSTM decoder. All
LSTMs, and the attention energy function, had a hidden di-
mensionality of 256. The decoder LSTM was fed directly
into the softmax output layer. All weights were initialized

Online and Linear-Time Attention by Enforcing Monotonic Alignments

uniform-randomly between −0.1 and 0.1.
In our mono-
tonic alignment decoder, we initialized r to -4. At test time,
we used a beam search over possible label sequences with
a beam width of 4.

A batch size of 64 was used and the model was trained
to minimize the sampled-softmax cross-entropy loss with
4096 negative samples. The Adam optimizer (Kingma &
Ba, 2014) was used with β1 = 0.9, β2 = 0.999, and
(cid:15) = 10−4, and an initial learning rate of 10−3; an expo-
nential decay was applied by multiplying the initial learn-
ing rate by .98n/30000 where n is the current training step.
Gradients were clipped to have a maximum global norm
of 2. Early stopping was used with respect to validation
loss and took about 300,000 steps for the baseline model,
and 180,000 steps for the monotonic model. Training was
conducted on 16 machines with 4 GPUs each. We reported
ROUGE scores computed over the test set of (Rush et al.,
2015).

D.3. Machine Translation

Overall, we followed the model of (Luong & Man-
ning, 2015) closely; our hyperparameters are largely the
same: Words were mapped to 512-dimensional embed-
dings, which were learned during training. We passed sen-
tences to the network in minibatches of size 128. As men-
tioned in the text, we used two unidirectional LSTM lay-
ers in both the encoder and decoder. All LSTM layers,
and the attention energy function, had a hidden dimen-
sionality of 512. We trained with a single replica for 40
epochs using Adam (Kingma & Ba, 2014) with β1 = 0.9,
β2 = 0.999, and (cid:15) = 10−8. We performed grid searches
over initial learning rate and decay schedules separately for
models using each of the two energy functions eq. (16) and
eq. (17). For the model using eq. (16), we used an ini-
tial learning rate of 0.0005, and after 10 epochs we mul-
tiplied the learning rate by 0.8 each epoch; for eq. (17)
we started at 0.001 and multiplied by 0.8 each epoch start-
ing at the eighth epoch. Parameters were uniformly initial-
ized in range [−0.1, 0.1]. Gradients were scaled whenever
their norms exceeded 5. We used dropout with probability
0.3 as described in (Pham et al., 2014). Unlike (Luong &
Manning, 2015), we did not reverse source sentences in our
monotonic attention experiments. We set r = −2 for the
attention energy function bias scalar for both eq. (16) and
eq. (17). We used greedy decoding (i.e. no beam search) at
test time.

E. Future Work

We believe there are a variety of promising extensions
of our monotonic attention mechanism, which we outline
brieﬂy below.

• The primary drawback of training in expectation is
that it retains the quadratic complexity during training.
One idea would be to replace the cumulative product
in eq. (9) with the thresholded remainder method of
(Graves, 2016) and (Grefenstette et al., 2015), but in
preliminary experiments we were unable to successfully
learn alignments with this approach. Alternatively, we
could further our investigation into gradient estimators
for discrete decisions (such as REINFORCE or straight-
through) instead of training in expectation (Bengio et al.,
2013).

• As we point out in section 2.4, our method can fail when
the attention energies ei,j are poorly scaled. This primar-
ily stems from the strict enforcement of monotonicity.
One possibility to mitigate this would be to instead reg-
ularize the model with a soft penalty which discourages
non-monotonic alignments, instead of preventing them
outright.

• In some problems, the input-output alignment is non-
monotonic only in small regions. A simple modiﬁca-
tion to our approach which would allow this would be
to subtract a constant integer from ti−1 between output
timesteps. Alternatively, utilizing multiple monotonic
attention mechanisms in parallel would allow the model
to attend to disparate memory locations at each output
timestep (effectively allowing for non-monotonic align-
ments) while still maintaining linear-time decoding.

• To facilitate comparison, we sought to modify the stan-
dard softmax-based attention framework as little as pos-
sible. As a result, we have thus far not fully taken advan-
tage of the fact that the decoding process is much more
efﬁcient. Speciﬁcally, the attention energy function of
eq. (15) was primarily motivated by the fact that it is
trivially parallelizable so that its repeated application is
inexpensive. We could instead use a recurrent attention
energy function, whose output depends on both the at-
tention energies for prior memory items and those at the
previous output timestep.

F. How much faster is linear-time decoding?

Throughout this paper, we have emphasized that one ad-
vantage of our approach is that it allows for linear-time de-
coding, i.e. the decoder RNN only makes a single pass over
the memory in the course of producing the output sequence.
However, we have thus far not attempted to quantify how
much of a speedup this incurs in practice. Towards this
end, we conducted an additional experiment to measure the
speed of efﬁciently-implemented softmax-based and hard
monotonic attention mechanisms. We chose to focus solely
on the speed of the attention mechanisms rather than an en-
tire RNN sequence-to-sequence model because models us-
ing these attention mechanisms are otherwise equivalent.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

emphasize that at training time, we expect our soft mono-
tonic attention approach to have roughly the computational
cost as standard softmax attention, thanks to the fact that
we can compute the resulting attention distribution in par-
allel as described in appendix C.1. The code used for this
benchmark is available in the repository for this paper.5

G. Practitioner’s Guide

Because we are proposing a novel attention mechanism, we
share here some insights gained from applying it in various
settings in order to help practitioners try it on their own
problems:

• The recursive structure of computing αi,j in eq. (9) can
result in exploding gradients. We found it vital to apply
gradient clipping in all of our experiments, as described
in appendix D.

• Many automatic differentiation packages can produce
numerically unstable gradients when using their cumula-
tive product function.67 Our simple solution was to com-
pute the product in log-space, i.e. replacing (cid:81)
n xn =
exp((cid:80)

i log(xn)).

• In addition, the product in the denominator of eq. (29)
can become negligibly small because the terms (1 −
pi,k−1) all fall in the range [0, 1]. The simplest way to
prevent the resulting numerical instabilities is to clip the
range of the denominator to be within [(cid:15), 1] where (cid:15) is a
small constant (we used (cid:15) = 10−10). This can result in
incorrect values for αi,j particularly when some pi,j are
close to 1, but we encountered no discernible effect on
our results.

• Alternatively, we found in preliminary experiments that
simply setting the denominator to 1 still produced good
results. This can be explained by the observation that
when all pi,j ∈ {0, 1} (which we encourage during train-
ing), eq. (29) is equivalent to the recurrence relation of
eq. (10) even when the denominator is 1.

• As we mention in the experiment details of the previous
section, we ended up using a small range of values for
the initial energy function scalar bias r. In general, per-
formance was not very sensitive to this parameter, but
we found small performance gains from using values in
{−5, −4, −3, −2, −1} for different problems.

• More broadly, while the attention energy function mod-
iﬁcations described in section 2.4 allowed models using
our mechanism to be effectively trained on all tasks we

5https://github.com/craffel/mad
6https://github.com/tensorflow/

tensorflow/issues/3862

7https://github.com/Theano/Theano/issues/

5197

Figure 8. Speedup of hard monotonic attention mechanism com-
pared to softmax attention on a synthetic benchmark.

Measuring the speed of the attention mechanisms alone al-
lows us to isolate the difference in computational cost be-
tween the two approaches.

Speciﬁcally, we implemented both attention mechanisms
using the highly-efﬁcient C++ linear algebra package Eigen
(Guennebaud et al., 2010). We set entries of the mem-
ory h and the decoder hidden states si to random vectors
with entries sampled uniformly in the range [−1, 1]. We
then computed context vectors following eqs. (2) and (3)
for the softmax attention mechanism and following algo-
rithm 1 for hard monotonic attention. We varied the input
and output sequence lengths and averaged the time to pro-
duce all of the corresponding context vectors over 100 trials
for each setting.

The speedup of the monotonic attention mechanism com-
pared to softmax attention is visualized in ﬁg. 8. We found
monotonic attention to be about 4 − 40× faster depending
on the input and output sequence lengths. The most promi-
nent difference occurred for short input sequences and long
output sequences; in these cases the monotonic attention
mechanism ﬁnishes processing the input sequence before
it ﬁnishes producing the output sequence and therefore is
able to stop computing context vectors. We emphasize that
these numbers represent the best-case speedup from our
approach; a more general insight is simply that our pro-
posed hard monotonic attention mechanism has the poten-
tial to make decoding signiﬁcantly more efﬁcient for long
sequences. Additionally, this advantage is distinct from the
fact that our hard monotonic attention mechanism can be
used for online sequence-to-sequence problems. We also

Online and Linear-Time Attention by Enforcing Monotonic Alignments

tried, they were not always necessary for convergence.
Speciﬁcally, in speech recognition experiments the per-
formance of our model was the same using eq. (15) and
eq. (16), but for summarization experiments the mod-
els were unable to learn to utilize attention when using
eq. (15). For ease of implementation, we recommend
starting with the standard attention energy function of
eq. (15) and then applying the modiﬁcations of eq. (16)
if the model fails to utilize attention.

• It is occasionally recommended to reverse the input se-
quence prior to feeding it into sequence-to-sequence
models (Sutskever et al., 2014). This violates our as-
sumption that the input should be processed in a left-
to-right manner when computing attention, so should be
avoided.

• Finally, we highly recommend visualizing the attention
alignments αi,j over the course of training. Attention
provides valuable insight into the model’s behavior, and
failure modes can be quickly spotted (e.g. if αi,j = 0 for
all i and j).

With the above factors in mind, on all problems we studied,
we were able to replace softmax-based attention with our
novel attention and immediately achieve competitive per-
formance.

References

Abadi, Martin, Barham, Paul, Chen, Jianmin, Chen,
Zhifeng, Davis, Andy, Dean, Jeffrey, Devin, Matthieu,
Ghemawat, Sanjay, Irving, Geoffrey, Isard, Michael,
Kudlur, Manjunath, Levenberg, Josh, Monga, Rajat,
Moore, Sherry, Murray, Derek G., Steiner, Benoit,
Tucker, Paul, Vasudevan, Vijay, Warden, Pete, Wicke,
Martin, Yu, Yuan, and Zheng, Xiaoqiang. TensorFlow:
A system for large-scale machine learning. In Operating
Systems Design and Implementation, 2016.

Graves, Alex. Adaptive computation time for recurrent
arXiv preprint arXiv:1603.08983,

neural networks.
2016.

Grefenstette, Edward, Hermann, Karl Moritz, Suleyman,
Mustafa, and Blunsom, Phil. Learning to transduce with
unbounded memory. In Advances in Neural Information
Processing Systems, 2015.

Guennebaud, Gaël, Jacob, Benoıt, Avery, Philip, Bachrach,
Eigen v3.

Abraham, Barthelemy, Sebastien, et al.
http://eigen.tuxfamily.org, 2010.

Ioffe, Sergey and Szegedy, Christian. Batch normalization:
Accelerating deep network training by reducing internal
covariate shift. In International Conference on Machine
Learning, 2015.

Kingma, Diederik and Ba,

Jimmy.
method for stochastic optimization.
arXiv:1412.6980, 2014.

Adam:

A
arXiv preprint

Ladner, Richard E. and Fischer, Michael J. Parallel preﬁx
computation. Journal of the ACM (JACM), 27(4):831–
838, 1980.

Liu, Peter J. and Pan, Xin. Text summarization with Ten-

sorFlow. http://goo.gl/16RNEu, 2016.

Luong, Minh-Thang and Manning, Christopher D. Stan-
ford neural machine translation systems for spoken lan-
In International Workshop on Spoken
guage domain.
Language Translation, 2015.

Pham, Vu, Bluche, Théodore, Kermorvant, Christopher,
and Louradour, Jérôme. Dropout improves recurrent
neural networks for handwriting recognition. In Interna-
tional Conference on Frontiers in Handwriting Recogni-
tion, 2014.

Bengio, Yoshua, Léonard, Nicholas, and Courville, Aaron.
Estimating or propagating gradients through stochastic
arXiv preprint
neurons for conditional computation.
arXiv:1308.3432, 2013.

Rush, Alexander M., Chopra, Sumit, and Weston, Jason. A
neural attention model for abstractive sentence summa-
rization. In Conference on Empirical Methods in Natural
Language Processing, 2015.

Chorowski, Jan and Jaitly, Navdeep. Towards better decod-
ing and language model integration in sequence to se-
quence models. arXiv preprint arXiv:1612.02695, 2017.

Sutskever, Ilya, Vinyals, Oriol, and Le, Quoc V. Sequence
to sequence learning with neural networks. In Advances
in neural information processing systems, 2014.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

7
1
0
2
 
n
u
J
 
9
2
 
 
]

G
L
.
s
c
[
 
 
2
v
4
8
7
0
0
.
4
0
7
1
:
v
i
X
r
a

Colin Raffel 1 Minh-Thang Luong 1 Peter J. Liu 1 Ron J. Weiss 1 Douglas Eck 1

Abstract

Recurrent neural network models with an atten-
tion mechanism have proven to be extremely
effective on a wide variety of sequence-to-
sequence problems. However, the fact that soft
attention mechanisms perform a pass over the
entire input sequence when producing each el-
ement in the output sequence precludes their use
in online settings and results in a quadratic time
complexity. Based on the insight that the align-
ment between input and output sequence ele-
ments is monotonic in many problems of interest,
we propose an end-to-end differentiable method
for learning monotonic alignments which, at test
time, enables computing attention online and in
linear time. We validate our approach on sen-
tence summarization, machine translation, and
online speech recognition problems and achieve
results competitive with existing sequence-to-
sequence models.

1. Introduction

the

“sequence-to-sequence”

Recently,
framework
(Sutskever et al., 2014; Cho et al., 2014) has facilitated
the use of recurrent neural networks (RNNs) on sequence
transduction problems such as machine translation and
speech recognition. In this framework, an input sequence
is processed with an RNN to produce an “encoding”; this
encoding is then used by a second RNN to produce the
target sequence. As originally proposed, the encoding is
a single ﬁxed-length vector representation of the input
sequence. This requires the model to effectively compress
all important information about the input sequence into a
single vector. In practice, this often results in the model
having difﬁculty generalizing to longer sequences than
those seen during training (Bahdanau et al., 2015).

An effective solution to these shortcomings are attention

1Google Brain, Mountain View, California, USA. Correspon-

dence to: Colin Raffel <craffel@gmail.com>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

In a sequence-to-
mechanisms (Bahdanau et al., 2015).
sequence model with attention, the encoder produces a se-
quence of hidden states (instead of a single ﬁxed-length
vector) which correspond to entries in the input sequence.
The decoder is then allowed to refer back to any of the en-
coder states as it produces its output. Similar mechanisms
have been used as soft addressing schemes in memory-
augmented neural network architectures (Graves et al.,
2014; Sukhbaatar et al., 2015) and RNNs used for sequence
generation (Graves, 2013). Attention-based sequence-to-
sequence models have proven to be extremely effective on
a wide variety of problems, including machine translation
(Bahdanau et al., 2015; Luong et al., 2015), image cap-
tioning (Xu et al., 2015), speech recognition (Chorowski
et al., 2015; Chan et al., 2016), and sentence summariza-
tion (Rush et al., 2015). In addition, attention creates an
implicit soft alignment between entries in the output se-
quence and entries in the input sequence, which can give
useful insight into the model’s behavior.

A common criticism of soft attention is that the model must
perform a pass over the entire input sequence when pro-
ducing each element of the output sequence. This results
in the decoding process having complexity O(T U ), where
T and U are the input and output sequence lengths respec-
tively. Furthermore, because the entire sequence must be
processed prior to outputting any symbols, soft attention
cannot be used in “online” settings where output sequence
elements are produced when the input has only been par-
tially observed.

The focus of this paper is to propose an alternative at-
tention mechanism which has linear-time complexity and
can be used in online settings. To achieve this, we ﬁrst
note that in many problems, the input-output alignment is
roughly monotonic. For example, when transcribing an
audio recording of someone saying “good morning”, the
region of the speech utterance corresponding to “good”
will always precede the region corresponding to “morn-
ing”. Even when the alignment is not strictly monotonic,
it often only contains local input-output reorderings. Sep-
arately, despite the fact that soft attention allows for as-
signment of focus to multiple disparate entries of the input
sequence, in many cases the attention is assigned mostly to
a single entry. For examples of alignments with these char-
acteristics, we refer to e.g. (Chorowski et al. 2015 Figure

Online and Linear-Time Attention by Enforcing Monotonic Alignments

2; Chan et al. 2016 Figure 2; Rush et al. 2015 Figure 1;
Bahdanau et al. 2015 Figure 3), etc. Of course, this is not
true in all problems; for example, when using soft attention
for image captioning, the model will often change focus
arbitrarily between output steps and will spread attention
across large regions of the input image (Xu et al., 2015).

Motivated by these observations, we propose using hard
monotonic alignments for sequence-to-sequence problems
because, as we argue in section 2.2, they enable computing
attention online and in linear time. Towards this end, we
show that it is possible to train such an attention mecha-
nism with a quadratic-time algorithm which computes its
expected output. This allows us to continue using standard
backpropagation for training while still facilitating efﬁcient
online decoding at test-time. On all problems we studied,
we found these added beneﬁts only incur a small decrease
in performance compared to softmax-based attention.

The rest of this paper is structured as follows: In the follow-
ing section, we develop an interpretation of soft attention as
optimizing a stochastic process in expectation and formu-
late a corresponding stochastic process which allows for
online and linear-time decoding by relying on hard mono-
tonic alignments. In analogy with soft attention, we then
show how to compute the expected output of the mono-
tonic attention process and elucidate how the resulting al-
gorithm differs from standard softmax attention. After giv-
ing an overview of related work, we apply our approach to
the tasks of sentence summarization, machine translation,
and online speech recognition, achieving results competi-
tive with existing sequence-to-sequence models. Finally,
we present additional derivations, experimental details, and
ideas for future research in the appendix.

2. Online and Linear-Time Attention

To motivate our approach, we ﬁrst point out that softmax-
based attention is computing the expected output of a sim-
ple stochastic process. We then detail an alternative process
which enables online and linear-time decoding. Because
this process is nondifferentiable, we derive an algorithm for
computing its expected output, allowing us to train a model
with standard backpropagation while applying our online
and linear-time process at test time. Finally, we propose
an alternative energy function motivated by the differences
between monotonic attention and softmax-based attention.

2.1. Soft Attention

To begin with, we review the commonly-used form of
soft attention proposed originally in (Bahdanau et al.,
2015). Broadly, a sequence-to-sequence model produces
a sequence of outputs based on a processed input se-
quence. The model consists of two RNNs, referred to

as the “encoder” and “decoder”. The encoder RNN pro-
cesses the input sequence x = {x1, . . . , xT } to produce
a sequence of hidden states h = {h1, . . . , hT }. We re-
fer to h as the “memory” to emphasize its connection to
memory-augmented neural networks (Graves et al., 2014;
Sukhbaatar et al., 2015). The decoder RNN then produces
an output sequence y = {y1, . . . , yU }, conditioned on the
memory, until a special end-of-sequence token is produced.

When computing yi, a soft attention-based decoder uses a
learnable nonlinear function a(·) to produce a scalar value
ei,j for each entry hj in the memory based on hj and the de-
coder’s state at the previous timestep si−1. Typically, a(·)
is a single-layer neural network using a tanh nonlinearity,
but other functions such as a simple dot product between
si−1 and hj have been used (Luong et al., 2015; Graves
et al., 2014). These scalar values are normalized using the
softmax function to produce a probability distribution over
the memory, which is used to compute a context vector ci as
the weighted sum of h. Because items in the memory have
a sequential correspondence with items in the input, these
attention distributions create a soft alignment between the
output and input. Finally, the decoder updates its state to si
based on si−1 and ci and produces yi. In total, producing
yi involves

ei,j = a(si−1, hj)

αi,j = exp(ei,j)

exp(ei,k)

(cid:30) T

(cid:88)

k=1

ci =

αi,jhj

T
(cid:88)

j=1

si = f (si−1, yi−1, ci)
yi = g(si, ci)

(1)

(2)

(3)

(4)

(5)

where f (·) is a recurrent neural network (typically one or
more LSTM (Hochreiter & Schmidhuber, 1997) or GRU
(Chung et al., 2014) layers) and g(·) is a learnable nonlinear
function which maps the decoder state to the output space
(e.g. an afﬁne transformation followed by a softmax when
the target sequences consist of discrete symbols).

To motivate our monotonic alignment scheme, we observe
that eqs. (2) and (3) are computing the expected output of
a simple stochastic process, which can be formulated as
follows: First, a probability αi,j is computed independently
for each entry hj of the memory. Then, a memory index k
is sampled by k ∼ Categorical(αi) and ci is set to hk. We
visualize this process in ﬁg. 1. Clearly, eq. (3) shows that
soft attention replaces sampling k and assigning ci = hk
with direct computation of the expected value of ci.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

the

stochastic process underlying
Figure 1. Schematic of
softmax-based attention decoders.
Each node represents a
possible alignment between an entry of the output sequence
(vertical axis) and the memory (horizontal axis). At each output
timestep, the decoder inspects all memory entries (indicated in
gray) and attends to a single one (indicated in black). A black
node indicates that memory element hj is aligned to output yi. In
terms of which memory entry is chosen, there is no dependence
across output timesteps or between memory entries.

Figure 2. Schematic of our novel monotonic stochastic decoding
process. At each output timestep, the decoder inspects memory
entries (indicated in gray) from left-to-right starting from where
it left off at the previous output timestep and chooses a single
one (indicated in black). A black node indicates that memory
element hj is aligned to output yi. White nodes indicate that a
particular input-output alignment was not considered because it
violates monotonicity. Arrows indicate the order of processing
and dependence between memory entries and output timesteps.

2.2. A Hard Monotonic Attention Process

The discussion above makes clear that softmax-based at-
tention requires a pass over the entire memory to compute
the terms αi,j required to produce each element of the out-
put sequence. This precludes its use in online settings, and
results in a complexity of O(T U ) for generating the out-
put sequence. In addition, despite the fact that h represents
a transformation of a sequence (which ostensibly exhibits
dependencies between subsequent elements), the attention
probabilities are computed independent of temporal order
and the attention distribution at the previous timestep.

We address these shortcomings by ﬁrst formulating a
stochastic process which explicitly processes the memory
in a left-to-right manner. Speciﬁcally, for output timestep
i we begin processing memory entries from index ti−1,
where ti is the index of the memory entry chosen at output
timestep i (for convenience, letting t0 = 1). We sequen-
tially compute, for j = ti−1, ti−1 + 1, ti−1 + 2, . . .

ei,j = a(si−1, hj)
pi,j = σ(ei,j)
zi,j ∼ Bernoulli(pi,j)

(6)

(7)

(8)

where a(·) is a learnable deterministic “energy function”
and σ(·) is the logistic sigmoid function. As soon as we
sample zi,j = 1 for some j, we stop and set ci = hj
and ti = j, “choosing” memory entry j for the context
vector. Each zi,j can be seen as representing a discrete
choice of whether to ingest a new item from the memory
(zi,j = 0) or produce an output (zi,j = 1). For all sub-

sequent output timesteps, we repeat this process, always
starting from ti−1 (the memory index chosen at the previ-
ous timestep). If for any output timestep i we have zi,j = 0
for j ∈ {ti−1, . . . , T }, we simply set ci to a vector of ze-
ros. This process is visualized in ﬁg. 2 and is presented
more explicitly in algorithm 1 (appendix A).

Note that by construction, in order to compute pi,j, we only
need to have computed hk for k ∈ {1, . . . , j}. It follows
that our novel process can be computed in an online man-
ner; i.e. we do not need to wait to observe the entire input
sequence before we start producing the output sequence.
Furthermore, because we start inspecting memory elements
from where we left off at the previous output timestep (i.e.
at index ti−1), the resulting process only computes at most
max(T, U ) terms pi,j, giving it a linear runtime. Of course,
it also makes the strong assumption that the alignment be-
tween the input and output sequence is strictly monotonic.

2.3. Training in Expectation

The online alignment process described above involves
sampling, which precludes the use of standard backpropa-
gation. In analogy with softmax-based attention, we there-
fore propose training with respect to the expected value of
ci, which can be computed straightforwardly as follows.
We ﬁrst compute ei,j and pi,j exactly as in eqs. (6) and (7),
where pi,j are interpreted as the probability of choosing
memory element j at output timestep i. The attention dis-
tribution over the memory is then given by (see appendix C

Online and Linear-Time Attention by Enforcing Monotonic Alignments

for a derivation)

αi,j = pi,j

αi−1,k

(1 − pi,l)

(9)

(cid:32)

j
(cid:88)

k=1
(cid:18)

(cid:33)

(cid:19)

j−1
(cid:89)

l=k
αi,j−1
pi,j−1

= pi,j

(1 − pi,j−1)

+ αi−1,j

(10)

We provide a solution to the recurrence relation of eq. (10)
which allows computing αi,j for j ∈ {1, . . . , T } in parallel
with cumulative sum and cumulative product operations in
appendix C.1. Deﬁning qi,j = αi,j/pi,j gives the following
procedure for computing αi,j:

ei,j = a(si−1, hj)
pi,j = σ(ei,j)
qi,j = (1 − pi,j−1)qi,j−1 + αi−1,j
αi,j = pi,jqi,j

(11)

(12)

(13)

(14)

where we deﬁne the special cases of qi,0 = 0, pi,0 = 0
to maintain equivalence with eq. (9). As in softmax-
based attention, the αi,j values produce a weighting over
the memory, which are then used to compute the con-
text vector at each timestep as in eq. (3). However, note
that αi may not be a valid probability distribution because
(cid:80)
j αi,j ≤ 1. Using αi as-is, without normalization, ef-
fectively associates any additional probability not allocated
to memory entries to an additional all-zero memory loca-
tion. Normalizing αi so that (cid:80)T
j=1 αi,j = 1 has two issues:
First, we can’t perform this normalization at test time and
still achieve online decoding because the normalization de-
pends on αi,j for j ∈ {1, . . . , T }, and second, it would re-
sult in a mismatch compared to the probability distribution
induced by the hard monotonic attention process which sets
ci to a vector of zeros when zi,j = 0 for j ∈ {ti−1, . . . , T }.

Note that computing ci still has a quadratic complexity be-
cause we must compute αi,j for j ∈ {1, . . . , T } for each
output timestep i. However, because we are training di-
rectly with respect to the expected value of ci, we will train
our decoders using eqs. (11) to (14) and then use the on-
line, linear-time attention process of section 2.2 at test time.
Furthermore, if pi,j ∈ {0, 1} these approaches are equiva-
lent, so in order for the model to exhibit similar behavior at
training and test time, we need pi,j ≈ 0 or pi,j ≈ 1. We
address this in section 2.5.

2.4. Modiﬁed Energy Function

While various “energy functions” a(·) have been proposed,
the most common to our knowledge is the one proposed in
(Bahdanau et al., 2015):

a(si−1, hj) = v(cid:62) tanh(W si−1 + V hj + b)

(15)

where W and V are weight matrices, b is a bias vector,1
and v is a weight vector. We make two modiﬁcations to
eq. (15) for use with our monotonic decoder: First, while
the softmax is invariant to offset,2 the logistic sigmoid is
not. As a result, we make the simple modiﬁcation of adding
a scalar variable r after the tanh function, allowing the
model to learn the appropriate offset for the pre-sigmoid
activations. Note that eq. (13) tends to exponentially de-
cay attention over the memory because 1 − pi,j ∈ [0, 1];
we therefore initialized r to a negative value prior to train-
ing so that 1 − pi,j tends to be close to 1. Second, the
use of the sigmoid nonlinearity in eq. (12) implies that our
mechanism is particularly sensitive to the scale of the en-
ergy terms ei,j, or correspondingly, the scale of the energy
vector v. We found an effective solution to this issue was
to apply weight normalization (Salimans & Kingma, 2016)
to v, replacing it by gv/(cid:107)v(cid:107) where g is a scalar parame-
ter. Initializing g to the inverse square root of the attention
hidden dimension worked well for all problems we studied.

The above produces the energy function

a(si−1, hj) = g

tanh(W si−1 + V hj + b) + r (16)

v(cid:62)
(cid:107)v(cid:107)

The addition of the two scalar parameters g and r prevented
the issues described above in all our experiments while in-
curring a negligible increase in the number of parameters.

2.5. Encouraging Discreteness

As mentioned above, in order for our mechanism to exhibit
similar behavior when training in expectation and when us-
ing the hard monotonic attention process at test time, we
require that pi,j ≈ 0 or pi,j ≈ 1. A straightforward way to
encourage this behavior is to add noise before the sigmoid
in eq. (12), as was done e.g. in (Frey, 1997; Salakhutdinov
& Hinton, 2009; Foerster et al., 2016). We found that sim-
ply adding zero-mean, unit-variance Gaussian noise to the
pre-sigmoid activations was sufﬁcient in all of our exper-
iments. This approach is similar to the recently proposed
Gumbel-Softmax trick (Jang et al., 2016; Maddison et al.,
2016), except we did not ﬁnd it necessary to anneal the
temperature as suggested in (Jang et al., 2016).

Note that once we have a model which produces pi,j which
are effectively discrete, we can eschew the sampling in-
volved in the process of section 2.2 and instead simply set
zi,j = I(pi,j > τ ) where I is the indicator function and τ
is a threshold. We used this approach in all of our exper-
iments, setting τ = 0.5. Furthermore, at test time we do
not add pre-sigmoid noise, making decoding purely deter-

1b is occasionally omitted, but we found it often improves per-
formance and only incurs a modest increase in parameters, so we
include it.

2That is, softmax(e) = softmax(e + r) for any r ∈ R.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

ministic. Combining all of the above, we present our dif-
ferentiable approach to training the monotonic alignment
decoder in algorithm 2 (appendix A).

3. Related Work

(Luo et al., 2016) and (Zaremba & Sutskever, 2015) both
study a similar framework in which a decoder RNN can
decide whether to ingest another entry from the input se-
quence or emit an entry of the output sequence. Instead of
training in expectation, they maintain the discrete nature of
this decision while training and use reinforcement learning
(RL) techniques. We initially experimented with RL-based
training methods but were unable to ﬁnd an approach which
worked reliably on the different tasks we studied. Empir-
ically, we also show superior performance to (Luo et al.,
2016) on online speech recognition tasks; we did not at-
tempt any of the tasks from (Zaremba & Sutskever, 2015).
(Aharoni & Goldberg, 2016) also study hard monotonic
alignments, but their approach requires target alignments
computed via a separate statistical alignment algorithm in
order to be trained.

As an alternative approach to monotonic alignments, Con-
nectionist Temporal Classiﬁcation (CTC) (Graves et al.,
2006) and the RNN Transducer (Graves, 2012) both as-
sume that the output sequences consist of symbols, and add
an additional “null” symbol which corresponds to “produce
no output”. More closely to our model, (Yu et al., 2016b)
similarly add “shift” and “emit” operations to an RNN. Fi-
nally, the Segmental RNN (Kong et al., 2015) treats a seg-
mentation of the input sequence as a latent random variable.
In all cases, the alignment path is marginalized out via a
dynamic program in order to obtain a conditional probabil-
ity distribution over label sequences and train directly with
maximum likelihood. These models either require condi-
tional independence assumptions between output symbols
or don’t condition the decoder (language model) RNN on
the input sequence. We instead follow the framework of
attention and marginalize out alignment paths when com-
puting the context vectors ci which are subsequently fed
into the decoder RNN, which allows the decoder to condi-
tion on its past output as well as the input sequence. Our
approach can therefore be seen as a marriage of these CTC-
style techniques and attention. Separately, instead of per-
forming an approximate search for the most probable out-
put sequence at test time, we use hard alignments which
facilitates linear-time decoding.

A related idea is proposed in (Raffel & Lawson, 2017),
where “subsampling” probabilities are assigned to each en-
try in the memory and a stochastic process is formulated
which involves keeping or discarding entries from the input
sequence according to the subsampling probabilities. A dy-
namic program similar to the one derived in section 2.3 is

then used to compute the expected output which allows for
training with standard backpropagation. Our approach dif-
fers in that we utilize an RNN decoder to construct the out-
put sequence, and furthermore allows for output sequences
which are longer than the input.

Some similar ideas to those in section 2.3 were proposed
in the context of speech recognition in (Chorowski et al.,
2015): First, the prior attention distributions are convolved
with a bank of one-dimensional ﬁlters and then included in
the energy function calculation. Second, instead of com-
puting attention over the entire memory they only compute
it over a sliding window. This reduces the runtime com-
plexity at the expense of the strong assumption that mem-
ory locations attended to at subsequent output timesteps fall
within a small window of one another. Finally, they also
advocate replacing the softmax function with a sigmoid,
but they then normalize by the sum of these sigmoid acti-
vations across the memory window instead of interpreting
these probabilities in the left-to-right framework we use.
While these modiﬁcations encourage monotonic attention,
they do not explicitly enforce it, and so the authors do not
investigate online decoding.

In a similar vein, (Luong et al., 2015) explore only comput-
ing attention over a small window of the memory. In addi-
tion to simply monotonically increasing the window loca-
tion at each output timestep, they also consider learning
a policy for producing the center of the memory window
based on the current decoder state.

(Kim et al., 2017) also make the connection between soft
attention and selecting items from memory in expectation.
They consider replacing the softmax in standard soft atten-
tion with an elementwise sigmoid nonlinearity, but do not
formulate the interpretation of addressing memory from
left-to-right and the corresponding probability distributions
as we do in section 2.3.

(Jaitly et al., 2015) apply standard softmax attention in on-
line settings by splitting the input sequence into chunks and
producing output tokens using the attentive sequence-to-
sequence framework over each chunk. They then devise a
dynamic program for ﬁnding the approximate best align-
ment between the model output and the target sequence.
In contrast, our ingest/emit probabilities pi,j can be seen as
adaptively chunking the input sequence (rather than provid-
ing a ﬁxed setting of the chunk size) and we instead train by
exactly computing the expectation over alignment paths.

4. Experiments

To validate our proposed approach for learning mono-
tonic alignments, we applied it to a variety of sequence-
to-sequence problems: sentence summarization, machine
translation, and online speech recognition. In the follow-

Online and Linear-Time Attention by Enforcing Monotonic Alignments

ing subsections, we give an overview of the models used
and the results we obtained; for more details about hy-
perparamers and training speciﬁcs please see appendix D.
Incidentally, all experiments involved predicting discrete
symbols (e.g. phonemes, characters, or words); as a result,
the output of the decoder in each of our models was fed
into an afﬁne transformation followed by a softmax non-
linearity with a dimensionality corresponding to the num-
ber of possible symbols. At test time, we performed a
beam search over softmax predictions on all problems ex-
cept machine translation. All networks were trained using
standard cross-entropy loss with teacher forcing against tar-
get sequences using the Adam optimizer (Kingma & Ba,
2014). All of our decoders used the monotonic attention
mechanism of section 2.3 during training to address the
hidden states of the encoder. For comparison, we report
test-time results using both the hard linear-time decoding
method of section 2.2 and the “soft” monotonic attention
distribution. We also present the results of a synthetic
benchmark we used to measure the potential speedup of-
fered by our linear-time decoding process in appendix F.

Online Speech Recognition Online speech recognition
involves transcribing the words spoken in a speech utter-
ance in real-time, i.e. as a person is talking. This problem
is a natural application for monotonic alignments because
online decoding is an explicit requirement. In addition, this
precludes the use of bidirectional RNNs, which degrades
performance somewhat (Graves et al., 2013). We tested our
approach on two datasets: TIMIT (Garofolo et al., 1993)
and the Wall Street Journal corpus (Paul & Baker, 1992).

Speech recognition on the TIMIT dataset involves tran-
scribing the phoneme sequence underlying a given speech
utterance.
Speech utterances were represented as se-
quences of 40-ﬁlter (plus energy) mel-ﬁlterbank spectra,
computed every 10 milliseconds, with delta- and delta-
delta-features. Our encoder RNN consisted of three uni-
directional LSTM layers. Following (Chan et al., 2016),
after the ﬁrst and second LSTM layer we placed time re-
duction layers which skip every other sequence element.
Our decoder RNN was a single unidirectional LSTM. Our
output softmax had 62 dimensions, corresponding to the
60 phonemes from TIMIT plus special start-of-sequence
and end-of-sequence tokens. At test time, we utilized a
beam search over softmax predictions, with a beam width
of 10. We report the phone error rate (PER) after apply-
ing the standard mapping to 39 phonemes (Graves et al.,
2013). We used the standard train/validation/test split and
report results on the test set.

Our model’s performance, with a comparison to other on-
line approaches, is shown in table 1. We achieve better
performance than recently proposed sequence-to-sequence
models (Luo et al., 2016; Jaitly et al., 2015), though the

Table 1. Phone error rate on the TIMIT dataset for different online
methods.

Method

(Luo et al., 2016) (stacked LSTM)
(Jaitly et al., 2015) (end-to-end)
(Luo et al., 2016) (grid LSTM)
Hard Monotonic Attention (ours)
Soft Monotonic Attention (ours, ofﬂine)
(Graves et al., 2013) (CTC)

PER

21.5%
20.8%
20.5%
20.4%
20.1%
19.6%

small size of the TIMIT dataset and the resulting variabil-
ity of results precludes making substantiative claims about
one approach being best. We note that (Jaitly et al., 2015)
were able to improve performance by precomputing align-
ments using an HMM system and providing them as a su-
pervised signal to their decoder; we did not experiment
with this idea. CTC (Graves et al., 2013) still outperforms
all sequence-to-sequence models.
In addition, there re-
mains a substantial gap between these online results and
ofﬂine results using bidirectional LSTMs, e.g. (Chorowski
et al., 2015) achieves a 17.6% phone error rate using a
softmax-based attention mechanism and (Graves et al.,
2013) achieved 17.7% using a pre-trained RNN transducer
model. We are interested in investigating ways to close this
gap in future work.

Because of the size of the dataset, performance on TIMIT is
often highly dependent on appropriate regularization. We
therefore also evaluated our approach on the Wall Street
Journal (WSJ) speech recognition dataset, which is about
10 times larger. For the WSJ corpus, we present speech
utterances to the network as 80-ﬁlter mel-ﬁlterbank spec-
tra with delta- and delta-delta features, and normalized us-
ing per-speaker mean and variance computed ofﬂine. The
model architecture is a variation of that from (Zhang et al.,
2016), using an 8 layer encoder including:
two convo-
lutional layers which downsample the sequence in time,
followed by one unidirectional convolutional LSTM layer,
and ﬁnally a stack of three unidirectional LSTM layers in-
terleaved with linear projection layers and batch normal-
ization. The encoder output sequence is consumed by the
proposed online attention mechanism which is passed into
a decoder consisting of a single unidirectional LSTM layer
followed by a softmax layer.

Our output softmax predicted one of 49 symbols, consist-
ing of alphanumeric characters, punctuation marks, and
start-of sequence, end-of-sequence, “unknown”, “noise”,
and word delimiter tokens. We utilized label smoothing
during training (Chorowski & Jaitly, 2017), replacing the
targets at time yt with a convex weighted combination of
the surrounding ﬁve labels (full details in appendix D.1.2).
Performance was measured in terms of word error rate
(WER) on the test set after segmenting the model’s predic-

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Table 2. Word error rate on the WSJ dataset. All approaches used
a unidirectional encoder; results in grey indicate ofﬂine models.

Method

CTC (our model)
(Luo et al., 2016) (hard attention)
(Wang et al., 2016) (CTC)
Hard Monotonic Attention (our model)
Soft Monotonic Attention (our model)
Softmax Attention (our model)

WER

33.4%
27.0%
22.7%
17.4%
16.5%
16.0%

tions according to the word delimiter tokens. We used the
standard dataset split of si284 for training, dev93 for vali-
dation, and eval92 for testing. We did not use a language
model to improve decoding performance.

Our results on WSJ are shown in table 2. Our model, with
hard monotonic decoding, achieved a signiﬁcantly lower
WER than the other online methods. While these ﬁgures
show a clear advantage to our approach, our model ar-
chitecture differed signiﬁcantly from those of (Luo et al.,
2016; Wang et al., 2016). We therefore additionally mea-
sured performance against a baseline model which was
identical to our model except that it used softmax-based
attention (which makes it quadratic-time and ofﬂine) in-
stead of a monotonic alignment decoder. This resulted in
a small decrease of 1.4% WER, suggesting that our hard
monotonic attention approach achieves competitive perfor-
mance while being substantially more efﬁcient. To get a
qualitative picture of our model’s behavior compared to the
softmax-attention baseline, we plot each model’s input-
output alignments for two example speech utterances in
ﬁg. 4 (appendix B). Both models learn roughly the same
alignment, with some minor differences caused by ours be-
ing both hard and strictly monotonic.

Sentence Summarization Speech recognition exhibits
a strictly monotonic input-output alignment. We are in-
terested in testing whether our approach is also effective
on problems which only exhibit approximately monotonic
alignments. We therefore ran a “sentence summarization”
experiment using the Gigaword corpus, which involves pre-
dicting the headline of a news article from its ﬁrst sentence.

Overall, we used the model of (Liu & Pan, 2016), modi-
fying it only so that it used our monotonic alignment de-
coder instead of a soft attention decoder. Because online
decoding is not important for sentence summarization, we
utilized bidirectional RNNs in the encoder for this task
(as is standard). We expect that the bidirectional RNNs
will give the model local context which may help allow
for strictly monotonic alignments. The model both took
as input and produced as output one-hot representations of
the word IDs, with a vocabulary of the 200,000 most com-
mon words in the training set. Our encoder consisted of

Table 3. ROUGE F-measure scores for sentence summarization
on the Gigaword test set of (Rush et al., 2015).
(Rush et al.,
2015) reports ROUGE recall scores, so we report the F-1 scores
computed for that approach from (Chopra et al., 2016). As is
standard, we report unigram, bigram, and longest common subse-
quence metrics as R-1, R-2, and R-L respectively.

Method

R-1

R-2

R-L

(Zeng et al., 2016)
(Rush et al., 2015)
(Yu et al., 2016b)
(Chopra et al., 2016)
(Miao & Blunsom, 2016)
(Nallapati et al., 2016)
(Yu et al., 2016a)
(Suzuki & Nagata, 2017)
Hard Monotonic (ours)
Soft Monotonic (ours)
(Liu & Pan, 2016)

27.82
29.76
30.27
33.78
34.17
34.19
34.41
36.30
37.14
38.03
38.22

12.74
11.88
13.68
15.97
15.94
16.29
16.86
17.31
18.00
18.57
18.70

26.01
26.96
27.91
31.15
31.92
32.13
31.83
33.88
34.87
35.70
35.74

Figure 3. Example sentence-summary pair with attention align-
ments for our hard monotonic model and the softmax-based at-
tention model of (Liu & Pan, 2016). Attention matrices are dis-
played so that black corresponds to 1 and white corresponds to
0. The ground-truth summary is “greece pumps more money and
personnel into bird ﬂu defense”.

a word embedding matrix (which was initialized randomly
and trained as part of the model) followed by four bidirec-
tional LSTM layers. We used a single LSTM layer for the
decoder. For data preparation and evaluation, we followed
the approach of (Rush et al., 2015), measuring performance
using the ROUGE metric.

Our results, along with the scores achieved by other ap-
proaches, are presented in table 3. While the monotonic
alignment model outperformed existing models by a sub-
stantial margin, it fell slightly behind the model of (Liu
& Pan, 2016) which we used as a baseline. The higher
performance of our model and the model of (Liu & Pan,
2016) can be partially explained by the fact that their en-
coders have roughly twice as many layers as most models
proposed in the literature.

For qualitative evaluation, we plot an example input-output

Online and Linear-Time Attention by Enforcing Monotonic Alignments

pair and alignment matrices for our hard monotonic atten-
tion model and the softmax-attention baseline of (Liu &
Pan, 2016) in ﬁg. 3 (an additional example is shown in
ﬁg. 6, appendix B). Most apparent is that a given word
in the summary is not always aligned to the most obvi-
ous word in the input sentence; the hard monotonic de-
coder aligns the ﬁrst four words in the summary reason-
ably (greek ↔ greek, government ↔ ﬁnance, approves ↔
approved, more ↔ more), but the latter four words have
unexpected alignments (funds ↔ in, to ↔ for, bird ↔ mea-
sures, bird ↔ ﬂu). We believe this is due to the ability of
the multilayer bidirectional RNN encoder to reorder words
in the input sequence. This effect is also apparent in ﬁg. 6/
(appendix B), where the monotonic alignment decoder is
able to produce the phrase “human rights criticism” despite
the fact that the input sentence has the phrase “criticism
of human rights”. Separately, we note that the softmax
attention model’s alignments are extremely “soft” and non-
monotonic; this may be advantageous for this problem and
partially explain its slightly superior performance.

Machine Translation We also evaluated our approach
on machine translation, another task which does not exhibit
strictly monotonic alignments. In fact, for some language
pairs (e.g. English and Japanese, English and Korean), we
do not expect monotonicity at all. However, for other pairs
(e.g. English and French, English and Vietnamese) only
local word reorderings are required. Our translation ex-
periments therefore involved English to Vietnamese trans-
lation using the parallel corpus of TED talks (133K sen-
tence pairs) provided by the IWSLT 2015 Evaluation Cam-
paign (Cettolo et al., 2015). Following (Luong & Manning,
2015), we tokenize the corpus with the default Moses tok-
enizer, preserve casing, and replace words whose frequen-
cies are less than 5 by <unk>. As a result, our vocab-
ulary sizes are 17K and 7.7K for English and Vietnamese
respectively. We use the TED tst2012 (1553 sentences) as a
validation set for hyperparameter tuning and TED tst2013
(1268 sentences) as a test set. We report results in both
perplexity and BLEU.

Our baseline neural machine translation (NMT) system is
the softmax attention-based sequence-to-sequence model
described in (Luong et al., 2015). From that baseline, we
substitute the softmax-based attention mechanism with our
proposed monotonic alignment decoder. The model uti-
lizes two-layer unidirectional LSTM networks for both the
encoder and decoder.

In (Luong et al., 2015), the authors demonstrated that un-
der their proposed architecture, a dot product-based energy
function worked better than eq. (15). Since our architec-
ture is based on that of (Luong et al., 2015), to facilitate
comparison we also tested the following variant:

Table 4. Performance on the IWSLT 2015 English-Vietnamese
TED talks for our monotonic alignment model and the baseline
softmax-attention model of (Luong & Manning, 2015).

Method

(Luong & Manning, 2015)
Hard Monotonic, energy function eq. (16)
Hard Monotonic, energy function eq. (17)

BLEU

23.3
22.6
23.0

where g and r are scalars (initialized as in section 2.4) and
W is a weight matrix.

Our results are shown in Table 4. To get a better pic-
ture of each model’s behavior, we plot input-output align-
ments in ﬁg. 5 (appendix B). Most noticeable is that the
monotonic alignment model tends to focus attention later
in the input sequence than the baseline softmax-attention
model. We hypothesize that this is a way to compensate
for non-monotonic alignments when a unidirectional en-
coder is used; i.e. the model has effectively learned to fo-
cus on words at the end of phrases which require reorder-
ing, at which point the unidirectional encoder has observed
the whole phrase. This can be seen most clearly in the
example on the right, where translating “a huge famine”
to Vietnamese requires reordering (as suggested by the
softmax-attention model’s alignment), so the hard mono-
tonic alignment model focuses attention on the ﬁnal word
in the phrase (“famine”) while producing its translation.
We suspect our model’s small decrease in BLEU compared
to the baseline model may be due in part to this increased
modeling burden.

5. Discussion

Our results show that our differentiable approach to enforc-
ing monotonic alignments can produce models which, fol-
lowing the decoding process of section 2.2, provide efﬁ-
cient online decoding at test time without sacriﬁcing sub-
stantial performance on a wide variety of tasks. We believe
our framework presents a promising environment for fu-
ture work on online and linear-time sequence-to-sequence
models. We are interested in investigating various exten-
sions to this approach, which we outline in appendix E.
To facilitate experimentation with our proposed attention
mechanism, we have made an example TensorFlow (Abadi
et al., 2016) implementation of our approach available on-
line3 and added a reference implementation to Tensor-
Flow’s tf.contrib.seq2seq module. We also pro-
vide a “practitioner’s guide” in appendix G.

a(si−1, hj) = g(s(cid:62)

i−1W h) + r

(17)

3https://github.com/craffel/mad

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Acknowledgements

We thank Jan Chorowski, Mark Daoust, Pietro Kreit-
lon Carolino, Dieterich Lawson, Navdeep Jaitly, George
Tucker, Quoc V. Le, Kelvin Xu, Cinjon Resnick, Melody
Guan, Matthew D. Hoffman, Jeffrey Dean, Kevin Swersky,
Ashish Vaswani, and members of the Google Brain team
for helpful discussions and insight.

References

Abadi, Martin, Barham, Paul, Chen, Jianmin, Chen,
Zhifeng, Davis, Andy, Dean, Jeffrey, Devin, Matthieu,
Ghemawat, Sanjay, Irving, Geoffrey, Isard, Michael,
Kudlur, Manjunath, Levenberg, Josh, Monga, Rajat,
Moore, Sherry, Murray, Derek G., Steiner, Benoit,
Tucker, Paul, Vasudevan, Vijay, Warden, Pete, Wicke,
Martin, Yu, Yuan, and Zheng, Xiaoqiang. TensorFlow:
A system for large-scale machine learning. In Operating
Systems Design and Implementation, 2016.

Aharoni, Roee and Goldberg, Yoav. Sequence to sequence
arXiv

transduction with hard monotonic attention.
preprint arXiv:1611.01487, 2016.

Bahdanau, Dzmitry, Cho, Kyunghyun, and Bengio,
Yoshua. Neural machine translation by jointly learning
In International Conference on
to align and translate.
Learning Representations, 2015.

Cettolo, Mauro, Niehues, Jan, Stüker, Sebastian, Ben-
tivogli, Luisa, Cattoni, Roldano, and Federico, Marcello.
The IWSLT 2015 evaluation campaign. In International
Workshop on Spoken Language Translation, 2015.

Chan, William, Jaitly, Navdeep, Le, Quoc V., and Vinyals,
Oriol. Listen, attend and spell: A neural network for
large vocabulary conversational speech recognition. In
International Conference on Acoustics, Speech and Sig-
nal Processing, 2016.

Cho, Kyunghyun, van Merriënboer, Bart, Gülçehre, Ça˘glar,
Bahdanau, Dzmitry, Bougares, Fethi, Schwenk, Holger,
and Bengio, Yoshua. Learning phrase representations us-
ing RNN encoder–decoder for statistical machine trans-
lation. In Conference on Empirical Methods in Natural
Language Processing, 2014.

Chopra, Sumit, Auli, Michael, and Rush, Alexander M.
Abstractive sentence summarization with attentive recur-
rent neural networks. Conference of the North American
Chapter of the Association for Computational Linguis-
tics: Human Language Technologies, 2016.

Chorowski, Jan, Bahdanau, Dzmitry, Serdyuk, Dmitriy,
Cho, Kyunghyun, and Bengio, Yoshua. Attention-based
models for speech recognition. In Conference on Neural
Information Processing Systems, 2015.

Chung, Junyoung, Gulcehre, Caglar, Cho, Kyunghyun, and
Bengio, Yoshua. Empirical evaluation of gated recurrent
neural networks on sequence modeling. arXiv preprint
arXiv:1412.3555, 2014.

Foerster, Jakob, Assael, Yannis M., de Freitas, Nando, and
Whiteson, Shimon. Learning to communicate with deep
multi-agent reinforcement learning. In Advances in Neu-
ral Information Processing Systems, 2016.

Frey, Brendan J. Continuous sigmoidal belief networks
trained using slice sampling. Advances in neural infor-
mation processing systems, 1997.

Garofolo, John S., Lamel, Lori F., Fisher, William M., Fis-
cus, Jonathon G., and Pallett, David S. DARPA TIMIT
acoustic-phonetic continous speech corpus. 1993.

Graves, Alex. Sequence transduction with recurrent neural

networks. arXiv preprint arXiv:1211.3711, 2012.

Graves, Alex. Generating sequences with recurrent neural

networks. arXiv preprint arXiv:1308.0850, 2013.

Graves, Alex, Fernández, Santiago, Gomez, Faustino, and
Schmidhuber, Jürgen. Connectionist temporal classiﬁ-
cation: labelling unsegmented sequence data with recur-
rent neural networks. In International conference on Ma-
chine learning, 2006.

Graves, Alex, Mohamed, Abdel-rahman, and Hinton, Ge-
offrey. Speech recognition with deep recurrent neural
In International Conference on Acoustics,
networks.
Speech and Signal Processing, 2013.

Graves, Alex, Wayne, Greg, and Danihelka, Ivo. Neural
turing machines. arXiv preprint arXiv:1410.5401, 2014.

Hochreiter, Sepp and Schmidhuber, Jürgen. Long short-

term memory. Neural computation, 9(8), 1997.

Jaitly, Navdeep, Sussillo, David, Le, Quoc V., Vinyals,
Oriol, Sutskever, Ilya, and Bengio, Samy. A neural trans-
ducer. arXiv preprint arXiv:1511.04868, 2015.

Jang, Eric, Gu, Shixiang, and Poole, Ben. Categorical
reparameterization with gumbel-softmax. arXiv preprint
arXiv:1611.01144, 2016.

Chorowski, Jan and Jaitly, Navdeep. Towards better decod-
ing and language model integration in sequence to se-
quence models. arXiv preprint arXiv:1612.02695, 2017.

Kim, Yoon, Denton, Carl, Hoang, Luong, and Rush,
arXiv

Alexander M. Structured attention networks.
preprint arXiv:1702.00887, 2017.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Kingma, Diederik and Ba,

Jimmy.
method for stochastic optimization.
arXiv:1412.6980, 2014.

Adam:

A
arXiv preprint

Kong, Lingpeng, Dyer, Chris, and Smith, Noah A. Seg-
arXiv preprint

mental recurrent neural networks.
arXiv:1511.06018, 2015.

Liu, Peter J. and Pan, Xin. Text summarization with Ten-

sorFlow. http://goo.gl/16RNEu, 2016.

Luo, Yuping, Chiu, Chung-Cheng, Jaitly, Navdeep, and
Learning online alignments with
arXiv preprint

Sutskever,
continuous rewards policy gradient.
arXiv:1608.01281, 2016.

Ilya.

Luong, Minh-Thang and Manning, Christopher D. Stan-
ford neural machine translation systems for spoken lan-
In International Workshop on Spoken
guage domain.
Language Translation, 2015.

Luong, Minh-Thang, Pham, Hieu, and Manning, Christo-
pher D. Effective approaches to attention-based neural
machine translation. In Conference on Empirical Meth-
ods in Natural Language Processing, 2015.

concrete distribution:

Maddison, Chris J., Mnih, Andriy, and Teh, Yee Whye.
relax-
arXiv preprint

The
ation of discrete random variables.
arXiv:1611.00712, 2016.

A continuous

Miao, Yishu and Blunsom, Phil. Language as a latent vari-
able: Discrete generative models for sentence compres-
sion. arXiv preprint arXiv:1609.07317, 2016.

Nallapati, Ramesh,

Zhou, Bowen,

dos Santos,
and Xiang,
Cícero Nogueira, Gülçehre, Çaglar,
Bing. Abstractive text summarization using sequence-
In Conference on
to-sequence RNNs and beyond.
Computational Natural Language Learning, 2016.

Paul, Douglas B. and Baker, Janet M. The design for the
Wall Street Journal-based CSR corpus. In Workshop on
Speech and Natural Language, 1992.

Salimans, Tim and Kingma, Diederik P. Weight normaliza-
tion: A simple reparameterization to accelerate training
of deep neural networks. In Advances in Neural Infor-
mation Processing Systems, 2016.

Sukhbaatar, Sainbayar, Szlam, Arthur, Weston, Jason, and
Fergus, Rob. End-to-end memory networks. In Advances
in neural information processing systems, 2015.

Sutskever, Ilya, Vinyals, Oriol, and Le, Quoc V. Sequence
to sequence learning with neural networks. In Advances
in neural information processing systems, 2014.

Suzuki, Jun and Nagata, Masaaki. Cutting-off redundant
repeating generations for neural abstractive summariza-
tion. arXiv preprint arXiv:1701.00138, 2017.

Wang, Chong, Yogatama, Dani, Coates, Adam, Han, Tony,
Hannun, Awni, and Xiao, Bo. Lookahead convolution
In
layer for unidirectional recurrent neural networks.
Workshop Extended Abstracts of the 4th International
Conference on Learning Representations, 2016.

Xu, Kelvin, Ba, Jimmy, Kiros, Ryan, Cho, Kyunghyun,
Courville, Aaron, Salakhudinov, Ruslan, Zemel, Rich,
and Bengio, Yoshua. Show, attend and tell: Neural im-
age caption generation with visual attention. In Interna-
tional Conference on Machine Learning, 2015.

Yu, Lei, Blunsom, Phil, Dyer, Chris, Grefenstette, Edward,
and Kocisky, Tomas. The neural noisy channel. arXiv
preprint arXiv:1611.02554, 2016a.

Yu, Lei, Buys, Jan, and Blunsom, Phil. Online segment to
segment neural transduction. In Conference on Empiri-
cal Methods in Natural Language Processing, 2016b.

Zaremba, Wojciech and Sutskever,

Reinforce-
ment learning neural turing machines. arXiv preprint
arXiv:1505.00521, 362, 2015.

Ilya.

Zeng, Wenyuan, Luo, Wenjie, Fidler, Sanja, and Urta-
sun, Raquel. Efﬁcient summarization with read-again
and copy mechanism. arXiv preprint arXiv:1611.03382,
2016.

Raffel, Colin and Lawson, Dieterich. Training a sub-
arXiv preprint

sampling mechanism in expectation.
arXiv:1702.06914, 2017.

Zhang, Yu, Chan, William, and Jaitly, Navdeep. Very deep
convolutional networks for end-to-end speech recogni-
tion. arXiv preprint arXiv:1610.03022, 2016.

Rush, Alexander M., Chopra, Sumit, and Weston, Jason. A
neural attention model for abstractive sentence summa-
rization. In Conference on Empirical Methods in Natural
Language Processing, 2015.

Salakhutdinov, Ruslan and Hinton, Geoffrey. Semantic
hashing. International Journal of Approximate Reason-
ing, 50(7), 2009.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

A. Algorithms

Below are algorithms for the hard monotonic decoding process we used at test time (algorithm 1) and the approach for
computing its expected output that we used to train the network (algorithm 2). Terminology matches the main text, except
we use (cid:126)0 to signify a vector of zeros.

Algorithm 1 Hard Monotonic Attention Process

Input: memory h of length T
State: s0 = (cid:126)0, t0 = 1, i = 1, y0 = StartOfSequence
while yi−1 (cid:54)= EndOfSequence do

// Produce output tokens until end-of-sequence token is produced

// Keep track of whether we chose a memory entry or not

ﬁnished = 0
for j = ti−1 to T do
ei,j = a(si−1, hj)
pi,j = σ(ei,j)
zi,j ∼ Bernoulli(pi,j)
if zi,j = 1 then // If we sample 1, we stop scanning the memory
// Set the context vector to the chosen memory entry

// Start inspecting memory entries hj left-to-right from where we left off
// Compute attention energy for hj
// Compute probability of choosing hj

// Sample whether to ingest another memory entry or output new symbol

ci = hj
ti = j
ﬁnished = 1
break // Stop scanning the memory

// Remember where we left off for the next output timestep

// Keep track of the fact that we chose a memory entry

end if
end for
if ﬁnished = 0 then

ci = (cid:126)0

end if
si = f (si−1, yi−1, ci)
yi = g(si, ci)
i = i + 1

end while

// If we scanned the entire memory without selecting anything, set ci to a vector of zeros

// Update the state based on the new context vector using the RNN f

// Output a new symbol using the softmax layer g

Algorithm 2 Soft Monotonic Attention Decoder

Input: memory h of length T , target outputs ˆy = {StartOfSequence, ˆy1, ˆy2, . . . , EndOfSequence}
State: s0 = (cid:126)0, i = 1, α0,j = δj for j ∈ {1, . . . , T }
while ˆyi−1 (cid:54)= EndOfSequence do

// Produce output tokens until end of the target sequence

pi,0 = 0, qi,0 = 0
for j = 1 to T do

// Special cases so that the recurrence relation matches eq. (9)
// Inspect all memory entries hj

ei,j = a(si−1, hj)
ei,j = ei,j + N (0, 1)
pi,j = σ(ei,j)
qi,j = (1 − pi,j−1)qi,j−1 + αi−1,j
αi,j = pi,jqi,j

// Compute attention energy for hj using eq. (16)

// Add pre-sigmoid noise to encourage pi,j ≈ 0 or pi,j ≈ 1

// Compute probability of choosing hj

// Iterate recurrence relation derived in eq. (10)

// Compute the probability that ci = hj

// Compute weighted combination of memory for context vector

// Update the state based on the new context vector using the RNN f

// Compute predicted output for timestep i using the softmax layer g

j=1 αi,jhj

end for
ci = (cid:80)T
si = f (si−1, yi−1, ci)
yi = g(si, ci)
i = i + 1

end while

Online and Linear-Time Attention by Enforcing Monotonic Alignments

B. Figures

Below are example hard monotonic and softmax attention alignments for each of the different tasks we included in our
experiments. Attention matrices are displayed so that black corresponds to 1 and white corresponds to 0.

Figure 4. Attention alignments from hard monotonic attention and softmax-based attention models for a two example speech utterances.
From top to bottom, we show the hard monotonic alignment, the softmax-attention alignment, and the utterance feature sequence.
Differences in the alignments are highlighted with dashed red circles. Gaps in the alignment paths correspond to effectively ignoring
silences and pauses in the speech utterances.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Figure 5. English sentences, predicted Vietnamese sentences, and input-output alignments for our proposed hard monotonic alignment
model and the baseline model of (Luong & Manning, 2015). The Vietnamese model outputs for the left example can be translated back
to English as “And I on this stage because I am a model.” (monotonic) and “And I am on this stage because I am a structure.” (softmax).
The input word “model” can mean either a person or a thing; the monotonic alignment model correctly chose the former while the
softmax alignment model chose the latter. The monotonic alignment model erroneously skipped the ﬁrst verb in the sentence. For the
right example, translations of the model outputs back to English are “A large famine in North Korea.” (monotonic) and “An invasion
of a huge famine in <unk>.” (softmax). The monotonic alignment model managed to translate the proper noun North Korea, while
the softmax alignment model produced <unk>. Both models skipped the phrase “mid-1990s”; this type of error is common in neural
machine translation systems.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Figure 6. Additional example sentence-summary pair and attention alignment matrices for our hard monotonic model and the softmax-
based attention model of (Liu & Pan, 2016). The ground-truth summary is “china attacks us human rights”.

C. Monotonic Attention Distribution

Recall that our goal is to compute the expected value of ci under the stochastic process deﬁned by eqs. (6) to (8). To achieve
this, we will derive an expression for the probability that ci = hj for j ∈ {1, . . . , T }, which in accordance with eq. (2) we
denote αi,j. For i = 1, α1,j is the probability that memory element j was chosen (p1,j) multiplied by the probability that
memory elements k ∈ {1, 2, . . . , j − 1} were not chosen ((1 − pi,k)), giving

α1,j = p1,j

(1 − p1,k)

j−1
(cid:89)

k=1

αi,j = pi,j

αi−1,k

(1 − pi,l)

(cid:32)

j
(cid:88)

k=1

j−1
(cid:89)

l=k

(cid:33)

For i > 0, in order for ci = hj we must have that ci−1 = hk for some k ∈ {1, . . . , j} (which occurs with probability
αi−1,k) and that none of hk, . . . , hj−1 were chosen. Summing over possible values of k, we have

where for convenience we deﬁne (cid:81)m
n x = 1 when n > m. We provide a schematic and explanation of eq. (19) in ﬁg. 7.
Note that we can recover eq. (18) from eq. (19) by deﬁning the special case α0,j = δj (i.e. α0,1 = 1 and α0,j = 0 for
j ∈ {2, . . . , T }). Expanding eq. (19) reveals we can compute αi,j directly given αi−1,j and αi,j−1:

αi,j = pi,j

αi−1,k

(1−pi,l)

+αi−1,j

(cid:33)

(cid:33)

(cid:32) j−1
(cid:88)

(cid:32)

k=1

(cid:32)

(cid:18)

j−1
(cid:89)

l=k

j−1
(cid:88)

(cid:32)

k=1
αi,j−1
pi,j−1

j−2
(cid:89)

l=k

(cid:19)

= pi,j

(1 − pi,j−1)

+ αi−1,j

= pi,j

(1 − pi,j−1)

αi−1,k

(1 − pi,l)

+ αi−1,j

(cid:33)

(cid:33)

(18)

(19)

(20)

(21)

(22)

Deﬁning qi,j = αi,j/pi,j produces eqs. (13) and (14). Equation (22) also has an intuitive interpretation: The expression
(1 − pi,j−1)αi,j−1/pi,j−1 represents the probability that the model attended to memory item j − 1 at output timestep i,
adjusted for the fact that memory item j − 1 was not chosen by multiplying (1 − pi,j−1) and dividing pi,j−1. Adding
αi−1,j reﬂects the additional possibility that the model attended to memory item j at the previous output timestep, and
multiplying by pi,j enforces that memory item j was chosen at the current output timestep i.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Figure 7. Visualization of eq. (19). In this example, we are showing the computation of α3,4. Each grid shows each of the four terms
in the summation, corresponding to the possibilities that we attended to memory item k = 1, 2, 3, 4 at the previous output timestep
i − 1 = 2. Gray nodes with curved arrows represent the probability of not selecting to the lth memory entry (1 − pi,l). The black nodes
represent the possibility of attending to memory item j at timestep i.

C.1. Recurrence Relation Solution

While eqs. (10) and (22) allow us to compute αi,j directly from αi−1,j and αi,j−1, the dependence on αi,j−1 means that
we must compute the terms αi,1, αi,2, . . . , αi,T sequentially. This is in contrast to softmax attention, where these terms
can be computed in parallel because they are independent. Fortunately, there is a solution to the recurrence relation of
eq. (10) which allows the terms of αi to be computed directly via parallelizable cumulative sum and cumulative product
operations. Using eq. (13) which substitutes qi,j = αi,j/pi,j, we have

qi,j = (1 − pi,j−1)qi,j−1 + αi−1,j

qi,j − (1 − pi,j−1)qi,j−1 = αi−1,j

qi,j
k=1(1 − pi,k−1)
qi,j
k=1(1 − pi,k−1)

(cid:81)j

(cid:81)j

−

−

(cid:32)

j
(cid:88)

l=1

qi,l
k=1(1 − pi,k−1)

(cid:81)l

−

(cid:81)l−1

(1 − pi,j−1)qi,j−1
(cid:81)j
k=1(1 − pi,k−1)
qi,j−1
k=1(1 − pi,k−1)
(cid:33)

(cid:81)j−1

qi,l−1
k=1(1 − pi,k−1)

=

=

=

qi,j
k=1(1 − pi,k−1)

(cid:81)j

− qi,0 =

αi−1,j
k=1(1 − pi,k−1)
αi−1,j
k=1(1 − pi,k−1)

αi−1,l
k=1(1 − pi,k−1)

(cid:81)l

αi−1,l
k=1(1 − pi,k−1)

(cid:81)l

(cid:81)j

(cid:81)j

j
(cid:88)

l=1

j
(cid:88)

l=1
(cid:32) j
(cid:89)

k=1

qi,j =

(1 − pi,k−1)

(cid:33) (cid:32) j

(cid:33)

(cid:88)

l=1

(cid:81)l

αi−1,l
k=1(1 − pi,k−1)
(cid:18)

αi−1
cumprod(1 − pi)

(cid:19)

⇒ qi = cumprod(1 − pi)cumsum

(23)

(24)

(25)

(26)

(27)

(28)

(29)

(30)

where cumprod(x) = [1, x1, x1x2, . . . , (cid:81)|x|−1
i xi]. Note that we use the
“exclusive” variant of cumprod4 in keeping with our deﬁned special case pi,0 = 0. Unlike the recurrence relation of
eq. (10), these operations can be computed efﬁciently in parallel (Ladner & Fischer, 1980). The primary disadvantage
of this approach is that the product in the denominator of eq. (29) can cause numerical instabilities; we address this in
appendix G.

xi] and cumsum(x) = [x1, x1 + x2, . . . , (cid:80)|x|

i

4This can be computed e.g. in Tensorﬂow via tf.cumprod(x, exclusive=True)

Online and Linear-Time Attention by Enforcing Monotonic Alignments

D. Experiment Details

In this section, we give further details into the models and
training procedures used in section 4. Any further ques-
tions about implementation details should be directed to the
corresponding author. All models were implemented with
TensorFlow (Abadi et al., 2016).

D.1. Speech Recognition

D.1.1. TIMIT

Mel ﬁlterbank features were standardized to have zero
mean and unit variance across feature dimensions accord-
ing to their training set statistics and were fed directly into
an RNN encoder with three unidirectional LSTM layers,
each with 512 hidden units. After the ﬁrst and second
LSTM layers, we downsampled hidden state sequences by
skipping every other state before feeding into the subse-
quent layer. For the decoder, we used a single unidirec-
tional LSTM layer with 256 units, fed directly into the out-
put softmax layer. All weight matrices were initialized uni-
formly from [−0.075, 0.075]. The output tokens were em-
bedded via a learned embedding matrix with dimensional-
ity 30, initialized uniformly from [−(cid:112)3/30, (cid:112)3/30]. Our
decoder attention energy function used a hidden dimen-
sionality of 512, with the scalar bias r initialized to -1.
The model was regularized by adding weight noise with
a standard deviation of 0.5 after 2,000 training updates.
L2 weight regularization was also applied with a weight
of 10−6.

We trained the network using Adam (Kingma & Ba, 2014),
with β1 = 0.9, β2 = 0.999, and (cid:15) = 10−6. Utter-
ances were fed to the network with a minibatch size of
4. Our initial learning rate was 10−4, which we halved
after 40,000 training steps. We clipped gradients when
their global norm exceeded 2. We used three training repli-
cas. Beam search decoding was used to produce output
sequences with a beam width of 10.

D.1.2. WALL STREET JOURNAL

The input 80 mel ﬁlterbank / delta / delta-delta features
were organized as a T × 80 × 3 tensor, i.e. raw features,
deltas, and delta-deltas are concatenated along the “depth”
dimension. This was passed into a stack of two convolu-
tional layers with ReLU activations, each consisting of 32
3×3× depth kernels in time × frequency. These were both
strided by 2 × 2 in order to downsample the sequence in
time, minimizing the computation performed in the follow-
ing layers. Batch normalization (Ioffe & Szegedy, 2015)
was applied prior to the ReLU activation in each layer. All
encoder weight matrices and ﬁlters were initialized via a
truncated Gaussian with zero mean and a standard devia-
tion of 0.1.

This downsampled feature sequence was then passed into a
single unidirectional convolutional LSTM layer using 1x3
ﬁlter (i.e. only convolving across the frequency dimension
within each timestep). Finally, this was passed into a stack
of three unidirectional LSTM layers of size 256, inter-
leaved with a 256 dimensional linear projection, following
by batch normalization, and a ReLU activation. Decoder
weight matrices were initialized uniformly at random from
[−0.1, 0.1].

The decoder input is created by concatenating a 64 dimen-
sional embedding corresponding to the symbol emitted at
the previous timestep, and the 256 dimensional attention
context vector. The embedding was initialized uniformly
from [−1, 1]. This was passed into a single unidirectional
LSTM layer with 256 units. We used an attention energy
function hidden dimensionality of 128 and initialized the
bias scalar r to -4. Finally the concatenation of the atten-
tion context and LSTM output is passed into the softmax
output layer.

We applied label smoothing (Chorowski & Jaitly, 2017),
the target at time t, with (0.015ˆyt−2 +
replacing ˆyt,
0.035ˆyt−1 + ˆyt + 0.035ˆyt+1 + 0.015ˆyt+2)/1.1. We used
beam search decoding at test time with rank pruning at 8
hypotheses and a pruning threshold of 3.

The network was trained using teacher forcing on mini-
batches of 8 input utterances, optimized using Adam
(Kingma & Ba, 2014) with β1 = 0.9, β2 = 0.999, and
(cid:15) = 10−6. Gradients were clipped to a maximum global
norm of 1. We set the initial learning rate to 0.0002 and
decayed by a factor of 10 after 700,000, 1,000,000, and
1,300,000 training steps. L2 weight decay is used with a
weight of 10−6, and, beginning from step 20,000, Gaussian
weight noise with standard deviation of 0.075 was added to
weights for all LSTM layers and decoder embeddings. We
trained using 16 replicas.

D.2. Sentence Summarization

For data preparation, we used the same Gigaword data pro-
cessing scripts provided in (Rush et al., 2015) and tok-
enized into words by splitting on spaces. The vocabulary
was determined by selecting the most frequent 200,000 to-
kens. Only the tokens of the ﬁrst sentence of the article
were used as input to the model. An embedding layer was
used to embed tokens into a 200 dimensional space; em-
beddings were initialized using random normal distribution
with mean 0 and standard deviation 10−4.

We used a 4-layer bidirectional LSTM encoder with 4 lay-
ers and a single-layer unidirectional LSTM decoder. All
LSTMs, and the attention energy function, had a hidden di-
mensionality of 256. The decoder LSTM was fed directly
into the softmax output layer. All weights were initialized

Online and Linear-Time Attention by Enforcing Monotonic Alignments

uniform-randomly between −0.1 and 0.1.
In our mono-
tonic alignment decoder, we initialized r to -4. At test time,
we used a beam search over possible label sequences with
a beam width of 4.

A batch size of 64 was used and the model was trained
to minimize the sampled-softmax cross-entropy loss with
4096 negative samples. The Adam optimizer (Kingma &
Ba, 2014) was used with β1 = 0.9, β2 = 0.999, and
(cid:15) = 10−4, and an initial learning rate of 10−3; an expo-
nential decay was applied by multiplying the initial learn-
ing rate by .98n/30000 where n is the current training step.
Gradients were clipped to have a maximum global norm
of 2. Early stopping was used with respect to validation
loss and took about 300,000 steps for the baseline model,
and 180,000 steps for the monotonic model. Training was
conducted on 16 machines with 4 GPUs each. We reported
ROUGE scores computed over the test set of (Rush et al.,
2015).

D.3. Machine Translation

Overall, we followed the model of (Luong & Man-
ning, 2015) closely; our hyperparameters are largely the
same: Words were mapped to 512-dimensional embed-
dings, which were learned during training. We passed sen-
tences to the network in minibatches of size 128. As men-
tioned in the text, we used two unidirectional LSTM lay-
ers in both the encoder and decoder. All LSTM layers,
and the attention energy function, had a hidden dimen-
sionality of 512. We trained with a single replica for 40
epochs using Adam (Kingma & Ba, 2014) with β1 = 0.9,
β2 = 0.999, and (cid:15) = 10−8. We performed grid searches
over initial learning rate and decay schedules separately for
models using each of the two energy functions eq. (16) and
eq. (17). For the model using eq. (16), we used an ini-
tial learning rate of 0.0005, and after 10 epochs we mul-
tiplied the learning rate by 0.8 each epoch; for eq. (17)
we started at 0.001 and multiplied by 0.8 each epoch start-
ing at the eighth epoch. Parameters were uniformly initial-
ized in range [−0.1, 0.1]. Gradients were scaled whenever
their norms exceeded 5. We used dropout with probability
0.3 as described in (Pham et al., 2014). Unlike (Luong &
Manning, 2015), we did not reverse source sentences in our
monotonic attention experiments. We set r = −2 for the
attention energy function bias scalar for both eq. (16) and
eq. (17). We used greedy decoding (i.e. no beam search) at
test time.

E. Future Work

We believe there are a variety of promising extensions
of our monotonic attention mechanism, which we outline
brieﬂy below.

• The primary drawback of training in expectation is
that it retains the quadratic complexity during training.
One idea would be to replace the cumulative product
in eq. (9) with the thresholded remainder method of
(Graves, 2016) and (Grefenstette et al., 2015), but in
preliminary experiments we were unable to successfully
learn alignments with this approach. Alternatively, we
could further our investigation into gradient estimators
for discrete decisions (such as REINFORCE or straight-
through) instead of training in expectation (Bengio et al.,
2013).

• As we point out in section 2.4, our method can fail when
the attention energies ei,j are poorly scaled. This primar-
ily stems from the strict enforcement of monotonicity.
One possibility to mitigate this would be to instead reg-
ularize the model with a soft penalty which discourages
non-monotonic alignments, instead of preventing them
outright.

• In some problems, the input-output alignment is non-
monotonic only in small regions. A simple modiﬁca-
tion to our approach which would allow this would be
to subtract a constant integer from ti−1 between output
timesteps. Alternatively, utilizing multiple monotonic
attention mechanisms in parallel would allow the model
to attend to disparate memory locations at each output
timestep (effectively allowing for non-monotonic align-
ments) while still maintaining linear-time decoding.

• To facilitate comparison, we sought to modify the stan-
dard softmax-based attention framework as little as pos-
sible. As a result, we have thus far not fully taken advan-
tage of the fact that the decoding process is much more
efﬁcient. Speciﬁcally, the attention energy function of
eq. (15) was primarily motivated by the fact that it is
trivially parallelizable so that its repeated application is
inexpensive. We could instead use a recurrent attention
energy function, whose output depends on both the at-
tention energies for prior memory items and those at the
previous output timestep.

F. How much faster is linear-time decoding?

Throughout this paper, we have emphasized that one ad-
vantage of our approach is that it allows for linear-time de-
coding, i.e. the decoder RNN only makes a single pass over
the memory in the course of producing the output sequence.
However, we have thus far not attempted to quantify how
much of a speedup this incurs in practice. Towards this
end, we conducted an additional experiment to measure the
speed of efﬁciently-implemented softmax-based and hard
monotonic attention mechanisms. We chose to focus solely
on the speed of the attention mechanisms rather than an en-
tire RNN sequence-to-sequence model because models us-
ing these attention mechanisms are otherwise equivalent.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

emphasize that at training time, we expect our soft mono-
tonic attention approach to have roughly the computational
cost as standard softmax attention, thanks to the fact that
we can compute the resulting attention distribution in par-
allel as described in appendix C.1. The code used for this
benchmark is available in the repository for this paper.5

G. Practitioner’s Guide

Because we are proposing a novel attention mechanism, we
share here some insights gained from applying it in various
settings in order to help practitioners try it on their own
problems:

• The recursive structure of computing αi,j in eq. (9) can
result in exploding gradients. We found it vital to apply
gradient clipping in all of our experiments, as described
in appendix D.

• Many automatic differentiation packages can produce
numerically unstable gradients when using their cumula-
tive product function.67 Our simple solution was to com-
pute the product in log-space, i.e. replacing (cid:81)
n xn =
exp((cid:80)

i log(xn)).

• In addition, the product in the denominator of eq. (29)
can become negligibly small because the terms (1 −
pi,k−1) all fall in the range [0, 1]. The simplest way to
prevent the resulting numerical instabilities is to clip the
range of the denominator to be within [(cid:15), 1] where (cid:15) is a
small constant (we used (cid:15) = 10−10). This can result in
incorrect values for αi,j particularly when some pi,j are
close to 1, but we encountered no discernible effect on
our results.

• Alternatively, we found in preliminary experiments that
simply setting the denominator to 1 still produced good
results. This can be explained by the observation that
when all pi,j ∈ {0, 1} (which we encourage during train-
ing), eq. (29) is equivalent to the recurrence relation of
eq. (10) even when the denominator is 1.

• As we mention in the experiment details of the previous
section, we ended up using a small range of values for
the initial energy function scalar bias r. In general, per-
formance was not very sensitive to this parameter, but
we found small performance gains from using values in
{−5, −4, −3, −2, −1} for different problems.

• More broadly, while the attention energy function mod-
iﬁcations described in section 2.4 allowed models using
our mechanism to be effectively trained on all tasks we

5https://github.com/craffel/mad
6https://github.com/tensorflow/

tensorflow/issues/3862

7https://github.com/Theano/Theano/issues/

5197

Figure 8. Speedup of hard monotonic attention mechanism com-
pared to softmax attention on a synthetic benchmark.

Measuring the speed of the attention mechanisms alone al-
lows us to isolate the difference in computational cost be-
tween the two approaches.

Speciﬁcally, we implemented both attention mechanisms
using the highly-efﬁcient C++ linear algebra package Eigen
(Guennebaud et al., 2010). We set entries of the mem-
ory h and the decoder hidden states si to random vectors
with entries sampled uniformly in the range [−1, 1]. We
then computed context vectors following eqs. (2) and (3)
for the softmax attention mechanism and following algo-
rithm 1 for hard monotonic attention. We varied the input
and output sequence lengths and averaged the time to pro-
duce all of the corresponding context vectors over 100 trials
for each setting.

The speedup of the monotonic attention mechanism com-
pared to softmax attention is visualized in ﬁg. 8. We found
monotonic attention to be about 4 − 40× faster depending
on the input and output sequence lengths. The most promi-
nent difference occurred for short input sequences and long
output sequences; in these cases the monotonic attention
mechanism ﬁnishes processing the input sequence before
it ﬁnishes producing the output sequence and therefore is
able to stop computing context vectors. We emphasize that
these numbers represent the best-case speedup from our
approach; a more general insight is simply that our pro-
posed hard monotonic attention mechanism has the poten-
tial to make decoding signiﬁcantly more efﬁcient for long
sequences. Additionally, this advantage is distinct from the
fact that our hard monotonic attention mechanism can be
used for online sequence-to-sequence problems. We also

Online and Linear-Time Attention by Enforcing Monotonic Alignments

tried, they were not always necessary for convergence.
Speciﬁcally, in speech recognition experiments the per-
formance of our model was the same using eq. (15) and
eq. (16), but for summarization experiments the mod-
els were unable to learn to utilize attention when using
eq. (15). For ease of implementation, we recommend
starting with the standard attention energy function of
eq. (15) and then applying the modiﬁcations of eq. (16)
if the model fails to utilize attention.

• It is occasionally recommended to reverse the input se-
quence prior to feeding it into sequence-to-sequence
models (Sutskever et al., 2014). This violates our as-
sumption that the input should be processed in a left-
to-right manner when computing attention, so should be
avoided.

• Finally, we highly recommend visualizing the attention
alignments αi,j over the course of training. Attention
provides valuable insight into the model’s behavior, and
failure modes can be quickly spotted (e.g. if αi,j = 0 for
all i and j).

With the above factors in mind, on all problems we studied,
we were able to replace softmax-based attention with our
novel attention and immediately achieve competitive per-
formance.

References

Abadi, Martin, Barham, Paul, Chen, Jianmin, Chen,
Zhifeng, Davis, Andy, Dean, Jeffrey, Devin, Matthieu,
Ghemawat, Sanjay, Irving, Geoffrey, Isard, Michael,
Kudlur, Manjunath, Levenberg, Josh, Monga, Rajat,
Moore, Sherry, Murray, Derek G., Steiner, Benoit,
Tucker, Paul, Vasudevan, Vijay, Warden, Pete, Wicke,
Martin, Yu, Yuan, and Zheng, Xiaoqiang. TensorFlow:
A system for large-scale machine learning. In Operating
Systems Design and Implementation, 2016.

Graves, Alex. Adaptive computation time for recurrent
arXiv preprint arXiv:1603.08983,

neural networks.
2016.

Grefenstette, Edward, Hermann, Karl Moritz, Suleyman,
Mustafa, and Blunsom, Phil. Learning to transduce with
unbounded memory. In Advances in Neural Information
Processing Systems, 2015.

Guennebaud, Gaël, Jacob, Benoıt, Avery, Philip, Bachrach,
Eigen v3.

Abraham, Barthelemy, Sebastien, et al.
http://eigen.tuxfamily.org, 2010.

Ioffe, Sergey and Szegedy, Christian. Batch normalization:
Accelerating deep network training by reducing internal
covariate shift. In International Conference on Machine
Learning, 2015.

Kingma, Diederik and Ba,

Jimmy.
method for stochastic optimization.
arXiv:1412.6980, 2014.

Adam:

A
arXiv preprint

Ladner, Richard E. and Fischer, Michael J. Parallel preﬁx
computation. Journal of the ACM (JACM), 27(4):831–
838, 1980.

Liu, Peter J. and Pan, Xin. Text summarization with Ten-

sorFlow. http://goo.gl/16RNEu, 2016.

Luong, Minh-Thang and Manning, Christopher D. Stan-
ford neural machine translation systems for spoken lan-
In International Workshop on Spoken
guage domain.
Language Translation, 2015.

Pham, Vu, Bluche, Théodore, Kermorvant, Christopher,
and Louradour, Jérôme. Dropout improves recurrent
neural networks for handwriting recognition. In Interna-
tional Conference on Frontiers in Handwriting Recogni-
tion, 2014.

Bengio, Yoshua, Léonard, Nicholas, and Courville, Aaron.
Estimating or propagating gradients through stochastic
arXiv preprint
neurons for conditional computation.
arXiv:1308.3432, 2013.

Rush, Alexander M., Chopra, Sumit, and Weston, Jason. A
neural attention model for abstractive sentence summa-
rization. In Conference on Empirical Methods in Natural
Language Processing, 2015.

Chorowski, Jan and Jaitly, Navdeep. Towards better decod-
ing and language model integration in sequence to se-
quence models. arXiv preprint arXiv:1612.02695, 2017.

Sutskever, Ilya, Vinyals, Oriol, and Le, Quoc V. Sequence
to sequence learning with neural networks. In Advances
in neural information processing systems, 2014.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

7
1
0
2
 
n
u
J
 
9
2
 
 
]

G
L
.
s
c
[
 
 
2
v
4
8
7
0
0
.
4
0
7
1
:
v
i
X
r
a

Colin Raffel 1 Minh-Thang Luong 1 Peter J. Liu 1 Ron J. Weiss 1 Douglas Eck 1

Abstract

Recurrent neural network models with an atten-
tion mechanism have proven to be extremely
effective on a wide variety of sequence-to-
sequence problems. However, the fact that soft
attention mechanisms perform a pass over the
entire input sequence when producing each el-
ement in the output sequence precludes their use
in online settings and results in a quadratic time
complexity. Based on the insight that the align-
ment between input and output sequence ele-
ments is monotonic in many problems of interest,
we propose an end-to-end differentiable method
for learning monotonic alignments which, at test
time, enables computing attention online and in
linear time. We validate our approach on sen-
tence summarization, machine translation, and
online speech recognition problems and achieve
results competitive with existing sequence-to-
sequence models.

1. Introduction

the

“sequence-to-sequence”

Recently,
framework
(Sutskever et al., 2014; Cho et al., 2014) has facilitated
the use of recurrent neural networks (RNNs) on sequence
transduction problems such as machine translation and
speech recognition. In this framework, an input sequence
is processed with an RNN to produce an “encoding”; this
encoding is then used by a second RNN to produce the
target sequence. As originally proposed, the encoding is
a single ﬁxed-length vector representation of the input
sequence. This requires the model to effectively compress
all important information about the input sequence into a
single vector. In practice, this often results in the model
having difﬁculty generalizing to longer sequences than
those seen during training (Bahdanau et al., 2015).

An effective solution to these shortcomings are attention

1Google Brain, Mountain View, California, USA. Correspon-

dence to: Colin Raffel <craffel@gmail.com>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

In a sequence-to-
mechanisms (Bahdanau et al., 2015).
sequence model with attention, the encoder produces a se-
quence of hidden states (instead of a single ﬁxed-length
vector) which correspond to entries in the input sequence.
The decoder is then allowed to refer back to any of the en-
coder states as it produces its output. Similar mechanisms
have been used as soft addressing schemes in memory-
augmented neural network architectures (Graves et al.,
2014; Sukhbaatar et al., 2015) and RNNs used for sequence
generation (Graves, 2013). Attention-based sequence-to-
sequence models have proven to be extremely effective on
a wide variety of problems, including machine translation
(Bahdanau et al., 2015; Luong et al., 2015), image cap-
tioning (Xu et al., 2015), speech recognition (Chorowski
et al., 2015; Chan et al., 2016), and sentence summariza-
tion (Rush et al., 2015). In addition, attention creates an
implicit soft alignment between entries in the output se-
quence and entries in the input sequence, which can give
useful insight into the model’s behavior.

A common criticism of soft attention is that the model must
perform a pass over the entire input sequence when pro-
ducing each element of the output sequence. This results
in the decoding process having complexity O(T U ), where
T and U are the input and output sequence lengths respec-
tively. Furthermore, because the entire sequence must be
processed prior to outputting any symbols, soft attention
cannot be used in “online” settings where output sequence
elements are produced when the input has only been par-
tially observed.

The focus of this paper is to propose an alternative at-
tention mechanism which has linear-time complexity and
can be used in online settings. To achieve this, we ﬁrst
note that in many problems, the input-output alignment is
roughly monotonic. For example, when transcribing an
audio recording of someone saying “good morning”, the
region of the speech utterance corresponding to “good”
will always precede the region corresponding to “morn-
ing”. Even when the alignment is not strictly monotonic,
it often only contains local input-output reorderings. Sep-
arately, despite the fact that soft attention allows for as-
signment of focus to multiple disparate entries of the input
sequence, in many cases the attention is assigned mostly to
a single entry. For examples of alignments with these char-
acteristics, we refer to e.g. (Chorowski et al. 2015 Figure

Online and Linear-Time Attention by Enforcing Monotonic Alignments

2; Chan et al. 2016 Figure 2; Rush et al. 2015 Figure 1;
Bahdanau et al. 2015 Figure 3), etc. Of course, this is not
true in all problems; for example, when using soft attention
for image captioning, the model will often change focus
arbitrarily between output steps and will spread attention
across large regions of the input image (Xu et al., 2015).

Motivated by these observations, we propose using hard
monotonic alignments for sequence-to-sequence problems
because, as we argue in section 2.2, they enable computing
attention online and in linear time. Towards this end, we
show that it is possible to train such an attention mecha-
nism with a quadratic-time algorithm which computes its
expected output. This allows us to continue using standard
backpropagation for training while still facilitating efﬁcient
online decoding at test-time. On all problems we studied,
we found these added beneﬁts only incur a small decrease
in performance compared to softmax-based attention.

The rest of this paper is structured as follows: In the follow-
ing section, we develop an interpretation of soft attention as
optimizing a stochastic process in expectation and formu-
late a corresponding stochastic process which allows for
online and linear-time decoding by relying on hard mono-
tonic alignments. In analogy with soft attention, we then
show how to compute the expected output of the mono-
tonic attention process and elucidate how the resulting al-
gorithm differs from standard softmax attention. After giv-
ing an overview of related work, we apply our approach to
the tasks of sentence summarization, machine translation,
and online speech recognition, achieving results competi-
tive with existing sequence-to-sequence models. Finally,
we present additional derivations, experimental details, and
ideas for future research in the appendix.

2. Online and Linear-Time Attention

To motivate our approach, we ﬁrst point out that softmax-
based attention is computing the expected output of a sim-
ple stochastic process. We then detail an alternative process
which enables online and linear-time decoding. Because
this process is nondifferentiable, we derive an algorithm for
computing its expected output, allowing us to train a model
with standard backpropagation while applying our online
and linear-time process at test time. Finally, we propose
an alternative energy function motivated by the differences
between monotonic attention and softmax-based attention.

2.1. Soft Attention

To begin with, we review the commonly-used form of
soft attention proposed originally in (Bahdanau et al.,
2015). Broadly, a sequence-to-sequence model produces
a sequence of outputs based on a processed input se-
quence. The model consists of two RNNs, referred to

as the “encoder” and “decoder”. The encoder RNN pro-
cesses the input sequence x = {x1, . . . , xT } to produce
a sequence of hidden states h = {h1, . . . , hT }. We re-
fer to h as the “memory” to emphasize its connection to
memory-augmented neural networks (Graves et al., 2014;
Sukhbaatar et al., 2015). The decoder RNN then produces
an output sequence y = {y1, . . . , yU }, conditioned on the
memory, until a special end-of-sequence token is produced.

When computing yi, a soft attention-based decoder uses a
learnable nonlinear function a(·) to produce a scalar value
ei,j for each entry hj in the memory based on hj and the de-
coder’s state at the previous timestep si−1. Typically, a(·)
is a single-layer neural network using a tanh nonlinearity,
but other functions such as a simple dot product between
si−1 and hj have been used (Luong et al., 2015; Graves
et al., 2014). These scalar values are normalized using the
softmax function to produce a probability distribution over
the memory, which is used to compute a context vector ci as
the weighted sum of h. Because items in the memory have
a sequential correspondence with items in the input, these
attention distributions create a soft alignment between the
output and input. Finally, the decoder updates its state to si
based on si−1 and ci and produces yi. In total, producing
yi involves

ei,j = a(si−1, hj)

αi,j = exp(ei,j)

exp(ei,k)

(cid:30) T

(cid:88)

k=1

ci =

αi,jhj

T
(cid:88)

j=1

si = f (si−1, yi−1, ci)
yi = g(si, ci)

(1)

(2)

(3)

(4)

(5)

where f (·) is a recurrent neural network (typically one or
more LSTM (Hochreiter & Schmidhuber, 1997) or GRU
(Chung et al., 2014) layers) and g(·) is a learnable nonlinear
function which maps the decoder state to the output space
(e.g. an afﬁne transformation followed by a softmax when
the target sequences consist of discrete symbols).

To motivate our monotonic alignment scheme, we observe
that eqs. (2) and (3) are computing the expected output of
a simple stochastic process, which can be formulated as
follows: First, a probability αi,j is computed independently
for each entry hj of the memory. Then, a memory index k
is sampled by k ∼ Categorical(αi) and ci is set to hk. We
visualize this process in ﬁg. 1. Clearly, eq. (3) shows that
soft attention replaces sampling k and assigning ci = hk
with direct computation of the expected value of ci.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

the

stochastic process underlying
Figure 1. Schematic of
softmax-based attention decoders.
Each node represents a
possible alignment between an entry of the output sequence
(vertical axis) and the memory (horizontal axis). At each output
timestep, the decoder inspects all memory entries (indicated in
gray) and attends to a single one (indicated in black). A black
node indicates that memory element hj is aligned to output yi. In
terms of which memory entry is chosen, there is no dependence
across output timesteps or between memory entries.

Figure 2. Schematic of our novel monotonic stochastic decoding
process. At each output timestep, the decoder inspects memory
entries (indicated in gray) from left-to-right starting from where
it left off at the previous output timestep and chooses a single
one (indicated in black). A black node indicates that memory
element hj is aligned to output yi. White nodes indicate that a
particular input-output alignment was not considered because it
violates monotonicity. Arrows indicate the order of processing
and dependence between memory entries and output timesteps.

2.2. A Hard Monotonic Attention Process

The discussion above makes clear that softmax-based at-
tention requires a pass over the entire memory to compute
the terms αi,j required to produce each element of the out-
put sequence. This precludes its use in online settings, and
results in a complexity of O(T U ) for generating the out-
put sequence. In addition, despite the fact that h represents
a transformation of a sequence (which ostensibly exhibits
dependencies between subsequent elements), the attention
probabilities are computed independent of temporal order
and the attention distribution at the previous timestep.

We address these shortcomings by ﬁrst formulating a
stochastic process which explicitly processes the memory
in a left-to-right manner. Speciﬁcally, for output timestep
i we begin processing memory entries from index ti−1,
where ti is the index of the memory entry chosen at output
timestep i (for convenience, letting t0 = 1). We sequen-
tially compute, for j = ti−1, ti−1 + 1, ti−1 + 2, . . .

ei,j = a(si−1, hj)
pi,j = σ(ei,j)
zi,j ∼ Bernoulli(pi,j)

(6)

(7)

(8)

where a(·) is a learnable deterministic “energy function”
and σ(·) is the logistic sigmoid function. As soon as we
sample zi,j = 1 for some j, we stop and set ci = hj
and ti = j, “choosing” memory entry j for the context
vector. Each zi,j can be seen as representing a discrete
choice of whether to ingest a new item from the memory
(zi,j = 0) or produce an output (zi,j = 1). For all sub-

sequent output timesteps, we repeat this process, always
starting from ti−1 (the memory index chosen at the previ-
ous timestep). If for any output timestep i we have zi,j = 0
for j ∈ {ti−1, . . . , T }, we simply set ci to a vector of ze-
ros. This process is visualized in ﬁg. 2 and is presented
more explicitly in algorithm 1 (appendix A).

Note that by construction, in order to compute pi,j, we only
need to have computed hk for k ∈ {1, . . . , j}. It follows
that our novel process can be computed in an online man-
ner; i.e. we do not need to wait to observe the entire input
sequence before we start producing the output sequence.
Furthermore, because we start inspecting memory elements
from where we left off at the previous output timestep (i.e.
at index ti−1), the resulting process only computes at most
max(T, U ) terms pi,j, giving it a linear runtime. Of course,
it also makes the strong assumption that the alignment be-
tween the input and output sequence is strictly monotonic.

2.3. Training in Expectation

The online alignment process described above involves
sampling, which precludes the use of standard backpropa-
gation. In analogy with softmax-based attention, we there-
fore propose training with respect to the expected value of
ci, which can be computed straightforwardly as follows.
We ﬁrst compute ei,j and pi,j exactly as in eqs. (6) and (7),
where pi,j are interpreted as the probability of choosing
memory element j at output timestep i. The attention dis-
tribution over the memory is then given by (see appendix C

Online and Linear-Time Attention by Enforcing Monotonic Alignments

for a derivation)

αi,j = pi,j

αi−1,k

(1 − pi,l)

(9)

(cid:32)

j
(cid:88)

k=1
(cid:18)

(cid:33)

(cid:19)

j−1
(cid:89)

l=k
αi,j−1
pi,j−1

= pi,j

(1 − pi,j−1)

+ αi−1,j

(10)

We provide a solution to the recurrence relation of eq. (10)
which allows computing αi,j for j ∈ {1, . . . , T } in parallel
with cumulative sum and cumulative product operations in
appendix C.1. Deﬁning qi,j = αi,j/pi,j gives the following
procedure for computing αi,j:

ei,j = a(si−1, hj)
pi,j = σ(ei,j)
qi,j = (1 − pi,j−1)qi,j−1 + αi−1,j
αi,j = pi,jqi,j

(11)

(12)

(13)

(14)

where we deﬁne the special cases of qi,0 = 0, pi,0 = 0
to maintain equivalence with eq. (9). As in softmax-
based attention, the αi,j values produce a weighting over
the memory, which are then used to compute the con-
text vector at each timestep as in eq. (3). However, note
that αi may not be a valid probability distribution because
(cid:80)
j αi,j ≤ 1. Using αi as-is, without normalization, ef-
fectively associates any additional probability not allocated
to memory entries to an additional all-zero memory loca-
tion. Normalizing αi so that (cid:80)T
j=1 αi,j = 1 has two issues:
First, we can’t perform this normalization at test time and
still achieve online decoding because the normalization de-
pends on αi,j for j ∈ {1, . . . , T }, and second, it would re-
sult in a mismatch compared to the probability distribution
induced by the hard monotonic attention process which sets
ci to a vector of zeros when zi,j = 0 for j ∈ {ti−1, . . . , T }.

Note that computing ci still has a quadratic complexity be-
cause we must compute αi,j for j ∈ {1, . . . , T } for each
output timestep i. However, because we are training di-
rectly with respect to the expected value of ci, we will train
our decoders using eqs. (11) to (14) and then use the on-
line, linear-time attention process of section 2.2 at test time.
Furthermore, if pi,j ∈ {0, 1} these approaches are equiva-
lent, so in order for the model to exhibit similar behavior at
training and test time, we need pi,j ≈ 0 or pi,j ≈ 1. We
address this in section 2.5.

2.4. Modiﬁed Energy Function

While various “energy functions” a(·) have been proposed,
the most common to our knowledge is the one proposed in
(Bahdanau et al., 2015):

a(si−1, hj) = v(cid:62) tanh(W si−1 + V hj + b)

(15)

where W and V are weight matrices, b is a bias vector,1
and v is a weight vector. We make two modiﬁcations to
eq. (15) for use with our monotonic decoder: First, while
the softmax is invariant to offset,2 the logistic sigmoid is
not. As a result, we make the simple modiﬁcation of adding
a scalar variable r after the tanh function, allowing the
model to learn the appropriate offset for the pre-sigmoid
activations. Note that eq. (13) tends to exponentially de-
cay attention over the memory because 1 − pi,j ∈ [0, 1];
we therefore initialized r to a negative value prior to train-
ing so that 1 − pi,j tends to be close to 1. Second, the
use of the sigmoid nonlinearity in eq. (12) implies that our
mechanism is particularly sensitive to the scale of the en-
ergy terms ei,j, or correspondingly, the scale of the energy
vector v. We found an effective solution to this issue was
to apply weight normalization (Salimans & Kingma, 2016)
to v, replacing it by gv/(cid:107)v(cid:107) where g is a scalar parame-
ter. Initializing g to the inverse square root of the attention
hidden dimension worked well for all problems we studied.

The above produces the energy function

a(si−1, hj) = g

tanh(W si−1 + V hj + b) + r (16)

v(cid:62)
(cid:107)v(cid:107)

The addition of the two scalar parameters g and r prevented
the issues described above in all our experiments while in-
curring a negligible increase in the number of parameters.

2.5. Encouraging Discreteness

As mentioned above, in order for our mechanism to exhibit
similar behavior when training in expectation and when us-
ing the hard monotonic attention process at test time, we
require that pi,j ≈ 0 or pi,j ≈ 1. A straightforward way to
encourage this behavior is to add noise before the sigmoid
in eq. (12), as was done e.g. in (Frey, 1997; Salakhutdinov
& Hinton, 2009; Foerster et al., 2016). We found that sim-
ply adding zero-mean, unit-variance Gaussian noise to the
pre-sigmoid activations was sufﬁcient in all of our exper-
iments. This approach is similar to the recently proposed
Gumbel-Softmax trick (Jang et al., 2016; Maddison et al.,
2016), except we did not ﬁnd it necessary to anneal the
temperature as suggested in (Jang et al., 2016).

Note that once we have a model which produces pi,j which
are effectively discrete, we can eschew the sampling in-
volved in the process of section 2.2 and instead simply set
zi,j = I(pi,j > τ ) where I is the indicator function and τ
is a threshold. We used this approach in all of our exper-
iments, setting τ = 0.5. Furthermore, at test time we do
not add pre-sigmoid noise, making decoding purely deter-

1b is occasionally omitted, but we found it often improves per-
formance and only incurs a modest increase in parameters, so we
include it.

2That is, softmax(e) = softmax(e + r) for any r ∈ R.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

ministic. Combining all of the above, we present our dif-
ferentiable approach to training the monotonic alignment
decoder in algorithm 2 (appendix A).

3. Related Work

(Luo et al., 2016) and (Zaremba & Sutskever, 2015) both
study a similar framework in which a decoder RNN can
decide whether to ingest another entry from the input se-
quence or emit an entry of the output sequence. Instead of
training in expectation, they maintain the discrete nature of
this decision while training and use reinforcement learning
(RL) techniques. We initially experimented with RL-based
training methods but were unable to ﬁnd an approach which
worked reliably on the different tasks we studied. Empir-
ically, we also show superior performance to (Luo et al.,
2016) on online speech recognition tasks; we did not at-
tempt any of the tasks from (Zaremba & Sutskever, 2015).
(Aharoni & Goldberg, 2016) also study hard monotonic
alignments, but their approach requires target alignments
computed via a separate statistical alignment algorithm in
order to be trained.

As an alternative approach to monotonic alignments, Con-
nectionist Temporal Classiﬁcation (CTC) (Graves et al.,
2006) and the RNN Transducer (Graves, 2012) both as-
sume that the output sequences consist of symbols, and add
an additional “null” symbol which corresponds to “produce
no output”. More closely to our model, (Yu et al., 2016b)
similarly add “shift” and “emit” operations to an RNN. Fi-
nally, the Segmental RNN (Kong et al., 2015) treats a seg-
mentation of the input sequence as a latent random variable.
In all cases, the alignment path is marginalized out via a
dynamic program in order to obtain a conditional probabil-
ity distribution over label sequences and train directly with
maximum likelihood. These models either require condi-
tional independence assumptions between output symbols
or don’t condition the decoder (language model) RNN on
the input sequence. We instead follow the framework of
attention and marginalize out alignment paths when com-
puting the context vectors ci which are subsequently fed
into the decoder RNN, which allows the decoder to condi-
tion on its past output as well as the input sequence. Our
approach can therefore be seen as a marriage of these CTC-
style techniques and attention. Separately, instead of per-
forming an approximate search for the most probable out-
put sequence at test time, we use hard alignments which
facilitates linear-time decoding.

A related idea is proposed in (Raffel & Lawson, 2017),
where “subsampling” probabilities are assigned to each en-
try in the memory and a stochastic process is formulated
which involves keeping or discarding entries from the input
sequence according to the subsampling probabilities. A dy-
namic program similar to the one derived in section 2.3 is

then used to compute the expected output which allows for
training with standard backpropagation. Our approach dif-
fers in that we utilize an RNN decoder to construct the out-
put sequence, and furthermore allows for output sequences
which are longer than the input.

Some similar ideas to those in section 2.3 were proposed
in the context of speech recognition in (Chorowski et al.,
2015): First, the prior attention distributions are convolved
with a bank of one-dimensional ﬁlters and then included in
the energy function calculation. Second, instead of com-
puting attention over the entire memory they only compute
it over a sliding window. This reduces the runtime com-
plexity at the expense of the strong assumption that mem-
ory locations attended to at subsequent output timesteps fall
within a small window of one another. Finally, they also
advocate replacing the softmax function with a sigmoid,
but they then normalize by the sum of these sigmoid acti-
vations across the memory window instead of interpreting
these probabilities in the left-to-right framework we use.
While these modiﬁcations encourage monotonic attention,
they do not explicitly enforce it, and so the authors do not
investigate online decoding.

In a similar vein, (Luong et al., 2015) explore only comput-
ing attention over a small window of the memory. In addi-
tion to simply monotonically increasing the window loca-
tion at each output timestep, they also consider learning
a policy for producing the center of the memory window
based on the current decoder state.

(Kim et al., 2017) also make the connection between soft
attention and selecting items from memory in expectation.
They consider replacing the softmax in standard soft atten-
tion with an elementwise sigmoid nonlinearity, but do not
formulate the interpretation of addressing memory from
left-to-right and the corresponding probability distributions
as we do in section 2.3.

(Jaitly et al., 2015) apply standard softmax attention in on-
line settings by splitting the input sequence into chunks and
producing output tokens using the attentive sequence-to-
sequence framework over each chunk. They then devise a
dynamic program for ﬁnding the approximate best align-
ment between the model output and the target sequence.
In contrast, our ingest/emit probabilities pi,j can be seen as
adaptively chunking the input sequence (rather than provid-
ing a ﬁxed setting of the chunk size) and we instead train by
exactly computing the expectation over alignment paths.

4. Experiments

To validate our proposed approach for learning mono-
tonic alignments, we applied it to a variety of sequence-
to-sequence problems: sentence summarization, machine
translation, and online speech recognition. In the follow-

Online and Linear-Time Attention by Enforcing Monotonic Alignments

ing subsections, we give an overview of the models used
and the results we obtained; for more details about hy-
perparamers and training speciﬁcs please see appendix D.
Incidentally, all experiments involved predicting discrete
symbols (e.g. phonemes, characters, or words); as a result,
the output of the decoder in each of our models was fed
into an afﬁne transformation followed by a softmax non-
linearity with a dimensionality corresponding to the num-
ber of possible symbols. At test time, we performed a
beam search over softmax predictions on all problems ex-
cept machine translation. All networks were trained using
standard cross-entropy loss with teacher forcing against tar-
get sequences using the Adam optimizer (Kingma & Ba,
2014). All of our decoders used the monotonic attention
mechanism of section 2.3 during training to address the
hidden states of the encoder. For comparison, we report
test-time results using both the hard linear-time decoding
method of section 2.2 and the “soft” monotonic attention
distribution. We also present the results of a synthetic
benchmark we used to measure the potential speedup of-
fered by our linear-time decoding process in appendix F.

Online Speech Recognition Online speech recognition
involves transcribing the words spoken in a speech utter-
ance in real-time, i.e. as a person is talking. This problem
is a natural application for monotonic alignments because
online decoding is an explicit requirement. In addition, this
precludes the use of bidirectional RNNs, which degrades
performance somewhat (Graves et al., 2013). We tested our
approach on two datasets: TIMIT (Garofolo et al., 1993)
and the Wall Street Journal corpus (Paul & Baker, 1992).

Speech recognition on the TIMIT dataset involves tran-
scribing the phoneme sequence underlying a given speech
utterance.
Speech utterances were represented as se-
quences of 40-ﬁlter (plus energy) mel-ﬁlterbank spectra,
computed every 10 milliseconds, with delta- and delta-
delta-features. Our encoder RNN consisted of three uni-
directional LSTM layers. Following (Chan et al., 2016),
after the ﬁrst and second LSTM layer we placed time re-
duction layers which skip every other sequence element.
Our decoder RNN was a single unidirectional LSTM. Our
output softmax had 62 dimensions, corresponding to the
60 phonemes from TIMIT plus special start-of-sequence
and end-of-sequence tokens. At test time, we utilized a
beam search over softmax predictions, with a beam width
of 10. We report the phone error rate (PER) after apply-
ing the standard mapping to 39 phonemes (Graves et al.,
2013). We used the standard train/validation/test split and
report results on the test set.

Our model’s performance, with a comparison to other on-
line approaches, is shown in table 1. We achieve better
performance than recently proposed sequence-to-sequence
models (Luo et al., 2016; Jaitly et al., 2015), though the

Table 1. Phone error rate on the TIMIT dataset for different online
methods.

Method

(Luo et al., 2016) (stacked LSTM)
(Jaitly et al., 2015) (end-to-end)
(Luo et al., 2016) (grid LSTM)
Hard Monotonic Attention (ours)
Soft Monotonic Attention (ours, ofﬂine)
(Graves et al., 2013) (CTC)

PER

21.5%
20.8%
20.5%
20.4%
20.1%
19.6%

small size of the TIMIT dataset and the resulting variabil-
ity of results precludes making substantiative claims about
one approach being best. We note that (Jaitly et al., 2015)
were able to improve performance by precomputing align-
ments using an HMM system and providing them as a su-
pervised signal to their decoder; we did not experiment
with this idea. CTC (Graves et al., 2013) still outperforms
all sequence-to-sequence models.
In addition, there re-
mains a substantial gap between these online results and
ofﬂine results using bidirectional LSTMs, e.g. (Chorowski
et al., 2015) achieves a 17.6% phone error rate using a
softmax-based attention mechanism and (Graves et al.,
2013) achieved 17.7% using a pre-trained RNN transducer
model. We are interested in investigating ways to close this
gap in future work.

Because of the size of the dataset, performance on TIMIT is
often highly dependent on appropriate regularization. We
therefore also evaluated our approach on the Wall Street
Journal (WSJ) speech recognition dataset, which is about
10 times larger. For the WSJ corpus, we present speech
utterances to the network as 80-ﬁlter mel-ﬁlterbank spec-
tra with delta- and delta-delta features, and normalized us-
ing per-speaker mean and variance computed ofﬂine. The
model architecture is a variation of that from (Zhang et al.,
2016), using an 8 layer encoder including:
two convo-
lutional layers which downsample the sequence in time,
followed by one unidirectional convolutional LSTM layer,
and ﬁnally a stack of three unidirectional LSTM layers in-
terleaved with linear projection layers and batch normal-
ization. The encoder output sequence is consumed by the
proposed online attention mechanism which is passed into
a decoder consisting of a single unidirectional LSTM layer
followed by a softmax layer.

Our output softmax predicted one of 49 symbols, consist-
ing of alphanumeric characters, punctuation marks, and
start-of sequence, end-of-sequence, “unknown”, “noise”,
and word delimiter tokens. We utilized label smoothing
during training (Chorowski & Jaitly, 2017), replacing the
targets at time yt with a convex weighted combination of
the surrounding ﬁve labels (full details in appendix D.1.2).
Performance was measured in terms of word error rate
(WER) on the test set after segmenting the model’s predic-

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Table 2. Word error rate on the WSJ dataset. All approaches used
a unidirectional encoder; results in grey indicate ofﬂine models.

Method

CTC (our model)
(Luo et al., 2016) (hard attention)
(Wang et al., 2016) (CTC)
Hard Monotonic Attention (our model)
Soft Monotonic Attention (our model)
Softmax Attention (our model)

WER

33.4%
27.0%
22.7%
17.4%
16.5%
16.0%

tions according to the word delimiter tokens. We used the
standard dataset split of si284 for training, dev93 for vali-
dation, and eval92 for testing. We did not use a language
model to improve decoding performance.

Our results on WSJ are shown in table 2. Our model, with
hard monotonic decoding, achieved a signiﬁcantly lower
WER than the other online methods. While these ﬁgures
show a clear advantage to our approach, our model ar-
chitecture differed signiﬁcantly from those of (Luo et al.,
2016; Wang et al., 2016). We therefore additionally mea-
sured performance against a baseline model which was
identical to our model except that it used softmax-based
attention (which makes it quadratic-time and ofﬂine) in-
stead of a monotonic alignment decoder. This resulted in
a small decrease of 1.4% WER, suggesting that our hard
monotonic attention approach achieves competitive perfor-
mance while being substantially more efﬁcient. To get a
qualitative picture of our model’s behavior compared to the
softmax-attention baseline, we plot each model’s input-
output alignments for two example speech utterances in
ﬁg. 4 (appendix B). Both models learn roughly the same
alignment, with some minor differences caused by ours be-
ing both hard and strictly monotonic.

Sentence Summarization Speech recognition exhibits
a strictly monotonic input-output alignment. We are in-
terested in testing whether our approach is also effective
on problems which only exhibit approximately monotonic
alignments. We therefore ran a “sentence summarization”
experiment using the Gigaword corpus, which involves pre-
dicting the headline of a news article from its ﬁrst sentence.

Overall, we used the model of (Liu & Pan, 2016), modi-
fying it only so that it used our monotonic alignment de-
coder instead of a soft attention decoder. Because online
decoding is not important for sentence summarization, we
utilized bidirectional RNNs in the encoder for this task
(as is standard). We expect that the bidirectional RNNs
will give the model local context which may help allow
for strictly monotonic alignments. The model both took
as input and produced as output one-hot representations of
the word IDs, with a vocabulary of the 200,000 most com-
mon words in the training set. Our encoder consisted of

Table 3. ROUGE F-measure scores for sentence summarization
on the Gigaword test set of (Rush et al., 2015).
(Rush et al.,
2015) reports ROUGE recall scores, so we report the F-1 scores
computed for that approach from (Chopra et al., 2016). As is
standard, we report unigram, bigram, and longest common subse-
quence metrics as R-1, R-2, and R-L respectively.

Method

R-1

R-2

R-L

(Zeng et al., 2016)
(Rush et al., 2015)
(Yu et al., 2016b)
(Chopra et al., 2016)
(Miao & Blunsom, 2016)
(Nallapati et al., 2016)
(Yu et al., 2016a)
(Suzuki & Nagata, 2017)
Hard Monotonic (ours)
Soft Monotonic (ours)
(Liu & Pan, 2016)

27.82
29.76
30.27
33.78
34.17
34.19
34.41
36.30
37.14
38.03
38.22

12.74
11.88
13.68
15.97
15.94
16.29
16.86
17.31
18.00
18.57
18.70

26.01
26.96
27.91
31.15
31.92
32.13
31.83
33.88
34.87
35.70
35.74

Figure 3. Example sentence-summary pair with attention align-
ments for our hard monotonic model and the softmax-based at-
tention model of (Liu & Pan, 2016). Attention matrices are dis-
played so that black corresponds to 1 and white corresponds to
0. The ground-truth summary is “greece pumps more money and
personnel into bird ﬂu defense”.

a word embedding matrix (which was initialized randomly
and trained as part of the model) followed by four bidirec-
tional LSTM layers. We used a single LSTM layer for the
decoder. For data preparation and evaluation, we followed
the approach of (Rush et al., 2015), measuring performance
using the ROUGE metric.

Our results, along with the scores achieved by other ap-
proaches, are presented in table 3. While the monotonic
alignment model outperformed existing models by a sub-
stantial margin, it fell slightly behind the model of (Liu
& Pan, 2016) which we used as a baseline. The higher
performance of our model and the model of (Liu & Pan,
2016) can be partially explained by the fact that their en-
coders have roughly twice as many layers as most models
proposed in the literature.

For qualitative evaluation, we plot an example input-output

Online and Linear-Time Attention by Enforcing Monotonic Alignments

pair and alignment matrices for our hard monotonic atten-
tion model and the softmax-attention baseline of (Liu &
Pan, 2016) in ﬁg. 3 (an additional example is shown in
ﬁg. 6, appendix B). Most apparent is that a given word
in the summary is not always aligned to the most obvi-
ous word in the input sentence; the hard monotonic de-
coder aligns the ﬁrst four words in the summary reason-
ably (greek ↔ greek, government ↔ ﬁnance, approves ↔
approved, more ↔ more), but the latter four words have
unexpected alignments (funds ↔ in, to ↔ for, bird ↔ mea-
sures, bird ↔ ﬂu). We believe this is due to the ability of
the multilayer bidirectional RNN encoder to reorder words
in the input sequence. This effect is also apparent in ﬁg. 6/
(appendix B), where the monotonic alignment decoder is
able to produce the phrase “human rights criticism” despite
the fact that the input sentence has the phrase “criticism
of human rights”. Separately, we note that the softmax
attention model’s alignments are extremely “soft” and non-
monotonic; this may be advantageous for this problem and
partially explain its slightly superior performance.

Machine Translation We also evaluated our approach
on machine translation, another task which does not exhibit
strictly monotonic alignments. In fact, for some language
pairs (e.g. English and Japanese, English and Korean), we
do not expect monotonicity at all. However, for other pairs
(e.g. English and French, English and Vietnamese) only
local word reorderings are required. Our translation ex-
periments therefore involved English to Vietnamese trans-
lation using the parallel corpus of TED talks (133K sen-
tence pairs) provided by the IWSLT 2015 Evaluation Cam-
paign (Cettolo et al., 2015). Following (Luong & Manning,
2015), we tokenize the corpus with the default Moses tok-
enizer, preserve casing, and replace words whose frequen-
cies are less than 5 by <unk>. As a result, our vocab-
ulary sizes are 17K and 7.7K for English and Vietnamese
respectively. We use the TED tst2012 (1553 sentences) as a
validation set for hyperparameter tuning and TED tst2013
(1268 sentences) as a test set. We report results in both
perplexity and BLEU.

Our baseline neural machine translation (NMT) system is
the softmax attention-based sequence-to-sequence model
described in (Luong et al., 2015). From that baseline, we
substitute the softmax-based attention mechanism with our
proposed monotonic alignment decoder. The model uti-
lizes two-layer unidirectional LSTM networks for both the
encoder and decoder.

In (Luong et al., 2015), the authors demonstrated that un-
der their proposed architecture, a dot product-based energy
function worked better than eq. (15). Since our architec-
ture is based on that of (Luong et al., 2015), to facilitate
comparison we also tested the following variant:

Table 4. Performance on the IWSLT 2015 English-Vietnamese
TED talks for our monotonic alignment model and the baseline
softmax-attention model of (Luong & Manning, 2015).

Method

(Luong & Manning, 2015)
Hard Monotonic, energy function eq. (16)
Hard Monotonic, energy function eq. (17)

BLEU

23.3
22.6
23.0

where g and r are scalars (initialized as in section 2.4) and
W is a weight matrix.

Our results are shown in Table 4. To get a better pic-
ture of each model’s behavior, we plot input-output align-
ments in ﬁg. 5 (appendix B). Most noticeable is that the
monotonic alignment model tends to focus attention later
in the input sequence than the baseline softmax-attention
model. We hypothesize that this is a way to compensate
for non-monotonic alignments when a unidirectional en-
coder is used; i.e. the model has effectively learned to fo-
cus on words at the end of phrases which require reorder-
ing, at which point the unidirectional encoder has observed
the whole phrase. This can be seen most clearly in the
example on the right, where translating “a huge famine”
to Vietnamese requires reordering (as suggested by the
softmax-attention model’s alignment), so the hard mono-
tonic alignment model focuses attention on the ﬁnal word
in the phrase (“famine”) while producing its translation.
We suspect our model’s small decrease in BLEU compared
to the baseline model may be due in part to this increased
modeling burden.

5. Discussion

Our results show that our differentiable approach to enforc-
ing monotonic alignments can produce models which, fol-
lowing the decoding process of section 2.2, provide efﬁ-
cient online decoding at test time without sacriﬁcing sub-
stantial performance on a wide variety of tasks. We believe
our framework presents a promising environment for fu-
ture work on online and linear-time sequence-to-sequence
models. We are interested in investigating various exten-
sions to this approach, which we outline in appendix E.
To facilitate experimentation with our proposed attention
mechanism, we have made an example TensorFlow (Abadi
et al., 2016) implementation of our approach available on-
line3 and added a reference implementation to Tensor-
Flow’s tf.contrib.seq2seq module. We also pro-
vide a “practitioner’s guide” in appendix G.

a(si−1, hj) = g(s(cid:62)

i−1W h) + r

(17)

3https://github.com/craffel/mad

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Acknowledgements

We thank Jan Chorowski, Mark Daoust, Pietro Kreit-
lon Carolino, Dieterich Lawson, Navdeep Jaitly, George
Tucker, Quoc V. Le, Kelvin Xu, Cinjon Resnick, Melody
Guan, Matthew D. Hoffman, Jeffrey Dean, Kevin Swersky,
Ashish Vaswani, and members of the Google Brain team
for helpful discussions and insight.

References

Abadi, Martin, Barham, Paul, Chen, Jianmin, Chen,
Zhifeng, Davis, Andy, Dean, Jeffrey, Devin, Matthieu,
Ghemawat, Sanjay, Irving, Geoffrey, Isard, Michael,
Kudlur, Manjunath, Levenberg, Josh, Monga, Rajat,
Moore, Sherry, Murray, Derek G., Steiner, Benoit,
Tucker, Paul, Vasudevan, Vijay, Warden, Pete, Wicke,
Martin, Yu, Yuan, and Zheng, Xiaoqiang. TensorFlow:
A system for large-scale machine learning. In Operating
Systems Design and Implementation, 2016.

Aharoni, Roee and Goldberg, Yoav. Sequence to sequence
arXiv

transduction with hard monotonic attention.
preprint arXiv:1611.01487, 2016.

Bahdanau, Dzmitry, Cho, Kyunghyun, and Bengio,
Yoshua. Neural machine translation by jointly learning
In International Conference on
to align and translate.
Learning Representations, 2015.

Cettolo, Mauro, Niehues, Jan, Stüker, Sebastian, Ben-
tivogli, Luisa, Cattoni, Roldano, and Federico, Marcello.
The IWSLT 2015 evaluation campaign. In International
Workshop on Spoken Language Translation, 2015.

Chan, William, Jaitly, Navdeep, Le, Quoc V., and Vinyals,
Oriol. Listen, attend and spell: A neural network for
large vocabulary conversational speech recognition. In
International Conference on Acoustics, Speech and Sig-
nal Processing, 2016.

Cho, Kyunghyun, van Merriënboer, Bart, Gülçehre, Ça˘glar,
Bahdanau, Dzmitry, Bougares, Fethi, Schwenk, Holger,
and Bengio, Yoshua. Learning phrase representations us-
ing RNN encoder–decoder for statistical machine trans-
lation. In Conference on Empirical Methods in Natural
Language Processing, 2014.

Chopra, Sumit, Auli, Michael, and Rush, Alexander M.
Abstractive sentence summarization with attentive recur-
rent neural networks. Conference of the North American
Chapter of the Association for Computational Linguis-
tics: Human Language Technologies, 2016.

Chorowski, Jan, Bahdanau, Dzmitry, Serdyuk, Dmitriy,
Cho, Kyunghyun, and Bengio, Yoshua. Attention-based
models for speech recognition. In Conference on Neural
Information Processing Systems, 2015.

Chung, Junyoung, Gulcehre, Caglar, Cho, Kyunghyun, and
Bengio, Yoshua. Empirical evaluation of gated recurrent
neural networks on sequence modeling. arXiv preprint
arXiv:1412.3555, 2014.

Foerster, Jakob, Assael, Yannis M., de Freitas, Nando, and
Whiteson, Shimon. Learning to communicate with deep
multi-agent reinforcement learning. In Advances in Neu-
ral Information Processing Systems, 2016.

Frey, Brendan J. Continuous sigmoidal belief networks
trained using slice sampling. Advances in neural infor-
mation processing systems, 1997.

Garofolo, John S., Lamel, Lori F., Fisher, William M., Fis-
cus, Jonathon G., and Pallett, David S. DARPA TIMIT
acoustic-phonetic continous speech corpus. 1993.

Graves, Alex. Sequence transduction with recurrent neural

networks. arXiv preprint arXiv:1211.3711, 2012.

Graves, Alex. Generating sequences with recurrent neural

networks. arXiv preprint arXiv:1308.0850, 2013.

Graves, Alex, Fernández, Santiago, Gomez, Faustino, and
Schmidhuber, Jürgen. Connectionist temporal classiﬁ-
cation: labelling unsegmented sequence data with recur-
rent neural networks. In International conference on Ma-
chine learning, 2006.

Graves, Alex, Mohamed, Abdel-rahman, and Hinton, Ge-
offrey. Speech recognition with deep recurrent neural
In International Conference on Acoustics,
networks.
Speech and Signal Processing, 2013.

Graves, Alex, Wayne, Greg, and Danihelka, Ivo. Neural
turing machines. arXiv preprint arXiv:1410.5401, 2014.

Hochreiter, Sepp and Schmidhuber, Jürgen. Long short-

term memory. Neural computation, 9(8), 1997.

Jaitly, Navdeep, Sussillo, David, Le, Quoc V., Vinyals,
Oriol, Sutskever, Ilya, and Bengio, Samy. A neural trans-
ducer. arXiv preprint arXiv:1511.04868, 2015.

Jang, Eric, Gu, Shixiang, and Poole, Ben. Categorical
reparameterization with gumbel-softmax. arXiv preprint
arXiv:1611.01144, 2016.

Chorowski, Jan and Jaitly, Navdeep. Towards better decod-
ing and language model integration in sequence to se-
quence models. arXiv preprint arXiv:1612.02695, 2017.

Kim, Yoon, Denton, Carl, Hoang, Luong, and Rush,
arXiv

Alexander M. Structured attention networks.
preprint arXiv:1702.00887, 2017.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Kingma, Diederik and Ba,

Jimmy.
method for stochastic optimization.
arXiv:1412.6980, 2014.

Adam:

A
arXiv preprint

Kong, Lingpeng, Dyer, Chris, and Smith, Noah A. Seg-
arXiv preprint

mental recurrent neural networks.
arXiv:1511.06018, 2015.

Liu, Peter J. and Pan, Xin. Text summarization with Ten-

sorFlow. http://goo.gl/16RNEu, 2016.

Luo, Yuping, Chiu, Chung-Cheng, Jaitly, Navdeep, and
Learning online alignments with
arXiv preprint

Sutskever,
continuous rewards policy gradient.
arXiv:1608.01281, 2016.

Ilya.

Luong, Minh-Thang and Manning, Christopher D. Stan-
ford neural machine translation systems for spoken lan-
In International Workshop on Spoken
guage domain.
Language Translation, 2015.

Luong, Minh-Thang, Pham, Hieu, and Manning, Christo-
pher D. Effective approaches to attention-based neural
machine translation. In Conference on Empirical Meth-
ods in Natural Language Processing, 2015.

concrete distribution:

Maddison, Chris J., Mnih, Andriy, and Teh, Yee Whye.
relax-
arXiv preprint

The
ation of discrete random variables.
arXiv:1611.00712, 2016.

A continuous

Miao, Yishu and Blunsom, Phil. Language as a latent vari-
able: Discrete generative models for sentence compres-
sion. arXiv preprint arXiv:1609.07317, 2016.

Nallapati, Ramesh,

Zhou, Bowen,

dos Santos,
and Xiang,
Cícero Nogueira, Gülçehre, Çaglar,
Bing. Abstractive text summarization using sequence-
In Conference on
to-sequence RNNs and beyond.
Computational Natural Language Learning, 2016.

Paul, Douglas B. and Baker, Janet M. The design for the
Wall Street Journal-based CSR corpus. In Workshop on
Speech and Natural Language, 1992.

Salimans, Tim and Kingma, Diederik P. Weight normaliza-
tion: A simple reparameterization to accelerate training
of deep neural networks. In Advances in Neural Infor-
mation Processing Systems, 2016.

Sukhbaatar, Sainbayar, Szlam, Arthur, Weston, Jason, and
Fergus, Rob. End-to-end memory networks. In Advances
in neural information processing systems, 2015.

Sutskever, Ilya, Vinyals, Oriol, and Le, Quoc V. Sequence
to sequence learning with neural networks. In Advances
in neural information processing systems, 2014.

Suzuki, Jun and Nagata, Masaaki. Cutting-off redundant
repeating generations for neural abstractive summariza-
tion. arXiv preprint arXiv:1701.00138, 2017.

Wang, Chong, Yogatama, Dani, Coates, Adam, Han, Tony,
Hannun, Awni, and Xiao, Bo. Lookahead convolution
In
layer for unidirectional recurrent neural networks.
Workshop Extended Abstracts of the 4th International
Conference on Learning Representations, 2016.

Xu, Kelvin, Ba, Jimmy, Kiros, Ryan, Cho, Kyunghyun,
Courville, Aaron, Salakhudinov, Ruslan, Zemel, Rich,
and Bengio, Yoshua. Show, attend and tell: Neural im-
age caption generation with visual attention. In Interna-
tional Conference on Machine Learning, 2015.

Yu, Lei, Blunsom, Phil, Dyer, Chris, Grefenstette, Edward,
and Kocisky, Tomas. The neural noisy channel. arXiv
preprint arXiv:1611.02554, 2016a.

Yu, Lei, Buys, Jan, and Blunsom, Phil. Online segment to
segment neural transduction. In Conference on Empiri-
cal Methods in Natural Language Processing, 2016b.

Zaremba, Wojciech and Sutskever,

Reinforce-
ment learning neural turing machines. arXiv preprint
arXiv:1505.00521, 362, 2015.

Ilya.

Zeng, Wenyuan, Luo, Wenjie, Fidler, Sanja, and Urta-
sun, Raquel. Efﬁcient summarization with read-again
and copy mechanism. arXiv preprint arXiv:1611.03382,
2016.

Raffel, Colin and Lawson, Dieterich. Training a sub-
arXiv preprint

sampling mechanism in expectation.
arXiv:1702.06914, 2017.

Zhang, Yu, Chan, William, and Jaitly, Navdeep. Very deep
convolutional networks for end-to-end speech recogni-
tion. arXiv preprint arXiv:1610.03022, 2016.

Rush, Alexander M., Chopra, Sumit, and Weston, Jason. A
neural attention model for abstractive sentence summa-
rization. In Conference on Empirical Methods in Natural
Language Processing, 2015.

Salakhutdinov, Ruslan and Hinton, Geoffrey. Semantic
hashing. International Journal of Approximate Reason-
ing, 50(7), 2009.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

A. Algorithms

Below are algorithms for the hard monotonic decoding process we used at test time (algorithm 1) and the approach for
computing its expected output that we used to train the network (algorithm 2). Terminology matches the main text, except
we use (cid:126)0 to signify a vector of zeros.

Algorithm 1 Hard Monotonic Attention Process

Input: memory h of length T
State: s0 = (cid:126)0, t0 = 1, i = 1, y0 = StartOfSequence
while yi−1 (cid:54)= EndOfSequence do

// Produce output tokens until end-of-sequence token is produced

// Keep track of whether we chose a memory entry or not

ﬁnished = 0
for j = ti−1 to T do
ei,j = a(si−1, hj)
pi,j = σ(ei,j)
zi,j ∼ Bernoulli(pi,j)
if zi,j = 1 then // If we sample 1, we stop scanning the memory
// Set the context vector to the chosen memory entry

// Start inspecting memory entries hj left-to-right from where we left off
// Compute attention energy for hj
// Compute probability of choosing hj

// Sample whether to ingest another memory entry or output new symbol

ci = hj
ti = j
ﬁnished = 1
break // Stop scanning the memory

// Remember where we left off for the next output timestep

// Keep track of the fact that we chose a memory entry

end if
end for
if ﬁnished = 0 then

ci = (cid:126)0

end if
si = f (si−1, yi−1, ci)
yi = g(si, ci)
i = i + 1

end while

// If we scanned the entire memory without selecting anything, set ci to a vector of zeros

// Update the state based on the new context vector using the RNN f

// Output a new symbol using the softmax layer g

Algorithm 2 Soft Monotonic Attention Decoder

Input: memory h of length T , target outputs ˆy = {StartOfSequence, ˆy1, ˆy2, . . . , EndOfSequence}
State: s0 = (cid:126)0, i = 1, α0,j = δj for j ∈ {1, . . . , T }
while ˆyi−1 (cid:54)= EndOfSequence do

// Produce output tokens until end of the target sequence

pi,0 = 0, qi,0 = 0
for j = 1 to T do

// Special cases so that the recurrence relation matches eq. (9)
// Inspect all memory entries hj

ei,j = a(si−1, hj)
ei,j = ei,j + N (0, 1)
pi,j = σ(ei,j)
qi,j = (1 − pi,j−1)qi,j−1 + αi−1,j
αi,j = pi,jqi,j

// Compute attention energy for hj using eq. (16)

// Add pre-sigmoid noise to encourage pi,j ≈ 0 or pi,j ≈ 1

// Compute probability of choosing hj

// Iterate recurrence relation derived in eq. (10)

// Compute the probability that ci = hj

// Compute weighted combination of memory for context vector

// Update the state based on the new context vector using the RNN f

// Compute predicted output for timestep i using the softmax layer g

j=1 αi,jhj

end for
ci = (cid:80)T
si = f (si−1, yi−1, ci)
yi = g(si, ci)
i = i + 1

end while

Online and Linear-Time Attention by Enforcing Monotonic Alignments

B. Figures

Below are example hard monotonic and softmax attention alignments for each of the different tasks we included in our
experiments. Attention matrices are displayed so that black corresponds to 1 and white corresponds to 0.

Figure 4. Attention alignments from hard monotonic attention and softmax-based attention models for a two example speech utterances.
From top to bottom, we show the hard monotonic alignment, the softmax-attention alignment, and the utterance feature sequence.
Differences in the alignments are highlighted with dashed red circles. Gaps in the alignment paths correspond to effectively ignoring
silences and pauses in the speech utterances.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Figure 5. English sentences, predicted Vietnamese sentences, and input-output alignments for our proposed hard monotonic alignment
model and the baseline model of (Luong & Manning, 2015). The Vietnamese model outputs for the left example can be translated back
to English as “And I on this stage because I am a model.” (monotonic) and “And I am on this stage because I am a structure.” (softmax).
The input word “model” can mean either a person or a thing; the monotonic alignment model correctly chose the former while the
softmax alignment model chose the latter. The monotonic alignment model erroneously skipped the ﬁrst verb in the sentence. For the
right example, translations of the model outputs back to English are “A large famine in North Korea.” (monotonic) and “An invasion
of a huge famine in <unk>.” (softmax). The monotonic alignment model managed to translate the proper noun North Korea, while
the softmax alignment model produced <unk>. Both models skipped the phrase “mid-1990s”; this type of error is common in neural
machine translation systems.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Figure 6. Additional example sentence-summary pair and attention alignment matrices for our hard monotonic model and the softmax-
based attention model of (Liu & Pan, 2016). The ground-truth summary is “china attacks us human rights”.

C. Monotonic Attention Distribution

Recall that our goal is to compute the expected value of ci under the stochastic process deﬁned by eqs. (6) to (8). To achieve
this, we will derive an expression for the probability that ci = hj for j ∈ {1, . . . , T }, which in accordance with eq. (2) we
denote αi,j. For i = 1, α1,j is the probability that memory element j was chosen (p1,j) multiplied by the probability that
memory elements k ∈ {1, 2, . . . , j − 1} were not chosen ((1 − pi,k)), giving

α1,j = p1,j

(1 − p1,k)

j−1
(cid:89)

k=1

αi,j = pi,j

αi−1,k

(1 − pi,l)

(cid:32)

j
(cid:88)

k=1

j−1
(cid:89)

l=k

(cid:33)

For i > 0, in order for ci = hj we must have that ci−1 = hk for some k ∈ {1, . . . , j} (which occurs with probability
αi−1,k) and that none of hk, . . . , hj−1 were chosen. Summing over possible values of k, we have

where for convenience we deﬁne (cid:81)m
n x = 1 when n > m. We provide a schematic and explanation of eq. (19) in ﬁg. 7.
Note that we can recover eq. (18) from eq. (19) by deﬁning the special case α0,j = δj (i.e. α0,1 = 1 and α0,j = 0 for
j ∈ {2, . . . , T }). Expanding eq. (19) reveals we can compute αi,j directly given αi−1,j and αi,j−1:

αi,j = pi,j

αi−1,k

(1−pi,l)

+αi−1,j

(cid:33)

(cid:33)

(cid:32) j−1
(cid:88)

(cid:32)

k=1

(cid:32)

(cid:18)

j−1
(cid:89)

l=k

j−1
(cid:88)

(cid:32)

k=1
αi,j−1
pi,j−1

j−2
(cid:89)

l=k

(cid:19)

= pi,j

(1 − pi,j−1)

+ αi−1,j

= pi,j

(1 − pi,j−1)

αi−1,k

(1 − pi,l)

+ αi−1,j

(cid:33)

(cid:33)

(18)

(19)

(20)

(21)

(22)

Deﬁning qi,j = αi,j/pi,j produces eqs. (13) and (14). Equation (22) also has an intuitive interpretation: The expression
(1 − pi,j−1)αi,j−1/pi,j−1 represents the probability that the model attended to memory item j − 1 at output timestep i,
adjusted for the fact that memory item j − 1 was not chosen by multiplying (1 − pi,j−1) and dividing pi,j−1. Adding
αi−1,j reﬂects the additional possibility that the model attended to memory item j at the previous output timestep, and
multiplying by pi,j enforces that memory item j was chosen at the current output timestep i.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Figure 7. Visualization of eq. (19). In this example, we are showing the computation of α3,4. Each grid shows each of the four terms
in the summation, corresponding to the possibilities that we attended to memory item k = 1, 2, 3, 4 at the previous output timestep
i − 1 = 2. Gray nodes with curved arrows represent the probability of not selecting to the lth memory entry (1 − pi,l). The black nodes
represent the possibility of attending to memory item j at timestep i.

C.1. Recurrence Relation Solution

While eqs. (10) and (22) allow us to compute αi,j directly from αi−1,j and αi,j−1, the dependence on αi,j−1 means that
we must compute the terms αi,1, αi,2, . . . , αi,T sequentially. This is in contrast to softmax attention, where these terms
can be computed in parallel because they are independent. Fortunately, there is a solution to the recurrence relation of
eq. (10) which allows the terms of αi to be computed directly via parallelizable cumulative sum and cumulative product
operations. Using eq. (13) which substitutes qi,j = αi,j/pi,j, we have

qi,j = (1 − pi,j−1)qi,j−1 + αi−1,j

qi,j − (1 − pi,j−1)qi,j−1 = αi−1,j

qi,j
k=1(1 − pi,k−1)
qi,j
k=1(1 − pi,k−1)

(cid:81)j

(cid:81)j

−

−

(cid:32)

j
(cid:88)

l=1

qi,l
k=1(1 − pi,k−1)

(cid:81)l

−

(cid:81)l−1

(1 − pi,j−1)qi,j−1
(cid:81)j
k=1(1 − pi,k−1)
qi,j−1
k=1(1 − pi,k−1)
(cid:33)

(cid:81)j−1

qi,l−1
k=1(1 − pi,k−1)

=

=

=

qi,j
k=1(1 − pi,k−1)

(cid:81)j

− qi,0 =

αi−1,j
k=1(1 − pi,k−1)
αi−1,j
k=1(1 − pi,k−1)

αi−1,l
k=1(1 − pi,k−1)

(cid:81)l

αi−1,l
k=1(1 − pi,k−1)

(cid:81)l

(cid:81)j

(cid:81)j

j
(cid:88)

l=1

j
(cid:88)

l=1
(cid:32) j
(cid:89)

k=1

qi,j =

(1 − pi,k−1)

(cid:33) (cid:32) j

(cid:33)

(cid:88)

l=1

(cid:81)l

αi−1,l
k=1(1 − pi,k−1)
(cid:18)

αi−1
cumprod(1 − pi)

(cid:19)

⇒ qi = cumprod(1 − pi)cumsum

(23)

(24)

(25)

(26)

(27)

(28)

(29)

(30)

where cumprod(x) = [1, x1, x1x2, . . . , (cid:81)|x|−1
i xi]. Note that we use the
“exclusive” variant of cumprod4 in keeping with our deﬁned special case pi,0 = 0. Unlike the recurrence relation of
eq. (10), these operations can be computed efﬁciently in parallel (Ladner & Fischer, 1980). The primary disadvantage
of this approach is that the product in the denominator of eq. (29) can cause numerical instabilities; we address this in
appendix G.

xi] and cumsum(x) = [x1, x1 + x2, . . . , (cid:80)|x|

i

4This can be computed e.g. in Tensorﬂow via tf.cumprod(x, exclusive=True)

Online and Linear-Time Attention by Enforcing Monotonic Alignments

D. Experiment Details

In this section, we give further details into the models and
training procedures used in section 4. Any further ques-
tions about implementation details should be directed to the
corresponding author. All models were implemented with
TensorFlow (Abadi et al., 2016).

D.1. Speech Recognition

D.1.1. TIMIT

Mel ﬁlterbank features were standardized to have zero
mean and unit variance across feature dimensions accord-
ing to their training set statistics and were fed directly into
an RNN encoder with three unidirectional LSTM layers,
each with 512 hidden units. After the ﬁrst and second
LSTM layers, we downsampled hidden state sequences by
skipping every other state before feeding into the subse-
quent layer. For the decoder, we used a single unidirec-
tional LSTM layer with 256 units, fed directly into the out-
put softmax layer. All weight matrices were initialized uni-
formly from [−0.075, 0.075]. The output tokens were em-
bedded via a learned embedding matrix with dimensional-
ity 30, initialized uniformly from [−(cid:112)3/30, (cid:112)3/30]. Our
decoder attention energy function used a hidden dimen-
sionality of 512, with the scalar bias r initialized to -1.
The model was regularized by adding weight noise with
a standard deviation of 0.5 after 2,000 training updates.
L2 weight regularization was also applied with a weight
of 10−6.

We trained the network using Adam (Kingma & Ba, 2014),
with β1 = 0.9, β2 = 0.999, and (cid:15) = 10−6. Utter-
ances were fed to the network with a minibatch size of
4. Our initial learning rate was 10−4, which we halved
after 40,000 training steps. We clipped gradients when
their global norm exceeded 2. We used three training repli-
cas. Beam search decoding was used to produce output
sequences with a beam width of 10.

D.1.2. WALL STREET JOURNAL

The input 80 mel ﬁlterbank / delta / delta-delta features
were organized as a T × 80 × 3 tensor, i.e. raw features,
deltas, and delta-deltas are concatenated along the “depth”
dimension. This was passed into a stack of two convolu-
tional layers with ReLU activations, each consisting of 32
3×3× depth kernels in time × frequency. These were both
strided by 2 × 2 in order to downsample the sequence in
time, minimizing the computation performed in the follow-
ing layers. Batch normalization (Ioffe & Szegedy, 2015)
was applied prior to the ReLU activation in each layer. All
encoder weight matrices and ﬁlters were initialized via a
truncated Gaussian with zero mean and a standard devia-
tion of 0.1.

This downsampled feature sequence was then passed into a
single unidirectional convolutional LSTM layer using 1x3
ﬁlter (i.e. only convolving across the frequency dimension
within each timestep). Finally, this was passed into a stack
of three unidirectional LSTM layers of size 256, inter-
leaved with a 256 dimensional linear projection, following
by batch normalization, and a ReLU activation. Decoder
weight matrices were initialized uniformly at random from
[−0.1, 0.1].

The decoder input is created by concatenating a 64 dimen-
sional embedding corresponding to the symbol emitted at
the previous timestep, and the 256 dimensional attention
context vector. The embedding was initialized uniformly
from [−1, 1]. This was passed into a single unidirectional
LSTM layer with 256 units. We used an attention energy
function hidden dimensionality of 128 and initialized the
bias scalar r to -4. Finally the concatenation of the atten-
tion context and LSTM output is passed into the softmax
output layer.

We applied label smoothing (Chorowski & Jaitly, 2017),
the target at time t, with (0.015ˆyt−2 +
replacing ˆyt,
0.035ˆyt−1 + ˆyt + 0.035ˆyt+1 + 0.015ˆyt+2)/1.1. We used
beam search decoding at test time with rank pruning at 8
hypotheses and a pruning threshold of 3.

The network was trained using teacher forcing on mini-
batches of 8 input utterances, optimized using Adam
(Kingma & Ba, 2014) with β1 = 0.9, β2 = 0.999, and
(cid:15) = 10−6. Gradients were clipped to a maximum global
norm of 1. We set the initial learning rate to 0.0002 and
decayed by a factor of 10 after 700,000, 1,000,000, and
1,300,000 training steps. L2 weight decay is used with a
weight of 10−6, and, beginning from step 20,000, Gaussian
weight noise with standard deviation of 0.075 was added to
weights for all LSTM layers and decoder embeddings. We
trained using 16 replicas.

D.2. Sentence Summarization

For data preparation, we used the same Gigaword data pro-
cessing scripts provided in (Rush et al., 2015) and tok-
enized into words by splitting on spaces. The vocabulary
was determined by selecting the most frequent 200,000 to-
kens. Only the tokens of the ﬁrst sentence of the article
were used as input to the model. An embedding layer was
used to embed tokens into a 200 dimensional space; em-
beddings were initialized using random normal distribution
with mean 0 and standard deviation 10−4.

We used a 4-layer bidirectional LSTM encoder with 4 lay-
ers and a single-layer unidirectional LSTM decoder. All
LSTMs, and the attention energy function, had a hidden di-
mensionality of 256. The decoder LSTM was fed directly
into the softmax output layer. All weights were initialized

Online and Linear-Time Attention by Enforcing Monotonic Alignments

uniform-randomly between −0.1 and 0.1.
In our mono-
tonic alignment decoder, we initialized r to -4. At test time,
we used a beam search over possible label sequences with
a beam width of 4.

A batch size of 64 was used and the model was trained
to minimize the sampled-softmax cross-entropy loss with
4096 negative samples. The Adam optimizer (Kingma &
Ba, 2014) was used with β1 = 0.9, β2 = 0.999, and
(cid:15) = 10−4, and an initial learning rate of 10−3; an expo-
nential decay was applied by multiplying the initial learn-
ing rate by .98n/30000 where n is the current training step.
Gradients were clipped to have a maximum global norm
of 2. Early stopping was used with respect to validation
loss and took about 300,000 steps for the baseline model,
and 180,000 steps for the monotonic model. Training was
conducted on 16 machines with 4 GPUs each. We reported
ROUGE scores computed over the test set of (Rush et al.,
2015).

D.3. Machine Translation

Overall, we followed the model of (Luong & Man-
ning, 2015) closely; our hyperparameters are largely the
same: Words were mapped to 512-dimensional embed-
dings, which were learned during training. We passed sen-
tences to the network in minibatches of size 128. As men-
tioned in the text, we used two unidirectional LSTM lay-
ers in both the encoder and decoder. All LSTM layers,
and the attention energy function, had a hidden dimen-
sionality of 512. We trained with a single replica for 40
epochs using Adam (Kingma & Ba, 2014) with β1 = 0.9,
β2 = 0.999, and (cid:15) = 10−8. We performed grid searches
over initial learning rate and decay schedules separately for
models using each of the two energy functions eq. (16) and
eq. (17). For the model using eq. (16), we used an ini-
tial learning rate of 0.0005, and after 10 epochs we mul-
tiplied the learning rate by 0.8 each epoch; for eq. (17)
we started at 0.001 and multiplied by 0.8 each epoch start-
ing at the eighth epoch. Parameters were uniformly initial-
ized in range [−0.1, 0.1]. Gradients were scaled whenever
their norms exceeded 5. We used dropout with probability
0.3 as described in (Pham et al., 2014). Unlike (Luong &
Manning, 2015), we did not reverse source sentences in our
monotonic attention experiments. We set r = −2 for the
attention energy function bias scalar for both eq. (16) and
eq. (17). We used greedy decoding (i.e. no beam search) at
test time.

E. Future Work

We believe there are a variety of promising extensions
of our monotonic attention mechanism, which we outline
brieﬂy below.

• The primary drawback of training in expectation is
that it retains the quadratic complexity during training.
One idea would be to replace the cumulative product
in eq. (9) with the thresholded remainder method of
(Graves, 2016) and (Grefenstette et al., 2015), but in
preliminary experiments we were unable to successfully
learn alignments with this approach. Alternatively, we
could further our investigation into gradient estimators
for discrete decisions (such as REINFORCE or straight-
through) instead of training in expectation (Bengio et al.,
2013).

• As we point out in section 2.4, our method can fail when
the attention energies ei,j are poorly scaled. This primar-
ily stems from the strict enforcement of monotonicity.
One possibility to mitigate this would be to instead reg-
ularize the model with a soft penalty which discourages
non-monotonic alignments, instead of preventing them
outright.

• In some problems, the input-output alignment is non-
monotonic only in small regions. A simple modiﬁca-
tion to our approach which would allow this would be
to subtract a constant integer from ti−1 between output
timesteps. Alternatively, utilizing multiple monotonic
attention mechanisms in parallel would allow the model
to attend to disparate memory locations at each output
timestep (effectively allowing for non-monotonic align-
ments) while still maintaining linear-time decoding.

• To facilitate comparison, we sought to modify the stan-
dard softmax-based attention framework as little as pos-
sible. As a result, we have thus far not fully taken advan-
tage of the fact that the decoding process is much more
efﬁcient. Speciﬁcally, the attention energy function of
eq. (15) was primarily motivated by the fact that it is
trivially parallelizable so that its repeated application is
inexpensive. We could instead use a recurrent attention
energy function, whose output depends on both the at-
tention energies for prior memory items and those at the
previous output timestep.

F. How much faster is linear-time decoding?

Throughout this paper, we have emphasized that one ad-
vantage of our approach is that it allows for linear-time de-
coding, i.e. the decoder RNN only makes a single pass over
the memory in the course of producing the output sequence.
However, we have thus far not attempted to quantify how
much of a speedup this incurs in practice. Towards this
end, we conducted an additional experiment to measure the
speed of efﬁciently-implemented softmax-based and hard
monotonic attention mechanisms. We chose to focus solely
on the speed of the attention mechanisms rather than an en-
tire RNN sequence-to-sequence model because models us-
ing these attention mechanisms are otherwise equivalent.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

emphasize that at training time, we expect our soft mono-
tonic attention approach to have roughly the computational
cost as standard softmax attention, thanks to the fact that
we can compute the resulting attention distribution in par-
allel as described in appendix C.1. The code used for this
benchmark is available in the repository for this paper.5

G. Practitioner’s Guide

Because we are proposing a novel attention mechanism, we
share here some insights gained from applying it in various
settings in order to help practitioners try it on their own
problems:

• The recursive structure of computing αi,j in eq. (9) can
result in exploding gradients. We found it vital to apply
gradient clipping in all of our experiments, as described
in appendix D.

• Many automatic differentiation packages can produce
numerically unstable gradients when using their cumula-
tive product function.67 Our simple solution was to com-
pute the product in log-space, i.e. replacing (cid:81)
n xn =
exp((cid:80)

i log(xn)).

• In addition, the product in the denominator of eq. (29)
can become negligibly small because the terms (1 −
pi,k−1) all fall in the range [0, 1]. The simplest way to
prevent the resulting numerical instabilities is to clip the
range of the denominator to be within [(cid:15), 1] where (cid:15) is a
small constant (we used (cid:15) = 10−10). This can result in
incorrect values for αi,j particularly when some pi,j are
close to 1, but we encountered no discernible effect on
our results.

• Alternatively, we found in preliminary experiments that
simply setting the denominator to 1 still produced good
results. This can be explained by the observation that
when all pi,j ∈ {0, 1} (which we encourage during train-
ing), eq. (29) is equivalent to the recurrence relation of
eq. (10) even when the denominator is 1.

• As we mention in the experiment details of the previous
section, we ended up using a small range of values for
the initial energy function scalar bias r. In general, per-
formance was not very sensitive to this parameter, but
we found small performance gains from using values in
{−5, −4, −3, −2, −1} for different problems.

• More broadly, while the attention energy function mod-
iﬁcations described in section 2.4 allowed models using
our mechanism to be effectively trained on all tasks we

5https://github.com/craffel/mad
6https://github.com/tensorflow/

tensorflow/issues/3862

7https://github.com/Theano/Theano/issues/

5197

Figure 8. Speedup of hard monotonic attention mechanism com-
pared to softmax attention on a synthetic benchmark.

Measuring the speed of the attention mechanisms alone al-
lows us to isolate the difference in computational cost be-
tween the two approaches.

Speciﬁcally, we implemented both attention mechanisms
using the highly-efﬁcient C++ linear algebra package Eigen
(Guennebaud et al., 2010). We set entries of the mem-
ory h and the decoder hidden states si to random vectors
with entries sampled uniformly in the range [−1, 1]. We
then computed context vectors following eqs. (2) and (3)
for the softmax attention mechanism and following algo-
rithm 1 for hard monotonic attention. We varied the input
and output sequence lengths and averaged the time to pro-
duce all of the corresponding context vectors over 100 trials
for each setting.

The speedup of the monotonic attention mechanism com-
pared to softmax attention is visualized in ﬁg. 8. We found
monotonic attention to be about 4 − 40× faster depending
on the input and output sequence lengths. The most promi-
nent difference occurred for short input sequences and long
output sequences; in these cases the monotonic attention
mechanism ﬁnishes processing the input sequence before
it ﬁnishes producing the output sequence and therefore is
able to stop computing context vectors. We emphasize that
these numbers represent the best-case speedup from our
approach; a more general insight is simply that our pro-
posed hard monotonic attention mechanism has the poten-
tial to make decoding signiﬁcantly more efﬁcient for long
sequences. Additionally, this advantage is distinct from the
fact that our hard monotonic attention mechanism can be
used for online sequence-to-sequence problems. We also

Online and Linear-Time Attention by Enforcing Monotonic Alignments

tried, they were not always necessary for convergence.
Speciﬁcally, in speech recognition experiments the per-
formance of our model was the same using eq. (15) and
eq. (16), but for summarization experiments the mod-
els were unable to learn to utilize attention when using
eq. (15). For ease of implementation, we recommend
starting with the standard attention energy function of
eq. (15) and then applying the modiﬁcations of eq. (16)
if the model fails to utilize attention.

• It is occasionally recommended to reverse the input se-
quence prior to feeding it into sequence-to-sequence
models (Sutskever et al., 2014). This violates our as-
sumption that the input should be processed in a left-
to-right manner when computing attention, so should be
avoided.

• Finally, we highly recommend visualizing the attention
alignments αi,j over the course of training. Attention
provides valuable insight into the model’s behavior, and
failure modes can be quickly spotted (e.g. if αi,j = 0 for
all i and j).

With the above factors in mind, on all problems we studied,
we were able to replace softmax-based attention with our
novel attention and immediately achieve competitive per-
formance.

References

Abadi, Martin, Barham, Paul, Chen, Jianmin, Chen,
Zhifeng, Davis, Andy, Dean, Jeffrey, Devin, Matthieu,
Ghemawat, Sanjay, Irving, Geoffrey, Isard, Michael,
Kudlur, Manjunath, Levenberg, Josh, Monga, Rajat,
Moore, Sherry, Murray, Derek G., Steiner, Benoit,
Tucker, Paul, Vasudevan, Vijay, Warden, Pete, Wicke,
Martin, Yu, Yuan, and Zheng, Xiaoqiang. TensorFlow:
A system for large-scale machine learning. In Operating
Systems Design and Implementation, 2016.

Graves, Alex. Adaptive computation time for recurrent
arXiv preprint arXiv:1603.08983,

neural networks.
2016.

Grefenstette, Edward, Hermann, Karl Moritz, Suleyman,
Mustafa, and Blunsom, Phil. Learning to transduce with
unbounded memory. In Advances in Neural Information
Processing Systems, 2015.

Guennebaud, Gaël, Jacob, Benoıt, Avery, Philip, Bachrach,
Eigen v3.

Abraham, Barthelemy, Sebastien, et al.
http://eigen.tuxfamily.org, 2010.

Ioffe, Sergey and Szegedy, Christian. Batch normalization:
Accelerating deep network training by reducing internal
covariate shift. In International Conference on Machine
Learning, 2015.

Kingma, Diederik and Ba,

Jimmy.
method for stochastic optimization.
arXiv:1412.6980, 2014.

Adam:

A
arXiv preprint

Ladner, Richard E. and Fischer, Michael J. Parallel preﬁx
computation. Journal of the ACM (JACM), 27(4):831–
838, 1980.

Liu, Peter J. and Pan, Xin. Text summarization with Ten-

sorFlow. http://goo.gl/16RNEu, 2016.

Luong, Minh-Thang and Manning, Christopher D. Stan-
ford neural machine translation systems for spoken lan-
In International Workshop on Spoken
guage domain.
Language Translation, 2015.

Pham, Vu, Bluche, Théodore, Kermorvant, Christopher,
and Louradour, Jérôme. Dropout improves recurrent
neural networks for handwriting recognition. In Interna-
tional Conference on Frontiers in Handwriting Recogni-
tion, 2014.

Bengio, Yoshua, Léonard, Nicholas, and Courville, Aaron.
Estimating or propagating gradients through stochastic
arXiv preprint
neurons for conditional computation.
arXiv:1308.3432, 2013.

Rush, Alexander M., Chopra, Sumit, and Weston, Jason. A
neural attention model for abstractive sentence summa-
rization. In Conference on Empirical Methods in Natural
Language Processing, 2015.

Chorowski, Jan and Jaitly, Navdeep. Towards better decod-
ing and language model integration in sequence to se-
quence models. arXiv preprint arXiv:1612.02695, 2017.

Sutskever, Ilya, Vinyals, Oriol, and Le, Quoc V. Sequence
to sequence learning with neural networks. In Advances
in neural information processing systems, 2014.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

7
1
0
2
 
n
u
J
 
9
2
 
 
]

G
L
.
s
c
[
 
 
2
v
4
8
7
0
0
.
4
0
7
1
:
v
i
X
r
a

Colin Raffel 1 Minh-Thang Luong 1 Peter J. Liu 1 Ron J. Weiss 1 Douglas Eck 1

Abstract

Recurrent neural network models with an atten-
tion mechanism have proven to be extremely
effective on a wide variety of sequence-to-
sequence problems. However, the fact that soft
attention mechanisms perform a pass over the
entire input sequence when producing each el-
ement in the output sequence precludes their use
in online settings and results in a quadratic time
complexity. Based on the insight that the align-
ment between input and output sequence ele-
ments is monotonic in many problems of interest,
we propose an end-to-end differentiable method
for learning monotonic alignments which, at test
time, enables computing attention online and in
linear time. We validate our approach on sen-
tence summarization, machine translation, and
online speech recognition problems and achieve
results competitive with existing sequence-to-
sequence models.

1. Introduction

the

“sequence-to-sequence”

Recently,
framework
(Sutskever et al., 2014; Cho et al., 2014) has facilitated
the use of recurrent neural networks (RNNs) on sequence
transduction problems such as machine translation and
speech recognition. In this framework, an input sequence
is processed with an RNN to produce an “encoding”; this
encoding is then used by a second RNN to produce the
target sequence. As originally proposed, the encoding is
a single ﬁxed-length vector representation of the input
sequence. This requires the model to effectively compress
all important information about the input sequence into a
single vector. In practice, this often results in the model
having difﬁculty generalizing to longer sequences than
those seen during training (Bahdanau et al., 2015).

An effective solution to these shortcomings are attention

1Google Brain, Mountain View, California, USA. Correspon-

dence to: Colin Raffel <craffel@gmail.com>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

In a sequence-to-
mechanisms (Bahdanau et al., 2015).
sequence model with attention, the encoder produces a se-
quence of hidden states (instead of a single ﬁxed-length
vector) which correspond to entries in the input sequence.
The decoder is then allowed to refer back to any of the en-
coder states as it produces its output. Similar mechanisms
have been used as soft addressing schemes in memory-
augmented neural network architectures (Graves et al.,
2014; Sukhbaatar et al., 2015) and RNNs used for sequence
generation (Graves, 2013). Attention-based sequence-to-
sequence models have proven to be extremely effective on
a wide variety of problems, including machine translation
(Bahdanau et al., 2015; Luong et al., 2015), image cap-
tioning (Xu et al., 2015), speech recognition (Chorowski
et al., 2015; Chan et al., 2016), and sentence summariza-
tion (Rush et al., 2015). In addition, attention creates an
implicit soft alignment between entries in the output se-
quence and entries in the input sequence, which can give
useful insight into the model’s behavior.

A common criticism of soft attention is that the model must
perform a pass over the entire input sequence when pro-
ducing each element of the output sequence. This results
in the decoding process having complexity O(T U ), where
T and U are the input and output sequence lengths respec-
tively. Furthermore, because the entire sequence must be
processed prior to outputting any symbols, soft attention
cannot be used in “online” settings where output sequence
elements are produced when the input has only been par-
tially observed.

The focus of this paper is to propose an alternative at-
tention mechanism which has linear-time complexity and
can be used in online settings. To achieve this, we ﬁrst
note that in many problems, the input-output alignment is
roughly monotonic. For example, when transcribing an
audio recording of someone saying “good morning”, the
region of the speech utterance corresponding to “good”
will always precede the region corresponding to “morn-
ing”. Even when the alignment is not strictly monotonic,
it often only contains local input-output reorderings. Sep-
arately, despite the fact that soft attention allows for as-
signment of focus to multiple disparate entries of the input
sequence, in many cases the attention is assigned mostly to
a single entry. For examples of alignments with these char-
acteristics, we refer to e.g. (Chorowski et al. 2015 Figure

Online and Linear-Time Attention by Enforcing Monotonic Alignments

2; Chan et al. 2016 Figure 2; Rush et al. 2015 Figure 1;
Bahdanau et al. 2015 Figure 3), etc. Of course, this is not
true in all problems; for example, when using soft attention
for image captioning, the model will often change focus
arbitrarily between output steps and will spread attention
across large regions of the input image (Xu et al., 2015).

Motivated by these observations, we propose using hard
monotonic alignments for sequence-to-sequence problems
because, as we argue in section 2.2, they enable computing
attention online and in linear time. Towards this end, we
show that it is possible to train such an attention mecha-
nism with a quadratic-time algorithm which computes its
expected output. This allows us to continue using standard
backpropagation for training while still facilitating efﬁcient
online decoding at test-time. On all problems we studied,
we found these added beneﬁts only incur a small decrease
in performance compared to softmax-based attention.

The rest of this paper is structured as follows: In the follow-
ing section, we develop an interpretation of soft attention as
optimizing a stochastic process in expectation and formu-
late a corresponding stochastic process which allows for
online and linear-time decoding by relying on hard mono-
tonic alignments. In analogy with soft attention, we then
show how to compute the expected output of the mono-
tonic attention process and elucidate how the resulting al-
gorithm differs from standard softmax attention. After giv-
ing an overview of related work, we apply our approach to
the tasks of sentence summarization, machine translation,
and online speech recognition, achieving results competi-
tive with existing sequence-to-sequence models. Finally,
we present additional derivations, experimental details, and
ideas for future research in the appendix.

2. Online and Linear-Time Attention

To motivate our approach, we ﬁrst point out that softmax-
based attention is computing the expected output of a sim-
ple stochastic process. We then detail an alternative process
which enables online and linear-time decoding. Because
this process is nondifferentiable, we derive an algorithm for
computing its expected output, allowing us to train a model
with standard backpropagation while applying our online
and linear-time process at test time. Finally, we propose
an alternative energy function motivated by the differences
between monotonic attention and softmax-based attention.

2.1. Soft Attention

To begin with, we review the commonly-used form of
soft attention proposed originally in (Bahdanau et al.,
2015). Broadly, a sequence-to-sequence model produces
a sequence of outputs based on a processed input se-
quence. The model consists of two RNNs, referred to

as the “encoder” and “decoder”. The encoder RNN pro-
cesses the input sequence x = {x1, . . . , xT } to produce
a sequence of hidden states h = {h1, . . . , hT }. We re-
fer to h as the “memory” to emphasize its connection to
memory-augmented neural networks (Graves et al., 2014;
Sukhbaatar et al., 2015). The decoder RNN then produces
an output sequence y = {y1, . . . , yU }, conditioned on the
memory, until a special end-of-sequence token is produced.

When computing yi, a soft attention-based decoder uses a
learnable nonlinear function a(·) to produce a scalar value
ei,j for each entry hj in the memory based on hj and the de-
coder’s state at the previous timestep si−1. Typically, a(·)
is a single-layer neural network using a tanh nonlinearity,
but other functions such as a simple dot product between
si−1 and hj have been used (Luong et al., 2015; Graves
et al., 2014). These scalar values are normalized using the
softmax function to produce a probability distribution over
the memory, which is used to compute a context vector ci as
the weighted sum of h. Because items in the memory have
a sequential correspondence with items in the input, these
attention distributions create a soft alignment between the
output and input. Finally, the decoder updates its state to si
based on si−1 and ci and produces yi. In total, producing
yi involves

ei,j = a(si−1, hj)

αi,j = exp(ei,j)

exp(ei,k)

(cid:30) T

(cid:88)

k=1

ci =

αi,jhj

T
(cid:88)

j=1

si = f (si−1, yi−1, ci)
yi = g(si, ci)

(1)

(2)

(3)

(4)

(5)

where f (·) is a recurrent neural network (typically one or
more LSTM (Hochreiter & Schmidhuber, 1997) or GRU
(Chung et al., 2014) layers) and g(·) is a learnable nonlinear
function which maps the decoder state to the output space
(e.g. an afﬁne transformation followed by a softmax when
the target sequences consist of discrete symbols).

To motivate our monotonic alignment scheme, we observe
that eqs. (2) and (3) are computing the expected output of
a simple stochastic process, which can be formulated as
follows: First, a probability αi,j is computed independently
for each entry hj of the memory. Then, a memory index k
is sampled by k ∼ Categorical(αi) and ci is set to hk. We
visualize this process in ﬁg. 1. Clearly, eq. (3) shows that
soft attention replaces sampling k and assigning ci = hk
with direct computation of the expected value of ci.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

the

stochastic process underlying
Figure 1. Schematic of
softmax-based attention decoders.
Each node represents a
possible alignment between an entry of the output sequence
(vertical axis) and the memory (horizontal axis). At each output
timestep, the decoder inspects all memory entries (indicated in
gray) and attends to a single one (indicated in black). A black
node indicates that memory element hj is aligned to output yi. In
terms of which memory entry is chosen, there is no dependence
across output timesteps or between memory entries.

Figure 2. Schematic of our novel monotonic stochastic decoding
process. At each output timestep, the decoder inspects memory
entries (indicated in gray) from left-to-right starting from where
it left off at the previous output timestep and chooses a single
one (indicated in black). A black node indicates that memory
element hj is aligned to output yi. White nodes indicate that a
particular input-output alignment was not considered because it
violates monotonicity. Arrows indicate the order of processing
and dependence between memory entries and output timesteps.

2.2. A Hard Monotonic Attention Process

The discussion above makes clear that softmax-based at-
tention requires a pass over the entire memory to compute
the terms αi,j required to produce each element of the out-
put sequence. This precludes its use in online settings, and
results in a complexity of O(T U ) for generating the out-
put sequence. In addition, despite the fact that h represents
a transformation of a sequence (which ostensibly exhibits
dependencies between subsequent elements), the attention
probabilities are computed independent of temporal order
and the attention distribution at the previous timestep.

We address these shortcomings by ﬁrst formulating a
stochastic process which explicitly processes the memory
in a left-to-right manner. Speciﬁcally, for output timestep
i we begin processing memory entries from index ti−1,
where ti is the index of the memory entry chosen at output
timestep i (for convenience, letting t0 = 1). We sequen-
tially compute, for j = ti−1, ti−1 + 1, ti−1 + 2, . . .

ei,j = a(si−1, hj)
pi,j = σ(ei,j)
zi,j ∼ Bernoulli(pi,j)

(6)

(7)

(8)

where a(·) is a learnable deterministic “energy function”
and σ(·) is the logistic sigmoid function. As soon as we
sample zi,j = 1 for some j, we stop and set ci = hj
and ti = j, “choosing” memory entry j for the context
vector. Each zi,j can be seen as representing a discrete
choice of whether to ingest a new item from the memory
(zi,j = 0) or produce an output (zi,j = 1). For all sub-

sequent output timesteps, we repeat this process, always
starting from ti−1 (the memory index chosen at the previ-
ous timestep). If for any output timestep i we have zi,j = 0
for j ∈ {ti−1, . . . , T }, we simply set ci to a vector of ze-
ros. This process is visualized in ﬁg. 2 and is presented
more explicitly in algorithm 1 (appendix A).

Note that by construction, in order to compute pi,j, we only
need to have computed hk for k ∈ {1, . . . , j}. It follows
that our novel process can be computed in an online man-
ner; i.e. we do not need to wait to observe the entire input
sequence before we start producing the output sequence.
Furthermore, because we start inspecting memory elements
from where we left off at the previous output timestep (i.e.
at index ti−1), the resulting process only computes at most
max(T, U ) terms pi,j, giving it a linear runtime. Of course,
it also makes the strong assumption that the alignment be-
tween the input and output sequence is strictly monotonic.

2.3. Training in Expectation

The online alignment process described above involves
sampling, which precludes the use of standard backpropa-
gation. In analogy with softmax-based attention, we there-
fore propose training with respect to the expected value of
ci, which can be computed straightforwardly as follows.
We ﬁrst compute ei,j and pi,j exactly as in eqs. (6) and (7),
where pi,j are interpreted as the probability of choosing
memory element j at output timestep i. The attention dis-
tribution over the memory is then given by (see appendix C

Online and Linear-Time Attention by Enforcing Monotonic Alignments

for a derivation)

αi,j = pi,j

αi−1,k

(1 − pi,l)

(9)

(cid:32)

j
(cid:88)

k=1
(cid:18)

(cid:33)

(cid:19)

j−1
(cid:89)

l=k
αi,j−1
pi,j−1

= pi,j

(1 − pi,j−1)

+ αi−1,j

(10)

We provide a solution to the recurrence relation of eq. (10)
which allows computing αi,j for j ∈ {1, . . . , T } in parallel
with cumulative sum and cumulative product operations in
appendix C.1. Deﬁning qi,j = αi,j/pi,j gives the following
procedure for computing αi,j:

ei,j = a(si−1, hj)
pi,j = σ(ei,j)
qi,j = (1 − pi,j−1)qi,j−1 + αi−1,j
αi,j = pi,jqi,j

(11)

(12)

(13)

(14)

where we deﬁne the special cases of qi,0 = 0, pi,0 = 0
to maintain equivalence with eq. (9). As in softmax-
based attention, the αi,j values produce a weighting over
the memory, which are then used to compute the con-
text vector at each timestep as in eq. (3). However, note
that αi may not be a valid probability distribution because
(cid:80)
j αi,j ≤ 1. Using αi as-is, without normalization, ef-
fectively associates any additional probability not allocated
to memory entries to an additional all-zero memory loca-
tion. Normalizing αi so that (cid:80)T
j=1 αi,j = 1 has two issues:
First, we can’t perform this normalization at test time and
still achieve online decoding because the normalization de-
pends on αi,j for j ∈ {1, . . . , T }, and second, it would re-
sult in a mismatch compared to the probability distribution
induced by the hard monotonic attention process which sets
ci to a vector of zeros when zi,j = 0 for j ∈ {ti−1, . . . , T }.

Note that computing ci still has a quadratic complexity be-
cause we must compute αi,j for j ∈ {1, . . . , T } for each
output timestep i. However, because we are training di-
rectly with respect to the expected value of ci, we will train
our decoders using eqs. (11) to (14) and then use the on-
line, linear-time attention process of section 2.2 at test time.
Furthermore, if pi,j ∈ {0, 1} these approaches are equiva-
lent, so in order for the model to exhibit similar behavior at
training and test time, we need pi,j ≈ 0 or pi,j ≈ 1. We
address this in section 2.5.

2.4. Modiﬁed Energy Function

While various “energy functions” a(·) have been proposed,
the most common to our knowledge is the one proposed in
(Bahdanau et al., 2015):

a(si−1, hj) = v(cid:62) tanh(W si−1 + V hj + b)

(15)

where W and V are weight matrices, b is a bias vector,1
and v is a weight vector. We make two modiﬁcations to
eq. (15) for use with our monotonic decoder: First, while
the softmax is invariant to offset,2 the logistic sigmoid is
not. As a result, we make the simple modiﬁcation of adding
a scalar variable r after the tanh function, allowing the
model to learn the appropriate offset for the pre-sigmoid
activations. Note that eq. (13) tends to exponentially de-
cay attention over the memory because 1 − pi,j ∈ [0, 1];
we therefore initialized r to a negative value prior to train-
ing so that 1 − pi,j tends to be close to 1. Second, the
use of the sigmoid nonlinearity in eq. (12) implies that our
mechanism is particularly sensitive to the scale of the en-
ergy terms ei,j, or correspondingly, the scale of the energy
vector v. We found an effective solution to this issue was
to apply weight normalization (Salimans & Kingma, 2016)
to v, replacing it by gv/(cid:107)v(cid:107) where g is a scalar parame-
ter. Initializing g to the inverse square root of the attention
hidden dimension worked well for all problems we studied.

The above produces the energy function

a(si−1, hj) = g

tanh(W si−1 + V hj + b) + r (16)

v(cid:62)
(cid:107)v(cid:107)

The addition of the two scalar parameters g and r prevented
the issues described above in all our experiments while in-
curring a negligible increase in the number of parameters.

2.5. Encouraging Discreteness

As mentioned above, in order for our mechanism to exhibit
similar behavior when training in expectation and when us-
ing the hard monotonic attention process at test time, we
require that pi,j ≈ 0 or pi,j ≈ 1. A straightforward way to
encourage this behavior is to add noise before the sigmoid
in eq. (12), as was done e.g. in (Frey, 1997; Salakhutdinov
& Hinton, 2009; Foerster et al., 2016). We found that sim-
ply adding zero-mean, unit-variance Gaussian noise to the
pre-sigmoid activations was sufﬁcient in all of our exper-
iments. This approach is similar to the recently proposed
Gumbel-Softmax trick (Jang et al., 2016; Maddison et al.,
2016), except we did not ﬁnd it necessary to anneal the
temperature as suggested in (Jang et al., 2016).

Note that once we have a model which produces pi,j which
are effectively discrete, we can eschew the sampling in-
volved in the process of section 2.2 and instead simply set
zi,j = I(pi,j > τ ) where I is the indicator function and τ
is a threshold. We used this approach in all of our exper-
iments, setting τ = 0.5. Furthermore, at test time we do
not add pre-sigmoid noise, making decoding purely deter-

1b is occasionally omitted, but we found it often improves per-
formance and only incurs a modest increase in parameters, so we
include it.

2That is, softmax(e) = softmax(e + r) for any r ∈ R.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

ministic. Combining all of the above, we present our dif-
ferentiable approach to training the monotonic alignment
decoder in algorithm 2 (appendix A).

3. Related Work

(Luo et al., 2016) and (Zaremba & Sutskever, 2015) both
study a similar framework in which a decoder RNN can
decide whether to ingest another entry from the input se-
quence or emit an entry of the output sequence. Instead of
training in expectation, they maintain the discrete nature of
this decision while training and use reinforcement learning
(RL) techniques. We initially experimented with RL-based
training methods but were unable to ﬁnd an approach which
worked reliably on the different tasks we studied. Empir-
ically, we also show superior performance to (Luo et al.,
2016) on online speech recognition tasks; we did not at-
tempt any of the tasks from (Zaremba & Sutskever, 2015).
(Aharoni & Goldberg, 2016) also study hard monotonic
alignments, but their approach requires target alignments
computed via a separate statistical alignment algorithm in
order to be trained.

As an alternative approach to monotonic alignments, Con-
nectionist Temporal Classiﬁcation (CTC) (Graves et al.,
2006) and the RNN Transducer (Graves, 2012) both as-
sume that the output sequences consist of symbols, and add
an additional “null” symbol which corresponds to “produce
no output”. More closely to our model, (Yu et al., 2016b)
similarly add “shift” and “emit” operations to an RNN. Fi-
nally, the Segmental RNN (Kong et al., 2015) treats a seg-
mentation of the input sequence as a latent random variable.
In all cases, the alignment path is marginalized out via a
dynamic program in order to obtain a conditional probabil-
ity distribution over label sequences and train directly with
maximum likelihood. These models either require condi-
tional independence assumptions between output symbols
or don’t condition the decoder (language model) RNN on
the input sequence. We instead follow the framework of
attention and marginalize out alignment paths when com-
puting the context vectors ci which are subsequently fed
into the decoder RNN, which allows the decoder to condi-
tion on its past output as well as the input sequence. Our
approach can therefore be seen as a marriage of these CTC-
style techniques and attention. Separately, instead of per-
forming an approximate search for the most probable out-
put sequence at test time, we use hard alignments which
facilitates linear-time decoding.

A related idea is proposed in (Raffel & Lawson, 2017),
where “subsampling” probabilities are assigned to each en-
try in the memory and a stochastic process is formulated
which involves keeping or discarding entries from the input
sequence according to the subsampling probabilities. A dy-
namic program similar to the one derived in section 2.3 is

then used to compute the expected output which allows for
training with standard backpropagation. Our approach dif-
fers in that we utilize an RNN decoder to construct the out-
put sequence, and furthermore allows for output sequences
which are longer than the input.

Some similar ideas to those in section 2.3 were proposed
in the context of speech recognition in (Chorowski et al.,
2015): First, the prior attention distributions are convolved
with a bank of one-dimensional ﬁlters and then included in
the energy function calculation. Second, instead of com-
puting attention over the entire memory they only compute
it over a sliding window. This reduces the runtime com-
plexity at the expense of the strong assumption that mem-
ory locations attended to at subsequent output timesteps fall
within a small window of one another. Finally, they also
advocate replacing the softmax function with a sigmoid,
but they then normalize by the sum of these sigmoid acti-
vations across the memory window instead of interpreting
these probabilities in the left-to-right framework we use.
While these modiﬁcations encourage monotonic attention,
they do not explicitly enforce it, and so the authors do not
investigate online decoding.

In a similar vein, (Luong et al., 2015) explore only comput-
ing attention over a small window of the memory. In addi-
tion to simply monotonically increasing the window loca-
tion at each output timestep, they also consider learning
a policy for producing the center of the memory window
based on the current decoder state.

(Kim et al., 2017) also make the connection between soft
attention and selecting items from memory in expectation.
They consider replacing the softmax in standard soft atten-
tion with an elementwise sigmoid nonlinearity, but do not
formulate the interpretation of addressing memory from
left-to-right and the corresponding probability distributions
as we do in section 2.3.

(Jaitly et al., 2015) apply standard softmax attention in on-
line settings by splitting the input sequence into chunks and
producing output tokens using the attentive sequence-to-
sequence framework over each chunk. They then devise a
dynamic program for ﬁnding the approximate best align-
ment between the model output and the target sequence.
In contrast, our ingest/emit probabilities pi,j can be seen as
adaptively chunking the input sequence (rather than provid-
ing a ﬁxed setting of the chunk size) and we instead train by
exactly computing the expectation over alignment paths.

4. Experiments

To validate our proposed approach for learning mono-
tonic alignments, we applied it to a variety of sequence-
to-sequence problems: sentence summarization, machine
translation, and online speech recognition. In the follow-

Online and Linear-Time Attention by Enforcing Monotonic Alignments

ing subsections, we give an overview of the models used
and the results we obtained; for more details about hy-
perparamers and training speciﬁcs please see appendix D.
Incidentally, all experiments involved predicting discrete
symbols (e.g. phonemes, characters, or words); as a result,
the output of the decoder in each of our models was fed
into an afﬁne transformation followed by a softmax non-
linearity with a dimensionality corresponding to the num-
ber of possible symbols. At test time, we performed a
beam search over softmax predictions on all problems ex-
cept machine translation. All networks were trained using
standard cross-entropy loss with teacher forcing against tar-
get sequences using the Adam optimizer (Kingma & Ba,
2014). All of our decoders used the monotonic attention
mechanism of section 2.3 during training to address the
hidden states of the encoder. For comparison, we report
test-time results using both the hard linear-time decoding
method of section 2.2 and the “soft” monotonic attention
distribution. We also present the results of a synthetic
benchmark we used to measure the potential speedup of-
fered by our linear-time decoding process in appendix F.

Online Speech Recognition Online speech recognition
involves transcribing the words spoken in a speech utter-
ance in real-time, i.e. as a person is talking. This problem
is a natural application for monotonic alignments because
online decoding is an explicit requirement. In addition, this
precludes the use of bidirectional RNNs, which degrades
performance somewhat (Graves et al., 2013). We tested our
approach on two datasets: TIMIT (Garofolo et al., 1993)
and the Wall Street Journal corpus (Paul & Baker, 1992).

Speech recognition on the TIMIT dataset involves tran-
scribing the phoneme sequence underlying a given speech
utterance.
Speech utterances were represented as se-
quences of 40-ﬁlter (plus energy) mel-ﬁlterbank spectra,
computed every 10 milliseconds, with delta- and delta-
delta-features. Our encoder RNN consisted of three uni-
directional LSTM layers. Following (Chan et al., 2016),
after the ﬁrst and second LSTM layer we placed time re-
duction layers which skip every other sequence element.
Our decoder RNN was a single unidirectional LSTM. Our
output softmax had 62 dimensions, corresponding to the
60 phonemes from TIMIT plus special start-of-sequence
and end-of-sequence tokens. At test time, we utilized a
beam search over softmax predictions, with a beam width
of 10. We report the phone error rate (PER) after apply-
ing the standard mapping to 39 phonemes (Graves et al.,
2013). We used the standard train/validation/test split and
report results on the test set.

Our model’s performance, with a comparison to other on-
line approaches, is shown in table 1. We achieve better
performance than recently proposed sequence-to-sequence
models (Luo et al., 2016; Jaitly et al., 2015), though the

Table 1. Phone error rate on the TIMIT dataset for different online
methods.

Method

(Luo et al., 2016) (stacked LSTM)
(Jaitly et al., 2015) (end-to-end)
(Luo et al., 2016) (grid LSTM)
Hard Monotonic Attention (ours)
Soft Monotonic Attention (ours, ofﬂine)
(Graves et al., 2013) (CTC)

PER

21.5%
20.8%
20.5%
20.4%
20.1%
19.6%

small size of the TIMIT dataset and the resulting variabil-
ity of results precludes making substantiative claims about
one approach being best. We note that (Jaitly et al., 2015)
were able to improve performance by precomputing align-
ments using an HMM system and providing them as a su-
pervised signal to their decoder; we did not experiment
with this idea. CTC (Graves et al., 2013) still outperforms
all sequence-to-sequence models.
In addition, there re-
mains a substantial gap between these online results and
ofﬂine results using bidirectional LSTMs, e.g. (Chorowski
et al., 2015) achieves a 17.6% phone error rate using a
softmax-based attention mechanism and (Graves et al.,
2013) achieved 17.7% using a pre-trained RNN transducer
model. We are interested in investigating ways to close this
gap in future work.

Because of the size of the dataset, performance on TIMIT is
often highly dependent on appropriate regularization. We
therefore also evaluated our approach on the Wall Street
Journal (WSJ) speech recognition dataset, which is about
10 times larger. For the WSJ corpus, we present speech
utterances to the network as 80-ﬁlter mel-ﬁlterbank spec-
tra with delta- and delta-delta features, and normalized us-
ing per-speaker mean and variance computed ofﬂine. The
model architecture is a variation of that from (Zhang et al.,
2016), using an 8 layer encoder including:
two convo-
lutional layers which downsample the sequence in time,
followed by one unidirectional convolutional LSTM layer,
and ﬁnally a stack of three unidirectional LSTM layers in-
terleaved with linear projection layers and batch normal-
ization. The encoder output sequence is consumed by the
proposed online attention mechanism which is passed into
a decoder consisting of a single unidirectional LSTM layer
followed by a softmax layer.

Our output softmax predicted one of 49 symbols, consist-
ing of alphanumeric characters, punctuation marks, and
start-of sequence, end-of-sequence, “unknown”, “noise”,
and word delimiter tokens. We utilized label smoothing
during training (Chorowski & Jaitly, 2017), replacing the
targets at time yt with a convex weighted combination of
the surrounding ﬁve labels (full details in appendix D.1.2).
Performance was measured in terms of word error rate
(WER) on the test set after segmenting the model’s predic-

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Table 2. Word error rate on the WSJ dataset. All approaches used
a unidirectional encoder; results in grey indicate ofﬂine models.

Method

CTC (our model)
(Luo et al., 2016) (hard attention)
(Wang et al., 2016) (CTC)
Hard Monotonic Attention (our model)
Soft Monotonic Attention (our model)
Softmax Attention (our model)

WER

33.4%
27.0%
22.7%
17.4%
16.5%
16.0%

tions according to the word delimiter tokens. We used the
standard dataset split of si284 for training, dev93 for vali-
dation, and eval92 for testing. We did not use a language
model to improve decoding performance.

Our results on WSJ are shown in table 2. Our model, with
hard monotonic decoding, achieved a signiﬁcantly lower
WER than the other online methods. While these ﬁgures
show a clear advantage to our approach, our model ar-
chitecture differed signiﬁcantly from those of (Luo et al.,
2016; Wang et al., 2016). We therefore additionally mea-
sured performance against a baseline model which was
identical to our model except that it used softmax-based
attention (which makes it quadratic-time and ofﬂine) in-
stead of a monotonic alignment decoder. This resulted in
a small decrease of 1.4% WER, suggesting that our hard
monotonic attention approach achieves competitive perfor-
mance while being substantially more efﬁcient. To get a
qualitative picture of our model’s behavior compared to the
softmax-attention baseline, we plot each model’s input-
output alignments for two example speech utterances in
ﬁg. 4 (appendix B). Both models learn roughly the same
alignment, with some minor differences caused by ours be-
ing both hard and strictly monotonic.

Sentence Summarization Speech recognition exhibits
a strictly monotonic input-output alignment. We are in-
terested in testing whether our approach is also effective
on problems which only exhibit approximately monotonic
alignments. We therefore ran a “sentence summarization”
experiment using the Gigaword corpus, which involves pre-
dicting the headline of a news article from its ﬁrst sentence.

Overall, we used the model of (Liu & Pan, 2016), modi-
fying it only so that it used our monotonic alignment de-
coder instead of a soft attention decoder. Because online
decoding is not important for sentence summarization, we
utilized bidirectional RNNs in the encoder for this task
(as is standard). We expect that the bidirectional RNNs
will give the model local context which may help allow
for strictly monotonic alignments. The model both took
as input and produced as output one-hot representations of
the word IDs, with a vocabulary of the 200,000 most com-
mon words in the training set. Our encoder consisted of

Table 3. ROUGE F-measure scores for sentence summarization
on the Gigaword test set of (Rush et al., 2015).
(Rush et al.,
2015) reports ROUGE recall scores, so we report the F-1 scores
computed for that approach from (Chopra et al., 2016). As is
standard, we report unigram, bigram, and longest common subse-
quence metrics as R-1, R-2, and R-L respectively.

Method

R-1

R-2

R-L

(Zeng et al., 2016)
(Rush et al., 2015)
(Yu et al., 2016b)
(Chopra et al., 2016)
(Miao & Blunsom, 2016)
(Nallapati et al., 2016)
(Yu et al., 2016a)
(Suzuki & Nagata, 2017)
Hard Monotonic (ours)
Soft Monotonic (ours)
(Liu & Pan, 2016)

27.82
29.76
30.27
33.78
34.17
34.19
34.41
36.30
37.14
38.03
38.22

12.74
11.88
13.68
15.97
15.94
16.29
16.86
17.31
18.00
18.57
18.70

26.01
26.96
27.91
31.15
31.92
32.13
31.83
33.88
34.87
35.70
35.74

Figure 3. Example sentence-summary pair with attention align-
ments for our hard monotonic model and the softmax-based at-
tention model of (Liu & Pan, 2016). Attention matrices are dis-
played so that black corresponds to 1 and white corresponds to
0. The ground-truth summary is “greece pumps more money and
personnel into bird ﬂu defense”.

a word embedding matrix (which was initialized randomly
and trained as part of the model) followed by four bidirec-
tional LSTM layers. We used a single LSTM layer for the
decoder. For data preparation and evaluation, we followed
the approach of (Rush et al., 2015), measuring performance
using the ROUGE metric.

Our results, along with the scores achieved by other ap-
proaches, are presented in table 3. While the monotonic
alignment model outperformed existing models by a sub-
stantial margin, it fell slightly behind the model of (Liu
& Pan, 2016) which we used as a baseline. The higher
performance of our model and the model of (Liu & Pan,
2016) can be partially explained by the fact that their en-
coders have roughly twice as many layers as most models
proposed in the literature.

For qualitative evaluation, we plot an example input-output

Online and Linear-Time Attention by Enforcing Monotonic Alignments

pair and alignment matrices for our hard monotonic atten-
tion model and the softmax-attention baseline of (Liu &
Pan, 2016) in ﬁg. 3 (an additional example is shown in
ﬁg. 6, appendix B). Most apparent is that a given word
in the summary is not always aligned to the most obvi-
ous word in the input sentence; the hard monotonic de-
coder aligns the ﬁrst four words in the summary reason-
ably (greek ↔ greek, government ↔ ﬁnance, approves ↔
approved, more ↔ more), but the latter four words have
unexpected alignments (funds ↔ in, to ↔ for, bird ↔ mea-
sures, bird ↔ ﬂu). We believe this is due to the ability of
the multilayer bidirectional RNN encoder to reorder words
in the input sequence. This effect is also apparent in ﬁg. 6/
(appendix B), where the monotonic alignment decoder is
able to produce the phrase “human rights criticism” despite
the fact that the input sentence has the phrase “criticism
of human rights”. Separately, we note that the softmax
attention model’s alignments are extremely “soft” and non-
monotonic; this may be advantageous for this problem and
partially explain its slightly superior performance.

Machine Translation We also evaluated our approach
on machine translation, another task which does not exhibit
strictly monotonic alignments. In fact, for some language
pairs (e.g. English and Japanese, English and Korean), we
do not expect monotonicity at all. However, for other pairs
(e.g. English and French, English and Vietnamese) only
local word reorderings are required. Our translation ex-
periments therefore involved English to Vietnamese trans-
lation using the parallel corpus of TED talks (133K sen-
tence pairs) provided by the IWSLT 2015 Evaluation Cam-
paign (Cettolo et al., 2015). Following (Luong & Manning,
2015), we tokenize the corpus with the default Moses tok-
enizer, preserve casing, and replace words whose frequen-
cies are less than 5 by <unk>. As a result, our vocab-
ulary sizes are 17K and 7.7K for English and Vietnamese
respectively. We use the TED tst2012 (1553 sentences) as a
validation set for hyperparameter tuning and TED tst2013
(1268 sentences) as a test set. We report results in both
perplexity and BLEU.

Our baseline neural machine translation (NMT) system is
the softmax attention-based sequence-to-sequence model
described in (Luong et al., 2015). From that baseline, we
substitute the softmax-based attention mechanism with our
proposed monotonic alignment decoder. The model uti-
lizes two-layer unidirectional LSTM networks for both the
encoder and decoder.

In (Luong et al., 2015), the authors demonstrated that un-
der their proposed architecture, a dot product-based energy
function worked better than eq. (15). Since our architec-
ture is based on that of (Luong et al., 2015), to facilitate
comparison we also tested the following variant:

Table 4. Performance on the IWSLT 2015 English-Vietnamese
TED talks for our monotonic alignment model and the baseline
softmax-attention model of (Luong & Manning, 2015).

Method

(Luong & Manning, 2015)
Hard Monotonic, energy function eq. (16)
Hard Monotonic, energy function eq. (17)

BLEU

23.3
22.6
23.0

where g and r are scalars (initialized as in section 2.4) and
W is a weight matrix.

Our results are shown in Table 4. To get a better pic-
ture of each model’s behavior, we plot input-output align-
ments in ﬁg. 5 (appendix B). Most noticeable is that the
monotonic alignment model tends to focus attention later
in the input sequence than the baseline softmax-attention
model. We hypothesize that this is a way to compensate
for non-monotonic alignments when a unidirectional en-
coder is used; i.e. the model has effectively learned to fo-
cus on words at the end of phrases which require reorder-
ing, at which point the unidirectional encoder has observed
the whole phrase. This can be seen most clearly in the
example on the right, where translating “a huge famine”
to Vietnamese requires reordering (as suggested by the
softmax-attention model’s alignment), so the hard mono-
tonic alignment model focuses attention on the ﬁnal word
in the phrase (“famine”) while producing its translation.
We suspect our model’s small decrease in BLEU compared
to the baseline model may be due in part to this increased
modeling burden.

5. Discussion

Our results show that our differentiable approach to enforc-
ing monotonic alignments can produce models which, fol-
lowing the decoding process of section 2.2, provide efﬁ-
cient online decoding at test time without sacriﬁcing sub-
stantial performance on a wide variety of tasks. We believe
our framework presents a promising environment for fu-
ture work on online and linear-time sequence-to-sequence
models. We are interested in investigating various exten-
sions to this approach, which we outline in appendix E.
To facilitate experimentation with our proposed attention
mechanism, we have made an example TensorFlow (Abadi
et al., 2016) implementation of our approach available on-
line3 and added a reference implementation to Tensor-
Flow’s tf.contrib.seq2seq module. We also pro-
vide a “practitioner’s guide” in appendix G.

a(si−1, hj) = g(s(cid:62)

i−1W h) + r

(17)

3https://github.com/craffel/mad

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Acknowledgements

We thank Jan Chorowski, Mark Daoust, Pietro Kreit-
lon Carolino, Dieterich Lawson, Navdeep Jaitly, George
Tucker, Quoc V. Le, Kelvin Xu, Cinjon Resnick, Melody
Guan, Matthew D. Hoffman, Jeffrey Dean, Kevin Swersky,
Ashish Vaswani, and members of the Google Brain team
for helpful discussions and insight.

References

Abadi, Martin, Barham, Paul, Chen, Jianmin, Chen,
Zhifeng, Davis, Andy, Dean, Jeffrey, Devin, Matthieu,
Ghemawat, Sanjay, Irving, Geoffrey, Isard, Michael,
Kudlur, Manjunath, Levenberg, Josh, Monga, Rajat,
Moore, Sherry, Murray, Derek G., Steiner, Benoit,
Tucker, Paul, Vasudevan, Vijay, Warden, Pete, Wicke,
Martin, Yu, Yuan, and Zheng, Xiaoqiang. TensorFlow:
A system for large-scale machine learning. In Operating
Systems Design and Implementation, 2016.

Aharoni, Roee and Goldberg, Yoav. Sequence to sequence
arXiv

transduction with hard monotonic attention.
preprint arXiv:1611.01487, 2016.

Bahdanau, Dzmitry, Cho, Kyunghyun, and Bengio,
Yoshua. Neural machine translation by jointly learning
In International Conference on
to align and translate.
Learning Representations, 2015.

Cettolo, Mauro, Niehues, Jan, Stüker, Sebastian, Ben-
tivogli, Luisa, Cattoni, Roldano, and Federico, Marcello.
The IWSLT 2015 evaluation campaign. In International
Workshop on Spoken Language Translation, 2015.

Chan, William, Jaitly, Navdeep, Le, Quoc V., and Vinyals,
Oriol. Listen, attend and spell: A neural network for
large vocabulary conversational speech recognition. In
International Conference on Acoustics, Speech and Sig-
nal Processing, 2016.

Cho, Kyunghyun, van Merriënboer, Bart, Gülçehre, Ça˘glar,
Bahdanau, Dzmitry, Bougares, Fethi, Schwenk, Holger,
and Bengio, Yoshua. Learning phrase representations us-
ing RNN encoder–decoder for statistical machine trans-
lation. In Conference on Empirical Methods in Natural
Language Processing, 2014.

Chopra, Sumit, Auli, Michael, and Rush, Alexander M.
Abstractive sentence summarization with attentive recur-
rent neural networks. Conference of the North American
Chapter of the Association for Computational Linguis-
tics: Human Language Technologies, 2016.

Chorowski, Jan, Bahdanau, Dzmitry, Serdyuk, Dmitriy,
Cho, Kyunghyun, and Bengio, Yoshua. Attention-based
models for speech recognition. In Conference on Neural
Information Processing Systems, 2015.

Chung, Junyoung, Gulcehre, Caglar, Cho, Kyunghyun, and
Bengio, Yoshua. Empirical evaluation of gated recurrent
neural networks on sequence modeling. arXiv preprint
arXiv:1412.3555, 2014.

Foerster, Jakob, Assael, Yannis M., de Freitas, Nando, and
Whiteson, Shimon. Learning to communicate with deep
multi-agent reinforcement learning. In Advances in Neu-
ral Information Processing Systems, 2016.

Frey, Brendan J. Continuous sigmoidal belief networks
trained using slice sampling. Advances in neural infor-
mation processing systems, 1997.

Garofolo, John S., Lamel, Lori F., Fisher, William M., Fis-
cus, Jonathon G., and Pallett, David S. DARPA TIMIT
acoustic-phonetic continous speech corpus. 1993.

Graves, Alex. Sequence transduction with recurrent neural

networks. arXiv preprint arXiv:1211.3711, 2012.

Graves, Alex. Generating sequences with recurrent neural

networks. arXiv preprint arXiv:1308.0850, 2013.

Graves, Alex, Fernández, Santiago, Gomez, Faustino, and
Schmidhuber, Jürgen. Connectionist temporal classiﬁ-
cation: labelling unsegmented sequence data with recur-
rent neural networks. In International conference on Ma-
chine learning, 2006.

Graves, Alex, Mohamed, Abdel-rahman, and Hinton, Ge-
offrey. Speech recognition with deep recurrent neural
In International Conference on Acoustics,
networks.
Speech and Signal Processing, 2013.

Graves, Alex, Wayne, Greg, and Danihelka, Ivo. Neural
turing machines. arXiv preprint arXiv:1410.5401, 2014.

Hochreiter, Sepp and Schmidhuber, Jürgen. Long short-

term memory. Neural computation, 9(8), 1997.

Jaitly, Navdeep, Sussillo, David, Le, Quoc V., Vinyals,
Oriol, Sutskever, Ilya, and Bengio, Samy. A neural trans-
ducer. arXiv preprint arXiv:1511.04868, 2015.

Jang, Eric, Gu, Shixiang, and Poole, Ben. Categorical
reparameterization with gumbel-softmax. arXiv preprint
arXiv:1611.01144, 2016.

Chorowski, Jan and Jaitly, Navdeep. Towards better decod-
ing and language model integration in sequence to se-
quence models. arXiv preprint arXiv:1612.02695, 2017.

Kim, Yoon, Denton, Carl, Hoang, Luong, and Rush,
arXiv

Alexander M. Structured attention networks.
preprint arXiv:1702.00887, 2017.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Kingma, Diederik and Ba,

Jimmy.
method for stochastic optimization.
arXiv:1412.6980, 2014.

Adam:

A
arXiv preprint

Kong, Lingpeng, Dyer, Chris, and Smith, Noah A. Seg-
arXiv preprint

mental recurrent neural networks.
arXiv:1511.06018, 2015.

Liu, Peter J. and Pan, Xin. Text summarization with Ten-

sorFlow. http://goo.gl/16RNEu, 2016.

Luo, Yuping, Chiu, Chung-Cheng, Jaitly, Navdeep, and
Learning online alignments with
arXiv preprint

Sutskever,
continuous rewards policy gradient.
arXiv:1608.01281, 2016.

Ilya.

Luong, Minh-Thang and Manning, Christopher D. Stan-
ford neural machine translation systems for spoken lan-
In International Workshop on Spoken
guage domain.
Language Translation, 2015.

Luong, Minh-Thang, Pham, Hieu, and Manning, Christo-
pher D. Effective approaches to attention-based neural
machine translation. In Conference on Empirical Meth-
ods in Natural Language Processing, 2015.

concrete distribution:

Maddison, Chris J., Mnih, Andriy, and Teh, Yee Whye.
relax-
arXiv preprint

The
ation of discrete random variables.
arXiv:1611.00712, 2016.

A continuous

Miao, Yishu and Blunsom, Phil. Language as a latent vari-
able: Discrete generative models for sentence compres-
sion. arXiv preprint arXiv:1609.07317, 2016.

Nallapati, Ramesh,

Zhou, Bowen,

dos Santos,
and Xiang,
Cícero Nogueira, Gülçehre, Çaglar,
Bing. Abstractive text summarization using sequence-
In Conference on
to-sequence RNNs and beyond.
Computational Natural Language Learning, 2016.

Paul, Douglas B. and Baker, Janet M. The design for the
Wall Street Journal-based CSR corpus. In Workshop on
Speech and Natural Language, 1992.

Salimans, Tim and Kingma, Diederik P. Weight normaliza-
tion: A simple reparameterization to accelerate training
of deep neural networks. In Advances in Neural Infor-
mation Processing Systems, 2016.

Sukhbaatar, Sainbayar, Szlam, Arthur, Weston, Jason, and
Fergus, Rob. End-to-end memory networks. In Advances
in neural information processing systems, 2015.

Sutskever, Ilya, Vinyals, Oriol, and Le, Quoc V. Sequence
to sequence learning with neural networks. In Advances
in neural information processing systems, 2014.

Suzuki, Jun and Nagata, Masaaki. Cutting-off redundant
repeating generations for neural abstractive summariza-
tion. arXiv preprint arXiv:1701.00138, 2017.

Wang, Chong, Yogatama, Dani, Coates, Adam, Han, Tony,
Hannun, Awni, and Xiao, Bo. Lookahead convolution
In
layer for unidirectional recurrent neural networks.
Workshop Extended Abstracts of the 4th International
Conference on Learning Representations, 2016.

Xu, Kelvin, Ba, Jimmy, Kiros, Ryan, Cho, Kyunghyun,
Courville, Aaron, Salakhudinov, Ruslan, Zemel, Rich,
and Bengio, Yoshua. Show, attend and tell: Neural im-
age caption generation with visual attention. In Interna-
tional Conference on Machine Learning, 2015.

Yu, Lei, Blunsom, Phil, Dyer, Chris, Grefenstette, Edward,
and Kocisky, Tomas. The neural noisy channel. arXiv
preprint arXiv:1611.02554, 2016a.

Yu, Lei, Buys, Jan, and Blunsom, Phil. Online segment to
segment neural transduction. In Conference on Empiri-
cal Methods in Natural Language Processing, 2016b.

Zaremba, Wojciech and Sutskever,

Reinforce-
ment learning neural turing machines. arXiv preprint
arXiv:1505.00521, 362, 2015.

Ilya.

Zeng, Wenyuan, Luo, Wenjie, Fidler, Sanja, and Urta-
sun, Raquel. Efﬁcient summarization with read-again
and copy mechanism. arXiv preprint arXiv:1611.03382,
2016.

Raffel, Colin and Lawson, Dieterich. Training a sub-
arXiv preprint

sampling mechanism in expectation.
arXiv:1702.06914, 2017.

Zhang, Yu, Chan, William, and Jaitly, Navdeep. Very deep
convolutional networks for end-to-end speech recogni-
tion. arXiv preprint arXiv:1610.03022, 2016.

Rush, Alexander M., Chopra, Sumit, and Weston, Jason. A
neural attention model for abstractive sentence summa-
rization. In Conference on Empirical Methods in Natural
Language Processing, 2015.

Salakhutdinov, Ruslan and Hinton, Geoffrey. Semantic
hashing. International Journal of Approximate Reason-
ing, 50(7), 2009.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

A. Algorithms

Below are algorithms for the hard monotonic decoding process we used at test time (algorithm 1) and the approach for
computing its expected output that we used to train the network (algorithm 2). Terminology matches the main text, except
we use (cid:126)0 to signify a vector of zeros.

Algorithm 1 Hard Monotonic Attention Process

Input: memory h of length T
State: s0 = (cid:126)0, t0 = 1, i = 1, y0 = StartOfSequence
while yi−1 (cid:54)= EndOfSequence do

// Produce output tokens until end-of-sequence token is produced

// Keep track of whether we chose a memory entry or not

ﬁnished = 0
for j = ti−1 to T do
ei,j = a(si−1, hj)
pi,j = σ(ei,j)
zi,j ∼ Bernoulli(pi,j)
if zi,j = 1 then // If we sample 1, we stop scanning the memory
// Set the context vector to the chosen memory entry

// Start inspecting memory entries hj left-to-right from where we left off
// Compute attention energy for hj
// Compute probability of choosing hj

// Sample whether to ingest another memory entry or output new symbol

ci = hj
ti = j
ﬁnished = 1
break // Stop scanning the memory

// Remember where we left off for the next output timestep

// Keep track of the fact that we chose a memory entry

end if
end for
if ﬁnished = 0 then

ci = (cid:126)0

end if
si = f (si−1, yi−1, ci)
yi = g(si, ci)
i = i + 1

end while

// If we scanned the entire memory without selecting anything, set ci to a vector of zeros

// Update the state based on the new context vector using the RNN f

// Output a new symbol using the softmax layer g

Algorithm 2 Soft Monotonic Attention Decoder

Input: memory h of length T , target outputs ˆy = {StartOfSequence, ˆy1, ˆy2, . . . , EndOfSequence}
State: s0 = (cid:126)0, i = 1, α0,j = δj for j ∈ {1, . . . , T }
while ˆyi−1 (cid:54)= EndOfSequence do

// Produce output tokens until end of the target sequence

pi,0 = 0, qi,0 = 0
for j = 1 to T do

// Special cases so that the recurrence relation matches eq. (9)
// Inspect all memory entries hj

ei,j = a(si−1, hj)
ei,j = ei,j + N (0, 1)
pi,j = σ(ei,j)
qi,j = (1 − pi,j−1)qi,j−1 + αi−1,j
αi,j = pi,jqi,j

// Compute attention energy for hj using eq. (16)

// Add pre-sigmoid noise to encourage pi,j ≈ 0 or pi,j ≈ 1

// Compute probability of choosing hj

// Iterate recurrence relation derived in eq. (10)

// Compute the probability that ci = hj

// Compute weighted combination of memory for context vector

// Update the state based on the new context vector using the RNN f

// Compute predicted output for timestep i using the softmax layer g

j=1 αi,jhj

end for
ci = (cid:80)T
si = f (si−1, yi−1, ci)
yi = g(si, ci)
i = i + 1

end while

Online and Linear-Time Attention by Enforcing Monotonic Alignments

B. Figures

Below are example hard monotonic and softmax attention alignments for each of the different tasks we included in our
experiments. Attention matrices are displayed so that black corresponds to 1 and white corresponds to 0.

Figure 4. Attention alignments from hard monotonic attention and softmax-based attention models for a two example speech utterances.
From top to bottom, we show the hard monotonic alignment, the softmax-attention alignment, and the utterance feature sequence.
Differences in the alignments are highlighted with dashed red circles. Gaps in the alignment paths correspond to effectively ignoring
silences and pauses in the speech utterances.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Figure 5. English sentences, predicted Vietnamese sentences, and input-output alignments for our proposed hard monotonic alignment
model and the baseline model of (Luong & Manning, 2015). The Vietnamese model outputs for the left example can be translated back
to English as “And I on this stage because I am a model.” (monotonic) and “And I am on this stage because I am a structure.” (softmax).
The input word “model” can mean either a person or a thing; the monotonic alignment model correctly chose the former while the
softmax alignment model chose the latter. The monotonic alignment model erroneously skipped the ﬁrst verb in the sentence. For the
right example, translations of the model outputs back to English are “A large famine in North Korea.” (monotonic) and “An invasion
of a huge famine in <unk>.” (softmax). The monotonic alignment model managed to translate the proper noun North Korea, while
the softmax alignment model produced <unk>. Both models skipped the phrase “mid-1990s”; this type of error is common in neural
machine translation systems.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Figure 6. Additional example sentence-summary pair and attention alignment matrices for our hard monotonic model and the softmax-
based attention model of (Liu & Pan, 2016). The ground-truth summary is “china attacks us human rights”.

C. Monotonic Attention Distribution

Recall that our goal is to compute the expected value of ci under the stochastic process deﬁned by eqs. (6) to (8). To achieve
this, we will derive an expression for the probability that ci = hj for j ∈ {1, . . . , T }, which in accordance with eq. (2) we
denote αi,j. For i = 1, α1,j is the probability that memory element j was chosen (p1,j) multiplied by the probability that
memory elements k ∈ {1, 2, . . . , j − 1} were not chosen ((1 − pi,k)), giving

α1,j = p1,j

(1 − p1,k)

j−1
(cid:89)

k=1

αi,j = pi,j

αi−1,k

(1 − pi,l)

(cid:32)

j
(cid:88)

k=1

j−1
(cid:89)

l=k

(cid:33)

For i > 0, in order for ci = hj we must have that ci−1 = hk for some k ∈ {1, . . . , j} (which occurs with probability
αi−1,k) and that none of hk, . . . , hj−1 were chosen. Summing over possible values of k, we have

where for convenience we deﬁne (cid:81)m
n x = 1 when n > m. We provide a schematic and explanation of eq. (19) in ﬁg. 7.
Note that we can recover eq. (18) from eq. (19) by deﬁning the special case α0,j = δj (i.e. α0,1 = 1 and α0,j = 0 for
j ∈ {2, . . . , T }). Expanding eq. (19) reveals we can compute αi,j directly given αi−1,j and αi,j−1:

αi,j = pi,j

αi−1,k

(1−pi,l)

+αi−1,j

(cid:33)

(cid:33)

(cid:32) j−1
(cid:88)

(cid:32)

k=1

(cid:32)

(cid:18)

j−1
(cid:89)

l=k

j−1
(cid:88)

(cid:32)

k=1
αi,j−1
pi,j−1

j−2
(cid:89)

l=k

(cid:19)

= pi,j

(1 − pi,j−1)

+ αi−1,j

= pi,j

(1 − pi,j−1)

αi−1,k

(1 − pi,l)

+ αi−1,j

(cid:33)

(cid:33)

(18)

(19)

(20)

(21)

(22)

Deﬁning qi,j = αi,j/pi,j produces eqs. (13) and (14). Equation (22) also has an intuitive interpretation: The expression
(1 − pi,j−1)αi,j−1/pi,j−1 represents the probability that the model attended to memory item j − 1 at output timestep i,
adjusted for the fact that memory item j − 1 was not chosen by multiplying (1 − pi,j−1) and dividing pi,j−1. Adding
αi−1,j reﬂects the additional possibility that the model attended to memory item j at the previous output timestep, and
multiplying by pi,j enforces that memory item j was chosen at the current output timestep i.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

Figure 7. Visualization of eq. (19). In this example, we are showing the computation of α3,4. Each grid shows each of the four terms
in the summation, corresponding to the possibilities that we attended to memory item k = 1, 2, 3, 4 at the previous output timestep
i − 1 = 2. Gray nodes with curved arrows represent the probability of not selecting to the lth memory entry (1 − pi,l). The black nodes
represent the possibility of attending to memory item j at timestep i.

C.1. Recurrence Relation Solution

While eqs. (10) and (22) allow us to compute αi,j directly from αi−1,j and αi,j−1, the dependence on αi,j−1 means that
we must compute the terms αi,1, αi,2, . . . , αi,T sequentially. This is in contrast to softmax attention, where these terms
can be computed in parallel because they are independent. Fortunately, there is a solution to the recurrence relation of
eq. (10) which allows the terms of αi to be computed directly via parallelizable cumulative sum and cumulative product
operations. Using eq. (13) which substitutes qi,j = αi,j/pi,j, we have

qi,j = (1 − pi,j−1)qi,j−1 + αi−1,j

qi,j − (1 − pi,j−1)qi,j−1 = αi−1,j

qi,j
k=1(1 − pi,k−1)
qi,j
k=1(1 − pi,k−1)

(cid:81)j

(cid:81)j

−

−

(cid:32)

j
(cid:88)

l=1

qi,l
k=1(1 − pi,k−1)

(cid:81)l

−

(cid:81)l−1

(1 − pi,j−1)qi,j−1
(cid:81)j
k=1(1 − pi,k−1)
qi,j−1
k=1(1 − pi,k−1)
(cid:33)

(cid:81)j−1

qi,l−1
k=1(1 − pi,k−1)

=

=

=

qi,j
k=1(1 − pi,k−1)

(cid:81)j

− qi,0 =

αi−1,j
k=1(1 − pi,k−1)
αi−1,j
k=1(1 − pi,k−1)

αi−1,l
k=1(1 − pi,k−1)

(cid:81)l

αi−1,l
k=1(1 − pi,k−1)

(cid:81)l

(cid:81)j

(cid:81)j

j
(cid:88)

l=1

j
(cid:88)

l=1
(cid:32) j
(cid:89)

k=1

qi,j =

(1 − pi,k−1)

(cid:33) (cid:32) j

(cid:33)

(cid:88)

l=1

(cid:81)l

αi−1,l
k=1(1 − pi,k−1)
(cid:18)

αi−1
cumprod(1 − pi)

(cid:19)

⇒ qi = cumprod(1 − pi)cumsum

(23)

(24)

(25)

(26)

(27)

(28)

(29)

(30)

where cumprod(x) = [1, x1, x1x2, . . . , (cid:81)|x|−1
i xi]. Note that we use the
“exclusive” variant of cumprod4 in keeping with our deﬁned special case pi,0 = 0. Unlike the recurrence relation of
eq. (10), these operations can be computed efﬁciently in parallel (Ladner & Fischer, 1980). The primary disadvantage
of this approach is that the product in the denominator of eq. (29) can cause numerical instabilities; we address this in
appendix G.

xi] and cumsum(x) = [x1, x1 + x2, . . . , (cid:80)|x|

i

4This can be computed e.g. in Tensorﬂow via tf.cumprod(x, exclusive=True)

Online and Linear-Time Attention by Enforcing Monotonic Alignments

D. Experiment Details

In this section, we give further details into the models and
training procedures used in section 4. Any further ques-
tions about implementation details should be directed to the
corresponding author. All models were implemented with
TensorFlow (Abadi et al., 2016).

D.1. Speech Recognition

D.1.1. TIMIT

Mel ﬁlterbank features were standardized to have zero
mean and unit variance across feature dimensions accord-
ing to their training set statistics and were fed directly into
an RNN encoder with three unidirectional LSTM layers,
each with 512 hidden units. After the ﬁrst and second
LSTM layers, we downsampled hidden state sequences by
skipping every other state before feeding into the subse-
quent layer. For the decoder, we used a single unidirec-
tional LSTM layer with 256 units, fed directly into the out-
put softmax layer. All weight matrices were initialized uni-
formly from [−0.075, 0.075]. The output tokens were em-
bedded via a learned embedding matrix with dimensional-
ity 30, initialized uniformly from [−(cid:112)3/30, (cid:112)3/30]. Our
decoder attention energy function used a hidden dimen-
sionality of 512, with the scalar bias r initialized to -1.
The model was regularized by adding weight noise with
a standard deviation of 0.5 after 2,000 training updates.
L2 weight regularization was also applied with a weight
of 10−6.

We trained the network using Adam (Kingma & Ba, 2014),
with β1 = 0.9, β2 = 0.999, and (cid:15) = 10−6. Utter-
ances were fed to the network with a minibatch size of
4. Our initial learning rate was 10−4, which we halved
after 40,000 training steps. We clipped gradients when
their global norm exceeded 2. We used three training repli-
cas. Beam search decoding was used to produce output
sequences with a beam width of 10.

D.1.2. WALL STREET JOURNAL

The input 80 mel ﬁlterbank / delta / delta-delta features
were organized as a T × 80 × 3 tensor, i.e. raw features,
deltas, and delta-deltas are concatenated along the “depth”
dimension. This was passed into a stack of two convolu-
tional layers with ReLU activations, each consisting of 32
3×3× depth kernels in time × frequency. These were both
strided by 2 × 2 in order to downsample the sequence in
time, minimizing the computation performed in the follow-
ing layers. Batch normalization (Ioffe & Szegedy, 2015)
was applied prior to the ReLU activation in each layer. All
encoder weight matrices and ﬁlters were initialized via a
truncated Gaussian with zero mean and a standard devia-
tion of 0.1.

This downsampled feature sequence was then passed into a
single unidirectional convolutional LSTM layer using 1x3
ﬁlter (i.e. only convolving across the frequency dimension
within each timestep). Finally, this was passed into a stack
of three unidirectional LSTM layers of size 256, inter-
leaved with a 256 dimensional linear projection, following
by batch normalization, and a ReLU activation. Decoder
weight matrices were initialized uniformly at random from
[−0.1, 0.1].

The decoder input is created by concatenating a 64 dimen-
sional embedding corresponding to the symbol emitted at
the previous timestep, and the 256 dimensional attention
context vector. The embedding was initialized uniformly
from [−1, 1]. This was passed into a single unidirectional
LSTM layer with 256 units. We used an attention energy
function hidden dimensionality of 128 and initialized the
bias scalar r to -4. Finally the concatenation of the atten-
tion context and LSTM output is passed into the softmax
output layer.

We applied label smoothing (Chorowski & Jaitly, 2017),
the target at time t, with (0.015ˆyt−2 +
replacing ˆyt,
0.035ˆyt−1 + ˆyt + 0.035ˆyt+1 + 0.015ˆyt+2)/1.1. We used
beam search decoding at test time with rank pruning at 8
hypotheses and a pruning threshold of 3.

The network was trained using teacher forcing on mini-
batches of 8 input utterances, optimized using Adam
(Kingma & Ba, 2014) with β1 = 0.9, β2 = 0.999, and
(cid:15) = 10−6. Gradients were clipped to a maximum global
norm of 1. We set the initial learning rate to 0.0002 and
decayed by a factor of 10 after 700,000, 1,000,000, and
1,300,000 training steps. L2 weight decay is used with a
weight of 10−6, and, beginning from step 20,000, Gaussian
weight noise with standard deviation of 0.075 was added to
weights for all LSTM layers and decoder embeddings. We
trained using 16 replicas.

D.2. Sentence Summarization

For data preparation, we used the same Gigaword data pro-
cessing scripts provided in (Rush et al., 2015) and tok-
enized into words by splitting on spaces. The vocabulary
was determined by selecting the most frequent 200,000 to-
kens. Only the tokens of the ﬁrst sentence of the article
were used as input to the model. An embedding layer was
used to embed tokens into a 200 dimensional space; em-
beddings were initialized using random normal distribution
with mean 0 and standard deviation 10−4.

We used a 4-layer bidirectional LSTM encoder with 4 lay-
ers and a single-layer unidirectional LSTM decoder. All
LSTMs, and the attention energy function, had a hidden di-
mensionality of 256. The decoder LSTM was fed directly
into the softmax output layer. All weights were initialized

Online and Linear-Time Attention by Enforcing Monotonic Alignments

uniform-randomly between −0.1 and 0.1.
In our mono-
tonic alignment decoder, we initialized r to -4. At test time,
we used a beam search over possible label sequences with
a beam width of 4.

A batch size of 64 was used and the model was trained
to minimize the sampled-softmax cross-entropy loss with
4096 negative samples. The Adam optimizer (Kingma &
Ba, 2014) was used with β1 = 0.9, β2 = 0.999, and
(cid:15) = 10−4, and an initial learning rate of 10−3; an expo-
nential decay was applied by multiplying the initial learn-
ing rate by .98n/30000 where n is the current training step.
Gradients were clipped to have a maximum global norm
of 2. Early stopping was used with respect to validation
loss and took about 300,000 steps for the baseline model,
and 180,000 steps for the monotonic model. Training was
conducted on 16 machines with 4 GPUs each. We reported
ROUGE scores computed over the test set of (Rush et al.,
2015).

D.3. Machine Translation

Overall, we followed the model of (Luong & Man-
ning, 2015) closely; our hyperparameters are largely the
same: Words were mapped to 512-dimensional embed-
dings, which were learned during training. We passed sen-
tences to the network in minibatches of size 128. As men-
tioned in the text, we used two unidirectional LSTM lay-
ers in both the encoder and decoder. All LSTM layers,
and the attention energy function, had a hidden dimen-
sionality of 512. We trained with a single replica for 40
epochs using Adam (Kingma & Ba, 2014) with β1 = 0.9,
β2 = 0.999, and (cid:15) = 10−8. We performed grid searches
over initial learning rate and decay schedules separately for
models using each of the two energy functions eq. (16) and
eq. (17). For the model using eq. (16), we used an ini-
tial learning rate of 0.0005, and after 10 epochs we mul-
tiplied the learning rate by 0.8 each epoch; for eq. (17)
we started at 0.001 and multiplied by 0.8 each epoch start-
ing at the eighth epoch. Parameters were uniformly initial-
ized in range [−0.1, 0.1]. Gradients were scaled whenever
their norms exceeded 5. We used dropout with probability
0.3 as described in (Pham et al., 2014). Unlike (Luong &
Manning, 2015), we did not reverse source sentences in our
monotonic attention experiments. We set r = −2 for the
attention energy function bias scalar for both eq. (16) and
eq. (17). We used greedy decoding (i.e. no beam search) at
test time.

E. Future Work

We believe there are a variety of promising extensions
of our monotonic attention mechanism, which we outline
brieﬂy below.

• The primary drawback of training in expectation is
that it retains the quadratic complexity during training.
One idea would be to replace the cumulative product
in eq. (9) with the thresholded remainder method of
(Graves, 2016) and (Grefenstette et al., 2015), but in
preliminary experiments we were unable to successfully
learn alignments with this approach. Alternatively, we
could further our investigation into gradient estimators
for discrete decisions (such as REINFORCE or straight-
through) instead of training in expectation (Bengio et al.,
2013).

• As we point out in section 2.4, our method can fail when
the attention energies ei,j are poorly scaled. This primar-
ily stems from the strict enforcement of monotonicity.
One possibility to mitigate this would be to instead reg-
ularize the model with a soft penalty which discourages
non-monotonic alignments, instead of preventing them
outright.

• In some problems, the input-output alignment is non-
monotonic only in small regions. A simple modiﬁca-
tion to our approach which would allow this would be
to subtract a constant integer from ti−1 between output
timesteps. Alternatively, utilizing multiple monotonic
attention mechanisms in parallel would allow the model
to attend to disparate memory locations at each output
timestep (effectively allowing for non-monotonic align-
ments) while still maintaining linear-time decoding.

• To facilitate comparison, we sought to modify the stan-
dard softmax-based attention framework as little as pos-
sible. As a result, we have thus far not fully taken advan-
tage of the fact that the decoding process is much more
efﬁcient. Speciﬁcally, the attention energy function of
eq. (15) was primarily motivated by the fact that it is
trivially parallelizable so that its repeated application is
inexpensive. We could instead use a recurrent attention
energy function, whose output depends on both the at-
tention energies for prior memory items and those at the
previous output timestep.

F. How much faster is linear-time decoding?

Throughout this paper, we have emphasized that one ad-
vantage of our approach is that it allows for linear-time de-
coding, i.e. the decoder RNN only makes a single pass over
the memory in the course of producing the output sequence.
However, we have thus far not attempted to quantify how
much of a speedup this incurs in practice. Towards this
end, we conducted an additional experiment to measure the
speed of efﬁciently-implemented softmax-based and hard
monotonic attention mechanisms. We chose to focus solely
on the speed of the attention mechanisms rather than an en-
tire RNN sequence-to-sequence model because models us-
ing these attention mechanisms are otherwise equivalent.

Online and Linear-Time Attention by Enforcing Monotonic Alignments

emphasize that at training time, we expect our soft mono-
tonic attention approach to have roughly the computational
cost as standard softmax attention, thanks to the fact that
we can compute the resulting attention distribution in par-
allel as described in appendix C.1. The code used for this
benchmark is available in the repository for this paper.5

G. Practitioner’s Guide

Because we are proposing a novel attention mechanism, we
share here some insights gained from applying it in various
settings in order to help practitioners try it on their own
problems:

• The recursive structure of computing αi,j in eq. (9) can
result in exploding gradients. We found it vital to apply
gradient clipping in all of our experiments, as described
in appendix D.

• Many automatic differentiation packages can produce
numerically unstable gradients when using their cumula-
tive product function.67 Our simple solution was to com-
pute the product in log-space, i.e. replacing (cid:81)
n xn =
exp((cid:80)

i log(xn)).

• In addition, the product in the denominator of eq. (29)
can become negligibly small because the terms (1 −
pi,k−1) all fall in the range [0, 1]. The simplest way to
prevent the resulting numerical instabilities is to clip the
range of the denominator to be within [(cid:15), 1] where (cid:15) is a
small constant (we used (cid:15) = 10−10). This can result in
incorrect values for αi,j particularly when some pi,j are
close to 1, but we encountered no discernible effect on
our results.

• Alternatively, we found in preliminary experiments that
simply setting the denominator to 1 still produced good
results. This can be explained by the observation that
when all pi,j ∈ {0, 1} (which we encourage during train-
ing), eq. (29) is equivalent to the recurrence relation of
eq. (10) even when the denominator is 1.

• As we mention in the experiment details of the previous
section, we ended up using a small range of values for
the initial energy function scalar bias r. In general, per-
formance was not very sensitive to this parameter, but
we found small performance gains from using values in
{−5, −4, −3, −2, −1} for different problems.

• More broadly, while the attention energy function mod-
iﬁcations described in section 2.4 allowed models using
our mechanism to be effectively trained on all tasks we

5https://github.com/craffel/mad
6https://github.com/tensorflow/

tensorflow/issues/3862

7https://github.com/Theano/Theano/issues/

5197

Figure 8. Speedup of hard monotonic attention mechanism com-
pared to softmax attention on a synthetic benchmark.

Measuring the speed of the attention mechanisms alone al-
lows us to isolate the difference in computational cost be-
tween the two approaches.

Speciﬁcally, we implemented both attention mechanisms
using the highly-efﬁcient C++ linear algebra package Eigen
(Guennebaud et al., 2010). We set entries of the mem-
ory h and the decoder hidden states si to random vectors
with entries sampled uniformly in the range [−1, 1]. We
then computed context vectors following eqs. (2) and (3)
for the softmax attention mechanism and following algo-
rithm 1 for hard monotonic attention. We varied the input
and output sequence lengths and averaged the time to pro-
duce all of the corresponding context vectors over 100 trials
for each setting.

The speedup of the monotonic attention mechanism com-
pared to softmax attention is visualized in ﬁg. 8. We found
monotonic attention to be about 4 − 40× faster depending
on the input and output sequence lengths. The most promi-
nent difference occurred for short input sequences and long
output sequences; in these cases the monotonic attention
mechanism ﬁnishes processing the input sequence before
it ﬁnishes producing the output sequence and therefore is
able to stop computing context vectors. We emphasize that
these numbers represent the best-case speedup from our
approach; a more general insight is simply that our pro-
posed hard monotonic attention mechanism has the poten-
tial to make decoding signiﬁcantly more efﬁcient for long
sequences. Additionally, this advantage is distinct from the
fact that our hard monotonic attention mechanism can be
used for online sequence-to-sequence problems. We also

Online and Linear-Time Attention by Enforcing Monotonic Alignments

tried, they were not always necessary for convergence.
Speciﬁcally, in speech recognition experiments the per-
formance of our model was the same using eq. (15) and
eq. (16), but for summarization experiments the mod-
els were unable to learn to utilize attention when using
eq. (15). For ease of implementation, we recommend
starting with the standard attention energy function of
eq. (15) and then applying the modiﬁcations of eq. (16)
if the model fails to utilize attention.

• It is occasionally recommended to reverse the input se-
quence prior to feeding it into sequence-to-sequence
models (Sutskever et al., 2014). This violates our as-
sumption that the input should be processed in a left-
to-right manner when computing attention, so should be
avoided.

• Finally, we highly recommend visualizing the attention
alignments αi,j over the course of training. Attention
provides valuable insight into the model’s behavior, and
failure modes can be quickly spotted (e.g. if αi,j = 0 for
all i and j).

With the above factors in mind, on all problems we studied,
we were able to replace softmax-based attention with our
novel attention and immediately achieve competitive per-
formance.

References

Abadi, Martin, Barham, Paul, Chen, Jianmin, Chen,
Zhifeng, Davis, Andy, Dean, Jeffrey, Devin, Matthieu,
Ghemawat, Sanjay, Irving, Geoffrey, Isard, Michael,
Kudlur, Manjunath, Levenberg, Josh, Monga, Rajat,
Moore, Sherry, Murray, Derek G., Steiner, Benoit,
Tucker, Paul, Vasudevan, Vijay, Warden, Pete, Wicke,
Martin, Yu, Yuan, and Zheng, Xiaoqiang. TensorFlow:
A system for large-scale machine learning. In Operating
Systems Design and Implementation, 2016.

Graves, Alex. Adaptive computation time for recurrent
arXiv preprint arXiv:1603.08983,

neural networks.
2016.

Grefenstette, Edward, Hermann, Karl Moritz, Suleyman,
Mustafa, and Blunsom, Phil. Learning to transduce with
unbounded memory. In Advances in Neural Information
Processing Systems, 2015.

Guennebaud, Gaël, Jacob, Benoıt, Avery, Philip, Bachrach,
Eigen v3.

Abraham, Barthelemy, Sebastien, et al.
http://eigen.tuxfamily.org, 2010.

Ioffe, Sergey and Szegedy, Christian. Batch normalization:
Accelerating deep network training by reducing internal
covariate shift. In International Conference on Machine
Learning, 2015.

Kingma, Diederik and Ba,

Jimmy.
method for stochastic optimization.
arXiv:1412.6980, 2014.

Adam:

A
arXiv preprint

Ladner, Richard E. and Fischer, Michael J. Parallel preﬁx
computation. Journal of the ACM (JACM), 27(4):831–
838, 1980.

Liu, Peter J. and Pan, Xin. Text summarization with Ten-

sorFlow. http://goo.gl/16RNEu, 2016.

Luong, Minh-Thang and Manning, Christopher D. Stan-
ford neural machine translation systems for spoken lan-
In International Workshop on Spoken
guage domain.
Language Translation, 2015.

Pham, Vu, Bluche, Théodore, Kermorvant, Christopher,
and Louradour, Jérôme. Dropout improves recurrent
neural networks for handwriting recognition. In Interna-
tional Conference on Frontiers in Handwriting Recogni-
tion, 2014.

Bengio, Yoshua, Léonard, Nicholas, and Courville, Aaron.
Estimating or propagating gradients through stochastic
arXiv preprint
neurons for conditional computation.
arXiv:1308.3432, 2013.

Rush, Alexander M., Chopra, Sumit, and Weston, Jason. A
neural attention model for abstractive sentence summa-
rization. In Conference on Empirical Methods in Natural
Language Processing, 2015.

Chorowski, Jan and Jaitly, Navdeep. Towards better decod-
ing and language model integration in sequence to se-
quence models. arXiv preprint arXiv:1612.02695, 2017.

Sutskever, Ilya, Vinyals, Oriol, and Le, Quoc V. Sequence
to sequence learning with neural networks. In Advances
in neural information processing systems, 2014.

