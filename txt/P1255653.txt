Generating Sentences from a Continuous Space

Samuel R. Bowman∗
NLP Group and Dept. of Linguistics
Stanford University
sbowman@stanford.edu

Luke Vilnis∗
CICS
University of Massachusetts Amherst
luke@cs.umass.edu

Oriol Vinyals, Andrew M. Dai, Rafal Jozefowicz & Samy Bengio
Google Brain
{vinyals, adai, rafalj, bengio}@google.com

Abstract

The standard recurrent neural network
language model (rnnlm) generates sen-
tences one word at a time and does not
work from an explicit global sentence rep-
resentation.
In this work, we introduce
and study an rnn-based variational au-
toencoder generative model that incorpo-
rates distributed latent representations of
entire sentences. This factorization al-
lows it to explicitly model holistic prop-
erties of sentences such as style, topic,
and high-level syntactic features. Samples
from the prior over these sentence repre-
sentations remarkably produce diverse and
well-formed sentences through simple de-
terministic decoding. By examining paths
through this latent space, we are able to
generate coherent novel sentences that in-
terpolate between known sentences. We
present techniques for solving the diﬃcult
learning problem presented by this model,
demonstrate its eﬀectiveness in imputing
missing words, explore many interesting
properties of the model’s latent sentence
space, and present negative results on the
use of the model in language modeling.

1 Introduction

neural

language sentences.

Recurrent
language models
network
(rnnlms, Mikolov et al., 2011) represent the state
of the art in unsupervised generative modeling
In supervised
for natural
settings, rnnlm decoders conditioned on task-
speciﬁc features are the state of the art in tasks
like machine translation (Sutskever et al., 2014;
Bahdanau et al., 2015) and image captioning
(Vinyals et al., 2015; Mao et al., 2015; Donahue
et al., 2015). The rnnlm generates sentences
word-by-word based on an evolving distributed
state representation, which makes it a proba-
bilistic model with no signiﬁcant independence

∗First two authors contributed equally. Work was

done when all authors were at Google, Inc.

i went to the store to buy some groceries .
i store to buy some groceries .
i were to buy any groceries .
horses are to buy any groceries .
horses are to buy any animal .
horses the favorite any animal .
horses the favorite favorite animal .
horses are my favorite animal .

Table 1: Sentences produced by greedily decoding
from points between two sentence encodings with
a conventional autoencoder. The intermediate sen-
tences are not plausible English.

assumptions, and makes it capable of modeling
complex distributions over sequences,
including
those with long-term dependencies. However, by
breaking the model structure down into a series of
next-step predictions, the rnnlm does not expose
an interpretable representation of global features
like topic or of high-level syntactic properties.

We propose an extension of the rnnlm that is
designed to explicitly capture such global features
in a continuous latent variable. Naively, maxi-
mum likelihood learning in such a model presents
an intractable inference problem. Drawing inspi-
ration from recent successes in modeling images
(Gregor et al., 2015), handwriting, and natural
speech (Chung et al., 2015), our model circum-
vents these diﬃculties using the architecture of a
variational autoencoder and takes advantage of re-
cent advances in variational inference (Kingma and
Welling, 2015; Rezende et al., 2014) that introduce
a practical training technique for powerful neural
network generative models with latent variables.

Our contributions are as follows: We propose a
variational autoencoder architecture for text and
discuss some of the obstacles to training it as well
as our proposed solutions. We ﬁnd that on a stan-
dard language modeling evaluation where a global
variable is not explicitly needed, this model yields
similar performance to existing rnnlms. We also
evaluate our model using a larger corpus on the
task of imputing missing words. For this task,
we introduce a novel evaluation strategy using an

6
1
0
2
 
y
a
M
 
2
1
 
 
]

G
L
.
s
c
[
 
 
4
v
9
4
3
6
0
.
1
1
5
1
:
v
i
X
r
a

adversarial classiﬁer, sidestepping the issue of in-
tractable likelihood computations by drawing in-
spiration from work on non-parametric two-sample
tests and adversarial training.
In this setting,
our model’s global latent variable allows it to do
well where simpler models fail. We ﬁnally intro-
duce several qualitative techniques for analyzing
the ability of our model to learn high level fea-
tures of sentences. We ﬁnd that they can produce
diverse, coherent sentences through purely deter-
ministic decoding and that they can interpolate
smoothly between sentences.

2 Background

2.1 Unsupervised sentence encoding
A standard rnn language model predicts each
word of a sentence conditioned on the previous
word and an evolving hidden state. While eﬀec-
tive, it does not learn a vector representation of
the full sentence. In order to incorporate a contin-
uous latent sentence representation, we ﬁrst need a
method to map between sentences and distributed
representations that can be trained in an unsuper-
vised setting. While no strong generative model
is available for this problem, three non-generative
techniques have shown promise: sequence autoen-
coders, skip-thought, and paragraph vector.

Sequence autoencoders have seen some success
in pre-training sequence models for supervised
downstream tasks (Dai and Le, 2015) and in gen-
erating complete documents (Li et al., 2015a).
An autoencoder consists of an encoder function
ϕenc and a probabilistic decoder model p(x|(cid:126)z =
ϕenc(x)), and maximizes the likelihood of an ex-
ample x conditioned on (cid:126)z, the learned code for
x.
In the case of a sequence autoencoder, both
encoder and decoder are rnns and examples are
token sequences.

Standard autoencoders are not eﬀective at ex-
tracting for global semantic features. In Table 1,
we present the results of computing a path or ho-
motopy between the encodings for two sentences
and decoding each intermediate code. The in-
termediate sentences are generally ungrammatical
and do not transition smoothly from one to the
other. This suggests that these models do not
generally learn a smooth, interpretable feature sys-
tem for sentence encoding. In addition, since these
models do not incorporate a prior over (cid:126)z, they can-
not be used to assign probabilities to sentences or
to sample novel sentences.

Two other models have shown promise in learn-
ing sentence encodings, but cannot be used in
a generative setting: Skip-thought models (Kiros
et al., 2015) are unsupervised learning models that
take the same model structure as a sequence au-
toencoder, but generate text conditioned on a
neighboring sentence from the target text, instead

of on the target sentence itself. Finally, para-
graph vector models (Le and Mikolov, 2014) are
non-recurrent sentence representation models. In a
paragraph vector model, the encoding of a sentence
is obtained by performing gradient-based inference
on a prospective encoding vector with the goal of
using it to predict the words in the sentence.

2.2 The variational autoencoder

The variational autoencoder (vae, Kingma and
Welling, 2015; Rezende et al., 2014) is a genera-
tive model that is based on a regularized version
of the standard autoencoder. This model imposes
a prior distribution on the hidden codes (cid:126)z which
enforces a regular geometry over codes and makes
it possible to draw proper samples from the model
using ancestral sampling.

The vae modiﬁes the autoencoder architecture
by replacing the deterministic function ϕenc with
a learned posterior recognition model, q((cid:126)z|x). This
model parametrizes an approximate posterior dis-
tribution over (cid:126)z (usually a diagonal Gaussian) with
a neural network conditioned on x. Intuitively, the
vae learns codes not as single points, but as soft
ellipsoidal regions in latent space, forcing the codes
to ﬁll the space rather than memorizing the train-
ing data as isolated codes.

If the vae were trained with a standard autoen-
coder’s reconstruction objective, it would learn to
encode its inputs deterministically by making the
variances in q((cid:126)z|x) vanishingly small (Raiko et al.,
Instead, the vae uses an objective which
2015).
encourages the model to keep its posterior distri-
butions close to a prior p((cid:126)z), generally a standard
Gaussian (µ = (cid:126)0, σ = (cid:126)1). Additionally, this objec-
tive is a valid lower bound on the true log likelihood
of the data, making the vae a generative model.
This objective takes the following form:

L(θ; x) = −kl(qθ((cid:126)z|x)||p((cid:126)z))

+ Eqθ((cid:126)z|x)[log pθ(x|(cid:126)z)]

(1)

≤ log p(x) .

This forces the model to be able to decode plausible
sentences from every point in the latent space that
has a reasonable probability under the prior.

In the experiments presented below using vae
models, we use diagonal Gaussians for the prior
and posterior distributions p((cid:126)z) and q((cid:126)z|x), using
the Gaussian reparameterization trick of Kingma
and Welling (2015). We train our models with
stochastic gradient descent, and at each gradient
step we estimate the reconstruction cost using a
single sample from q((cid:126)z|x), but compute the kl di-
vergence term of the cost function in closed form,
again following Kingma and Welling (2015).

Figure 1: The core structure of our variational au-
toencoder language model. Words are represented
using a learned dictionary of embedding vectors.

3 A VAE for sentences

We adapt the variational autoencoder to text
by using single-layer lstm rnns (Hochreiter and
Schmidhuber, 1997) for both the encoder and the
decoder, essentially forming a sequence autoen-
coder with the Gaussian prior acting as a regu-
larizer on the hidden code. The decoder serves as
a special rnn language model that is conditioned
on this hidden code, and in the degenerate setting
where the hidden code incorporates no useful in-
formation, this model is eﬀectively equivalent to an
rnnlm. The model is depicted in Figure 1, and is
used in all of the experiments discussed below.

We explored several variations on this architec-
ture, including concatenating the sampled (cid:126)z to the
decoder input at every time step, using a soft-
plus parametrization for the variance, and using
deep feedforward networks between the encoder
and latent variable and the decoder and latent vari-
able. We noticed little diﬀerence in the model’s
performance when using any of these variations.
However, when including feedforward networks be-
tween the encoder and decoder we found that it
is necessary to use highway network layers (Srivas-
tava et al., 2015) for the model to learn. We discuss
hyperparameter tuning in the appendix.

We also experimented with more sophisticated
recognition models q((cid:126)z|x), including a multistep
sampling model styled after draw (Gregor et al.,
2015), and a posterior approximation using nor-
malizing ﬂows (Rezende and Mohamed, 2015).
However, we were unable to reap signiﬁcant gains
over our plain vae.

While the strongest results with vaes to date
have been on continuous domains like images, there
has been some work on discrete sequences: a tech-
nique for doing this using rnn encoders and de-
coders, which shares the same high-level architec-
ture as our model, was proposed under the name
Variational Recurrent Autoencoder (vrae) for the
modeling of music in Fabius and van Amersfoort
(2014). While there has been other work on includ-
ing continuous latent variables in rnn-style mod-
els for modeling speech, handwriting, and music
(Bayer and Osendorfer, 2015; Chung et al., 2015),
these models include separate latent variables per
timestep and are unsuitable for our goal of model-
ing global features.

In a recent paper with goals similar to ours,
Miao et al. (2015) introduce an eﬀective VAE-
based document-level language model that models
texts as bags of words, rather than as sequences.
They mention brieﬂy that they have to train the
encoder and decoder portions of the network in al-
ternation rather than simultaneously, possibly as a
way of addressing some of the issues that we dis-
cuss in Section 3.1.

3.1 Optimization challenges

Our model aims to learn global latent represen-
tations of sentence content. We can quantify the
degree to which our model learns global features
by looking at the variational lower bound objec-
tive (1). The bound breaks into two terms: the
data likelihood under the posterior (expressed as
cross entropy), and the kl divergence of the pos-
terior from the prior. A model that encodes useful
information in the latent variable (cid:126)z will have a non-
zero kl divergence term and a relatively small cross
entropy term. Straightforward implementations of
our vae fail to learn this behavior: except in van-
ishingly rare cases, most training runs with most
hyperparameters yield models that consistently set
q((cid:126)z|x) equal to the prior p((cid:126)z), bringing the kl di-
vergence term of the cost function to zero.

When the model does this, it is essentially be-
having as an rnnlm. Because of this, it can ex-
press arbitrary distributions over the output sen-
tences (albeit with a potentially awkward left-to-
right factorization) and can thereby achieve like-
lihoods that are close to optimal. Previous work
on vaes for image modeling (Kingma and Welling,
2015) used a much weaker independent pixel de-
coder model p(x|(cid:126)z), forcing the model to use the
global latent variable to achieve good likelihoods.
In a related result, recent approaches to image gen-
eration that use lstm decoders are able to do well
without vae-style global latent variables (Theis
and Bethge, 2015).

This problematic tendency in learning is com-
pounded by the lstm decoder’s sensitivity to sub-
tle variation in the hidden states, such as that in-
troduced by the posterior sampling process. This
causes the model to initially learn to ignore (cid:126)z and
go after low hanging fruit, explaining the data with
the more easily optimized decoder. Once this has
happened, the decoder ignores the encoder and lit-
tle to no gradient signal passes between the two,
yielding an undesirable stable equilibrium with the
kl cost term at zero. We propose two techniques
to mitigate this issue.

KL cost annealing In this simple approach to
this problem, we add a variable weight to the kl
term in the cost function at training time. At the
start of training, we set that weight to zero, so
that the model learns to encode as much informa-

This technique is parameterized by a keep rate
k ∈ [0, 1]. We tune this parameter both for our
vae and for our baseline rnnlm. Taken to the
extreme of k = 0, the decoder sees no input, and is
thus able to condition only on the number of words
produced so far, yielding a model that is extremely
limited in the kinds of distributions it can model
without using (cid:126)z.

4 Results: Language modeling

In this section, we report on language modeling
experiments on the Penn Treebank in an eﬀort to
discover whether the inclusion of a global latent
variable is helpful for this standard task. For this
reason, we restrict our vae hyperparameter search
to those models which encode a non-trivial amount
in the latent variable, as measured by the kl di-
vergence term of the variational lower bound.

Results We used the standard train–test split
for the corpus, and report test set results in Ta-
ble 2. The results shown reﬂect the training and
test set performance of each model at the training
step at which the model performs best on the de-
velopment set. Our reported ﬁgures for the vae
reﬂect the variational lower bound on the test like-
lihood, while for the rnnlms, which can be eval-
uated exactly, we report the true test likelihood.
This discrepancy puts the vae at a potential dis-
advantage.

In the standard setting,

the vae performs
slightly worse than the rnnlm baseline, though
it does succeed in using the latent space to a lim-
ited extent: it has a reconstruction cost (99) better
than that of the baseline rnnlm, but makes up for
this with a kl divergence cost of 2. Training a vae
in the standard setting without both word dropout
and cost annealing reliably results in models with
equivalent performance to the baseline rnnlm, and
zero kl divergence.

To demonstrate the ability of the latent variable
to encode the full content of sentences in addition
to more abstract global features, we also provide
numbers for an inputless decoder that does not
condition on previous tokens, corresponding to a
word dropout keep rate of 0.
In this regime we
can see that the variational lower bound contains
a signiﬁcantly larger kl term and shows a substan-
tial improvement over the weakened rnnlm, which
is essentially limited to using unigram statistics
in this setting. While it is weaker than a stan-
dard decoder, the inputless decoder has the inter-
esting property that its sentence generating pro-
cess is fully diﬀerentiable. Advances in generative
models of this kind could be promising as a means
of generating text while using adversarial training
methods, which require diﬀerentiable generators.

Even with the techniques described in the pre-

Figure 2: The weight of the kl divergence term
of variational lower bound according to a typical
sigmoid annealing schedule plotted alongside the
(unweighted) value of the kl divergence term for
our vae on the Penn Treebank.

tion in (cid:126)z as it can. Then, as training progresses, we
gradually increase this weight, forcing the model to
smooth out its encodings and pack them into the
prior. We increase this weight until it reaches 1,
at which point the weighted cost function is equiv-
alent to the true variational lower bound. In this
setting, we do not optimize the proper lower bound
on the training data likelihood during the early
stages of training, but we nonetheless see improve-
ments on the value of that bound at convergence.
This can be thought of as annealing from a vanilla
autoencoder to a vae. The rate of this increase is
tuned as a hyperparameter.

Figure 2 shows the behavior of the kl cost term
during the ﬁrst 50k steps of training on Penn Tree-
bank (Marcus et al., 1993) language modeling with
kl cost annealing in place. This example reﬂects a
pattern that we observed often: kl spikes early in
training while the model can encode information in
(cid:126)z cheaply, then drops substantially once it begins
paying the full kl divergence penalty, and ﬁnally
slowly rises again before converging as the model
learns to condense more information into (cid:126)z.

Word dropout and historyless decoding In
addition to weakening the penalty term on the en-
codings, we also experiment with weakening the
decoder. As in rnnlms and sequence autoen-
coders, during learning our decoder predicts each
word conditioned on the ground-truth previous
word. A natural way to weaken the decoder is
to remove some or all of this conditioning infor-
mation during learning. We do this by randomly
replacing some fraction of the conditioned-on word
tokens with the generic unknown word token unk.
This forces the model to rely on the latent variable
(cid:126)z to make good predictions. This technique is a
variant of word dropout (Iyyer et al., 2015; Kumar
et al., 2015), applied not to a feature extractor but
to a decoder. We also experimented with standard
dropout (Srivastava et al., 2014) applied to the in-
put word embeddings in the decoder, but this did
not help the model learn to use the latent variable.

Model

Standard
Train nll Train ppl Test nll Test ppl

Inputless Decoder
Train nll Train ppl Test nll Test ppl

RNNLM 100 –
98 (2)
VAE

95 100 –
100 101 (2)

116
119

135 –
120 (15)

600 135 –
300 125 (15)

> 600
380

Table 2: Penn Treebank language modeling results, reported as negative log likelihoods and as perplexi-
ties. Lower is better for both metrics. For the vae, the kl term of the likelihood is shown in parentheses
alongside the total likelihood.

vious section, including the inputless decoder, we
were unable to train models for which the kl diver-
gence term of the cost function dominates the re-
construction term. This suggests that it is still sub-
stantially easier to learn to factor the data distribu-
tion using simple local statistics, as in the rnnlm,
such that an encoder will only learn to encode in-
formation in (cid:126)z when that information cannot be
eﬀectively described by these local statistics.

5 Results: Imputing missing words

We claim that the our vae’s global sentence fea-
tures make it especially well suited to the task of
imputing missing words in otherwise known sen-
tences.
In this section, we present a technique
for imputation and a novel evaluation strategy in-
spired by adversarial training. Qualitatively, we
ﬁnd that the vae yields more diverse and plausible
imputations for the same amount of computation
(see the examples given in Table 3), but precise
quantitative evaluation requires intractable likeli-
hood computations. We sidestep this by introduc-
ing a novel evaluation strategy.

While the standard rnnlm is a powerful genera-
tive model, the sequential nature of likelihood com-
putation and decoding makes it unsuitable for per-
forming inference over unknown words given some
known words (the task of imputation). Except in
the special case where the unknown words all ap-
pear at the end of the decoding sequence, sampling
from the posterior over the missing variables is in-
tractable for all but the smallest vocabularies. For
a vocabulary of size V , it requires O(V ) runs of full
rnn inference per step of Gibbs sampling or iter-
ated conditional modes. Worse, because of the di-
rectional nature of the graphical model given by an
rnnlm, many steps of sampling could be required
to propagate information between unknown vari-
ables and the known downstream variables. The
vae, while it suﬀers from the same intractability
problems when sampling or computing map im-
putations, can more easily propagate information
between all variables, by virtue of having a global
latent variable and a tractable recognition model.
For this experiment and subsequent analysis, we
train our models on the Books Corpus introduced
in Kiros et al. (2015). This is a collection of text
from 12k e-books, mostly ﬁction. The dataset,

after pruning, contains approximately 80m sen-
tences. We ﬁnd that this much larger amount of
data produces more subjectively interesting gener-
ative models than smaller standard language mod-
eling datasets. We use a ﬁxed word dropout rate of
75% when training this model and all subsequent
models unless otherwise speciﬁed. Our models (the
vae and rnnlm) are trained as language models,
decoding right-to-left to shorten the dependencies
during learning for the vae. We use 512 hidden
units.

Inference method To generate imputations
from the two models, we use beam search with
beam size 15 for the rnnlm and approximate iter-
ated conditional modes (Besag, 1986) with 3 steps
of a beam size 5 search for the vae. This allows
us to compare the same amount of computation
for both models. We ﬁnd that breaking decod-
ing for the vae into several sequential steps is nec-
essary to propagate information among the vari-
ables.
Iterated conditional modes is a technique
for ﬁnding the maximum joint assignment of a set
of variables by alternately maximizing conditional
distributions, and is a generalization of “hard-em”
algorithms like k-means (Kearns et al., 1998). For
approximate iterated conditional modes, we ﬁrst
initialize the unknown words to the unk token. We
then alternate assigning the latent variable to its
mode from the recognition model, and performing
constrained beam search to assign the unknown
words. Both of our generative models are trained
to decode sentences from right-to-left, which short-
ens the dependencies involved in learning for the
vae, and we impute the ﬁnal 20% of each sen-
tence. This lets us demonstrate the advantages of
the global latent variable in the regime where the
rnnlm suﬀers the most from its inductive bias.

Adversarial evaluation Drawing inspiration
from adversarial training methods for generative
models as well as non-parametric two-sample tests
(Goodfellow et al., 2014; Li et al., 2015b; Denton
et al., 2015; Gretton et al., 2012), we evaluate the
imputed sentence completions by examining their
distinguishability from the true sentence endings.
While the non-diﬀerentiability of the discrete rnn
decoder prevents us from easily applying the ad-
versarial criterion at train time, we can deﬁne a

but now , as they parked out front and owen stepped out of the car , he could see
True: that the transition was complete . RNNLM: it , ” i said . VAE: through the driver ’s door .

you kill him and his
True: men .

RNNLM: . ”

VAE: brother .

not surprising , the mothers dont exactly see eye to eye with me
RNNLM: , i said .
True: on this matter .

VAE: , right now .

Table 3: Examples of using beam search to impute missing words within sentences. Since we decode from
right to left, note the stereotypical completions given by the rnnlm, compared to the vae completions
that often use topic data and more varied vocabulary.

Model

Adv. Err. (%)
Unigram lstm

NLL
rnnlm

RNNLM (15 bm.)
VAE (3x5 bm.)

28.32
22.39

38.92
35.59

46.01
46.14

Table 4: Results for adversarial evaluation of im-
putations. Unigram and lstm numbers are the
adversarial error (see text) and rnnlm numbers
are the negative log-likelihood given to entire gen-
erated sentence by the rnnlm, a measure of sen-
tence typicality. Lower is better on both metrics.
The vae is able to generate imputations that are
signiﬁcantly more diﬃcult to distinguish from the
true sentences.

very ﬂexible test time evaluation by training a dis-
criminant function to separate the generated and
true sentences, which deﬁnes an adversarial error.
We train two classiﬁers: a bag-of-unigrams lo-
gistic regression classiﬁer and an lstm logistic re-
gression classiﬁer that reads the input sentence and
produces a binary prediction after seeing the ﬁnal
eos token. We train these classiﬁers using early
stopping on a 80/10/10 train/dev/test split of 320k
sentences, constructing a dataset of 50% complete
sentences from the corpus (positive examples) and
50% sentences with imputed completions (negative
examples). We deﬁne the adversarial error as the
gap between the ideal accuracy of the discrimina-
indistinguishable samples), and the
tor (50%, i.e.
actual accuracy attained.

Results As a consequence of this experimental
setup, the rnnlm cannot choose anything outside
of the top 15 tokens given by the rnn’s initial un-
conditional distribution P (x1|Null) when produc-
ing the ﬁnal token of the sentence, since it has not
yet generated anything to condition on, and has a
beam size of 15. Table 4 shows that this weakness
makes the rnnlm produce far less diverse samples
than the vae and suﬀer accordingly versus the ad-
versarial classiﬁer. Additionally, we include the
score given to the entire sentence with the imputed
completion given a separate independently trained
language model. The likelihood results are com-

parable, though the rnnlms favoring of generic
high-probability endings such as “he said,” gives
it a slightly lower negative log-likelihood. Mea-
suring the rnnlm likelihood of sentences them-
selves produced by an rnnlm is not a good mea-
sure of the power of the model, but demonstrates
that the rnnlm can produce what it sees as high-
quality imputations by favoring typical local statis-
tics, even though their repetitive nature produces
easy failure modes for the adversarial classiﬁer.
Accordingly, under the adversarial evaluation our
model substantially outperforms the baseline since
it is able to eﬃciently propagate information bidi-
rectionally through the latent variable.

6 Analyzing variational models

We now turn to more qualitative analysis of the
model. Since our decoder model p(x|(cid:126)z) is a sophis-
ticated rnnlm, simply sampling from the directed
graphical model (ﬁrst p((cid:126)z) then p(x|(cid:126)z)) would not
tell us much about how much of the data is being
explained by each of the latent space and the de-
coder. Instead, for this part of the evaluation, we
sample from the Gaussian prior, but use a greedy
deterministic decoder for p(x|(cid:126)z), the rnnlm con-
ditioned on (cid:126)z. This allows us to get a sense of how
much of the variance in the data distribution is be-
ing captured by the distributed vector (cid:126)z as opposed
to the decoder. Interestingly, these results qualita-
tively demonstrate that large amounts of variation
in generated language can be achieved by following
this procedure. In the appendix, we provide some
results on small text classiﬁcation tasks.

6.1 Analyzing the impact of word dropout

For this experiment, we train on the Books Cor-
pus and test on a held out 10k sentence test set
from that corpus. We ﬁnd that train and test set
performance are very similar. In Figure 3, we ex-
amine the impact of word dropout on the varia-
tional lower bound, broken down into kl diver-
gence and cross entropy components. We drop out
words with the speciﬁed keep rate at training time,
but supply all words as inputs at test time except
in the 0% setting.

We do not re-tune the hyperparameters for each

100% word keep

“ no , ” he said .
“ thank you , ” he said .

75% word keep

“ love you , too . ”
she put her hand on his shoulder and followed him
to the door .

50% word keep

0% word keep

“ maybe two or two . ”
she laughed again , once again , once again , and
thought about it for a moment in long silence .

i i hear some of of of
i was noticed that she was holding the in in of the
the in

Table 5: Samples from a model trained with varying amounts of word dropout. We sample a vector from
the Gaussian prior and apply greedy decoding to the result. Note that diverse samples can be achieved
using a purely deterministic decoding procedure. Once we use reach a purely inputless decoder in the
0% setting, however, the samples cease to be plausible English sentences.

he had been unable to conceal the fact that there was a logical explanation for his inability to
alter the fact that they were supposed to be on the other side of the house .

with a variety of pots strewn scattered across the vast expanse of the high ceiling , a vase of
colorful ﬂowers adorned the tops of the rose petals littered the ﬂoor and littered the ﬂoor .

atop the circular dais perched atop the gleaming marble columns began to emerge from atop the
stone dais, perched atop the dais .

Table 6: Greedily decoded sentences from a model with 75% word keep probability, sampling from
lower-likelihood areas of the latent space. Note the consistent topics and vocabulary usage.

taking each token xt = argmaxxtp(xt|x0,...,t−1, (cid:126)z).
This allows us to get a sense of how much of the
variance in the data distribution is being captured
by the distributed vector (cid:126)z as opposed to by local
language model dependencies.

These results, shown in Table 5, qualitatively
demonstrate that large amounts of variation in
generated language can be achieved by following
this procedure. At the low end, where very lit-
tle of the variance is explained by (cid:126)z, we see that
greedy decoding applied to a Gaussian sample does
not produce diverse sentences. As we increase the
amount of word dropout and force (cid:126)z to encode
more information, we see the sentences become
more varied, but past a certain point they begin
to repeat words or show other signs of ungram-
maticality. Even in the case of a fully dropped-out
decoder, the model is able to capture higher-order
statistics not present in the unigram distribution.

Additionally, in Table 6 we examine the eﬀect
of using lower-probability samples from the latent
Gaussian space for a model with a 75% word keep
rate. We ﬁnd lower-probability samples by ap-
plying an approximately volume-preserving trans-
formation to the Gaussian samples that stretches
some eigenspaces by up to a factor of 4. This has
the eﬀect of creating samples that are not too im-
probable under the prior, but still reach into the
tails of the distribution. We use a random linear
transformation, with matrix elements drawn from
a uniform distribution from [−c, c], with c chosen
to give the desired properties (0.1 in our experi-

Figure 3: The values of the two terms of the cost
function as word dropout increases.

run, which results in the model with no dropout
encoding very little information in (cid:126)z (i.e., the kl
component is small). We can see that as we lower
the keep rate for word dropout, the amount of in-
formation stored in the latent variable increases,
and the overall likelihood of the model degrades
somewhat. Results from the Section 4 indicate
that a model with no latent variable would degrade
in performance signiﬁcantly more in the presence
of heavy word dropout.

We also qualitatively evaluate samples,
to
demonstrate that the increased kl allows meaning-
ful sentences to be generated purely from contin-
uous sampling. Since our decoder model p(x|(cid:126)z) is
a sophisticated rnnlm, simply sampling from the
directed graphical model (ﬁrst p((cid:126)z) then p(x|(cid:126)z))
would not tell us about how much of the data is
being explained by the learned vector vs. the lan-
Instead, for this part of the qual-
guage model.
itative evaluation, we sample from the Gaussian
prior, but use a greedy deterministic decoder for x,

input
mean
samp. 1
samp. 2
samp. 3

we looked out at the setting sun .
they were laughing at the same time .
ill see you in the early morning .
i looked up at the blue sky .
it was down on the dance ﬂoor .

i went to the kitchen .
i went to the kitchen .
i went to my apartment .
i looked around the room .
i turned back to the table .

how are you doing ?
what are you doing ?
“ are you sure ?
what are you doing ?
what are you doing ?

Table 7: Three sentences which were used as inputs to the vae, presented with greedy decodes from the
mean of the posterior distribution, and from three samples from that distribution.

“ i want to talk to you . ”
“i want to be with you . ”
“i do n’t want to be with you . ”
i do n’t want to be with you .
she did n’t want to be with him .

he was silent for a long moment .
he was silent for a moment .
it was quiet for a moment .
it was dark and cold .
there was a pause .
it was my turn .

Table 8: Paths between pairs of random points in
vae space: Note that intermediate sentences are
grammatical, and that topic and syntactic struc-
ture are usually locally consistent.

ments). Here we see that the sentences are far less
typical, but for the most part are grammatical and
maintain a clear topic, indicating that the latent
variable is capturing a rich variety of global fea-
tures even for rare sentences.

6.2 Sampling from the posterior

In addition to generating unconditional samples,
we can also examine the sentences decoded from
the posterior vectors p(z|x) for various sentences
x. Because the model is regularized to produce dis-
tributions rather than deterministic codes, it does
not exactly memorize and round-trip the input. In-
stead, we can see what the model considers to be
similar sentences by examining the posterior sam-
ples in Table 7. The codes appear to capture in-
formation about the number of tokens and parts
of speech for each token, as well as topic informa-
tion. As the sentences get longer, the ﬁdelity of
the round-tripped sentences decreases.

6.3 Homotopies

The use of a variational autoencoder allows us to
generate sentences using greedy decoding on con-
tinuous samples from the space of codes. Addi-
tionally, the volume-ﬁlling and smooth nature of
the code space allows us to examine for the ﬁrst
time a concept of homotopy (linear interpolation)
between sentences. In this context, a homotopy be-
tween two codes (cid:126)z1 and (cid:126)z2 is the set of points on the
line between them, inclusive, (cid:126)z(t) = (cid:126)z1∗(1−t)+(cid:126)z2∗t
for t ∈ [0, 1]. Similarly, the homotopy between two

sentences decoded (greedily) from codes (cid:126)z1 and (cid:126)z2
is the set of sentences decoded from the codes on
the line. Examining these homotopies allows us to
get a sense of what neighborhoods in code space
look like – how the autoencoder organizes infor-
mation and what it regards as a continuous defor-
mation between two sentences.

While a standard non-variational rnnlm does
not have a way to perform these homotopies, a
vanilla sequence autoencoder can do so. As men-
tioned earlier in the paper, if we examine the ho-
motopies created by the sequence autoencoder in
Table 1, though, we can see that the transition be-
tween sentences is sharp, and results in ungram-
matical intermediate sentences. This gives evi-
dence for our intuition that the vae learns repre-
sentations that are smooth and “ﬁll up” the space.
In Table 8 (and in additional tables in the ap-
pendix) we can see that the codes mostly contain
syntactic information, such as the number of words
and the parts of speech of tokens, and that all in-
termediate sentences are grammatical. Some topic
information also remains consistent in neighbor-
hoods along the path. Additionally, sentences with
similar syntax and topic but ﬂipped sentiment va-
lence, e.g. “the pain was unbearable” vs. “the
thought made me smile”, can have similar embed-
dings, a phenomenon which has been observed with
single-word embeddings (for example the vectors
for “bad” and “good” are often very similar due to
their similar distributional characteristics).

7 Conclusion

This paper introduces the use of a variational
autoencoder for natural language sentences. We
present novel techniques that allow us to train
our model successfully, and ﬁnd that it can eﬀec-
tively impute missing words. We analyze the la-
tent space learned by our model, and ﬁnd that it
is able to generate coherent and diverse sentences
through purely continuous sampling and provides
interpretable homotopies that smoothly interpo-
late between sentences.

We hope in future work to investigate factoriza-
tion of the latent variable into separate style and
content components, to generate sentences condi-
tioned on extrinsic features, to learn sentence em-
beddings in a semi-supervised fashion for language

understanding tasks like textual entailment, and to
go beyond adversarial evaluation to a fully adver-
sarial training objective.

Sepp Hochreiter and J¨urgen Schmidhuber. 1997.
Long short-term memory. Neural computation
9(8).

References

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua
Bengio. 2015. Neural machine translation by
jointly learning to align and translate. In Proc.
ICLR.

Justin Bayer and Christian Osendorfer. 2015.
Learning stochastic recurrent networks. arXiv
preprint arXiv:1411.7610 .

Julian Besag. 1986. On the statistical analysis of
dirty pictures. Journal of the Royal Statistical
Society Series B (Methodological) pages 48–259.

Junyoung Chung, Kyle Kastner, Laurent Dinh,
Kratarth Goel, Aaron Courville, and Yoshua
Bengio. 2015. A recurrent latent variable model
for sequential data. In Proc. NIPS .

Andrew M. Dai and Quoc V. Le. 2015. Semi-
supervised sequence learning. In Proc. NIPS .

Emily Denton, Soumith Chintala, Arthur Szlam,
and Rob Fergus. 2015. Deep generative image
models using a laplacian pyramid of adversarial
networks. In Proc. NIPS .

Bill Dolan, Chris Quirk, and Chris Brockett.
2004. Unsupervised construction of large para-
phrase corpora: Exploiting massively parallel
news sources. In Proceedings of the 20th interna-
tional conference on Computational Linguistics.
Association for Computational Linguistics, page
350.

Jeﬀ Donahue, Lisa Anne Hendricks, Sergio
Guadarrama, Marcus Rohrbach, Subhashini
Venugopalan, Kate Saenko, and Trevor Darrell.
2015. Long-term recurrent convolutional net-
works for visual recognition and description. In
Proc. CVPR.

Otto Fabius and Joost R. van Amersfoort. 2014.
arXiv

Variational recurrent auto-encoders.
preprint arXiv:1412.6581.

Ian Goodfellow, Jean Pouget-Abadie, Mehdi
Mirza, Bing Xu, David Warde-Farley, Sherjil
Ozair, Aaron Courville, and Yoshua Bengio.
2014. Generative adversarial nets.
In Proc.
NIPS .

Karol Gregor, Ivo Danihelka, Alex Graves, and
Daan Wierstra. 2015. DRAW: A recurrent neu-
ral network for image generation.
In Proc.
ICML.

Mohit Iyyer, Varun Manjunatha, Jordan Boyd-
Graber, and Hal Daum´e III. 2015. Deep un-
ordered composition rivals syntactic methods for
text classiﬁcation. In Proc. ACL.

Michael Kearns, Yishay Mansour, and Andrew Y
Ng. 1998. An information-theoretic analysis of
hard and soft assignment methods for clustering.
In Learning in graphical models, Springer, pages
495–520.

Yoon Kim. 2014. Convolutional neural networks

for sentence classiﬁcation. EMNLP .

Diederik P. Kingma and Max Welling. 2015. Auto-
encoding variational bayes. In Proc. ICLR.

Ryan Kiros, Yukun Zhu, Ruslan Salakhutdinov,
Richard S Zemel, Antonio Torralba, Raquel Ur-
tasun, and Sanja Fidler. 2015. Skip-thought vec-
tors. arXiv preprint arXiv:1506.06726.

Ankit Kumar, Ozan Irsoy, Jonathan Su, James
Bradbury, Robert English, Brian Pierce, Pe-
ter Ondruska, Ishaan Gulrajani, and Richard
Socher. 2015. Ask me anything: Dynamic mem-
ory networks for natural language processing.
arXiv preprint arXiv:1506.07285.

Quoc V. Le and Tom´aˇs Mikolov. 2014. Distributed
representations of sentences and documents. In
Proc. ICML.

Jiwei Li, Minh-Thang Luong, and Dan Jurafsky.
2015a. A hierarchical neural autoencoder for
paragraphs and documents. In Proc. ACL.

Xin Li and Dan Roth. 2002. Learning question
classiﬁers.
In Proceedings of the 19th interna-
tional conference on Computational linguistics-
Volume 1 . Association for Computational Lin-
guistics, pages 1–7.

Yujia Li, Kevin Swersky, and Richard Zemel.
2015b. Generative moment matching networks.
In Proc. ICML.

Junhua Mao, Wei Xu, Yi Yang, Jiang Wang, Zhi-
heng Huang, and Alan Yuille. 2015. Deep cap-
tioning with multimodal recurrent neural net-
works (m-RNN). In Proc. ICLR.

Mitchell P Marcus, Mary Ann Marcinkiewicz, and
Beatrice Santorini. 1993. Building a large an-
notated corpus of English: The Penn Treebank.
Computational linguistics 19(2):313–330.

Yishu Miao, Lei Yu, and Phil Blunsom. 2015.
Neural variational inference for text processing.
arXiv preprint arXiv:1511.06038 .

Arthur Gretton, Karsten M Borgwardt, Malte J
Rasch, Bernhard Sch¨olkopf, and Alexander
Smola. 2012. A kernel two-sample test. JMLR
13(1):723–773.

Tom´aˇs Mikolov, Stefan Kombrink, Luk´aˇs Burget,
Jan Honza ˇCernock`y, and Sanjeev Khudanpur.
2011. Extensions of recurrent neural network
language model. In Proc. ICASSP .

Tapani Raiko, Mathias Berglund, Guillaume
Alain, and Laurent Dinh. 2015. Techniques
for learning binary stochastic feedforward neu-
ral networks. In Proc. ICLR.

Danilo J. Rezende and Shakir Mohamed. 2015.
Variational inference with normalizing ﬂows. In
Proc. ICML.

Danilo J. Rezende, Shakir Mohamed, and Daan
Wierstra. 2014. Stochastic backpropagation and
approximate inference in deep generative mod-
els. In Proc. ICML.

Jasper Snoek, Hugo Larochelle, and Ryan P.
Adams. 2012. Practical Bayesian optimization
of machine learning algorithms. In Proc. NIPS .

Richard Socher, Eric H Huang, Jeﬀrey Pennin,
Christopher D Manning, and Andrew Y Ng.
2011. Dynamic pooling and unfolding recur-
sive autoencoders for paraphrase detection. In
Advances in Neural Information Processing Sys-
tems. pages 801–809.

Nitish

Ilya

Srivastava, Geoﬀrey Hinton,

Alex
and Ruslan
Krizhevsky,
Salakhutdinov. 2014.
Dropout: A simple
way to prevent neural networks from overﬁtting.
JMLR 15(1):1929–1958.

Sutskever,

Rupesh Kumar Srivastava, Klaus Greﬀ, and
J¨urgen Schmidhuber. 2015. Training very deep
networks. In Proc. NIPS .

Ilya Sutskever, Oriol Vinyals, and Quoc V. Le.
2014. Sequence to sequence learning with neural
networks. In Proc. NIPS .

Lucas Theis and Matthias Bethge. 2015. Gener-
ative image modeling using spatial LSTMs. In
Proc. NIPS .

Oriol Vinyals, Alexander Toshev, Samy Bengio,
and Dumitru Erhan. 2015. Show and tell: A
neural image caption generator. In Proc. CVPR.

Han Zhao, Zhengdong Lu, and Pascal Poupart.
2015. Self-adaptive hierarchical sentence model.
IJCAI .

Text classiﬁcation

In order to further examine the the structure of the
representations discovered by the vae, we conduct
classiﬁcation experiments on paraphrase detection
and question type classiﬁcation. We train a vae
with a hidden state size of 1200 hidden units on
the Books Corpus, and use the posterior mean of
the model as the extracted sentence vector. We
train classiﬁers on these means using the same ex-
perimental protocol as Kiros et al. (2015).

Method

Accuracy

Feats
rae+dp
rae+feats
rae+dp+feats
st
Bi-st
Combine-st
vae
vae+feats
vae+combine-st
Feats+combine-st
vae+combine-st+feats

73.2
72.6
74.2
76.8

73.0
71.2
73.0

72.9
75.0
74.8
75.8
76.9

F1

–
–
–
83.6

81.9
81.2
82.0

81.4
82.4
82.3
83.0
83.8

Table 9: Results for the msr Paraphrase Corpus.

Paraphrase detection For the task of para-
phrase detection, we use the Microsoft Research
Paraphrase Corpus (Dolan et al., 2004). We com-
pute features from the sentence vectors of sentence
pairs in the same way as Kiros et al. (2015), con-
catenating the elementwise products and the abso-
lute value of the elementwise diﬀerences of the two
vectors. We train an (cid:96)2-regularized logistic regres-
sion classiﬁer and tune the regularization strength
using cross-validation.

We present results in Table 9 and compare to
several previous models for this task. Feats is the
lexicalized baseline from Socher et al. (2011). rae
uses the recursive autoencoder from that work, and
dp adds their dynamic pooling step to calculate
pairwise features. st uses features from the uni-
directional skip-thought model, bi-st uses bidirec-
tional skip-thought, and combine-st uses the con-
catenation of those features. We also experimented
with concatenating lexical features and the two
types of distributed features.

We found that our features performed slightly
worse than skip-thought features by themselves
and slightly better than recursive autoencoder fea-
tures, and were complementary and yielded strong
performance when simply concatenated with the
skip-thought features.

Question classiﬁcation We also conduct ex-
periments on the TREC Question Classiﬁcation
dataset of Li and Roth (2002). Following Kiros
et al. (2015), we train an (cid:96)2-regularized softmax
classiﬁer with 10-fold cross-validation to set the
regularization. Note that using a linear classiﬁer
like this one may disadvantage our representations
here, since the Gaussian distribution over hidden
codes in a vae is likely to discourage linear sepa-
rability.

We present results in Table 10. Here, ae is
a plain sequence autoencoder. We compare with
results from a bag of word vectors (cbow, Zhao
et al., 2015) and skip-thought (st). We also com-

Method
st
Bi-st
Combine-st
AE
vae
cbow
vae, combine-st
rnn
cnn

Accuracy

91.4
89.4
92.2
84.2
87.0
87.3
92.0

90.2
93.6

Table 10: Results for TREC Question Classiﬁca-
tion.

pare with an rnn classiﬁer (Zhao et al., 2015) and
a cnn classiﬁer (Kim, 2014) both of which, un-
like our model, are optimized end-to-end. We were
not able to make the vae codes perform better
than cbow in this case, but they did outperform
features from the sequence autoencoder.
Skip-
thought performed quite well, possibly because the
skip-thought training objective of next sentence
prediction is well aligned to this task:
it essen-
tially trains the model to generate sentences that
address implicit open questions from the narrative
of the book. Combining the two representations
did not give any additional performance gain over
the base skip-thought model.

Hyperparameter tuning

We extensively tune the hyperparameters of each
model using an automatic Bayesian hyperparame-
ter tuning algorithm (based on Snoek et al., 2012)
over development set data. We run the model with
each set of hyperpameters for 10 hours, operating
12 experiments in parallel, and choose the best set
of hyperparameters after 200 runs. Results for our
language modeling experiments are reported in Ta-
ble 11 on the next page.

Additional homotopies

Table 12, on the next page, shows additional homo-
topies from our model. We observe that intermedi-
ate sentences are almost always grammatical, and
often contain consistent topic, vocabulary and syn-
tactic information in local neighborhoods as they
interpolate between the endpoint sentences. Be-
cause the model is trained on ﬁction, including ro-
mance novels, the topics are often rather dramatic.

Standard
rnnlm vae

Inputless Decoder
vae
rnnlm

Embedding dim.
lstm state dim.
z dim.
Word dropout keep rate

464
337
–
0.66

353
191
13
0.62

305
68
–
–

499
350
111
–

Table 11: Automatically selected hyperparameter values used for the models used in the Penn Treebank
language modeling experiments.

amazing , is n’t it ?
so , what is it ?
it hurts , isnt it ?
why would you do that ?
“ you can do it .
“ i can do it .
i ca n’t do it .
“ i can do it .
“ do n’t do it .
“ i can do it .
i could n’t do it .

no .
he said .
“ no , ” he said .
“ no , ” i said .
“ i know , ” she said .
“ thank you , ” she said .
“ come with me , ” she said .
“ talk to me , ” she said .
“ do n’t worry about it , ” she said .

i dont like it , he said .
i waited for what had happened .
it was almost thirty years ago .
it was over thirty years ago .
that was six years ago .
he had died two years ago .
ten , thirty years ago .
“ it ’s all right here .
“ everything is all right here .
“ it ’s all right here .
it ’s all right here .
we are all right here .
come here in ﬁve minutes .

this was the only way .
it was the only way .
it was her turn to blink .
it was hard to tell .
it was time to move on .
he had to do it again .
they all looked at each other .
they all turned to look back .
they both turned to face him .
they both turned and walked away .

there is no one else in the world .
there is no one else in sight .
they were the only ones who mattered .
they were the only ones left .
he had to be with me .
she had to be with him .
i had to do this .
i wanted to kill him .
i started to cry .
i turned to him .

im ﬁne .
youre right .
“ all right .
you ’re right .
okay , ﬁne .
“ okay , ﬁne .
yes , right here .
no , not right now .
“ no , not right now .
“ talk to me right now .
please talk to me right now .
i ’ll talk to you right now .
“ i ’ll talk to you right now .
“ you need to talk to me now .
“ but you need to talk to me now .

Table 12: Selected homotopies between pairs of random points in the latent vae space.

