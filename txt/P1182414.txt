Gaussian Mixture Latent Vector Grammars

Yanpeng Zhao, Liwen Zhang, Kewei Tu
School of Information Science and Technology,
ShanghaiTech University, Shanghai, China
{zhaoyp1,zhanglw1,tukw}@shanghaitech.edu.cn

8
1
0
2
 
y
a
M
 
2
1
 
 
]
L
C
.
s
c
[
 
 
1
v
8
8
6
4
0
.
5
0
8
1
:
v
i
X
r
a

Abstract

We introduce Latent Vector Grammars
(LVeGs), a new framework that extends la-
tent variable grammars such that each non-
terminal symbol is associated with a con-
tinuous vector space representing the set
of (inﬁnitely many) subtypes of the non-
terminal. We show that previous models
such as latent variable grammars and com-
positional vector grammars can be inter-
preted as special cases of LVeGs. We then
present Gaussian Mixture LVeGs (GM-
LVeGs), a new special case of LVeGs that
uses Gaussian mixtures to formulate the
weights of production rules over subtypes
of nonterminals. A major advantage of us-
ing Gaussian mixtures is that the partition
function and the expectations of subtype
rules can be computed using an extension
of the inside-outside algorithm, which en-
ables efﬁcient inference and learning. We
apply GM-LVeGs to part-of-speech tag-
ging and constituency parsing and show
that GM-LVeGs can achieve competitive
accuracies.
Our code is available at
https://github.com/zhaoyanpeng/lveg.

1

Introduction

In constituency parsing, reﬁning coarse syntactic
categories of treebank grammars (Charniak, 1996)
into ﬁne-grained subtypes has been proven effec-
tive in improving parsing results. Previous ap-
proaches to reﬁning syntactic categories use tree
annotations (Johnson, 1998), lexicalization (Char-
niak, 2000; Collins, 2003), or linguistically mo-
tivated category splitting (Klein and Manning,
2003). Matsuzaki et al. (2005) introduce latent
variable grammars, in which each syntactic cate-
gory (represented by a nonterminal) is split into

a ﬁxed number of subtypes and a discrete latent
variable is used to indicate the subtype of the
nonterminal when it appears in a speciﬁc parse
tree. Since the latent variables are not observ-
able in treebanks, the grammar is learned using
expectation-maximization. Petrov et al. (2006)
present a split-merge approach to learning la-
tent variable grammars, which hierarchically splits
each nonterminal and merges ineffective splits.
Petrov and Klein (2008b) further allow a nonter-
minal to have different splits in different produc-
tion rules, which results in a more compact gram-
mar.

Recently, neural approaches become very pop-
ular in natural language processing (NLP). An im-
portant technique in neural approaches to NLP
is to represent discrete symbols such as words
and syntactic categories with continuous vectors
Since the distances between
or embeddings.
such vector representations often reﬂect the sim-
ilarity between the corresponding symbols, this
technique facilitates more informed smoothing in
learning functions of symbols (e.g., the probability
of a production rule). In addition, what a symbol
represents may subtly depend on its context, and a
continuous vector representation has the potential
of representing each instance of the symbol in a
more precise manner. For constituency parsing,
recursive neural networks (Socher et al., 2011)
and their extensions such as compositional vector
grammars (Socher et al., 2013) can be seen as rep-
resenting nonterminals in a context-free grammar
with continuous vectors. However, exact inference
in these models is intractable.

In this paper, we introduce latent vector gram-
mars (LVeGs), a novel framework of grammars
with ﬁne-grained nonterminal subtypes. A LVeG
associates each nonterminal with a continuous
vector space that represents the set of (inﬁnitely
many) subtypes of the nonterminal. For each in-

stance of a nonterminal that appears in a parse
tree, its subtype is represented by a latent vector.
For each production rule over nonterminals, a non-
negative continuous function speciﬁes the weight
of any ﬁne-grained production rule over subtypes
of the nonterminals. Compared with latent vari-
able grammars which assume a small ﬁxed num-
ber of subtypes for each nonterminal, LVeGs as-
sume an unlimited number of subtypes and are
potentially more expressive. By having weight
functions of varying smoothness for different pro-
duction rules, LVeGs can also control the level
of subtype granularity for different productions,
which has been shown to improve the parsing ac-
curacy (Petrov and Klein, 2008b).
In addition,
similarity between subtypes of a nonterminal can
be naturally modeled by the distance between the
corresponding vectors, so by using continuous and
smooth weight functions we can ensure that simi-
lar subtypes will have similar syntactic behaviors.

We further present Gaussian Mixture LVeGs
(GM-LVeGs), a special case of LVeGs that uses
mixtures of Gaussian distributions as the weight
functions of ﬁne-grained production rules. A ma-
jor advantage of GM-LVeGs is that the partition
function and the expectations of ﬁne-grained pro-
duction rules can be computed using an extension
of the inside-outside algorithm. This makes it pos-
sible to efﬁciently compute the gradients during
discriminative learning of GM-LVeGs. We evalu-
ate GM-LVeGs on part-of-speech tagging and con-
stituency parsing on a variety of languages and
corpora and show that GM-LVeGs achieve com-
petitive results.

It shall be noted that many modern state-of-
the-art constituency parsers predict how likely a
constituent is based on not only local information
(such as the production rules used in composing
the constituent), but also contextual information
of the constituent. For example, the neural CRF
parser (Durrett and Klein, 2015) looks at the words
before and after the constituent; and RNNG (Dyer
et al., 2016) looks at the constituents that are al-
ready predicted (in the stack) and the words that
In this paper,
are not processed (in the buffer).
however, we choose to focus on the basic frame-
work and algorithms of LVeGs and leave the in-
corporation of contextual information for future
work. We believe that by laying a solid foundation
for LVeGs, our work can pave the way for many
interesting extensions of LVeGs in the future.

2 Latent Vector Grammars

A latent vector grammar (LVeG) considers sub-
types of nonterminals as continuous vectors and
associates each nonterminal with a latent vector
space representing the set of its subtypes. For each
production rule, the LVeG deﬁnes a weight func-
tion over the subtypes of the nonterminal involved
in the production rule. In this way, it models the
space of reﬁnements of the production rule.

2.1 Model Deﬁnition

A latent vector grammar is deﬁned as a 5-tuple
G = (N, S, Σ, R, W ), where N is a ﬁnite set of
nonterminal symbols, S ∈ N is the start sym-
bol, Σ is a ﬁnite set of terminal symbols such that
N ∩Σ = ∅, R is a set production rules of the form
γ where X ∈ N and γ ∈ (N ∪ Σ)∗, W is a
X
set of rule weight functions indexed by production
rules in R (to be deﬁned below). In the following
discussion, we consider R in the Chomsky normal
form (CNF) for clarity of presentation. However,
it is straightforward to extend our formulation to
the general case.

(cid:1)

(cid:1)

(cid:1)

Unless otherwise speciﬁed, we always use cap-
ital letters A, B, C, . . . for nonterminal symbols
and use bold lowercase letters a, b, c, . . . for their
subtypes. Note that subtypes are represented
by continuous vectors.
For a production rule
of the form A
BC, its weight function is
BC(a, b, c). For a production rule of the
WA
(cid:1)
w where w ∈ Σ, its weight func-
form A
(cid:1)
tion is WA
w(a). The weight functions should
be non-negative, continuous and smooth, and
hence ﬁne-grained production rules of similar sub-
types of a nonterminal would have similar weight
assignments. Rule weights can be normalized
such that (cid:80)
BC(a, b, c)dbdc = 1,
(cid:1)
which leads to a probabilistic context-free gram-
mar (PCFG). Whether the weights are normalized
or not leads to different model classes and accord-
ingly different estimation methods. However, the
two model classes are proven equivalent by Smith
and Johnson (2007).

b,c WA

B,C

(cid:82)

2.2 Relation to Other Models

Latent variable grammars (LVGs)
(Matsuzaki
et al., 2005; Petrov et al., 2006) associate
each nonterminal with a discrete latent vari-
able, which is used to indicate the subtype
of the nonterminal when it appears in a parse
Through nonterminal-splitting and the
tree.

expectation-maximization algorithm, ﬁne-grained
production rules can be automatically induced
from a treebank.

(cid:1)

BC.

We show that LVGs can be seen as a special case
of LVeGs. Speciﬁcally, we can use one-hot vec-
tors in LVeGs to represent latent variables in LVGs
and deﬁne weight functions in LVeGs accordingly.
Consider a production rule r : A
In a
LVG, each nonterminal is split into a number of
subtypes. Suppose A, B, and C are split into nA,
nB, and nC subtypes respectively. ax is the x-th
subtype of A, by is the y-th subtype of B, and cz
bycz is a ﬁne-
is the z-th subtype of C. ax
grained production rule of A
BC, where x =
1, . . . , nA, y = 1, . . . , nB, and z = 1, . . . , nC.
The probabilities of all the ﬁne-grained produc-
tion rules can be represented by a rank-3 tensor
BC ∈ RnA×nB×nC . To cast the LVG as a
ΘA
(cid:1)
LVeG, we require that the latent vectors in the
LVeG must be one-hot vectors. We achieve this by
deﬁning weight functions that output zero if any
of the input vectors is not one-hot. Speciﬁcally,
we deﬁne the weight function of the production
rule A

BC as:

(cid:1)

(cid:1)

(cid:1)
Wr(a, b, c) =

(cid:88)

x,y,z

(cid:1)

ΘA

BCcba × (δ(a − ax)

× δ(b − by) × δ(c − cz)) ,

(1)

where δ(·) is the Dirac delta function, ax ∈ RnA,
by ∈ RnB , cz ∈ RnC are one-hot vectors (which
are zero everywhere with the exception of a single
1 at the x-th index of ax, the y-th index of by,
and the z-th index of cz) and ΘA
BC is multiplied
sequentially by c, b, and a.

(cid:1)

Compared with LVGs, LVeGs have the follow-
ing advantages. While a LVG contains a ﬁnite,
typically small number of subtypes for each non-
terminal, a LVeG uses a continuous space to rep-
resent an inﬁnite number of subtypes. When
equipped with weight functions of sufﬁcient com-
plexity, LVeGs can represent more ﬁne-grained
syntactic categories and production rules than
LVGs. By controlling the complexity and smooth-
ness of the weight functions, a LVeG is also ca-
pable of representing any level of subtype gran-
ularity. Importantly, this allows us to change the
level of subtype granularity for the same nonter-
minal in different production rules, which is sim-
ilar to multi-scale grammars (Petrov and Klein,
2008b). In addition, with a continuous space of
subtypes in a LVeG, similarity between subtypes

can be naturally modeled by their distance in the
space and can be automatically learned from data.
Consequently, with continuous and smooth weight
functions, ﬁne-grained production rules over simi-
lar subtypes would have similar weights in LVeGs,
eliminating the need for the extra smoothing steps
that are necessary in training LVGs.

vector

grammars

Compositional

(CVGs)
(Socher et al., 2013), an extension of recursive
neural networks (RNNs) (Socher et al., 2011),
can also be seen as a special case of LVeGs.
For a production rule r : A
BC, a CVG can
be interpreted as specifying its weight function
Wr(a, b, c) in the following way. First, a neural
network f indexed by B and C is used to compute
a parent vector p = fBC(b, c). Next, the score of
the parent vector is computed using a base PCFG
and a vector vBC:

(cid:1)

s(p) = vT

BCp + log P (A

BC) ,

(cid:1)
where P (A
BC) is the rule probability from
the base PCFG. Then, the weight function of the
production rule A

BC is deﬁned as:

(cid:1)

(2)

(cid:1)

Wr(a, b, c) = exp (s(p)) × δ(a − p) .

(3)

This form of weight functions in CVGs leads
to point estimation of latent vectors in a parse
tree, i.e., for each nonterminal in a given parse
tree, only one subtype in the whole subtype space
would lead to a non-zero weight of the parse. In
addition, different parse trees of the same sub-
string typically lead to different point estimations
of the subtype vector at the root nonterminal. Con-
sequently, CVGs cannot use dynamic program-
ming for inference and hence have to resort to
greedy search or beam search.

3 Gaussian Mixture LVeGs

A major challenge in applying LVeGs to parsing is
that it is impossible to enumerate the inﬁnite num-
ber of subtypes. Previous work such as CVGs re-
sorts to point estimation and greedy search. In this
section we present Gaussian Mixture LVeGs (GM-
LVeGs), which use mixtures of Gaussian distribu-
tions as the weight functions in LVeGs. Because
Gaussian mixtures have the nice property of being
closed under product, summation, and marginal-
ization, we can compute the partition function and
the expectations of ﬁne-grained production rules
using dynamic programming. This in turn makes
efﬁcient learning and parsing possible.

3.1 Representation

In a GM-LVeG, the weight function of a produc-
tion rule r is deﬁned as a Gaussian mixture con-
taining Kr mixture components:

Wr(r) =

ρr,k N (r|µr,k, Σr,k) ,

(4)

Kr(cid:88)

k=1

where r is the concatenation of the latent vectors
of the nonterminals in r, which denotes a ﬁne-
grained production rule of r. ρr,k > 0 is the k-th
mixture weight (the mixture weights do not nec-
essarily sum up to 1), N (r|µr,k, Σr,k) is the k-th
Gaussian distribution parameterized by mean µr,k
and covariance matrix Σr,k, and Kr is the num-
ber of mixture components, which can be differ-
ent for different production rules. Below we write
N (r|µr,k, Σr,k) as Nr,k(r) for brevity. Given a
production rule of the form A
BC, the GM-
LVeG expects r = [a; b; c] and a, b, c ∈ Rd,
where d is the dimension of the vectors a, b, c. We
use the same dimension for all the subtype vectors.
For the sake of computational efﬁciency, we
use diagonal or spherical Gaussian distributions,
whose covariance matrices are diagonal, so that
the inverse of covariance matrices in Equation 15–
16 can be computed in linear time. A spherical
Gaussian has a diagonal covariance matrix where
all the diagonal elements are equal, so it has fewer
free parameters than a diagonal Gaussian and re-
sults in faster learning and parsing. We empiri-
cally ﬁnd that spherical Gaussians lead to slightly
better balance between the efﬁciency and the pars-
ing accuracy than diagonal Gaussians.

(cid:1)

3.2 Parsing

The goal of parsing is to ﬁnd the most probable
parse tree T ∗ with unreﬁned nonterminals for a
sentence w of n words w1:n = w1 . . . wn. This
is formally deﬁned as:

T ∗ = argmax
T ∈G(w)

P (T |w) ,

(5)

where G(w) denotes the set of parse trees with
unreﬁned nonterminals for w. In a PCFG, T ∗ can
be found using dynamic programming such as the
CYK algorithm. However, parsing becomes in-
tractable with LVeGs, and even with LVGs, the
special case of LVeGs.

A common practice in parsing with LVGs is to
use max-rule parsing (Petrov et al., 2006; Petrov

and Klein, 2007). The basic idea of max-rule
parsing is to decompose the posteriors over parses
into the posteriors over production rules approx-
imately. This requires calculating the expected
counts of unreﬁned production rules in parsing
the input sentence. Since Gaussian mixtures are
closed under product, summation, and marginal-
ization, in GM-LVeGs the expected counts can be
calculated using the inside-outside algorithm in
the following way. Given a sentence w1:n, we
ﬁrst calculate the inside score sA
I (a, i, j) and out-
side score sA
O(a, i, j) for a nonterminal A over a
span wi:j using Equation 6 and Equation 7 in Ta-
ble 1 respectively. Note that both sA
I (a, i, j) and
sA
O(a, i, j) are mixtures of Gaussian distributions
of the subtype vector a. Next, using Equation 8 in
BC, i, k, j)
Table 1, we calculate the score s(A
BC, i, k, j(cid:105)
(1 ≤ i ≤ k < j ≤ n), where (cid:104)A
represents a production rule A
BC with nonter-
minals A, B, and C spanning words wi:j, wi,k, and
wk+1:j respectively in the sentence w1:n. Then the
expected count (or posterior) of (cid:104)A
BC, i, k, j(cid:105)
is calculated as:

(cid:1)
(cid:1)

(cid:1)

(cid:1)

q(A

BC, i, k, j) =

(cid:1)

s(A

BC, i, k, j)

(cid:1)
sI(S, 1, n)

,

(9)

where sI(S, 1, n) is the inside score for the start
symbol S spanning the whole sentence w1:n. Af-
ter calculating all the expected counts, we can use
the MAX-RULE-PRODUCT algorithm (Petrov and
Klein, 2007) for parsing, which returns a parse
with the highest probability that all the production
rules are correct. Its objective function is given by

T ∗
q = argmax
T ∈G(w)

(cid:89)

e∈T

q(e) ,

(10)

e

(cid:1)

all

the

ranges

where
over
4-tuples
BC, i, k, j(cid:105) in the parse tree T .
(cid:104)A
This
objective function can be efﬁciently solved
by dynamic programming such as the CYK
algorithm.

Although the time complexity of the inside-
outside algorithm with GM-LVeGs is polynomial
in the sentence length and the nonterminal num-
ber, in practice the algorithm is still slow because
the number of Gaussian components in the inside
and outside scores increases dramatically with the
recursion depth. To speed up the computation, we
prune Gaussian components in the inside and out-
side scores using the following technique. Sup-
pose we have a minimum pruning threshold kmin

sA
I (a, i, j) =

sA
O(a, i, j) =

+

(cid:90) (cid:90)

(cid:90) (cid:90)

(cid:90) (cid:90)

(cid:80)
BC∈R

(cid:80)
k=i,··· ,j−1

(cid:80)
CA∈R

(cid:80)
k=1,··· ,i−1

(cid:80)
AC∈R

(cid:80)
k=j+1,··· ,n

A

(cid:1)

B

(cid:1)

B

(cid:1)

(cid:90) (cid:90) (cid:90)

(cid:1)

(cid:1)

WA

BC(a, b, c) × sB
(cid:1)

I (b, i, k) × sC

I (c, k + 1, j) dbdc .(6)

WB

CA(b, c, a) × sB

O(b, k, j) × sC

I (c, k, i − 1) dbdc

WB

AC(b, a, c) × sB

O(b, i, k) × sC

I (c, j + 1, k) dbdc .(7)

s(A

BC, i, k, j) =

(cid:1)

WA

BC(a, b, c) × sA
(cid:1)

O(a, i, j) × sB

I (b, i, k) × sC

I (c, k + 1, j) dadbdc .(8)

Table 1: Equation 6: sA
i < j ≤ n. Equation 7: sA
1 ≤ i ≤ j ≤ n. Equation 8: s(A
spanning words wi:j, wi,k, and wk+1:j respectively in the sentence w1:n, where 1 ≤ i ≤ k < j ≤ n.

I (a, i, j) is the inside score of a nonterminal A over a span wi:j in the sentence w1:n, where 1 ≤
O (a, i, j) is the outside score of a nonterminal A over a span wi:j in the sentence w1:n, where
BC with nonterminals A, B, and C

BC, i, k, j) is the score of a production rule A

(cid:1)

(cid:1)

and a maximum pruning threshold kmax. Given
an inside or outside score with kc Gaussian com-
ponents, if kc ≤ kmin, then we do not prune
any Gaussian component; otherwise, we compute
kallow = min{kmin + ﬂoor(kϑ
c ), kmax} (0 ≤ ϑ ≤
1 is a constant) and keep only kallow components
with the largest mixture weights.

In addition to component pruning, we also em-
ploy two constituent pruning techniques to reduce
the search space during parsing. The ﬁrst tech-
nique is used by Petrov et al. (2006). Before
parsing a sentence with a GM-LVeG, we run the
inside-outside algorithm with the treebank gram-
mar and calculate the posterior probability of ev-
ery nonterminal spanning every substring. Then
a nonterminal would be pruned from a span if
its posterior probability is below a pre-speciﬁed
threshold pmin. When parsing with GM-LVeGs,
we only consider the unpruned nonterminals for
each span.

The second constituent pruning technique is
similar to the one used by Socher et al. (2013).
Note that for a strong constituency parser such as
the Berkeley parser (Petrov and Klein, 2007), the
constituents in the top 200 best parses of a sen-
tence can cover almost all the constituents in the
gold parse tree. So we ﬁrst use an existing con-
stituency parser to run k-best parsing with k =
200 on the input sentence. Then we parse with a
GM-LVeG and only consider the constituents that
appear in the top 200 parses. Note that this method
is different from the re-ranking technique because
it may produce a parse different from the top 200
parses.

3.3 Learning

Given a training dataset D = {(Ti, wi) | i =
1, . . . , m} containing m samples, where Ti is the
gold parse tree with unreﬁned nonterminals for the
sentence wi, the objective of discriminative learn-
ing is to minimize the negative log conditional
likelihood:

L(Θ) = − log

P (Ti|wi; Θ) ,

(11)

m
(cid:89)

i=1

where Θ represents the set of parameters of the
GM-LVeG.

We optimize the objective function using the
Adam (Kingma and Ba, 2014) optimization algo-
rithm. The derivative with respect to Θr, the pa-
rameters of the weight function Wr(r) of an un-
reﬁned production rule r, is calculated as follows
(the derivation is in the supplementary material):

∂L(Θ)
∂Θr

=

m
(cid:88)

(cid:90) (cid:18) ∂Wr(r)

∂Θr

i=1
EP (t|wi)[fr(t)] − EP (t|Ti)[fr(t)]
Wr(r)

(cid:19)

×

(12)

dr ,

where t indicates a parse tree with nonterminal
subtypes, and fr(t) is the number of occurrences
of the unreﬁned rule r in the unreﬁned parse tree
that is obtained by replacing all the subtypes in t
with the corresponding nonterminals. The two ex-
pectations in Equation 12 can be efﬁciently com-
puted using the inside-outside algorithm. Because
the second expectation is conditioned on the parse
tree Ti, in Equation 6 and Equation 7 we can skip
all the summations and assign the values of B, C,
and k according to Ti.

In GM-LVeGs, Θr is the set of parameters in a

Gaussian mixture:

Θr = {(ρr,k, µr,k, Σr,k)|k = 1, . . . , Kr} .

(13)

According to Equation 12, we need to take the
derivatives of Wr(r) respect to ρr,k, µr,k, and Σr,k
respectively:

its potential advantage over previous special cases.
It is therefore not our goal to compete with the
latest state-of-the-art approaches to tagging and
parsing. In particular, we currently do not incor-
porate contextual information of words and con-
stituents during tagging and parsing, while such
information is critical in achieving state-of-the-art
accuracy. We will discuss future improvements of
LVeGs in Section 5.

∂Wr(r)/∂ρr,k = Nr,k(r) ,
∂Wr(r)/∂µr,k = ρr,kNr,k(r)Σ−1

(14)
r,k(r − µr,k) ,(15)

4.1 Datasets

∂Wr(r)/∂Σr,k = ρr,kNr,k(r)Σ−1
r,k

(cid:16)

1
2

− I

(16)
(cid:17)

.

+ (r − µr,k)(r − µr,k)T Σ−1
r,k

Substituting Equation 14–16 into Equation 12, we
have the full gradient formulations of all the pa-
rameters. In spite of the integral in Equation 12,
we can derive a closed-form solution for the gradi-
ent of each parameter, which is shown in the sup-
plementary material.

In order to keep each mixture weight ρr,k posi-
tive, we do not directly optimize ρr,k; instead, we
set ρr,k = exp(θρr,k ) and optimize θρr,k by gradi-
ent descent. We use a similar trick to keep each
covariance matrix Σr,k positive deﬁnite.

Since we use the inside-outside algorithm de-
scribed in Section 3.2 to calculate the two ex-
pectations in Equation 12, we face the same ef-
ﬁciency problem that we encounter in parsing. To
speed up the computation,we again use both com-
ponent pruning and constituent pruning introduced
in Section 3.2.

Because gradient descent is often sensitive to
the initial values of the parameters, we employ the
following informed initialization method. Mixture
weights are initialized using the treebank gram-
mar. Suppose in the treebank grammar P (r) is
the probability of a production rule r. We initial-
ize the mixture weights in the weight function Wr
by ρr,k = α · P (r) where α > 1 is a constant.
We initialize all the covariance matrices to iden-
tity matrices and initialize each mean with a value
uniformly sampled from [−0.05, 0.05].

4 Experiment

We evaluate the GM-LVeG on part-of-speech
(POS) tagging and constituency parsing and com-
pare it against its special cases such as LVGs and
CVGs. It shall be noted that in this paper we focus
on the basic framework of LVeGs and aim to show

Parsing. We use the Wall Street Journal corpus
from the Penn English Treebank (WSJ) (Marcus
et al., 1994). Following the standard data splitting,
we use sections 2 to 21 for training, section 23 for
testing, and section 22 for development. We pre-
process the treebank using a right-branching bina-
rization procedure to obtain an unannotated X-bar
grammar, so that there are only binary and unary
production rules. To deal with the problem of un-
known words in testing, we adopt the unknown
word features used in the Berkeley parser and set
the unknown word threshold to 1. Speciﬁcally, any
word occurring less than two times is replaced by
one of the 60 unknown word categories.
Tagging. (1) We use Wall Street Journal corpus
from the Penn English Treebank (WSJ) (Marcus
et al., 1994). Following the standard data split-
ting, we use sections 0 to 18 for training, sections
22 to 24 for testing, and sections 19 to 21 for de-
velopment. (2) The Universal Dependencies tree-
bank 1.4 (UD) (Nivre et al., 2016), in which En-
glish, French, German, Russian, Spanish, Indone-
sian, Finnish, and Italian treebanks are used. We
use the original data splitting of these corpora for
training and testing. For both WSJ and UD En-
glish treebanks, we deal with unknown words in
the same way as we do in parsing. For the rest of
the data, we use only one unknown word category
and the unknown word threshold is also set to 1.

4.2 POS Tagging

POS tagging is the task of labeling each word in
a sentence with the most probable part-of-speech
tag. Here we focus on POS tagging with Hidden
Markov Models (HMMs). Because HMMs are
equivalent to probabilistic regular grammars, we
can extend HMMs with both LVGs and LVeGs.
Speciﬁcally, the hidden states in HMMs can be
seen as nonterminals in regular grammars and
therefore can be associated with latent variables
or latent vectors.

(LVG-G)

We implement two training methods for LVGs.
is generative training us-
The ﬁrst
ing expectation-maximization that maximizes the
joint probability of the sentence and the tags. The
second (LVG-D) is discriminative training using
gradient descent that maximizes the conditional
probability of the tags given the sentence. In both
cases, each nonterminal is split into a ﬁxed num-
ber of subtypes. In our experiments we test 1, 2,
4, 8, and 16 subtypes of each nonterminal. Due
to the limited space, we only report experimental
results of LVG with 16 subtypes for each nonter-
minal. Full experimental results can be found in
the supplementary material.

We experiment with two different GM-LVeGs:
GM-LVeG-D with diagonal Gaussians and GM-
LVeG-S with spherical Gaussians. In both cases,
we ﬁx the number of Gaussian components Kr to
4 and the dimension of the latent vectors d to 3.
We do not use any pruning techniques in learning
and inference because we ﬁnd that our algorithm
is fast enough with the current setting of Kr and
d. We train the GM-LVeGs for 20 epoches and se-
lect the models with the best token accuracy on the
development data for the ﬁnal testing.

We report both token accuracy and sentence ac-
curacy of POS tagging in Table 2. It can be seen
that, on all the testing data, GM-LVeGs consis-
tently surpass LVGs in terms of both token ac-
curacy and sentence accuracy. GM-LVeG-D is
slightly better than GM-LVeG-S in sentence ac-
curacy, producing the best sentence accuracy on
5 of the 9 testing datasets. GM-LVeG-S performs
slightly better than GM-LVeG-D in token accuracy
on 5 of the 9 datasets. Overall, there is not sig-
niﬁcant difference between GM-LVeG-D and GM-
LVeG-S. However, GM-LVeG-S admits more efﬁ-
cient learning than GM-LVeG-D in practice since
it has fewer parameters.

4.3 Parsing

For efﬁciency, we train GM-LVeGs only on sen-
tences with no more than 50 words (totally 39115
sentences). Since we have found that spherical
Gaussians are better than diagonal Gaussians con-
sidering both model performance and learning ef-
ﬁciency, here we use spherical Gaussians in the
weight functions. The dimension of latent vectors
d is set to 3, and all the Gaussian mixtures have
Kr = 4 components. We use α = 8 in initializing
mixture weights. We train the GM-LVeG for 15

epoches and select the model with the highest F1
score on the development data for the ﬁnal testing.
We use component pruning in both learning and
parsing, with kmax = 50 and ϑ = 0.35 in both
learning and parsing, kmin = 40 in learning and
kmin = 20 in parsing. During learning we use the
ﬁrst constituent pruning technique with the prun-
ing threshold pmin = 1e − 5, and during parsing
we use the second constituent pruning technique
based on the Berkeley parser which produced 133
parses on average for each testing sentence. As
can be seen, we use weaker pruning during train-
ing than during testing. This is because in training
stronger pruning (even if accurate) results in worse
estimation of the ﬁrst expectation in Equation 12,
which makes gradient computation less accurate.

We compare LVeGs with CVGs and several
variants of LVGs: (1) LVG-G-16 and LVG-D-16,
which are LVGs with 16 subtypes for each nonter-
minal with discriminative and generative training
respectively (accuracies obtained from Petrov and
Klein (2008a)); (2) Multi-scale grammars (Petrov
trained without using the
and Klein, 2008b),
span features in order for a fair comparison; (3)
Berkeley parser (Petrov and Klein, 2007) (accura-
cies obtained from Petrov and Klein (2008b) be-
cause Petrov and Klein (2007) do not report exact
match scores). The experimental results are shown
in Table 3. It can be seen that GM-LVeG-S pro-
duces the best F1 scores on both the development
data and the testing data. It surpasses the Berkeley
parser by 0.92% in F1 score on the testing data.
Its exact match score on the testing data is only
slightly lower than that of LVG-D-16.

We further investigate the inﬂuence of the la-
tent vector dimension and the Gaussian compo-
nent number on the efﬁciency and the parsing ac-
curacy . We experiment on a small dataset (statis-
tics of this dataset are in the supplemental mate-
rial). We ﬁrst ﬁx the component number to 4 and
experiment with the dimension 2, 3, 4, 5, 6, 7, 8,
9. Then we ﬁx the dimension to 3 and experiment
with the component number 2, 3, 4, 5, 6, 7, 8, 9.
F1 scores on the development data are shown in
the ﬁrst row in Figure 1. Average time consumed
per epoch in learning is shown in the second row
in Figure 1. When Kr = 4, the best dimension is
5; when d = 3, the best Gaussian component num-
ber is 3. A higher dimension or a larger Gaussian
component number hurts the model performance
and requires much more time for learning. Thus

Model

WSJ

English

French

German

Russian

Spanish

Indonesian

Finnish

Italian

T

S

T

S

T

S

T

S

T

S

T

S

T

S

T

S

T

S

LVG-D-16
LVG-G-16

96.62 48.74 92.31 52.67 93.75 34.90 87.38 20.98 81.91 12.25 92.47 24.82 89.27 20.29 83.81 19.29 94.81 45.19
96.78 50.88 93.30 57.54 94.52 34.90 88.92 24.05 84.03 16.63 93.21 27.37 90.09 21.19 85.01 20.53 95.46 48.26

GM-LVeG-D 96.99 53.10 93.66 59.46 94.73 39.60 89.11 24.77 84.21 17.84 93.76 32.48 90.24 21.72 85.27 23.30 95.61 50.72
GM-LVeG-S 97.00 53.11 93.55 58.11 94.74 39.26 89.14 25.58 84.06 18.44 93.52 30.66 90.12 21.72 85.35 22.07 95.62 49.69

Table 2: Token accuracy (T) and sentence accuracy (S) for POS tagging on the testing data.

Model

LVG-G-16
LVG-D-16
Multi-Scale
Berkeley Parser
CVG (SU-RNN)

GM-LVeG-S

dev (all)

test ≤ 40

test (all)

F1

F1

EX

F1

EX

88.70 35.80
89.30 39.40
37.20
89.20
90.10 37.10
90.40

89.70 39.60
90.60
39.10
91.10

91.38

41.51

91.02

39.24

91.20

91.24

Table 3: Parsing accuracy on the testing data of WSJ. EX
indicates the exact match score.

our choice of Kr = 4 and d = 3 in GM-LVeGs for
parsing is a good balance between the efﬁciency
and the parsing accuracy.

Figure 1: F1 score and average time (min) consumed per
epoch in learning. Left: # of Gaussian components ﬁxed to
4 with different dimensions; Right: dimension of Gaussians
ﬁxed to 3 with different # of Gaussian components.

5 Discussion

It shall be noted that in this paper we choose to
focus on the basic framework and algorithms of
LVeGs, and therefore we leave a few important
extensions for future work. One extension is to
incorporate contextual information of words and
constituents. which is a crucial technique that can
be found in most state-of-the-art approaches to
parsing or POS tagging. One possible way to uti-

lize contextual information in LVeGs is to allow
the words in the context of an anchored produc-
tion rule to inﬂuence the rule’s weight function.
For example, we may learn neural networks to pre-
dict the parameters of the Gaussian mixture weight
functions in a GM-LVeG from the pre-trained em-
beddings of the words in the context.

In GM-LVeGs, we currently use the same num-
ber of Gaussian components for all the weight
functions. A more desirable way would be au-
tomatically determining the number of Gaussian
components for each production rule based on the
ideal reﬁnement granularity of the rule, e.g., we
may need more Gaussian components for NP
(cid:1)
DT NN than for NP
DT JJ, since the latter is
rarely used. There are a few possible ways to learn
the component numbers such as greedy addition
and removal, the split-merge method, and sparsity
priors over mixture weights.

(cid:1)

An interesting extension beyond LVeGs is to
have a single continuous space for subtypes of all
the nonterminals.
Ideally, subtypes of the same
nonterminal or similar nonterminals are close to
each other. The beneﬁt is that similarity between
nonterminals can now be modeled.

6 Conclusion

We present Latent Vector Grammars (LVeGs) that
associate each nonterminal with a latent continu-
ous vector space representing the set of subtypes
of the nonterminal. For each production rule, a
LVeG deﬁnes a continuous weight function over
the subtypes of the nonterminals involved in the
rule. We show that LVeGs can subsume latent vari-
able grammars and compositional vector gram-
mars as special cases. We then propose Gaus-
sian mixture LVeGs (GM-LVeGs). which formu-
late weight functions of production rules by mix-
tures of Gaussian distributions. The partition func-
tion and the expectations of ﬁne-grained produc-
tion rules in GM-LVeGs can be efﬁciently com-
puted using dynamic programming, which makes
learning and inference with GM-LVeGs feasible.

We empirically show that GM-LVeGs can achieve
competitive accuracies on POS tagging and con-
stituency parsing.

Acknowledgments

This work was supported by the National Natu-
ral Science Foundation of China (61503248), Ma-
jor Program of Science and Technology Com-
mission Shanghai Municipal (17JC1404102), and
Program of Shanghai Subject Chief Scientist (A
type) (No.15XD1502900). We would like to thank
the anonymous reviewers for their careful reading
and useful comments.

References

Eugene Charniak. 1996. Tree-bank grammars. In Pro-
ceedings of the 30th National Conference on Artiﬁ-
cial Intelligence, volume 2, pages 1031–1036.

Eugene Charniak. 2000. A maximum-entropy-inspired
In Proceedings of the 1st Meeting of the
parser.
North American Chapter of
the Association for
Computational Linguistics, pages 132–139. Associ-
ation for Computational Linguistics.

Michael Collins. 2003. Head-driven statistical mod-
els for natural language parsing. Computational lin-
guistics, 29(4):589–637.

Greg Durrett and Dan Klein. 2015. Neural CRF pars-
In Proceedings of the 53rd Annual Meeting
ing.
of the Association for Computational Linguistics,
pages 302–312. Association for Computational Lin-
guistics.

Chris Dyer, Adhiguna Kuncoro, Miguel Ballesteros,
and Noah A Smith. 2016. Recurrent neural network
grammars. In Proceedings of the 2016 Conference
of the North American Chapter of the Association
for Computational Linguistics: Human Language
Technologies, pages 199–209. Association for Com-
putational Linguistics.

Mark Johnson. 1998.

PCFG models of linguistic
tree representations. Computational Linguistics,
24(4):613–632.

Diederik P Kingma and Jimmy Ba. 2014. Adam: A
method for stochastic optimization. arXiv preprint
arXiv:1412.6980.

Dan Klein and Christopher D Manning. 2003. Accu-
In Proceedings of the
rate unlexicalized parsing.
41st annual meeting on Association for Computa-
tional Linguistics, pages 423–430. Association for
Computational Linguistics.

Mitchell Marcus,

Grace Kim, Mary Ann
Marcinkiewicz, Robert MacIntyre, Ann Bies,

The penn treebank:

Mark Ferguson, Karen Katz, and Britta Schas-
annotating
berger. 1994.
In Proceedings of
predicate argument structure.
the workshop on Human Language Technology,
pages 114–119. Association for Computational
Linguistics.

Takuya Matsuzaki, Yusuke Miyao, and Jun’ichi Tsujii.
2005. Probabilistic CFG with latent annotations. In
Proceedings of the 43rd annual meeting on Associ-
ation for Computational Linguistics, pages 75–82.
Association for Computational Linguistics.

Joakim Nivre, Marie-Catherine de Marneffe, Filip
Ginter, Yoav Goldberg, Jan Hajic, Christopher D.
Manning, Ryan T. McDonald, Slav Petrov, Sampo
Pyysalo, Natalia Silveira, Reut Tsarfaty, and Daniel
Zeman. 2016. Universal dependencies v1: A mul-
In Proceedings of
tilingual treebank collection.
the 10th International Conference on Language Re-
sources and Evaluation, pages 1659–1666.

Slav Petrov, Leon Barrett, Romain Thibaux, and Dan
Klein. 2006. Learning accurate, compact, and in-
In Proceedings of the
terpretable tree annotation.
44th annual meeting of the Association for Compu-
tational Linguistics, pages 433–440. Association for
Computational Linguistics.

Slav Petrov and Dan Klein. 2007.

Improved infer-
ence for unlexicalized parsing. In Proceedings of the
2007 Conference of the North American Chapter of
the Association for Computational Linguistics: Hu-
man Language Technologies, pages 404–411. Asso-
ciation for Computational Linguistics.

Slav Petrov and Dan Klein. 2008a. Discriminative log-
linear grammars with latent variables. In Advances
in Neural Information Processing Systems 20, pages
1153–1160.

Slav Petrov and Dan Klein. 2008b. Sparse multi-scale
grammars for discriminative latent variable parsing.
In Proceedings of the 2008 Conference on Empiri-
cal Methods in Natural Language Processing, pages
867–876. Association for Computational Linguis-
tics.

Noah A Smith and Mark Johnson. 2007. Weighted
and probabilistic context-free grammars are equally
expressive. Computational Linguistics, 33(4):477–
491.

Richard Socher, John Bauer, Christopher D Manning,
et al. 2013. Parsing with compositional vector gram-
mars. In Proceedings of the 51st Annual Meeting of
the Association for Computational Linguistics, vol-
ume 1, pages 455–465. Association for Computa-
tional Linguistics.

Richard Socher, Cliff C Lin, Chris Manning, and An-
drew Y Ng. 2011. Parsing natural scenes and nat-
ural language with recursive neural networks.
In
Proceedings of the 28th International Conference on
Machine Learning, pages 129–136.

Supplementary Material

Abstract

where t ∼ w indicates that t is a parse tree of w
with nonterminal subtypes. Thus the conditional
probability density of t given T is

A Derivation of Gradient Formulations

Therefore, we rewrite Equation 17 as

This supplementary material contains the follow-
(1) The derivation of the gradi-
ing contents.
ent formulation (Equation 12 in the paper).
(2)
The general idea of calculating analytic gradients
for all the parameters in Gaussian Mixture Latent
Vector Grammars (GM-LVeGs). (3) Algorithmic
complexity and running time. (4) Statistics of the
data used for part-of-speech (POS) tagging and
constituency parsing. (5) Additional experimental
results and analysis of GM-LVeGs.

Given a training dataset D = {(Ti, wi) | i =
1, . . . , m} containing m samples, we minimize the
negative log conditional likelihood during learning
of GM-LVeGs:

L(Θ) = − log

P (Ti|wi; Θ) ,

(17)

m
(cid:89)

i=1

where Ti is the gold parse tree with unreﬁned non-
terminals for the sentence wi, and Θ is the set of
parameters in GM-LVeGs.

We deﬁne t as a parse tree with nonterminal
subtypes, denote by fr(t) the number of occur-
rences of the unreﬁned rule r in the unreﬁned
parse tree that is obtained by replacing all the sub-
types in t with the corresponding nonterminals,
and use r to represent a ﬁne-grained production
rule of r, which is represented by the concatena-
tion of the latent vectors of the nonterminals in r.

The weight of t is deﬁned as:

st =

Wr(r) .

(18)

sT =

st dt ,

(19)

where t ∼ T indicates that t is a parse tree with
nonterminal subtypes that can be converted into a
parse tree T by replacing its nonterminal subtypes
with the corresponding nonterminals. The weight
of a sentence w is deﬁned as:

sw =

st dt ,

(20)

(cid:90)

t∼w

(cid:89)

r∈t

(cid:90)

t∼T

the conditional probability density of t given w is

(21)

(22)

st
sT

,

st
sw

,

P (t|T ) =

P (t|w) =

(cid:90)

=

sT
sw

t∼T

and the conditional probability of T given w is

P (T |w) =

P (t|w) dt .

(23)

L(Θ) = −

log

P (t|wi) dt .

(24)

m
(cid:88)

i=1

(cid:90)

t∼Ti

The derivative of L(Θ) with respect to Θr, where
r is an unreﬁned production rule, is calculated by
Equation 25 in Table 4.

B Calculation of Analytic Gradients

In GM-LVeGs, Θr is the set of parameters in a
Gaussian mixture with Kr mixture components:

Θr = {(ρr,k, µr,k, Σr,k)|k = 1, . . . , Kr} .

(29)

According to Equation 25 in Table 4, we need
to take derivatives of Wr(r) with respect to ρr,k,
µr,k, and Σr,k respectively:

∂Wr(r)/∂ρr,k = Nr,k(r) ,
∂Wr(r)/∂µr,k = ρr,kNr,k(r)Σ−1

(30)
r,k(r − µr,k) ,(31)

∂Wr(r)/∂Σr,k = ρr,kNr,k(r)Σ−1
r,k

(cid:16)

1
2

− I

(32)
(cid:17)

.

+ (r − µr,k)(r − µr,k)T Σ−1
r,k

ψ(r) =

EP (t|wi)[fr(t)] − EP (t|Ti)[fr(t)]
Wr(r)

.

(33)

Substituting Equations 30–32 into Equation 25,
we have the full gradient formulations of all the
parameters (Equations 26–28 in Table 4).

In the following discussion, we assume that all
the Gaussians are diagonal. It can be veriﬁed that
ψ(r) in Equation 33 is in fact a mixture of Gaus-
sians, so multiplying ψ(r) by Nr,k(r) in Equa-
tion 26–28 results in another mixture of Gaus-
sians. Below we consider the special case where

The weight of T , a parse tree with unreﬁned non-
terminals, is deﬁned as:

For brevity, we deﬁne

L(cid:48)(Θ) = −

(P (t|wi))(cid:48)

P (t(cid:48)|wi) dt(cid:48) dt

(cid:82)
t(cid:48)∼Ti

t∼Ti

m
(cid:88)

(cid:90)

i=1
m
(cid:88)

(cid:90)

i=1
m
(cid:88)

(cid:90)

i=1
m
(cid:88)

(cid:90)

i=1
m
(cid:88)

(cid:90)

= −

= −

(P (t|wi))(cid:48)

P (t|wi)
P (t|wi)

dt

P (t(cid:48)|wi) dt(cid:48) ×
P (t|wi)
P (t(cid:48)|wi) dt(cid:48) × (log P (t|wi))(cid:48) dt

(cid:82)
t(cid:48)∼Ti

t∼Ti

(cid:82)
t(cid:48)∼Ti

t∼Ti

= −

P (t|Ti) ×

log

(cid:82)

t∼Ti

(cid:32)

(cid:32)

(cid:81)

r∈t Wr(r)
(cid:81)
r∈t(cid:48) Wr(r) dt(cid:48)
(cid:90)

t(cid:48)∼wi

(cid:33)(cid:48)

dt

(cid:89)

r∈t(cid:48)
(cid:90)

t(cid:48)∼wi
(cid:32)

(cid:33)(cid:48)

(cid:89)

r∈t

(cid:32)

(cid:88)

r∈t

= −

P (t|Ti) ×

log

Wr(r) − log

t∼Ti
(cid:32)(cid:90)

t∼Ti

(cid:32)(cid:90)

i=1

m
(cid:88)

i=1
m
(cid:88)

= −

P (t|Ti)

log Wr(r)

dt −

log

= −

= −

(cid:88)

P (t|Ti)

W (cid:48)
r(r)
Wr(r)

(cid:90)

dt −

t(cid:48)∼wi

P (t(cid:48)|wi)

i=1
m
(cid:88)

(cid:90)

i=1

r

t∼Ti
r∈t
EP (t|Ti)[fr(t)] − EP (t|wi)[fr(t)]
Wr(r)

(cid:48)

× W

r(r) dr .

(cid:33)(cid:48)

Wr(r) dt(cid:48)

dt

(cid:33)(cid:48)(cid:33)

(cid:89)

Wr(r) dt(cid:48)

t(cid:48)∼wi

(cid:88)

r∈t(cid:48)

r∈t(cid:48)
W (cid:48)
r(r)
Wr(r)

(cid:33)

dt(cid:48)

ψ(r) · Nr,k(r) dr .

ψ(r) · Nr,k(r) · ρr,kΣ−1

r,k(r − µr,k) dr .

∂L(Θ)
∂ρr,k

∂L(Θ)
∂µr,k

∂L(Θ)
∂Σr,k

=

=

=

m
(cid:88)

(cid:90)

i=1
m
(cid:88)

(cid:90)

i=1
m
(cid:88)

(cid:90)

i=1

r

r

r

ψ(r) · Nr,k(r) · ρr,kΣ−1
r,k

(r − µr,k)(r − µr,k)T Σ−1

r,k − I

dr .

(28)

2

Table 4: Derivation of gradient formulations.

(25)

(26)

(27)

the resulting Gaussian mixture contains only a sin-
gle component:

readily calculated as
(cid:90)

ψ(r) · Nr,k(r) = λ · N (r) .

(34)

Owing to the sum rule in integral, we can easily
extend our derivation on the special case to the
general case in which the Gaussian mixture con-
tains multiple components. Because N (r) is diag-
onal, it can be factorized as:

λ ·

N (r) dr = λ .

(36)

For Equation 27, consider taking the derivative
with respect to the mean in dimension d. Since the
means in different dimensions are independent, to
solve the integral in Equation 27, we only need to
solve the following integral:

(cid:90)

λ ·

N (r)rd dr1 . . . dr|r|

N (r) = N (r1) × · · · × N (r|r|) ,

(35)

= λ ·

N (r1) dr1 × · · · ×

N (rd)rd drd

(cid:90)

where N (r1), . . . , N (r|r|) are univariate Gaus-
sians (or normal distributions), rd (1 ≤ d ≤ |r|)
refers to the d-th element of r, and |r| is the di-
mension of r. The integral in Equation 26 can be

× . . . ×

N (r|r|) dr|r|

= λ ·

N (rd)rd drd .

(37)

(cid:90)

(cid:90)

(cid:90)

For Equation 28, when taking the derivative with
respect to the variance in dimension d, we also
need to solve Equation 37 and additionally need
to solve the following integral:

(cid:90)

λ ·

N (r)rdrd dr1 . . . dr|r|

= λ ·

N (r1) dr1 × · · · ×

N (rd)rdrd drd

(cid:90)

(cid:90)

(cid:90)

(cid:90)

× . . . ×

N (r|r|) dr|r|

= λ ·

N (rd)rdrd drd .

(38)

The integrals in Equation 37 and Equation 38
are the ﬁrst order moment and the second order
moment of the univariate Gaussian N (rd) respec-
tively, and both of them can be calculated exactly.
Therefore, we can calculate analytic gradients of
all the parameters in GM-LVeGs.

C Algorithmic Complexity and Running

Time

The time complexity of the learning algorithm
for each sentence in each epoch is approximately
O(cn3kmd + cklmd2). The ﬁrst term is the time
complexity of the extended inside-outside algo-
rithm, where c is the number of binary productions
in CNF, n is the length of the sentence, k is the
Gaussian component number of each rule weight
function, m is the maximum Gaussian component
number of an inside or outside score after prun-
ing, and d is the dimension of diagonal Gaussians.
kmd is generally much smaller than cn3. It shall
be noted that m is bounded by kmax, which is set
to 50 in our experiments. The second term is the
approximate time complexity of gradient calcula-
tion, where l is the number of times that a pro-
duction rule is used in all possible parses of a sen-
tence. The second term is much smaller than the
ﬁrst term in general.

We run our learning and inference algorithms
with a CPU cluster without any GPU. In our POS
tagging experiments, GM-LVeGs are only slightly
slower than the baseline LVG models, and we
can perform all the tagging experiments on all the
datasets with our model within one day. For pars-
ing, there is a trade-off between running time and
parsing accuracy based on the amount of prun-
ing. For the best parsing accuracy of GM-LVeGs,
it takes two weeks for training. However, once
we complete training, parsing can be done within
three minutes on the whole testing data of WSJ.

There are a few ways to improve the training
efﬁciency. We currently use CPU parallelization
at the sentence level in training, but in the future
we may take the advantage of GPU parallelization,
e.g., we can vectorize the inside-outside algorithm
for a batch of sentences of the same length. Be-
sides, for each long sentence, we can parallelize
the inside or outside computation at the same re-
cursive depth.

D Data Statistics

Dataset

# of tokens

WSJ

950028

train

39832

test

2416

dev

1700

# of sentences

Table 5: Statistics of WSJ used for constituency parsing.

Statistics of the data used for constituency pars-
ing are shown in Table 5. Statistics of the data used
for POS tagging are summarized in Table 6.
In
the experiments of constituency parsing, in order
to study the inﬂuence of the dimension of Gaus-
sians and the number of Gaussian components on
the parsing accuracy, we experimented on a small
dataset. The small dataset only contains section 4
and section 5 of WSJ. In the two sections, we use
ﬁle IDs from 80-89 in the two sections are used
for testing, 90-99 for development, and the rest
are used for training. The resulting dataset con-
tains 3599 training samples, 426 test samples, and
375 development samples.

E Additional Experimental Results

The complete experimental results of POS tagging
are shown in Table 7.
In addition to the results
shown in the paper, this table includes the tagging
results of LVGs with 1, 2, 4, 8 subtypes for each
nonterminal.

In the experiments of constituency parsing, in
order to investigate the impact of the maximum
Gaussian component number of inside and out-
side scores, we experiment with a new prun-
ing technique. Speciﬁcally, we use a maximum
component-pruning threshold khard. We do not
prune any Gaussian component if an inside or
outside score has no more than khard Gaussian
components; otherwise we keep only khard Gaus-
sian components with the largest mixture weights.
We experiment on the small dataset mentioned
in Section D. For efﬁciency, we train GM-LVeG-
D only on sentences of no more than 20 words

WSJ

English

French

German

Russian

Spanish

Indonesian

Finnish

Italian

# of tokens
train
dev
test

1173766
38219
5462
5527

254830
12543
2002
2077

402197
14554
1596
298

298242
14118
799
977

99389
4029
502
499

431587
14187
1552
274

121923
4477
559
557

181022
12217
716
648

292471
12837
489
489

Table 6: Statistics of WSJ and UD (English, French, German, Russian, Spanish, Indonesian, Finnish, and Italian treebanks).
Numbers in the rows of train, test, and dev indicate the number of sentences in training, testing, and development data respec-
tively.

Model

LVG-D-1
LVG-D-2
LVG-D-4
LVG-D-8
LVG-D-16

LVG-G-1
LVG-G-2
LVG-G-4
LVG-G-8
LVG-G-16

WSJ

English

French

German

Russian

Spanish

Indonesian

Finnish

Italian

T

S

T

S

T

S

T

S

T

S

T

S

T

S

T

S

T

S

96.50 48.04 91.80 50.79 93.55 30.20 86.52 16.99 81.21 9.24 91.79 22.63 89.08 18.85 83.15 16.82 94.00 37.42
96.57 47.60 92.17 52.05 93.86 33.56 86.93 18.32 81.46 10.04 92.10 24.82 89.16 19.21 83.34 18.52 94.45 40.90
96.57 48.76 92.30 52.34 93.96 34.90 87.18 19.86 81.95 11.85 92.37 24.82 89.28 19.57 83.76 18.83 94.60 42.54
96.60 49.14 92.31 53.06 93.78 34.90 87.52 21.60 81.54 11.25 92.26 23.72 89.23 19.39 83.68 18.67 94.70 42.95
96.62 48.74 92.31 52.67 93.75 34.90 87.38 20.98 81.91 12.25 92.47 24.82 89.27 20.29 83.81 19.29 94.81 45.19

96.11 43.68 90.84 44.92 92.69 26.51 86.71 17.40 81.22 10.22 91.85 22.63 88.93 18.31 82.94 16.36 93.64 33.74
96.27 45.57 92.11 51.37 93.28 28.19 87.87 19.86 81.51 11.45 92.29 23.36 89.19 18.49 83.29 17.44 94.20 38.45
96.50 48.19 92.90 54.31 94.06 32.55 88.31 20.78 82.64 11.85 92.58 24.45 89.58 19.03 83.76 19.44 95.00 45.40
96.76 50.38 93.29 56.67 94.57 37.25 88.75 21.70 82.85 14.86 92.95 29.20 89.78 20.29 84.69 21.76 95.42 46.83
96.78 50.88 93.30 57.54 94.52 34.90 88.92 24.05 84.03 16.63 93.21 27.37 90.09 21.19 85.01 20.53 95.46 48.26

GM-LVeG-D 96.99 53.10 93.66 59.46 94.73 39.60 89.11 24.77 84.21 17.84 93.76 32.48 90.24 21.72 85.27 23.30 95.61 50.72
GM-LVeG-S 97.00 53.11 93.55 58.11 94.74 39.26 89.14 25.58 84.06 18.44 93.52 30.66 90.12 21.72 85.35 22.07 95.62 49.69

Table 7: Token accuracy (T) and sentence accuracy (S) for POS tagging on the testing data. The numerical postﬁx of each LVG
model indicates the number of nonterminal subtypes, and hence LVG-G-1 denotes HMM.

and test GM-LVeG-D only on testing sentences
of no more than 25 words. We experiment with
khard = 10, 20, 30, 40, 50, 60, 70, 80. The results
are shown in Figure 2. We also experiment with-
out component pruning, which corresponds to the
rightmost point in Figure 2.

We can see that a weaker component pruning or
a larger khard results in a better F1 score. How-
ever, it takes much more time per epoch for learn-
ing, as is shown in the lower ﬁgure in Figure 2.
We ﬁnd that khard = 40 produces a good F1 score
and also admits efﬁcient learning. Therefore, in
the experiments of constituency parsing, we use
kmin = 40 in learning for the component-pruning
technique introduced in Section 3.2 in the paper.

Figure 2: Upper: F1 scores with different khard; Lower:
time (min) per epoch in learning with different khard.

