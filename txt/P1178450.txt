Sequence-to-Action: End-to-End Semantic Graph Generation for
Semantic Parsing

Bo Chen†‡, Le Sun†, Xianpei Han†
†State Key Laboratory of Computer Science
Institute of Software, Chinese Academy of Sciences, Beijing, China
‡University of Chinese Academy of Sciences, Beijing, China
{chenbo,sunle,xianpei}@iscas.ac.cn

8
1
0
2
 
p
e
S
 
4
 
 
]
L
C
.
s
c
[
 
 
1
v
3
7
7
0
0
.
9
0
8
1
:
v
i
X
r
a

Abstract

This paper proposes a neural semantic
parsing approach – Sequence-to-Action,
which models semantic parsing as an end-
to-end semantic graph generation process.
Our method simultaneously leverages the
advantages from two recent promising di-
rections of semantic parsing. Firstly, our
model uses a semantic graph to represent
the meaning of a sentence, which has a
tight-coupling with knowledge bases. Sec-
ondly, by leveraging the powerful repre-
sentation learning and prediction ability
of neural network models, we propose a
RNN model which can effectively map
sentences to action sequences for seman-
tic graph generation. Experiments show
that our method achieves state-of-the-art
performance on OVERNIGHT dataset and
gets competitive performance on GEO and
ATIS datasets.

1

Introduction

lan-
Semantic parsing aims to map natural
guage sentences to logical
forms (Zelle and
Mooney, 1996; Zettlemoyer and Collins, 2005;
Wong and Mooney, 2007; Lu et al., 2008;
Kwiatkowski et al., 2013).
the
sentence “Which states border Texas?” will
be mapped to answer (A, (state (A),
next to (A, stateid ( texas )))).

For example,

A semantic parser needs two functions, one
for structure prediction and the other for seman-
tic grounding. Traditional semantic parsers are
usually based on compositional grammar, such as
CCG (Zettlemoyer and Collins, 2005, 2007), DCS
(Liang et al., 2011), etc. These parsers compose
structure using manually designed grammars, use
lexicons for semantic grounding, and exploit fea-

Figure 1: Overview of our method, with a demon-
stration example.

tures for candidate logical forms ranking. Un-
fortunately, it is challenging to design grammars
and learn accurate lexicons, especially in wide-
open domains. Moreover, it is often hard to design
effective features, and its learning process is not
end-to-end. To resolve the above problems, two
promising lines of work have been proposed: Se-
mantic graph-based methods and Seq2Seq meth-
ods.

Semantic graph-based methods (Reddy et al.,
2014, 2016; Bast and Haussmann, 2015; Yih et al.,
2015) represent the meaning of a sentence as a
semantic graph (i.e., a sub-graph of a knowledge
base, see example in Figure 1) and treat semantic
parsing as a semantic graph matching/generation
process. Compared with logical forms, seman-
tic graphs have a tight-coupling with knowledge
bases (Yih et al., 2015), and share many com-
monalities with syntactic structures (Reddy et al.,
2014). Therefore both the structure and seman-
tic constraints from knowledge bases can be eas-
ily exploited during parsing (Yih et al., 2015).
The main challenge of semantic graph-based pars-
ing is how to effectively construct the semantic
graph of a sentence. Currently, semantic graphs

are either constructed by matching with patterns
(Bast and Haussmann, 2015), transforming from
dependency tree (Reddy et al., 2014, 2016), or
via a staged heuristic search algorithm (Yih et al.,
2015). These methods are all based on manually-
designed, heuristic construction processes, mak-
ing them hard to handle open/complex situations.

In recent years, RNN models have achieved
success in sequence-to-sequence problems due to
its strong ability on both representation learning
and prediction, e.g., in machine translation (Cho
et al., 2014). A lot of Seq2Seq models have
also been employed for semantic parsing (Xiao
et al., 2016; Dong and Lapata, 2016; Jia and
Liang, 2016), where a sentence is parsed by trans-
lating it to linearized logical form using RNN
models. There is no need for high-quality lexi-
cons, manually-built grammars, and hand-crafted
features. These models are trained end-to-end,
and can leverage attention mechanism (Bahdanau
et al., 2014; Luong et al., 2015) to learn soft align-
ments between sentences and logical forms.

In this paper, we propose a new neural semantic
parsing framework – Sequence-to-Action, which
can simultaneously leverage the advantages of se-
mantic graph representation and the strong predic-
tion ability of Seq2Seq models. Speciﬁcally, we
model semantic parsing as an end-to-end semantic
graph generation process. For example in Figure
1, our model will parse the sentence “Which states
border Texas” by generating a sequence of ac-
tions [add variable:A, add type:state,
...]. To achieve the above goal, we ﬁrst design an
action set which can encode the generation process
of semantic graph (including node actions such
as add variable, add entity, add type,
edge actions such as add edge, and operation ac-
tions such as argmin, argmax, count, sum,
etc.). And then we design a RNN model which
can generate the action sequence for constructing
the semantic graph of a sentence. Finally we fur-
ther enhance parsing by incorporating both struc-
ture and semantic constraints during decoding.

Compared with the manually-designed, heuris-
tic generation algorithms used in traditional se-
mantic graph-based methods, our sequence-to-
action method generates semantic graphs using a
RNN model, which is learned end-to-end from
training data. Such a learnable, end-to-end gener-
ation makes our approach more effective and can
ﬁt to different situations.

Compared with the previous Seq2Seq seman-
tic parsing methods, our sequence-to-action model
predicts a sequence of semantic graph generation
actions, rather than linearized logical forms. We
ﬁnd that the action sequence encoding can better
capture structure and semantic information, and
is more compact. And the parsing can be en-
hanced by exploiting structure and semantic con-
straints. For example, in GEO dataset, the action
add edge:next to must subject to the seman-
tic constraint that its arguments must be of type
state and state, and the structure constraint
that the edge next to must connect two nodes to
form a valid graph.

We evaluate our approach on three standard
datasets: GEO (Zelle and Mooney, 1996), ATIS
(He and Young, 2005) and OVERNIGHT (Wang
et al., 2015b).
The results show that our
method achieves state-of-the-art performance on
OVERNIGHT dataset and gets competitive perfor-
mance on GEO and ATIS datasets.

The main contributions of this paper are sum-

marized as follows:

• We propose a new semantic parsing frame-
work – Sequence-to-Action, which models
semantic parsing as an end-to-end semantic
graph generation process. This new frame-
work can synthesize the advantages of se-
mantic graph representation and the predic-
tion ability of Seq2Seq models.

• We design a sequence-to-action model, in-
cluding an action set encoding for semantic
graph generation and a Seq2Seq RNN model
for action sequence prediction. We further
enhance the parsing by exploiting structure
and semantic constraints during decoding.
Experiments validate the effectiveness of our
method.

2 Sequence-to-Action Model for
End-to-End Semantic Graph
Generation

Given a sentence X = x1, ..., x|X|, our sequence-
to-action model generates a sequence of actions
Y = y1, ..., y|Y | for constructing the correct
semantic graph.
Figure 2 shows an example.
The conditional probability P (Y |X) used in our

Add Entity Node: This kind of actions denotes
adding an entity node (e.g., Texas, New York) and
is represented as add entity node:texas.
An entity node corresponds to an entity in knowl-
edge bases.

Add Type Node: This kind of actions denotes
adding a type node (e.g., state, city). We represent
them as add type node:state.

Add Edge: This kind of actions denotes adding
an edge between two nodes. An edge is a binary
relation in knowledge bases. This kind of actions
is represented as add edge:next to.

Operation Action: This kind of actions de-
notes adding an operation. An operation can be
argmax, argmin, count, sum, not, et al. Be-
cause each operation has a scope, we deﬁne two
actions for an operation, one is operation start ac-
tion, represented as start operation:most,
and the other is operation end action,
repre-
sented as end operation:most. The sub-
graph within the start and end operation actions
is its scope.

Argument Action: Some above actions need
argument information. For example, which nodes
the add edge:next to action should connect
to.
In this paper, we design argument actions
for add type, add edge and operation ac-
tions, and the argument actions should be put di-
rectly after its main action.

For add type actions, we put an argument ac-
tion to indicate which node this type node should
constrain. The argument can be a variable node
or an entity node. An argument action for a type
node is represented as arg:A.

For add edge action, we use two argu-
ment actions: arg1 node and arg2 node,
and they are represented as arg1 node:A and
arg2 node:B.

We design argument actions for different op-
For operation:sum,
there are
erations.
arg-for, arg-in and
three arguments:
arg-return. For operation:count, they
are arg-for and arg-return. There are two
arg-for arguments for operation:most.

We can see that each action encodes both struc-
ture and semantic information, which makes it
easy to capture more information for parsing and
can be tightly coupled with knowledge base. Fur-
thermore, we ﬁnd that action sequence encoding
is more compact than linearized logical form (See
Section 4.4 for more details).

Figure 2: An example of a sentence paired with its
semantic graph, together with the action sequence
for semantic graph generation.

model is decomposed as follows:

P (Y |X) =

P (yt|y<t, X)

(1)

|Y |
(cid:89)

t=1

where y<t = y1, ..., yt−1.

To achieve the above goal, we need: 1) an ac-
tion set which can encode semantic graph genera-
tion process; 2) an encoder which encodes natural
language input X into a vector representation, and
a decoder which generates y1, ..., y|Y | conditioned
on the encoding vector. In following we describe
them in detail.

2.1 Actions for Semantic Graph Generation

Generally, a semantic graph consists of nodes
(including variables, entities,
types) and edges
(semantic relations), with some universal opera-
tions (e.g., argmax, argmin, count, sum, and
not). To generate a semantic graph, we deﬁne six
types of actions as follows:

Add Variable Node: This kind of actions de-
notes adding a variable node to semantic graph. In
most cases a variable node is a return node (e.g.,
which, what), but can also be an intermediate vari-
able node. We represent this kind of action as
add variable:A, where A is the identiﬁer of
the variable node.

Figure 3: Our attention-based Sequence-to-Action
RNN model, with a controller for incorporating
constraints.

2.2 Neural Sequence-to-Action Model

Based on the above action encoding mechanism,
this section describes our encoder-decoder model
for mapping sentence to action sequence. Specif-
ically, similar to the RNN model
in Jia and
Liang (2016), this paper employs the attention-
based sequence-to-sequence RNN model. Figure
3 presents the overall structure.
Encoder: The encoder converts the input se-
quence x1, ..., xm to a sequence of context-
sensitive vectors b1, ..., bm using a bidirectional
RNN (Bahdanau et al., 2014). Firstly each word xi
is mapped to its embedding vector, then these vec-
tors are fed into a forward RNN and a backward
RNN. The sequence of hidden states h1, ..., hm are
generated by recurrently applying the recurrence:

hi = LST M (φ(x)(xi), hi−1).

(2)

The recurrence takes the form of LSTM (Hochre-
iter and Schmidhuber, 1997). Finally, for each in-
put position i, we deﬁne its context-sensitive em-
bedding as bi = [hF
i , hB
i ].
Decoder: This paper uses the classical attention-
based decoder (Bahdanau et al., 2014), which gen-
erates action sequence y1, ..., yn, one action at a
time. At each time step j, it writes yj based on
the current hidden state sj, then updates the hid-
den state to sj+1 based on sj and yj. The decoder
is formally deﬁned by the following equations:

s1 = tanh(W (s)[hF
j W (a)bi
eji = sT

m, hB

1 ])

aji =

exp(eji)
i(cid:48) =1 exp(eji(cid:48) )

(cid:80)m

cj =

ajibi

m
(cid:88)

i=1

P (yj = w|x, y1:j−1) ∝ exp(Uw[sj, cj])
sj+1 = LST M ([φ(y)(yj), cj], sj)

(3)

(4)

(5)

(6)

(7)

(8)

where the normalized attention scores aji deﬁnes
the probability distribution over input words, in-
dicating the attention probability on input word i
at time j; eji is un-normalized attention score. To
incorporate constraints during decoding, an extra
controller component is added and its details will
be described in Section 3.3.
Action Embedding. The above decoder needs
the embedding of each action. As described
above, each action has two parts, one for struc-
ture (e.g., add edge), and the other for se-
mantic (e.g., next to).
As a result, ac-
se-
tions may share the same structure or
mantic part, e.g., add edge:next to and
add edge:loc have the same structure part,
and add node:A and arg node:A have the
same semantic part. To make parameters more
compact, we ﬁrst embed the structure part and
the semantic part independently,
then concate-
nate them to get the ﬁnal embedding. For in-
stance, φ(y)(add edge:next to ) = [ φ(y)
strut(
add edge ), φ(y)
sem( next to )]. The action em-
beddings φ(y) are learned during training.

3 Constrained Semantic Parsing using

Sequence-to-Action Model

In this section, we describe how to build a neural
semantic parser using sequence-to-action model.
We ﬁrst describe the training and the inference of
our model, and then introduce how to incorporate
structure and semantic constraints during decod-
ing.

3.1 Training

Parameter Estimation. The parameters of our
model include RNN parameters W (s), W (a), Uw,
word embeddings φ(x), and action embeddings
φ(y). We estimate these parameters from training
data. Given a training example with a sentence X
and its action sequence Y , we maximize the like-
lihood of the generated sequence of actions given
X. The objective function is:

n
(cid:88)

i=1

log P (Yi|Xi)

(9)

Standard stochastic gradient descent algorithm is
employed to update parameters.
Logical Form to Action Sequence. Currently,
most datasets of semantic parsing are labeled with
In order to train our model, we
logical forms.

Figure 4: The procedure of converting between
logical form and action sequence.

convert logical forms to action sequences using
semantic graph as an intermediate representation
(See Figure 4 for an overview). Concretely, we
transform logical forms into semantic graphs us-
ing a depth-ﬁrst-search algorithm from root, and
then generate the action sequence using the same
order. Speciﬁcally, entities, variables and types
are nodes; relations are edges. Conversely we can
convert action sequence to logical form similarly.
Based on the above algorithm, action sequences
can be transformed into logical forms in a deter-
ministic way, and the same for logical forms to
action sequences.
Mechanisms for Handling Entities. Entities play
an important role in semantic parsing (Yih et al.,
In Dong and Lapata (2016), entities are
2015).
In
replaced with their types and unique IDs.
Jia and Liang (2016), entities are generated via
attention-based copying mechanism helped with a
lexicon. This paper implements both mechanisms
and compares them in experiments.

3.2

Inference

Given a new sentence X, we predict action se-
quence by:

Y ∗ = argmax

P (Y |X)

(10)

Y

where Y represents action sequence, and P (Y |X)
is computed using Formula (1). Beam search is
used for best action sequence decoding. Semantic
graph and logical form can be derived from Y ∗ as
described in above.

3.3

Incorporating Constraints in Decoding

For decoding, we generate action sequentially. It
is obviously that the next action has a strong cor-
relation with the partial semantic graph generated
to current, and illegal actions can be ﬁltered us-
ing structure and semantic constraints. Speciﬁ-
cally, we incorporate constraints in decoding using
a controller. This procedure has two steps: 1) the
controller constructs partial semantic graph using
the actions generated to current; 2) the controller
checks whether a new generated action can meet

Figure 5: A demonstration of illegal action ﬁlter-
ing using constraints. The graph in color is the
constructed semantic graph to current.

all structure/semantic constraints using the partial
semantic graph.

Structure Constraints. The structure constraints
ensure action sequence will form a connected
acyclic graph. For example, there must be two ar-
gument nodes for an edge, and the two argument
nodes should be different (The third candidate next
action in Figure 5 violates this constraint). This
kind of constraints are domain-independent. The
controller encodes structure constraints as a set of
rules.

Semantic Constraints. The semantic constraints
ensure the constructed graph must follow the
schema of knowledge bases.
Speciﬁcally, we
model two types of semantic constraints. One is
selectional preference constraints where the argu-
ment types of a relation should follow knowledge
base schemas. For example, in GEO dataset, rela-
tion next to’s arg1 and arg2 should both be
a state. The second is type conﬂict constraints,
i.e., an entity/variable node’s type must be consis-
tent, i.e., a node cannot be both of type city and
state. Semantic constraints are domain-speciﬁc
and are automatically extracted from knowledge
base schemas. The controller encodes semantic
constraints as a set of rules.

4 Experiments

In this section, we assess the performance of our
method and compare it with previous methods.

4.1 Datasets

We conduct experiments on three standard
datasets: GEO, ATIS and OVERNIGHT.
GEO contains natural language questions about
US geography paired with corresponding Pro-
log database queries. Following Zettlemoyer and
Collins (2005), we use the standard 600/280 in-
stance splits for training/test.
ATIS contains natural language questions of a
ﬂight database, with each question is annotated
with a lambda calculus query. Following Zettle-
moyer and Collins (2007), we use the standard
4473/448 instance splits for training/test.
OVERNIGHT contains natural
language para-
phrases paired with logical forms across eight do-
mains. We evaluate on the standard train/test splits
as Wang et al. (2015b).

4.2 Experimental Settings

Following the experimental setup of Jia and Liang
(2016): we use 200 hidden units and 100-
dimensional word vectors for sentence encoding.
The dimensions of action embedding are tuned on
validation datasets for each corpus. We initialize
all parameters by uniformly sampling within the
interval [-0.1, 0.1]. We train our model for a to-
tal of 30 epochs with an initial learning rate of
0.1, and halve the learning rate every 5 epochs af-
ter epoch 15. We replace word vectors for words
occurring only once with an universal word vec-
tor. The beam size is set as 5. Our model is
implemented in Theano (Bergstra et al., 2010),
and the codes and settings are released on Github:
https://github.com/dongpobeyond/Seq2Act.

We evaluate different systems using the stan-
dard accuracy metric, and the accuracies on differ-
ent datasets are obtained as same as Jia and Liang
(2016).

4.3 Overall Results

We compare our method with state-of-the-art sys-
tems on all three datasets. Because all systems us-
ing the same training/test splits, we directly use
the reported best performances from their original
papers for fair comparison.

For our method, we train our model with three
settings:
the ﬁrst one is the basic sequence-to-
action model without constraints – Seq2Act; the
second one adds structure constraints in decod-
ing – Seq2Act (+C1);
the third one is the full
model which adds both structure and semantic

Previous Work
Zettlemoyer and Collins (2005)
Zettlemoyer and Collins (2007)
Kwiatkowksi et al. (2010)
Kwiatkowski et al. (2011)
Liang et al. (2011)* (+lexicon)
Poon (2013)
Zhao et al. (2015)
Rabinovich et al. (2017)
Seq2Seq Models
Jia and Liang (2016)
Jia and Liang (2016)* (+data)
Dong and Lapata (2016): 2Seq
Dong and Lapata (2016): 2Tree
Our Models
Seq2Act
Seq2Act (+C1)
Seq2Act (+C1+C2)

GEO ATIS

79.3
86.1
88.9
88.6
91.1
–
88.9
87.1

85.0
89.3
84.6
87.1

87.5
88.2
88.9

–
84.6
–
82.8
–
83.5
84.2
85.9

76.3
83.3
84.2
84.6

84.6
85.0
85.5

Test accuracies on GEO and ATIS
Table 1:
datasets, where * indicates systems with extra-
resources are used.

constraints – Seq2Act (+C1+C2). Semantic con-
straints (C2) are stricter than structure constraints
(C1). Therefore we set that C1 should be ﬁrst met
for C2 to be met. So in our experiments we add
constraints incrementally. The overall results are
shown in Table 1-2. From the overall results, we
can see that:

1) By synthetizing the advantages of seman-
tic graph representation and the prediction abil-
ity of Seq2Seq model, our method achieves state-
of-the-art performance on OVERNIGHT dataset,
and gets competitive performance on GEO and
ATIS dataset.
In fact, on GEO our full model
(Seq2Act+C1+C2) also gets the best test accuracy
of 88.9 if under the same settings, which only falls
behind Liang et al. (2011)* which uses extra hand-
crafted lexicons and Jia and Liang (2016)* which
uses extra augmented training data. On ATIS our
full model gets the second best test accuracy of
85.5, which only falls behind Rabinovich et al.
(2017) which uses a supervised attention strategy.
On OVERNIGHT, our full model gets state-of-the-
art accuracy of 79.0, which even outperforms Jia
and Liang (2016)* with extra augmented training
data.

2) Compared with the linearized logical form
representation used in previous Seq2Seq base-
lines, our action sequence encoding is more effec-
tive for semantic parsing. On all three datasets,

Previous Work
Wang et al. (2015b)
Seq2Seq Models
Xiao et al. (2016)
Jia and Liang (2016)
Jia and Liang (2016)* (+data)
Our Models
Seq2Act
Seq2Act (+C1)
Seq2Act (+C1+C2)

Soc. Blo. Bas. Res. Cal. Hou. Pub. Rec. Avg.

48.2

41.9

46.3

75.9

74.4

54.0

59.0

70.8

58.8

80.0
81.4
79.6

81.4
81.8
82.1

55.6
58.1
60.2

60.4
60.9
61.4

80.5
85.2
87.5

87.5
88.0
88.2

80.1
76.2
79.5

79.8
80.1
80.7

75.0
78.0
81.0

81.0
81.0
81.5

61.9
71.4
72.5

73.0
73.5
74.1

75.8
76.4
78.3

79.5
80.1
80.7

–
79.6
81.0

81.5
82.0
82.9

72.7
75.8
77.5

78.0
78.4
79.0

Table 2: Test accuracies on OVERNIGHT dataset, which includes eight domains: Social, Blocks, Bas-
ketball, Restaurants, Calendar, Housing, Publications, and Recipes.

our basic Seq2Act model gets better results than
all Seq2Seq baselines. On GEO, the Seq2Act
model achieve test accuracy of 87.5, better than
the best accuracy 87.1 of Seq2Seq baseline. On
ATIS, the Seq2Act model obtains a test accuracy
of 84.6, the same as the best Seq2Seq baseline. On
OVERNGIHT, the Seq2Act model gets a test accu-
racy of 78.0, better than the best Seq2Seq baseline
gets 77.5. We argue that this is because our ac-
tion sequence encoding is more compact and can
capture more information.

3) Structure constraints can enhance semantic
parsing by ensuring the validity of graph using the
generated action sequence.
In all three datasets,
Seq2Act (+C1) outperforms the basic Seq2Act
model. This is because a part of illegal actions
will be ﬁltered during decoding.

4) By leveraging knowledge base schemas dur-
ing decoding, semantic constraints are effective
for semantic parsing. Compared to Seq2Act and
Seq2Act (+C1), the Seq2Act (+C1+C2) gets the
best performance on all three datasets. This is
because semantic constraints can further ﬁlter se-
mantic illegal actions using selectional preference
and consistency between types.

4.4 Detailed Analysis

Effect of Entity Handling Mechanisms. This pa-
per implements two entity handling mechanisms –
Replacing (Dong and Lapata, 2016) which identi-
ﬁes entities and then replaces them with their types
and IDs, and attention-based Copying (Jia and
Liang, 2016). To compare the above two mech-
anisms, we train and test with our full model and
the results are shown in Table 3. We can see that,
Replacing mechanism outperforms Copying in all
three datasets. This is because Replacing is done

Replacing Copying

GEO
ATIS
OVERNIGHT

88.9
85.5
79.0

88.2
84.0
77.9

Table 3: Test accuracies of Seq2Act (+C1+C2) on
GEO, ATIS, and OVERNIGHT of two entity han-
dling mechanisms.

Logical Form Action Sequence

GEO
ATIS
OVERNIGHT

28.2
28.4
46.6

18.2
25.8
33.3

Table 4: Average length of logical forms and ac-
tion sequences on three datasets. On OVERNIGHT,
we average across all eight domains.

in preprocessing, while attention-based Copying
is done during parsing and needs additional copy
mechanism.
Linearized Logical Form vs. Action Sequence.
Table 4 shows the average length of linearized log-
ical forms used in previous Seq2Seq models and
the action sequences of our model on all three
datasets. As we can see, action sequence en-
coding is more compact than linearized logical
form encoding: action sequence is shorter on all
three datasets, 35.5%, 9.2% and 28.5% reduction
in length respectively. The main advantage of a
shorter/compact encoding is that it will reduce the
inﬂuence of long distance dependency problem.

4.5 Error Analysis

We perform error analysis on results and ﬁnd there
are mainly two types of errors.
Unseen/Informal Sentence Structure. Some test
sentences have unseen syntactic structures. For
example, the ﬁrst case in Table 5 has an unseen

Error Types

Un-covered
Sentence
Structure

Under-
Mapping

Examples

answer(A, count(B, (const (C, stateid(iowa)), next to(C, B),

Sentence: Iowa borders how many states? (Formal Form: How many states does Iowa border?)
Gold Parse:
state (B)), A))
Predicted Parse: answer (A, count(B, state(B), A))
Sentence: Please show me ﬁrst class ﬂights from indianapolis to memphis one way leaving before 10am
Gold Parse:
(< (departure time x) 1000:ti) (from x indianapolis:ci) (to x
memphis:ci)))
Predicted Parse:
1000:ti) (from x indianapolis:ci) (to x memphis:ci)))

(lambda x (and (flight x) (oneway x) (class type x first:cl)

(lambda x (and (flight x) (oneway x) (< (departure time x)

Table 5: Some examples for error analysis. Each example includes the sentence for parsing, with gold
parse and predicted parse from our model.

and informal structure, where entity word “Iowa”
and relation word “borders” appear ahead of the
question words “how many”. For this problem,
we can employ sentence rewriting or paraphrasing
techniques (Chen et al., 2016; Dong et al., 2017) to
transform unseen sentence structures into normal
ones.
Under-Mapping. As Dong and Lapata (2016)
discussed, the attention model does not take the
alignment history into consideration, makes some
words are ignored during parsing. For example in
the second case in Table 5, “ﬁrst class” is ignored
during the decoding process. This problem can be
further solved using explicit word coverage mod-
els used in neural machine translation (Tu et al.,
2016; Cohn et al., 2016)

5 Related Work

Semantic parsing has received signiﬁcant atten-
tion for a long time (Kate and Mooney, 2006;
Clarke et al., 2010; Krishnamurthy and Mitchell,
2012; Artzi and Zettlemoyer, 2013; Berant and
Liang, 2014; Quirk et al., 2015; Artzi et al., 2015;
Reddy et al., 2017; Chen et al., 2018). Tradi-
tional methods are mostly based on the princi-
ple of compositional semantics, which ﬁrst trig-
ger predicates using lexicons and then compose
them using grammars.
The prominent gram-
mars include SCFG (Wong and Mooney, 2007; Li
et al., 2015), CCG (Zettlemoyer and Collins, 2005;
Kwiatkowski et al., 2011; Cai and Yates, 2013),
DCS (Liang et al., 2011; Berant et al., 2013),
etc. As discussed above, the main drawback of
grammar-based methods is that they rely on high-
quality lexicons, manually-built grammars, and
hand-crafted features.

In recent years, one promising direction of se-
mantic parsing is to use semantic graph as rep-
resentation. Thus semantic parsing is modeled
as a semantic graph generation process. Ge and

Mooney (2009) build semantic graph by trans-
forming syntactic tree. Bast and Haussmann
(2015) identify the structure of a semantic query
using three pre-deﬁned patterns. Reddy et al.
(2014, 2016) use Freebase-based semantic graph
representation, and convert sentences to semantic
graphs using CCG or dependency tree. Yih et al.
(2015) generate semantic graphs using a staged
heuristic search algorithm. These methods are all
based on manually-designed, heuristic generation
process, which may suffer from syntactic parse er-
rors (Ge and Mooney, 2009; Reddy et al., 2014,
2016), structure mismatch (Chen et al., 2016), and
are hard to deal with complex sentences (Yih et al.,
2015).

One other direction is

to employ neural
Seq2Seq models, which models semantic parsing
as an end-to-end, sentence to logical form machine
translation problem. Dong and Lapata (2016), Jia
and Liang (2016) and Xiao et al. (2016) transform
word sequence to linearized logical forms. One
main drawback of these methods is that it is hard
to capture and exploit structure and semantic con-
straints using linearized logical forms. Dong and
Lapata (2016) propose a Seq2Tree model to cap-
ture the hierarchical structure of logical forms.

It has been shown that structure and seman-
tic constraints are effective for enhancing seman-
tic parsing. Krishnamurthy et al. (2017) use type
constraints to ﬁlter illegal tokens. Liang et al.
(2017) adopt a Lisp interpreter with pre-deﬁned
functions to produce valid tokens.
Iyyer et al.
(2017) adopt type constraints to generate valid ac-
tions. Inspired by these approaches, we also in-
corporate both structure and semantic constraints
in our neural sequence-to-action model.

Transition-based approaches are important in
both dependency parsing (Nivre, 2008; Hender-
son et al., 2013) and AMR parsing (Wang et al.,
In semantic parsing, our method has a
2015a).

tight-coupling with knowledge bases, and con-
straints can be exploited for more accurate decod-
ing. We believe this can also be used to enhance
previous transition based methods and may also be
used in other parsing tasks, e.g., AMR parsing.

6 Conclusions

a
This paper proposes Sequence-to-Action,
method which models semantic parsing as an
end-to-end semantic graph generation process.
By leveraging the advantages of semantic graph
representation and exploiting the representation
learning and prediction ability of Seq2Seq models,
our method achieved signiﬁcant performance im-
provements on three datasets. Furthermore, struc-
ture and semantic constraints can be easily incor-
porated in decoding to enhance semantic parsing.
For future work, to solve the problem of the lack
of training data, we want to design weakly super-
vised learning algorithm using denotations (QA
pairs) as supervision. Furthermore, we want to
collect labeled data by designing an interactive UI
for annotation assist like (Yih et al., 2016), which
uses semantic graphs to annotate the meaning of
sentences, since semantic graph is more natural
and can be easily annotated without the need of
expert knowledge.

References

Yoav Artzi, Kenton Lee, and Luke Zettlemoyer.
Broad-coverage ccg semantic parsing
2015.
the 2015 Con-
with amr.
ference on Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics, Lisbon, Portugal, pages 1699–1710.
http://aclweb.org/anthology/D15-1198.

In Proceedings of

Yoav Artzi and Luke Zettlemoyer. 2013. Weakly su-
pervised learning of semantic parsers for mapping
instructions to actions. Transactions of the Associa-
tion for Computational Linguistics 1(1):49–62.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua
Neural machine translation by
CoRR

Bengio. 2014.
jointly learning to align and translate.
abs/1409.0473. http://arxiv.org/abs/1409.0473.

Jonathan Berant, Andrew Chou, Roy Frostig, and Percy
Liang. 2013. Semantic parsing on Freebase from
question-answer pairs. In Proceedings of the 2013
Conference on Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics, Seattle, Washington, USA, pages 1533–
1544. http://www.aclweb.org/anthology/D13-1160.

Jonathan Berant and Percy Liang. 2014.

Se-
In Proceed-
mantic parsing via paraphrasing.
the Asso-
the 52nd Annual Meeting of
ings of
ciation for Computational Linguistics (Volume 1:
Long Papers). Association for Computational Lin-
guistics, Baltimore, Maryland, pages 1415–1425.
http://www.aclweb.org/anthology/P14-1133.

James Bergstra, Olivier Breuleux, Fr´ed´eric Bastien,
Pascal Lamblin, Razvan Pascanu, Guillaume Des-
jardins, Joseph Turian, David Warde-Farley, and
Yoshua Bengio. 2010. Theano: A cpu and gpu math
compiler in python. In Proc. 9th Python in Science
Conf . pages 1–7.

Qingqing Cai and Alexander Yates. 2013. Large-scale
semantic parsing via schema matching and lexicon
extension. In Proceedings of the 51st Annual Meet-
ing of the Association for Computational Linguistics
(Volume 1: Long Papers). Association for Computa-
tional Linguistics, Soﬁa, Bulgaria, pages 423–433.
http://www.aclweb.org/anthology/P13-1042.

Bo Chen, Bo An, Le Sun, and Xianpei Han. 2018.
Semi-supervised lexicon learning for wide-coverage
semantic parsing. In Proceedings of the 27th Inter-
national Conference on Computational Linguistics.
Association for Computational Linguistics, pages
892–904. http://aclweb.org/anthology/C18-1076.

Bo Chen, Le Sun, Xianpei Han, and Bo An. 2016.
In
Sentence rewriting for semantic parsing.
Proceedings of
the
Association for Computational Linguistics (Vol-
ume 1: Long Papers). Association for Computa-
tional Linguistics, Berlin, Germany, pages 766–777.
http://www.aclweb.org/anthology/P16-1073.

the 54th Annual Meeting of

Kyunghyun Cho, Bart van Merrienboer, Caglar Gul-
cehre, Dzmitry Bahdanau, Fethi Bougares, Holger
Schwenk, and Yoshua Bengio. 2014.
Learning
phrase representations using rnn encoder–decoder
for statistical machine translation. In Proceedings of
the 2014 Conference on Empirical Methods in Nat-
ural Language Processing (EMNLP). Association
for Computational Linguistics, Doha, Qatar, pages
1724–1734. http://www.aclweb.org/anthology/D14-
1179.

Hannah Bast and Elmar Haussmann. 2015. More
In
accurate question answering on freebase.
Proceedings of
the 24th ACM International on
Conference on Information and Knowledge Man-
agement, CIKM 2015, Melbourne, VIC, Aus-
tralia, October 19 - 23, 2015. pages 1431–1440.
https://doi.org/10.1145/2806416.2806472.

James Clarke, Dan Goldwasser, Ming-Wei Chang,
and Dan Roth. 2010. Driving semantic parsing
In Proceedings of
from the world’s response.
the Fourteenth Conference on Computational Nat-
ural Language Learning. Association for Computa-
tional Linguistics, Uppsala, Sweden, pages 18–27.
http://www.aclweb.org/anthology/W10-2903.

Trevor Cohn, Cong Duy Vu Hoang, Ekaterina Vy-
molova, Kaisheng Yao, Chris Dyer, and Gholam-
reza Haffari. 2016.
Incorporating structural align-
ment biases into an attentional neural translation
In Proceedings of the 2016 Conference
model.
of the North American Chapter of the Associa-
tion for Computational Linguistics: Human Lan-
guage Technologies. Association for Computational
Linguistics, San Diego, California, pages 876–885.
http://www.aclweb.org/anthology/N16-1102.

Li Dong and Mirella Lapata. 2016.

the 54th Annual Meeting of

Language
In Pro-
to logical form with neural attention.
ceedings of
the
Association for Computational Linguistics (Vol-
ume 1: Long Papers). Association for Computa-
tional Linguistics, Berlin, Germany, pages 33–43.
http://www.aclweb.org/anthology/P16-1004.

Li Dong, Jonathan Mallinson, Siva Reddy, and Mirella
Lapata. 2017. Learning to paraphrase for ques-
In Proceedings of the 2017 Con-
tion answering.
ference on Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics, Copenhagen, Denmark, pages 875–886.
https://www.aclweb.org/anthology/D17-1091.

Ruifang Ge and Raymond Mooney. 2009. Learn-
ing a compositional semantic parser using an
In Proceedings of
existing syntactic parser.
the Joint Conference of
the 47th Annual Meet-
ing of
the ACL and the 4th International Joint
Conference on Natural Language Processing
the AFNLP. Association for Computational
of
Linguistics, Suntec, Singapore, pages 611–619.
http://www.aclweb.org/anthology/P/P09/P09-1069.

Yulan He and Steve Young. 2005.

Semantic pro-
state model.
cessing using the hidden vector
Computer Speech and Language 19(1):85 – 106.
https://doi.org/https://doi.org/10.1016/j.csl.2004.03.001.

James Henderson, Paola Merlo,

Ivan Titov, and
Gabriele Musillo. 2013. Multilingual joint parsing
of syntactic and semantic dependencies with a latent
variable model. Comput. Linguist. 39(4):949–998.
http://dx.doi.org/10.1162/COLI a 00158.

Sepp Hochreiter and J¨urgen Schmidhuber. 1997. Long
short-term memory. Neural Comput. 9(8):1735–
1780. https://doi.org/10.1162/neco.1997.9.8.1735.

Mohit Iyyer, Wen-tau Yih, and Ming-Wei Chang.
Search-based neural structured learning
2017.
In Proceed-
for sequential question answering.
ings of
the Asso-
the 55th Annual Meeting of
ciation for Computational Linguistics (Volume 1:
Long Papers). Association for Computational Lin-
guistics, Vancouver, Canada, pages 1821–1831.
http://aclweb.org/anthology/P17-1167.

Robin Jia and Percy Liang. 2016.

bination for neural semantic parsing.
ceedings of

the 54th Annual Meeting of

Data recom-
In Pro-
the

Association for Computational Linguistics (Vol-
ume 1: Long Papers). Association for Computa-
tional Linguistics, Berlin, Germany, pages 12–22.
http://www.aclweb.org/anthology/P16-1002.

Rohit J. Kate and Raymond J. Mooney. 2006. Us-
ing string-kernels for learning semantic parsers.
In Proceedings of the 21st International Confer-
ence on Computational Linguistics and 44th An-
nual Meeting of
the Association for Computa-
tional Linguistics. Association for Computational
Linguistics, Sydney, Australia, pages 913–920.
https://doi.org/10.3115/1220175.1220290.

Jayant Krishnamurthy, Pradeep Dasigi, and Matt
Neural semantic parsing with
Gardner. 2017.
In
type constraints for semi-structured tables.
Proceedings of
the 2017 Conference on Em-
pirical Methods in Natural Language Process-
ing. Association
for Computational Linguis-
tics, Copenhagen, Denmark, pages 1516–1526.
https://www.aclweb.org/anthology/D17-1160.

Jayant Krishnamurthy and Tom Mitchell. 2012.
Weakly supervised training of semantic parsers.
In Proceedings of the 2012 Joint Conference on
Empirical Methods in Natural Language Pro-
cessing and Computational Natural Language
Learning. Association for Computational Lin-
Jeju Island, Korea, pages 754–765.
guistics,
http://www.aclweb.org/anthology/D12-1069.

Tom Kwiatkowksi, Luke Zettlemoyer, Sharon Gold-
water, and Mark Steedman. 2010.
Inducing prob-
abilistic CCG grammars from logical form with
In Proceedings of the
higher-order uniﬁcation.
2010 Conference on Empirical Methods in Natu-
ral Language Processing. Association for Compu-
tational Linguistics, Cambridge, MA, pages 1223–
1233. http://www.aclweb.org/anthology/D10-1119.

Tom Kwiatkowski, Eunsol Choi, Yoav Artzi, and Luke
Zettlemoyer. 2013. Scaling semantic parsers with
In Proceedings of
on-the-ﬂy ontology matching.
the 2013 Conference on Empirical Methods in Natu-
ral Language Processing. Association for Computa-
tional Linguistics, Seattle, Washington, USA, pages
1545–1556. http://www.aclweb.org/anthology/D13-
1161.

Tom Kwiatkowski, Luke Zettlemoyer, Sharon Gold-
water, and Mark Steedman. 2011. Lexical gen-
eralization in ccg grammar induction for seman-
In Proceedings of the 2011 Confer-
tic parsing.
ence on Empirical Methods in Natural Language
Processing. Association for Computational Linguis-
tics, Edinburgh, Scotland, UK., pages 1512–1523.
http://www.aclweb.org/anthology/D11-1140.

Junhui Li, Muhua Zhu, Wei Lu, and Guodong Zhou.
Improving semantic parsing with enriched
2015.
In Proceed-
synchronous context-free grammar.
ings of the 2015 Conference on Empirical Methods
in Natural Language Processing. Association for
Computational Linguistics, Lisbon, Portugal, pages
1455–1465. http://aclweb.org/anthology/D15-1170.

Chen Liang, Jonathan Berant, Quoc Le, Kenneth D.
Forbus, and Ni Lao. 2017. Neural symbolic ma-
chines: Learning semantic parsers on freebase with
In Proceedings of the 55th An-
weak supervision.
nual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers). Association
for Computational Linguistics, Vancouver, Canada,
pages 23–33.
http://aclweb.org/anthology/P17-
1003.

Percy Liang, Michael

Jordan,

and Dan Klein.
Learning dependency-based composi-
2011.
the 49th
In Proceedings of
tional semantics.
Annual Meeting of
the Association for Com-
putational Linguistics: Human Language Tech-
nologies. Association for Computational Linguis-
tics, Portland, Oregon, USA, pages 590–599.
http://www.aclweb.org/anthology/P11-1060.

Wei Lu, Hwee Tou Ng, Wee Sun Lee,

and
Luke S. Zettlemoyer. 2008. A generative model
language to meaning repre-
for parsing natural
the 2008 Con-
sentations.
ference on Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics, Honolulu, Hawaii, pages 783–792.
http://www.aclweb.org/anthology/D08-1082.

In Proceedings of

Thang Luong, Hieu Pham, and Christopher D. Man-
ning. 2015. Effective approaches to attention-based
In Proceedings of the
neural machine translation.
2015 Conference on Empirical Methods in Natu-
ral Language Processing. Association for Compu-
tational Linguistics, Lisbon, Portugal, pages 1412–
1421. http://aclweb.org/anthology/D15-1166.

Joakim Nivre. 2008. Algorithms for deterministic in-
cremental dependency parsing. Comput. Linguist.
34(4):513–553.
http://dx.doi.org/10.1162/coli.07-
056-R1-07-027.

Hoifung Poon. 2013. Grounded unsupervised seman-
tic parsing. In Proceedings of the 51st Annual Meet-
ing of the Association for Computational Linguistics
(Volume 1: Long Papers). Association for Computa-
tional Linguistics, Soﬁa, Bulgaria, pages 933–943.
http://www.aclweb.org/anthology/P13-1092.

Chris Quirk, Raymond Mooney, and Michel Galley.
2015. Language to code: Learning semantic parsers
In Proceedings of the
for if-this-then-that recipes.
53rd Annual Meeting of the Association for Compu-
tational Linguistics and the 7th International Joint
Conference on Natural Language Processing (Vol-
ume 1: Long Papers). Association for Computa-
tional Linguistics, Beijing, China, pages 878–888.
http://www.aclweb.org/anthology/P15-1085.

Siva Reddy, Mirella Lapata, and Mark Steedman.
Large-scale semantic parsing without
2014.
question-answer pairs. Transactions of the Asso-
ciation for Computational Linguistics 2:377–392.
http://aclweb.org/anthology/Q14-1030.

Siva Reddy, Oscar T¨ackstr¨om, Michael Collins,
Tom Kwiatkowski, Dipanjan Das, Mark Steed-
Transforming
man, and Mirella Lapata. 2016.
Dependency Structures
for
the Associ-
Semantic Parsing.
ation for Computational Linguistics 4:127–140.
http://sivareddy.in/papers/reddy2016transforming.pdf.

to Logical Forms

Transactions of

Siva Reddy, Oscar T¨ackstr¨om, Slav Petrov, Mark
Steedman, and Mirella Lapata. 2017. Universal
the 2017
semantic parsing.
Conference on Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics, Copenhagen, Denmark, pages 89–101.
https://www.aclweb.org/anthology/D17-1009.

In Proceedings of

Zhaopeng Tu, Zhengdong Lu, Yang Liu, Xiao-
hua Liu, and Hang Li. 2016. Modeling cov-
In Pro-
erage for neural machine translation.
the
ceedings of
Association for Computational Linguistics (Vol-
ume 1: Long Papers). Association for Computa-
tional Linguistics, Berlin, Germany, pages 76–85.
http://www.aclweb.org/anthology/P16-1008.

the 54th Annual Meeting of

Chuan Wang, Nianwen Xue, and Sameer Pradhan.
A transition-based algorithm for amr
2015a.
the 2015 Confer-
In Proceedings of
parsing.
ence of the North American Chapter of the As-
sociation for Computational Linguistics: Human
Language Technologies. Association for Computa-
tional Linguistics, Denver, Colorado, pages 366–
375. http://www.aclweb.org/anthology/N15-1040.

Yushi Wang, Jonathan Berant, and Percy Liang. 2015b.
Building a semantic parser overnight. In Proceed-
ings of the 53rd Annual Meeting of the Association
for Computational Linguistics and the 7th Interna-
tional Joint Conference on Natural Language Pro-
cessing (Volume 1: Long Papers). Association for
Computational Linguistics, Beijing, China, pages
1332–1342. http://www.aclweb.org/anthology/P15-
1129.

Yuk Wah Wong and Raymond Mooney. 2007. Learn-
ing synchronous grammars for semantic parsing
In Proceedings of the 45th
with lambda calculus.
Annual Meeting of the Association of Computa-
tional Linguistics. Association for Computational
Linguistics, Prague, Czech Republic, pages 960–
967. http://www.aclweb.org/anthology/P07-1121.

Maxim Rabinovich, Mitchell Stern, and Dan Klein.
2017. Abstract syntax networks for code gen-
In Proceed-
eration and semantic parsing.
ings of
the Asso-
the 55th Annual Meeting of
ciation for Computational Linguistics (Volume 1:
Long Papers). Association for Computational Lin-
guistics, Vancouver, Canada, pages 1139–1149.
http://aclweb.org/anthology/P17-1105.

Chunyang Xiao, Marc Dymetman, and Claire Gardent.
2016. Sequence-based structured prediction for se-
mantic parsing. In Proceedings of the 54th Annual
Meeting of the Association for Computational Lin-
guistics (Volume 1: Long Papers). Association for
Computational Linguistics, Berlin, Germany, pages
1341–1350. http://www.aclweb.org/anthology/P16-
1127.

In Proceedings of

Wen-tau Yih, Ming-Wei Chang, Xiaodong He, and
Jianfeng Gao. 2015. Semantic parsing via staged
query graph generation: Question answering with
the 53rd
knowledge base.
Annual Meeting of the Association for Computa-
tional Linguistics and the 7th International Joint
Conference on Natural Language Processing (Vol-
ume 1: Long Papers). Association for Compu-
tational Linguistics, Beijing, China, pages 1321–
1331. http://www.aclweb.org/anthology/P15-1128.

Wen-tau Yih, Matthew Richardson, Chris Meek, Ming-
Wei Chang, and Jina Suh. 2016. The value of se-
mantic parse labeling for knowledge base question
answering. In Proceedings of the 54th Annual Meet-
ing of the Association for Computational Linguistics
(Volume 2: Short Papers). Association for Computa-
tional Linguistics, Berlin, Germany, pages 201–206.
http://anthology.aclweb.org/P16-2033.

John M. Zelle and Raymond J. Mooney. 1996.
Learning to parse database queries using induc-
In AAAI/IAAI. AAAI
tive logic programming.
Press/MIT Press, Portland, OR, pages 1050–1055.
http://www.cs.utexas.edu/users/ai-lab/?zelle:aaai96.

relaxed CCG grammars

Luke Zettlemoyer and Michael Collins. 2007. On-
for
line learning of
In Proceedings of the
parsing to logical form.
2007 Joint Conference on Empirical Methods
in Natural Language Processing and Compu-
tational Natural Language Learning (EMNLP-
CoNLL). Association for Computational Linguis-
tics, Prague, Czech Republic, pages 678–687.
http://www.aclweb.org/anthology/D/D07/D07-
1071.

Luke S. Zettlemoyer and Michael Collins. 2005.
Learning to map sentences to logical form: Struc-
tured classiﬁcation with probabilistic categorial
grammars. In UAI ’05, Proceedings of the 21st Con-
ference in Uncertainty in Artiﬁcial Intelligence, Ed-
inburgh, Scotland, July 26-29, 2005. pages 658–666.

Kai Zhao, Hany Hassan, and Michael Auli. 2015.
Learning translation models from monolingual con-
tinuous representations. In Proceedings of the 2015
Conference of the North American Chapter of the
Association for Computational Linguistics: Human
Language Technologies. Association for Computa-
tional Linguistics, Denver, Colorado, pages 1527–
1536. http://www.aclweb.org/anthology/N15-1176.

