Dynamic Multiscale Graph Neural Networks for
3D Skeleton-Based Human Motion Prediction

Maosen Li1, Siheng Chen2 (cid:0), Yangheng Zhao1, Ya Zhang1 (cid:0), Yanfeng Wang1, and Qi Tian3

1 Cooperative Medianet Innovation Center, Shanghai Jiao Tong University
2 Mitsubishi Electric Research Laboratories
3 Huawei Noah’s Ark Lab
{maosen li, zhaoyangheng-sjtu, ya zhang, wangyanfeng} @sjtu.edu.cn, schen@merl.com,
tian.qi1@huawei.com

0
2
0
2
 
r
a

M
 
7
1
 
 
]

V
C
.
s
c
[
 
 
1
v
2
0
8
8
0
.
3
0
0
2
:
v
i
X
r
a

Abstract

We propose novel dynamic multiscale graph neural net-
works (DMGNN) to predict 3D skeleton-based human mo-
tions. The core idea of DMGNN is to use a multiscale
graph to comprehensively model the internal relations of
a human body for motion feature learning. This multi-
scale graph is adaptive during training and dynamic across
network layers. Based on this graph, we propose a mul-
tiscale graph computational unit (MGCU) to extract fea-
tures at individual scales and fuse features across scales.
The entire model is action-category-agnostic and follows
an encoder-decoder framework. The encoder consists of
a sequence of MGCUs to learn motion features. The de-
coder uses a proposed graph-based gate recurrent unit to
generate future poses. Extensive experiments show that
the proposed DMGNN outperforms state-of-the-art meth-
ods in both short and long-term predictions on the datasets
of Human 3.6M and CMU Mocap. We further investigate
the learned multiscale graphs for the interpretability. The
codes could be downloaded from https://github.
com/limaosen0/DMGNN .

1. Introduction

3D skeleton-based human motion prediction forecasts
future poses given the past motions based on the human-
body-skeleton. The motion prediction helps machines un-
derstand human behaviors, attracting considerable atten-
tion [9, 20, 33, 5, 12, 2]. The related techniques can be
widely applied to many computer vision and robotics sce-
narios, such as human-computer interaction [24, 23, 17, 13],
autonomous driving [6], and pedestrian tracking [1, 15, 3].
Many methods, including the conventional state-based
methods [26, 45, 39, 38, 37] and deep-network-based meth-

Figure 1. Two learned multiscale graphs on ‘Posing’. We show
strong relations associated with torsos in single scales and across
scales. Two multiscale graphs are dynamic from one MGCUs to
another, capturing local and distant relations, respectively.

ods [9, 33, 10, 7, 12, 14, 11, 34, 44], have been proposed to
achieve promising motion prediction. However, most meth-
ods did not explicitly exploit the relations or constraints be-
tween different body-components, which carry crucial in-
formation for motion prediction. A recent work [32] built
graphs across body-joints for pairwise relation modeling;
however, such a graph was still insufﬁcient to reﬂect a func-
tional group of body-joints. Another work [44] builds pre-
deﬁned sturctures to aggregate body-joint features to rep-
resent ﬁxed body-parts, while the model only considers
the body physical constraints without exploiting the move-
ment coordination and relations. For example, the action
of ‘Walking’ tends to be understood based on the collabo-
rative movements of abstract arms and legs, rather than the
detailed locations of ﬁngers and toes.

To model more comprehensive relations, we propose a
new representation for a human body: a multiscale graph,
whose nodes are body-components at various scales and
edges are pairwise relations between components. To model
a body at multiple scales, a multiscale graph consists of two

Figure 2. The architecture of DMGNN, which uses an encoder-decoder framework for motion prediction. In the encoder, cascaded mul-
tiscale graph computational blocks (MGCU) leverage dynamic muliscale graphs to extract spatio-temporal features. In the decoder, we
propose a graph-based GRU (G-GRU) to predict poses.

types of sub-graphs: single-scale graphs, connecting body-
components at the same scales, and cross-scale graphs, con-
necting body-components across two scales; see Figure 1.
The single-scale graphs together provide a pyramid repre-
sentation of a body skeleton. Each cross-scale graph is
a bipartite graph, bridging one single-scale graph to an-
other. For example, an “arm” node in a coarse-scale graph
could connect to “hand” and “elbow“ nodes in a ﬁne-scale
graph. This multiscale graph is initialized by predeﬁned
physical connections and adaptively adjusted in training to
be motion-sensitive. Overall, this multiscale representation
provides a new potentiality to model body relations.

Based on the multiscale graph, we propose a novel
model, called dynamic multiscale graph neural networks
(DMGNN), which is action-category-agnostic and follows
from an encoder-decoder framework to learn motion repre-
sentations for prediction. The encoder contains a cascade
of multiscale graph computational units (MGCU), where
each is associated with a multiscale graph. One MGCU
includes two key components: single-scale graph convo-
lution block (SS-GCB), leveraging single-scale graphs to
exact features at individual scales, and cross-scale fusion
block (CS-FB), inferring cross-scale graphs to convert fea-
tures from one scale to another and enable fusion across
scales. The multiscale graph has adaptive and trainable
inbuilt topology; it is also dynamic because the topology
is changing from one MGCU to another; see the learned
dynamic multiscale graphs in Figure 1. Notably, cross-
scale graphs in CS-FBs are constructed adaptively to in-
put motions, and reﬂect discriminative motion patterns for
category-agnostic prediction.

As for the decoder, we adopt a graph-based gated re-
current unit (G-GRU) to sequentially produce predictions
given the last estimated poses. The G-GRU utilizes train-
able graphs to further enhance state propagation. We also
use residual connections to stabilize the prediction. To learn
richer motion dynamics, we introduce difference operators
to extract multiple orders of motion differences as the prox-
ies of positions, velocities, and accelerations. The architec-
ture of DMGNN is illustrated in Figure 2.

To verify the superiority of our DMGNN, extensive ex-
periments are conducted on two large-scale datasets: Hu-
man 3.6M [19] and CMU Mocap1. The experimental re-
sults show that our model outperforms most state-of-the-art
works for both short-term and long-term prediction in terms
of both effectiveness and efﬁciency. The main contributions
of this paper are as follow:

• We propose dynamic multiscale graph neural networks
(DMGNN) to extract deep features at multiple scales
and achieve effective motion prediction;

• We propose two key components: a multiscale graph
computational unit, which leverages a multiscale graph
to extract and fuse features across multiple scales, as
well as a graph-based GRU to enhance state propaga-
tion for pose generation; and

• We conduct extensive experiments to show that the
proposed DMGNN outperforms most state-of-the-art
methods for short and long-term motion prediction on
two large datasets. We further visualize the learned
graphs for interpretability and reasoning.

2. Related Work

Human motion prediction: To forecast motions, some
traditional methods, e.g., hidden Markov models [26],
Gaussian-process [45] and random forests [26], were devel-
oped. Recently, deep networks are playing increasingly cru-
cial roles: some recurrent-network-based models generated
future poses step-by-step [9, 20, 33, 42, 46, 11, 31, 12, 29];
some feed-forward networks [27, 32] tried to reduce er-
ror accumulation for stable prediction; imitation-learning
algorithm was also proposed [43]. However, these meth-
ods rarely considered enough relations from various scales,
which carry comprehensive information for human behav-
iors understanding. In this work, we build dynamic multi-
scale graphs to capture rich multiscale relations and extract
ﬂexible semantics for motion prediction.

Graph deep learning: Graphs, expressing data asso-
ciated with non-grid structures, preserve the dependencies

1http://mocap.cs.cmu.edu/

Figure 3. Three body scales on Human 3.6M. In s1, we consider
20 joints with non-zero exponential maps [18]; In s2 and s3, we
consider 10 and 5 parts, respectively.

among internal nodes [47, 41, 40]. Many studies focused
on graph representation learning and the relative applica-
tions [30, 8, 22, 16, 47, 36]. Based on ﬁxed graph struc-
tures, previous works explored propagating node features
according to either the graph spectral domain [8, 22] or
the graph vertex domain [16]. Several graph-based mod-
els have been employed for skeleton-based action recogni-
tion [47, 28, 35], motion prediction [32] and 3D pose esti-
mation [48]; Different from any previous works, our model
considers multiscale graphs and corresponding operations.

3. Problem Formulation

Suppose that the historical 3D skeleton-based poses are
X−Th:0 = [X(−Th), . . . , X(0)]∈ RM ×(Th+1)×Dx and the
future poses are X1:Tf = [X(1), . . . , X(Tf )]∈ RM ×Tf ×Dx,
where X(t) ∈ RM ×Dx with M joints and Dx = 3 feature-
dimensions depicts the 3D pose at time t. The goal of mo-
tion prediction is to generate future poses given the past ob-
served ones; mathematically, we need to propose a model
Fpred(·) to predict (cid:98)X1:Tf = Fpred(X−Th:0), where (cid:98)X1:Tf is
the predicted motion close to the target X1:Tf .

To exploit rich body relations, we represent a body as a
multiscale graph across multiscale body-components. The-
orically, we could use arbitrary number of scales. Based
on human nature, we speciﬁcally adopt 3 scales: the body-
joint scale, the low-level-part scale, and the high-level-part
scale. To initialize multiscale body graphs, we merge spa-
tially nearby joints to coarser scales based on human prior;
see Figure 3. With the multiscale graphs, we propose dy-
namic multiscale graph neural networks (DMGNN) to pre-
dict future poses in an end-to-end fashion.

4. Key Components

To construct our dynamic multiscale graph neural net-
works (DMGNN), we consider three basic components:
a multiscale graph computational unit (MGCU), a graph-
based GRU (G-GRU), and a difference operator.

4.1. Multiscale graph computational unit (MGCU)

The functionality of a MGCU is to extract and fuse fea-
tures at multiple scales based on a multiscale graph, which

Figure 4. An MGCU uses single-scale graph convolution blocks
(SS-CB) cross-scale fusion blocks (CS-FB).

is trained adaptively and individually. One MGCU includes
two types of building blocks: single-scale graph convolu-
tion blocks, which leverage single-scale graphs to extract
features at each scale, and cross-scale fusion blocks, which
leverage cross-scale graphs to convert features from one
scale to another and enable effective fusion across scales;
see Figure 4. We now introduce each block in detail.

Single-scale graph convolution block (SS-GCB). To
extract spatio-temporal features at each scale, we propose
a single-scale graph convolution block (SS-GCB). Let the
trainable adjacency matrix of the single-scale graph at scale
s be As ∈ RMs×Ms , where Ms is the number of body-
components. As is ﬁrst initialized by a skeleton graph
whose nodes are body-components and edges are physical
connections, modeling a prior of the physical constraints;
see Figure 3. During training, each element in As is adap-
tively tuned to capture ﬂexible body relations.

Based on the single-scale graph, SS-GCB effectively ex-
tracts deep features through two steps: 1) a graph convolu-
tion extracts spatial features of body-components; and 2) a
temporal convolution extracts temporal features from mo-
tion sequences. Let the input feature at scale s be Xs ∈
RMs×Dx , the spatial graph convolution is formulated as
Xs,sp = ReLU(AsXsWs + XsUs) ∈ RMs×D(cid:48)
x,

(1)

where Ws, Us ∈ RDx×D(cid:48)
x are trainable parameters.
Through (1), we extract the spatial features from correlated
body-components. As in each SS-GCB is trained individ-
ually and stays ﬁxed during test. To capture motions along
time, we then develop a temporal convolution on the feature
sequences. The single-scale graphs in different SS-GCBs
are dynamic, showing ﬂexible relations. Note that features
extracted at various scales have different dimensionalities
and reﬂect information with different receptive ﬁelds.

Cross-scale fusion block (CS-FB). To enable informa-
tion diffusion across scales, we propose a cross-scale fusion
block (CS-FB) which uses a cross-scale graph to convert
features from one scale to another. A cross-scale graph is
a bipartite graph that corresponds the nodes in one single-
scale graph to the nodes in another single-scale graph. For
example, the features of an “arm” node in the low-level-
part scale s2 can potentially guide the feature learning of a
“hand” node in the body-joint scale s1. We aim to infer this

corresponding joints in s1. The fused Xs2 is fed into the SS-
CB of the next MGCU in s2. In the other way around, we
can deﬁne the fusion from s2 to s1 with similar operations.

4.2. Graph-based GRU

The functionality of a graph-based GRU (G-GRU) is to
learn and update hidden states with the guide of a graph.
The key is to use a trainable graph to regularize the states,
which are used to generate future poses. Let AH ∈ RM ×M
be the adjacent matrix of the inbuilt graph, which is ini-
tialized with the skeleton-graph and trained to build adap-
tive edges, and H(0) ∈ RM ×Dh be the initial state of G-
GRU. At time t > 0, G-GRU takes two inputs: the initial
state, H(t), and the online 3D skeleton-based information,
I(t) ∈ RM ×d. Then, G-GRU(I(t), H(t)) works as

r(t) = σ(rin(I(t)) + rhid(AHH(t)WH)),
u(t) = σ(uin(I(t)) + uhid(AHH(t)WH)),
c(t) = tanh(cin(I(t)) + r(t) (cid:12) chid(AHH(t)WH)),

H(t+1) = u(t) (cid:12) H(t) + (1 − u(t)) (cid:12) c(t),

where rin(·), rhid(·), uin(·), uhid(·), cin(·) and chid(·)
are trainable linear mappings; WH denotes the trainable
weights. For each G-GRU cell, it applies a graph convo-
lution on the hidden states for information propagation and
produces the state for next frame.

The motion states like velocity and acceleration carry
important dynamics. To use them, we propose a differ-
ence operator to compute high-order differences of input
sequences, guiding the model to learn richer dynamics. At
time t, the 0-order difference is ∆0X(t) = X(t) ∈ RM ×Dx,
and the β-order difference (β > 0) of the pose, ∆βX(t),
is ∆βX(t) = ∆β−1X(t) − ∆β−1X(t−1). We use zero
paddings after computing the differences to handle bound-
ary conditions. Overall, the difference operator works as

diﬀ β(X(t)) = (cid:2)∆0X(t)

· · · ∆βX(t)(cid:3) .

Here we consider β = 2. The three elements reﬂects posi-
tions, velocities, and accelerations.

5. DMGNN Framework

Here we present the architecture of our DMGNN, which
contains a multiscale graph-based encoder and a recurrent
graph-based decoder for motion prediction.

5.1. Encoder

Capturing semantics from observed motions, the encoder
aims to provide the decoder with motion states for predic-
tion. In the encoder, for each motion sample, we ﬁrst con-
catenate its 0, 1, 2-order of differences as input. And we
initialize 3 body scales by averaging joint clusters in s1 to

Figure 5. The inference of a cross-scale graph.

cross-scale graph adaptively from data. Here we present
CS-FB from s1 to s2 as an example.

We ﬁrst infer the cross-scale graph with adjacent matrix
As1s2 ∈ [0, 1]Ms2 ×Ms1 to model the cross-scale relations.
Let the feature of the ith joint and the kth part along time
be (Xs1):,i,: ∈ RTs1 ×D(cid:48)
x, we
vectorize them as ps1,i = vec(convs1,τ ((Xs1):,i,:; µ)) and
ps2,k = vec(convs2,τ ((Xs2):,k,:; µ)) to leverage temporal
information, where τ and µ denote the temporal convolution
kernel size and stride. We infer the edge weight between the
ith joint and kth part (As1s2 )k,i through

x and (Xs2):,k,: ∈ RTs2 ×D(cid:48)

Ms1(cid:88)

rs1,i =

fs1 ([ps1,i, ps1,j − ps1,i])

(2a)

j=1
hs1,i = gs1 ([ps1,i, rs1,i])
Ms2(cid:88)

j=1
hs2,k = gs2 ([ps2,k, rs2,k])

(2b)

(2d)

(2e)

(As1s2 )k,i = softmax(h(cid:62)

s2,khs1,i) ∈ [0, 1],

where fs1(·), gs1(·), fs2(·) and gs2(·) denotes MLPs;
softmax(·) is a softmax operator along the raw of inner
product matrix and [·, ·] is concatenation. (2a) and (2c) ag-
gregate the relative features of all the components to the
ith and the kth components in two scales, which are then
updated by (2b) and (2d); and (2e) obtains adjacent matrix
through inner product and softmax, thus we model the nor-
malized effects from a body in s1 to each component in s2.
The intuition behind this design is to leverage the global
relative information to augment body-component features,
and we use the inner product of two augmented features to
obtain the edge weight. Figure 5 illustrates the inference of
As1s2. Notably, different from the ﬁxed single-scale graphs
during inference, the cross-scale graphs are efﬁciently in-
ferred online and adaptive to motion features, which are
ﬂexible to capture distinct patterns for individual inputs.

We next fuse the joint features to the part-scale with
As1s2. Given the joint features at a certain time stamp
Xs1 ∈ RMs1 ×D(cid:48)

x, the part-scale feature is updated as
Xs2 ← As1s2 Xs1WF,s1 + Xs2 ∈ RMs2 ×D(cid:48)
x ,

where WF,s1 ∈ RD(cid:48)
x is trainable. Thus, each body-
part in s2 adaptively absorbs detailed information from the

x×D(cid:48)

rs2,k =

fs2 ([ps2,k, ps2,j − ps2,k]) (2c)

4.3. Difference operator

spatially corresponding components in coarser scales. For
example, we average two “right hand” joints in s1 to the
“right arm” part in s2. We then use a cascade of MGCUs
to extract spatio-temporal features. Note that the multi-
scale graph associated with each MGCU is trained individ-
ually, thus the graph topology can be dynamically chang-
ing from one MGCU to another. To ﬁnally combine the
three scales for comprehensive semantics, the output fea-
tures are weighted summed. Since the numbers of body-
components are different across scales, we broadcast the
coarser components to match their spatially corresponding
joints. Let the broadcast output features of the three scale
be Hs1 , Hs2 , Hs3 ∈ RT (cid:48)×M ×Dh, the summed feature is

H = Hs1 + λ(Hs2 + Hs3 ),

(3)

where λ is a hyper-parameter to balance different scales.
We next use a temporal average pooling to remove the time
dimension of H and obtain H ∈ RM ×Dh, which aggregates
historical information as the initial state of the decoder.

5.2. Decoder

The decoder aims to predict future poses sequentially.
The core of the decoder is the proposed graph-based GRU
(G-GRU), which further propagates motion states for se-
quence regression. We ﬁrst use the difference operator to
extract three orders of differences as motion priors, and then
feed them into G-GRU to update the hidden state. We next
generate future pose displacement with an output function.
Finally, we add the displacements to the input pose to pre-
dict the next frame. At frame t, the decoder works as
(cid:16)

(cid:16)

(cid:98)X(t+1) = (cid:98)X(t) + fpred

G-GRU

diﬀ 2( (cid:98)X(t)), H(t)(cid:17)(cid:17)

,

where fpred(·) represents an output function, implemented
by MLPs. The initial state H(0) = H, which is the ﬁnal
output of encoder.

5.3. Loss function

To train our DMGNN, we consider the (cid:96)1 loss. Let the
nth sample of predictions be ((cid:98)X1:Tf )n ∈ RTf ×M ×Dx and
the corresponding ground truth be (X1:Tf )n. For N training
samples, the loss function is

Lpred =

1
N

N
(cid:88)

n=1

(cid:13)
(cid:13)(X1:Tf )n − ((cid:98)X1:Tf )n
(cid:13)

(cid:13)
(cid:13)
(cid:13)1

,

where ||·||1 denotes the (cid:96)1 norm. (cid:96)1 loss gives sufﬁcient gra-
dients to joints with small losses to promote even more pre-
cise prediction; (cid:96)1 loss also gives stable gradients to joints
with large losses, alleviating gradient explosion. In our ex-
periments, (cid:96)1 loss leads to more precise predictions than (cid:96)2
loss. All the weights in the proposed DMGNN are trained
end-to-end with the stochastic gradient descent [4].

6. Experiments

6.1. Datasets and experimental setup

Human 3.6m (H3.6M). H3.6M dataset [19] has 7 sub-
jects performing 15 different classes of actions. There are
32 joints in each subject, and we transform the joint posi-
tions into the exponential maps and only use the joints with
non-zero values (20 joints remain). Along the time axis,
we downsample all sequences by two. Following previous
paradigms [33], the models are trained on 6 subjects and
tested on the speciﬁc clips of the 5th subject.

CMU motion capture (CMU Mocap). CMU Mocap
consists of 5 general classes of actions: ‘human interaction’,
‘interaction with environment’, ‘locomotion’, ‘physical ac-
tivities & sports’, and ‘situations & scenarios’, where each
subject has 38 joints and we preserve 26 joints with non-
zero exponential maps. Be consistent with [27], we select
8 detailed actions: ‘basketball’, ‘basketball signal’, ‘direct-
ing trafﬁc’, ‘jumping’, ‘running’, ‘soccer’, ‘walking’ and
‘washing window’. We evaluate our model with the same
approach as we do for H3.6M.

Model conﬁguration. We implement DMGNN with Py-
Torch 1.0 on one GTX-2080Ti GPU. We set 3 scales, which
contains body-joints, 10 and 5 body-components for both
datasets. We use 4 cascaded MGCUs, whose feature di-
mensions are 32, 64, 128 and 256, respectively. In the ﬁrst
two MGCUs, we use both SS-GCBs and CS-FBs to extract
spatio-temporal features and fuse cross-scale features; In
the last two MGCUs, we only use SS-GCBs. In the decoder,
the dimension of the G-GRU is 256, and we use a two-layer
MLP for pose output. In training, we set the batch size 32
and clip the gradients to a maximum (cid:96)2-norm of 0.5; we
use Adam optimizer [21] with learning rate 0.0001. All the
hyper-parameters are selected with validation sets.

Baseline methods. We compare the proposed DMGNN
with many recent works, which learned motion patterns
from pose vectors, e.g. Res-sup. [33], CSM [27], TP-
RNN [7], AGED [12], and Imit-L [43], or separated bod-
ies e.g. Skel-TNet [14], and Traj-GCN [32]. We repro-
duce, Res-sup., CSM and Traj-GCN based on their released
codes. We also employ a naive baseline, ZeroV [33], which
sets all predictions to be the last observed pose at t = 0.

6.2. Comparison to state-of-the-art methods

To validate the proposed DMGNN, we show the predic-
tion performance for both short-term and long-term motion
prediction on Human 3.6M (H3.6M) and CMU Mocap. We
quantitatively evaluate various methods by the mean angle
error (MAE) between the generated motions and ground-
truths in angle space. We also illustrate the predicted sam-
ples for qualitative evaluation.

Short-term motion prediction. Short-term motion pre-
diction aims to predict the future poses within 500 millisec-

Table 1. Mean angle errors (MAE) of different methods for short-term prediction on 4 representative actions of H3.6M. We also present
different DMGNN variants, including using ﬁxed graphs in SS-GCB (ﬁxed As), no graph in GRU (no G-GRU), and only one scale (single).
The complete DMGNN outperform others methods at most time stamp.

Motion
milliseconds
ZeroV [33]
Res-sup. [33]
CSM [27]
TP-RNN [7]
AGED [12]
Skel-TNet [14]
Imit-L [43]
Traj-GCN [32]
DMGNN (ﬁxed As)
DMGNN (no G-GRU)
DMGNN (S = 1)
DMGNN

Walking

Eating

Smoking

80
0.39
0.27
0.33
0.25
0.21
0.31
0.21
0.18
0.20
0.22
0.20
0.18

160
0.68
0.46
0.54
0.41
0.35
0.50
0.34
0.32
0.35
0.33
0.33
0.31

320
0.99
0.67
0.68
0.58
0.55
0.69
0.53
0.49
0.54
0.53
0.54
0.49

400
1.15
0.75
0.73
0.65
0.64
0.76
0.59
0.56
0.63
0.61
0.60
0.58

80
0.27
0.23
0.22
0.20
0.18
0.20
0.17
0.17
0.20
0.19
0.18
0.17

160
0.48
0.37
0.36
0.33
0.28
0.31
0.30
0.31
0.34
0.32
0.31
0.30

320
0.73
0.59
0.58
0.53
0.50
0.53
0.52
0.52
0.53
0.53
0.52
0.49

400
0.86
0.73
0.71
0.67
0.63
0.69
0.65
0.62
0.66
0.66
0.62
0.59

80
0.26
0.32
0.26
0.26
0.27
0.25
0.23
0.22
0.23
0.23
0.22
0.21

160
0.48
0.59
0.49
0.47
0.43
0.50
0.44
0.41
0.41
0.42
0.41
0.39

320
0.97
1.01
0.96
0.88
0.81
0.93
0.87
0.84
0.86
0.87
0.83
0.81

400
0.95
1.10
0.92
0.90
0.83
0.89
0.85
0.79
0.83
0.82
0.80
0.77

80
0.31
0.30
0.32
0.30
0.26
0.30
0.23
0.20
0.26
0.27
0.25
0.26

Discussion
320
160
0.94
0.67
0.98
0.67
0.94
0.67
0.96
0.66
0.77
0.56
0.89
0.64
0.82
0.56
0.79
0.51
0.92
0.65
0.90
0.65
0.95
0.64
0.92
0.65

400
1.04
1.06
1.01
1.04
0.84
0.98
0.91
0.86
1.02
0.98
1.00
0.99

Table 2. MAEs of different methods for short-term motion prediction on other 11 actions of H3.6M.

80

80

80

Posing

CSM [27]

Greeting
160 320 400

Directions
160 320 400

Phoning
Motion
millisecond
160 320 400
160 320 400
Res-sup [33] 0.41 0.64 0.80 0.92 0.57 0.83 1.45 1.60 0.59 1.06 1.45 1.60 0.45 0.85 1.34 1.56 0.58 0.79 1.08 1.15 0.41 0.68 1.12 1.33
0.39 0.60 0.80 0.91 0.51 0.82 1.21 1.38 0.59 1.13 1.51 1.65 0.29 0.60 1.12 1.37 0.63 0.91 1.19 1.29 0.39 0.61 1.02 1.18
Traj-GCN [32] 0.26 0.45 0.70 0.79 0.35 0.61 0.96 1.13 0.53 1.02 1.32 1.45 0.23 0.54 1.26 1.38 0.42 0.66 1.04 1.12 0.29 0.45 0.82 0.97
0.25 0.44 0.65 0.71 0.36 0.61 0.94 1.12 0.52 0.97 1.29 1.43 0.20 0.46 1.06 1.34 0.41 0.61 1.05 1.14 0.26 0.42 0.76 0.97

DMGNN
Average
Waiting
Motion
160 320 400
160 320 400
millisecond
Res-sup. [33] 0.47 0.88 1.37 1.54 0.28 0.57 0.90 1.02 0.32 0.63 1.07 1.26 0.52 0.89 1.25 1.40 0.27 0.53 0.74 0.79 0.40 0.69 1.04 1.18
0.41 0.78 1.16 1.31 0.23 0.49 0.88 1.06 0.30 0.62 1.09 1.30 0.59 1.00 1.32 1.44 0.27 0.52 0.71 0.74 0.38 0.68 1.01 1.13
Traj-GCN [32] 0.30 0.63 0.89 1.01 0.15 0.36 0.59 0.72 0.23 0.50 0.92 1.15 0.46 0.80 1.12 1.30 0.15 0.35 0.52 0.57 0.27 0.53 0.85 0.96
0.32 0.65 0.93 1.05 0.15 0.34 0.58 0.71 0.22 0.49 0.88 1.10 0.42 0.72 1.16 1.34 0.15 0.33 0.50 0.57 0.27 0.52 0.83 0.95

Walking Together
80

Purchases
160 320 400

160 320 400

160 320 400

160 320 400

160 320 400

160 320 400

Sitting Down

Taking Photo

Walking Dog

CSM [27]

DMGNN

Sitting

80

80

80

80

80

80

80

80

Table 3. MAEs of different methods for long-term prediction on
the 4 representative actions of H3.6M dataset.

1k

1k

560

560

Eating
1k

Smoking Discussion Average
Walking
Motion
560
1k
560
1k
milliseconds
1.35 1.32 1.04 1.38 1.02 1.69 1.41 1.96 1.21 1.59
ZeroV [33]
Res-sup. [33] 0.93 1.03 0.95 1.08 1.25 1.50 1.43 1.69 1.14 1.33
0.98 0.92 1.01 1.24 0.97 1.62 1.56 1.86 1.13 1.41
0.78 0.91 0.86 0.93 1.06 1.21 1.25 1.30 0.99 1.09
Skel-TNet [14] 0.94 0.92 0.97 1.23 0.99 1.59 1.51 1.82 1.10 1.39
0.67 0.69 0.79 1.13 0.95 1.63 1.34 1.81 0.94 1.32
Traj-GCN [32] 0.65 0.67 0.76 1.12 0.87 1.57 1.33 1.70 0.90 1.27
0.66 0.75 0.74 1.14 0.83 1.52 1.33 1.45 0.89 1.21

CSM [27]
AGED [12]

Imit-L [43]

DMGNN

560

onds. We compare DMGNN to state-of-the-art methods
for predicting poses in 400 milliseconds on H3.6M dataset.
We ﬁrst test 4 representative actions: ‘Walking’, ‘Eating’,
‘Smoking’ and ‘Discussion’. Table 16 shows MAEs of
DMGNN and some baselines. We also present the perfor-
mance of several variants of DMGNN: we use ﬁxed body-
graphs in SS-GCBs (ﬁxed As); the common GRU with-
out a graph (no G-GRU); or only the joint-scale (S = 1)
bodies. We see that, i) the complete DMGNN obtain the
most precise prediction among all the variants; ii) compared
to baselines, DMGNN has the lowest prediction MAEs on
‘Eating’ and ‘Smoking’, and obtains competitive results on
‘Walking’ and ‘Discussion’. Table 2 compares the proposed
DMGNN with some recent baselines on the remaining 11
actions in H3.6M. We see that DMGNN achieves the best
performance in most actions (also for average MAEs).

Long-term motion prediction. Long-term motion pre-
diction aims to predict the poses over 500 milliseconds,
which is challenging due to the action variation and non-
linearity movements. Table 3 presents the MAEs of various
models for predicting 4 actions and average MAEs across
the 4 actions in the future 560 ms and 1000 ms on H3.6M
dataset. We see that DMGNN outperforms the competitors
on actions ‘Eating’, and ‘Discussion’ at 560 ms, and obtains
competitive performances on other cases.

We also train our DMGNN for short-term and long-term
prediction on 8 classes of actions in CMU Mocap dataset.
Table 4 shows the MAEs across the future 1000 ms. We see
that DMGNN signiﬁcantly outperforms the state-of-the-art
methods on actions ‘Basketball’, ‘Basketball Signal’, ‘Run-
ning’ and ‘Walking’ and obtains competitive performance
on the other actions.

Predicted sample visualization. We compare the syn-
thesized samples of DMGNN to those of Res-sup., CSM
and Traj-GCN on H3.6M. Figure 6 illustrates the future
poses of ‘Taking Photo’ in 1000 ms with the frame inter-
val of 80 ms. Comparing to baselines, we see that DMGNN
completes the action accurately and reasonably, providing
signiﬁcantly better predictions. Res-sup. has large disconti-
nuity between the last observed pose the ﬁrst predicted one
(red box); CSM and Traj-GCN have large errors after the
280th ms (blue box); three baselines give large posture er-
rors in long-term (yellow box). We show more prediction

Table 4. Comparisons of MAEs between our model and the state-of-the-art methods on the 8 actions of CMU Mocap dataset. We evaluate
the model and present the MAEs at both short and long-term prediction time stamps.

160

Basketball
320

Motion
milliseconds
Res-sup. [33]
CSM [27]

80
400
0.49 0.77 1.26 1.45
0.36 0.62 1.07 1.17
Traj-GCN [32] 0.33 0.52 0.89 1.06
0.30 0.46 0.89 1.11

DMGNN
Motion
milliseconds
Res-sup. [33]
CSM [27]

160

80
400
0.32 0.48 0.65 0.74
0.28 0.43 0.54 0.57
Traj-GCN [32] 0.33 0.55 0.73 0.74
0.19 0.31 0.47 0.49

DMGNN

Running
320

1000
1.77
1.95
1.71
1.66

1000
1.00
0.69
0.95
0.64

Basketball Signal
80
400
320
160
0.42 0.76 1.33 1.54
0.33 0.62 1.05 1.23
0.11 0.20 0.41 0.53
0.10 0.17 0.31 0.41

Soccer
320

160

80
400
0.29 0.50 0.87 0.98
0.28 0.48 0.79 0.90
0.18 0.29 0.61 0.71
0.22 0.32 0.79 0.91

1000
2.17
1.98
1.00
1.26

1000
1.73
1.58
1.40
1.54

Directing Trafﬁc
80
400
320
160
0.31 0.58 0.94 1.10
0.26 0.58 0.91 1.04
0.15 0.32 0.52 0.60
0.15 0.30 0.57 0.72

Walking
320

160

80
400
0.35 0.45 0.59 0.64
0.35 0.44 0.46 0.51
0.33 0.45 0.49 0.53
0.30 0.34 0.38 0.43

1000
2.06
2.08
2.00
1.98

1000
0.88
0.77
0.61
0.60

Jumping
320

160

80
400
0.57 0.86 1.76 2.03
0.38 0.60 1.36 1.58
0.31 0.49 1.23 1.39
0.37 0.65 1.49 1.71
Washing Window
80
400
320
160
0.31 0.47 0.74 0.93
0.30 0.47 0.79 1.00
0.22 0.33 0.57 0.75
0.20 0.27 0.62 0.81

1000
2.42
2.05
1.80
1.79

1000
1.37
1.39
1.20
1.09

400
1.00
0.97
0.95
0.92
0.98
0.97
0.99
1.00

Table 6. Average MAEs of DMGNN with different scales for
short-term prediction at different time stamps.
Node numbers Ms
5

MAEs

10

3

2

20
(cid:88)
(cid:88) (cid:88)
(cid:88) (cid:88) (cid:88)
(cid:88)
(cid:88)

Scales
1
1, 2
1, 2, 3
1, 3
1, 2, 3, 4 (cid:88) (cid:88) (cid:88) (cid:88)
(cid:88)
(cid:88)
1, 4
1, 2, 3, 5 (cid:88) (cid:88) (cid:88)
(cid:88)
1, 5

80
0.29
0.27
0.27
0.28
0.28
0.28
(cid:88) 0.28
(cid:88) 0.29

160
0.55
0.53
0.52
0.53
0.54
0.54
0.55
0.55

320
0.87
0.85
0.83
0.84
0.87
0.86
0.86
0.87

Table 7. MAEs and running times of DMGNN with different num-
bers of MGCUs for short and long-term prediction on H3.6M.

MGCUs
1
2
3
4
5
6

MAE at different time stamps (ms)

80
0.30
0.29
0.27
0.27
0.28
0.29

160
0.56
0.53
0.54
0.52
0.55
0.54

320
0.87
0.85
0.83
0.83
0.83
0.84

400
1.02
0.99
0.95
0.95
0.96
0.98

560
1.25
1.20
1.18
1.16
1.17
1.19

1000
1.52
1.52
1.49
1.48
1.51
1.54

running time (ms)
400
27.42
27.89
28.34
29.18
30.37
31.55

1000
83.01
83.95
84.89
86.04
88.39
91.15

Table 8. Average MAEs of DMGNN with different numbers of
CS-FBs and feature aggregators over 400 ms on H3.6M.
Average MAE across 400 ms

CS-FB numbers
without relative
with relative

1
0.623
0.618

2
0.622
0.613

3
0.618
0.616

0

0.630

tion error is achieved. Notably, using two scales (s1, s2 or
s1, s3) is signiﬁcant better than using only s1; but involving
too abstract scales (s4 or s5) tends to hurt prediction.

Effects of the number of MGCUs. To validate the ef-
fects of multiple MGCUs in the encoder, we tune the num-
bers of MGCUs from 1 to 6 and show the prediction errors
and running time costs for short and long-term prediction
on H3.6M, which are presented in Table 7. We see that,
when we adopt 1 to 4 MGCUs, the prediction MAEs fall
and time costs rise continuously; when we use 5 or 6 MG-
CUs, the prediction errors are stably low, but the time costs
rise higher. Therefore, we select to use 4 MGCUs, resulting
in precise prediction and high running efﬁciency.

Effects of CS-FBs. Here, we evaluate 1) the effective-
ness of using relative features during cross-scale graph in-
ference in CS-FBs; 2) different numbers of CS-FBs in a

Figure 6. Qualitative comparison on the action ‘Taking Photo’ of
H3.6M for both short and long-term prediction.

Table 5. Average time cost comparison between DMGCNN with
the latest models on H3.6M dataset.

Time cost (ms)

Model
milisecond
TP-RNN [7]
Skel-TNet [14]
Traj-GCN [32]
DMGNN

400
48.96
33.29
71.43
29.18

1000
127.41
98.17
144.93
86.04

images and videos in Appendix.

Effectiveness and efﬁciency test. We compare the run-
ning time costs of DMGNN to several latest models. Table 5
presents the running time of different methods for short and
long-term motion prediction on H3.6M dataset. We see that
DMGNN achieves the shortest running time while generat-
ing future poses over both 400 or 1000 ms, compared with
the other competitors [33, 27, 32]. DMGNN takes only
29.18 ms to generate motions in 400 ms, indicating that
DMGNN with multiscale graphs has efﬁcient operations.

6.3. Ablation study

We now investigate some crucial elements of DMGNN.
Effects of multiple scales. To verify the proposed multi-
scale representation, we employ various scales in DMGNN
for 3D skeleton-based motion prediction. Besides the three
scales in our model, we introduce additional two scales: s4,
which represents a body as Ms4 = 3 parts: left limbs, right
limbs and torso, and s5, which contains Ms5 = 2 parts: up-
per body and lower body; see illustrations of s4 and s5 in
Appendix. Table 6 presents the MAEs with various scales.
We see that, when we combine s1, s2 and s3, lowest predic-

Table 9. Average MAEs for different orders of motion differences.

Difference Order
β = 0
β = 0, 1
β = 0, 1, 2

MAE at different time stamps (ms)

80
0.34
0.28
0.27

160
0.60
0.54
0.52

320
0.86
0.83
0.83

400
1.01
0.97
0.95

Figure 7. Average MAEs of DMGNN variants with different ﬁnal
fusion coefﬁcient λ for short-term motion prediction.

sequence of 4 MGCUs. For 0 CS-FB, the model only fuses
all scales at the end of the encoder. Table 8 presents the
average MAEs with different CS-FBs and relative-feature
mechanisms across 400 ms on H3.6M. We see that 1) using
relative features leads to lower MAEs, validating the effec-
tiveness of such augmented features; 2) 2 CS-FBs leads to
the best prediction performance. The intuition is that 0 or 1
CS-FB fuse insufﬁciently and 3 CS-FBs tend to fuse redun-
dant information to confuse the model.

Effect of λ in ﬁnal fusion. The hyper-parameter λ in the
ﬁnal fusion (3) balances the inﬂuence between joint-scale
and more abstract scales. Figure 7 illustrates the average
MAE with different body scales and CS-FBs for short-term
prediction on H3.6M. We see that the performance reach
its best when we use 3 scales, 2 hierarchical CS-FBs and
λ = 0.6, even though it is robust to the change of λ.

Effect of high-order motion differences. We study the
effects of various orders of motion differences fed into the
encoder and decoder of our model. We evaluate DMGNN
with combinations of 0, 1, 2-orders of pose differences. Ta-
ble 9 presents the MAEs of DMGNN with various input dif-
ferences for short-term motion prediction. We see that the
proposed DMGNN obtains the lowest MAEs when it adopts
the 0, 1, 2-orders of motion differences. This indicates that
high-order differences improve the prediction performance
signiﬁcantly.

6.4. Analysis of category-agnostic property

Here we validate that DMGNN can learn discriminative

motion features for category-agnostic prediction.

We ﬁrst visualize the learned cross-scale graphs for dif-
ferent actions to test the discriminative power. Figure 8
shows the graphs in two CS-FBs on ‘Walking’ and ‘Direc-

Figure 8. The learned dynamic cross-scale graphs on two CS-FBs
for two actions: ‘Walking’ and ‘Directions’ in H3.6M.

Table 10. Classiﬁcation accuracies on cross-scale graphs and mo-
tion features of DMGNN and other methods on H3.6M.
Methods On CS-FB 1 On CS-FB 2 On H Res-sup. [33] TP-RNN [7]
Accuracy

24.4%

28.6%

40.1%

45.7%

22.6%

tions’ in H3.6M. For each action, we show some strong
relations from detailed scales to the right arms in coarse
scales. We see that i) for each action, the CS-FBs capture
diverse ranges of a human body: the graph in the ﬁrst CS-
FB focuses on nearby body-components; the second CS-FB
captures more global and action-related effects; i.e. hands
and feet affects arms during walking; and ii) the cross-scale
graphs are different for various actions, especially in the
second CS-FB, capturing distinct patterns.

We next conduct action classiﬁcation on the intermedi-
ate representations to test the discriminative power. We
isolatedly train a two-layer MLP to classify each dynamic
cross-scale graph. We also classify the outputs from the en-
coders of DMGNN, Res-sup. (class-aware) and TP-RNN
(class-agnostic). Table 10 presents the average classiﬁca-
tion accuracies on 15 categories of actions. We see that
the cross-scale graph in the second CS-FB is more informa-
tive than the one in the ﬁrst CS-FB for action recognition.
Comparing to baselines, DMGNN obtains the highest the
classiﬁcation accuracies on encoder representation, indicat-
ing that DMGNN captures discriminative information for
class-agnostic prediction.

7. Conclusion

We build dynamic mutiscale graphs to represent a hu-
man body and propose dynamic multiscale graph neural
networks (DMGNN) with an encoder-decoder framework
for 3D skeleton-based human motion prediction.
In the
encoder, We develop multiscale graph computational units
(MGCU) to extract features; in the decoder, we develop a
graph-based GRU (G-GRU) for pose generation. The re-
sults show that the proposed model outperforms most state-
of-the-art methods for both short and long-trem prediction
in terms of both effectiveness and efﬁciency.

Acknowledgement: This work is supported by the Na-
tional Key Research and Development Program of China
2018-RGZN-
(No.
02046), NSFC (No. 61521062), 111 plan (No. B07022),
and STCSM (No. 18DZ2270700).

2019YFB1804304), SHEITC (No.

References

[1] Alexandre Alahi, Kratarth Goel, Vignesh Ramanathan,
Alexandre Robicquet, Feifei Li, and Silvio Savarese. Social
lstm: Human trajectory prediction in crowded spaces. In The
IEEE Conference on Computer Vision and Pattern Recogni-
tion (CVPR), pages 961–971, June 2016.

[2] Emad Barsoum, John Kender, and Zicheng Liu. Hp-gan:
In The
Probabilistic 3d human motion prediction via gan.
IEEE Conference on Computer Vision and Pattern Recogni-
tion (CVPR) Workshops, pages 1531–1540, June 2018.
[3] Apratim Bhattacharyya, Mario Fritz, and Bernt Schiele.
Long-term on-board prediction of people in trafﬁc scenes
In The IEEE Conference on Computer
under uncertainty.
Vision and Pattern Recognition (CVPR), pages 4194–4202,
June 2018.

[4] Lon Bottou. Large-scale machine learning with stochas-
tic gradient descent. In International Conference on Com-
putational Statistics (COMPSTAT), pages 177–187, August
2010.

[5] Judith Butepage, Michael Black, Danica Kragic, and Hed-
vig Kjellstrom. Deep representation learning for human mo-
tion prediction and classiﬁcation. In The IEEE Conference
on Computer Vision and Pattern Recognition (CVPR), pages
1591–1599, July 2017.

[6] Siheng Chen, Baoan Liu, Chen Feng, Carlos Vallespi-
Gonzalez, and Carl Wellington. 3d point cloud processing
and learning for autonomous driving. IEEE Signal Process-
ing Magazine Special Issue on Autonomous Driving, 2020.

[7] Hsukuang Chiu, Ehsan Adeli, Borui Wang, DeAn Huang,
and Juan Niebles. Action-agnostic human pose forecasting.
CoRR, abs/1810.09676, 2018.

[8] Micha¨el Defferrard, Xavier Bresson, and Pierre Van-
dergheynst. Convolutional neural networks on graphs with
In Advances in Neural In-
fast localized spectral ﬁltering.
formation Processing Systems (NeurIPS), pages 3844–3852,
December 2016.

[9] Katerina Fragkiadaki, Sergey Levine, Panna Felsen, and Ji-
tendra Malik. Recurrent network models for human dynam-
ics. In The IEEE International Conference on Computer Vi-
sion (ICCV), pages 4346–4354, December 2015.

[10] Partha Ghosh, Jie Song, Emre Aksan, and Otmar Hilliges.
Learning human motion models for long-term predictions.
CoRR, abs/1704.02827, 2017.

[11] Anand Gopalakrishnan, Ankur Mali, Dan Kifer, Lee Giles,
and Alexander Ororbia. A neural temporal model for human
motion prediction. In The IEEE Conference on Computer Vi-
sion and Pattern Recognition (CVPR), pages 12116–12125,
June 2019.

[12] Liangyan Gui, Yuxiong Wang, Xiaodan Liang, and Jose
Moura. Adversarial geometry-aware human motion pre-
In The European Conference on Computer Vision
diction.
(ECCV), pages 786–803, September 2018.

[13] Liangyan Gui, Kevin Zhang, Yuxiong Wang, Xiaodan Liang,
Jose Moura, and Manuela Veloso. Teaching robots to predict
In IEEE/RSJ International Conference on
human motion.
Intelligent Robots and Systems (IROS), October 2018.

[14] Xiao Guo and Jongmoo Choi. Human motion prediction
via learning local structure representations and temporal de-
pendencies. In AAAI Conference on Artiﬁcial Intelligence,
February 2019.

[15] Ankur Gupta, Julieta Martinez, James Little, and Robert
Woodham. 3d pose from motion for cross-view action recog-
In The
nition via non-linear circulant temporal encoding.
IEEE Conference on Computer Vision and Pattern Recogni-
tion (CVPR), pages 2061–2068, June 2014.

[16] Will Hamilton, Zhitao Ying, and Jure Leskovec. Inductive
representation learning on large graphs. In Advances in Neu-
ral Information Processing Systems (NeurIPS), pages 1024–
1034, December 2017.

[17] Dean Huang and Kris Kitani. Action-reaction: Forecasting
the dynamics of human interaction. In The European Con-
ference on Computer Vision (ECCV), pages 489–504, July
2014.

[18] Du Huynh. Metrics for 3d rotations: Comparison and analy-
sis. Journal of Mathematical Imaging and Vision, 35(2):155–
164, October 2009.

[19] Catalin Ionescu, Dragos Papava, Vlad Olaru, and Cristian
Sminchisescu. Human3.6m: Large scale datasets and predic-
tive methods for 3d human sensing in natural environments.
IEEE Transactions on Pattern Analysis and Machine Intelli-
gence (TPAMI), 36(7):1325–1339, July 2014.

[20] Ashesh Jain, Amir Zamir, Silvio Savarese, and Ashutosh
Saxena. Structural-rnn: Deep learning on spatio-temporal
In The IEEE Conference on Computer Vision and
graphs.
Pattern Recognition (CVPR), pages 5308–5317, June 2016.
[21] Diederik Kingma and Jimmylei Ba. Adam: A method
for stochastic optimization. In International Conference on
Learning Representations (ICLR), pages 1–15, May 2015.

[22] Thomas Kipf and Max Welling. Semi-supervised classiﬁ-
cation with graph convolutional networks. In International
Conference on Learning Representations (ICLR), pages 1–
14, April 2017.

[23] Hema Koppula and Ashutosh Saxena. Learning spatio-
temporal structure from rgb-d videos for human activity de-
tection and anticipation. In International Conference on Ma-
chine Learning (ICML), pages 792–800, June 2013.

[24] Hema Koppula and Ashutosh Saxena. Anticipating human
activities using object affordances for reactive robotic re-
sponse. IEEE Transactions on Pattern Analysis and Machine
Intelligence (TPAMI), 38(1):14–29, January 2016.

[25] JogendraNath Kundu, Maharshi Gor, and RVenkatesh Babu.
Bihmp-gan: Bidirectional 3d human motion prediction gan.
In AAAI Conference on Artiﬁcial Intelligence, February
2019.

[26] Andreas Lehrmann, Peter Gehler, and Sebastian Nowozin.
Efﬁcient nonlinear markov models for human motion. In The
IEEE Conference on Computer Vision and Pattern Recogni-
tion (CVPR), pages 1314–1321, June 2014.

[27] Chen Li, Zhen Zhang, Wee Sun Lee, and Gim Hee Lee. Con-
volutional sequence to sequence model for human dynamics.
In The IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), pages 5226–5234, June 2018.

[28] Maosen Li, Siheng Chen, Xu Chen, Ya Zhang, Yanfeng
Wang, and Qi Tian. Actional-structural graph convolutional

[42] Jacob Walker, Kenneth Marino, Abhinav Gupta, and Mar-
tial Hebert. The pose knows: Video forecasting by generat-
ing pose futures. In The IEEE International Conference on
Computer Vision (ICCV), pages 3332–3341, October 2017.
[43] Borui Wang, Ehsan Adeli, Hsukuang Chiu, Dean Huang, and
JuanCarlos Niebles. Imitation learning for human pose pre-
diction. In The IEEE International Conference on Computer
Vision (ICCV), October 2019.

[44] He Wang, Edmond Ho, Hubert Shum, and Zhanxing Zhu.
Spatio-temporal manifold learning for human motions via
long-horizon modeling. IEEE Transactions on Visualization
and Computer Graphics (TVCG), PP(99), August 2019.
[45] Jack Wang, Aaron Hertzmann, and David Fleet. Gaussian
process dynamical models. In Advances in Neural Informa-
tion Processing Systems (NeurIPS), pages 1441–1448, De-
cember 2006.

[46] Tianfan Xue, Jiajun Wu, Katherine Bouman, and Bill Free-
man. Visual dynamics: Probabilistic future frame synthesis
via cross convolutional networks. In Advances in Neural In-
formation Processing Systems (NeurIPS), pages 91–99. De-
cember 2016.

[47] Sijie Yan, Yuanjun Xiong, and Dahua Lin. Spatial tempo-
ral graph convolutional networks for skeleton-based action
In AAAI Conference on Artiﬁcial Intelligence
recognition.
(AAAI), pages 7444–7452, February 2018.

[48] Long Zhao, Xi Peng, Yu Tian, Mubbasir Kapadia, and Dim-
itris N. Metaxas. Semantic graph convolutional networks for
3d human pose regression. In The IEEE Conference on Com-
puter Vision and Pattern Recognition (CVPR), pages 3425–
3435, June 2019.

networks for skeleton-based action recognition. In The IEEE
Conference on Computer Vision and Pattern Recognition
(CVPR), pages 3595–3603, June 2019.

[29] Maosen Li, Siheng Chen, Xu Chen, Ya Zhang, Yanfeng
Wang, and Qi Tian. Symbiotic graph neural networks for
3d skeleton-based human action recognition and motion pre-
diction. CoRR, abs/1910.02212, 2019.

[30] Yujia Li, Daniel Tarlow, Marc Brockschmidt, and Richard
In Inter-
Zemel. Gated graph sequence neural networks.
national Conference on Learning Representations (ICLR),
pages 1–20, May 2016.

[31] Zhenguang Liu, Shuang Wu, Shuyuan Jin, Qi Liu, Shijian
Lu, Roger Zimmermann, and Li Cheng. Towards natural and
accurate future motion prediction of humans and animals.
In The IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), pages 10004–10012, June 2019.
[32] Wei Mao, Miaomiao Liu, Mathieu Salzmann, and Hongdong
Li. Learning trajectory dependencies for human motion pre-
diction. In The IEEE International Conference on Computer
Vision (ICCV), October 2019.

[33] Julieta Martinez, Michael Black, and Javier Romero. On
human motion prediction using recurrent neural networks.
In The IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), pages 4674–4683, July 2017.

[34] Dario Pavllo, David Grangier, and Michael Auli. Quater-
net: A quaternion-based recurrent model for human motion.
In British Machine Vision Converence (BMVC), pages 1–14,
September 2018.

[35] Lei Shi, Yifan Zhang, Jian Cheng, and Hanqing Lu.
Skeleton-based action recognition with directed graph neural
networks. In The IEEE Conference on Computer Vision and
Pattern Recognition (CVPR), pages 7912–7921, June 2019.
[36] Chenyang Si, Ya Jing, Wei Wang, Liang Wang, and Tieniu
Tan. Skeleton-based action recognition with spatial reason-
ing and temporal stack learning. In The European Confer-
ence on Computer Vision (ECCV), pages 103–118, Septem-
ber 2018.

[37] Ilya Sutskever, Geoffrey Hinton, and Graham Taylor. The re-
current temporal restricted boltzmann machine. In Advances
in Neural Information Processing Systems (NeurIPS), pages
1601–1608, December 2009.

[38] Graham Taylor and Geoffrey Hinton. Factored conditional
restricted Boltzmann machines for modeling motion style.
In International Conference on Machine Learning (ICML),
pages 1025–1032, June 2009.

[39] Graham Taylor, Geoffrey Hinton, and Sam Roweis. Model-
ing human motion using binary latent variables. In Advances
in Neural Information Processing Systems (NeurIPS), pages
1345–1352, December 2007.

[40] Diego Valsesia, Giulia Fracastoro, and Enrico Magli. Learn-
ing localized generative models for 3d point clouds via graph
convolution. In International Conference on Learning Rep-
resentations (ICLR), pages 1–15, May 2019.

[41] Nitika Verma, Edmond Boyer, and Jakob Verbeek. Feast-
net: Feature-steered graph convolutions for 3d shape analy-
sis. In The IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), pages 2598–2606, June 2018.

Shape & Operations
[32, 3, 1, 1] × 2
-bn-relu
[32, 32, 5, 1], stride=1
bn-dropout-relu
[64, 32, 1, 1] × 2
-bn-relu
[64, 64, 5, 1], stride=2
bn-dropout-relu
[128, 64, 1, 1] × 2
-bn-relu
[128, 128, 5, 1], stride=2
bn-dropout-relu
[256, 128, 1, 1] × 2
-bn-relu
[256, 256, 5, 1], stride=2
bn-dropout-relu

1

2

3

4

8. Detailed Architecture

Here we show the detailed structure of the proposed
DMGNN. We ﬁrst show the structure of the encoder, in-
cluding the single-scale graph convolution block (SS-GCB)
and cross-scale fusion block (CS-FB). We then show the
structure of the decoder, including the graph-based gated
recurrent unit (G-GRU).

8.1. Encoder

Single-scale graph convolution block (SS-GCB). SS-
GCB consists of a graph convolution and a temporal convo-
lution. Table 11 presents the structures of four cascaded SS-
GCB at scale s in the encoder of DMGNN. We see that we

Table 11. The structure of four SS-GCBs at scale s in the encoder.
Idx

Remarks

Feature

[32, 32, Ms, 49]

graph conv

[32, 32, Ms, 49]

temporal conv

[32, 64, Ms, 49]

graph conv

ploy a softmax to calculate the corresponding edge weight
in a cross-scale graph.

Total architecture In summary, we show the total archi-
tecture of the encoder, which combine SS-GCBs at multiple
scales and CS-FB across scales. Table 13 presents the struc-
ture of the encoder. We see that we use four MGCUs, where

MGCU

1

2

3
4

Table 13. The structure of the encoder.

SS-GCB 1 at s1

SS-GCB 1 at s3

SS-GCB 2 at s1

SS-GCB 2 at s3

SS-GCB 3 at s1
SS-GCB 4 at s1

SS-GCB 3 at s3
SS-GCB 4 at s3

Initialize three scales
SS-GCB 1 at s2
CS-FB 1 between s1&s2 and s2&s3
SS-GCB 2 at s2
CS-FB 2 between s1&s2 and s2&s3
SS-GCB 3 at s2
SS-GCB 4 at s2
Weighted sum
A ﬁnal SS-GCB at s1
Temporal average pooling

the ﬁrst two MGCUs use SS-GCBs and CS-FBs to learn the
features from multiscale bodies and the last two MGCUs
only use SS-GCB to extract features.

[32, 64, Ms, 25]

temporal conv

8.2. Decoder

[32, 128, Ms, 25]

graph conv

[32, 128, Ms, 13]

temporal conv

[32, 256, Ms, 13]

graph conv

Graph-based Gated Recurrent Unit (G-GRU) G-
GRU is one of the key components in the proposed decoder
for synthesizing precise and reasonable future poses. Ta-
ble 14 presents the structure of the G-GRU at time stamp t.
We see that we take the historical motion state and the on-

[32, 256, Ms, 7]

temporal conv

Variables

Table 14. The structure of the G-GRU in the decoder at time t.

use four SS-GCBs to extract spatio-temporal motion fea-
tures. In each SS-GCB, we employ ReLU, batch normal-
ization, and dropout operations. We use stride 2 to down-
sample along the temporal dimension.

Cross-scale fusion block (CS-FB) We use CS-FB to
fuse multiscale features. Table 12 presents the structure
of the ﬁrst CS-FB to fuse the feature from s1 to s2. We

Table 12. The structure of the ﬁrst CS-FB from s1 to s2.
Step
1

Shape & Operations
temporal conv: [32, 32, 5, 1], stride=2; vectorize
for both fs1 and fs2 : 800-256-relu
-dropout-256-relu-bn; Sum
for both gs1 and gs2 : 512-256-relu
-dropout-256-relu-bn
Computing (2e) in paper

2

3

ﬁrst use a temporal convolution to shrink the temporal di-
mension and obtain a compact feature vector for each body-
component; we then use four MLPs to learn the feature em-
beddings for two body-scales, respectively; we ﬁnally cal-
culate the inner product of these two embeddings and em-

Operations
input: H(t), I(t); rin: 9 → 256
graph conv: 256 → 256; rhid: 256 → 256
sum and sigmoid
input: H(t), I(t); uin: 9 → 256
graph conv: 256 → 256; uhid: 256 → 256
sum and sigmoid
input: H(t), I(t); cin: 9 → 256
graph conv: 256 → 256; chid: 256 → 256
element-wise product of chid and r(t)
sum and tanh
u(t) (cid:12) H(t) + (1 − u(t)) (cid:12) c(t)

r(t)

u(t)

c(t)

H(t+1)

line 3D skeleton-based information as inputs and introduce
the graph convolution to propagate the motion information
to produce the motion state at the next frame. The hidden
dimension of the G-GRU is 256.

Total architecture Here, we show the total architecture
of the decoder, which combines the proposed G-GRU and
an MLP-formed output function. Table 15 presents the
structure the decoder at time stamp t. We see that, given
the hidden motion state and current input information, we
use a G-GRU and an MLP-formed output function fpred to
model the displacement of motions between two consecu-

Table 15. The structure of the decoder at time t.

Operations
H(t), I(t) = [ (cid:98)X(t), ∆1 (cid:98)X(t), ∆2 (cid:98)X(t)]

Inputs
G-GRU H(t+1) = G-GRU(I(t), H(t)), 9, 256 → 256
fpred
(cid:98)X(t+1)

fpred(H(t+1)), 256 → 256 → 3
(cid:98)X(t+1) = (cid:98)X(t) + fpred(H(t+1))

tive frames, and we emply residual connections to obtain
the estimated poses. The hidden dimensions are 256.

9. Quantitative Comparison with more Base-

lines

In our paper submission, we only compare DMGNN to
several state-of-the-art works, while many other methods
has been developed. Here we compare DMGNN to as many
previous methods as possible. Table 16 presents the MAE
of many methods for short-term motion prediction on 4 rep-
resentative actions of Human 3.6M We see that, the pro-
posed DMGNN outperforms the state-of-the-art methods on
most actions. Notably, we have cited all of baselines pre-
sented in Table 16 in our paper submission.

10. Coarser Body-scales in Ablation Studies

In the ﬁrst experiment of ablation studies (‘effects of
multiple scales’), we initialize two coarser body-scales (s4
and s5) besides the effective three scales (s1, s2 and s3) that
used in our DMGNN. Here we present s4 and s5 in details.
To initialize s4, we average the input features of three
left-body, head-and-torso, and right-
body-components:
body as the nodes of corresponding body-graph. We build
two initial edges to respectively connect head-and-torso
with left-body and right-body. To initialize s5, we average
the input features of two body-components: upper-body and
lower-body as the graph nodes. We build an edge between
these two body-components. Figure 9 illustrates the two
coarser body-scales as well as the body-joint scale on Hu-
man 3.6M [19]. We name s4 as ‘Left-right-body scale’ and
name s5 as ‘Up-low-body scale’.

11. Effects of Numbers and Positions of CS-

FBs

In our DMGNN, we employ CS-FBs with aggregating
relative features at different MGCUs to fuse various levels
of motion features across different scales; see Equation (2a)
in the submission. Here we further investigate the effects
of numbers and positions of CS-FBs at cascaded MGCUs.
In the four MGCUs, we use one to four CS-FBs at different
MGCUs, and we obtain the average prediction MAEs of
different model variants.

Table 17 presents the average MAEs of DMGNN with
different numbers of CS-FBs at different MGCUs on

Figure 9. Three body scales on Human 3.6M. In body-joint scale,
we consider 20 joints with non-zero exponential maps [18]; In s4
and s5, we consider 3 and 2 parts, respectively.

H3.6M for short-term motion prediction. We also compare
the performance of CS-FBs with or without aggregating rel-
ative information from all the body-components (‘with rel-
ative’ or ‘without relative’). We denote the numbers of CS-
FBs at the column ‘Number’ and denote the CS-FB posi-
tions as MGCU indices at column ‘Position’. We see that
1) when we aggregate global relative information to in the
CS-FB, we obtain lower MAEs than the module without
relative information aggregation; 2) when we use two CS-
FBs with relative information aggregation at the 1st and 2nd
MGCUs, DMGNN produces the most precise predictions
across different model variants; 3) fusing multiscale fea-
tures at ﬁrst few MGCUs outperforms fusing at last ones.
The reason behind could be, if we use only one CS-FB, we
cannot fuse rich features for comprehensive pattern learn-
ing; if we use too many CS-FBs, the capacity of the network
become much larger, leading to overﬁtting.

12. More Generated Motion Samples

To further demonstrate the effectiveness of the AS-
GNN, we illustrate more predicted samples on both Human
3.6M [19] and CMU Mocap 2 dataset.

12.1. Human 3.6M Dataset

We ﬁrst illustrate two generated motions of the actions
of ‘Posing’ and ‘Waiting’ on Human 3.6 dataset (H3.6). We
compare the DMGNN with three models: Res-sup. [33],
CSM [27] and Traj-GCN [32].

Figure 10 illustrates the predicted poses of ‘Posing’
in Human 3.6M in 1000 ms. We see that the proposed
DMGNN could well model the posture, such as stretched

2http://mocap.cs.cmu.edu/

Eating

Smoking

Table 16. Mean angle errors (MAE) of different methods for short-term prediction on 4 representative actions of H3.6M.
Motion
milliseconds
ZeroV [33]
ERD [9]
LSTM-3R [9]
SRNN [20]
DropAE [10]
Res-sup. [33]
CSM [27]
TP-RNN [7]
QuaterNet [34]
AGED [12]
Skel-TNet [14]
BiHMP-GAN [25]
VGRU-r1 [11]
HMR [31]
Imit-L [43]
Traj-GCN [32]
DMGNN

Discussion
320
160
0.94
0.67
0.94
0.67
2.25
2.12
1.83
1.49
1.38
1.20
0.98
0.67
0.94
0.67
0.96
0.66
0.85
0.60
0.77
0.56
0.89
0.64
0.91
0.65
0.95
0.82
0.83
0.55
0.82
0.56
0.79
0.51
0.92
0.65

Walking
160
0.68
1.18
1.00
0.94
1.11
0.46
0.54
0.41
0.34
0.35
0.50
0.52
0.47
0.35
0.34
0.32
0.31

80
0.39
0.93
0.977
0.81
1.00
0.27
0.33
0.25
0.21
0.21
0.31
0.33
0.34
0.23
0.21
0.18
0.18

400
1.15
1.78
1.47
1.30
/
0.75
0.73
0.65
0.62
0.64
0.76
0.67
0.72
0.65
0.59
0.56
0.58

320
0.73
1.66
1.35
1.35
1.86
0.59
0.58
0.53
0.58
0.50
0.53
0.54
0.64
0.55
0.52
0.52
0.49

80
0.31
0.31
1.88
1.22
1.11
0.30
0.32
0.30
0.26
0.26
0.30
0.33
0.46
0.29
0.23
0.20
0.26

400
0.86
1.80
1.46
1.46
/
0.73
0.71
0.67
0.70
0.63
0.69
0.70
0.79
0.67
0.65
0.62
0.59

160
0.48
1.45
1.09
1.14
1.49
0.37
0.36
0.33
0.35
0.28
0.31
0.33
0.40
0.32
0.30
0.31
0.30

320
0.99
1.59
1.29
1.16
1.39
0.67
0.68
0.58
0.56
0.55
0.69
0.63
0.64
0.56
0.53
0.49
0.49

400
0.95
2.42
2.16
2.08
/
1.10
0.92
0.90
0.90
0.83
0.89
0.86
0.92
0.89
0.85
0.79
0.77

80
0.27
1.27
0.89
0.97
1.31
0.23
0.22
0.20
0.20
0.18
0.20
0.20
0.27
0.21
0.17
0.17
0.17

160
0.48
1.95
1.65
1.68
1.03
0.59
0.49
0.47
0.47
0.43
0.50
0.50
0.61
0.47
0.44
0.41
0.39

320
0.97
2.35
2.04
1.94
1.15
1.01
0.96
0.88
0.93
0.81
0.93
0.91
0.85
0.90
0.87
0.84
0.81

80
0.26
1.66
1.34
1.45
0.92
0.32
0.26
0.26
0.25
0.27
0.25
0.26
0.36
0.26
0.23
0.22
0.21

400
1.04
1.04
2.23
1.93
/
1.06
1.01
1.04
0.93
0.84
0.98
0.95
1.21
0.94
0.91
0.87
0.99

Table 17. Average MAEs of DMGNN with different numbers of
CS-FBs at different MGCUs on H3.6M across 400 ms.
Number Position MAE (without relative) MAE (with relative)

1
2
3
4
1,2
1,3
1,4
2,3
2,4
3,4
1,2,3
1,2,4
1,3,4
2,3,4
1,2,3,4
/

1

2

3

4
0

0.621
0.620
0.620
0.622
0.620
0.619
0.621
0.622
0.622
0.625
0.622
0.623
0.624
0.625
0.622

0.630

0.621
0.618
0.616
0.619
0.613
0.614
0.615
0.616
0.617
0.620
0.616
0.619
0.622
0.622
0.619

Figure 10. Predicted samples of the action of ‘Posing’ in Human
3.6M dataset from four models in a long term.

bodies and arms; however, Res-sup predicts the motion with
large discontinuity between the last observed pose the ﬁrst
predicted one (red box); CSM and Traj-GCN tends to have
large errors after the 400th ms (blue box); all the baselines

Figure 11. Predicted samples of the action of ‘Waiting’ in Human
3.6M dataset from four models in a long term.

produce unreasonable poses at the 1000th ms (yellow box),
which are far from the ground truth.

We also predict the action of ‘Waiting’ in Human 3.6M
in a long term with different methods. The results are illus-
trated in Figure 11. We see that, for baselines, the motion
predicted by res-sup has large discontinuity between the last
observed pose the ﬁrst predicted one (red box) and loses the
movements, which is far from the ground truths. CSM and
Traj-GCN suffer from large errors after the 320th ms; all the
baselines predict unreasonable poses at the 1000th ms (yel-
low box); but the predictions from DMGNN could complete
the action reasonably.

12.2. CMU Mocap Dataset

We then test DMGNN on the two actions of ‘Basketball’
and ‘Washing window’ in CMU Mocap dataset. The base-
lines are the CSM [27] and Traj-GCN [32].

For the action of ‘Basketball’, the main challenge of mo-
tion prediction is the running legs and swaying arms. We il-
lustrate the generated samples of three models in Figure 13.
We see that the errors of the predictions from CSM and
Traj-GCN rise after the 320th ms (blue box); two baselines

Figure 12. Predicted samples of the action of ‘Basketball’ in CMU
Mocap dataset from three models in a long term.

Figure 13. Predicted samples of the action of ‘Washing window’
in CMU Mocap dataset from three models in a long term.

give unreasonable postures at the 1000th ms in long-term
(yellow box); that is, CSM has wrong tilt orientation of the
body and the left leg (purple) of the pose predicted by Traj-
GCN has inaccurate position; DMGNN could predict mo-
tions with smaller errors in both short-term and long-term.
For the action of ‘Washing window’, we also predict the
future poses in 1000 ms and illustrate them in Figure 13.
We see that the prediction of CSM has large discontinuity
between the last observed pose the ﬁrst predicted one (red
box); Traj-GCN tends to have large errors after the 400th
ms, since the pose does not raise the left arm (blue box);
two baselines give poses at the 1000th ms with large er-
rors (yellow box); but DMGNN could predict motions with
smaller errors in both short-term and long-term.

