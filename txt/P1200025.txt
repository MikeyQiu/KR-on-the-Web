Deep Reinforcement Learning for Page-wise Recommendations

Xiangyu Zhao
Data Science and Engineering Lab
Michigan State University
zhaoxi35@msu.edu

Zhuoye Ding
JD.com
dingzhuoye@jd.com

Long Xia
JD.com
xialong@jd.com

Dawei Yin
JD.com
yindawei@acm.org

Liang Zhang
JD.com
zhangliang16@jd.com

Jiliang Tang
Data Science and Engineering Lab
Michigan State University
tangjili@msu.edu

8
1
0
2
 
g
u
A
 
0
1
 
 
]

R

I
.
s
c
[
 
 
2
v
3
4
3
2
0
.
5
0
8
1
:
v
i
X
r
a

ABSTRACT
Recommender systems can mitigate the information overload prob-
lem by suggesting users’ personalized items. In real-world recom-
mendations such as e-commerce, a typical interaction between the
system and its users is – users are recommended a page of items
and provide feedback; and then the system recommends a new
page of items. To effectively capture such interaction for recom-
mendations, we need to solve two key problems – (1) how to update
recommending strategy according to user’s real-time feedback, and
2) how to generate a page of items with proper display, which pose
tremendous challenges to traditional recommender systems. In this
paper, we study the problem of page-wise recommendations aiming
to address aforementioned two challenges simultaneously. In par-
ticular, we propose a principled approach to jointly generate a set
of complementary items and the corresponding strategy to display
them in a 2-D page; and propose a novel page-wise recommenda-
tion framework based on deep reinforcement learning, DeepPage,
which can optimize a page of items with proper display based on
real-time feedback from users. The experimental results based on
a real-world e-commerce dataset demonstrate the effectiveness of
the proposed framework.

KEYWORDS
Recommender Systems; Deep Reinforcement Learning; Actor-Critic;
Item Display Strategy; Sequential Preference

ACM Reference Format:
Xiangyu Zhao, Long Xia, Liang Zhang, Zhuoye Ding, Dawei Yin, and Jiliang
Tang. 2018. Deep Reinforcement Learning for Page-wise Recommendations.
In Twelfth ACM Conference on Recommender Systems (RecSys ’18), October
2–7, 2018, Vancouver, BC, Canada. ACM, New York, NY, USA, 9 pages. https:
//doi.org/10.1145/3240323.3240374

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
RecSys ’18, October 2–7, 2018, Vancouver, BC, Canada
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5901-6/18/10. . . $15.00
https://doi.org/10.1145/3240323.3240374

Figure 1: An example to illustrate the interactions between
recommender systems and users.
1 INTRODUCTION
Recommender systems are intelligent E-commerce applications [4,
21, 26]. They assist users in their information-seeking tasks by
suggesting items (products, services, or information) that best fit
their needs and preferences. Recommender systems have become
increasingly popular in recent years, and have been utilized in a
variety of domains including movies, music, locations, and social
events [2, 11, 13, 30, 31, 39, 41, 45]. Figure 1 illustrates a typical
example of the interactions between an e-commerce recommender
system and a user – each time the system recommends a page of
items to the user; next the user browses these items and provides
real-time feedback and then the system recommends a new page
of items. This example suggests two key challenges to effectively
take advantage of these interactions for e-commerce recommender
systems – 1) how to efficiently capture user’s preference and update
recommending strategy according to user’s real-time feedback; and
2) how to generate a page of items with proper display based on
user’s preferences.
1.1 Real-time Feedback
Most existing recommender systems consider the recommendation
procedure as a static process and make recommendations follow-
ing a fixed greedy strategy. However, these approaches may fail in
capturing the dynamic nature of the users’ preferences, and they
become infeasible to efficiently and continuously update their rec-
ommending strategies according to user’s real-time feedback. Thus,
in this work, we consider the recommendation procedure as sequen-
tial interactions between users and the recommender agent; and
leverage Reinforcement Learning (RL) to automatically learn the
optimal recommendation strategies. Recommender systems based

RecSys ’18, October 2–7, 2018, Vancouver, BC, Canada

Xiangyu Zhao et al.

on reinforcement learning have two major advantages. First, they
are able to continuously update their strategies based on user’s
real-time feedback during the interactions, until the system con-
verges to the optimal strategy that generates recommendations best
fitting users’ dynamic preferences. Second, the optimal strategy is
made by maximizing the expected long-term cumulative reward
from users; while the majority of traditional recommender systems
are designed to maximize the immediate (short-term) reward of
recommendations [32]. Therefore, the system can identify items
with small immediate rewards but making big contributions to the
rewards for future recommendations.
1.2 Page-wise Recommendations
As mentioned in the example, users are typically recommended
a page of items. To achieve this goal, we introduce a page-wise
recommender system, which is able to jointly (1) generate a set
of diverse and complementary items and (2) form an item display
strategy to arrange the items in a 2-D page that can lead to maxi-
mal reward. Conventional RL methods could recommend a set of
items each time, for instance, DQN can recommend a set of items
with highest Q-values according to the current state[24]. How-
ever, these approaches recommend items based on the same state,
which leads to the recommended items to be similar. In practice, a
bundling of complementary items may receive higher rewards than
recommending all similar items. For instance, in real-time news
feed recommendations, a user may want to read diverse topics
of interest[40]. In addition, page-wise recommendations need to
properly display a set of generated items in a 2-D page. Traditional
approaches treat it as a ranking problem, i.e., ranking items into
a 1-D list according to the importance of items. In other words,
user’s most preferred item is posited in the top of list. However,
in e-commerce recommender systems, a recommendation page is
a 2-D grid rather than a 1-D list. Also eye-tracking studies [33]
show that rather than scanning a page in a linear fashion, users do
page chunking, i.e., they partition the 2-D page into chunks, and
browse the chunk they prefer more. In addition, the set of items and
the display strategy are generated separately; hence they may be
not optimal to each other. Therefore, page-wise recommendations
need principled approaches to simultaneously generate a set of
complementary items and the display strategy in a 2-D page.
1.3 Contributions
In this paper, we tackle the two aforementioned challenges simul-
taneously by introducing a novel page-wise recommender system
based on deep reinforcement learning. We summarize our major
contributions as follows – (1) we introduce a principled approach to
generate a set of complementary items and properly display them
in one 2-D recommendation page simultaneously; (2) we propose
a page-wise recommendation framework DeepPage, which can
jointly optimize a page of items by incorporating real-time feed-
back from users; and (3) we demonstrate the effectiveness of the
proposed framework in a real-world e-commerce dataset and vali-
date the effectiveness of the components in DeepPage for accurate
recommendations.

2 THE PROPOSED FRAMEWORK
In this section, we first give an overview of the proposed Actor-
Critic based reinforcement learning recommendation framework

Figure 2: Framework architecture selection.

with notations. Then we present the technical details of components
in Actor and Critic, respectively.

2.1 Framework Overview
As mentioned in Section 1.1, we model the recommendation task
as a Markov Decision Process (MDP) and leverage Reinforcement
Learning (RL) to automatically learn the optimal recommenda-
tion strategies, which can continuously update recommendation
strategies during the interactions and the optimal strategy is made
by maximizing the expected long-term cumulative reward from
users. With the above intuitions, we formally define the tuple of
five elements (S, A, P, R, γ ) of MDP – (a) State space S: A state
s ∈ S is defined as user’s current preference, which is generated
based on user’s browsing history, i.e., the items that a user browsed
and her corresponding feedback; (b) Action space A: An action
a = {a1, · · · , aM } ∈ A is to recommend a page of M items to a
user based on current state s; (c) Reward R: After the RA takes
an action a at the state s, i.e., recommending a page of items to a
user, the user browses these items and provides her feedback. She
can skip (not click), click, or purchase these items, and the agent
receives immediate reward r (s, a) according to the user’s feedback;
(d) Transition P: Transition p(s ′|s, a) defines the state transition
from s to s ′ when RA takes action a; and (e) Discount factor γ :
γ ∈ [0, 1] defines the discount factor when we measure the present
value of future reward. In particular, when γ = 0, RA only consid-
ers the immediate reward. In other words, when γ = 1, all future
rewards can be counted fully into that of the current action.

Specifically, we model the recommendation task as a MDP in
which a recommender agent (RA) interacts with environment E
(or users) over a sequence of time steps. At each time step, the RA
takes an action a ∈ A according to E’s state s ∈ S, and receives a
reward r (s, a) (i.e. the RA recommends a page of items according
to user’s current preference, and receives user’s feedback). As the
consequence of action a, the environment E updates its state to s ′
with transition p(s ′|s, a). The goal of reinforcement learning is to
find a recommendation policy π : S → A, which can maximize
the cumulative reward for the recommender system.

In practice, conventional RL methods like Q-learning[36, 37] and
POMDP[14, 17, 27, 28, 32] become infeasible with the increasing
number of items for recommendations. Thus, we leverage Deep Re-
inforcement Learning[20] with (adapted) artificial neural networks
as the non-linear approximators to estimate the action-value func-
tion in RL. This model-free reinforcement learning method does
not estimate the transition probability and not store the Q-value
table. Hence it can support huge amount of items in recommender
systems.

Deep Reinforcement Learning for Page-wise Recommendations

RecSys ’18, October 2–7, 2018, Vancouver, BC, Canada

There are two major challenges when we apply deep reinforce-
ment learning to the studied problem – (a) the large (or even con-
tinuous) and dynamic action space (item space), and (b) the com-
putational cost to select an optimal action (a page of items). In
practice, only using discrete indices to denote items is not sufficient
since we cannot know the relations between different items only
from indices. One common way is to use extra information to rep-
resent items with continuous embeddings[19]. Besides, the action
space of recommender systems is dynamic as items are arriving and
leaving. Moreover, computing Q-value for all state-action pairs is
time-consuming because of the enormous state and action spaces.
To tackle these challenges, in this paper, our recommending
policy builds upon the Actor-Critic framework [35], shown in Fig-
ure 2 (c). The Actor-Critic architecture is preferred from the studied
problem since it is suitable for large and dynamic action space, and
can also reduce redundant computation simultaneously compared
to alternative architectures as shown in Figures 2 (a) and (b). The
conventional Deep Q-learning architectures shown in Figure 2 (a)
inputs only the state space and outputs Q-values of all actions. This
architecture is suitable for the scenario with high state space and
small/fixed action space like Atari[24], but cannot handle large and
dynamic action space scenario, like recommender systems. Also,
we cannot leverage the second conventional deep Q-learning ar-
chitecture as shown in Fig.2(b) because of its temporal complexity.
This architecture inputs a state-action pair and outputs the Q-value
correspondingly, and makes use of the optimal action-value func-
tion Q∗(s, a). It is the maximum expected return achievable by the
optimal policy, and should follow the Bellman equation [3] as:

Q ∗(s ′, a′)|s, a(cid:3) .

Q ∗(s, a) = Es′ (cid:2)r + γ max
a′

(1)
In practice, selecting an optimal a′, |A| evaluations is necessary
for the inner operation “maxa′”. In other words, this architecture
computes Q-value for all a′ ∈ A separately, and then selects the
maximal one. This prevents Equation (1) from being adopted in
practical recommender systems.

In the Actor-Critic framework, the Actor architecture inputs
the current state s and aims to output a deterministic action (or
recommending a deterministic page of M items), i.e., s → a =
{a1, · · · , aM }. The Critic inputs only this state-action pair rather
than all potential state-action pairs, which avoids the aforemen-
tioned computational cost as follows:

Q (s, a) = Es′ (cid:2)r + γ Q (s ′, a′)|s, a(cid:3),
(2)
where the Q-value function Q(s, a) is a judgment of whether the
selected action matches the current state, i.e., whether the rec-
ommendations match user’s preference. Finally, according to the
judgment from Critic, the Actor updates its’ parameters in a di-
rection of boosting recommendation performance so as to output
properer actions in the next iteration. Next we will elaborate the
Actor and Critic architectures.

2.2 Architecture of Actor Framework
The Actor is designed to generate a page of recommendations ac-
cording to user’s preference, which needs to tackle three challenges
– 1) setting an initial preference at the beginning of a new rec-
ommendation session, 2) learning the real-time preference in the
current session, which should capture the dynamic nature of user’s
preference in current session and user’s preferable item display pat-
terns in a page, and 3) jointly generating a set of recommendations
and displaying them in a 2-D page. To address these challenges, we

Figure 3: Encoder to generate initial state sini .
propose an Actor framework with the Encoder-Decoder architec-
ture.
2.2.1 Encoder for Initial State Generation Process. Figure 3
illustrates the model for generating initial preference. We introduce
a RNN with Gated Recurrent Units (GRU) to capture users’ sequen-
tial behaviors as user’s initial preference. The inputs of GRU are
user’s last clicked/purchased items {e1, · · · , eN } (sorted in chrono-
logical order) before the current session, while the output is the
representation of users’ initial preference by a vector. The input
{e1, · · · , eN } is dense and low-dimensional vector representations
of items 1. We add an item-embedding layer to transform ei into
a low-dimensional dense vector via Ei = tanh(WEei + bE ) ∈ R |E |
where we use “tanh” activate function since ei ∈ (−1, +1).

We leverage GRU rather than Long Short-Term Memory (LSTM)
because that GRU outperforms LSTM for capturing users’ sequential
preference in some recommendation tasks [15]. Unlike LSTM using
input gate it and forget gate ft to generate a new state, GRU utilizes
an update gate zt :

zt = σ (Wz Et + Uz ht −1).
GRU leverages a reset gate rt to control the input of the former
state ht −1:

rt = σ (Wr Et + Ur ht −1).
(4)
Then the activation of GRU is a linear interpolation between the
previous activation ht −1 and the candidate activation ˆht :

(3)

ht = (1 − zt )ht −1 + zt ˆht ,

(5)

where candidate activation function ˆht is computed as:

(6)

ˆht = tanh[W Et + U (rt · ht −1)].
We use the final hidden state ht as the representation of the user’s
initial state sini at the beginning of current recommendation ses-
sion, i.e., sini = ht .
2.2.2 Encoder for Real-time State Generation Process. Fig-
ure 4 illustrates the model to generate real-time preference in cur-
rent session. In the page-wise recommender system, the inputs
{x1, · · · , xM } for each recommendation page are the representa-
tions of the items in the page and user’s corresponding feedback,
where M is the size of a recommendation page and xi is a tuple as:
xi = (ei, ci, fi ),
(7)
where ei is the aforementioned item representation. To assist the
RA in capturing user’s preference among different categories of
items and generating complementary recommendations, we in-
corporate item’s category ci . The item’s category ci is an one-hot

1These item representations are pre-trained using users’ browsing history by a
company, i.e. each item is treated as a word and the clicked items in one recommenda-
tion session as a sentence, and item representations are trained via word embedding[19].
The effectiveness of these item representations is validated by their business such as
searching, ranking, bidding and recommendations.

RecSys ’18, October 2–7, 2018, Vancouver, BC, Canada

Xiangyu Zhao et al.

on and linearly combine different parts of the input sequence:

T
(cid:213)

s cur =

αt ht ,

(10)

t =1
where the weighted factors αt determine which parts of the input
sequence should be emphasized or ignored when making predic-
tions. Here we leverage location-based attention mechanism [22]
where the weighted factors are computed from the target hidden
state ht as follows:

.

(cid:205)

(11)

αt = exp(Wα ht + bα )
j exp(Wα hj + bα )
This GRU with attention mechanism is able to dynamically select
more important inputs, which is helpful to capture the user’s real-
time preference in the current session. Note that - 1) the length of
this GRU is flexible according to that of the current recommendation
session. After each user-agent interaction, i.e., user browse one page
of generated recommendations and give feedback to RA, we can
add one more GRU unit, and use this page of items, corresponding
categories and feedback as the input of the new GRU unit; 2) in fact,
the two RNNs in Section 2.2.1 and Section 2.2.2 can be integrated
into one RNN, we describe them separately to clearly illustrate their
architecture, and clearly validate their effectiveness in Section 4.4.
2.2.3 Decoder for Action Generation Process. In this subsec-
tion, we will propose the action acur generation process, which
generates (recommends) a new page of items to users. In other
words, given user’s current preference scur , we aim to recommend
a page of items and displays them properly to maximize the reward.
It is the inverse process of what the convolutional layer does. Hence,
we use deconvolution neural network (DeCNN) to restore one page
from the low-dimensional representation scur . It provides a sophis-
ticated and automatic way to generate a page of recommendations
with the corresponding display as:

acur = deconv2d (s cur ).

(12)

Note that - 1) the size of acur and P are different, since acur only
contains item-embedding Ei , while P also contains item’s category
embedding Ci and feedback-embedding Fi . For instance, if one
recommendation page has h rows and w columns (M = h × w), P
is a h × w |X | matrix, while acur is a h × w |E| matrix; and 2) the
generated item embeddings in acur may be not in the real item
embedding set, thus we need to map them to valid item embeddings,
which will be provided in later sections.
2.3 The Architecture of Critic Framework
The Critic is designed to leverage an approximator to learn an
action-value function Q(s, a), which is a judgment of whether the
action a (or a recommendation page) generated by Actor matches
the current state s. Note that we use “s” as scur in the last subsec-
tion for simplicity. Then, according Q(s, a), the Actor updates its’
parameters in a direction of improving performance to generate
proper actions (or recommendations) in the following iterations.

Thus we need to feed user’s current state s and action a (or a
recommendation page) into the critic. To generate user’s current
state s, the RA follows the same strategy from Equation (3) to
Equation (10), which uses embedding layers, 2D-CNN and GRU
with attention mechanism to capture user’s current preference. For
action a, because acur generated in Equation (12) is a 2D matrix
similar to an image, we utilize the same strategy in Equation (9), a
2D-CNN, to degrade acur into a low-dimensional dense vector a

(8)

Figure 4: Encoder to generate real-time state scur .
indicator vector where ci (i) = 1 if this item belongs to the ith cat-
egory and other entities are zero. The one-hot indicator vector is
extremely sparse and high-dimensional; hence we add a category-
embedding layer transforming ci into a low-dimensional dense
vector Ci = tanh(WCci + bC ) ∈ R|C |.

In addition to information from items, ei and ci , we also want
to capture user’s interests or feedback in current recommenda-
tion page. Thus, we introduce user’s feedback vector fi , which
is an one-hot vector to indicate user’s feedback for item i, i.e.,
skip/click/purchase. Similarly, we transform fi into a dense vector
Fi = tanh(WF fi + bF ) ∈ R|F | via the embedding layer. Finally, we
get a low-dimensional dense vector Xi ∈ R |X | (|X | = |E| + |C | + |F |)
by concatenating Ei , Ci and Fi as:
Xi = concat (Ei, Ci, Fi )

= tanh (cid:0)concat (WE ei + bE, WC ci + bC, WF fi + bF )(cid:1) .
Note that all item-embedding layers share the same parameters
WE and bE , which reduces the number of parameters and achieves
better generalization. We apply the same constraints for category
and feedback embedding layers.

Then, we reshape the transformed item representations {X1, · · · ,
XM } as the original arrangement in the page. In other words, we
arrange the item representations in one page Pt as 2D grids similar
to one image. For instance, if one recommendation page has h rows
and w columns (M = h × w), we will get a h × w |X | matrix Pt . To
learn item spatial display strategy in one page that leads to maximal
reward, we introduce a Convolutional Neural Network (CNN). CNN
is a successful architecture in computer vision applications because
of its capability to apply various learnable kernel filters on image
to discover complex spatial correlations [18]. Hence, we utilize 2D-
CNN followed by fully connected layers to learn the optimal item
display strategy as:

pt = conv2d (Pt ),
(9)
where pt is a low-dimensional dense vector representing the in-
formation from the items and user’s feedback in page Pt as well as
the spatial patterns of the item display strategy of page Pt .

Next, we feed {p1, · · · , pT } into another RNN with Gated Re-
current Units (GRU) to capture user’s real-time preference in the
current session. The architecture of this GRU is similar to the one
in Section 2.2.1, but we utilize the final hidden state sini in Section
2.2.1 as the initial state in current GRU. Furthermore, to capture
the user’s real-time preference in the current session, we employ
attention mechanism [1], which allows the RA to adaptively focus

Deep Reinforcement Learning for Page-wise Recommendations

RecSys ’18, October 2–7, 2018, Vancouver, BC, Canada

·

e ⊤
i

= arg max
e∈I

ei = arg max
e∈I

e ⊤
· e
i
∥ei ∥ ∥e ∥
To decrease the computational cost, we pre-compute e
∥e ∥ and also
adopt item recalling mechanism to reduce the number of relevant
items 2 . Note that Equation (14) is of the same complexity as the
maxa′ Q∗(s ′, a′) in Equation (1), |A|, but each step of evaluation is
a cosine similarity instead of a full value-function evaluation [9].

e
∥e ∥

(14)

.

Algorithm 1 Mapping Algorithm.
Input: User’s browsing history, item-embedding space I, the size of
recommendation page M .
Output: Valid recommendation page acur
v al .
1: Generate proto-action acur
2: for m = 1, M do
3:
4:
5:
6: end for
7: return acur
v al

Select the most similar item as em according to Eq.(14)
Add item em into acur
Remove item em from I

v al (at the same location as em in acur
pr o )

pr o according Eq.(3) to Eq.(10)

pr o (line 1). For each em in acur

We present the mapping algorithm in Algorithm 1. The Actor
first generates proto-action acur
pr o , the
RA selects the most similar item in terms of cosine similarity (line
3), and then adds this item into acur
val at the same position as em
in acur
pr o (line 4). Finally, the RA removes this item from the item-
embedding space (line 5), which prevents recommending the same
item repeatedly in one recommendation page.

Then the RA recommends the new recommendation page acur
val
to user, and receives the immediate feedback (reward) from user.
The reward r is the summation of rewards of all items in this page:

r =

M
(cid:213)

m=1

r ewar d (em).

(15)

3.1.2 Offline Training Procedure. When we use user’s histor-
ical browsing data to train the proposed Actor-Critic framework,
user’s browsing history, the new recommendation page acur
val and
user’s corresponding feedback (reward) r are given in the data.
Thus, there is a gap between acur
val , i.e., no matter what
proto-action acur
val is
fixed. This will disconnect the Actor and the Critic.

pr o and acur
pr o outputted by the Actor, the valid-action acur

From existing work [9, 20] and Section 3.1.1, we learn that acur
pr o
and acur
val should be similar, which is the prerequisite to connect the
Actor and the Critic for training. Thus, we choose to minimize the
pr o and acur
difference between acur
val :

min
θ π

B
(cid:213)

b=1

(cid:0) ∥acur

pr o − acur
v al

∥2
F

(cid:1),

(16)

where B is the batch size of samples in each iteration of SGD.
Equation(16) updates Actor’s parameters in the direction of pushing
pr o and acur
acur
val to be similar. In each iteration, given user’s browsing
history, the new recommendation page acur
val , the RA generates
2In general, user’s preference in current session should be related to user’s last
clicked/purchased items before the current session(say L). Thus for each item in L,
we collect a number of most similar items in terms of cosine similarity from the whole
item space, and combine all collected items as the initial item-embedding space I
of current recommendation session. During the current session, when a user clicks
or purchases an item, we will also add a number of its most similar items into the
item-embedding space I.

Figure 5: An illustration of the proposed framework.

as:

a = conv2d (acur ).
(13)
Then the RA concatenates current state s and action a, and feeds
them into a Q-value function Q(s, a). In real recommender sys-
tems, the state and action spaces are enormous, thus estimating
the action-value function Q(s, a) for each state-action pair is infea-
sible. In addition, many state-action pairs may not appear in the
real trace such that it is hard to update their values. Therefore, it
is more flexible and practical to use an approximator function to
estimate the action-value function. In practice, the action-value
function is usually highly nonlinear. Thus we choose Deep neu-
ral networks as approximators. In this work, we refer to a neural
network approximator as deep Q-value function (DQN).

3 TRAINING AND TEST PROCEDURE
In this section, we discuss the training and test procedures. We
propose two polices, i.e., online-policy and off-policy, to train and
test the proposed framework based on online environment and
offline historical data, respectively. Off-policy is necessary because
the proposed framework should be pre-trained offline and be eval-
uated before launching them online to ensure the quality of the
recommendations and mitigate possible negative impacts on user
experience. After the offline stage, we can apply the framework
online, and then the framework can continuously improve its strate-
gies during the interactions with users.

3.1 The Training Procedure
As aforementioned in Section 2.2, we map user’s preference scur
to a new page of recommendations (acur ). In a page of M items,
acur contains item-embeddings of M items, i.e., {e1, · · · , eM }. How-
ever, acur is a proto-action, because the generated item embedding
ei ∈ acur may be not in the existing item-embedding space I.
Therefore, we need to map from proto-action acur
pr o to valid-action
val where we have {ei ∈ I|∀ei ∈ acur
acur
}. With this modification,
an illustration of the proposed Actor-Critic recommending frame-
work is demonstrated in Figure 5 where we omit Encoders for state
generation part.
3.1.1 Online Training Procedure. When we train the proposed
framework in online environment, RA can interact with users by
sequentially choosing recommendation items over a sequence of
time steps. Thus, in online environment, the RA is able to receive
real-time feedback for the recommended items from users. In this
setting, for each ei in acur
pr o , we select the most similar ei ∈ I as
the valid item-embedding in acur
val . In this work, we select cosine
similarity as:

val

RecSys ’18, October 2–7, 2018, Vancouver, BC, Canada

Xiangyu Zhao et al.

pr o and then minimizes the difference between acur
proto-action acur
pr o
and acur
val , which can connect the Actor and the Critic. Next, we can
follow conventional methods to update the parameters of Actor
and Critic. The reward r is the summation of rewards of all items
in page acur
val .
3.1.3 Training Algorithm. In this work, we utilize DDPG [20]
algorithm to train the parameters of the proposed Actor-Critic
framework. The Critic can be trained by minimizing a sequence of
loss functions L(θ µ ) as:

L(θ µ ) = Es, a,r ,s′ (cid:2)(cid:0)r + γ Qθ µ′ (s ′, fθ π ′ (s ′)) − Qθ µ (s, a)(cid:1) 2(cid:3),

(17)
where θ µ represents all parameters in Critic. The critic is trained
from samples stored in a replay buffer [25]. Actions stored in the re-
val , i.e., a = conv2d(acur
play buffer are generated by valid-action acur
).
val
This allows the learning algorithm to leverage the information of
which action was actually executed to train the critic [9].

The first term y = r + γQθ µ′ (s ′, fθ π ′ (s ′)) in Equation (17) is the
target for the current iteration. The parameters from the previous
iteration θ µ ′
are fixed when optimizing the loss function L(θ µ ). In
practice, it is often computationally efficient to optimize the loss
function by stochastic gradient descent, rather than computing
the full expectations in the above gradient. The derivatives of loss
function L(θ µ ) with respective to parameters θ µ are presented as
follows:

∇θ µ L(θ µ ) = Es, a,r ,s′ (cid:2)(r + γ Qθ µ′ (s ′, fθ π ′ (s ′))
− Qθ µ (s, a))∇θ µ Qθ µ (s, a)(cid:3) .
We update the Actor using the policy gradient:

∇θ π fθ π ≈ Es

(cid:2)∇ ˆa Qθ µ (s, ˆa) ∇θ π fθ π (s)(cid:3),

(19)
pr o ( ˆa =
where ˆa = fθ π (s), i.e., ˆa is generated by proto-action acur
conv2d(acur
pr o is the actual action out-
putted by Actor. This guarantees that policy gradient is taken at
the actual output of policy fθ π [9].

pr o )). Note that proto-action acur

The online training algorithm for the proposed framework Deep-
Page is presented in Algorithm 2. In each iteration, there are two
stages, i.e., 1) transition generating stage (lines 7-10), and 2) param-
eter updating stage (lines 11-16). For transition generating stage
(line 7): given the current state st , the RA first recommends a page
of items at according to Algorithm 1 (line 8); then the RA observes
the reward rt and updates the state to st +1 (lines 9); and finally the
RA stores transitions (st , at , rt , st +1) into the replay buffer D (line
10). For parameter updating stage (line 11): the RA samples mini-
batch of transitions (s, a, r , s ′) from D (line 12), and then updates
parameters of Actor and Critic (lines 13-16) following a standard
DDPG procedure [20].

val according to Equation (16).

The offline training procedure is similar with Algorithm 2. The
two differences are: 1) in line 8, offline training follows off-policy
b(st ), and 2) before line 13, offline training first minimizes the
difference between acur

pr o and acur
3.2 The Test Procedure
After the training stage, the proposed framework learns parameters
Θπ and Θµ . Now we formally present the test procedure of the
proposed framework DeepPage. We design two test methods, i.e.,
1) Online test: to test DeepPage in online environment where RA
interacts with users and receive real-time feedback for the recom-
mended items from users, and 2) Offline test: to test DeepPage based
on user’s historical browsing data.

Algorithm 2 Parameters Online Training for DeepPage with
DDPG.

1: Initialize actor network fθ π and critic network Qθ µ with random

weights

2: Initialize target network fθ π ′ and Qθ µ′ with weights

θ π ′

← θ π , θ µ′

← θ µ
3: Initialize the capacity of replay buffer D
4: for session = 1, G do
5:
6:
7:
8:
9:

Receive initial observation state s1
for t = 1, T do

Stage 1: Transition Generating Stage
Select an action at according to Alg.1 (policy fθ π )
Execute action at and observe the reward rt according to Eq.
(15) and new state st +1 according to Section 2.2.2
Store transition (st , at , rt , st +1) in D
Stage 2: Parameter Updating Stage
Sample minibatch of N transitions (s, a, r, s ′) from D
Set y = r + γ Qθ µ′ (s ′, fθ π ′ (s ′))
Update Critic by minimizing 1
N
to Eq. (18)
Update Actor using the sampled policy gradient according to Eq.
(19)
Update the target networks:

(cid:0)y − Qθ µ (s, a)(cid:1) 2 according

(cid:205)

n

10:
11:
12:
13:

14:

15:

16:

θ µ′
θ π ′

← τ θ µ + (1 − τ )θ µ′
← τ θ π + (1 − τ )θ π ′

3.2.1 Online Test. The online test algorithm in one recommenda-
tion session is presented in Algorithm 3. The online test procedure
is similar with the transition generating stage in Algorithm 2. In
each iteration of the recommendation session, given the current
state st , the RA recommends a page of recommendations at to user
following policy fΘπ (line 4). Then the RA observes the reward rt
from user (line 5) and updates the state to st +1 (line 6).

Algorithm 3 Online Test for DeepPage.

1: Initialize Actor with the trained parameters Θπ
2: Receive initial observation state s1
3: for t = 1, T do
4:
5:
6:
7: end for

Execute an action at according to Alg.1 (policy fΘπ )
Observe the reward rt from user according to Eq. (15)
Observe new state st +1 according to Section 2.2.2

3.2.2 Offline Test. The intuition of our offline test method is
that, for a given recommendation session (offline data), the RA
reranks the items in this session. If the proposed framework works
well, the clicked/purchased items in this session will be ranked at
the top of the new list. The reason why RA only reranks items
in this session rather than items in the whole item space is that
for the offline dataset, we only have the ground truth rewards
of the existing items in this session. The offline test algorithm in
one recommendation session is presented in Algorithm 4. In each
iteration of an offline test recommendation session, given the state
st (line 2), the RA recommends an page of recommendations at
following policy fΘπ (lines 4). For each item ei in at , we add it into

(18)

end for

17:
18: end for

Deep Reinforcement Learning for Page-wise Recommendations

RecSys ’18, October 2–7, 2018, Vancouver, BC, Canada

new recommendation list L (line 6), and record ei ’s reward ri from
user’s historical browsing data (line 7). Then we can compute the
overall reward rt of at (line 9) and update the state to st +1 (line
10). Finally, we remove all items ei in at from the item set I of the
current session (line 11).

Algorithm 4 Offline Test of DeepPage Framework.
Input: Item set I = {e1, · · · , eN } and corresponding reward set
R = {r1, · · · , rN } of a session.
Output:Recommendation list L with new order
1: Initialize Actor with well-trained parameters Θπ
2: Receive initial observation state s1
3: while |I | > 0 do
4:
5:
6:
7:
8:
9:
10:

Add ei into the end of L
Record reward ri from user’s historical browsing data

Select an action at according to Alg.1 (policy fΘπ )
for ei ∈ at do

end for
Compute the overall reward rt of at according to Eq. (15)
Execute action at and observe new state st +1 according to Section
2.2.2
Remove all ei ∈ at from I

11:
12: end while

4 EXPERIMENTS
In this section, we conduct extensive experiments with a dataset
from a real e-commerce company to evaluate the effectiveness of
the proposed framework. We mainly focus on two questions: (1)
how the proposed framework performs compared to representa-
tive baselines; and (2) how the components in Actor and Critic
contribute to the performance.

4.1 Experimental Settings
We evaluate our method on a dataset of September, 2017 from a real
e-commerce company. We randomly collect 1,000,000 recommenda-
tion sessions (9,136,976 items) in temporal order, and use the first
70% sessions as the training/validation set and the later 30% sessions
as the test set. For a new session, the initial state is collected from the
previous sessions of the user. In this work, we leverage N = 10 pre-
viously clicked/purchased items to generate the initial state. Each
time the RA recommends a page of M = 10 items (5 rows and 2
columns) to users 3. The reward r of one skipped/clicked/purchased
item is empirically set as 0, 1, and 5, respectively. The dimensions
of item-embedding/category-embedding/ feedback-embedding are
|E| = 50, |C | = 35, and |F | = 15. We set the discounted fac-
tor γ = 0.95, and the rate for soft updates of target networks
τ = 0.01. For offline test, we select Precision@20, Recall@20,
F1-score@20 [12], NDCG@20 [16] and MAP [38], as the metrics.
For online test, we leverage the summation of all rewards in one
recommendation session as the metric.
4.2 Performance Comparison for Offline Test
To answer the first question, we compare the proposed framework
with the following representative baseline methods – CF [4]: col-
laborative filtering; FM [29]: Factorization Machines; GRU [15] : it
utilizes the Gated Recurrent Units (GRU) to predict what user will
click/purchase next based on the browsing histories (to make a fair

3This is based on offline historical data collected from mobile App, i.e., to fit the

screen size of mobile phones, one page has only 5 rows and 2 columns.

Figure 6: Overall performance comparison in offline test.

comparison, it also keeps previous N = 10 clicked/purchased items
as initial states); DQN [24]: we use a Deep Q-network with five
fully-connected layers in this baseline. The input is the concate-
nation of embeddings of users’ historical clicked/purchased items
(state) and a page of recommendations (action), and train this base-
line by Eq.(1); and DDPG [9]: in this baseline, we use conventional
Deep Deterministic Policy Gradient with five fully connected layers
in both Actor and Critic.

We leverage offline training strategy to train DDPG and Deep-
Page as mentioned in Section 3.1.1. The results are shown in Figure 6.
Figure 6 (a) illustrates the training process of DeepPage. We can ob-
serve that the framework approaches convergence when the model
is trained by 500,000 offline sessions. We note that CF and FM per-
form worse than other baselines. These two baselines ignore the
temporal sequence of the users’ browsing history, while GRU can
capture the temporal sequence, and DQN, DDPG and DeepPage are
able to continuously update their strategies during the interactions.
DQN and DDPG outperform GRU. We design GRU to maximize the
immediate reward for recommendations, while DQN and DDPG
are designed to achieve the trade-off between short-term and long-
term rewards. This result suggests that introducing reinforcement
learning can improve the performance of recommendations. Finally
DeepPage performs better than conventional DDPG. Compared to
DDPG, DeepPage jointly optimizes a page of items and uses GRU
to learn user’s real-time preference.

4.3 Performance Comparison for Online Test
Following [42], we build a simulated online environment (adapted
to our case) for online test. We compare DeepPage with GRU, DQN
and DDPG. Here we utilize online training strategy to train DDPG
and DeepPage (both Actor-Critic framework) as mentioned in Sec-
tion 3.1.2. Baselines are also applicable to be trained via the rewards
generated by simulated online environment. Note that we use data
different from the training set to build the simulated online envi-
ronment to avoid over-fitting.

As the test stage is based on the simulator, we can artificially
control the length of recommendation sessions to study the perfor-
mance in short and long sessions. We define short sessions with
10 recommendation pages, while long sessions with 50 recommen-
dation pages. The results are shown in Figure 7. We note DDPG
performs similar to DQN, but the training speed of DDPG is much

RecSys ’18, October 2–7, 2018, Vancouver, BC, Canada

Xiangyu Zhao et al.

Table 1: Performance comparison of different components.

Methods

DeepPage-1
DeepPage-2
DeepPage-3
DeepPage-4
DeepPage-5
DeepPage-6
DeepPage-7
DeepPage

Precision
@20

0.0479
0.0475
0.0351
0.0452
0.0476
0.0318
0.0459
0.0491

Recall
@20

0.3351
0.3308
0.2627
0.3136
0.3342
0.2433
0.3179
0.3576

F1score
@20

0.0779
0.0772
0.0578
0.0729
0.0775
0.0528
0.0736
0.0805

NDCG
@20

0.1753
0.1737
0.1393
0.1679
0.1716
0.1316
0.1698
0.1872

MAP

0.1276
0.1265
0.1071
0.1216
0.1243
0.1039
0.1233
0.1378

setting user’s initial preference at the beginning of a new recom-
mendation session, and capturing user’s real-time preference in
current session is helpful for accurate recommendations. DeepPage-
5 proves that incorporating attention mechanism can better capture
user’s real-time preference than only GRU. DeepPage outperforms
DeepPage-4 and DeepPage-7, which indicates that item display
strategy can influence the decision making process of users. In a
nutshell, DeepPage outperforms all its variants, which demonstrates
the effectiveness of each component for recommendations.
5 RELATED WORK
In this section, we briefly review research related to our study, i.e.,
reinforcement learning for recommendations. The MDP-Based CF
model can be viewed as approximating a partial observable MDP
[32]. Mahmood et al.[23] adopted the RL technique to observe the
responses of users in a conversational recommender. Taghipour
et al.[36, 37] modeled web page recommendation as a Q-Learning
problem and learned to make recommendations from web usage
data. Sunehag et al.[34] addressed sequential decision problems
with high-dimensional slate-action spaces. Zheng et al.[44] pro-
posed a RL framework to do online news recommendation. Cai
et al.[5, 6] employed a RL mechanism for impression allocation
problem. Feng et al. [10] optimized ranking strategies collabora-
tively for multi-scenario recommendations. Choi et al. [8] used RL
and biclustering for cold-start problem. Chen et al. [7] proposed
strategies to improve the reward estimation in dynamic recommen-
dation environments. Zhao et al. [42] captured both positive and
negative feedback into RL based recommendations. Zhao et al. [43]
optimized a set of recommendations with proper order.
6 CONCLUSION
In this paper, we propose a novel page-wise recommendation frame-
work, DeepPage, which leverages Deep Reinforcement Learning
to automatically learn the optimal recommendation strategies and
optimizes a page of items simultaneously. We validate the effec-
tiveness of our framework with extensive experiments based on
data from a real e-commerce company. Further research directions
include reducing the temporal complexity of mapping from proto-
action to valid-action and handling multiple tasks such as search,
bidding, advertisement and recommendation collaboratively in one
reinforcement learning framework.
ACKNOWLEDGEMENTS
This material is based upon work supported by the National Science
Foundation (NSF) under grant number IIS-1714741 and IIS-1715940,
and a grant from Criteo Faculty Research Award.

Figure 7: Overall performance comparison in online test.

faster than DQN, as shown in Figure 7 (a). This result indicates
that Actor-Critic framework is suitable for practical recommender
systems with enormous action space. In short recommendation
sessions, GRU, DQN and DDPG achieve comparable performance.
In other words, GRU model and reinforcement learning models
like DQN and DDPG can recommend proper items matching users’
short-term interests. In long recommendation sessions, DQN and
DDPG outperform GRU significantly. GRU is designed to maximize
the immediate reward for recommendations, while DQN and DDPG
are designed to achieve the trade-off between short-term and long-
term rewards. This result suggests that introducing reinforcement
learning can improve the long-term performance of recommenda-
tions. Finally DeepPage performs better than conventional DQN
and DDPG. DeepPage can learn user’s real-time preference and
optimize a page of items. We detail the effect of model components
of DeepPage in the following subsection.
4.4 Effectiveness of Components
To validate the effectiveness of each component, we systemati-
cally eliminate the corresponding model components by defining
following variants of DeepPage – (1) DeepPage-1: this variant
is to evaluate the performance of the embedding layers. We re-
move the embedding layers for items, categories and feedback; (2)
DeepPage-2: in this variant, we evaluate the contribution of cate-
gory and feedback information, hence, this variant does not contain
one-hot indicator vectors of category and feedback; (3) DeepPage-
3: This variant is to evaluate the effectiveness of GRU to generate
initial state, so we eliminate the GRU in Figure 3; (4) DeepPage-4:
In this variant, we evaluate the contribution of CNNs as shown
in Figure 4, thus we remove CNNs and directly feed the outputs
of embedding layers (concatenate embeddings of all items as one
vector) into GRU units; (5) DeepPage-5: This variant is to evaluate
the effectiveness of attention mechanism in Figure 4, therefore, we
eliminate attention layer and use the hidden state of last GRU unit
as the input of DeCNN; (6) DeepPage-6: In this variant, we evalu-
ate the GRU to generate real-time state, thereby, we remove this
GRU in Figure 4 and concatenate outputs of all CNNs as a vector,
and feed it into DeCNN; and (7) DeepPage-7: This variant is to
evaluate the performance of DeCNN to generate a new page of
items, hence, we replace it by fully-connected layers, which output
a concatenated vector of M item-embeddings.

The offline results are shown in Table 1. Note that we omit simi-
lar online observations because of the space limitation. DeepPage-1
and DeepPage-2 validate that incorporating category/feedback in-
formation and the embedding layers can boost the performance.
DeepPage-3 and DeepPage-6 perform worse, which suggests that

Deep Reinforcement Learning for Page-wise Recommendations

RecSys ’18, October 2–7, 2018, Vancouver, BC, Canada

REFERENCES
[1] Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. 2014. Neural ma-
chine translation by jointly learning to align and translate. arXiv preprint
arXiv:1409.0473 (2014).

[2] Jie Bao, Yu Zheng, David Wilkie, and Mohamed Mokbel. 2015. Recommendations
in location-based social networks: a survey. Geoinformatica 19, 3 (2015), 525–565.

[3] Richard Bellman. 2013. Dynamic programming. Courier Corporation.
[4] John S Breese, David Heckerman, and Carl Kadie. 1998. Empirical analysis of
predictive algorithms for collaborative filtering. In Proceedings of the Fourteenth
conference on Uncertainty in artificial intelligence. Morgan Kaufmann Publishers
Inc., 43–52.

[5] Qingpeng Cai, Aris Filos-Ratsikas, Pingzhong Tang, and Yiwei Zhang. 2018.
Reinforcement Mechanism Design for e-commerce. In Proceedings of the 2018
World Wide Web Conference on World Wide Web. International World Wide Web
Conferences Steering Committee, 1339–1348.

[6] Qingpeng Cai, Aris Filos-Ratsikas, Pingzhong Tang, and Yiwei Zhang. 2018.
Reinforcement mechanism design for fraudulent behaviour in e-commerce. In
Proceedings of the 32nd AAAI Conference on Artificial Intelligence.

[7] Shi-Yong Chen, Yang Yu, Qing Da, Jun Tan, Hai-Kuan Huang, and Hai-Hong
Tang. 2018. Stabilizing reinforcement learning in dynamic environment with
application to online recommendation. In Proceedings of the 24th ACM SIGKDD
International Conference on Knowledge Discovery & Data Mining. ACM, 1187–
1196.

[8] Sungwoon Choi, Heonseok Ha, Uiwon Hwang, Chanju Kim, Jung-Woo Ha, and
Sungroh Yoon. 2018. Reinforcement Learning based Recommender System using
Biclustering Technique. arXiv preprint arXiv:1801.05532 (2018).

[9] Gabriel Dulac-Arnold, Richard Evans, Hado van Hasselt, Peter Sunehag, Timothy
Lillicrap, Jonathan Hunt, Timothy Mann, Theophane Weber, Thomas Degris, and
Ben Coppin. 2015. Deep reinforcement learning in large discrete action spaces.
arXiv preprint arXiv:1512.07679 (2015).

[10] Jun Feng, Heng Li, Minlie Huang, Shichen Liu, Wenwu Ou, Zhirong Wang, and
Xiaoyan Zhu. 2018. Learning to Collaborate: Multi-Scenario Ranking via Multi-
Agent Reinforcement Learning. (2018).

[11] Huiji Gao, Jiliang Tang, Xia Hu, and Huan Liu. 2015. Content-Aware Point of
Interest Recommendation on Location-Based Social Networks.. In AAAI. 1721–
1727.

[12] Asela Gunawardana and Guy Shani. 2009. A survey of accuracy evaluation
metrics of recommendation tasks. Journal of Machine Learning Research 10, Dec
(2009), 2935–2962.

[13] Hao Guo, Xin Li, Ming He, Xiangyu Zhao, Guiquan Liu, and Guandong Xu. 2016.
CoSoLoRec: Joint Factor Model with Content, Social, Location for Heterogeneous
Point-of-Interest Recommendation. In International Conference on Knowledge
Science, Engineering and Management. Springer, 613–627.

[14] Milos Hauskrecht. 1997. Incremental methods for computing bounds in partially

observable Markov decision processes. In AAAI/IAAI. 734–739.

[15] Balázs Hidasi, Alexandros Karatzoglou, Linas Baltrunas, and Domonkos Tikk.
2015. Session-based recommendations with recurrent neural networks. arXiv
preprint arXiv:1511.06939 (2015).

[16] Kalervo Järvelin and Jaana Kekäläinen. 2002. Cumulated gain-based evaluation
of IR techniques. ACM Transactions on Information Systems (TOIS) 20, 4 (2002),
422–446.

[17] Michael Kearns, Yishay Mansour, and Andrew Y Ng. 2002. A sparse sampling
algorithm for near-optimal planning in large Markov decision processes. Machine
learning 49, 2 (2002), 193–208.

[18] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. 2012. Imagenet classifica-
tion with deep convolutional neural networks. In Advances in neural information
processing systems. 1097–1105.

[19] Omer Levy and Yoav Goldberg. 2014. Neural word embedding as implicit matrix
factorization. In Advances in neural information processing systems. 2177–2185.
[20] Timothy P Lillicrap, Jonathan J Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez,
Yuval Tassa, David Silver, and Daan Wierstra. 2015. Continuous control with
deep reinforcement learning. arXiv preprint arXiv:1509.02971 (2015).

[21] Greg Linden, Brent Smith, and Jeremy York. 2003. Amazon. com recommenda-
tions: Item-to-item collaborative filtering. IEEE Internet computing 7, 1 (2003),
76–80.

[22] Thang Luong, Hieu Pham, and Christopher D Manning. 2015. Effective ap-
proaches to attention-based neural machine translation. In Proceedings of the
2015 Conference on Empirical Methods in Natural Language Processing. 1412–1421.
[23] Tariq Mahmood and Francesco Ricci. 2009. Improving recommender systems
with adaptive conversational strategies. In Proceedings of the 20th ACM conference
on Hypertext and hypermedia. ACM, 73–82.

[24] Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis
Antonoglou, Daan Wierstra, and Martin Riedmiller. 2013. Playing atari with deep
reinforcement learning. arXiv preprint arXiv:1312.5602 (2013).

[25] Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness,
Marc G Bellemare, Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg
Ostrovski, et al. 2015. Human-level control through deep reinforcement learning.

Nature 518, 7540 (2015), 529.

[26] Raymond J Mooney and Loriene Roy. 2000. Content-based book recommending
using learning for text categorization. In Proceedings of the fifth ACM conference
on Digital libraries. ACM, 195–204.

[27] Andrew Y Ng and Michael Jordan. 2000. PEGASUS: A policy search method for
large MDPs and POMDPs. In Proceedings of the Sixteenth conference on Uncertainty
in artificial intelligence. Morgan Kaufmann Publishers Inc., 406–415.

[28] Pascal Poupart and Craig Boutilier. 2005. VDCBPI: an approximate scalable algo-
rithm for large POMDPs. In Advances in Neural Information Processing Systems.
1081–1088.

[29] Steffen Rendle. 2010. Factorization machines. In Data Mining (ICDM), 2010 IEEE

10th International Conference on. IEEE, 995–1000.

[30] Paul Resnick and Hal R Varian. 1997. Recommender systems. Commun. ACM 40,

3 (1997), 56–58.

[31] Francesco Ricci, Lior Rokach, and Bracha Shapira. 2011. Introduction to rec-
In Recommender systems handbook. Springer,

ommender systems handbook.
1–35.

[32] Guy Shani, David Heckerman, and Ronen I Brafman. 2005. An MDP-based
recommender system. Journal of Machine Learning Research 6, Sep (2005), 1265–
1295.

[33] Ramakrishnan Srikant, Sugato Basu, Ni Wang, and Daryl Pregibon. 2010. User
browsing models: relevance versus examination. In Proceedings of the 16th ACM
SIGKDD international conference on Knowledge discovery and data mining. ACM,
223–232.

[34] Peter Sunehag, Richard Evans, Gabriel Dulac-Arnold, Yori Zwols, Daniel Visentin,
and Ben Coppin. 2015. Deep Reinforcement Learning with Attention for Slate
Markov Decision Processes with High-Dimensional States and Actions. arXiv
preprint arXiv:1512.01124 (2015).

[35] Richard S Sutton and Andrew G Barto. 1998. Reinforcement learning: An intro-

duction. Vol. 1. MIT press Cambridge.

[36] Nima Taghipour and Ahmad Kardan. 2008. A hybrid web recommender system
based on q-learning. In Proceedings of the 2008 ACM symposium on Applied
computing. ACM, 1164–1168.

[37] Nima Taghipour, Ahmad Kardan, and Saeed Shiry Ghidary. 2007. Usage-based
web recommendations: a reinforcement learning approach. In Proceedings of the
2007 ACM conference on Recommender systems. ACM, 113–120.

[38] Andrew Turpin and Falk Scholer. 2006. User performance versus precision
measures for simple search tasks. In Proceedings of the 29th annual international
ACM SIGIR conference on Research and development in information retrieval. ACM,
11–18.

[39] Suhang Wang, Yilin Wang, Jiliang Tang, Kai Shu, Suhas Ranganath, and Huan Liu.
2017. What your images reveal: Exploiting visual contents for point-of-interest
recommendation. In Proceedings of the 26th International Conference on World
Wide Web. International World Wide Web Conferences Steering Committee,
391–400.

[40] Yisong Yue and Carlos Guestrin. 2011. Linear submodular bandits and their
application to diversified retrieval. In Advances in Neural Information Processing
Systems. 2483–2491.

[41] Xiangyu Zhao, Tong Xu, Qi Liu, and Hao Guo. 2016. Exploring the Choice Under
Conflict for Social Event Participation. In International Conference on Database
Systems for Advanced Applications. Springer, 396–411.

[42] Xiangyu Zhao, Liang Zhang, Zhuoye Ding, Long Xia, Jiliang Tang, and Dawei Yin.
2018. Recommendations with Negative Feedback via Pairwise Deep Reinforce-
ment Learning. In Proceedings of the 24th ACM SIGKDD International Conference
on Knowledge Discovery & Data Mining. ACM, 1040–1048.

[43] Xiangyu Zhao, Liang Zhang, Zhuoye Ding, Dawei Yin, Yihong Zhao, and Jiliang
Tang. 2017. Deep Reinforcement Learning for List-wise Recommendations. arXiv
preprint arXiv:1801.00209 (2017).

[44] Guanjie Zheng, Fuzheng Zhang, Zihan Zheng, Yang Xiang, Nicholas Jing Yuan,
Xing Xie, and Zhenhui Li. 2018. DRN: A Deep Reinforcement Learning Frame-
work for News Recommendation. In Proceedings of the 2018 World Wide Web
Conference on World Wide Web. International World Wide Web Conferences
Steering Committee, 167–176.

[45] Yu Zheng, Lizhu Zhang, Zhengxin Ma, Xing Xie, and Wei Ying Ma. 2011. Rec-
ommending friends and locations based on individual location history. Acm
Transactions on the Web 5, 1 (2011), 5.

