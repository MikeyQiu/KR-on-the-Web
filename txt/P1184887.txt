Adaptive Laplace Mechanism: Differential Privacy
Preservation in Deep Learning

NhatHai Phan∗1, Xintao Wu†, Han Hu∗, and Dejing Dou‡
∗New Jersey Institute of Technology, Newark, New Jersey, USA
†University of Arkansas, Fayetteville, Arkansas, USA
‡University of Oregon, Eugene, Oregon, USA
Emails: phan@njit.edu, xintaowu@uark.edu, hh255@njit.edu, and dou@cs.uoregon.edu

8
1
0
2
 
r
p
A
 
3
2
 
 
]

R
C
.
s
c
[
 
 
2
v
0
5
7
5
0
.
9
0
7
1
:
v
i
X
r
a

Abstract—In this paper, we focus on developing a novel
mechanism to preserve differential privacy in deep neural net-
works, such that: (1) The privacy budget consumption is totally
independent of the number of training steps; (2) It has the ability
to adaptively inject noise into features based on the contribution
of each to the output; and (3) It could be applied in a variety
of different deep neural networks. To achieve this, we ﬁgure
out a way to perturb afﬁne transformations of neurons, and
loss functions used in deep neural networks. In addition, our
mechanism intentionally adds “more noise” into features which
are “less relevant” to the model output, and vice-versa. Our
theoretical analysis further derives the sensitivities and error
bounds of our mechanism. Rigorous experiments conducted on
MNIST and CIFAR-10 datasets show that our mechanism is
highly effective and outperforms existing solutions.

I. INTRODUCTION

Today, deep learning has become the tool of choice in many
areas of engineering, such as autonomous systems, signal
and information processing, and data analytics. Deep learning
systems are, therefore, not only applied in classic settings, such
as speech and handwriting recognition, but also progressively
operate at the core of security and privacy critical applications.
For instance, self-driving cars make use of deep learning for
recognizing objects and street signs [1]. Detection systems for
email spam integrate learning methods for analyzing data more
effectively [2]. Furthermore, deep learning has applications in
a number of healthcare areas, e.g., phenotype extraction and
health risk prediction [3], prediction of the development of
various diseases, including schizophrenia, cancers, diabetes,
heart failure, etc. [4], and many more. This presents an obvious
threat to privacy in new deep learning systems which are being
deployed. However, there are only a few scientiﬁc studies in
preserving privacy in deep learning.

In the past few decades, a subject of signiﬁcant interest has
been how to release the sensitive results of statistical analyses
and data mining, while still protecting privacy. One state-
of-the-art privacy model is (cid:15)-differential privacy [5], which
ensures that the adversary cannot infer any information about
any speciﬁc record with high conﬁdence (controlled by a
privacy budget) from the released learning models, even if
all the remaining tuples of the sensitive data are possessed
by the adversary. The privacy budget controls the amount by

1 This is a correction version of the previous arXiv:1709.05750 and
ICDM’17 published version. Refer to Appendix G for summary of changes.

which the output distributions induced by two neighboring
datasets may differ: A smaller privacy budget value enforces
a stronger privacy guarantee. Differential privacy research has
been studied from both theoretical and application perspectives
[6, 7]. The mechanisms of achieving differential privacy
mainly include adding Laplace noise [5],
the exponential
mechanism [8], and the functional perturbation method [6].

It is signiﬁcant and timely to combine differential privacy
and deep learning, i.e., the two state-of-the-art techniques in
privacy preserving and machine learning. However, this is
a challenging task, and only a few scientiﬁc studies have
been conducted. In [9], Shokri and Shmatikov proposed a dis-
tributed training method, which injects noise into “gradients”
of parameters, to preserve privacy in neural networks. In this
method, the magnitude of injected noise and the privacy budget
(cid:15) are accumulated in proportion to the number of training
epochs and the number of shared parameters. Thus, it may
consume an unnecessarily large portion of the privacy budget,
as the number of training epochs and the number of shared
parameters among multiple parties are often large [10].

To improve this, based on the composition theorem [11],
Abadi et al. [12] proposed a privacy accountant, which keeps
track of privacy spending and enforces applicable privacy poli-
cies. However, the approach is still dependent on the number
of training epochs, as it introduces noise into “gradients” of
parameters in every training step. With a small privacy budget
(cid:15), only a small number of epochs can be used to train the
model [12]. In practice, that could potentially affect the model
utility, when the number of training epochs needs to be large
to guarantee the model accuracy.

A recent approach towards differentially private deep neural
networks was explored by Phan et al. [10]. This work pro-
posed deep private auto-encoders (dPAs), in which differential
privacy is enforced by perturbing the cross-entropy errors in
auto-encoders [13]. Their algorithm was designed particularly
for auto-encoders, in which speciﬁc objective functions are ap-
plied. A different method, named CryptoNets, was proposed
in [14] towards the application of neural networks to encrypted
data. A data owner can send their encrypted data to a cloud
service that hosts the network, and get encrypted predictions in
return. This method is different from our context, since it does
not aim at releasing learning models under privacy protections.
Another drawback of the existing techniques is that all

parameters are treated the same in terms of the amount of noise
injected. This may not be ideal in real scenarios, since different
features and parameters normally have different impacts upon
the model output. Fig. 1 shows the relevance estimated by
applying Layer-wise Relevance Propagation (LRP) [15] of
input features to the prediction of the image’s label in the
MNIST dataset [16]. Dark red units have stronger impacts
than green and yellow units. Injecting the same magnitude of
noise into all parameters may affect the model utility.

Research Goal. Therefore,
there is an urgent demand for
the development of a privacy
preserving mechanism, such that:
(1) It
is totally independent of
training epochs
the number of
in consuming privacy budget; (2)
It has the ability to adaptively
inject noise into features based
on the contribution of each to
the model output; and (3) It can
be applied in a variety of deep
networks. Mechanisms
neural
signiﬁcantly enhance the

Fig. 1. An instance of rel-
evance of each input
feature
given to the classiﬁcation out-
put (MNIST dataset). Red neu-
rele-
rons
vances, and green neurons indi-
cate weaker relevances.

stronger

indicate

with such characteristics will
operation of privacy preservation in deep learning.

Our Contribution. Motivated by this, we develop a novel
mechanism, called Adaptive Laplace Mechanism (AdLM), to
preserve differential privacy in deep learning. Our idea is to
intentionally add “more noise” into features which are “less
relevant” to the model output, and vice-versa. To achieve that,
we inject Laplace noise into the computation of Layer-wise
Relevance Propagation (LRP) [15] to estimate a differentially
private relevance of each input feature to the model output.
Given the perturbed features, we ﬁgure out a novel way to
distribute adaptive noise into afﬁne transformations and loss
functions used in deep neural networks as a preprocessing step,
so that preserving differential privacy is feasible. As a result,
we expect to improve the utility of deep neural networks under
(cid:15)-differential privacy. It is worth noting that our mechanism
does not access the original data again in the training phase.
Theoretical analysis derives the sensitivities and error bounds
of our mechanism, and shows that they are totally independent
of the number of epochs.

Different from [9, 12], in our mechanism, the injected noise
and the privacy budget consumption do not accumulate in each
training step. Consequently, the privacy budget consumption in
our mechanism is totally independent of the number of training
epochs. In addition, different from [10], our mechanism can be
applied in a variety of deep learning networks with different
activation functions. Convolution neural networks (CNNs)
[16] are used as an example to validate the effectiveness of our
mechanism. Rigorous experiments conducted on MNIST and
CIFAR-10 datasets [17] show that our mechanism is effective
and outperforms existing solutions.

II. PRELIMINARIES AND RELATED WORKS

In this section, we revisit differential privacy, existing tech-
niques in preserving differential privacy in deep learning, and
the Layer-wise Relevance Propagation (LRP) algorithm [15].
Let D be a database that contains n tuples x1, x2, . . . , xn
and d+1 attributes X1, X2, . . . , Xd, Y , and for each tuple xi =
(xi1, xi2, . . . , xid, yi). We assume, without loss of generality,
(cid:113)(cid:80)d
ij ≤ 1 where xij ≥ 0. This assumption can be
easily enforced by changing each xij to
, where
αj and βj denote the minimum and maximum values in the
domain of Xj.

xij −αj
(βj −αj )·

j=1 x2

√

d

To be general, let us consider a classiﬁcation task with M
possible categorical outcomes, i.e., the data label yi given
xi ∈ L is assigned to only one of the M categories.
Each yi can be considered as a vector of M categories
yi = {yi1, . . . , yiM }. If the l-th category is the class of xi,
then yil = 1, otherwise yil = 0. Our objective is to construct a
differentially private deep neural network from D that (i) takes
xi = (xi1, xi2, . . . , xid) as input and (ii) outputs a prediction
of yi that is as accurate as possible. To evaluate whether model
parameters θ lead to an accurate model, a cost function FD(θ)
is used to measure the difference between the original and
predicted values of yi.

A. (cid:15)-Differential Privacy

As the released model parameter θ may disclose sensitive
information of D, to protect the privacy, we require that the
model training should be performed with an algorithm that
satisﬁes (cid:15)-differential privacy. The deﬁnition of differential
privacy is as follows:

Deﬁnition 1: (cid:15)-Differential Privacy [5]. A randomized algo-
rithm A fulﬁlls (cid:15)-differential privacy, if for any two databases
D and D(cid:48) differing at most one tuple, and for all O ⊆
Range(A), we have:

P r[A(D) = O] ≤ e(cid:15)P r[A(D(cid:48)) = O]

(1)

where the privacy budget (cid:15) controls the amount by which the
distributions induced by D and D(cid:48) may differ. A smaller (cid:15)
enforces a stronger privacy guarantee of A.

A general method for preserving (cid:15)-differential privacy of
any function F (on D) is the Laplace mechanism [5], where
the output of F is a vector of real numbers. In fact, the
mechanism exploits the global sensitivity of F over any two
neighboring data sets (differing at most one record), which is
denoted as GSF (D). Given GSF (D), the Laplace mechanism
ensures (cid:15)-differential privacy by injecting noise η into each
2GSF (D) exp(−|η| ·
value in the output of F(D): pdf (η) =
GSF (D) ), where η is drawn i.i.d. from Laplace distribution
with zero mean and scale GSF (D)/(cid:15).

(cid:15)

(cid:15)

Research in differential privacy has been signiﬁcantly stud-
ied, from both the theoretical perspective, e.g., [6, 18], and
the application perspective, e.g., data collection [19], spatio-
temporal correlations [20, 21], data streams [22], stochastic
gradient descents [23], recommendation [7], regression [6],

online learning [24], publishing contingency tables [25], and
spectral graph analysis [26].

B. Differential Privacy in Deep Learning

Deep neural networks deﬁne parameterized functions from
inputs xi ∈ D to outputs, i.e, a prediction of yi, as compo-
sitions of many layers of hidden neurons and nonlinear func-
tions. For instance, Fig. 2 illustrates a multilayer neural net-
work, in which there are k hidden layers H = {h1, . . . , hk}.
Rectiﬁed linear units (ReLUs) and sigmoids are widely used
examples of activation functions. By adjusting parameters of
these neurons, such parameterized functions can be trained
with the goal of ﬁtting a ﬁnite set of input-output data
instances. We specify a loss function FD(θ) that represents
the penalty for mismatching between the predicted and original
values of yi. FD(θ) on parameters θ is the average of the loss
over the training examples {x1,..., xn}. Stochastic gradient
descent (SGD) algorithm is used to minimize the cross-entropy
error [13], given the model outputs and true data labels.

In the work of Abadi et al. [12],
to preserve differential privacy, normal
(Gaussian) distribution noise is added
into the gradients ˜g of parameters W as
follows. At each training step t, the al-
gorithm ﬁrst takes a random sample Lt
with sampling probability L/n, where
L is a group size and n is the number
of tuples in D. For each tuple xi ∈ Lt,
the gradient gt(xi) = ∇θtFxi(θt) is
computed. Then the gradients will be
bounded by clipping each gradient in
l2 norm, i.e., the gradient vector gt is
replaced by gt/ max(1, (cid:107)g2
t (cid:107)/C) for a
predeﬁned threshold C. Normal distri-
bution noise is added into gradients of
parameters θ as

Fig. 2. An instance of
differentially private neu-
ral networks.

˜gt ←

(cid:88)

(cid:16)

1
L

i

gt(xi)
max(1, (cid:107)gt(xi)2(cid:107)

)

C

+ N (0, σ2C 2I)

(cid:17)

θt ← θt − ξt˜gt

(2)

(3)

where ξt is a learning rate at the training step t.

Finally, differentially private parameters θ, denoted θ,
learned by the algorithm are shared to the public and other
parties. Overall, the algorithm introduces noise into “gradi-
ents” of parameters at every training step. The magnitude of
injected noise and the privacy budget (cid:15) are accumulated in
proportion to the number of training epochs.

Compared with the work in [12], the goal is similar: learn-
ing differentially private parameters θ. However, we develop a
novel mechanism in which the privacy budget consumption is
independent of the number of training epochs. Our mechanism
is different. We redistribute the noise so that “more noise”
will be added into features which are “less relevant” to the
model output, and vice-versa. Moreover, we inject noise into
coefﬁcients of afﬁne transformations and loss functions, such
that differentially private parameters can be learned.

C. Layer-wise Relevance Propagation

Layer-wise Relevance Propagation (LRP) [15] is a well-
accepted algorithm, which is applied to compute the relevance
to the model outcome Fxi(θ).
of each input feature xij
Given the relevance, denoted R(k)
m (xi), of a certain neuron
m at the layer k, i.e., m ∈ hk, for the model outcome
Fxi(θ), LRP algorithm aims at obtaining a decomposition of
such relevance in terms of messages sent to neurons of the
previous layers, i.e., the layer (k-1)-th. These messages are
called R(k−1,k)
p←m (xi). The overall relevance of each neuron in
the lower layer is determined by summing up the relevance
coming from all upper-layer neurons:

R(k−1)
p

(xi) =

R(k−1,k)

p←m (xi)

(4)

(cid:88)

m∈hk

where the relevance decomposition is based on the ratio of
local and global afﬁne transformations and is given by:
zm(xi)+µ R(k)
zm(xi)−µ R(k)
with: zm(xi) is the afﬁne transformation of neuron m ∈ hk:

zm(xi) ≥ 0
zm(xi) < 0

m (xi)
m (xi)

p←m (xi) =

(cid:40) zpm(xi)

R(k−1,k)

zpm(xi)

(5)

zpm(xi) = pxi × Wpm
zm(xi) =

(cid:88)

zpm(xi) + bm

p∈hk

(6)

(7)

s.t. pxi is the value of neuron p given xi, Wpm is a weight
connecting the neuron p to neuron m, and bm is a bias term.
A predeﬁned stabilizer µ ≥ 0 is introduced to overcome
unboundedness.

In Eq. 5, in order to back propagate the relevance, we need
to compute the relevance R(k)
m (xi) at the last hidden layer, i.e.,
the k-th layer, from the output layer. Given the output variable
o, R(k)

m (xi) is computed as follows:

(cid:40) zmo(xi)

R(k)

m (xi) =

zo(xi)+µ Fxi(θ)
zmo(xi)
zo(xi)−µ Fxi(θ)
Given k hidden layers {h1, . . . , hk}, by using Eqs. 4, 5,
and 8, we can compute the relevance of every hidden neuron
and input feature. As in [15], the following equation holds:

zo(xi) ≥ 0
zo(xi) < 0

(8)

Fxi(θ) =

R(k)

m (xi) = . . . =

Rxij (xi)

(9)

(cid:88)

m∈hk

(cid:88)

xij ∈xi

where Rxij (xi) is the relevance of the feature xij given
the model outcome Fxi(θ). To ensure that
the relevance
Rxij (xi) ∈ [−1, 1], each Rxij (xi)
is normalized to
Rxij (xi)−χ
(ϕ−χ)
imum values in the domain of (cid:8)Rxi1 (xi), . . . , Rxid (xi)(cid:9).
III. ADAPTIVE LAPLACE MECHANISM (ADLM)

, where ϕ and χ denote the maximum and min-

In this section, we formally present our mechanism. Given
a loss function F(θ) with model parameters θ, the network is
trained by optimizing the loss function F(θ) on D by applying
SGD algorithm on T random training batches consequently.
At each training step, a single training batch L is used. A batch

L is a random set of training samples in D with a predeﬁned
batch size |L|.

The pseudo-codes of Algorithm 1 outline ﬁve basic steps
in our mechanism to learn differentially private parameters of
the model. The ﬁve basic steps are as follows:

• Step 1 (Lines 1-7). In the ﬁrst step, we obtain the average
relevances of all the j-th input features, denoted as Rj(D),
by applying the LRP algorithm on a well-trained deep neural
network on the database D. Rj(D) is computed as follows:

A. Private Relevance

In this section, we preserve differential privacy in the
computation of the relevance of each j-th input feature on
database D by injecting Laplace noise into Rj(D). We set
∆R = 2d
|D| based on the maximum values of all the relevances
Rj(D) (line 4, Alg. 1). In lines 5-6, the relevance of each j-
th input feature Rj(D) is perturbed by adding Laplace noise
Lap( ∆R
). The perturbed relevance is denoted as Rj. In line
(cid:15)1
7, we obtain the set of all perturbed relevances R(D):

Rj(D) =

Rxij (xi)

(10)

R(D) = (cid:8)Rj

(cid:9)

1
|D|

(cid:88)

xi∈D

Then, we derive differentially private relevances, denoted as
Rj, by injecting Laplace noise into Rj for all the j-th input
features. The total privacy budget in this step is (cid:15)1.

• Step 2 (Lines 8-14). In the second step, we derive a
differentially private afﬁne transformation layer, denoted h0.
Every hidden neuron h0j ∈ h0 will be perturbed by injecting
adaptive Laplace noise into its afﬁne transformation to pre-
serve differential privacy given a batch L. Based on Rj, “more
noise” is injected into features which are “less relevant” to the
model output, and vice-versa. The total privacy budget used
in this step is (cid:15)2. The perturbed afﬁne transformation layer is
denoted as h0L (Fig. 2).

• Step 3 (Line 15). In the third step, we stack hidden layers
{h1, . . . , hk} on top of the differentially private hidden layer
h0L to construct the deep private neural network (Fig. 2).
The computations of h1, . . . , hk are done based on the differ-
entially private layer h0L without accessing any information
from the original data. Therefore, the computations do not
disclose any information. Before each stacking operation, a
normalization layer, denoted h, is applied to bound non-linear
activation functions, such as ReLUs (Fig. 2).

• Step 4 (Lines 16-19). After constructing a private struc-
ture of hidden layers {h0L, h1, . . . , hk}, we need to protect
the labels yi at the output layer. To achieve this, we derive a
polynomial approximation of the loss function F. Then, we
perturb the loss function F by injecting Laplace noise with a
privacy budget (cid:15)3 into its coefﬁcients to preserve differential
privacy on each training batch L, denoted F L(θ).

• Step 5 (Lines 20-30). Finally, the parameter θT is derived
by minimizing the loss function F L(θ) on T training steps
sequentially. In each step t, stochastic gradient descent (SGD)
algorithm is used to update parameters θt given a random batch
L of training samples in D. This essentially is an optimization
process, without using any additional information from the
original data.

In our mechanism, differential privacy is preserved, since it
is enforced at every computation task that needs to access the
original data D. Laplace noise is injected into our model only
once, as a preprocessing step to preserve differential privacy in
the computation of the relevance Rj(D), the ﬁrst layer h0L,
and the loss function F L(θ). Thereafter, the training phase
will not access the original data again. The privacy budget
consumption does not accumulate in each training step. As
such, it is independent of the number of training epochs.

where Rj =

Rxij (xi) + Lap(

j∈[1,d]
1
(cid:88)
|D|

xi∈D

(11)

(12)

∆R
(cid:15)1

)

The computation of R(D) is (cid:15)1-differential private. The

correctness is based on the following lemmas.

Lemma 1: Let D and D(cid:48) be any two neighboring databases.
Given R(D) and R(D(cid:48)) be the relevance of all input features
on D and D(cid:48), respectively, and denote their representations as

R(D) = (cid:8)Rj(D)(cid:9)

j∈[1,d] s.t. Rj(D) =

Rxij (xi)

R(D(cid:48)) = (cid:8)Rj(D(cid:48))(cid:9)

j∈[1,d] s.t. Rj(D(cid:48)) =

Rx(cid:48)

ij

(x(cid:48)
i)

1
|D|

(cid:88)

xi∈D

1
|D(cid:48)|

(cid:88)

x(cid:48)

i∈D(cid:48)

Then, we have the following inequality:

1
|D|

d
(cid:88)

(cid:13)
(cid:13)
(cid:13)

(cid:88)

j=1

xi∈D

Rxij (xi) −

Rx(cid:48)

ij

(cid:13)
(x(cid:48)
(cid:13)
i)
(cid:13)1

≤

2d
|D|

(13)

(cid:88)

x(cid:48)

i∈D(cid:48)

where d is the number of features in each tuple xi ∈ D.
Proof 1: The proof of Lemma 1 is in Appendix A.
Lemma 2: Algorithm 1 preserves (cid:15)1-differential privacy in

the computation of R(D).

Proof 2: The proof of Lemma 2 is in Appendix B1.

Lemma 2 shows that the computa-
tion of the relevances R(D) is dif-
ferentially private. Fig. 3 illustrates
the differentially private relevance Rj
(Eq. 12) of each j-th coefﬁcient given
the database D. It is worth noting
that the relevance distribution is not
identical. In the next section, R(D) is
used to redistribute the noise injected
into the afﬁne transformation layer h0
in our deep neural network.

B. Private Afﬁne
Layer with Adaptive Noise

Transformation

Fig. 3. The average differ-
entially private relevance
of each input feature given
MNIST dataset.

In general, before applying activation functions such as
the afﬁne transformation of a hidden

ReLU and sigmoid,
neuron h ∈ h0 can be presented as:

hxi(W ) = b + xiW T
where b is a static bias, and W is the parameter of h. Given
a training batch L, h can be rewritten as:

(14)

hL(W ) =

(b + xiW T )

(15)

(cid:88)

xi∈L

Given the above representation of each neuron hL(Wh),
we preserve differential privacy in the computation of h0 on
L by injecting Laplace noise into inputs b and xi of every
neuron hL(W ) ∈ h0. Intuitively, we can apply an identical
noise distribution 1
) to all input features, where
∆h0 = 2 (cid:80)
d (line 9, Alg. 1). This approach works well
when every input feature has an identical contribution to the
model outcome. (Please refer to the Appendix C1.)

|L| Lap( ∆h0

h∈h0

(cid:15)2

In practice, this assumption usually is violated. For instance,
Fig. 1 illustrates the relevance, estimated by the LRP algorithm
[15], of each input feature given different handwritten digits. It
is clear that the relevances are not identical. The differentially
private relevances are not identical as well (Fig. 3). Therefore,
injecting the same magnitude of noise into all input features
may affect the utility of differentially private neural networks.
To address this problem, we propose an Adaptive Laplace
Mechanism (AdLM), to adaptively redistribute the injected
noise to improve the performance. Given hidden units hxi(W )
in Eq. 14, our key idea is to intentionally add more noise into
input features which are less relevant to the model output Y ,
and vice-versa. As a result, we expect to improve the utility
of the model under differential privacy. In fact, we introduce
a privacy budget ratio βj and the privacy budget (cid:15)j for each
j-th input feature as follows:

s.t.

(cid:15)j = βj × (cid:15)2

(16)

βj =

d × |Rj|
(cid:80)d
j=1 |Rj|
We set ∆h0 = 2 (cid:80)

h∈h0

d based on the maximum values
of all the input features xij (line 9, Alg. 1). In line 11, βj
can be considered as the fraction of the contribution to ∆h0
from the j-th input feature to the hidden neuron h ∈ h0. In
lines 12-13, each input feature xij of every hidden neuron h in
the ﬁrst afﬁne transformation layer h0 is perturbed by adding
adaptive Laplace noise 1
|L| Lap(∆h0 /(cid:15)j). The perturbed input
features are denoted as xi. In lines 20-21, given a random
training batch L, we construct the differentially private afﬁne
transformation layer h0L, which consists of perturbed hidden
neurons hL(W ):
h0L(W0) = (cid:8)hL(W )(cid:9)

s.t. hL(W ) =

xiW T + b

(cid:88)

(cid:16)

(cid:17)

h∈h0

xi∈L

|L| Lap( ∆h0

where b = b+ 1
) is the perturbed bias (line 14). The
following lemma shows that Alg. 1 preserves (cid:15)2-differential
privacy in the computation of h0L.

(cid:15)2

Lemma 3: Let L and L(cid:48) be any two neighboring batches.
Given parameter W0, let h0L and h0L(cid:48) be the ﬁrst afﬁne
transformation layers on L and L(cid:48), respectively, and denote
their representations as follows:
h0L(W0) = {hL(W )}h∈h0 s.t. hL(W ) =

(b + xiW T )

(cid:88)

h0L(cid:48)(W0) = {hL(cid:48)(W )}h∈h0 s.t. hL(cid:48)(W ) =

(b + x(cid:48)

iW T )

xi∈L
(cid:88)

x(cid:48)

i∈L(cid:48)

Then, we have the following inequality:

Algorithm 1 Adaptive Laplace Mechanism (Database D,
hidden layers H, loss function F(θ), and privacy budgets (cid:15)1,
(cid:15)2, and (cid:15)3, the number of batches T , the batch size |L|)

1: Compute the average relevance by applying the LRP Alg.
(cid:80)
2: ∀j ∈ [1, d] : Rj(D) = 1
|D|
3: Inject Laplace noise into the average relevance of each j-th

xi∈D Rxij (xi) #Eq.10#

input feature

4: ∆R = 2d/|D| #Lemma 1#
5: for j ∈ [1, d] do
(cid:80)
Rj ← 1
6:
|D|
7: R(D) = {Rj}j∈[1,d]
8: Inject Laplace noise into coefﬁcients of the differentially

xi∈D Rxij (xi) + Lap( ∆R

(cid:15)1

)

private layer h0

d #Lemma 3#

9: ∆h0 = 2 (cid:80)
h∈h0
10: for j ∈ [1, d] do
(cid:15)j ← βj × (cid:15)2 #Eq. 16#
11:
12: for xi ∈ D, j ∈ [1, d] do
xij ← xij + 1
|L| Lap(
13:
∆h0
14: b ← b + 1
|L| Lap(
(cid:15)2
15: Construct hidden layers {h1, . . . , hk} and normalization

) #perturb input feature xij#

) #perturb bias b#

∆h0
(cid:15)j

layers {h1, . . . , h(k)}

16: Inject Laplace noise into coefﬁcients of the approximated

) #perturb coefﬁcients of (cid:98)F

4 |h(k)|2) #Lemma 5#

loss function (cid:98)F
17: ∆F = M (|h(k)| + 1
18: for xi ∈ D, R ∈ [0, 2], l ∈ [1, M ] do
+ 1
19:
20: Initialize θ0 randomly
21: for t ∈ [T ] do
22:
23:

|L| Lap( ∆F
(cid:15)3

← φ(R)
lxi

(R)
lxi

φ

24:
25:
26:

Take a random training batch L
Construct differentially private afﬁne transformation
layer
h0L(W0) ← {hL(W )}h∈h0
s.t. hL(W ) = (cid:80)
Construct differentially private loss function
(cid:1)R
F L(θt) = (cid:80)M
(cid:80)2
l=1
Compute gradient descents
θt+1 ← θt − ηt

27:
28:
29:
30: Return θT #((cid:15)1 + (cid:15)2 + (cid:15)3)-differentially private#

(cid:79)θt F L(θt) #ηt is a learning rate#

(cid:0)xiW T + b)(cid:3)(cid:1)

(R)
lxi

W T

xi∈L

xi∈L

(cid:0)φ

1
|L|

R=0

(cid:80)

l(k)

∆h0 =

(cid:88)

d
(cid:88)

(cid:88)

(cid:13)
(cid:13)
(cid:13)

h∈h0

j=1

xi∈L

xij −

x(cid:48)
ij

(cid:13)
(cid:13)
(cid:13)1

(cid:88)

x(cid:48)

i∈L(cid:48)

≤ 2

d

(17)

(cid:88)

h∈h0

where d is the number of features in each tuple xi ∈ D.

Proof 3: Assume that L and L(cid:48) differ in the last tuple. Let

xn (x(cid:48)

n) be the last tuple in L (L(cid:48)). We have that

∆h0 =

(cid:88)

d
(cid:88)

(cid:88)

(cid:13)
(cid:13)
(cid:13)

h∈h0

j=1

xi∈L

xij −

x(cid:48)
ij

(cid:13)
(cid:13)
(cid:13)1

(cid:88)

x(cid:48)

i∈L(cid:48)

(cid:88)

d
(cid:88)

=

h∈h0

j=1

(cid:107)xnj − x(cid:48)

nj(cid:107)1 ≤ 2 max
xi∈L

(cid:107)xij(cid:107)1

(18)

(cid:88)

d
(cid:88)

h∈h0

j=1

Since ∀xi, j : xij ∈ [0, 1], from Eq. 18 we have that: ∆h0 ≤
2 (cid:80)
(cid:4)

d. Eq. 17 holds.

h∈h0

Lemma 4: Algorithm 1 preserves (cid:15)2-differential privacy in

the computation of h0L(W0) (lines 24-25).

Proof 4: From lines 24-25 in the Alg. 1, for each h ∈ h0L,

h can be re-written as:

hL(W ) =

d
(cid:88)

(cid:104) (cid:88)

j=1

xi∈L

(cid:0)xij +

1
|L|

Lap(

)(cid:1)W T (cid:105)

∆h0
(cid:15)j

1
|L|

(cid:88)

(cid:0)b +

+

xi∈L

Lap(

∆h0
(cid:15)2

)(cid:1)

(19)

Let us consider the static bias b = 1 as the 0-th input feature
and its associated parameter Wb, i.e., xi0 = b = 1 and W =
Wb ∪ W , we have that

hL(W ) =

d
(cid:88)

(cid:104) (cid:88)

j=0

xi∈L

(cid:0)xij +

1
|L|

Lap(

)(cid:1)W T (cid:105)

∆h0
(cid:15)j

(20)

d
(cid:88)

(cid:104) (cid:88)

=

j=0

xi∈L

xij + Lap(

(cid:105)
W T =

)

∆h0
(cid:15)j

d
(cid:88)

j=0

h
j W T

φ

(21)

h

where φ

j = (cid:2) (cid:80)
We can see that φ

xi∈L xij + Lap( ∆h0

(cid:15)j

)(cid:3).

h
j is the perturbation of the input feature
xij associated with the j-th parameter Wj ∈ W of the hidden
neuron h on L. Since all the hidden neurons h in h0 are
perturbed, we have that:

P r(cid:0)h0L(W0)(cid:1) =

(cid:89)

d
(cid:89)

exp(cid:0) (cid:15)j(cid:107)(cid:80)

xi∈L xij − φ

h
j (cid:107)

(cid:1)

h∈h0

j=0

∆h0

d (line 9 in Alg. 1). h0L(W0) is the

∆h0 is set to 2 (cid:80)

h∈h0
output (lines 24-25 in Alg. 1). We have that
j=0 exp (cid:0) (cid:15)j (cid:107)(cid:80)
(cid:81)d
j=0 exp (cid:0) (cid:15)j (cid:107)(cid:80)

P r(cid:0)h0L(W0)(cid:1)
P r(cid:0)h0L(cid:48)(W0)(cid:1) =

h∈h0

(cid:81)d

(cid:81)

(cid:81)

h∈h0

xi∈L xij −φh
∆h0
∈L(cid:48) x(cid:48)
∆h0

ij −φh

x(cid:48)
i

j (cid:107)1

(cid:1)

j (cid:107)1

(cid:1)

≤

≤

≤

(cid:89)

d
(cid:89)

h∈h0

j=0

(cid:89)

d
(cid:89)

h∈h0

j=1

(cid:89)

d
(cid:89)

h∈h0

j=1

≤ exp((cid:15)2

exp(

(cid:15)j
∆h0

(cid:13)
(cid:13)
(cid:13)

(cid:88)

xi∈L

xij −

x(cid:48)

ij

(cid:13)
(cid:13)
(cid:13)1

)

(cid:88)

x(cid:48)

i∈L(cid:48)

exp(

(cid:15)j
∆h0

2 max
xn∈L

(cid:13)
(cid:13)xnj

(cid:13)
(cid:13)1) ≤

(cid:89)

d
(cid:89)

h∈h0

j=1

exp(

2(cid:15)j
∆h0

)

)

2 d×|Rj |
(cid:80)d
j=1 |Rj |
∆h0
d(cid:2) (cid:80)d

j=1

exp((cid:15)2

2 (cid:80)

h∈h0

∆h0

|Rj |
j=1 |Rj |

(cid:80)d

(cid:3)

) = exp((cid:15)2)

Consequently,
differential privacy in Alg. 1.

the computation of h0L(W0) preserves (cid:15)2-
(cid:4)
Lemma 4 shows that we can redistribute the noise in the
computation of the ﬁrst hidden layer h0L under differential
privacy. In addition, given a batch L, without accessing
additional information from the original data, none of the
computations on top of h0L risk the privacy protection under
differential privacy. These computation tasks include the appli-
cation of activation functions, e.g., ReLU and sigmoid, on h0L,
the computation of hidden layers h1, . . . , hk, local response

normalizations, drop-out operations, polling layers, etc. (line
15, Alg. 1). This result can be applied to both fully-connected
layers and convolution layers. In this paper, we applied ReLU
on top of h0L and other layers h1, . . . , hk. Local response
normalization layers are used after the application of ReLUs
in each hidden layer to bound ReLU functions.

Local Response Normalization. The hidden units of the
lower layer will be considered as the input of the next layer
(Fig. 2). To ensure that this input is bounded hxi ∈ [0, 1], as in
[10, 27], we add a local response normalization (LRN) layer on
top of each hidden layer. Given a fully-connected layer, as in
[10], given an input xi, each perturbed neuron hxi (W ) can be
directly normalized as follows: hxi ←
/(ϕ−χ),
where ϕ and χ denote the maximum and minimum values in
the domain of {hxi}i∈L.

hxi(W )−χ

(cid:17)

(cid:16)

k
Given a convolution layer with a perturbed neuron h
ij at
location (i, j) in the k-th feature map, based on [27], our local
response normalization (LRN) is presented as follows:

k
k
h
ij/ max
ij ← h

k
ij, (cid:0)q + α
h

(cid:16)

min(N −1,k+l/2)
(cid:88)

m=max(0,k−l/2)

m

ij )2(cid:1)β(cid:17)

(h

(22)

where the constants q, l, α, and β are hyper-parameters, N is
the total number of feature maps. As in [27], we used q =
2, l = 5, α = 10−4, and β = 0.75 in our experiments.

C. Perturbation of the Loss Function FL(θ)

On top of our private deep neural network (Fig. 2), we add
an output layer with the loss function FL(θ) to predict Y .
Since the loss function FL(θ) accesses the labels yi given
xi ∈ L from the data, we need to protect the labels yi at the
output layer. First, we derive a polynomial approximation of
the loss function based on Taylor Expansion [28]. Then, we
inject Laplace noise into coefﬁcients of the loss function F to
preserve differential privacy on each training batch L.

The model output variables {ˆy1, . . . , ˆyM } are fully linked to
the normalized highest hidden layer, denoted h(k), by weighted
connections W(k) (Fig. 2). As common, the logistic function
can be used as an activation function of the output variables.
Given, l-th output variable ˆyl and xi, we have:

ˆyil = σ(cid:0)hxi(k)W T

l(k)

(cid:1)

(23)

where hxi(k)
navigating through the neural network.

is the state of h(k) derived from h0xi by

Cross-entropy error [13] can be used as a loss function. It
has been widely used and applied in real-world applications
[13]. Therefore, it is critical to preserve differential privacy
under the use of the cross-entropy error function. Other loss
functions, e.g., square errors, can be applied in the output layer,

M
(cid:88)

(cid:88)

(cid:16)

l=1

xi∈L

M
(cid:88)

(cid:88)

(cid:16)

l=1

xi∈L

as well. In our context, the cross-entropy error function is
given by:

Proof 5: The proof of Lemma 5 is in Appendix D1.
Lemma 6: Algorithm 1 preserves (cid:15)3-differential privacy in

FL(θ) = −

yil log ˆyil + (1 − yil) log(1 − ˆyil)

(cid:17)

the computation of F L(θt) (line 27).

Proof 6: The proof of Lemma 6 is in Appendix E1.

= −

yil log(1 + e−hxi(k)W T

l(k) )

+ (1 − yil) log(1 + ehxi(k)W T

l(k))

(24)

(cid:17)

Based on [10] and Taylor Expansion [28], we derive the

polynomial approximation of FL(θ) as:

(cid:0)hxi(k)W T

l(k)

(cid:1)R

M
(cid:88)

(cid:88)

2
(cid:88)

2
(cid:88)

q=1

R=0

(cid:98)FL(θ) =

l=1

xi∈L
(cid:104) 2
(cid:88)

M
(cid:88)

(cid:88)

=

l=1

xi∈L

q=1

f (R)
ql (0)
R!

2
(cid:88)

q=1
f (2)
ql (0)
2!

ql (0) + (cid:0)
f (0)

ql (0)(cid:1)hxi(k)W T
f (1)

l(k)

+ (cid:0)

2
(cid:88)

q=1

(cid:1)(hxi(k)W T

l(k))2(cid:105)

(25)

where ∀l ∈ [1, M ] : f1l(z) = yil log(1 + e−z) and f2l(z) =
(1 − yil) log(1 + ez).

To achieve (cid:15)3-differential privacy, we employ functional
mechanism [29] to perturb the loss function (cid:98)FL(θ) by injecting
Laplace noise into its polynomial coefﬁcients. So, we only
need to perturb (cid:98)FL(θ) just once in each training batch. To be
, φ(2)
clear, we denote {φ(0)
} as the coefﬁcients, where
lxi
lxi
φ(0)
and φ(2)
ql (0) and φ(1)
are coefﬁcients at the
lxi
lxi
lxi
ﬁrst order and the second order of the function (cid:98)FL(θ). In fact,
φ(1)
will be combinations between the approximation
lxi
terms (cid:80)2
ql (0), (cid:80)2

and φ(2)
lxi
q=1 f (1)

, and hxi(k).

q=1 f (0)

f (2)
ql (0)
2!

= (cid:80)2

, φ(1)
lxi

In Alg. 1, we set ∆F = M (|h(k)| + 1

4 |h(k)|2) (line 17).
In essence, coefﬁcients φ(R)
with R ∈ [0, 2] are functions
lxi
of the label yil only. Therefore, we can perform the pertur-
) into φ(R)
bation by injecting Laplace noise 1/|L|Lap( ∆F
lxi
(cid:15)3
for every training label yil ∈ D (lines 18-19). Then, the
(R)
perturbed coefﬁcients, denoted φ
lxi are used to construct the
differentially private loss function F L(θt) (line 27) during
the training process without accessing the original label yil
again (lines 20-30). Stochastic gradient descent and back-
propagation algorithms are used to minimize the perturbed
loss function F L(θt).

q=1

Now, we are ready to state that the computation of F L(θt)
is (cid:15)3-differentially private, and our mechanism preserves ((cid:15)1 +
(cid:15)2 + (cid:15)3)-differential privacy in the following lemmas.

Lemma 5: Let L and L(cid:48) be any two neighboring batches.
Let (cid:98)FL(θ) and (cid:98)FL(cid:48)(θ) be the loss functions on L and L(cid:48)
respectively, then we have the following inequality:

∆F =

M
(cid:88)

2
(cid:88)

(cid:88)

(cid:13)
(cid:13)
(cid:13)

l=1

R=0

xi∈L

(cid:88)

φ(R)
lxi

−

x(cid:48)

i∈L(cid:48)

φ(R)
lx(cid:48)
i

(cid:13)
(cid:13)
(cid:13) ≤ M (|h(k)|+

1
4

|h(k)|2)

where |h(k)| is the number of hidden neurons in h(k).

D. The Correctness and Characteristics of the AdLM

The following theorem illustrates that the Alg. 1 preserves

(cid:15)-differential privacy, where (cid:15) = (cid:15)1 + (cid:15)2 + (cid:15)3.

Theorem 1: Algorithm 1 preserves (cid:15)-differential privacy,

where (cid:15) = (cid:15)1 + (cid:15)2 + (cid:15)3.

Proof: At a speciﬁc training step t ∈ T , it is crystal clear
that the computation of h0L is (cid:15)2-differentially private (Lemma
4). Therefore, the computation of the hidden layers h1, . . . , hk
and normalization layers h are differentially private. This is
because they do not access any additional information from
the data. At the output layer, the loss function F L(θt) is (cid:15)3-
differentially private (Lemma 6). The computation of gradients
(cid:79)θtF L(θt) and descents is an optimization process, without
1
|L|
using any additional information from the original data. Thus,
θt+1 is differentially private (line 29, Alg. 1).

This optimization process is repeated through T steps with-
out querying the original data D (lines 21-30). This is done
because Laplace noise is injected into input features xij and
coefﬁcients φ(R)
as preprocessing steps (lines 3-19). Note that
lxi
(R)
xij and φ
lxi are associated with features xi and the label yi
respectively. h0L and F L(θt) are computed based on xij and
(R)
φ
lxi . As a result, the noise and privacy budget consumption
will not be accumulated during the training process.

Finally, F L(θt) uses the outputs of h0L, which essentially
uses the differentially private relevances R(D) as of one
inputs. R(D), h0L, and F L(θt) are achieved by applying
(cid:15)1, (cid:15)2, and (cid:15)3-differential privacy mechanisms. Furthermore,
F L(θt) and h0L access the same training batch L at each
training step. Therefore, based on the composition theorem
[11], the total privacy budget in Alg. 1 must be the summation
of (cid:15)1, (cid:15)2, and (cid:15)3.

where (cid:15) = (cid:15)1 + (cid:15)2 + (cid:15)3.

Consequently, Algorithm 1 preserves (cid:15)-differential privacy,
(cid:4)
Note that ∆R and ∆h0 are dependent on the number of
input features d. ∆R is negatively proportional to the number
of tuples in D. The larger the size of D, the less noise will be
injected into the private relevance R. ∆F is only dependent
on the number of neurons in the last hidden layer and the
output layer. In addition, ∆R, ∆h0 , and ∆F do not depend on
the number of training epochs. Consequently:

(1) The privacy budget consumption in our model is totally

independent of the number of training epochs.

(2) In order to improve the model utility under differential
privacy, our mechanism adaptively injects Laplace noise into
features based on the contribution of each to the model output.
(3) The average error incurred by our approximation ap-
proach, (cid:98)FL(θ), is bounded by a small number M × e2+2e−1
e(1+e)2
(Please refer to Lemma 7 in Appendix F1).

(4) The proposed mechanism can be applied to a variety
of deep learning models, e.g., CNNs [30], deep auto-encoders

[13], Restricted Boltzmann Machines [31], convolution deep
belief networks [32], etc., as long as we can perturb the ﬁrst
afﬁne transformation layer.

With these characteristics, our mechanism has a great po-
tential to be applied in large datasets, without consuming
excessive privacy budgets. In the experiment section, we will
show that our mechanism leads to accurate results.

IV. EXPERIMENTAL RESULTS
We have carried out an extensive experiment on two well-
known image datasets, MNIST and CIFAR-10. The MNIST
database of handwritten digits consists of 60,000 training ex-
amples, and a test set of 10,000 examples [16]. Each example
is a 28 × 28 size gray-level image. The CIFAR-10 dataset
consists of color images categorized into 10 classes, such as
birds, dogs, trucks, airplanes, etc. The dataset is partitioned
into 50,000 training examples and 10,000 test examples [17].
Competitive Models. We compare our mechanism with
the state-of-the-art differentially private stochastic gradient
descent (pSGD) for deep learning proposed by [12]. CNNs
are used in our experiments for both algorithms. The hyper-
parameters in pSGD are set
to the default values recom-
mended by Abadi et al. [12]. To comprehensively examine
the proposed approaches, our mechanism is implemented in
two different settings: (1) The Adaptive Laplace Mechanism
(Alg. 1)-based CNN with ReLUs, simply denoted AdLM; and
(2) An Identical Laplace Mechanism-based CNN with ReLUs
(ILM), in which an identical Laplace noise 1
) is
injected into each feature xij to preserve (cid:15)2-differential privacy
in the computation of the afﬁne transformation layer h0. In
the ILM algorithm, we do not need to use the differentially
private relevances R(D). More details about the ILM are in
the Appendix C1. The implementation of our mechanism is
publicly available1.

|L| Lap( ∆h0

(cid:15)2

A. MNIST Dataset

The designs of the three models are the same on the
MNIST dataset. We used two convolution layers, one with
32 features and one with 64 features. Each hidden neuron
connects with a 5x5 unit patch. A fully-connected layer with
25 units and an output layer of 10 classes (i.e., 10 digits)
with cross-entropy loss with LRN are used. The batch size
is 1,800. This also is the structure of the pre-trained model,
which is learned and used to compute the average relevances
R(D). The experiments were conducted on a single GPU, i.e.,
NVIDIA GTX TITAN X, 12 GB with 3,072 CUDA cores.

Fig. 4a illustrates the prediction accuracy of each model as
a function of the privacy budget (cid:15) on the MNIST dataset. It
is clear that our models, i.e., AdLM and ILM, outperform the
pSGD, especially when the privacy budget (cid:15) is small. This is
a crucial result, since smaller privacy budget values enforce
stronger privacy guarantees. When the privacy budget (cid:15) is
large, e.g., (cid:15) = 2, 4, 8, which means small noise is injected
into the model, the efﬁciencies of all the models are almost
converged to higher prediction accuracies.

1https://github.com/haiphanNJIT/PrivateDeepLearning

The AdLM model achieves the best performance. Given a
very small privacy budget (cid:15) = 0.25, it achieves 90.2% in terms
of prediction accuracy, compared with 88.46% obtained by the
ILM and 82.09% obtained by the pSGD. Overall, given small
values of the privacy budget (cid:15), i.e., 0.2 ≤ (cid:15) ≤ 0.5, the AdLM
improves the prediction accuracy by 7.7% on average (i.e.,
91.62%) compared with the pSGD (i.e., 83.93%). The result
is statistically signiﬁcant with p < 0.01 (t-test).

Figs. 4b-c illustrate the prediction accuracy of each model
the number of epochs under (cid:15) = 0.5 and (cid:15) = 2.0
vs.
respectively. Given large noise, i.e., (cid:15) = 0.5, the pSGD quickly
achieves higher prediction accuracies (i.e., 88.59%) after a
small number of epochs, compared with other models (Fig.
4b). However, the pSDG can only be applied to train the model
by using a limited number of epochs; speciﬁcally because the
privacy budget is accumulated after every training step. Mean-
while, our mechanism is totally independent of the number
of epochs in the consumption of privacy budget. Therefore,
after 500 epochs, our models outperform the pSGD. The
AdLM achieves the best performance, in terms of prediction
accuracy: 93.66%, whereas the ILM and the pSGD reached
only 92.39% and 88.59%, respectively. Interestingly, given
small noise, i.e., (cid:15) = 2.0, our models achieve higher accuracies
than the pSGD after a small number of epochs (Fig. 4c). This
result illustrates the crucial beneﬁts of being independent of
the number of training epochs in preserving differential privacy
in deep learning. With our mechanism, we can keep training
our models without accumulating noise and privacy budget.

B. CIFAR-10 Dataset

The designs of the three models are the same on the
CIFAR-10 dataset. We used three convolution layers, two with
128 features and one with 256 features. Each hidden neuron
connects with a 3x3 unit patch in the ﬁrst layer, and a 5x5
unit patch in other layers. One fully-connected layer with 30
neurons, and an output layer of 10 classes with a cross-entropy
loss with LRN are used. The batch size is set to 7,200. This
also is the structure of the pre-trained model, which is learned
and used to compute the average relevances R(D).

Fig. 5a shows the prediction accuracies of each model as
a function of the privacy budget (cid:15) on the CIFAR-10 dataset.
Figs. 5b-c illustrate the prediction accuracy of each model vs.
the number of epochs under different noise levels. Similar to
the results on the MNIST dataset, the results on CIFAR-10
strengthen our observations: (1) Our mechanism outperforms
the pSGD in terms of prediction accuracy, given both modest
and large values of the privacy budget (cid:15) (Fig. 5a); and (2) Our
mechanism has the ability to work with large-scale datasets,
since it is totally independent of the number of training epochs
in the consumption of privacy budget (Figs. 5b-c).

In fact, the AdLM improves the prediction accuracy by
5.9% on average (i.e., to 77%) compared with the pSGD (i.e.,
71.1%). The result is statistically signiﬁcant with p < 0.01
(t-test). Given large noise, i.e., (cid:15) = 2.5, our models including
the AdLM and ILM outperform the pSGD after 800 epochs
(Fig. 5b).

(a) accuracy vs. (cid:15)

(b) (cid:15) = 0.5 (large noise)

(c) (cid:15) = 2.0 (small noise)

Fig. 4. Accuracy for different noise levels on the MNIST dataset.

(a) accuracy vs. (cid:15)

(b) (cid:15) = 2.5 (large noise)

(c) (cid:15) = 8.0 (small noise)

Fig. 5. Accuracy for different noise levels on the CIFAR-10 dataset.

C. Adaptive Laplace Noise

It is important to note that by adaptively redistributing the
noise into input features based on the relevance of each to
the model output, we can achieve much better prediction
accuracies in both MNIST and CIFAR-10 datasets given
both small and large values of privacy budget (cid:15). This is
clearly demonstrated in Figs. 4a and 5a, since the AdLM
outperforms the ILM in all cases. Overall, the AdLM improves
the prediction accuracy by 2% and 5% on average on MNIST
and CIFAR-10 datasets correspondingly, compared with the
ILM. The result is statistically signiﬁcant with p < 0.05 (t-
test). Note that the ILM injected an identical amount of noise
into all input features, regardless of their contributions to the
model output. This is an important result, since our mechanism
is the ﬁrst of its kind, which can redistribute the noise injected
into the deep learning model to improve the utility. In addition,
the reallocation of (cid:15)1, (cid:15)2, and (cid:15)3 could further improve the
utility. This is an open research direction in the future work.

D. Computational Efﬁciency

In terms of computation efﬁciency, there are two differences
in our mechanism, compared with a regular deep neural
network: (i) The pre-trained model; and (ii) The noise injection
task. In practice,
is not necessarily
the pre-trained model
identical to the differentially private network trained by our
AdLM. A simple model can be used as a pre-trained model to
approximate the average relevance R(D), as long as the pre-
trained model is effective in terms of prediction accuracy even
over a small training dataset. Achieving this is quite straight-
forward, because: (1) The pre-trained model is noiseless; and
(2) The number of training epochs used to learn a pre-trained
model is small compared with the one of differentially private

models. In fact, we only correspondingly need 12 and 50
extra epochs to learn the pre-trained models on MNIST and
CIFAR-10 datasets. Training pre-trained models takes about
10 minutes on a single GPU, i.e., NVIDIA GTX TITAN X,
12 GB with 3,072 CUDA cores. Therefore, the model pre-
training for the computation of R(D) is efﬁcient.

Another difference in our mechanism is the noise injection
into input attributes and coefﬁcients of the loss function (cid:98)F.
In this task, the computations of ∆R, ∆h0, ∆F , Rj, βj, x,
and φ are efﬁcient and straight-forward, since there is not
any operation such as arg min, arg max, sorting, etc. The
complexity of these computations is O(cid:0)|D|(d + M )(cid:1), which
is linear to the size of the database D. In addition, these
computations can be efﬁciently performed in either a serial
process or a parallel process. Therefore, this task does not
affect the computational efﬁciency of our mechanism much.

V. CONCLUSIONS

In this paper, we proposed a novel mechanism, called
Adaptive Laplace Mechanism (AdLM), to preserve differential
privacy in deep learning. Our mechanism conducts both sensi-
tivity analysis and noise insertion on deep neural networks. It
is totally independent of the number of training epochs in the
consumption of privacy budget. That makes our mechanism
more practical. In addition, our mechanism is the ﬁrst of its
kind to have the ability to redistribute the noise insertion
toward the improvement of model utility in deep learning.
In fact, our mechanism has the ability to intentionally add
more noise into input features which are less relevant to the
model output, and vice-versa. Different activation functions
can be applied in our mechanism, as well. These distinctive
characteristics guarantee the ability to apply our mechanism on

large datasets in different deep learning models and in different
contexts. Our mechanism can clearly enhance the application
of differential privacy in deep learning. Rigorous experimental
evaluations conducted on well-known datasets validated our
theoretical results and the effectiveness of our mechanism.

ACKNOWLEDGMENT

This work is supported by the NIH grant R01GM103309
to the SMASH project. Wu is also supported by NSF grant
DGE-1523115 and IIS-1502273.

REFERENCES

[1] J. Levinson, J. Askeland, J. Becker, J. Dolson, D. Held,
S. Kammel, J. Z. Kolter, D. Langer, O. Pink, V. Pratt,
M. Sokolsky, G. Stanek, D. Stavens, A. Teichman,
M. Werling, and S. Thrun, “Towards fully autonomous
driving: Systems and algorithms,” in 2011 IEEE Intelli-
gent Vehicles Symposium (IV), 2011, pp. 163–168.
[2] D. Lowd, “Good word attacks on statistical spam ﬁlters,”

in CEAS’05, 2005.

[3] Y. Cheng, F. Wang, P. Zhang, and J. Hu, “Risk pre-
diction with electronic health records: A deep learning
approach,” in SDM’16, 2016.

[4] E. Choi, A. Schuetz, W. F. Stewart, and J. Sun, “Using
recurrent neural network models for early detection of
heart failure onset,” JAMIA, 2016.

[5] C. Dwork, F. McSherry, K. Nissim, and A. Smith,
“Calibrating noise to sensitivity in private data analysis,”
Theory of Cryptography, pp. 265–284, 2006.

[6] K. Chaudhuri and C. Monteleoni, “Privacy-preserving
logistic regression,” in NIPS’08, 2008, pp. 289–296.
[7] F. McSherry and I. Mironov, “Differentially Private Rec-

ommender Systems,” in KDD’09. ACM, 2009.

[8] F. McSherry and K. Talwar, “Mechanism design via
differential privacy,” in FOCS ’07, 2007, pp. 94–103.
[9] R. Shokri and V. Shmatikov, “Privacy-preserving deep

[10] N. Phan, Y. Wang, X. Wu, and D. Dou, “Differential pri-
vacy preservation for deep auto-encoders: an application
of human behavior prediction,” in AAAI’16, 2016, pp.
1309–1316.

[11] C. Dwork and J. Lei, “Differential privacy and robust

statistics,” in STOC’09, 2009, pp. 371–380.

[12] M. Abadi, A. Chu, I. Goodfellow, H. B. McMahan,
I. Mironov, K. Talwar, and L. Zhang, “Deep learning
with differential privacy,” arXiv:1607.00133, 2016.
[13] Y. Bengio, “Learning deep architectures for ai,” Found.
Trends Mach. Learn., vol. 2, no. 1, pp. 1–127, 2009.
[14] N. Dowlin, R. Gilad-Bachrach, K. Laine, K. Lauter,
M. Naehrig, and J. Wernsing, “Cryptonets: Applying
neural networks to encrypted data with high throughput
and accuracy,” in ICML’16, 2016, pp. 201–210.

[15] S. Bach, A. Binder, G. Montavon, F. Klauschen, K.-
R. M¨uller, and W. Samek, “On pixel-wise explanations
for non-linear classiﬁer decisions by layer-wise relevance

propagation,” PLoS ONE, vol. 10, no. 7, p. e0130140, 07
2015.

[16] Y. Lecun, L. Bottou, Y. Bengio, and P. Haffner,
“Gradient-based learning applied to document recogni-
tion,” Proceedings of the IEEE, vol. 86, no. 11, pp. 2278–
2324, 1998.

[17] A. Krizhevsky and G. Hinton, “Learning multiple layers

of features from tiny images,” 2009.

[18] D. Kifer and A. Machanavajjhala, “No free lunch in data

privacy,” in SIGMOD’11, 2011, pp. 193–204.

[19] U. Erlingsson, V. Pihur, and A. Korolova, “Rappor:
Randomized aggregatable privacy-preserving ordinal re-
sponse,” in CCS’14, 2014, pp. 1054–1067.

[20] C. Liu, S. Chakraborty, and P. Mittal, “Dependence
Makes You Vulnerable: Differential Privacy Under De-
pendent Tuples,” in NDSS’16, Feb. 2016.

[21] Y. Cao, M. Yoshikawa, Y. Xiao, and L. Xiong, “Quan-
tifying differential privacy under temporal correlations,”
CoRR, vol. abs/1610.07543, 2016.

[22] T.-H. H. Chan, M. Li, E. Shi, and W. Xu, “Differen-
tially private continual monitoring of heavy hitters from
distributed streams,” in PETS’12, 2012, pp. 140–159.

[23] S. Song, K. Chaudhuri, and A. D. Sarwate, “Stochastic
gradient descent with differentially private updates,” in
GlobalSIP, 2013, pp. 245–248.

[24] P. Jain, P. Kothari, and A. Thakurta, “Differentially
private online learning,” in COLT’12, 2012, pp. 24.1–
24.34.

[25] X. Xiao, G. Wang, and J. Gehrke, “Differential privacy
via wavelet transforms,” in ICDE’10, 2010, pp. 225–236.
[26] Y. Wang, X. Wu, and L. Wu, “Differential privacy
preserving spectral graph analysis,” in PAKDD (2), 2013,
pp. 329–340.

[27] A. Krizhevsky, I. Sutskever, and G. E. Hinton, “Imagenet
classiﬁcation with deep convolutional neural networks,”
in NIPS’12, 2012, pp. 1097–1105.

[28] G. Arfken,

in Mathematical Methods for Physicists

[29] J. Zhang, Z. Zhang, X. Xiao, Y. Yang, and M. Winslett,
“Functional mechanism: regression analysis under differ-
ential privacy,” PVLDB, vol. 5, no. 11, pp. 1364–1375,
2012.

[30] Y. Lecun, L. Bottou, Y. Bengio, and P. Haffner,
“Gradient-based learning applied to document recogni-
tion,” Proceedings of the IEEE, vol. 86, no. 11, pp. 2278–
2324, 1998.

[31] P. Smolensky, “Information processing in dynamical sys-
tems: Foundations of harmony theory,” 1986, ch. Parallel
Distributed Processing: Explorations in the Microstruc-
ture of Cognition, Vol. 1, pp. 194–281.

[32] H. Lee, R. Grosse, R. Ranganath, and A. Y. Ng, “Convo-
lutional deep belief networks for scalable unsupervised
learning of hierarchical representations,” in ICML’09,
2009, pp. 609–616.

[33] T. Apostol, Calculus.

John Wiley & Sons, 1967.

learning.” in CCS’15, 2015, pp. 1310–1321.

(Third Edition). Academic Press, 1985.

APPENDIX

A. Proof of Lemma 1

we have that ∀xi ∈ D, j ∈ [1, d] : xij = xij + 1
For each h ∈ h0L, h can be re-written as:

|L| Lap( ∆h0

(cid:15)2

).

Proof 1: Assume that D and D(cid:48) differ in the last tuple. Let

xn (x(cid:48)

n) be the last tuple in D (D(cid:48)). We have that

hL(W ) =

d
(cid:88)

(cid:104) (cid:88)

j=1

xi∈L

(cid:0)xij +

1
|L|

Lap(

)(cid:1)W T (cid:105)

∆h0
(cid:15)2

1
|L|

(cid:88)

(cid:0)b +

+

xi∈L

Lap(

∆h0
(cid:15)2

)(cid:1)

(27)

Rx(cid:48)

ij

(cid:13)
(x(cid:48)
(cid:13)
i)
(cid:13)1

(cid:88)

x(cid:48)

i∈D(cid:48)

∆R =

Rxij (xi) −

1
|D|

1
|D|

2
|D|

=

≤

d
(cid:88)

(cid:13)
(cid:13)
(cid:13)

(cid:88)

j=1

xi∈D

d
(cid:88)

j=1

max
xi∈D

d
(cid:88)

j=1

(cid:13)
(cid:13)
(cid:13)Rxnj (xn) − Rx(cid:48)

nj

(x(cid:48)

(cid:13)
(cid:13)
n)
(cid:13)1

(cid:107)Rxij (xi)(cid:107)1 ≤

2d
|D|

Eq. 13 holds.

B. Proof of Lemma 2

Proof 2: Let D and D(cid:48) be two neighbor databases. Without
loss of generality, assume that D and D(cid:48) differ in the last tuple
xn (x(cid:48)
n). Rj(D) is calculated as done in line 6, Alg. 1, and
R(D) = (cid:8)Rj(D)(cid:9)
j∈[1,d] is the output of the Alg. 1 (line 7).
The perturbation of the relevance Rj(D) can be rewritten as:

Rj =

Rxij (xi) + Lap(

(26)

∆R
(cid:15)1

)

1
|D|

(cid:88)

xi∈D

Since all the input features are perturbed, we have that

P r(cid:0)R(D)(cid:1)
P r(cid:0)R(D(cid:48))(cid:1) =

≤

exp(

j=1 exp (cid:0) (cid:15)1(cid:107) 1
(cid:81)d
j=1 exp (cid:0) (cid:15)1(cid:107) 1
(cid:81)d
(cid:13)
(cid:88)
(cid:13)
(cid:13)

xi∈D

(cid:15)1
|D|∆R

Rj(xi) −

(cid:80)

|D|

xi∈D Rj (xi)−Rj (cid:107)1

(cid:1)

|D|

(cid:80)

x(cid:48)
i

∆R
∈D Rj (x(cid:48)
∆R

i)−Rj (cid:107)1

(cid:1)

(cid:13)
Rj(x(cid:48)
(cid:13)
i)
(cid:13)1

)

(cid:88)

x(cid:48)

i∈D(cid:48)

d
(cid:89)

j=1

d
(cid:89)

j=1

d
(cid:89)

j=1

≤

exp(

(cid:15)1
|D|∆R

(cid:13)
(cid:13)
(cid:13)Rj(xn) − Rj(x(cid:48)
(cid:13)
(cid:13)
n)
(cid:13)1

)

≤

exp(

(cid:15)1
|D|∆R

2 max
xn∈D

(cid:13)
(cid:13)Rj(xn)(cid:13)

(cid:13)1)

2 maxxn∈L

j=1(cid:107)Rj(xn)(cid:107)1

(cid:80)d

)

|D|∆R

≤ exp((cid:15)1

≤ exp((cid:15)1)

Let us consider the static bias b = 1 as the 0-th input feature
and its associated parameter Wb, i.e., xi0 = b = 1 and W =
Wb ∪ W , we have that

hL(W ) =

d
(cid:88)

(cid:104) (cid:88)

j=0

xi∈L

(cid:0)xij +

1
|L|

Lap(

)(cid:1)W T (cid:105)

∆h0
(cid:15)2

(28)

d
(cid:88)

(cid:104) (cid:88)

=

j=0

xi∈L

xij + Lap(

(cid:105)
W T =

)

∆h0
(cid:15)2

d
(cid:88)

j=0

h
j W T

φ

(29)

h

where φ

j = (cid:2) (cid:80)
We can see that φ

xi∈L xij + Lap( ∆h0

(cid:15)2

)(cid:3).

h
j is the perturbation of the input feature
xij associated with the j-th parameter Wj ∈ W of the hidden
neuron h on L. Since all the hidden neurons h in h0 are
perturbed, we have that:

P r(cid:0)h0L(W0)(cid:1) =

(cid:89)

d
(cid:89)

exp(cid:0) (cid:15)2(cid:107)(cid:80)

xi∈L xij − φ

h
j (cid:107)

(cid:1)

h∈h0

j=0

∆h0

∆h0 is set to 2 (cid:80)
h∈h0
the output, we have that

d and h0L(W0) = {hL(W )}h∈h0 is

P r(cid:0)h0L(W0)(cid:1)
P r(cid:0)h0L(cid:48)(W0)(cid:1) =

(cid:81)

h∈h0

(cid:81)

h∈h0

j=0 exp (cid:0) (cid:15)2(cid:107)(cid:80)
(cid:81)d
j=0 exp (cid:0) (cid:15)2(cid:107)(cid:80)

(cid:81)d

xi∈L xij −φh
∆h0
∈L(cid:48) x(cid:48)
∆h0

ij −φh

x(cid:48)
i

j (cid:107)1

(cid:1)

j (cid:107)1

(cid:1)

exp(

(cid:15)2
∆h0

(cid:13)
(cid:13)
(cid:13)

(cid:88)

xi∈L

xij −

x(cid:48)

ij

(cid:13)
(cid:13)
(cid:13)1

)

(cid:88)

x(cid:48)

i∈L(cid:48)

(cid:13)
(cid:13)xnj − x(cid:48)
(cid:13)

nj

(cid:13)
(cid:13)
(cid:13)1

)

≤

≤

≤

(cid:89)

d
(cid:89)

h∈h0

j=0

(cid:89)

d
(cid:89)

h∈h0

j=1

(cid:89)

d
(cid:89)

h∈h0

j=1

exp(

exp(

(cid:15)2
∆h0

(cid:15)2
∆h0

d

2 (cid:80)

h∈h0
∆h0

≤ exp((cid:15)2

) = exp((cid:15)2)

2 max
xn∈L

(cid:13)
(cid:13)xnj

(cid:13)
(cid:13)1) ≤

(cid:89)

d
(cid:89)

h∈h0

j=1

exp(

2(cid:15)2
∆h0

)

Consequently,
differential privacy in Alg. 1.

the computation of R(D) preserves

(cid:15)1-

C. Identical Laplace Mechanism (ILM)

We can add an identical noise distribution 1

|L| Lap( ∆h0
) to
all input features, where ∆h0 = 2 (cid:80)
d (line 9, Alg. 1) to
preserve differential privacy in the computation of h0. In fact,

h∈h0

(cid:15)2

Consequently, based on the above analysis, the computation
of h0L(W0) preserves (cid:15)2-differential privacy in Alg. 1 by
injecting an identical Laplace noise 1
) into all input
features. In addition, given the identical Laplace noise, we
do not need to use the differentially private relevance R(D),
since we do not need to redistribute the noise in the ﬁrst afﬁne
transformation layer h0.

|L| Lap( ∆h0

(cid:15)2

D. Proof of Lemma 5

have that

Proof 5: Assume that L and L(cid:48) differ in the last tuple. Let

xn (x(cid:48)

n) be the last tuple in L (L(cid:48)). We have that

∆F =

M
(cid:88)

2
(cid:88)

(cid:88)

(cid:13)
(cid:13)
(cid:13)

l=1

R=0

xi∈L

φ(R)
lxi

−

φ(R)
lx(cid:48)
i

(cid:13)
(cid:13)
(cid:13)

(cid:88)

x(cid:48)

i∈L(cid:48)

M
(cid:88)

2
(cid:88)

=

l=1

R=0

(cid:13)
(cid:13)φ(R)
lxn

− φ(R)
lx(cid:48)
n

(cid:13)
(cid:13)

(30)

= (cid:80)2

We can show that φ(0)
lxn
ynl) log 2 = log 2. Similarly, we can show that φ(0)
lx(cid:48)
n
As a result, φ(0)
lxn

ql (0) = ynl log 2 + (1 −
= log 2.

q=1 f (0)

. Therefore

= φ(0)
lx(cid:48)
n

∆F =

(cid:13)
(cid:13)φ(R)
lxn

− φ(R)
lx(cid:48)
n

(cid:13)
(cid:13) =

(cid:13)
(cid:13)φ(R)
lxn

− φ(R)
lx(cid:48)
n

(cid:13)
(cid:13)

M
(cid:88)

2
(cid:88)

l=1

R=1

(cid:0)(cid:13)
(cid:13)φ(R)
lxn

(cid:13) + (cid:13)
(cid:13)

(cid:13)φ(R)
lx(cid:48)
n

(cid:13)
(cid:1) ≤ 2 max
(cid:13)
xn

M
(cid:88)

2
(cid:88)

l=1

R=1

(cid:107)φ(R)
lxn

(cid:107)

M
(cid:88)

2
(cid:88)

l=1
M
(cid:88)

R=0
2
(cid:88)

l=1

R=1

≤

≤ 2 max
xn

(cid:104) M
(cid:88)
(

l=1

1
2

|h(k)|
(cid:88)

− ynl)

hexn(k)

e=1
M
(cid:88)

(cid:0) 1
8

+

l=1

e,g

(cid:88)

hexn(k)hgxn(k)

(cid:1)(cid:105)

≤ 2(

M × |h(k)| +

M × |h(k)|2)

1
2

1
8
|h(k)|2)

1
4

= M (|h(k)| +

E. Proof of Lemma 6

Proof 6: Let L and L(cid:48) be two neighbor batches. Without
loss of generality, assume that L and L(cid:48) differ in the last
tuple xn (x(cid:48)
n). ∆F is calculated as done in line 17, Alg. 1,
and F L(θt) = (cid:80)M
is the
output of line 27 of the Alg. 1. Note that hxi(k) is the state
of h(k) derived from h0xi by navigating through the neural
network. The perturbation of the coefﬁcient φ(R)
, denoted as
(R)
φ
l

, can be rewritten as:

(cid:0)hxi(k)W T

R=0 φ

(R)
lxi

(cid:80)2

xi∈L

(cid:1)R

(cid:80)

l(k)

l=1

l

(R)
l =

φ

(cid:104) (cid:88)

φ(R)
lxi

+ Lap(

(cid:105)
)

∆F
(cid:15)3

xi∈L

−φ(R)
l

(cid:107)1

(cid:1)

−φ(R)
l

(cid:107)1

(cid:1)

x(cid:48)
i

xi∈L φ(R)
lxi
∆F
∈L(cid:48) φ(R)
lxi
∆F
(cid:13)
(cid:13)
(cid:13)1

φ(R)
lx(cid:48)
i

)

P r(cid:0)F L(θt)(cid:1)
P r(cid:0)F L(cid:48)(θt)(cid:1) =

(cid:81)M

l=1

(cid:81)M

l=1

R=0 exp (cid:0) (cid:15)3(cid:107)(cid:80)
(cid:81)2
R=0 exp (cid:0) (cid:15)3(cid:107)(cid:80)

(cid:81)2

exp(

(cid:15)3
∆F

(cid:13)
(cid:13)
(cid:13)

(cid:88)

xi∈L

φ(R)
lxi

−

(cid:88)

x(cid:48)

i∈L(cid:48)

exp(

exp(

(cid:15)3
∆F

(cid:15)3
∆F

(cid:13)
(cid:13)φ(R)
(cid:13)

lxn

− φ(R)
lx(cid:48)
n

(cid:13)
(cid:13)
(cid:13)1

)

2 max
xn∈L

(cid:13)
(cid:13)φ(R)
lxn

(cid:13)
(cid:13)1)

≤

≤

≤

M
(cid:89)

2
(cid:89)

l=1

R=0

M
(cid:89)

2
(cid:89)

l=1
M
(cid:89)

R=0
2
(cid:89)

l=1

R=0

≤ exp((cid:15)3

2 maxxn∈L

(cid:80)2

R=0(cid:107)φ(R)
lxn

(cid:107)1

)

(cid:80)M

l=1
∆F
4 |h(k)|2)

) = exp((cid:15)3)

≤ exp((cid:15)3

M (|h(k)| + 1
∆F

Consequently,
differential privacy in Alg. 1.

the computation of F L(θt) preserves (cid:15)3-

F. Approximation Error Bounds

The following lemma illustrates the result of how much
error our approximation approach, (cid:98)FL(θ) (Eq. 25), incurs. The
error only depends on the number of possible classiﬁcation
outcomes M . In addition, the average error of the approxima-
tions is always bounded. As in [10, 29], the approximation of
the loss function FL(θ) by applying Taylor Expansion without
removing all polynomial terms with order larger than 2 is as
follows:

M
(cid:88)

(cid:88)

2
(cid:88)

∞
(cid:88)

l=1

xi∈L

q=1

R=0

f (R)
ql (zql)
R!

(cid:0)gql(hxi(k), Wl(k))−zql

(cid:1)R

∀l ∈ {1, . . . , M }, let f1l, f2l, g1l, and g2l be four functions
deﬁned as follows:

g1l(hxi(k), Wj) = hxi(k)W T
g2l(hxi(k), Wj) = hxi(k)W T

l(k)

l(k)

f1l(z1l) = yil log(1 + e−z1l )
f2l(z2l) = (1 − yil) log(1 + ez2l )

(32)

(33)

(34)

(35)

where ∀q, l : zql is a real number.
∀q, l, by setting zql = 0,

simpliﬁed as:

the above equation can be

(31)

(cid:101)FL(θ) =

M
(cid:88)

(cid:88)

2
(cid:88)

∞
(cid:88)

l=1

xi∈L

q=1

R=0

f (R)
ql (0)
R!

(cid:0)hxi(k)W T

l(k)

(cid:1)R

(36)

where hexn(k) is the state of e-th hidden neuron in h(k).

(cid:101)FL(θ) =

We can see that φ

is the perturbation of the coefﬁcient
associated with the labels yil in the training batch L. We

φ(R)
l

(R)
l

As in [10], our approximation approach works by truncating
the Taylor series in Eq. 36 to remove all polynomial terms with

order larger than 2. This leads to a new objective function in
Eq. 25 with low-order polynomials as follows:

(cid:98)FL(θ) =

l=1

xi∈L
(cid:104) 2
(cid:88)

M
(cid:88)

(cid:88)

=

l=1

xi∈L

q=1

M
(cid:88)

(cid:88)

2
(cid:88)

2
(cid:88)

q=1

R=0

f (R)
ql (0)
R!

(cid:0)hxi(k)W T

l(k)

(cid:1)R

ql (0) + (cid:0)
f (0)

ql (0)(cid:1)hxi(k)W T
f (1)

l(k)

2
(cid:88)

q=1

+ (cid:0)

2
(cid:88)

q=1

f (2)
ql (0)
2!

(cid:1)(hxi(k)W T

l(k))2(cid:105)

We are now ready to state the following lemma to show the

approximation error bound of our approach.

Lemma 7: Given two polynomial functions (cid:101)FL(θ) (Eq. 36)
and (cid:98)FL(θ) (Eq. 25), the average error of the approximation is
always bounded as follows:

| (cid:101)FL((cid:98)θ) − (cid:101)FL((cid:101)θ)| ≤ M ×

(37)

e2 + 2e − 1
e(1 + e)2

where (cid:101)θ = arg minθ (cid:101)FL(θ) and (cid:98)θ = arg minθ (cid:98)FL(θ).

(cid:0)

(cid:101)FL(θ)− (cid:98)FL(θ)(cid:1) and S = minθ

Proof 7: Let (cid:101)θ = arg minθ (cid:101)FL(θ) and (cid:98)θ = arg minθ (cid:98)FL(θ),
(cid:101)FL(θ)− (cid:98)FL(θ)(cid:1).
U = maxθ
We have that U ≥ (cid:101)FL((cid:98)θ) − (cid:98)FL((cid:98)θ) and ∀θ∗ : S ≤ (cid:101)FL(θ∗) −
(cid:98)FL(θ∗). Therefore, we have

(cid:0)

(cid:101)FL((cid:98)θ) − (cid:98)FL((cid:98)θ) − (cid:101)FL(θ∗) + (cid:98)FL(θ∗) ≤ U − S
⇔ (cid:101)FL((cid:98)θ) − (cid:101)FL(θ∗) ≤ U − S + (cid:0)

(cid:98)FL((cid:98)θ) − (cid:98)FL(θ∗)(cid:1)

In addition, (cid:98)FL((cid:98)θ) − (cid:98)FL(θ∗) ≤ 0, so (cid:101)FL((cid:98)θ) − (cid:101)FL(θ∗) ≤

U − S. If U ≥ 0 and S ≤ 0 then we have:

| (cid:101)FL((cid:98)θ) − (cid:101)FL(θ∗)| ≤ U − S

(38)

Eq. 38 holds for every θ∗. Therefore, it still holds for (cid:101)θ. Eq.
38 shows that the error incurred by truncating the Taylor series
approximate function depends on the maximum and minimum
values of (cid:101)FL(θ) − (cid:98)FL(θ). To quantify the magnitude of the
error, we ﬁrst rewrite (cid:101)FL(θ) − (cid:98)FL(θ) as:

M
(cid:88)

(cid:104)

l=1
∞
(cid:88)

(cid:101)FL(θ) − (cid:98)FL(θ) =

(cid:101)FL(Wl(k)) − (cid:98)FL(Wl(k))

(cid:105)

M
(cid:88)

(cid:104) (cid:88)

2
(cid:88)

=

l=1

xi∈L

q=1

R=3

f (R)
ql (zql)
R!

(cid:0)gql(hxi(k), Wl(k)) − zql

(cid:1)R(cid:105)

To derive the minimum and maximum values of the function
above, we look into the remainder of the Taylor Expansion for
each l. Let zl ∈ [zql −1, zql +1]. According to the well-known
(cid:101)FL(Wl(k)) − (cid:98)FL(Wl(k))(cid:1) must be in the in-
result [33],
(cid:104) (cid:80)
q

1
|D|
minzl f (3)

ql (zl)(zl−zql)3

ql (zl)(zl−zql)3

maxzl f (3)

, (cid:80)
l

terval

(cid:105)
.

(cid:0)

6

6

maxzl f (3)

If (cid:80)
q
6
minzl f (3)
ql (zl)(zl−zql)3

ql (zl)(zl−zql)3

(cid:80)
q

6

≤ 0, then we have that:

≥

0

and

(cid:101)FL(θ) − (cid:98)FL(θ)

(cid:105)(cid:12)
(cid:12)
(cid:12)

(cid:104)

(cid:12)
(cid:12)
(cid:12)

1
|L|
M
(cid:88)

≤

l=1

q

maxzl f (3)

ql (zl)(zl − zql)3 − minzl f (3)

ql (zl)(zl − zql)3

(cid:88)

6

(39)

This analysis applies to the case of the cross-entropy
error-based loss function as follows. First, for the functions
f1l(z1l) = yil log(1 + e−z1l ) and f2l(z2l) = (1 − yil) log(1 +
ez2l ), we have

f (3)
1l (z1l) =

2yilez1l
(1 + ez1l)3

f (3)
2l (z2l) = (1 − yil)

e−z2l (e−z2l − 1)
(1 + e−z2l )3

It can be veriﬁed that arg minz1l f (3)
1l (z1l) = 2e

1l (z1l) = −2e
(1+e)3 > 0, arg minz2l f (3)
arg maxz1l f (3)
e(1+e)3 < 0, and arg maxz2l f (3)
2l (z2l) = e(e−1)
the average error of the approximation is at most

(1+e)3 < 0,
2l (z2l) =
(1+e)3 > 0. Thus,

1−e

(cid:12) (cid:101)FL((cid:98)θ) − (cid:101)FL((cid:101)θ)(cid:12)
(cid:12)

(cid:12) ≤ M ×

+ (cid:0) e(e − 1)

(1 + e)3 −
Therefore, Eq. 37 holds.

G. Corrections of the Paper

−2e
(1 + e)3

(cid:1)

(cid:104)(cid:0)

2e
(1 + e)3 −
(cid:1)(cid:105)

1 − e
e(1 + e)3

= M ×

e2 + 2e − 1
e(1 + e)2

The differences between this correction and the ﬁrst sub-

mission of our paper can be summarized as follows:

1. There was a mistake in terms of model conﬁgurations
reported in our original version. The number of layers,
hidden neurons, unit patches, and batch sizes are updated
in this correction version. The experimental results of
our algorithms and the differentially private Stochastic
Gradient Descent algorithm (pSGD) [12] are updated as
well. In fact, the code release of the pSGD algorithm2 is
used in this version. The pSGD algorithm is signiﬁcantly
improved in terms of accuracy, and the computation of
the privacy budget (cid:15) is also more accurate.
2. We replace the equations of coefﬁcients {φ(0)
lxi

, φ(1)
,
lxi
φ(2)
}, i.e., after the Eq. 25, with a more detailed ex-
lxi
planation, since it may cause some misunderstanding
to the readers in terms of identifying coefﬁcients of
the Taylor Expansion in Eq. 25. To be clear, we de-
note {φ(0)
, φ(1)
=
lxi
lxi
(cid:80)2
ql (0) and φ(1)
q=1 f (0)
and φ(2)
are coefﬁcients at the
lxi
lxi
ﬁrst order and the second order of the function (cid:98)FL(θ).
and φ(2)
φ(1)
are combinations between the approxima-
lxi
lxi
f (2)
ql (0)
tion terms (cid:80)2
q=1 f (1)
2!

} as the coefﬁcients, where φ(0)
lxi

ql (0), (cid:80)2

, and hxi(k).

, φ(2)
lxi

q=1

2https://github.com/tensorﬂow/models/tree/master/research/differential privacy

Adaptive Laplace Mechanism: Differential Privacy
Preservation in Deep Learning

NhatHai Phan∗1, Xintao Wu†, Han Hu∗, and Dejing Dou‡
∗New Jersey Institute of Technology, Newark, New Jersey, USA
†University of Arkansas, Fayetteville, Arkansas, USA
‡University of Oregon, Eugene, Oregon, USA
Emails: phan@njit.edu, xintaowu@uark.edu, hh255@njit.edu, and dou@cs.uoregon.edu

8
1
0
2
 
r
p
A
 
3
2
 
 
]

R
C
.
s
c
[
 
 
2
v
0
5
7
5
0
.
9
0
7
1
:
v
i
X
r
a

Abstract—In this paper, we focus on developing a novel
mechanism to preserve differential privacy in deep neural net-
works, such that: (1) The privacy budget consumption is totally
independent of the number of training steps; (2) It has the ability
to adaptively inject noise into features based on the contribution
of each to the output; and (3) It could be applied in a variety
of different deep neural networks. To achieve this, we ﬁgure
out a way to perturb afﬁne transformations of neurons, and
loss functions used in deep neural networks. In addition, our
mechanism intentionally adds “more noise” into features which
are “less relevant” to the model output, and vice-versa. Our
theoretical analysis further derives the sensitivities and error
bounds of our mechanism. Rigorous experiments conducted on
MNIST and CIFAR-10 datasets show that our mechanism is
highly effective and outperforms existing solutions.

I. INTRODUCTION

Today, deep learning has become the tool of choice in many
areas of engineering, such as autonomous systems, signal
and information processing, and data analytics. Deep learning
systems are, therefore, not only applied in classic settings, such
as speech and handwriting recognition, but also progressively
operate at the core of security and privacy critical applications.
For instance, self-driving cars make use of deep learning for
recognizing objects and street signs [1]. Detection systems for
email spam integrate learning methods for analyzing data more
effectively [2]. Furthermore, deep learning has applications in
a number of healthcare areas, e.g., phenotype extraction and
health risk prediction [3], prediction of the development of
various diseases, including schizophrenia, cancers, diabetes,
heart failure, etc. [4], and many more. This presents an obvious
threat to privacy in new deep learning systems which are being
deployed. However, there are only a few scientiﬁc studies in
preserving privacy in deep learning.

In the past few decades, a subject of signiﬁcant interest has
been how to release the sensitive results of statistical analyses
and data mining, while still protecting privacy. One state-
of-the-art privacy model is (cid:15)-differential privacy [5], which
ensures that the adversary cannot infer any information about
any speciﬁc record with high conﬁdence (controlled by a
privacy budget) from the released learning models, even if
all the remaining tuples of the sensitive data are possessed
by the adversary. The privacy budget controls the amount by

1 This is a correction version of the previous arXiv:1709.05750 and
ICDM’17 published version. Refer to Appendix G for summary of changes.

which the output distributions induced by two neighboring
datasets may differ: A smaller privacy budget value enforces
a stronger privacy guarantee. Differential privacy research has
been studied from both theoretical and application perspectives
[6, 7]. The mechanisms of achieving differential privacy
mainly include adding Laplace noise [5],
the exponential
mechanism [8], and the functional perturbation method [6].

It is signiﬁcant and timely to combine differential privacy
and deep learning, i.e., the two state-of-the-art techniques in
privacy preserving and machine learning. However, this is
a challenging task, and only a few scientiﬁc studies have
been conducted. In [9], Shokri and Shmatikov proposed a dis-
tributed training method, which injects noise into “gradients”
of parameters, to preserve privacy in neural networks. In this
method, the magnitude of injected noise and the privacy budget
(cid:15) are accumulated in proportion to the number of training
epochs and the number of shared parameters. Thus, it may
consume an unnecessarily large portion of the privacy budget,
as the number of training epochs and the number of shared
parameters among multiple parties are often large [10].

To improve this, based on the composition theorem [11],
Abadi et al. [12] proposed a privacy accountant, which keeps
track of privacy spending and enforces applicable privacy poli-
cies. However, the approach is still dependent on the number
of training epochs, as it introduces noise into “gradients” of
parameters in every training step. With a small privacy budget
(cid:15), only a small number of epochs can be used to train the
model [12]. In practice, that could potentially affect the model
utility, when the number of training epochs needs to be large
to guarantee the model accuracy.

A recent approach towards differentially private deep neural
networks was explored by Phan et al. [10]. This work pro-
posed deep private auto-encoders (dPAs), in which differential
privacy is enforced by perturbing the cross-entropy errors in
auto-encoders [13]. Their algorithm was designed particularly
for auto-encoders, in which speciﬁc objective functions are ap-
plied. A different method, named CryptoNets, was proposed
in [14] towards the application of neural networks to encrypted
data. A data owner can send their encrypted data to a cloud
service that hosts the network, and get encrypted predictions in
return. This method is different from our context, since it does
not aim at releasing learning models under privacy protections.
Another drawback of the existing techniques is that all

parameters are treated the same in terms of the amount of noise
injected. This may not be ideal in real scenarios, since different
features and parameters normally have different impacts upon
the model output. Fig. 1 shows the relevance estimated by
applying Layer-wise Relevance Propagation (LRP) [15] of
input features to the prediction of the image’s label in the
MNIST dataset [16]. Dark red units have stronger impacts
than green and yellow units. Injecting the same magnitude of
noise into all parameters may affect the model utility.

Research Goal. Therefore,
there is an urgent demand for
the development of a privacy
preserving mechanism, such that:
(1) It
is totally independent of
training epochs
the number of
in consuming privacy budget; (2)
It has the ability to adaptively
inject noise into features based
on the contribution of each to
the model output; and (3) It can
be applied in a variety of deep
networks. Mechanisms
neural
signiﬁcantly enhance the

Fig. 1. An instance of rel-
evance of each input
feature
given to the classiﬁcation out-
put (MNIST dataset). Red neu-
rele-
rons
vances, and green neurons indi-
cate weaker relevances.

stronger

indicate

with such characteristics will
operation of privacy preservation in deep learning.

Our Contribution. Motivated by this, we develop a novel
mechanism, called Adaptive Laplace Mechanism (AdLM), to
preserve differential privacy in deep learning. Our idea is to
intentionally add “more noise” into features which are “less
relevant” to the model output, and vice-versa. To achieve that,
we inject Laplace noise into the computation of Layer-wise
Relevance Propagation (LRP) [15] to estimate a differentially
private relevance of each input feature to the model output.
Given the perturbed features, we ﬁgure out a novel way to
distribute adaptive noise into afﬁne transformations and loss
functions used in deep neural networks as a preprocessing step,
so that preserving differential privacy is feasible. As a result,
we expect to improve the utility of deep neural networks under
(cid:15)-differential privacy. It is worth noting that our mechanism
does not access the original data again in the training phase.
Theoretical analysis derives the sensitivities and error bounds
of our mechanism, and shows that they are totally independent
of the number of epochs.

Different from [9, 12], in our mechanism, the injected noise
and the privacy budget consumption do not accumulate in each
training step. Consequently, the privacy budget consumption in
our mechanism is totally independent of the number of training
epochs. In addition, different from [10], our mechanism can be
applied in a variety of deep learning networks with different
activation functions. Convolution neural networks (CNNs)
[16] are used as an example to validate the effectiveness of our
mechanism. Rigorous experiments conducted on MNIST and
CIFAR-10 datasets [17] show that our mechanism is effective
and outperforms existing solutions.

II. PRELIMINARIES AND RELATED WORKS

In this section, we revisit differential privacy, existing tech-
niques in preserving differential privacy in deep learning, and
the Layer-wise Relevance Propagation (LRP) algorithm [15].
Let D be a database that contains n tuples x1, x2, . . . , xn
and d+1 attributes X1, X2, . . . , Xd, Y , and for each tuple xi =
(xi1, xi2, . . . , xid, yi). We assume, without loss of generality,
(cid:113)(cid:80)d
ij ≤ 1 where xij ≥ 0. This assumption can be
easily enforced by changing each xij to
, where
αj and βj denote the minimum and maximum values in the
domain of Xj.

xij −αj
(βj −αj )·

j=1 x2

√

d

To be general, let us consider a classiﬁcation task with M
possible categorical outcomes, i.e., the data label yi given
xi ∈ L is assigned to only one of the M categories.
Each yi can be considered as a vector of M categories
yi = {yi1, . . . , yiM }. If the l-th category is the class of xi,
then yil = 1, otherwise yil = 0. Our objective is to construct a
differentially private deep neural network from D that (i) takes
xi = (xi1, xi2, . . . , xid) as input and (ii) outputs a prediction
of yi that is as accurate as possible. To evaluate whether model
parameters θ lead to an accurate model, a cost function FD(θ)
is used to measure the difference between the original and
predicted values of yi.

A. (cid:15)-Differential Privacy

As the released model parameter θ may disclose sensitive
information of D, to protect the privacy, we require that the
model training should be performed with an algorithm that
satisﬁes (cid:15)-differential privacy. The deﬁnition of differential
privacy is as follows:

Deﬁnition 1: (cid:15)-Differential Privacy [5]. A randomized algo-
rithm A fulﬁlls (cid:15)-differential privacy, if for any two databases
D and D(cid:48) differing at most one tuple, and for all O ⊆
Range(A), we have:

P r[A(D) = O] ≤ e(cid:15)P r[A(D(cid:48)) = O]

(1)

where the privacy budget (cid:15) controls the amount by which the
distributions induced by D and D(cid:48) may differ. A smaller (cid:15)
enforces a stronger privacy guarantee of A.

A general method for preserving (cid:15)-differential privacy of
any function F (on D) is the Laplace mechanism [5], where
the output of F is a vector of real numbers. In fact, the
mechanism exploits the global sensitivity of F over any two
neighboring data sets (differing at most one record), which is
denoted as GSF (D). Given GSF (D), the Laplace mechanism
ensures (cid:15)-differential privacy by injecting noise η into each
2GSF (D) exp(−|η| ·
value in the output of F(D): pdf (η) =
GSF (D) ), where η is drawn i.i.d. from Laplace distribution
with zero mean and scale GSF (D)/(cid:15).

(cid:15)

(cid:15)

Research in differential privacy has been signiﬁcantly stud-
ied, from both the theoretical perspective, e.g., [6, 18], and
the application perspective, e.g., data collection [19], spatio-
temporal correlations [20, 21], data streams [22], stochastic
gradient descents [23], recommendation [7], regression [6],

online learning [24], publishing contingency tables [25], and
spectral graph analysis [26].

B. Differential Privacy in Deep Learning

Deep neural networks deﬁne parameterized functions from
inputs xi ∈ D to outputs, i.e, a prediction of yi, as compo-
sitions of many layers of hidden neurons and nonlinear func-
tions. For instance, Fig. 2 illustrates a multilayer neural net-
work, in which there are k hidden layers H = {h1, . . . , hk}.
Rectiﬁed linear units (ReLUs) and sigmoids are widely used
examples of activation functions. By adjusting parameters of
these neurons, such parameterized functions can be trained
with the goal of ﬁtting a ﬁnite set of input-output data
instances. We specify a loss function FD(θ) that represents
the penalty for mismatching between the predicted and original
values of yi. FD(θ) on parameters θ is the average of the loss
over the training examples {x1,..., xn}. Stochastic gradient
descent (SGD) algorithm is used to minimize the cross-entropy
error [13], given the model outputs and true data labels.

In the work of Abadi et al. [12],
to preserve differential privacy, normal
(Gaussian) distribution noise is added
into the gradients ˜g of parameters W as
follows. At each training step t, the al-
gorithm ﬁrst takes a random sample Lt
with sampling probability L/n, where
L is a group size and n is the number
of tuples in D. For each tuple xi ∈ Lt,
the gradient gt(xi) = ∇θtFxi(θt) is
computed. Then the gradients will be
bounded by clipping each gradient in
l2 norm, i.e., the gradient vector gt is
replaced by gt/ max(1, (cid:107)g2
t (cid:107)/C) for a
predeﬁned threshold C. Normal distri-
bution noise is added into gradients of
parameters θ as

Fig. 2. An instance of
differentially private neu-
ral networks.

˜gt ←

(cid:88)

(cid:16)

1
L

i

gt(xi)
max(1, (cid:107)gt(xi)2(cid:107)

)

C

+ N (0, σ2C 2I)

(cid:17)

θt ← θt − ξt˜gt

(2)

(3)

where ξt is a learning rate at the training step t.

Finally, differentially private parameters θ, denoted θ,
learned by the algorithm are shared to the public and other
parties. Overall, the algorithm introduces noise into “gradi-
ents” of parameters at every training step. The magnitude of
injected noise and the privacy budget (cid:15) are accumulated in
proportion to the number of training epochs.

Compared with the work in [12], the goal is similar: learn-
ing differentially private parameters θ. However, we develop a
novel mechanism in which the privacy budget consumption is
independent of the number of training epochs. Our mechanism
is different. We redistribute the noise so that “more noise”
will be added into features which are “less relevant” to the
model output, and vice-versa. Moreover, we inject noise into
coefﬁcients of afﬁne transformations and loss functions, such
that differentially private parameters can be learned.

C. Layer-wise Relevance Propagation

Layer-wise Relevance Propagation (LRP) [15] is a well-
accepted algorithm, which is applied to compute the relevance
to the model outcome Fxi(θ).
of each input feature xij
Given the relevance, denoted R(k)
m (xi), of a certain neuron
m at the layer k, i.e., m ∈ hk, for the model outcome
Fxi(θ), LRP algorithm aims at obtaining a decomposition of
such relevance in terms of messages sent to neurons of the
previous layers, i.e., the layer (k-1)-th. These messages are
called R(k−1,k)
p←m (xi). The overall relevance of each neuron in
the lower layer is determined by summing up the relevance
coming from all upper-layer neurons:

R(k−1)
p

(xi) =

R(k−1,k)

p←m (xi)

(4)

(cid:88)

m∈hk

where the relevance decomposition is based on the ratio of
local and global afﬁne transformations and is given by:
zm(xi)+µ R(k)
zm(xi)−µ R(k)
with: zm(xi) is the afﬁne transformation of neuron m ∈ hk:

zm(xi) ≥ 0
zm(xi) < 0

m (xi)
m (xi)

p←m (xi) =

(cid:40) zpm(xi)

R(k−1,k)

zpm(xi)

(5)

zpm(xi) = pxi × Wpm
zm(xi) =

(cid:88)

zpm(xi) + bm

p∈hk

(6)

(7)

s.t. pxi is the value of neuron p given xi, Wpm is a weight
connecting the neuron p to neuron m, and bm is a bias term.
A predeﬁned stabilizer µ ≥ 0 is introduced to overcome
unboundedness.

In Eq. 5, in order to back propagate the relevance, we need
to compute the relevance R(k)
m (xi) at the last hidden layer, i.e.,
the k-th layer, from the output layer. Given the output variable
o, R(k)

m (xi) is computed as follows:

(cid:40) zmo(xi)

R(k)

m (xi) =

zo(xi)+µ Fxi(θ)
zmo(xi)
zo(xi)−µ Fxi(θ)
Given k hidden layers {h1, . . . , hk}, by using Eqs. 4, 5,
and 8, we can compute the relevance of every hidden neuron
and input feature. As in [15], the following equation holds:

zo(xi) ≥ 0
zo(xi) < 0

(8)

Fxi(θ) =

R(k)

m (xi) = . . . =

Rxij (xi)

(9)

(cid:88)

m∈hk

(cid:88)

xij ∈xi

where Rxij (xi) is the relevance of the feature xij given
the model outcome Fxi(θ). To ensure that
the relevance
Rxij (xi) ∈ [−1, 1], each Rxij (xi)
is normalized to
Rxij (xi)−χ
(ϕ−χ)
imum values in the domain of (cid:8)Rxi1 (xi), . . . , Rxid (xi)(cid:9).
III. ADAPTIVE LAPLACE MECHANISM (ADLM)

, where ϕ and χ denote the maximum and min-

In this section, we formally present our mechanism. Given
a loss function F(θ) with model parameters θ, the network is
trained by optimizing the loss function F(θ) on D by applying
SGD algorithm on T random training batches consequently.
At each training step, a single training batch L is used. A batch

L is a random set of training samples in D with a predeﬁned
batch size |L|.

The pseudo-codes of Algorithm 1 outline ﬁve basic steps
in our mechanism to learn differentially private parameters of
the model. The ﬁve basic steps are as follows:

• Step 1 (Lines 1-7). In the ﬁrst step, we obtain the average
relevances of all the j-th input features, denoted as Rj(D),
by applying the LRP algorithm on a well-trained deep neural
network on the database D. Rj(D) is computed as follows:

A. Private Relevance

In this section, we preserve differential privacy in the
computation of the relevance of each j-th input feature on
database D by injecting Laplace noise into Rj(D). We set
∆R = 2d
|D| based on the maximum values of all the relevances
Rj(D) (line 4, Alg. 1). In lines 5-6, the relevance of each j-
th input feature Rj(D) is perturbed by adding Laplace noise
Lap( ∆R
). The perturbed relevance is denoted as Rj. In line
(cid:15)1
7, we obtain the set of all perturbed relevances R(D):

Rj(D) =

Rxij (xi)

(10)

R(D) = (cid:8)Rj

(cid:9)

1
|D|

(cid:88)

xi∈D

Then, we derive differentially private relevances, denoted as
Rj, by injecting Laplace noise into Rj for all the j-th input
features. The total privacy budget in this step is (cid:15)1.

• Step 2 (Lines 8-14). In the second step, we derive a
differentially private afﬁne transformation layer, denoted h0.
Every hidden neuron h0j ∈ h0 will be perturbed by injecting
adaptive Laplace noise into its afﬁne transformation to pre-
serve differential privacy given a batch L. Based on Rj, “more
noise” is injected into features which are “less relevant” to the
model output, and vice-versa. The total privacy budget used
in this step is (cid:15)2. The perturbed afﬁne transformation layer is
denoted as h0L (Fig. 2).

• Step 3 (Line 15). In the third step, we stack hidden layers
{h1, . . . , hk} on top of the differentially private hidden layer
h0L to construct the deep private neural network (Fig. 2).
The computations of h1, . . . , hk are done based on the differ-
entially private layer h0L without accessing any information
from the original data. Therefore, the computations do not
disclose any information. Before each stacking operation, a
normalization layer, denoted h, is applied to bound non-linear
activation functions, such as ReLUs (Fig. 2).

• Step 4 (Lines 16-19). After constructing a private struc-
ture of hidden layers {h0L, h1, . . . , hk}, we need to protect
the labels yi at the output layer. To achieve this, we derive a
polynomial approximation of the loss function F. Then, we
perturb the loss function F by injecting Laplace noise with a
privacy budget (cid:15)3 into its coefﬁcients to preserve differential
privacy on each training batch L, denoted F L(θ).

• Step 5 (Lines 20-30). Finally, the parameter θT is derived
by minimizing the loss function F L(θ) on T training steps
sequentially. In each step t, stochastic gradient descent (SGD)
algorithm is used to update parameters θt given a random batch
L of training samples in D. This essentially is an optimization
process, without using any additional information from the
original data.

In our mechanism, differential privacy is preserved, since it
is enforced at every computation task that needs to access the
original data D. Laplace noise is injected into our model only
once, as a preprocessing step to preserve differential privacy in
the computation of the relevance Rj(D), the ﬁrst layer h0L,
and the loss function F L(θ). Thereafter, the training phase
will not access the original data again. The privacy budget
consumption does not accumulate in each training step. As
such, it is independent of the number of training epochs.

where Rj =

Rxij (xi) + Lap(

j∈[1,d]
1
(cid:88)
|D|

xi∈D

(11)

(12)

∆R
(cid:15)1

)

The computation of R(D) is (cid:15)1-differential private. The

correctness is based on the following lemmas.

Lemma 1: Let D and D(cid:48) be any two neighboring databases.
Given R(D) and R(D(cid:48)) be the relevance of all input features
on D and D(cid:48), respectively, and denote their representations as

R(D) = (cid:8)Rj(D)(cid:9)

j∈[1,d] s.t. Rj(D) =

Rxij (xi)

R(D(cid:48)) = (cid:8)Rj(D(cid:48))(cid:9)

j∈[1,d] s.t. Rj(D(cid:48)) =

Rx(cid:48)

ij

(x(cid:48)
i)

1
|D|

(cid:88)

xi∈D

1
|D(cid:48)|

(cid:88)

x(cid:48)

i∈D(cid:48)

Then, we have the following inequality:

1
|D|

d
(cid:88)

(cid:13)
(cid:13)
(cid:13)

(cid:88)

j=1

xi∈D

Rxij (xi) −

Rx(cid:48)

ij

(cid:13)
(x(cid:48)
(cid:13)
i)
(cid:13)1

≤

2d
|D|

(13)

(cid:88)

x(cid:48)

i∈D(cid:48)

where d is the number of features in each tuple xi ∈ D.
Proof 1: The proof of Lemma 1 is in Appendix A.
Lemma 2: Algorithm 1 preserves (cid:15)1-differential privacy in

the computation of R(D).

Proof 2: The proof of Lemma 2 is in Appendix B1.

Lemma 2 shows that the computa-
tion of the relevances R(D) is dif-
ferentially private. Fig. 3 illustrates
the differentially private relevance Rj
(Eq. 12) of each j-th coefﬁcient given
the database D. It is worth noting
that the relevance distribution is not
identical. In the next section, R(D) is
used to redistribute the noise injected
into the afﬁne transformation layer h0
in our deep neural network.

B. Private Afﬁne
Layer with Adaptive Noise

Transformation

Fig. 3. The average differ-
entially private relevance
of each input feature given
MNIST dataset.

In general, before applying activation functions such as
the afﬁne transformation of a hidden

ReLU and sigmoid,
neuron h ∈ h0 can be presented as:

hxi(W ) = b + xiW T
where b is a static bias, and W is the parameter of h. Given
a training batch L, h can be rewritten as:

(14)

hL(W ) =

(b + xiW T )

(15)

(cid:88)

xi∈L

Given the above representation of each neuron hL(Wh),
we preserve differential privacy in the computation of h0 on
L by injecting Laplace noise into inputs b and xi of every
neuron hL(W ) ∈ h0. Intuitively, we can apply an identical
noise distribution 1
) to all input features, where
∆h0 = 2 (cid:80)
d (line 9, Alg. 1). This approach works well
when every input feature has an identical contribution to the
model outcome. (Please refer to the Appendix C1.)

|L| Lap( ∆h0

h∈h0

(cid:15)2

In practice, this assumption usually is violated. For instance,
Fig. 1 illustrates the relevance, estimated by the LRP algorithm
[15], of each input feature given different handwritten digits. It
is clear that the relevances are not identical. The differentially
private relevances are not identical as well (Fig. 3). Therefore,
injecting the same magnitude of noise into all input features
may affect the utility of differentially private neural networks.
To address this problem, we propose an Adaptive Laplace
Mechanism (AdLM), to adaptively redistribute the injected
noise to improve the performance. Given hidden units hxi(W )
in Eq. 14, our key idea is to intentionally add more noise into
input features which are less relevant to the model output Y ,
and vice-versa. As a result, we expect to improve the utility
of the model under differential privacy. In fact, we introduce
a privacy budget ratio βj and the privacy budget (cid:15)j for each
j-th input feature as follows:

s.t.

(cid:15)j = βj × (cid:15)2

(16)

βj =

d × |Rj|
(cid:80)d
j=1 |Rj|
We set ∆h0 = 2 (cid:80)

h∈h0

d based on the maximum values
of all the input features xij (line 9, Alg. 1). In line 11, βj
can be considered as the fraction of the contribution to ∆h0
from the j-th input feature to the hidden neuron h ∈ h0. In
lines 12-13, each input feature xij of every hidden neuron h in
the ﬁrst afﬁne transformation layer h0 is perturbed by adding
adaptive Laplace noise 1
|L| Lap(∆h0 /(cid:15)j). The perturbed input
features are denoted as xi. In lines 20-21, given a random
training batch L, we construct the differentially private afﬁne
transformation layer h0L, which consists of perturbed hidden
neurons hL(W ):
h0L(W0) = (cid:8)hL(W )(cid:9)

s.t. hL(W ) =

xiW T + b

(cid:88)

(cid:16)

(cid:17)

h∈h0

xi∈L

|L| Lap( ∆h0

where b = b+ 1
) is the perturbed bias (line 14). The
following lemma shows that Alg. 1 preserves (cid:15)2-differential
privacy in the computation of h0L.

(cid:15)2

Lemma 3: Let L and L(cid:48) be any two neighboring batches.
Given parameter W0, let h0L and h0L(cid:48) be the ﬁrst afﬁne
transformation layers on L and L(cid:48), respectively, and denote
their representations as follows:
h0L(W0) = {hL(W )}h∈h0 s.t. hL(W ) =

(b + xiW T )

(cid:88)

h0L(cid:48)(W0) = {hL(cid:48)(W )}h∈h0 s.t. hL(cid:48)(W ) =

(b + x(cid:48)

iW T )

xi∈L
(cid:88)

x(cid:48)

i∈L(cid:48)

Then, we have the following inequality:

Algorithm 1 Adaptive Laplace Mechanism (Database D,
hidden layers H, loss function F(θ), and privacy budgets (cid:15)1,
(cid:15)2, and (cid:15)3, the number of batches T , the batch size |L|)

1: Compute the average relevance by applying the LRP Alg.
(cid:80)
2: ∀j ∈ [1, d] : Rj(D) = 1
|D|
3: Inject Laplace noise into the average relevance of each j-th

xi∈D Rxij (xi) #Eq.10#

input feature

4: ∆R = 2d/|D| #Lemma 1#
5: for j ∈ [1, d] do
(cid:80)
Rj ← 1
6:
|D|
7: R(D) = {Rj}j∈[1,d]
8: Inject Laplace noise into coefﬁcients of the differentially

xi∈D Rxij (xi) + Lap( ∆R

(cid:15)1

)

private layer h0

d #Lemma 3#

9: ∆h0 = 2 (cid:80)
h∈h0
10: for j ∈ [1, d] do
(cid:15)j ← βj × (cid:15)2 #Eq. 16#
11:
12: for xi ∈ D, j ∈ [1, d] do
xij ← xij + 1
|L| Lap(
13:
∆h0
14: b ← b + 1
|L| Lap(
(cid:15)2
15: Construct hidden layers {h1, . . . , hk} and normalization

) #perturb input feature xij#

) #perturb bias b#

∆h0
(cid:15)j

layers {h1, . . . , h(k)}

16: Inject Laplace noise into coefﬁcients of the approximated

) #perturb coefﬁcients of (cid:98)F

4 |h(k)|2) #Lemma 5#

loss function (cid:98)F
17: ∆F = M (|h(k)| + 1
18: for xi ∈ D, R ∈ [0, 2], l ∈ [1, M ] do
+ 1
19:
20: Initialize θ0 randomly
21: for t ∈ [T ] do
22:
23:

|L| Lap( ∆F
(cid:15)3

← φ(R)
lxi

(R)
lxi

φ

24:
25:
26:

Take a random training batch L
Construct differentially private afﬁne transformation
layer
h0L(W0) ← {hL(W )}h∈h0
s.t. hL(W ) = (cid:80)
Construct differentially private loss function
(cid:1)R
F L(θt) = (cid:80)M
(cid:80)2
l=1
Compute gradient descents
θt+1 ← θt − ηt

27:
28:
29:
30: Return θT #((cid:15)1 + (cid:15)2 + (cid:15)3)-differentially private#

(cid:79)θt F L(θt) #ηt is a learning rate#

(cid:0)xiW T + b)(cid:3)(cid:1)

(R)
lxi

W T

xi∈L

xi∈L

(cid:0)φ

1
|L|

R=0

(cid:80)

l(k)

∆h0 =

(cid:88)

d
(cid:88)

(cid:88)

(cid:13)
(cid:13)
(cid:13)

h∈h0

j=1

xi∈L

xij −

x(cid:48)
ij

(cid:13)
(cid:13)
(cid:13)1

(cid:88)

x(cid:48)

i∈L(cid:48)

≤ 2

d

(17)

(cid:88)

h∈h0

where d is the number of features in each tuple xi ∈ D.

Proof 3: Assume that L and L(cid:48) differ in the last tuple. Let

xn (x(cid:48)

n) be the last tuple in L (L(cid:48)). We have that

∆h0 =

(cid:88)

d
(cid:88)

(cid:88)

(cid:13)
(cid:13)
(cid:13)

h∈h0

j=1

xi∈L

xij −

x(cid:48)
ij

(cid:13)
(cid:13)
(cid:13)1

(cid:88)

x(cid:48)

i∈L(cid:48)

(cid:88)

d
(cid:88)

=

h∈h0

j=1

(cid:107)xnj − x(cid:48)

nj(cid:107)1 ≤ 2 max
xi∈L

(cid:107)xij(cid:107)1

(18)

(cid:88)

d
(cid:88)

h∈h0

j=1

Since ∀xi, j : xij ∈ [0, 1], from Eq. 18 we have that: ∆h0 ≤
2 (cid:80)
(cid:4)

d. Eq. 17 holds.

h∈h0

Lemma 4: Algorithm 1 preserves (cid:15)2-differential privacy in

the computation of h0L(W0) (lines 24-25).

Proof 4: From lines 24-25 in the Alg. 1, for each h ∈ h0L,

h can be re-written as:

hL(W ) =

d
(cid:88)

(cid:104) (cid:88)

j=1

xi∈L

(cid:0)xij +

1
|L|

Lap(

)(cid:1)W T (cid:105)

∆h0
(cid:15)j

1
|L|

(cid:88)

(cid:0)b +

+

xi∈L

Lap(

∆h0
(cid:15)2

)(cid:1)

(19)

Let us consider the static bias b = 1 as the 0-th input feature
and its associated parameter Wb, i.e., xi0 = b = 1 and W =
Wb ∪ W , we have that

hL(W ) =

d
(cid:88)

(cid:104) (cid:88)

j=0

xi∈L

(cid:0)xij +

1
|L|

Lap(

)(cid:1)W T (cid:105)

∆h0
(cid:15)j

(20)

d
(cid:88)

(cid:104) (cid:88)

=

j=0

xi∈L

xij + Lap(

(cid:105)
W T =

)

∆h0
(cid:15)j

d
(cid:88)

j=0

h
j W T

φ

(21)

h

where φ

j = (cid:2) (cid:80)
We can see that φ

xi∈L xij + Lap( ∆h0

(cid:15)j

)(cid:3).

h
j is the perturbation of the input feature
xij associated with the j-th parameter Wj ∈ W of the hidden
neuron h on L. Since all the hidden neurons h in h0 are
perturbed, we have that:

P r(cid:0)h0L(W0)(cid:1) =

(cid:89)

d
(cid:89)

exp(cid:0) (cid:15)j(cid:107)(cid:80)

xi∈L xij − φ

h
j (cid:107)

(cid:1)

h∈h0

j=0

∆h0

d (line 9 in Alg. 1). h0L(W0) is the

∆h0 is set to 2 (cid:80)

h∈h0
output (lines 24-25 in Alg. 1). We have that
j=0 exp (cid:0) (cid:15)j (cid:107)(cid:80)
(cid:81)d
j=0 exp (cid:0) (cid:15)j (cid:107)(cid:80)

P r(cid:0)h0L(W0)(cid:1)
P r(cid:0)h0L(cid:48)(W0)(cid:1) =

h∈h0

(cid:81)d

(cid:81)

(cid:81)

h∈h0

xi∈L xij −φh
∆h0
∈L(cid:48) x(cid:48)
∆h0

ij −φh

x(cid:48)
i

j (cid:107)1

(cid:1)

j (cid:107)1

(cid:1)

≤

≤

≤

(cid:89)

d
(cid:89)

h∈h0

j=0

(cid:89)

d
(cid:89)

h∈h0

j=1

(cid:89)

d
(cid:89)

h∈h0

j=1

≤ exp((cid:15)2

exp(

(cid:15)j
∆h0

(cid:13)
(cid:13)
(cid:13)

(cid:88)

xi∈L

xij −

x(cid:48)

ij

(cid:13)
(cid:13)
(cid:13)1

)

(cid:88)

x(cid:48)

i∈L(cid:48)

exp(

(cid:15)j
∆h0

2 max
xn∈L

(cid:13)
(cid:13)xnj

(cid:13)
(cid:13)1) ≤

(cid:89)

d
(cid:89)

h∈h0

j=1

exp(

2(cid:15)j
∆h0

)

)

2 d×|Rj |
(cid:80)d
j=1 |Rj |
∆h0
d(cid:2) (cid:80)d

j=1

exp((cid:15)2

2 (cid:80)

h∈h0

∆h0

|Rj |
j=1 |Rj |

(cid:80)d

(cid:3)

) = exp((cid:15)2)

Consequently,
differential privacy in Alg. 1.

the computation of h0L(W0) preserves (cid:15)2-
(cid:4)
Lemma 4 shows that we can redistribute the noise in the
computation of the ﬁrst hidden layer h0L under differential
privacy. In addition, given a batch L, without accessing
additional information from the original data, none of the
computations on top of h0L risk the privacy protection under
differential privacy. These computation tasks include the appli-
cation of activation functions, e.g., ReLU and sigmoid, on h0L,
the computation of hidden layers h1, . . . , hk, local response

normalizations, drop-out operations, polling layers, etc. (line
15, Alg. 1). This result can be applied to both fully-connected
layers and convolution layers. In this paper, we applied ReLU
on top of h0L and other layers h1, . . . , hk. Local response
normalization layers are used after the application of ReLUs
in each hidden layer to bound ReLU functions.

Local Response Normalization. The hidden units of the
lower layer will be considered as the input of the next layer
(Fig. 2). To ensure that this input is bounded hxi ∈ [0, 1], as in
[10, 27], we add a local response normalization (LRN) layer on
top of each hidden layer. Given a fully-connected layer, as in
[10], given an input xi, each perturbed neuron hxi (W ) can be
directly normalized as follows: hxi ←
/(ϕ−χ),
where ϕ and χ denote the maximum and minimum values in
the domain of {hxi}i∈L.

hxi(W )−χ

(cid:17)

(cid:16)

k
Given a convolution layer with a perturbed neuron h
ij at
location (i, j) in the k-th feature map, based on [27], our local
response normalization (LRN) is presented as follows:

k
k
h
ij/ max
ij ← h

k
ij, (cid:0)q + α
h

(cid:16)

min(N −1,k+l/2)
(cid:88)

m=max(0,k−l/2)

m

ij )2(cid:1)β(cid:17)

(h

(22)

where the constants q, l, α, and β are hyper-parameters, N is
the total number of feature maps. As in [27], we used q =
2, l = 5, α = 10−4, and β = 0.75 in our experiments.

C. Perturbation of the Loss Function FL(θ)

On top of our private deep neural network (Fig. 2), we add
an output layer with the loss function FL(θ) to predict Y .
Since the loss function FL(θ) accesses the labels yi given
xi ∈ L from the data, we need to protect the labels yi at the
output layer. First, we derive a polynomial approximation of
the loss function based on Taylor Expansion [28]. Then, we
inject Laplace noise into coefﬁcients of the loss function F to
preserve differential privacy on each training batch L.

The model output variables {ˆy1, . . . , ˆyM } are fully linked to
the normalized highest hidden layer, denoted h(k), by weighted
connections W(k) (Fig. 2). As common, the logistic function
can be used as an activation function of the output variables.
Given, l-th output variable ˆyl and xi, we have:

ˆyil = σ(cid:0)hxi(k)W T

l(k)

(cid:1)

(23)

where hxi(k)
navigating through the neural network.

is the state of h(k) derived from h0xi by

Cross-entropy error [13] can be used as a loss function. It
has been widely used and applied in real-world applications
[13]. Therefore, it is critical to preserve differential privacy
under the use of the cross-entropy error function. Other loss
functions, e.g., square errors, can be applied in the output layer,

M
(cid:88)

(cid:88)

(cid:16)

l=1

xi∈L

M
(cid:88)

(cid:88)

(cid:16)

l=1

xi∈L

as well. In our context, the cross-entropy error function is
given by:

Proof 5: The proof of Lemma 5 is in Appendix D1.
Lemma 6: Algorithm 1 preserves (cid:15)3-differential privacy in

FL(θ) = −

yil log ˆyil + (1 − yil) log(1 − ˆyil)

(cid:17)

the computation of F L(θt) (line 27).

Proof 6: The proof of Lemma 6 is in Appendix E1.

= −

yil log(1 + e−hxi(k)W T

l(k) )

+ (1 − yil) log(1 + ehxi(k)W T

l(k))

(24)

(cid:17)

Based on [10] and Taylor Expansion [28], we derive the

polynomial approximation of FL(θ) as:

(cid:0)hxi(k)W T

l(k)

(cid:1)R

M
(cid:88)

(cid:88)

2
(cid:88)

2
(cid:88)

q=1

R=0

(cid:98)FL(θ) =

l=1

xi∈L
(cid:104) 2
(cid:88)

M
(cid:88)

(cid:88)

=

l=1

xi∈L

q=1

f (R)
ql (0)
R!

2
(cid:88)

q=1
f (2)
ql (0)
2!

ql (0) + (cid:0)
f (0)

ql (0)(cid:1)hxi(k)W T
f (1)

l(k)

+ (cid:0)

2
(cid:88)

q=1

(cid:1)(hxi(k)W T

l(k))2(cid:105)

(25)

where ∀l ∈ [1, M ] : f1l(z) = yil log(1 + e−z) and f2l(z) =
(1 − yil) log(1 + ez).

To achieve (cid:15)3-differential privacy, we employ functional
mechanism [29] to perturb the loss function (cid:98)FL(θ) by injecting
Laplace noise into its polynomial coefﬁcients. So, we only
need to perturb (cid:98)FL(θ) just once in each training batch. To be
, φ(2)
clear, we denote {φ(0)
} as the coefﬁcients, where
lxi
lxi
φ(0)
and φ(2)
ql (0) and φ(1)
are coefﬁcients at the
lxi
lxi
lxi
ﬁrst order and the second order of the function (cid:98)FL(θ). In fact,
φ(1)
will be combinations between the approximation
lxi
terms (cid:80)2
ql (0), (cid:80)2

and φ(2)
lxi
q=1 f (1)

, and hxi(k).

q=1 f (0)

f (2)
ql (0)
2!

= (cid:80)2

, φ(1)
lxi

In Alg. 1, we set ∆F = M (|h(k)| + 1

4 |h(k)|2) (line 17).
In essence, coefﬁcients φ(R)
with R ∈ [0, 2] are functions
lxi
of the label yil only. Therefore, we can perform the pertur-
) into φ(R)
bation by injecting Laplace noise 1/|L|Lap( ∆F
lxi
(cid:15)3
for every training label yil ∈ D (lines 18-19). Then, the
(R)
perturbed coefﬁcients, denoted φ
lxi are used to construct the
differentially private loss function F L(θt) (line 27) during
the training process without accessing the original label yil
again (lines 20-30). Stochastic gradient descent and back-
propagation algorithms are used to minimize the perturbed
loss function F L(θt).

q=1

Now, we are ready to state that the computation of F L(θt)
is (cid:15)3-differentially private, and our mechanism preserves ((cid:15)1 +
(cid:15)2 + (cid:15)3)-differential privacy in the following lemmas.

Lemma 5: Let L and L(cid:48) be any two neighboring batches.
Let (cid:98)FL(θ) and (cid:98)FL(cid:48)(θ) be the loss functions on L and L(cid:48)
respectively, then we have the following inequality:

∆F =

M
(cid:88)

2
(cid:88)

(cid:88)

(cid:13)
(cid:13)
(cid:13)

l=1

R=0

xi∈L

(cid:88)

φ(R)
lxi

−

x(cid:48)

i∈L(cid:48)

φ(R)
lx(cid:48)
i

(cid:13)
(cid:13)
(cid:13) ≤ M (|h(k)|+

1
4

|h(k)|2)

where |h(k)| is the number of hidden neurons in h(k).

D. The Correctness and Characteristics of the AdLM

The following theorem illustrates that the Alg. 1 preserves

(cid:15)-differential privacy, where (cid:15) = (cid:15)1 + (cid:15)2 + (cid:15)3.

Theorem 1: Algorithm 1 preserves (cid:15)-differential privacy,

where (cid:15) = (cid:15)1 + (cid:15)2 + (cid:15)3.

Proof: At a speciﬁc training step t ∈ T , it is crystal clear
that the computation of h0L is (cid:15)2-differentially private (Lemma
4). Therefore, the computation of the hidden layers h1, . . . , hk
and normalization layers h are differentially private. This is
because they do not access any additional information from
the data. At the output layer, the loss function F L(θt) is (cid:15)3-
differentially private (Lemma 6). The computation of gradients
(cid:79)θtF L(θt) and descents is an optimization process, without
1
|L|
using any additional information from the original data. Thus,
θt+1 is differentially private (line 29, Alg. 1).

This optimization process is repeated through T steps with-
out querying the original data D (lines 21-30). This is done
because Laplace noise is injected into input features xij and
coefﬁcients φ(R)
as preprocessing steps (lines 3-19). Note that
lxi
(R)
xij and φ
lxi are associated with features xi and the label yi
respectively. h0L and F L(θt) are computed based on xij and
(R)
φ
lxi . As a result, the noise and privacy budget consumption
will not be accumulated during the training process.

Finally, F L(θt) uses the outputs of h0L, which essentially
uses the differentially private relevances R(D) as of one
inputs. R(D), h0L, and F L(θt) are achieved by applying
(cid:15)1, (cid:15)2, and (cid:15)3-differential privacy mechanisms. Furthermore,
F L(θt) and h0L access the same training batch L at each
training step. Therefore, based on the composition theorem
[11], the total privacy budget in Alg. 1 must be the summation
of (cid:15)1, (cid:15)2, and (cid:15)3.

where (cid:15) = (cid:15)1 + (cid:15)2 + (cid:15)3.

Consequently, Algorithm 1 preserves (cid:15)-differential privacy,
(cid:4)
Note that ∆R and ∆h0 are dependent on the number of
input features d. ∆R is negatively proportional to the number
of tuples in D. The larger the size of D, the less noise will be
injected into the private relevance R. ∆F is only dependent
on the number of neurons in the last hidden layer and the
output layer. In addition, ∆R, ∆h0 , and ∆F do not depend on
the number of training epochs. Consequently:

(1) The privacy budget consumption in our model is totally

independent of the number of training epochs.

(2) In order to improve the model utility under differential
privacy, our mechanism adaptively injects Laplace noise into
features based on the contribution of each to the model output.
(3) The average error incurred by our approximation ap-
proach, (cid:98)FL(θ), is bounded by a small number M × e2+2e−1
e(1+e)2
(Please refer to Lemma 7 in Appendix F1).

(4) The proposed mechanism can be applied to a variety
of deep learning models, e.g., CNNs [30], deep auto-encoders

[13], Restricted Boltzmann Machines [31], convolution deep
belief networks [32], etc., as long as we can perturb the ﬁrst
afﬁne transformation layer.

With these characteristics, our mechanism has a great po-
tential to be applied in large datasets, without consuming
excessive privacy budgets. In the experiment section, we will
show that our mechanism leads to accurate results.

IV. EXPERIMENTAL RESULTS
We have carried out an extensive experiment on two well-
known image datasets, MNIST and CIFAR-10. The MNIST
database of handwritten digits consists of 60,000 training ex-
amples, and a test set of 10,000 examples [16]. Each example
is a 28 × 28 size gray-level image. The CIFAR-10 dataset
consists of color images categorized into 10 classes, such as
birds, dogs, trucks, airplanes, etc. The dataset is partitioned
into 50,000 training examples and 10,000 test examples [17].
Competitive Models. We compare our mechanism with
the state-of-the-art differentially private stochastic gradient
descent (pSGD) for deep learning proposed by [12]. CNNs
are used in our experiments for both algorithms. The hyper-
parameters in pSGD are set
to the default values recom-
mended by Abadi et al. [12]. To comprehensively examine
the proposed approaches, our mechanism is implemented in
two different settings: (1) The Adaptive Laplace Mechanism
(Alg. 1)-based CNN with ReLUs, simply denoted AdLM; and
(2) An Identical Laplace Mechanism-based CNN with ReLUs
(ILM), in which an identical Laplace noise 1
) is
injected into each feature xij to preserve (cid:15)2-differential privacy
in the computation of the afﬁne transformation layer h0. In
the ILM algorithm, we do not need to use the differentially
private relevances R(D). More details about the ILM are in
the Appendix C1. The implementation of our mechanism is
publicly available1.

|L| Lap( ∆h0

(cid:15)2

A. MNIST Dataset

The designs of the three models are the same on the
MNIST dataset. We used two convolution layers, one with
32 features and one with 64 features. Each hidden neuron
connects with a 5x5 unit patch. A fully-connected layer with
25 units and an output layer of 10 classes (i.e., 10 digits)
with cross-entropy loss with LRN are used. The batch size
is 1,800. This also is the structure of the pre-trained model,
which is learned and used to compute the average relevances
R(D). The experiments were conducted on a single GPU, i.e.,
NVIDIA GTX TITAN X, 12 GB with 3,072 CUDA cores.

Fig. 4a illustrates the prediction accuracy of each model as
a function of the privacy budget (cid:15) on the MNIST dataset. It
is clear that our models, i.e., AdLM and ILM, outperform the
pSGD, especially when the privacy budget (cid:15) is small. This is
a crucial result, since smaller privacy budget values enforce
stronger privacy guarantees. When the privacy budget (cid:15) is
large, e.g., (cid:15) = 2, 4, 8, which means small noise is injected
into the model, the efﬁciencies of all the models are almost
converged to higher prediction accuracies.

1https://github.com/haiphanNJIT/PrivateDeepLearning

The AdLM model achieves the best performance. Given a
very small privacy budget (cid:15) = 0.25, it achieves 90.2% in terms
of prediction accuracy, compared with 88.46% obtained by the
ILM and 82.09% obtained by the pSGD. Overall, given small
values of the privacy budget (cid:15), i.e., 0.2 ≤ (cid:15) ≤ 0.5, the AdLM
improves the prediction accuracy by 7.7% on average (i.e.,
91.62%) compared with the pSGD (i.e., 83.93%). The result
is statistically signiﬁcant with p < 0.01 (t-test).

Figs. 4b-c illustrate the prediction accuracy of each model
the number of epochs under (cid:15) = 0.5 and (cid:15) = 2.0
vs.
respectively. Given large noise, i.e., (cid:15) = 0.5, the pSGD quickly
achieves higher prediction accuracies (i.e., 88.59%) after a
small number of epochs, compared with other models (Fig.
4b). However, the pSDG can only be applied to train the model
by using a limited number of epochs; speciﬁcally because the
privacy budget is accumulated after every training step. Mean-
while, our mechanism is totally independent of the number
of epochs in the consumption of privacy budget. Therefore,
after 500 epochs, our models outperform the pSGD. The
AdLM achieves the best performance, in terms of prediction
accuracy: 93.66%, whereas the ILM and the pSGD reached
only 92.39% and 88.59%, respectively. Interestingly, given
small noise, i.e., (cid:15) = 2.0, our models achieve higher accuracies
than the pSGD after a small number of epochs (Fig. 4c). This
result illustrates the crucial beneﬁts of being independent of
the number of training epochs in preserving differential privacy
in deep learning. With our mechanism, we can keep training
our models without accumulating noise and privacy budget.

B. CIFAR-10 Dataset

The designs of the three models are the same on the
CIFAR-10 dataset. We used three convolution layers, two with
128 features and one with 256 features. Each hidden neuron
connects with a 3x3 unit patch in the ﬁrst layer, and a 5x5
unit patch in other layers. One fully-connected layer with 30
neurons, and an output layer of 10 classes with a cross-entropy
loss with LRN are used. The batch size is set to 7,200. This
also is the structure of the pre-trained model, which is learned
and used to compute the average relevances R(D).

Fig. 5a shows the prediction accuracies of each model as
a function of the privacy budget (cid:15) on the CIFAR-10 dataset.
Figs. 5b-c illustrate the prediction accuracy of each model vs.
the number of epochs under different noise levels. Similar to
the results on the MNIST dataset, the results on CIFAR-10
strengthen our observations: (1) Our mechanism outperforms
the pSGD in terms of prediction accuracy, given both modest
and large values of the privacy budget (cid:15) (Fig. 5a); and (2) Our
mechanism has the ability to work with large-scale datasets,
since it is totally independent of the number of training epochs
in the consumption of privacy budget (Figs. 5b-c).

In fact, the AdLM improves the prediction accuracy by
5.9% on average (i.e., to 77%) compared with the pSGD (i.e.,
71.1%). The result is statistically signiﬁcant with p < 0.01
(t-test). Given large noise, i.e., (cid:15) = 2.5, our models including
the AdLM and ILM outperform the pSGD after 800 epochs
(Fig. 5b).

(a) accuracy vs. (cid:15)

(b) (cid:15) = 0.5 (large noise)

(c) (cid:15) = 2.0 (small noise)

Fig. 4. Accuracy for different noise levels on the MNIST dataset.

(a) accuracy vs. (cid:15)

(b) (cid:15) = 2.5 (large noise)

(c) (cid:15) = 8.0 (small noise)

Fig. 5. Accuracy for different noise levels on the CIFAR-10 dataset.

C. Adaptive Laplace Noise

It is important to note that by adaptively redistributing the
noise into input features based on the relevance of each to
the model output, we can achieve much better prediction
accuracies in both MNIST and CIFAR-10 datasets given
both small and large values of privacy budget (cid:15). This is
clearly demonstrated in Figs. 4a and 5a, since the AdLM
outperforms the ILM in all cases. Overall, the AdLM improves
the prediction accuracy by 2% and 5% on average on MNIST
and CIFAR-10 datasets correspondingly, compared with the
ILM. The result is statistically signiﬁcant with p < 0.05 (t-
test). Note that the ILM injected an identical amount of noise
into all input features, regardless of their contributions to the
model output. This is an important result, since our mechanism
is the ﬁrst of its kind, which can redistribute the noise injected
into the deep learning model to improve the utility. In addition,
the reallocation of (cid:15)1, (cid:15)2, and (cid:15)3 could further improve the
utility. This is an open research direction in the future work.

D. Computational Efﬁciency

In terms of computation efﬁciency, there are two differences
in our mechanism, compared with a regular deep neural
network: (i) The pre-trained model; and (ii) The noise injection
task. In practice,
is not necessarily
the pre-trained model
identical to the differentially private network trained by our
AdLM. A simple model can be used as a pre-trained model to
approximate the average relevance R(D), as long as the pre-
trained model is effective in terms of prediction accuracy even
over a small training dataset. Achieving this is quite straight-
forward, because: (1) The pre-trained model is noiseless; and
(2) The number of training epochs used to learn a pre-trained
model is small compared with the one of differentially private

models. In fact, we only correspondingly need 12 and 50
extra epochs to learn the pre-trained models on MNIST and
CIFAR-10 datasets. Training pre-trained models takes about
10 minutes on a single GPU, i.e., NVIDIA GTX TITAN X,
12 GB with 3,072 CUDA cores. Therefore, the model pre-
training for the computation of R(D) is efﬁcient.

Another difference in our mechanism is the noise injection
into input attributes and coefﬁcients of the loss function (cid:98)F.
In this task, the computations of ∆R, ∆h0, ∆F , Rj, βj, x,
and φ are efﬁcient and straight-forward, since there is not
any operation such as arg min, arg max, sorting, etc. The
complexity of these computations is O(cid:0)|D|(d + M )(cid:1), which
is linear to the size of the database D. In addition, these
computations can be efﬁciently performed in either a serial
process or a parallel process. Therefore, this task does not
affect the computational efﬁciency of our mechanism much.

V. CONCLUSIONS

In this paper, we proposed a novel mechanism, called
Adaptive Laplace Mechanism (AdLM), to preserve differential
privacy in deep learning. Our mechanism conducts both sensi-
tivity analysis and noise insertion on deep neural networks. It
is totally independent of the number of training epochs in the
consumption of privacy budget. That makes our mechanism
more practical. In addition, our mechanism is the ﬁrst of its
kind to have the ability to redistribute the noise insertion
toward the improvement of model utility in deep learning.
In fact, our mechanism has the ability to intentionally add
more noise into input features which are less relevant to the
model output, and vice-versa. Different activation functions
can be applied in our mechanism, as well. These distinctive
characteristics guarantee the ability to apply our mechanism on

large datasets in different deep learning models and in different
contexts. Our mechanism can clearly enhance the application
of differential privacy in deep learning. Rigorous experimental
evaluations conducted on well-known datasets validated our
theoretical results and the effectiveness of our mechanism.

ACKNOWLEDGMENT

This work is supported by the NIH grant R01GM103309
to the SMASH project. Wu is also supported by NSF grant
DGE-1523115 and IIS-1502273.

REFERENCES

[1] J. Levinson, J. Askeland, J. Becker, J. Dolson, D. Held,
S. Kammel, J. Z. Kolter, D. Langer, O. Pink, V. Pratt,
M. Sokolsky, G. Stanek, D. Stavens, A. Teichman,
M. Werling, and S. Thrun, “Towards fully autonomous
driving: Systems and algorithms,” in 2011 IEEE Intelli-
gent Vehicles Symposium (IV), 2011, pp. 163–168.
[2] D. Lowd, “Good word attacks on statistical spam ﬁlters,”

in CEAS’05, 2005.

[3] Y. Cheng, F. Wang, P. Zhang, and J. Hu, “Risk pre-
diction with electronic health records: A deep learning
approach,” in SDM’16, 2016.

[4] E. Choi, A. Schuetz, W. F. Stewart, and J. Sun, “Using
recurrent neural network models for early detection of
heart failure onset,” JAMIA, 2016.

[5] C. Dwork, F. McSherry, K. Nissim, and A. Smith,
“Calibrating noise to sensitivity in private data analysis,”
Theory of Cryptography, pp. 265–284, 2006.

[6] K. Chaudhuri and C. Monteleoni, “Privacy-preserving
logistic regression,” in NIPS’08, 2008, pp. 289–296.
[7] F. McSherry and I. Mironov, “Differentially Private Rec-

ommender Systems,” in KDD’09. ACM, 2009.

[8] F. McSherry and K. Talwar, “Mechanism design via
differential privacy,” in FOCS ’07, 2007, pp. 94–103.
[9] R. Shokri and V. Shmatikov, “Privacy-preserving deep

[10] N. Phan, Y. Wang, X. Wu, and D. Dou, “Differential pri-
vacy preservation for deep auto-encoders: an application
of human behavior prediction,” in AAAI’16, 2016, pp.
1309–1316.

[11] C. Dwork and J. Lei, “Differential privacy and robust

statistics,” in STOC’09, 2009, pp. 371–380.

[12] M. Abadi, A. Chu, I. Goodfellow, H. B. McMahan,
I. Mironov, K. Talwar, and L. Zhang, “Deep learning
with differential privacy,” arXiv:1607.00133, 2016.
[13] Y. Bengio, “Learning deep architectures for ai,” Found.
Trends Mach. Learn., vol. 2, no. 1, pp. 1–127, 2009.
[14] N. Dowlin, R. Gilad-Bachrach, K. Laine, K. Lauter,
M. Naehrig, and J. Wernsing, “Cryptonets: Applying
neural networks to encrypted data with high throughput
and accuracy,” in ICML’16, 2016, pp. 201–210.

[15] S. Bach, A. Binder, G. Montavon, F. Klauschen, K.-
R. M¨uller, and W. Samek, “On pixel-wise explanations
for non-linear classiﬁer decisions by layer-wise relevance

propagation,” PLoS ONE, vol. 10, no. 7, p. e0130140, 07
2015.

[16] Y. Lecun, L. Bottou, Y. Bengio, and P. Haffner,
“Gradient-based learning applied to document recogni-
tion,” Proceedings of the IEEE, vol. 86, no. 11, pp. 2278–
2324, 1998.

[17] A. Krizhevsky and G. Hinton, “Learning multiple layers

of features from tiny images,” 2009.

[18] D. Kifer and A. Machanavajjhala, “No free lunch in data

privacy,” in SIGMOD’11, 2011, pp. 193–204.

[19] U. Erlingsson, V. Pihur, and A. Korolova, “Rappor:
Randomized aggregatable privacy-preserving ordinal re-
sponse,” in CCS’14, 2014, pp. 1054–1067.

[20] C. Liu, S. Chakraborty, and P. Mittal, “Dependence
Makes You Vulnerable: Differential Privacy Under De-
pendent Tuples,” in NDSS’16, Feb. 2016.

[21] Y. Cao, M. Yoshikawa, Y. Xiao, and L. Xiong, “Quan-
tifying differential privacy under temporal correlations,”
CoRR, vol. abs/1610.07543, 2016.

[22] T.-H. H. Chan, M. Li, E. Shi, and W. Xu, “Differen-
tially private continual monitoring of heavy hitters from
distributed streams,” in PETS’12, 2012, pp. 140–159.

[23] S. Song, K. Chaudhuri, and A. D. Sarwate, “Stochastic
gradient descent with differentially private updates,” in
GlobalSIP, 2013, pp. 245–248.

[24] P. Jain, P. Kothari, and A. Thakurta, “Differentially
private online learning,” in COLT’12, 2012, pp. 24.1–
24.34.

[25] X. Xiao, G. Wang, and J. Gehrke, “Differential privacy
via wavelet transforms,” in ICDE’10, 2010, pp. 225–236.
[26] Y. Wang, X. Wu, and L. Wu, “Differential privacy
preserving spectral graph analysis,” in PAKDD (2), 2013,
pp. 329–340.

[27] A. Krizhevsky, I. Sutskever, and G. E. Hinton, “Imagenet
classiﬁcation with deep convolutional neural networks,”
in NIPS’12, 2012, pp. 1097–1105.

[28] G. Arfken,

in Mathematical Methods for Physicists

[29] J. Zhang, Z. Zhang, X. Xiao, Y. Yang, and M. Winslett,
“Functional mechanism: regression analysis under differ-
ential privacy,” PVLDB, vol. 5, no. 11, pp. 1364–1375,
2012.

[30] Y. Lecun, L. Bottou, Y. Bengio, and P. Haffner,
“Gradient-based learning applied to document recogni-
tion,” Proceedings of the IEEE, vol. 86, no. 11, pp. 2278–
2324, 1998.

[31] P. Smolensky, “Information processing in dynamical sys-
tems: Foundations of harmony theory,” 1986, ch. Parallel
Distributed Processing: Explorations in the Microstruc-
ture of Cognition, Vol. 1, pp. 194–281.

[32] H. Lee, R. Grosse, R. Ranganath, and A. Y. Ng, “Convo-
lutional deep belief networks for scalable unsupervised
learning of hierarchical representations,” in ICML’09,
2009, pp. 609–616.

[33] T. Apostol, Calculus.

John Wiley & Sons, 1967.

learning.” in CCS’15, 2015, pp. 1310–1321.

(Third Edition). Academic Press, 1985.

APPENDIX

A. Proof of Lemma 1

we have that ∀xi ∈ D, j ∈ [1, d] : xij = xij + 1
For each h ∈ h0L, h can be re-written as:

|L| Lap( ∆h0

(cid:15)2

).

Proof 1: Assume that D and D(cid:48) differ in the last tuple. Let

xn (x(cid:48)

n) be the last tuple in D (D(cid:48)). We have that

hL(W ) =

d
(cid:88)

(cid:104) (cid:88)

j=1

xi∈L

(cid:0)xij +

1
|L|

Lap(

)(cid:1)W T (cid:105)

∆h0
(cid:15)2

1
|L|

(cid:88)

(cid:0)b +

+

xi∈L

Lap(

∆h0
(cid:15)2

)(cid:1)

(27)

Rx(cid:48)

ij

(cid:13)
(x(cid:48)
(cid:13)
i)
(cid:13)1

(cid:88)

x(cid:48)

i∈D(cid:48)

∆R =

Rxij (xi) −

1
|D|

1
|D|

2
|D|

=

≤

d
(cid:88)

(cid:13)
(cid:13)
(cid:13)

(cid:88)

j=1

xi∈D

d
(cid:88)

j=1

max
xi∈D

d
(cid:88)

j=1

(cid:13)
(cid:13)
(cid:13)Rxnj (xn) − Rx(cid:48)

nj

(x(cid:48)

(cid:13)
(cid:13)
n)
(cid:13)1

(cid:107)Rxij (xi)(cid:107)1 ≤

2d
|D|

Eq. 13 holds.

B. Proof of Lemma 2

Proof 2: Let D and D(cid:48) be two neighbor databases. Without
loss of generality, assume that D and D(cid:48) differ in the last tuple
xn (x(cid:48)
n). Rj(D) is calculated as done in line 6, Alg. 1, and
R(D) = (cid:8)Rj(D)(cid:9)
j∈[1,d] is the output of the Alg. 1 (line 7).
The perturbation of the relevance Rj(D) can be rewritten as:

Rj =

Rxij (xi) + Lap(

(26)

∆R
(cid:15)1

)

1
|D|

(cid:88)

xi∈D

Since all the input features are perturbed, we have that

P r(cid:0)R(D)(cid:1)
P r(cid:0)R(D(cid:48))(cid:1) =

≤

exp(

j=1 exp (cid:0) (cid:15)1(cid:107) 1
(cid:81)d
j=1 exp (cid:0) (cid:15)1(cid:107) 1
(cid:81)d
(cid:13)
(cid:88)
(cid:13)
(cid:13)

xi∈D

(cid:15)1
|D|∆R

Rj(xi) −

(cid:80)

|D|

xi∈D Rj (xi)−Rj (cid:107)1

(cid:1)

|D|

(cid:80)

x(cid:48)
i

∆R
∈D Rj (x(cid:48)
∆R

i)−Rj (cid:107)1

(cid:1)

(cid:13)
Rj(x(cid:48)
(cid:13)
i)
(cid:13)1

)

(cid:88)

x(cid:48)

i∈D(cid:48)

d
(cid:89)

j=1

d
(cid:89)

j=1

d
(cid:89)

j=1

≤

exp(

(cid:15)1
|D|∆R

(cid:13)
(cid:13)
(cid:13)Rj(xn) − Rj(x(cid:48)
(cid:13)
(cid:13)
n)
(cid:13)1

)

≤

exp(

(cid:15)1
|D|∆R

2 max
xn∈D

(cid:13)
(cid:13)Rj(xn)(cid:13)

(cid:13)1)

2 maxxn∈L

j=1(cid:107)Rj(xn)(cid:107)1

(cid:80)d

)

|D|∆R

≤ exp((cid:15)1

≤ exp((cid:15)1)

Let us consider the static bias b = 1 as the 0-th input feature
and its associated parameter Wb, i.e., xi0 = b = 1 and W =
Wb ∪ W , we have that

hL(W ) =

d
(cid:88)

(cid:104) (cid:88)

j=0

xi∈L

(cid:0)xij +

1
|L|

Lap(

)(cid:1)W T (cid:105)

∆h0
(cid:15)2

(28)

d
(cid:88)

(cid:104) (cid:88)

=

j=0

xi∈L

xij + Lap(

(cid:105)
W T =

)

∆h0
(cid:15)2

d
(cid:88)

j=0

h
j W T

φ

(29)

h

where φ

j = (cid:2) (cid:80)
We can see that φ

xi∈L xij + Lap( ∆h0

(cid:15)2

)(cid:3).

h
j is the perturbation of the input feature
xij associated with the j-th parameter Wj ∈ W of the hidden
neuron h on L. Since all the hidden neurons h in h0 are
perturbed, we have that:

P r(cid:0)h0L(W0)(cid:1) =

(cid:89)

d
(cid:89)

exp(cid:0) (cid:15)2(cid:107)(cid:80)

xi∈L xij − φ

h
j (cid:107)

(cid:1)

h∈h0

j=0

∆h0

∆h0 is set to 2 (cid:80)
h∈h0
the output, we have that

d and h0L(W0) = {hL(W )}h∈h0 is

P r(cid:0)h0L(W0)(cid:1)
P r(cid:0)h0L(cid:48)(W0)(cid:1) =

(cid:81)

h∈h0

(cid:81)

h∈h0

j=0 exp (cid:0) (cid:15)2(cid:107)(cid:80)
(cid:81)d
j=0 exp (cid:0) (cid:15)2(cid:107)(cid:80)

(cid:81)d

xi∈L xij −φh
∆h0
∈L(cid:48) x(cid:48)
∆h0

ij −φh

x(cid:48)
i

j (cid:107)1

(cid:1)

j (cid:107)1

(cid:1)

exp(

(cid:15)2
∆h0

(cid:13)
(cid:13)
(cid:13)

(cid:88)

xi∈L

xij −

x(cid:48)

ij

(cid:13)
(cid:13)
(cid:13)1

)

(cid:88)

x(cid:48)

i∈L(cid:48)

(cid:13)
(cid:13)xnj − x(cid:48)
(cid:13)

nj

(cid:13)
(cid:13)
(cid:13)1

)

≤

≤

≤

(cid:89)

d
(cid:89)

h∈h0

j=0

(cid:89)

d
(cid:89)

h∈h0

j=1

(cid:89)

d
(cid:89)

h∈h0

j=1

exp(

exp(

(cid:15)2
∆h0

(cid:15)2
∆h0

d

2 (cid:80)

h∈h0
∆h0

≤ exp((cid:15)2

) = exp((cid:15)2)

2 max
xn∈L

(cid:13)
(cid:13)xnj

(cid:13)
(cid:13)1) ≤

(cid:89)

d
(cid:89)

h∈h0

j=1

exp(

2(cid:15)2
∆h0

)

Consequently,
differential privacy in Alg. 1.

the computation of R(D) preserves

(cid:15)1-

C. Identical Laplace Mechanism (ILM)

We can add an identical noise distribution 1

|L| Lap( ∆h0
) to
all input features, where ∆h0 = 2 (cid:80)
d (line 9, Alg. 1) to
preserve differential privacy in the computation of h0. In fact,

h∈h0

(cid:15)2

Consequently, based on the above analysis, the computation
of h0L(W0) preserves (cid:15)2-differential privacy in Alg. 1 by
injecting an identical Laplace noise 1
) into all input
features. In addition, given the identical Laplace noise, we
do not need to use the differentially private relevance R(D),
since we do not need to redistribute the noise in the ﬁrst afﬁne
transformation layer h0.

|L| Lap( ∆h0

(cid:15)2

D. Proof of Lemma 5

have that

Proof 5: Assume that L and L(cid:48) differ in the last tuple. Let

xn (x(cid:48)

n) be the last tuple in L (L(cid:48)). We have that

∆F =

M
(cid:88)

2
(cid:88)

(cid:88)

(cid:13)
(cid:13)
(cid:13)

l=1

R=0

xi∈L

φ(R)
lxi

−

φ(R)
lx(cid:48)
i

(cid:13)
(cid:13)
(cid:13)

(cid:88)

x(cid:48)

i∈L(cid:48)

M
(cid:88)

2
(cid:88)

=

l=1

R=0

(cid:13)
(cid:13)φ(R)
lxn

− φ(R)
lx(cid:48)
n

(cid:13)
(cid:13)

(30)

= (cid:80)2

We can show that φ(0)
lxn
ynl) log 2 = log 2. Similarly, we can show that φ(0)
lx(cid:48)
n
As a result, φ(0)
lxn

ql (0) = ynl log 2 + (1 −
= log 2.

q=1 f (0)

. Therefore

= φ(0)
lx(cid:48)
n

∆F =

(cid:13)
(cid:13)φ(R)
lxn

− φ(R)
lx(cid:48)
n

(cid:13)
(cid:13) =

(cid:13)
(cid:13)φ(R)
lxn

− φ(R)
lx(cid:48)
n

(cid:13)
(cid:13)

M
(cid:88)

2
(cid:88)

l=1

R=1

(cid:0)(cid:13)
(cid:13)φ(R)
lxn

(cid:13) + (cid:13)
(cid:13)

(cid:13)φ(R)
lx(cid:48)
n

(cid:13)
(cid:1) ≤ 2 max
(cid:13)
xn

M
(cid:88)

2
(cid:88)

l=1

R=1

(cid:107)φ(R)
lxn

(cid:107)

M
(cid:88)

2
(cid:88)

l=1
M
(cid:88)

R=0
2
(cid:88)

l=1

R=1

≤

≤ 2 max
xn

(cid:104) M
(cid:88)
(

l=1

1
2

|h(k)|
(cid:88)

− ynl)

hexn(k)

e=1
M
(cid:88)

(cid:0) 1
8

+

l=1

e,g

(cid:88)

hexn(k)hgxn(k)

(cid:1)(cid:105)

≤ 2(

M × |h(k)| +

M × |h(k)|2)

1
2

1
8
|h(k)|2)

1
4

= M (|h(k)| +

E. Proof of Lemma 6

Proof 6: Let L and L(cid:48) be two neighbor batches. Without
loss of generality, assume that L and L(cid:48) differ in the last
tuple xn (x(cid:48)
n). ∆F is calculated as done in line 17, Alg. 1,
and F L(θt) = (cid:80)M
is the
output of line 27 of the Alg. 1. Note that hxi(k) is the state
of h(k) derived from h0xi by navigating through the neural
network. The perturbation of the coefﬁcient φ(R)
, denoted as
(R)
φ
l

, can be rewritten as:

(cid:0)hxi(k)W T

R=0 φ

(R)
lxi

(cid:80)2

xi∈L

(cid:1)R

(cid:80)

l(k)

l=1

l

(R)
l =

φ

(cid:104) (cid:88)

φ(R)
lxi

+ Lap(

(cid:105)
)

∆F
(cid:15)3

xi∈L

−φ(R)
l

(cid:107)1

(cid:1)

−φ(R)
l

(cid:107)1

(cid:1)

x(cid:48)
i

xi∈L φ(R)
lxi
∆F
∈L(cid:48) φ(R)
lxi
∆F
(cid:13)
(cid:13)
(cid:13)1

φ(R)
lx(cid:48)
i

)

P r(cid:0)F L(θt)(cid:1)
P r(cid:0)F L(cid:48)(θt)(cid:1) =

(cid:81)M

l=1

(cid:81)M

l=1

R=0 exp (cid:0) (cid:15)3(cid:107)(cid:80)
(cid:81)2
R=0 exp (cid:0) (cid:15)3(cid:107)(cid:80)

(cid:81)2

exp(

(cid:15)3
∆F

(cid:13)
(cid:13)
(cid:13)

(cid:88)

xi∈L

φ(R)
lxi

−

(cid:88)

x(cid:48)

i∈L(cid:48)

exp(

exp(

(cid:15)3
∆F

(cid:15)3
∆F

(cid:13)
(cid:13)φ(R)
(cid:13)

lxn

− φ(R)
lx(cid:48)
n

(cid:13)
(cid:13)
(cid:13)1

)

2 max
xn∈L

(cid:13)
(cid:13)φ(R)
lxn

(cid:13)
(cid:13)1)

≤

≤

≤

M
(cid:89)

2
(cid:89)

l=1

R=0

M
(cid:89)

2
(cid:89)

l=1
M
(cid:89)

R=0
2
(cid:89)

l=1

R=0

≤ exp((cid:15)3

2 maxxn∈L

(cid:80)2

R=0(cid:107)φ(R)
lxn

(cid:107)1

)

(cid:80)M

l=1
∆F
4 |h(k)|2)

) = exp((cid:15)3)

≤ exp((cid:15)3

M (|h(k)| + 1
∆F

Consequently,
differential privacy in Alg. 1.

the computation of F L(θt) preserves (cid:15)3-

F. Approximation Error Bounds

The following lemma illustrates the result of how much
error our approximation approach, (cid:98)FL(θ) (Eq. 25), incurs. The
error only depends on the number of possible classiﬁcation
outcomes M . In addition, the average error of the approxima-
tions is always bounded. As in [10, 29], the approximation of
the loss function FL(θ) by applying Taylor Expansion without
removing all polynomial terms with order larger than 2 is as
follows:

M
(cid:88)

(cid:88)

2
(cid:88)

∞
(cid:88)

l=1

xi∈L

q=1

R=0

f (R)
ql (zql)
R!

(cid:0)gql(hxi(k), Wl(k))−zql

(cid:1)R

∀l ∈ {1, . . . , M }, let f1l, f2l, g1l, and g2l be four functions
deﬁned as follows:

g1l(hxi(k), Wj) = hxi(k)W T
g2l(hxi(k), Wj) = hxi(k)W T

l(k)

l(k)

f1l(z1l) = yil log(1 + e−z1l )
f2l(z2l) = (1 − yil) log(1 + ez2l )

(32)

(33)

(34)

(35)

where ∀q, l : zql is a real number.
∀q, l, by setting zql = 0,

simpliﬁed as:

the above equation can be

(31)

(cid:101)FL(θ) =

M
(cid:88)

(cid:88)

2
(cid:88)

∞
(cid:88)

l=1

xi∈L

q=1

R=0

f (R)
ql (0)
R!

(cid:0)hxi(k)W T

l(k)

(cid:1)R

(36)

where hexn(k) is the state of e-th hidden neuron in h(k).

(cid:101)FL(θ) =

We can see that φ

is the perturbation of the coefﬁcient
associated with the labels yil in the training batch L. We

φ(R)
l

(R)
l

As in [10], our approximation approach works by truncating
the Taylor series in Eq. 36 to remove all polynomial terms with

order larger than 2. This leads to a new objective function in
Eq. 25 with low-order polynomials as follows:

(cid:98)FL(θ) =

l=1

xi∈L
(cid:104) 2
(cid:88)

M
(cid:88)

(cid:88)

=

l=1

xi∈L

q=1

M
(cid:88)

(cid:88)

2
(cid:88)

2
(cid:88)

q=1

R=0

f (R)
ql (0)
R!

(cid:0)hxi(k)W T

l(k)

(cid:1)R

ql (0) + (cid:0)
f (0)

ql (0)(cid:1)hxi(k)W T
f (1)

l(k)

2
(cid:88)

q=1

+ (cid:0)

2
(cid:88)

q=1

f (2)
ql (0)
2!

(cid:1)(hxi(k)W T

l(k))2(cid:105)

We are now ready to state the following lemma to show the

approximation error bound of our approach.

Lemma 7: Given two polynomial functions (cid:101)FL(θ) (Eq. 36)
and (cid:98)FL(θ) (Eq. 25), the average error of the approximation is
always bounded as follows:

| (cid:101)FL((cid:98)θ) − (cid:101)FL((cid:101)θ)| ≤ M ×

(37)

e2 + 2e − 1
e(1 + e)2

where (cid:101)θ = arg minθ (cid:101)FL(θ) and (cid:98)θ = arg minθ (cid:98)FL(θ).

(cid:0)

(cid:101)FL(θ)− (cid:98)FL(θ)(cid:1) and S = minθ

Proof 7: Let (cid:101)θ = arg minθ (cid:101)FL(θ) and (cid:98)θ = arg minθ (cid:98)FL(θ),
(cid:101)FL(θ)− (cid:98)FL(θ)(cid:1).
U = maxθ
We have that U ≥ (cid:101)FL((cid:98)θ) − (cid:98)FL((cid:98)θ) and ∀θ∗ : S ≤ (cid:101)FL(θ∗) −
(cid:98)FL(θ∗). Therefore, we have

(cid:0)

(cid:101)FL((cid:98)θ) − (cid:98)FL((cid:98)θ) − (cid:101)FL(θ∗) + (cid:98)FL(θ∗) ≤ U − S
⇔ (cid:101)FL((cid:98)θ) − (cid:101)FL(θ∗) ≤ U − S + (cid:0)

(cid:98)FL((cid:98)θ) − (cid:98)FL(θ∗)(cid:1)

In addition, (cid:98)FL((cid:98)θ) − (cid:98)FL(θ∗) ≤ 0, so (cid:101)FL((cid:98)θ) − (cid:101)FL(θ∗) ≤

U − S. If U ≥ 0 and S ≤ 0 then we have:

| (cid:101)FL((cid:98)θ) − (cid:101)FL(θ∗)| ≤ U − S

(38)

Eq. 38 holds for every θ∗. Therefore, it still holds for (cid:101)θ. Eq.
38 shows that the error incurred by truncating the Taylor series
approximate function depends on the maximum and minimum
values of (cid:101)FL(θ) − (cid:98)FL(θ). To quantify the magnitude of the
error, we ﬁrst rewrite (cid:101)FL(θ) − (cid:98)FL(θ) as:

M
(cid:88)

(cid:104)

l=1
∞
(cid:88)

(cid:101)FL(θ) − (cid:98)FL(θ) =

(cid:101)FL(Wl(k)) − (cid:98)FL(Wl(k))

(cid:105)

M
(cid:88)

(cid:104) (cid:88)

2
(cid:88)

=

l=1

xi∈L

q=1

R=3

f (R)
ql (zql)
R!

(cid:0)gql(hxi(k), Wl(k)) − zql

(cid:1)R(cid:105)

To derive the minimum and maximum values of the function
above, we look into the remainder of the Taylor Expansion for
each l. Let zl ∈ [zql −1, zql +1]. According to the well-known
(cid:101)FL(Wl(k)) − (cid:98)FL(Wl(k))(cid:1) must be in the in-
result [33],
(cid:104) (cid:80)
q

1
|D|
minzl f (3)

ql (zl)(zl−zql)3

ql (zl)(zl−zql)3

maxzl f (3)

, (cid:80)
l

terval

(cid:105)
.

(cid:0)

6

6

maxzl f (3)

If (cid:80)
q
6
minzl f (3)
ql (zl)(zl−zql)3

ql (zl)(zl−zql)3

(cid:80)
q

6

≤ 0, then we have that:

≥

0

and

(cid:101)FL(θ) − (cid:98)FL(θ)

(cid:105)(cid:12)
(cid:12)
(cid:12)

(cid:104)

(cid:12)
(cid:12)
(cid:12)

1
|L|
M
(cid:88)

≤

l=1

q

maxzl f (3)

ql (zl)(zl − zql)3 − minzl f (3)

ql (zl)(zl − zql)3

(cid:88)

6

(39)

This analysis applies to the case of the cross-entropy
error-based loss function as follows. First, for the functions
f1l(z1l) = yil log(1 + e−z1l ) and f2l(z2l) = (1 − yil) log(1 +
ez2l ), we have

f (3)
1l (z1l) =

2yilez1l
(1 + ez1l)3

f (3)
2l (z2l) = (1 − yil)

e−z2l (e−z2l − 1)
(1 + e−z2l )3

It can be veriﬁed that arg minz1l f (3)
1l (z1l) = 2e

1l (z1l) = −2e
(1+e)3 > 0, arg minz2l f (3)
arg maxz1l f (3)
e(1+e)3 < 0, and arg maxz2l f (3)
2l (z2l) = e(e−1)
the average error of the approximation is at most

(1+e)3 < 0,
2l (z2l) =
(1+e)3 > 0. Thus,

1−e

(cid:12) (cid:101)FL((cid:98)θ) − (cid:101)FL((cid:101)θ)(cid:12)
(cid:12)

(cid:12) ≤ M ×

+ (cid:0) e(e − 1)

(1 + e)3 −
Therefore, Eq. 37 holds.

G. Corrections of the Paper

−2e
(1 + e)3

(cid:1)

(cid:104)(cid:0)

2e
(1 + e)3 −
(cid:1)(cid:105)

1 − e
e(1 + e)3

= M ×

e2 + 2e − 1
e(1 + e)2

The differences between this correction and the ﬁrst sub-

mission of our paper can be summarized as follows:

1. There was a mistake in terms of model conﬁgurations
reported in our original version. The number of layers,
hidden neurons, unit patches, and batch sizes are updated
in this correction version. The experimental results of
our algorithms and the differentially private Stochastic
Gradient Descent algorithm (pSGD) [12] are updated as
well. In fact, the code release of the pSGD algorithm2 is
used in this version. The pSGD algorithm is signiﬁcantly
improved in terms of accuracy, and the computation of
the privacy budget (cid:15) is also more accurate.
2. We replace the equations of coefﬁcients {φ(0)
lxi

, φ(1)
,
lxi
φ(2)
}, i.e., after the Eq. 25, with a more detailed ex-
lxi
planation, since it may cause some misunderstanding
to the readers in terms of identifying coefﬁcients of
the Taylor Expansion in Eq. 25. To be clear, we de-
note {φ(0)
, φ(1)
=
lxi
lxi
(cid:80)2
ql (0) and φ(1)
q=1 f (0)
and φ(2)
are coefﬁcients at the
lxi
lxi
ﬁrst order and the second order of the function (cid:98)FL(θ).
and φ(2)
φ(1)
are combinations between the approxima-
lxi
lxi
f (2)
ql (0)
tion terms (cid:80)2
q=1 f (1)
2!

} as the coefﬁcients, where φ(0)
lxi

ql (0), (cid:80)2

, and hxi(k).

, φ(2)
lxi

q=1

2https://github.com/tensorﬂow/models/tree/master/research/differential privacy

Adaptive Laplace Mechanism: Differential Privacy
Preservation in Deep Learning

NhatHai Phan∗1, Xintao Wu†, Han Hu∗, and Dejing Dou‡
∗New Jersey Institute of Technology, Newark, New Jersey, USA
†University of Arkansas, Fayetteville, Arkansas, USA
‡University of Oregon, Eugene, Oregon, USA
Emails: phan@njit.edu, xintaowu@uark.edu, hh255@njit.edu, and dou@cs.uoregon.edu

8
1
0
2
 
r
p
A
 
3
2
 
 
]

R
C
.
s
c
[
 
 
2
v
0
5
7
5
0
.
9
0
7
1
:
v
i
X
r
a

Abstract—In this paper, we focus on developing a novel
mechanism to preserve differential privacy in deep neural net-
works, such that: (1) The privacy budget consumption is totally
independent of the number of training steps; (2) It has the ability
to adaptively inject noise into features based on the contribution
of each to the output; and (3) It could be applied in a variety
of different deep neural networks. To achieve this, we ﬁgure
out a way to perturb afﬁne transformations of neurons, and
loss functions used in deep neural networks. In addition, our
mechanism intentionally adds “more noise” into features which
are “less relevant” to the model output, and vice-versa. Our
theoretical analysis further derives the sensitivities and error
bounds of our mechanism. Rigorous experiments conducted on
MNIST and CIFAR-10 datasets show that our mechanism is
highly effective and outperforms existing solutions.

I. INTRODUCTION

Today, deep learning has become the tool of choice in many
areas of engineering, such as autonomous systems, signal
and information processing, and data analytics. Deep learning
systems are, therefore, not only applied in classic settings, such
as speech and handwriting recognition, but also progressively
operate at the core of security and privacy critical applications.
For instance, self-driving cars make use of deep learning for
recognizing objects and street signs [1]. Detection systems for
email spam integrate learning methods for analyzing data more
effectively [2]. Furthermore, deep learning has applications in
a number of healthcare areas, e.g., phenotype extraction and
health risk prediction [3], prediction of the development of
various diseases, including schizophrenia, cancers, diabetes,
heart failure, etc. [4], and many more. This presents an obvious
threat to privacy in new deep learning systems which are being
deployed. However, there are only a few scientiﬁc studies in
preserving privacy in deep learning.

In the past few decades, a subject of signiﬁcant interest has
been how to release the sensitive results of statistical analyses
and data mining, while still protecting privacy. One state-
of-the-art privacy model is (cid:15)-differential privacy [5], which
ensures that the adversary cannot infer any information about
any speciﬁc record with high conﬁdence (controlled by a
privacy budget) from the released learning models, even if
all the remaining tuples of the sensitive data are possessed
by the adversary. The privacy budget controls the amount by

1 This is a correction version of the previous arXiv:1709.05750 and
ICDM’17 published version. Refer to Appendix G for summary of changes.

which the output distributions induced by two neighboring
datasets may differ: A smaller privacy budget value enforces
a stronger privacy guarantee. Differential privacy research has
been studied from both theoretical and application perspectives
[6, 7]. The mechanisms of achieving differential privacy
mainly include adding Laplace noise [5],
the exponential
mechanism [8], and the functional perturbation method [6].

It is signiﬁcant and timely to combine differential privacy
and deep learning, i.e., the two state-of-the-art techniques in
privacy preserving and machine learning. However, this is
a challenging task, and only a few scientiﬁc studies have
been conducted. In [9], Shokri and Shmatikov proposed a dis-
tributed training method, which injects noise into “gradients”
of parameters, to preserve privacy in neural networks. In this
method, the magnitude of injected noise and the privacy budget
(cid:15) are accumulated in proportion to the number of training
epochs and the number of shared parameters. Thus, it may
consume an unnecessarily large portion of the privacy budget,
as the number of training epochs and the number of shared
parameters among multiple parties are often large [10].

To improve this, based on the composition theorem [11],
Abadi et al. [12] proposed a privacy accountant, which keeps
track of privacy spending and enforces applicable privacy poli-
cies. However, the approach is still dependent on the number
of training epochs, as it introduces noise into “gradients” of
parameters in every training step. With a small privacy budget
(cid:15), only a small number of epochs can be used to train the
model [12]. In practice, that could potentially affect the model
utility, when the number of training epochs needs to be large
to guarantee the model accuracy.

A recent approach towards differentially private deep neural
networks was explored by Phan et al. [10]. This work pro-
posed deep private auto-encoders (dPAs), in which differential
privacy is enforced by perturbing the cross-entropy errors in
auto-encoders [13]. Their algorithm was designed particularly
for auto-encoders, in which speciﬁc objective functions are ap-
plied. A different method, named CryptoNets, was proposed
in [14] towards the application of neural networks to encrypted
data. A data owner can send their encrypted data to a cloud
service that hosts the network, and get encrypted predictions in
return. This method is different from our context, since it does
not aim at releasing learning models under privacy protections.
Another drawback of the existing techniques is that all

parameters are treated the same in terms of the amount of noise
injected. This may not be ideal in real scenarios, since different
features and parameters normally have different impacts upon
the model output. Fig. 1 shows the relevance estimated by
applying Layer-wise Relevance Propagation (LRP) [15] of
input features to the prediction of the image’s label in the
MNIST dataset [16]. Dark red units have stronger impacts
than green and yellow units. Injecting the same magnitude of
noise into all parameters may affect the model utility.

Research Goal. Therefore,
there is an urgent demand for
the development of a privacy
preserving mechanism, such that:
(1) It
is totally independent of
training epochs
the number of
in consuming privacy budget; (2)
It has the ability to adaptively
inject noise into features based
on the contribution of each to
the model output; and (3) It can
be applied in a variety of deep
networks. Mechanisms
neural
signiﬁcantly enhance the

Fig. 1. An instance of rel-
evance of each input
feature
given to the classiﬁcation out-
put (MNIST dataset). Red neu-
rele-
rons
vances, and green neurons indi-
cate weaker relevances.

stronger

indicate

with such characteristics will
operation of privacy preservation in deep learning.

Our Contribution. Motivated by this, we develop a novel
mechanism, called Adaptive Laplace Mechanism (AdLM), to
preserve differential privacy in deep learning. Our idea is to
intentionally add “more noise” into features which are “less
relevant” to the model output, and vice-versa. To achieve that,
we inject Laplace noise into the computation of Layer-wise
Relevance Propagation (LRP) [15] to estimate a differentially
private relevance of each input feature to the model output.
Given the perturbed features, we ﬁgure out a novel way to
distribute adaptive noise into afﬁne transformations and loss
functions used in deep neural networks as a preprocessing step,
so that preserving differential privacy is feasible. As a result,
we expect to improve the utility of deep neural networks under
(cid:15)-differential privacy. It is worth noting that our mechanism
does not access the original data again in the training phase.
Theoretical analysis derives the sensitivities and error bounds
of our mechanism, and shows that they are totally independent
of the number of epochs.

Different from [9, 12], in our mechanism, the injected noise
and the privacy budget consumption do not accumulate in each
training step. Consequently, the privacy budget consumption in
our mechanism is totally independent of the number of training
epochs. In addition, different from [10], our mechanism can be
applied in a variety of deep learning networks with different
activation functions. Convolution neural networks (CNNs)
[16] are used as an example to validate the effectiveness of our
mechanism. Rigorous experiments conducted on MNIST and
CIFAR-10 datasets [17] show that our mechanism is effective
and outperforms existing solutions.

II. PRELIMINARIES AND RELATED WORKS

In this section, we revisit differential privacy, existing tech-
niques in preserving differential privacy in deep learning, and
the Layer-wise Relevance Propagation (LRP) algorithm [15].
Let D be a database that contains n tuples x1, x2, . . . , xn
and d+1 attributes X1, X2, . . . , Xd, Y , and for each tuple xi =
(xi1, xi2, . . . , xid, yi). We assume, without loss of generality,
(cid:113)(cid:80)d
ij ≤ 1 where xij ≥ 0. This assumption can be
easily enforced by changing each xij to
, where
αj and βj denote the minimum and maximum values in the
domain of Xj.

xij −αj
(βj −αj )·

j=1 x2

√

d

To be general, let us consider a classiﬁcation task with M
possible categorical outcomes, i.e., the data label yi given
xi ∈ L is assigned to only one of the M categories.
Each yi can be considered as a vector of M categories
yi = {yi1, . . . , yiM }. If the l-th category is the class of xi,
then yil = 1, otherwise yil = 0. Our objective is to construct a
differentially private deep neural network from D that (i) takes
xi = (xi1, xi2, . . . , xid) as input and (ii) outputs a prediction
of yi that is as accurate as possible. To evaluate whether model
parameters θ lead to an accurate model, a cost function FD(θ)
is used to measure the difference between the original and
predicted values of yi.

A. (cid:15)-Differential Privacy

As the released model parameter θ may disclose sensitive
information of D, to protect the privacy, we require that the
model training should be performed with an algorithm that
satisﬁes (cid:15)-differential privacy. The deﬁnition of differential
privacy is as follows:

Deﬁnition 1: (cid:15)-Differential Privacy [5]. A randomized algo-
rithm A fulﬁlls (cid:15)-differential privacy, if for any two databases
D and D(cid:48) differing at most one tuple, and for all O ⊆
Range(A), we have:

P r[A(D) = O] ≤ e(cid:15)P r[A(D(cid:48)) = O]

(1)

where the privacy budget (cid:15) controls the amount by which the
distributions induced by D and D(cid:48) may differ. A smaller (cid:15)
enforces a stronger privacy guarantee of A.

A general method for preserving (cid:15)-differential privacy of
any function F (on D) is the Laplace mechanism [5], where
the output of F is a vector of real numbers. In fact, the
mechanism exploits the global sensitivity of F over any two
neighboring data sets (differing at most one record), which is
denoted as GSF (D). Given GSF (D), the Laplace mechanism
ensures (cid:15)-differential privacy by injecting noise η into each
2GSF (D) exp(−|η| ·
value in the output of F(D): pdf (η) =
GSF (D) ), where η is drawn i.i.d. from Laplace distribution
with zero mean and scale GSF (D)/(cid:15).

(cid:15)

(cid:15)

Research in differential privacy has been signiﬁcantly stud-
ied, from both the theoretical perspective, e.g., [6, 18], and
the application perspective, e.g., data collection [19], spatio-
temporal correlations [20, 21], data streams [22], stochastic
gradient descents [23], recommendation [7], regression [6],

online learning [24], publishing contingency tables [25], and
spectral graph analysis [26].

B. Differential Privacy in Deep Learning

Deep neural networks deﬁne parameterized functions from
inputs xi ∈ D to outputs, i.e, a prediction of yi, as compo-
sitions of many layers of hidden neurons and nonlinear func-
tions. For instance, Fig. 2 illustrates a multilayer neural net-
work, in which there are k hidden layers H = {h1, . . . , hk}.
Rectiﬁed linear units (ReLUs) and sigmoids are widely used
examples of activation functions. By adjusting parameters of
these neurons, such parameterized functions can be trained
with the goal of ﬁtting a ﬁnite set of input-output data
instances. We specify a loss function FD(θ) that represents
the penalty for mismatching between the predicted and original
values of yi. FD(θ) on parameters θ is the average of the loss
over the training examples {x1,..., xn}. Stochastic gradient
descent (SGD) algorithm is used to minimize the cross-entropy
error [13], given the model outputs and true data labels.

In the work of Abadi et al. [12],
to preserve differential privacy, normal
(Gaussian) distribution noise is added
into the gradients ˜g of parameters W as
follows. At each training step t, the al-
gorithm ﬁrst takes a random sample Lt
with sampling probability L/n, where
L is a group size and n is the number
of tuples in D. For each tuple xi ∈ Lt,
the gradient gt(xi) = ∇θtFxi(θt) is
computed. Then the gradients will be
bounded by clipping each gradient in
l2 norm, i.e., the gradient vector gt is
replaced by gt/ max(1, (cid:107)g2
t (cid:107)/C) for a
predeﬁned threshold C. Normal distri-
bution noise is added into gradients of
parameters θ as

Fig. 2. An instance of
differentially private neu-
ral networks.

˜gt ←

(cid:88)

(cid:16)

1
L

i

gt(xi)
max(1, (cid:107)gt(xi)2(cid:107)

)

C

+ N (0, σ2C 2I)

(cid:17)

θt ← θt − ξt˜gt

(2)

(3)

where ξt is a learning rate at the training step t.

Finally, differentially private parameters θ, denoted θ,
learned by the algorithm are shared to the public and other
parties. Overall, the algorithm introduces noise into “gradi-
ents” of parameters at every training step. The magnitude of
injected noise and the privacy budget (cid:15) are accumulated in
proportion to the number of training epochs.

Compared with the work in [12], the goal is similar: learn-
ing differentially private parameters θ. However, we develop a
novel mechanism in which the privacy budget consumption is
independent of the number of training epochs. Our mechanism
is different. We redistribute the noise so that “more noise”
will be added into features which are “less relevant” to the
model output, and vice-versa. Moreover, we inject noise into
coefﬁcients of afﬁne transformations and loss functions, such
that differentially private parameters can be learned.

C. Layer-wise Relevance Propagation

Layer-wise Relevance Propagation (LRP) [15] is a well-
accepted algorithm, which is applied to compute the relevance
to the model outcome Fxi(θ).
of each input feature xij
Given the relevance, denoted R(k)
m (xi), of a certain neuron
m at the layer k, i.e., m ∈ hk, for the model outcome
Fxi(θ), LRP algorithm aims at obtaining a decomposition of
such relevance in terms of messages sent to neurons of the
previous layers, i.e., the layer (k-1)-th. These messages are
called R(k−1,k)
p←m (xi). The overall relevance of each neuron in
the lower layer is determined by summing up the relevance
coming from all upper-layer neurons:

R(k−1)
p

(xi) =

R(k−1,k)

p←m (xi)

(4)

(cid:88)

m∈hk

where the relevance decomposition is based on the ratio of
local and global afﬁne transformations and is given by:
zm(xi)+µ R(k)
zm(xi)−µ R(k)
with: zm(xi) is the afﬁne transformation of neuron m ∈ hk:

zm(xi) ≥ 0
zm(xi) < 0

m (xi)
m (xi)

p←m (xi) =

(cid:40) zpm(xi)

R(k−1,k)

zpm(xi)

(5)

zpm(xi) = pxi × Wpm
zm(xi) =

(cid:88)

zpm(xi) + bm

p∈hk

(6)

(7)

s.t. pxi is the value of neuron p given xi, Wpm is a weight
connecting the neuron p to neuron m, and bm is a bias term.
A predeﬁned stabilizer µ ≥ 0 is introduced to overcome
unboundedness.

In Eq. 5, in order to back propagate the relevance, we need
to compute the relevance R(k)
m (xi) at the last hidden layer, i.e.,
the k-th layer, from the output layer. Given the output variable
o, R(k)

m (xi) is computed as follows:

(cid:40) zmo(xi)

R(k)

m (xi) =

zo(xi)+µ Fxi(θ)
zmo(xi)
zo(xi)−µ Fxi(θ)
Given k hidden layers {h1, . . . , hk}, by using Eqs. 4, 5,
and 8, we can compute the relevance of every hidden neuron
and input feature. As in [15], the following equation holds:

zo(xi) ≥ 0
zo(xi) < 0

(8)

Fxi(θ) =

R(k)

m (xi) = . . . =

Rxij (xi)

(9)

(cid:88)

m∈hk

(cid:88)

xij ∈xi

where Rxij (xi) is the relevance of the feature xij given
the model outcome Fxi(θ). To ensure that
the relevance
Rxij (xi) ∈ [−1, 1], each Rxij (xi)
is normalized to
Rxij (xi)−χ
(ϕ−χ)
imum values in the domain of (cid:8)Rxi1 (xi), . . . , Rxid (xi)(cid:9).
III. ADAPTIVE LAPLACE MECHANISM (ADLM)

, where ϕ and χ denote the maximum and min-

In this section, we formally present our mechanism. Given
a loss function F(θ) with model parameters θ, the network is
trained by optimizing the loss function F(θ) on D by applying
SGD algorithm on T random training batches consequently.
At each training step, a single training batch L is used. A batch

L is a random set of training samples in D with a predeﬁned
batch size |L|.

The pseudo-codes of Algorithm 1 outline ﬁve basic steps
in our mechanism to learn differentially private parameters of
the model. The ﬁve basic steps are as follows:

• Step 1 (Lines 1-7). In the ﬁrst step, we obtain the average
relevances of all the j-th input features, denoted as Rj(D),
by applying the LRP algorithm on a well-trained deep neural
network on the database D. Rj(D) is computed as follows:

A. Private Relevance

In this section, we preserve differential privacy in the
computation of the relevance of each j-th input feature on
database D by injecting Laplace noise into Rj(D). We set
∆R = 2d
|D| based on the maximum values of all the relevances
Rj(D) (line 4, Alg. 1). In lines 5-6, the relevance of each j-
th input feature Rj(D) is perturbed by adding Laplace noise
Lap( ∆R
). The perturbed relevance is denoted as Rj. In line
(cid:15)1
7, we obtain the set of all perturbed relevances R(D):

Rj(D) =

Rxij (xi)

(10)

R(D) = (cid:8)Rj

(cid:9)

1
|D|

(cid:88)

xi∈D

Then, we derive differentially private relevances, denoted as
Rj, by injecting Laplace noise into Rj for all the j-th input
features. The total privacy budget in this step is (cid:15)1.

• Step 2 (Lines 8-14). In the second step, we derive a
differentially private afﬁne transformation layer, denoted h0.
Every hidden neuron h0j ∈ h0 will be perturbed by injecting
adaptive Laplace noise into its afﬁne transformation to pre-
serve differential privacy given a batch L. Based on Rj, “more
noise” is injected into features which are “less relevant” to the
model output, and vice-versa. The total privacy budget used
in this step is (cid:15)2. The perturbed afﬁne transformation layer is
denoted as h0L (Fig. 2).

• Step 3 (Line 15). In the third step, we stack hidden layers
{h1, . . . , hk} on top of the differentially private hidden layer
h0L to construct the deep private neural network (Fig. 2).
The computations of h1, . . . , hk are done based on the differ-
entially private layer h0L without accessing any information
from the original data. Therefore, the computations do not
disclose any information. Before each stacking operation, a
normalization layer, denoted h, is applied to bound non-linear
activation functions, such as ReLUs (Fig. 2).

• Step 4 (Lines 16-19). After constructing a private struc-
ture of hidden layers {h0L, h1, . . . , hk}, we need to protect
the labels yi at the output layer. To achieve this, we derive a
polynomial approximation of the loss function F. Then, we
perturb the loss function F by injecting Laplace noise with a
privacy budget (cid:15)3 into its coefﬁcients to preserve differential
privacy on each training batch L, denoted F L(θ).

• Step 5 (Lines 20-30). Finally, the parameter θT is derived
by minimizing the loss function F L(θ) on T training steps
sequentially. In each step t, stochastic gradient descent (SGD)
algorithm is used to update parameters θt given a random batch
L of training samples in D. This essentially is an optimization
process, without using any additional information from the
original data.

In our mechanism, differential privacy is preserved, since it
is enforced at every computation task that needs to access the
original data D. Laplace noise is injected into our model only
once, as a preprocessing step to preserve differential privacy in
the computation of the relevance Rj(D), the ﬁrst layer h0L,
and the loss function F L(θ). Thereafter, the training phase
will not access the original data again. The privacy budget
consumption does not accumulate in each training step. As
such, it is independent of the number of training epochs.

where Rj =

Rxij (xi) + Lap(

j∈[1,d]
1
(cid:88)
|D|

xi∈D

(11)

(12)

∆R
(cid:15)1

)

The computation of R(D) is (cid:15)1-differential private. The

correctness is based on the following lemmas.

Lemma 1: Let D and D(cid:48) be any two neighboring databases.
Given R(D) and R(D(cid:48)) be the relevance of all input features
on D and D(cid:48), respectively, and denote their representations as

R(D) = (cid:8)Rj(D)(cid:9)

j∈[1,d] s.t. Rj(D) =

Rxij (xi)

R(D(cid:48)) = (cid:8)Rj(D(cid:48))(cid:9)

j∈[1,d] s.t. Rj(D(cid:48)) =

Rx(cid:48)

ij

(x(cid:48)
i)

1
|D|

(cid:88)

xi∈D

1
|D(cid:48)|

(cid:88)

x(cid:48)

i∈D(cid:48)

Then, we have the following inequality:

1
|D|

d
(cid:88)

(cid:13)
(cid:13)
(cid:13)

(cid:88)

j=1

xi∈D

Rxij (xi) −

Rx(cid:48)

ij

(cid:13)
(x(cid:48)
(cid:13)
i)
(cid:13)1

≤

2d
|D|

(13)

(cid:88)

x(cid:48)

i∈D(cid:48)

where d is the number of features in each tuple xi ∈ D.
Proof 1: The proof of Lemma 1 is in Appendix A.
Lemma 2: Algorithm 1 preserves (cid:15)1-differential privacy in

the computation of R(D).

Proof 2: The proof of Lemma 2 is in Appendix B1.

Lemma 2 shows that the computa-
tion of the relevances R(D) is dif-
ferentially private. Fig. 3 illustrates
the differentially private relevance Rj
(Eq. 12) of each j-th coefﬁcient given
the database D. It is worth noting
that the relevance distribution is not
identical. In the next section, R(D) is
used to redistribute the noise injected
into the afﬁne transformation layer h0
in our deep neural network.

B. Private Afﬁne
Layer with Adaptive Noise

Transformation

Fig. 3. The average differ-
entially private relevance
of each input feature given
MNIST dataset.

In general, before applying activation functions such as
the afﬁne transformation of a hidden

ReLU and sigmoid,
neuron h ∈ h0 can be presented as:

hxi(W ) = b + xiW T
where b is a static bias, and W is the parameter of h. Given
a training batch L, h can be rewritten as:

(14)

hL(W ) =

(b + xiW T )

(15)

(cid:88)

xi∈L

Given the above representation of each neuron hL(Wh),
we preserve differential privacy in the computation of h0 on
L by injecting Laplace noise into inputs b and xi of every
neuron hL(W ) ∈ h0. Intuitively, we can apply an identical
noise distribution 1
) to all input features, where
∆h0 = 2 (cid:80)
d (line 9, Alg. 1). This approach works well
when every input feature has an identical contribution to the
model outcome. (Please refer to the Appendix C1.)

|L| Lap( ∆h0

h∈h0

(cid:15)2

In practice, this assumption usually is violated. For instance,
Fig. 1 illustrates the relevance, estimated by the LRP algorithm
[15], of each input feature given different handwritten digits. It
is clear that the relevances are not identical. The differentially
private relevances are not identical as well (Fig. 3). Therefore,
injecting the same magnitude of noise into all input features
may affect the utility of differentially private neural networks.
To address this problem, we propose an Adaptive Laplace
Mechanism (AdLM), to adaptively redistribute the injected
noise to improve the performance. Given hidden units hxi(W )
in Eq. 14, our key idea is to intentionally add more noise into
input features which are less relevant to the model output Y ,
and vice-versa. As a result, we expect to improve the utility
of the model under differential privacy. In fact, we introduce
a privacy budget ratio βj and the privacy budget (cid:15)j for each
j-th input feature as follows:

s.t.

(cid:15)j = βj × (cid:15)2

(16)

βj =

d × |Rj|
(cid:80)d
j=1 |Rj|
We set ∆h0 = 2 (cid:80)

h∈h0

d based on the maximum values
of all the input features xij (line 9, Alg. 1). In line 11, βj
can be considered as the fraction of the contribution to ∆h0
from the j-th input feature to the hidden neuron h ∈ h0. In
lines 12-13, each input feature xij of every hidden neuron h in
the ﬁrst afﬁne transformation layer h0 is perturbed by adding
adaptive Laplace noise 1
|L| Lap(∆h0 /(cid:15)j). The perturbed input
features are denoted as xi. In lines 20-21, given a random
training batch L, we construct the differentially private afﬁne
transformation layer h0L, which consists of perturbed hidden
neurons hL(W ):
h0L(W0) = (cid:8)hL(W )(cid:9)

s.t. hL(W ) =

xiW T + b

(cid:88)

(cid:16)

(cid:17)

h∈h0

xi∈L

|L| Lap( ∆h0

where b = b+ 1
) is the perturbed bias (line 14). The
following lemma shows that Alg. 1 preserves (cid:15)2-differential
privacy in the computation of h0L.

(cid:15)2

Lemma 3: Let L and L(cid:48) be any two neighboring batches.
Given parameter W0, let h0L and h0L(cid:48) be the ﬁrst afﬁne
transformation layers on L and L(cid:48), respectively, and denote
their representations as follows:
h0L(W0) = {hL(W )}h∈h0 s.t. hL(W ) =

(b + xiW T )

(cid:88)

h0L(cid:48)(W0) = {hL(cid:48)(W )}h∈h0 s.t. hL(cid:48)(W ) =

(b + x(cid:48)

iW T )

xi∈L
(cid:88)

x(cid:48)

i∈L(cid:48)

Then, we have the following inequality:

Algorithm 1 Adaptive Laplace Mechanism (Database D,
hidden layers H, loss function F(θ), and privacy budgets (cid:15)1,
(cid:15)2, and (cid:15)3, the number of batches T , the batch size |L|)

1: Compute the average relevance by applying the LRP Alg.
(cid:80)
2: ∀j ∈ [1, d] : Rj(D) = 1
|D|
3: Inject Laplace noise into the average relevance of each j-th

xi∈D Rxij (xi) #Eq.10#

input feature

4: ∆R = 2d/|D| #Lemma 1#
5: for j ∈ [1, d] do
(cid:80)
Rj ← 1
6:
|D|
7: R(D) = {Rj}j∈[1,d]
8: Inject Laplace noise into coefﬁcients of the differentially

xi∈D Rxij (xi) + Lap( ∆R

(cid:15)1

)

private layer h0

d #Lemma 3#

9: ∆h0 = 2 (cid:80)
h∈h0
10: for j ∈ [1, d] do
(cid:15)j ← βj × (cid:15)2 #Eq. 16#
11:
12: for xi ∈ D, j ∈ [1, d] do
xij ← xij + 1
|L| Lap(
13:
∆h0
14: b ← b + 1
|L| Lap(
(cid:15)2
15: Construct hidden layers {h1, . . . , hk} and normalization

) #perturb input feature xij#

) #perturb bias b#

∆h0
(cid:15)j

layers {h1, . . . , h(k)}

16: Inject Laplace noise into coefﬁcients of the approximated

) #perturb coefﬁcients of (cid:98)F

4 |h(k)|2) #Lemma 5#

loss function (cid:98)F
17: ∆F = M (|h(k)| + 1
18: for xi ∈ D, R ∈ [0, 2], l ∈ [1, M ] do
+ 1
19:
20: Initialize θ0 randomly
21: for t ∈ [T ] do
22:
23:

|L| Lap( ∆F
(cid:15)3

← φ(R)
lxi

(R)
lxi

φ

24:
25:
26:

Take a random training batch L
Construct differentially private afﬁne transformation
layer
h0L(W0) ← {hL(W )}h∈h0
s.t. hL(W ) = (cid:80)
Construct differentially private loss function
(cid:1)R
F L(θt) = (cid:80)M
(cid:80)2
l=1
Compute gradient descents
θt+1 ← θt − ηt

27:
28:
29:
30: Return θT #((cid:15)1 + (cid:15)2 + (cid:15)3)-differentially private#

(cid:79)θt F L(θt) #ηt is a learning rate#

(cid:0)xiW T + b)(cid:3)(cid:1)

(R)
lxi

W T

xi∈L

xi∈L

(cid:0)φ

1
|L|

R=0

(cid:80)

l(k)

∆h0 =

(cid:88)

d
(cid:88)

(cid:88)

(cid:13)
(cid:13)
(cid:13)

h∈h0

j=1

xi∈L

xij −

x(cid:48)
ij

(cid:13)
(cid:13)
(cid:13)1

(cid:88)

x(cid:48)

i∈L(cid:48)

≤ 2

d

(17)

(cid:88)

h∈h0

where d is the number of features in each tuple xi ∈ D.

Proof 3: Assume that L and L(cid:48) differ in the last tuple. Let

xn (x(cid:48)

n) be the last tuple in L (L(cid:48)). We have that

∆h0 =

(cid:88)

d
(cid:88)

(cid:88)

(cid:13)
(cid:13)
(cid:13)

h∈h0

j=1

xi∈L

xij −

x(cid:48)
ij

(cid:13)
(cid:13)
(cid:13)1

(cid:88)

x(cid:48)

i∈L(cid:48)

(cid:88)

d
(cid:88)

=

h∈h0

j=1

(cid:107)xnj − x(cid:48)

nj(cid:107)1 ≤ 2 max
xi∈L

(cid:107)xij(cid:107)1

(18)

(cid:88)

d
(cid:88)

h∈h0

j=1

Since ∀xi, j : xij ∈ [0, 1], from Eq. 18 we have that: ∆h0 ≤
2 (cid:80)
(cid:4)

d. Eq. 17 holds.

h∈h0

Lemma 4: Algorithm 1 preserves (cid:15)2-differential privacy in

the computation of h0L(W0) (lines 24-25).

Proof 4: From lines 24-25 in the Alg. 1, for each h ∈ h0L,

h can be re-written as:

hL(W ) =

d
(cid:88)

(cid:104) (cid:88)

j=1

xi∈L

(cid:0)xij +

1
|L|

Lap(

)(cid:1)W T (cid:105)

∆h0
(cid:15)j

1
|L|

(cid:88)

(cid:0)b +

+

xi∈L

Lap(

∆h0
(cid:15)2

)(cid:1)

(19)

Let us consider the static bias b = 1 as the 0-th input feature
and its associated parameter Wb, i.e., xi0 = b = 1 and W =
Wb ∪ W , we have that

hL(W ) =

d
(cid:88)

(cid:104) (cid:88)

j=0

xi∈L

(cid:0)xij +

1
|L|

Lap(

)(cid:1)W T (cid:105)

∆h0
(cid:15)j

(20)

d
(cid:88)

(cid:104) (cid:88)

=

j=0

xi∈L

xij + Lap(

(cid:105)
W T =

)

∆h0
(cid:15)j

d
(cid:88)

j=0

h
j W T

φ

(21)

h

where φ

j = (cid:2) (cid:80)
We can see that φ

xi∈L xij + Lap( ∆h0

(cid:15)j

)(cid:3).

h
j is the perturbation of the input feature
xij associated with the j-th parameter Wj ∈ W of the hidden
neuron h on L. Since all the hidden neurons h in h0 are
perturbed, we have that:

P r(cid:0)h0L(W0)(cid:1) =

(cid:89)

d
(cid:89)

exp(cid:0) (cid:15)j(cid:107)(cid:80)

xi∈L xij − φ

h
j (cid:107)

(cid:1)

h∈h0

j=0

∆h0

d (line 9 in Alg. 1). h0L(W0) is the

∆h0 is set to 2 (cid:80)

h∈h0
output (lines 24-25 in Alg. 1). We have that
j=0 exp (cid:0) (cid:15)j (cid:107)(cid:80)
(cid:81)d
j=0 exp (cid:0) (cid:15)j (cid:107)(cid:80)

P r(cid:0)h0L(W0)(cid:1)
P r(cid:0)h0L(cid:48)(W0)(cid:1) =

h∈h0

(cid:81)d

(cid:81)

(cid:81)

h∈h0

xi∈L xij −φh
∆h0
∈L(cid:48) x(cid:48)
∆h0

ij −φh

x(cid:48)
i

j (cid:107)1

(cid:1)

j (cid:107)1

(cid:1)

≤

≤

≤

(cid:89)

d
(cid:89)

h∈h0

j=0

(cid:89)

d
(cid:89)

h∈h0

j=1

(cid:89)

d
(cid:89)

h∈h0

j=1

≤ exp((cid:15)2

exp(

(cid:15)j
∆h0

(cid:13)
(cid:13)
(cid:13)

(cid:88)

xi∈L

xij −

x(cid:48)

ij

(cid:13)
(cid:13)
(cid:13)1

)

(cid:88)

x(cid:48)

i∈L(cid:48)

exp(

(cid:15)j
∆h0

2 max
xn∈L

(cid:13)
(cid:13)xnj

(cid:13)
(cid:13)1) ≤

(cid:89)

d
(cid:89)

h∈h0

j=1

exp(

2(cid:15)j
∆h0

)

)

2 d×|Rj |
(cid:80)d
j=1 |Rj |
∆h0
d(cid:2) (cid:80)d

j=1

exp((cid:15)2

2 (cid:80)

h∈h0

∆h0

|Rj |
j=1 |Rj |

(cid:80)d

(cid:3)

) = exp((cid:15)2)

Consequently,
differential privacy in Alg. 1.

the computation of h0L(W0) preserves (cid:15)2-
(cid:4)
Lemma 4 shows that we can redistribute the noise in the
computation of the ﬁrst hidden layer h0L under differential
privacy. In addition, given a batch L, without accessing
additional information from the original data, none of the
computations on top of h0L risk the privacy protection under
differential privacy. These computation tasks include the appli-
cation of activation functions, e.g., ReLU and sigmoid, on h0L,
the computation of hidden layers h1, . . . , hk, local response

normalizations, drop-out operations, polling layers, etc. (line
15, Alg. 1). This result can be applied to both fully-connected
layers and convolution layers. In this paper, we applied ReLU
on top of h0L and other layers h1, . . . , hk. Local response
normalization layers are used after the application of ReLUs
in each hidden layer to bound ReLU functions.

Local Response Normalization. The hidden units of the
lower layer will be considered as the input of the next layer
(Fig. 2). To ensure that this input is bounded hxi ∈ [0, 1], as in
[10, 27], we add a local response normalization (LRN) layer on
top of each hidden layer. Given a fully-connected layer, as in
[10], given an input xi, each perturbed neuron hxi (W ) can be
directly normalized as follows: hxi ←
/(ϕ−χ),
where ϕ and χ denote the maximum and minimum values in
the domain of {hxi}i∈L.

hxi(W )−χ

(cid:17)

(cid:16)

k
Given a convolution layer with a perturbed neuron h
ij at
location (i, j) in the k-th feature map, based on [27], our local
response normalization (LRN) is presented as follows:

k
k
h
ij/ max
ij ← h

k
ij, (cid:0)q + α
h

(cid:16)

min(N −1,k+l/2)
(cid:88)

m=max(0,k−l/2)

m

ij )2(cid:1)β(cid:17)

(h

(22)

where the constants q, l, α, and β are hyper-parameters, N is
the total number of feature maps. As in [27], we used q =
2, l = 5, α = 10−4, and β = 0.75 in our experiments.

C. Perturbation of the Loss Function FL(θ)

On top of our private deep neural network (Fig. 2), we add
an output layer with the loss function FL(θ) to predict Y .
Since the loss function FL(θ) accesses the labels yi given
xi ∈ L from the data, we need to protect the labels yi at the
output layer. First, we derive a polynomial approximation of
the loss function based on Taylor Expansion [28]. Then, we
inject Laplace noise into coefﬁcients of the loss function F to
preserve differential privacy on each training batch L.

The model output variables {ˆy1, . . . , ˆyM } are fully linked to
the normalized highest hidden layer, denoted h(k), by weighted
connections W(k) (Fig. 2). As common, the logistic function
can be used as an activation function of the output variables.
Given, l-th output variable ˆyl and xi, we have:

ˆyil = σ(cid:0)hxi(k)W T

l(k)

(cid:1)

(23)

where hxi(k)
navigating through the neural network.

is the state of h(k) derived from h0xi by

Cross-entropy error [13] can be used as a loss function. It
has been widely used and applied in real-world applications
[13]. Therefore, it is critical to preserve differential privacy
under the use of the cross-entropy error function. Other loss
functions, e.g., square errors, can be applied in the output layer,

M
(cid:88)

(cid:88)

(cid:16)

l=1

xi∈L

M
(cid:88)

(cid:88)

(cid:16)

l=1

xi∈L

as well. In our context, the cross-entropy error function is
given by:

Proof 5: The proof of Lemma 5 is in Appendix D1.
Lemma 6: Algorithm 1 preserves (cid:15)3-differential privacy in

FL(θ) = −

yil log ˆyil + (1 − yil) log(1 − ˆyil)

(cid:17)

the computation of F L(θt) (line 27).

Proof 6: The proof of Lemma 6 is in Appendix E1.

= −

yil log(1 + e−hxi(k)W T

l(k) )

+ (1 − yil) log(1 + ehxi(k)W T

l(k))

(24)

(cid:17)

Based on [10] and Taylor Expansion [28], we derive the

polynomial approximation of FL(θ) as:

(cid:0)hxi(k)W T

l(k)

(cid:1)R

M
(cid:88)

(cid:88)

2
(cid:88)

2
(cid:88)

q=1

R=0

(cid:98)FL(θ) =

l=1

xi∈L
(cid:104) 2
(cid:88)

M
(cid:88)

(cid:88)

=

l=1

xi∈L

q=1

f (R)
ql (0)
R!

2
(cid:88)

q=1
f (2)
ql (0)
2!

ql (0) + (cid:0)
f (0)

ql (0)(cid:1)hxi(k)W T
f (1)

l(k)

+ (cid:0)

2
(cid:88)

q=1

(cid:1)(hxi(k)W T

l(k))2(cid:105)

(25)

where ∀l ∈ [1, M ] : f1l(z) = yil log(1 + e−z) and f2l(z) =
(1 − yil) log(1 + ez).

To achieve (cid:15)3-differential privacy, we employ functional
mechanism [29] to perturb the loss function (cid:98)FL(θ) by injecting
Laplace noise into its polynomial coefﬁcients. So, we only
need to perturb (cid:98)FL(θ) just once in each training batch. To be
, φ(2)
clear, we denote {φ(0)
} as the coefﬁcients, where
lxi
lxi
φ(0)
and φ(2)
ql (0) and φ(1)
are coefﬁcients at the
lxi
lxi
lxi
ﬁrst order and the second order of the function (cid:98)FL(θ). In fact,
φ(1)
will be combinations between the approximation
lxi
terms (cid:80)2
ql (0), (cid:80)2

and φ(2)
lxi
q=1 f (1)

, and hxi(k).

q=1 f (0)

f (2)
ql (0)
2!

= (cid:80)2

, φ(1)
lxi

In Alg. 1, we set ∆F = M (|h(k)| + 1

4 |h(k)|2) (line 17).
In essence, coefﬁcients φ(R)
with R ∈ [0, 2] are functions
lxi
of the label yil only. Therefore, we can perform the pertur-
) into φ(R)
bation by injecting Laplace noise 1/|L|Lap( ∆F
lxi
(cid:15)3
for every training label yil ∈ D (lines 18-19). Then, the
(R)
perturbed coefﬁcients, denoted φ
lxi are used to construct the
differentially private loss function F L(θt) (line 27) during
the training process without accessing the original label yil
again (lines 20-30). Stochastic gradient descent and back-
propagation algorithms are used to minimize the perturbed
loss function F L(θt).

q=1

Now, we are ready to state that the computation of F L(θt)
is (cid:15)3-differentially private, and our mechanism preserves ((cid:15)1 +
(cid:15)2 + (cid:15)3)-differential privacy in the following lemmas.

Lemma 5: Let L and L(cid:48) be any two neighboring batches.
Let (cid:98)FL(θ) and (cid:98)FL(cid:48)(θ) be the loss functions on L and L(cid:48)
respectively, then we have the following inequality:

∆F =

M
(cid:88)

2
(cid:88)

(cid:88)

(cid:13)
(cid:13)
(cid:13)

l=1

R=0

xi∈L

(cid:88)

φ(R)
lxi

−

x(cid:48)

i∈L(cid:48)

φ(R)
lx(cid:48)
i

(cid:13)
(cid:13)
(cid:13) ≤ M (|h(k)|+

1
4

|h(k)|2)

where |h(k)| is the number of hidden neurons in h(k).

D. The Correctness and Characteristics of the AdLM

The following theorem illustrates that the Alg. 1 preserves

(cid:15)-differential privacy, where (cid:15) = (cid:15)1 + (cid:15)2 + (cid:15)3.

Theorem 1: Algorithm 1 preserves (cid:15)-differential privacy,

where (cid:15) = (cid:15)1 + (cid:15)2 + (cid:15)3.

Proof: At a speciﬁc training step t ∈ T , it is crystal clear
that the computation of h0L is (cid:15)2-differentially private (Lemma
4). Therefore, the computation of the hidden layers h1, . . . , hk
and normalization layers h are differentially private. This is
because they do not access any additional information from
the data. At the output layer, the loss function F L(θt) is (cid:15)3-
differentially private (Lemma 6). The computation of gradients
(cid:79)θtF L(θt) and descents is an optimization process, without
1
|L|
using any additional information from the original data. Thus,
θt+1 is differentially private (line 29, Alg. 1).

This optimization process is repeated through T steps with-
out querying the original data D (lines 21-30). This is done
because Laplace noise is injected into input features xij and
coefﬁcients φ(R)
as preprocessing steps (lines 3-19). Note that
lxi
(R)
xij and φ
lxi are associated with features xi and the label yi
respectively. h0L and F L(θt) are computed based on xij and
(R)
φ
lxi . As a result, the noise and privacy budget consumption
will not be accumulated during the training process.

Finally, F L(θt) uses the outputs of h0L, which essentially
uses the differentially private relevances R(D) as of one
inputs. R(D), h0L, and F L(θt) are achieved by applying
(cid:15)1, (cid:15)2, and (cid:15)3-differential privacy mechanisms. Furthermore,
F L(θt) and h0L access the same training batch L at each
training step. Therefore, based on the composition theorem
[11], the total privacy budget in Alg. 1 must be the summation
of (cid:15)1, (cid:15)2, and (cid:15)3.

where (cid:15) = (cid:15)1 + (cid:15)2 + (cid:15)3.

Consequently, Algorithm 1 preserves (cid:15)-differential privacy,
(cid:4)
Note that ∆R and ∆h0 are dependent on the number of
input features d. ∆R is negatively proportional to the number
of tuples in D. The larger the size of D, the less noise will be
injected into the private relevance R. ∆F is only dependent
on the number of neurons in the last hidden layer and the
output layer. In addition, ∆R, ∆h0 , and ∆F do not depend on
the number of training epochs. Consequently:

(1) The privacy budget consumption in our model is totally

independent of the number of training epochs.

(2) In order to improve the model utility under differential
privacy, our mechanism adaptively injects Laplace noise into
features based on the contribution of each to the model output.
(3) The average error incurred by our approximation ap-
proach, (cid:98)FL(θ), is bounded by a small number M × e2+2e−1
e(1+e)2
(Please refer to Lemma 7 in Appendix F1).

(4) The proposed mechanism can be applied to a variety
of deep learning models, e.g., CNNs [30], deep auto-encoders

[13], Restricted Boltzmann Machines [31], convolution deep
belief networks [32], etc., as long as we can perturb the ﬁrst
afﬁne transformation layer.

With these characteristics, our mechanism has a great po-
tential to be applied in large datasets, without consuming
excessive privacy budgets. In the experiment section, we will
show that our mechanism leads to accurate results.

IV. EXPERIMENTAL RESULTS
We have carried out an extensive experiment on two well-
known image datasets, MNIST and CIFAR-10. The MNIST
database of handwritten digits consists of 60,000 training ex-
amples, and a test set of 10,000 examples [16]. Each example
is a 28 × 28 size gray-level image. The CIFAR-10 dataset
consists of color images categorized into 10 classes, such as
birds, dogs, trucks, airplanes, etc. The dataset is partitioned
into 50,000 training examples and 10,000 test examples [17].
Competitive Models. We compare our mechanism with
the state-of-the-art differentially private stochastic gradient
descent (pSGD) for deep learning proposed by [12]. CNNs
are used in our experiments for both algorithms. The hyper-
parameters in pSGD are set
to the default values recom-
mended by Abadi et al. [12]. To comprehensively examine
the proposed approaches, our mechanism is implemented in
two different settings: (1) The Adaptive Laplace Mechanism
(Alg. 1)-based CNN with ReLUs, simply denoted AdLM; and
(2) An Identical Laplace Mechanism-based CNN with ReLUs
(ILM), in which an identical Laplace noise 1
) is
injected into each feature xij to preserve (cid:15)2-differential privacy
in the computation of the afﬁne transformation layer h0. In
the ILM algorithm, we do not need to use the differentially
private relevances R(D). More details about the ILM are in
the Appendix C1. The implementation of our mechanism is
publicly available1.

|L| Lap( ∆h0

(cid:15)2

A. MNIST Dataset

The designs of the three models are the same on the
MNIST dataset. We used two convolution layers, one with
32 features and one with 64 features. Each hidden neuron
connects with a 5x5 unit patch. A fully-connected layer with
25 units and an output layer of 10 classes (i.e., 10 digits)
with cross-entropy loss with LRN are used. The batch size
is 1,800. This also is the structure of the pre-trained model,
which is learned and used to compute the average relevances
R(D). The experiments were conducted on a single GPU, i.e.,
NVIDIA GTX TITAN X, 12 GB with 3,072 CUDA cores.

Fig. 4a illustrates the prediction accuracy of each model as
a function of the privacy budget (cid:15) on the MNIST dataset. It
is clear that our models, i.e., AdLM and ILM, outperform the
pSGD, especially when the privacy budget (cid:15) is small. This is
a crucial result, since smaller privacy budget values enforce
stronger privacy guarantees. When the privacy budget (cid:15) is
large, e.g., (cid:15) = 2, 4, 8, which means small noise is injected
into the model, the efﬁciencies of all the models are almost
converged to higher prediction accuracies.

1https://github.com/haiphanNJIT/PrivateDeepLearning

The AdLM model achieves the best performance. Given a
very small privacy budget (cid:15) = 0.25, it achieves 90.2% in terms
of prediction accuracy, compared with 88.46% obtained by the
ILM and 82.09% obtained by the pSGD. Overall, given small
values of the privacy budget (cid:15), i.e., 0.2 ≤ (cid:15) ≤ 0.5, the AdLM
improves the prediction accuracy by 7.7% on average (i.e.,
91.62%) compared with the pSGD (i.e., 83.93%). The result
is statistically signiﬁcant with p < 0.01 (t-test).

Figs. 4b-c illustrate the prediction accuracy of each model
the number of epochs under (cid:15) = 0.5 and (cid:15) = 2.0
vs.
respectively. Given large noise, i.e., (cid:15) = 0.5, the pSGD quickly
achieves higher prediction accuracies (i.e., 88.59%) after a
small number of epochs, compared with other models (Fig.
4b). However, the pSDG can only be applied to train the model
by using a limited number of epochs; speciﬁcally because the
privacy budget is accumulated after every training step. Mean-
while, our mechanism is totally independent of the number
of epochs in the consumption of privacy budget. Therefore,
after 500 epochs, our models outperform the pSGD. The
AdLM achieves the best performance, in terms of prediction
accuracy: 93.66%, whereas the ILM and the pSGD reached
only 92.39% and 88.59%, respectively. Interestingly, given
small noise, i.e., (cid:15) = 2.0, our models achieve higher accuracies
than the pSGD after a small number of epochs (Fig. 4c). This
result illustrates the crucial beneﬁts of being independent of
the number of training epochs in preserving differential privacy
in deep learning. With our mechanism, we can keep training
our models without accumulating noise and privacy budget.

B. CIFAR-10 Dataset

The designs of the three models are the same on the
CIFAR-10 dataset. We used three convolution layers, two with
128 features and one with 256 features. Each hidden neuron
connects with a 3x3 unit patch in the ﬁrst layer, and a 5x5
unit patch in other layers. One fully-connected layer with 30
neurons, and an output layer of 10 classes with a cross-entropy
loss with LRN are used. The batch size is set to 7,200. This
also is the structure of the pre-trained model, which is learned
and used to compute the average relevances R(D).

Fig. 5a shows the prediction accuracies of each model as
a function of the privacy budget (cid:15) on the CIFAR-10 dataset.
Figs. 5b-c illustrate the prediction accuracy of each model vs.
the number of epochs under different noise levels. Similar to
the results on the MNIST dataset, the results on CIFAR-10
strengthen our observations: (1) Our mechanism outperforms
the pSGD in terms of prediction accuracy, given both modest
and large values of the privacy budget (cid:15) (Fig. 5a); and (2) Our
mechanism has the ability to work with large-scale datasets,
since it is totally independent of the number of training epochs
in the consumption of privacy budget (Figs. 5b-c).

In fact, the AdLM improves the prediction accuracy by
5.9% on average (i.e., to 77%) compared with the pSGD (i.e.,
71.1%). The result is statistically signiﬁcant with p < 0.01
(t-test). Given large noise, i.e., (cid:15) = 2.5, our models including
the AdLM and ILM outperform the pSGD after 800 epochs
(Fig. 5b).

(a) accuracy vs. (cid:15)

(b) (cid:15) = 0.5 (large noise)

(c) (cid:15) = 2.0 (small noise)

Fig. 4. Accuracy for different noise levels on the MNIST dataset.

(a) accuracy vs. (cid:15)

(b) (cid:15) = 2.5 (large noise)

(c) (cid:15) = 8.0 (small noise)

Fig. 5. Accuracy for different noise levels on the CIFAR-10 dataset.

C. Adaptive Laplace Noise

It is important to note that by adaptively redistributing the
noise into input features based on the relevance of each to
the model output, we can achieve much better prediction
accuracies in both MNIST and CIFAR-10 datasets given
both small and large values of privacy budget (cid:15). This is
clearly demonstrated in Figs. 4a and 5a, since the AdLM
outperforms the ILM in all cases. Overall, the AdLM improves
the prediction accuracy by 2% and 5% on average on MNIST
and CIFAR-10 datasets correspondingly, compared with the
ILM. The result is statistically signiﬁcant with p < 0.05 (t-
test). Note that the ILM injected an identical amount of noise
into all input features, regardless of their contributions to the
model output. This is an important result, since our mechanism
is the ﬁrst of its kind, which can redistribute the noise injected
into the deep learning model to improve the utility. In addition,
the reallocation of (cid:15)1, (cid:15)2, and (cid:15)3 could further improve the
utility. This is an open research direction in the future work.

D. Computational Efﬁciency

In terms of computation efﬁciency, there are two differences
in our mechanism, compared with a regular deep neural
network: (i) The pre-trained model; and (ii) The noise injection
task. In practice,
is not necessarily
the pre-trained model
identical to the differentially private network trained by our
AdLM. A simple model can be used as a pre-trained model to
approximate the average relevance R(D), as long as the pre-
trained model is effective in terms of prediction accuracy even
over a small training dataset. Achieving this is quite straight-
forward, because: (1) The pre-trained model is noiseless; and
(2) The number of training epochs used to learn a pre-trained
model is small compared with the one of differentially private

models. In fact, we only correspondingly need 12 and 50
extra epochs to learn the pre-trained models on MNIST and
CIFAR-10 datasets. Training pre-trained models takes about
10 minutes on a single GPU, i.e., NVIDIA GTX TITAN X,
12 GB with 3,072 CUDA cores. Therefore, the model pre-
training for the computation of R(D) is efﬁcient.

Another difference in our mechanism is the noise injection
into input attributes and coefﬁcients of the loss function (cid:98)F.
In this task, the computations of ∆R, ∆h0, ∆F , Rj, βj, x,
and φ are efﬁcient and straight-forward, since there is not
any operation such as arg min, arg max, sorting, etc. The
complexity of these computations is O(cid:0)|D|(d + M )(cid:1), which
is linear to the size of the database D. In addition, these
computations can be efﬁciently performed in either a serial
process or a parallel process. Therefore, this task does not
affect the computational efﬁciency of our mechanism much.

V. CONCLUSIONS

In this paper, we proposed a novel mechanism, called
Adaptive Laplace Mechanism (AdLM), to preserve differential
privacy in deep learning. Our mechanism conducts both sensi-
tivity analysis and noise insertion on deep neural networks. It
is totally independent of the number of training epochs in the
consumption of privacy budget. That makes our mechanism
more practical. In addition, our mechanism is the ﬁrst of its
kind to have the ability to redistribute the noise insertion
toward the improvement of model utility in deep learning.
In fact, our mechanism has the ability to intentionally add
more noise into input features which are less relevant to the
model output, and vice-versa. Different activation functions
can be applied in our mechanism, as well. These distinctive
characteristics guarantee the ability to apply our mechanism on

large datasets in different deep learning models and in different
contexts. Our mechanism can clearly enhance the application
of differential privacy in deep learning. Rigorous experimental
evaluations conducted on well-known datasets validated our
theoretical results and the effectiveness of our mechanism.

ACKNOWLEDGMENT

This work is supported by the NIH grant R01GM103309
to the SMASH project. Wu is also supported by NSF grant
DGE-1523115 and IIS-1502273.

REFERENCES

[1] J. Levinson, J. Askeland, J. Becker, J. Dolson, D. Held,
S. Kammel, J. Z. Kolter, D. Langer, O. Pink, V. Pratt,
M. Sokolsky, G. Stanek, D. Stavens, A. Teichman,
M. Werling, and S. Thrun, “Towards fully autonomous
driving: Systems and algorithms,” in 2011 IEEE Intelli-
gent Vehicles Symposium (IV), 2011, pp. 163–168.
[2] D. Lowd, “Good word attacks on statistical spam ﬁlters,”

in CEAS’05, 2005.

[3] Y. Cheng, F. Wang, P. Zhang, and J. Hu, “Risk pre-
diction with electronic health records: A deep learning
approach,” in SDM’16, 2016.

[4] E. Choi, A. Schuetz, W. F. Stewart, and J. Sun, “Using
recurrent neural network models for early detection of
heart failure onset,” JAMIA, 2016.

[5] C. Dwork, F. McSherry, K. Nissim, and A. Smith,
“Calibrating noise to sensitivity in private data analysis,”
Theory of Cryptography, pp. 265–284, 2006.

[6] K. Chaudhuri and C. Monteleoni, “Privacy-preserving
logistic regression,” in NIPS’08, 2008, pp. 289–296.
[7] F. McSherry and I. Mironov, “Differentially Private Rec-

ommender Systems,” in KDD’09. ACM, 2009.

[8] F. McSherry and K. Talwar, “Mechanism design via
differential privacy,” in FOCS ’07, 2007, pp. 94–103.
[9] R. Shokri and V. Shmatikov, “Privacy-preserving deep

[10] N. Phan, Y. Wang, X. Wu, and D. Dou, “Differential pri-
vacy preservation for deep auto-encoders: an application
of human behavior prediction,” in AAAI’16, 2016, pp.
1309–1316.

[11] C. Dwork and J. Lei, “Differential privacy and robust

statistics,” in STOC’09, 2009, pp. 371–380.

[12] M. Abadi, A. Chu, I. Goodfellow, H. B. McMahan,
I. Mironov, K. Talwar, and L. Zhang, “Deep learning
with differential privacy,” arXiv:1607.00133, 2016.
[13] Y. Bengio, “Learning deep architectures for ai,” Found.
Trends Mach. Learn., vol. 2, no. 1, pp. 1–127, 2009.
[14] N. Dowlin, R. Gilad-Bachrach, K. Laine, K. Lauter,
M. Naehrig, and J. Wernsing, “Cryptonets: Applying
neural networks to encrypted data with high throughput
and accuracy,” in ICML’16, 2016, pp. 201–210.

[15] S. Bach, A. Binder, G. Montavon, F. Klauschen, K.-
R. M¨uller, and W. Samek, “On pixel-wise explanations
for non-linear classiﬁer decisions by layer-wise relevance

propagation,” PLoS ONE, vol. 10, no. 7, p. e0130140, 07
2015.

[16] Y. Lecun, L. Bottou, Y. Bengio, and P. Haffner,
“Gradient-based learning applied to document recogni-
tion,” Proceedings of the IEEE, vol. 86, no. 11, pp. 2278–
2324, 1998.

[17] A. Krizhevsky and G. Hinton, “Learning multiple layers

of features from tiny images,” 2009.

[18] D. Kifer and A. Machanavajjhala, “No free lunch in data

privacy,” in SIGMOD’11, 2011, pp. 193–204.

[19] U. Erlingsson, V. Pihur, and A. Korolova, “Rappor:
Randomized aggregatable privacy-preserving ordinal re-
sponse,” in CCS’14, 2014, pp. 1054–1067.

[20] C. Liu, S. Chakraborty, and P. Mittal, “Dependence
Makes You Vulnerable: Differential Privacy Under De-
pendent Tuples,” in NDSS’16, Feb. 2016.

[21] Y. Cao, M. Yoshikawa, Y. Xiao, and L. Xiong, “Quan-
tifying differential privacy under temporal correlations,”
CoRR, vol. abs/1610.07543, 2016.

[22] T.-H. H. Chan, M. Li, E. Shi, and W. Xu, “Differen-
tially private continual monitoring of heavy hitters from
distributed streams,” in PETS’12, 2012, pp. 140–159.

[23] S. Song, K. Chaudhuri, and A. D. Sarwate, “Stochastic
gradient descent with differentially private updates,” in
GlobalSIP, 2013, pp. 245–248.

[24] P. Jain, P. Kothari, and A. Thakurta, “Differentially
private online learning,” in COLT’12, 2012, pp. 24.1–
24.34.

[25] X. Xiao, G. Wang, and J. Gehrke, “Differential privacy
via wavelet transforms,” in ICDE’10, 2010, pp. 225–236.
[26] Y. Wang, X. Wu, and L. Wu, “Differential privacy
preserving spectral graph analysis,” in PAKDD (2), 2013,
pp. 329–340.

[27] A. Krizhevsky, I. Sutskever, and G. E. Hinton, “Imagenet
classiﬁcation with deep convolutional neural networks,”
in NIPS’12, 2012, pp. 1097–1105.

[28] G. Arfken,

in Mathematical Methods for Physicists

[29] J. Zhang, Z. Zhang, X. Xiao, Y. Yang, and M. Winslett,
“Functional mechanism: regression analysis under differ-
ential privacy,” PVLDB, vol. 5, no. 11, pp. 1364–1375,
2012.

[30] Y. Lecun, L. Bottou, Y. Bengio, and P. Haffner,
“Gradient-based learning applied to document recogni-
tion,” Proceedings of the IEEE, vol. 86, no. 11, pp. 2278–
2324, 1998.

[31] P. Smolensky, “Information processing in dynamical sys-
tems: Foundations of harmony theory,” 1986, ch. Parallel
Distributed Processing: Explorations in the Microstruc-
ture of Cognition, Vol. 1, pp. 194–281.

[32] H. Lee, R. Grosse, R. Ranganath, and A. Y. Ng, “Convo-
lutional deep belief networks for scalable unsupervised
learning of hierarchical representations,” in ICML’09,
2009, pp. 609–616.

[33] T. Apostol, Calculus.

John Wiley & Sons, 1967.

learning.” in CCS’15, 2015, pp. 1310–1321.

(Third Edition). Academic Press, 1985.

APPENDIX

A. Proof of Lemma 1

we have that ∀xi ∈ D, j ∈ [1, d] : xij = xij + 1
For each h ∈ h0L, h can be re-written as:

|L| Lap( ∆h0

(cid:15)2

).

Proof 1: Assume that D and D(cid:48) differ in the last tuple. Let

xn (x(cid:48)

n) be the last tuple in D (D(cid:48)). We have that

hL(W ) =

d
(cid:88)

(cid:104) (cid:88)

j=1

xi∈L

(cid:0)xij +

1
|L|

Lap(

)(cid:1)W T (cid:105)

∆h0
(cid:15)2

1
|L|

(cid:88)

(cid:0)b +

+

xi∈L

Lap(

∆h0
(cid:15)2

)(cid:1)

(27)

Rx(cid:48)

ij

(cid:13)
(x(cid:48)
(cid:13)
i)
(cid:13)1

(cid:88)

x(cid:48)

i∈D(cid:48)

∆R =

Rxij (xi) −

1
|D|

1
|D|

2
|D|

=

≤

d
(cid:88)

(cid:13)
(cid:13)
(cid:13)

(cid:88)

j=1

xi∈D

d
(cid:88)

j=1

max
xi∈D

d
(cid:88)

j=1

(cid:13)
(cid:13)
(cid:13)Rxnj (xn) − Rx(cid:48)

nj

(x(cid:48)

(cid:13)
(cid:13)
n)
(cid:13)1

(cid:107)Rxij (xi)(cid:107)1 ≤

2d
|D|

Eq. 13 holds.

B. Proof of Lemma 2

Proof 2: Let D and D(cid:48) be two neighbor databases. Without
loss of generality, assume that D and D(cid:48) differ in the last tuple
xn (x(cid:48)
n). Rj(D) is calculated as done in line 6, Alg. 1, and
R(D) = (cid:8)Rj(D)(cid:9)
j∈[1,d] is the output of the Alg. 1 (line 7).
The perturbation of the relevance Rj(D) can be rewritten as:

Rj =

Rxij (xi) + Lap(

(26)

∆R
(cid:15)1

)

1
|D|

(cid:88)

xi∈D

Since all the input features are perturbed, we have that

P r(cid:0)R(D)(cid:1)
P r(cid:0)R(D(cid:48))(cid:1) =

≤

exp(

j=1 exp (cid:0) (cid:15)1(cid:107) 1
(cid:81)d
j=1 exp (cid:0) (cid:15)1(cid:107) 1
(cid:81)d
(cid:13)
(cid:88)
(cid:13)
(cid:13)

xi∈D

(cid:15)1
|D|∆R

Rj(xi) −

(cid:80)

|D|

xi∈D Rj (xi)−Rj (cid:107)1

(cid:1)

|D|

(cid:80)

x(cid:48)
i

∆R
∈D Rj (x(cid:48)
∆R

i)−Rj (cid:107)1

(cid:1)

(cid:13)
Rj(x(cid:48)
(cid:13)
i)
(cid:13)1

)

(cid:88)

x(cid:48)

i∈D(cid:48)

d
(cid:89)

j=1

d
(cid:89)

j=1

d
(cid:89)

j=1

≤

exp(

(cid:15)1
|D|∆R

(cid:13)
(cid:13)
(cid:13)Rj(xn) − Rj(x(cid:48)
(cid:13)
(cid:13)
n)
(cid:13)1

)

≤

exp(

(cid:15)1
|D|∆R

2 max
xn∈D

(cid:13)
(cid:13)Rj(xn)(cid:13)

(cid:13)1)

2 maxxn∈L

j=1(cid:107)Rj(xn)(cid:107)1

(cid:80)d

)

|D|∆R

≤ exp((cid:15)1

≤ exp((cid:15)1)

Let us consider the static bias b = 1 as the 0-th input feature
and its associated parameter Wb, i.e., xi0 = b = 1 and W =
Wb ∪ W , we have that

hL(W ) =

d
(cid:88)

(cid:104) (cid:88)

j=0

xi∈L

(cid:0)xij +

1
|L|

Lap(

)(cid:1)W T (cid:105)

∆h0
(cid:15)2

(28)

d
(cid:88)

(cid:104) (cid:88)

=

j=0

xi∈L

xij + Lap(

(cid:105)
W T =

)

∆h0
(cid:15)2

d
(cid:88)

j=0

h
j W T

φ

(29)

h

where φ

j = (cid:2) (cid:80)
We can see that φ

xi∈L xij + Lap( ∆h0

(cid:15)2

)(cid:3).

h
j is the perturbation of the input feature
xij associated with the j-th parameter Wj ∈ W of the hidden
neuron h on L. Since all the hidden neurons h in h0 are
perturbed, we have that:

P r(cid:0)h0L(W0)(cid:1) =

(cid:89)

d
(cid:89)

exp(cid:0) (cid:15)2(cid:107)(cid:80)

xi∈L xij − φ

h
j (cid:107)

(cid:1)

h∈h0

j=0

∆h0

∆h0 is set to 2 (cid:80)
h∈h0
the output, we have that

d and h0L(W0) = {hL(W )}h∈h0 is

P r(cid:0)h0L(W0)(cid:1)
P r(cid:0)h0L(cid:48)(W0)(cid:1) =

(cid:81)

h∈h0

(cid:81)

h∈h0

j=0 exp (cid:0) (cid:15)2(cid:107)(cid:80)
(cid:81)d
j=0 exp (cid:0) (cid:15)2(cid:107)(cid:80)

(cid:81)d

xi∈L xij −φh
∆h0
∈L(cid:48) x(cid:48)
∆h0

ij −φh

x(cid:48)
i

j (cid:107)1

(cid:1)

j (cid:107)1

(cid:1)

exp(

(cid:15)2
∆h0

(cid:13)
(cid:13)
(cid:13)

(cid:88)

xi∈L

xij −

x(cid:48)

ij

(cid:13)
(cid:13)
(cid:13)1

)

(cid:88)

x(cid:48)

i∈L(cid:48)

(cid:13)
(cid:13)xnj − x(cid:48)
(cid:13)

nj

(cid:13)
(cid:13)
(cid:13)1

)

≤

≤

≤

(cid:89)

d
(cid:89)

h∈h0

j=0

(cid:89)

d
(cid:89)

h∈h0

j=1

(cid:89)

d
(cid:89)

h∈h0

j=1

exp(

exp(

(cid:15)2
∆h0

(cid:15)2
∆h0

d

2 (cid:80)

h∈h0
∆h0

≤ exp((cid:15)2

) = exp((cid:15)2)

2 max
xn∈L

(cid:13)
(cid:13)xnj

(cid:13)
(cid:13)1) ≤

(cid:89)

d
(cid:89)

h∈h0

j=1

exp(

2(cid:15)2
∆h0

)

Consequently,
differential privacy in Alg. 1.

the computation of R(D) preserves

(cid:15)1-

C. Identical Laplace Mechanism (ILM)

We can add an identical noise distribution 1

|L| Lap( ∆h0
) to
all input features, where ∆h0 = 2 (cid:80)
d (line 9, Alg. 1) to
preserve differential privacy in the computation of h0. In fact,

h∈h0

(cid:15)2

Consequently, based on the above analysis, the computation
of h0L(W0) preserves (cid:15)2-differential privacy in Alg. 1 by
injecting an identical Laplace noise 1
) into all input
features. In addition, given the identical Laplace noise, we
do not need to use the differentially private relevance R(D),
since we do not need to redistribute the noise in the ﬁrst afﬁne
transformation layer h0.

|L| Lap( ∆h0

(cid:15)2

D. Proof of Lemma 5

have that

Proof 5: Assume that L and L(cid:48) differ in the last tuple. Let

xn (x(cid:48)

n) be the last tuple in L (L(cid:48)). We have that

∆F =

M
(cid:88)

2
(cid:88)

(cid:88)

(cid:13)
(cid:13)
(cid:13)

l=1

R=0

xi∈L

φ(R)
lxi

−

φ(R)
lx(cid:48)
i

(cid:13)
(cid:13)
(cid:13)

(cid:88)

x(cid:48)

i∈L(cid:48)

M
(cid:88)

2
(cid:88)

=

l=1

R=0

(cid:13)
(cid:13)φ(R)
lxn

− φ(R)
lx(cid:48)
n

(cid:13)
(cid:13)

(30)

= (cid:80)2

We can show that φ(0)
lxn
ynl) log 2 = log 2. Similarly, we can show that φ(0)
lx(cid:48)
n
As a result, φ(0)
lxn

ql (0) = ynl log 2 + (1 −
= log 2.

q=1 f (0)

. Therefore

= φ(0)
lx(cid:48)
n

∆F =

(cid:13)
(cid:13)φ(R)
lxn

− φ(R)
lx(cid:48)
n

(cid:13)
(cid:13) =

(cid:13)
(cid:13)φ(R)
lxn

− φ(R)
lx(cid:48)
n

(cid:13)
(cid:13)

M
(cid:88)

2
(cid:88)

l=1

R=1

(cid:0)(cid:13)
(cid:13)φ(R)
lxn

(cid:13) + (cid:13)
(cid:13)

(cid:13)φ(R)
lx(cid:48)
n

(cid:13)
(cid:1) ≤ 2 max
(cid:13)
xn

M
(cid:88)

2
(cid:88)

l=1

R=1

(cid:107)φ(R)
lxn

(cid:107)

M
(cid:88)

2
(cid:88)

l=1
M
(cid:88)

R=0
2
(cid:88)

l=1

R=1

≤

≤ 2 max
xn

(cid:104) M
(cid:88)
(

l=1

1
2

|h(k)|
(cid:88)

− ynl)

hexn(k)

e=1
M
(cid:88)

(cid:0) 1
8

+

l=1

e,g

(cid:88)

hexn(k)hgxn(k)

(cid:1)(cid:105)

≤ 2(

M × |h(k)| +

M × |h(k)|2)

1
2

1
8
|h(k)|2)

1
4

= M (|h(k)| +

E. Proof of Lemma 6

Proof 6: Let L and L(cid:48) be two neighbor batches. Without
loss of generality, assume that L and L(cid:48) differ in the last
tuple xn (x(cid:48)
n). ∆F is calculated as done in line 17, Alg. 1,
and F L(θt) = (cid:80)M
is the
output of line 27 of the Alg. 1. Note that hxi(k) is the state
of h(k) derived from h0xi by navigating through the neural
network. The perturbation of the coefﬁcient φ(R)
, denoted as
(R)
φ
l

, can be rewritten as:

(cid:0)hxi(k)W T

R=0 φ

(R)
lxi

(cid:80)2

xi∈L

(cid:1)R

(cid:80)

l(k)

l=1

l

(R)
l =

φ

(cid:104) (cid:88)

φ(R)
lxi

+ Lap(

(cid:105)
)

∆F
(cid:15)3

xi∈L

−φ(R)
l

(cid:107)1

(cid:1)

−φ(R)
l

(cid:107)1

(cid:1)

x(cid:48)
i

xi∈L φ(R)
lxi
∆F
∈L(cid:48) φ(R)
lxi
∆F
(cid:13)
(cid:13)
(cid:13)1

φ(R)
lx(cid:48)
i

)

P r(cid:0)F L(θt)(cid:1)
P r(cid:0)F L(cid:48)(θt)(cid:1) =

(cid:81)M

l=1

(cid:81)M

l=1

R=0 exp (cid:0) (cid:15)3(cid:107)(cid:80)
(cid:81)2
R=0 exp (cid:0) (cid:15)3(cid:107)(cid:80)

(cid:81)2

exp(

(cid:15)3
∆F

(cid:13)
(cid:13)
(cid:13)

(cid:88)

xi∈L

φ(R)
lxi

−

(cid:88)

x(cid:48)

i∈L(cid:48)

exp(

exp(

(cid:15)3
∆F

(cid:15)3
∆F

(cid:13)
(cid:13)φ(R)
(cid:13)

lxn

− φ(R)
lx(cid:48)
n

(cid:13)
(cid:13)
(cid:13)1

)

2 max
xn∈L

(cid:13)
(cid:13)φ(R)
lxn

(cid:13)
(cid:13)1)

≤

≤

≤

M
(cid:89)

2
(cid:89)

l=1

R=0

M
(cid:89)

2
(cid:89)

l=1
M
(cid:89)

R=0
2
(cid:89)

l=1

R=0

≤ exp((cid:15)3

2 maxxn∈L

(cid:80)2

R=0(cid:107)φ(R)
lxn

(cid:107)1

)

(cid:80)M

l=1
∆F
4 |h(k)|2)

) = exp((cid:15)3)

≤ exp((cid:15)3

M (|h(k)| + 1
∆F

Consequently,
differential privacy in Alg. 1.

the computation of F L(θt) preserves (cid:15)3-

F. Approximation Error Bounds

The following lemma illustrates the result of how much
error our approximation approach, (cid:98)FL(θ) (Eq. 25), incurs. The
error only depends on the number of possible classiﬁcation
outcomes M . In addition, the average error of the approxima-
tions is always bounded. As in [10, 29], the approximation of
the loss function FL(θ) by applying Taylor Expansion without
removing all polynomial terms with order larger than 2 is as
follows:

M
(cid:88)

(cid:88)

2
(cid:88)

∞
(cid:88)

l=1

xi∈L

q=1

R=0

f (R)
ql (zql)
R!

(cid:0)gql(hxi(k), Wl(k))−zql

(cid:1)R

∀l ∈ {1, . . . , M }, let f1l, f2l, g1l, and g2l be four functions
deﬁned as follows:

g1l(hxi(k), Wj) = hxi(k)W T
g2l(hxi(k), Wj) = hxi(k)W T

l(k)

l(k)

f1l(z1l) = yil log(1 + e−z1l )
f2l(z2l) = (1 − yil) log(1 + ez2l )

(32)

(33)

(34)

(35)

where ∀q, l : zql is a real number.
∀q, l, by setting zql = 0,

simpliﬁed as:

the above equation can be

(31)

(cid:101)FL(θ) =

M
(cid:88)

(cid:88)

2
(cid:88)

∞
(cid:88)

l=1

xi∈L

q=1

R=0

f (R)
ql (0)
R!

(cid:0)hxi(k)W T

l(k)

(cid:1)R

(36)

where hexn(k) is the state of e-th hidden neuron in h(k).

(cid:101)FL(θ) =

We can see that φ

is the perturbation of the coefﬁcient
associated with the labels yil in the training batch L. We

φ(R)
l

(R)
l

As in [10], our approximation approach works by truncating
the Taylor series in Eq. 36 to remove all polynomial terms with

order larger than 2. This leads to a new objective function in
Eq. 25 with low-order polynomials as follows:

(cid:98)FL(θ) =

l=1

xi∈L
(cid:104) 2
(cid:88)

M
(cid:88)

(cid:88)

=

l=1

xi∈L

q=1

M
(cid:88)

(cid:88)

2
(cid:88)

2
(cid:88)

q=1

R=0

f (R)
ql (0)
R!

(cid:0)hxi(k)W T

l(k)

(cid:1)R

ql (0) + (cid:0)
f (0)

ql (0)(cid:1)hxi(k)W T
f (1)

l(k)

2
(cid:88)

q=1

+ (cid:0)

2
(cid:88)

q=1

f (2)
ql (0)
2!

(cid:1)(hxi(k)W T

l(k))2(cid:105)

We are now ready to state the following lemma to show the

approximation error bound of our approach.

Lemma 7: Given two polynomial functions (cid:101)FL(θ) (Eq. 36)
and (cid:98)FL(θ) (Eq. 25), the average error of the approximation is
always bounded as follows:

| (cid:101)FL((cid:98)θ) − (cid:101)FL((cid:101)θ)| ≤ M ×

(37)

e2 + 2e − 1
e(1 + e)2

where (cid:101)θ = arg minθ (cid:101)FL(θ) and (cid:98)θ = arg minθ (cid:98)FL(θ).

(cid:0)

(cid:101)FL(θ)− (cid:98)FL(θ)(cid:1) and S = minθ

Proof 7: Let (cid:101)θ = arg minθ (cid:101)FL(θ) and (cid:98)θ = arg minθ (cid:98)FL(θ),
(cid:101)FL(θ)− (cid:98)FL(θ)(cid:1).
U = maxθ
We have that U ≥ (cid:101)FL((cid:98)θ) − (cid:98)FL((cid:98)θ) and ∀θ∗ : S ≤ (cid:101)FL(θ∗) −
(cid:98)FL(θ∗). Therefore, we have

(cid:0)

(cid:101)FL((cid:98)θ) − (cid:98)FL((cid:98)θ) − (cid:101)FL(θ∗) + (cid:98)FL(θ∗) ≤ U − S
⇔ (cid:101)FL((cid:98)θ) − (cid:101)FL(θ∗) ≤ U − S + (cid:0)

(cid:98)FL((cid:98)θ) − (cid:98)FL(θ∗)(cid:1)

In addition, (cid:98)FL((cid:98)θ) − (cid:98)FL(θ∗) ≤ 0, so (cid:101)FL((cid:98)θ) − (cid:101)FL(θ∗) ≤

U − S. If U ≥ 0 and S ≤ 0 then we have:

| (cid:101)FL((cid:98)θ) − (cid:101)FL(θ∗)| ≤ U − S

(38)

Eq. 38 holds for every θ∗. Therefore, it still holds for (cid:101)θ. Eq.
38 shows that the error incurred by truncating the Taylor series
approximate function depends on the maximum and minimum
values of (cid:101)FL(θ) − (cid:98)FL(θ). To quantify the magnitude of the
error, we ﬁrst rewrite (cid:101)FL(θ) − (cid:98)FL(θ) as:

M
(cid:88)

(cid:104)

l=1
∞
(cid:88)

(cid:101)FL(θ) − (cid:98)FL(θ) =

(cid:101)FL(Wl(k)) − (cid:98)FL(Wl(k))

(cid:105)

M
(cid:88)

(cid:104) (cid:88)

2
(cid:88)

=

l=1

xi∈L

q=1

R=3

f (R)
ql (zql)
R!

(cid:0)gql(hxi(k), Wl(k)) − zql

(cid:1)R(cid:105)

To derive the minimum and maximum values of the function
above, we look into the remainder of the Taylor Expansion for
each l. Let zl ∈ [zql −1, zql +1]. According to the well-known
(cid:101)FL(Wl(k)) − (cid:98)FL(Wl(k))(cid:1) must be in the in-
result [33],
(cid:104) (cid:80)
q

1
|D|
minzl f (3)

ql (zl)(zl−zql)3

ql (zl)(zl−zql)3

maxzl f (3)

, (cid:80)
l

terval

(cid:105)
.

(cid:0)

6

6

maxzl f (3)

If (cid:80)
q
6
minzl f (3)
ql (zl)(zl−zql)3

ql (zl)(zl−zql)3

(cid:80)
q

6

≤ 0, then we have that:

≥

0

and

(cid:101)FL(θ) − (cid:98)FL(θ)

(cid:105)(cid:12)
(cid:12)
(cid:12)

(cid:104)

(cid:12)
(cid:12)
(cid:12)

1
|L|
M
(cid:88)

≤

l=1

q

maxzl f (3)

ql (zl)(zl − zql)3 − minzl f (3)

ql (zl)(zl − zql)3

(cid:88)

6

(39)

This analysis applies to the case of the cross-entropy
error-based loss function as follows. First, for the functions
f1l(z1l) = yil log(1 + e−z1l ) and f2l(z2l) = (1 − yil) log(1 +
ez2l ), we have

f (3)
1l (z1l) =

2yilez1l
(1 + ez1l)3

f (3)
2l (z2l) = (1 − yil)

e−z2l (e−z2l − 1)
(1 + e−z2l )3

It can be veriﬁed that arg minz1l f (3)
1l (z1l) = 2e

1l (z1l) = −2e
(1+e)3 > 0, arg minz2l f (3)
arg maxz1l f (3)
e(1+e)3 < 0, and arg maxz2l f (3)
2l (z2l) = e(e−1)
the average error of the approximation is at most

(1+e)3 < 0,
2l (z2l) =
(1+e)3 > 0. Thus,

1−e

(cid:12) (cid:101)FL((cid:98)θ) − (cid:101)FL((cid:101)θ)(cid:12)
(cid:12)

(cid:12) ≤ M ×

+ (cid:0) e(e − 1)

(1 + e)3 −
Therefore, Eq. 37 holds.

G. Corrections of the Paper

−2e
(1 + e)3

(cid:1)

(cid:104)(cid:0)

2e
(1 + e)3 −
(cid:1)(cid:105)

1 − e
e(1 + e)3

= M ×

e2 + 2e − 1
e(1 + e)2

The differences between this correction and the ﬁrst sub-

mission of our paper can be summarized as follows:

1. There was a mistake in terms of model conﬁgurations
reported in our original version. The number of layers,
hidden neurons, unit patches, and batch sizes are updated
in this correction version. The experimental results of
our algorithms and the differentially private Stochastic
Gradient Descent algorithm (pSGD) [12] are updated as
well. In fact, the code release of the pSGD algorithm2 is
used in this version. The pSGD algorithm is signiﬁcantly
improved in terms of accuracy, and the computation of
the privacy budget (cid:15) is also more accurate.
2. We replace the equations of coefﬁcients {φ(0)
lxi

, φ(1)
,
lxi
φ(2)
}, i.e., after the Eq. 25, with a more detailed ex-
lxi
planation, since it may cause some misunderstanding
to the readers in terms of identifying coefﬁcients of
the Taylor Expansion in Eq. 25. To be clear, we de-
note {φ(0)
, φ(1)
=
lxi
lxi
(cid:80)2
ql (0) and φ(1)
q=1 f (0)
and φ(2)
are coefﬁcients at the
lxi
lxi
ﬁrst order and the second order of the function (cid:98)FL(θ).
and φ(2)
φ(1)
are combinations between the approxima-
lxi
lxi
f (2)
ql (0)
tion terms (cid:80)2
q=1 f (1)
2!

} as the coefﬁcients, where φ(0)
lxi

ql (0), (cid:80)2

, and hxi(k).

, φ(2)
lxi

q=1

2https://github.com/tensorﬂow/models/tree/master/research/differential privacy

