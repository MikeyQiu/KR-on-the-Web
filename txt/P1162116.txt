8
1
0
2
 
v
o
N
 
1
2
 
 
]

G
L
.
s
c
[
 
 
2
v
4
9
7
1
0
.
6
0
8
1
:
v
i
X
r
a

Sequential Attend, Infer, Repeat: Generative
Modelling of Moving Objects

Adam R. Kosiorek∗ § †

Hyunjik Kim†

Ingmar Posner§

Yee Whye Teh†

§ Applied Artiﬁcial Intelligence Lab
Oxford Robotics Institute
University of Oxford

† Department of Statistics
University of Oxford

Abstract

We present Sequential Attend, Infer, Repeat (SQAIR), an interpretable deep genera-
tive model for videos of moving objects. It can reliably discover and track objects
throughout the sequence of frames, and can also generate future frames condition-
ing on the current frame, thereby simulating expected motion of objects. This is
achieved by explicitly encoding object presence, locations and appearances in the
latent variables of the model. SQAIR retains all strengths of its predecessor, Attend,
Infer, Repeat (AIR, Eslami et al., 2016), including learning in an unsupervised
manner, and addresses its shortcomings. We use a moving multi-MNIST dataset to
show limitations of AIR in detecting overlapping or partially occluded objects, and
show how SQAIR overcomes them by leveraging temporal consistency of objects.
Finally, we also apply SQAIR to real-world pedestrian CCTV data, where it learns
to reliably detect, track and generate walking pedestrians with no supervision.

1

Introduction

The ability to identify objects in their environments and to understand relations between them is a
cornerstone of human intelligence (Kemp and Tenenbaum, 2008). Arguably, in doing so we rely on
a notion of spatial and temporal consistency which gives rise to an expectation that objects do not
appear out of thin air, nor do they spontaneously vanish, and that they can be described by properties
such as location, appearance and some dynamic behaviour that explains their evolution over time.
We argue that this notion of consistency can be seen as an inductive bias that improves the efﬁciency
of our learning. Equally, we posit that introducing such a bias towards spatio-temporal consistency
into our models should greatly reduce the amount of supervision required for learning.

One way of achieving such inductive biases is through model structure. While recent successes in deep
learning demonstrate that progress is possible without explicitly imbuing models with interpretable
structure (LeCun, Bengio, et al., 2015), recent works show that introducing such structure into deep
models can indeed lead to favourable inductive biases improving performance e.g. in convolutional
networks (LeCun, Boser, et al., 1989) or in tasks requiring relational reasoning (Santoro et al.,
2017). Structure can also make neural networks useful in new contexts by signiﬁcantly improving
generalization, data efﬁciency (Jacobsen et al., 2016) or extending their capabilities to unstructured
inputs (Graves et al., 2016).

Attend, Infer, Repeat (AIR), introduced by Eslami et al., 2016, is a notable example of such a structured
probabilistic model that relies on deep learning and admits efﬁcient amortized inference. Trained
without any supervision, AIR is able to decompose a visual scene into its constituent components and
to generate a (learned) number of latent variables that explicitly encode the location and appearance
of each object. While this approach is inspiring, its focus on modelling individual (and thereby
inherently static) scenes leads to a number of limitations. For example, it often merges two objects
that are close together into one since no temporal context is available to distinguish between them.

∗Corresponding author: adamk@robots.ox.ac.uk

32nd Conference on Neural Information Processing Systems (NIPS 2018), Montréal, Canada.

Similarly, we demonstrate that AIR struggles to identify partially occluded objects, e.g. when they
extend beyond the boundaries of the scene frame (see Figure 7 in Section 4.1).

Our contribution is to mitigate the shortcomings of AIR by introducing a sequential version that
models sequences of frames, enabling it to discover and track objects over time as well as to
generate convincing extrapolations of frames into the future. We achieve this by leveraging temporal
information to learn a richer, more capable generative model. Speciﬁcally, we extend AIR into a
spatio-temporal state-space model and train it on unlabelled image sequences of dynamic objects.
We show that the resulting model, which we name Sequential AIR (SQAIR), retains the strengths of
the original AIR formulation while outperforming it on moving MNIST digits.

The rest of this work is organised as follows. In Section 2, we describe the generative model and
inference of AIR. In Section 3, we discuss its limitations and how it can be improved, thereby
introducing Sequential Attend, Infer, Repeat (SQAIR), our extension of AIR to image sequences. In
Section 4, we demonstrate the model on a dataset of multiple moving MNIST digits (Section 4.1)
and compare it against AIR trained on each frame and Variational Recurrent Neural Network (VRNN)
of Chung et al., 2015 with convolutional architectures, and show the superior performance of SQAIR
in terms of log marginal likelihood and interpretability of latent variables. We also investigate the
utility of inferred latent variables of SQAIR in downstream tasks. In Section 4.2 we apply SQAIR on
real-world pedestrian CCTV data, where SQAIR learns to reliably detect, track and generate walking
pedestrians without any supervision. Code for the implementation on the MNIST dataset2 and the
results video3 are available online.

2 Attend, Infer, Repeat (AIR)

AIR, introduced by Eslami et al., 2016, is a structured variational auto-encoder (VAE) capable of
decomposing a static scene x into its constituent objects, where each object is represented as a
i=1, n ∈ N being the
separate triplet of continuous latent variables z = {zwhat,i, zwhere,i, zpres,i}n
(random) number of objects in the scene. Each triplet of latent variables explicitly encodes position,
appearance and presence of the respective object, and the model is able to infer the number of objects
present in the scene. Hence it is able to count, locate and describe objects in the scene, all learnt in an
unsupervised manner, made possible by the inductive bias introduced by the model structure.

Generative Model The generative model of AIR is deﬁned as follows

pθ(n) = Geom(n | θ),

pθ(zw | n) =

(cid:0)zw,i(cid:1) =

pθ

N (cid:0)zw,i|0, I(cid:1),

n
(cid:89)

i=1

pθ(x | z) = N (cid:0)x | yt, σ2

xI(cid:1),

with yt =

hdec
θ

(zwhat,i, zwhere,i),

(1)

n
(cid:89)

i=1
n
(cid:88)

i=1

where zw,i ..= (zwhat,i, zwhere,i), zpres,i = 1 for i = 1 . . . n and hdec
is the object decoder with
parameters θ. It is composed of a glimpse decoder f dec
t, which constructs an image patch
and a spatial transformer (ST, Jaderberg et al., 2015), which scales and shifts it according to zwhere;
see Figure 1 for details.

t (cid:55)→ yi

: gi

θ

θ

Inference Eslami et al., 2016 use a sequential inference algorithm, where latent variables are inferred
one at a time; see Figure 2. The number of inference steps n is given by zpres,1:n+1, a random vector
of n ones followed by a zero. The zi are sampled sequentially from

qφ(z | x) = qφ

(cid:0)zpres,n+1 = 0 | zw,1:n, x(cid:1)

(cid:0)zw,i, zpres,i = 1 | z1:i−1, x(cid:1),

qφ

(2)

n
(cid:89)

i=1

where qφ is implemented as a neural network with parameters φ. To implement explain-
it is vital to capture the depen-
ing away, e.g. to avoid encoding the same object twice,
dency of zw,i and zpres,i on z1:i−1 and x. This is done using a recurrent neural network
(RNN) Rφ with hidden state hi, namely: ωi, hi = Rφ(x, zi−1, hi−1). The outputs ωi,
which are computed iteratively and depend on the previous latent variables (cf. Algorithm 3),
(cid:0)zw,i, zpres,i | z1:i−1, x(cid:1). For simplicity the latter is assumed to factorise such that
parametrise qφ
qφ

(cid:0)zw, zpres | z1:i−1, x(cid:1) = qφ

(cid:0)zpres,n+1 = 0 | ωn+1(cid:1) (cid:81)n

(cid:0)zpres,i = 1 | ωi(cid:1).

(cid:0)zw,i | ωi(cid:1)qφ

i=1 qφ

2code: github.com/akosiorek/sqair
3video: youtu.be/-IUNQgSLE0c

2

Figure 1: Left: Generation in AIR. The image mean yt is generated by ﬁrst using the glimpse decoder f dec
to
map the what variables into glimpses gt, transforming them with the spatial transformer ST according to the
where variables and summing up the results. Right: Generation in SQAIR. When new objects enter the frame,
new latent variables (here, z4
t ) are sampled from the discovery prior. The temporal evolution of already present
objects is governed by the propagation prior, which can choose to forget some variables (here, z3
t+1)
when the object moves out of the frame. The image generation process, which mimics the left-hand side of the
ﬁgure, is abstracted in the decoder block.

t and z4

θ

Figure 2: Left: Inference in AIR. The pink RNN attends to the image sequentially and produces one latent variable
t at a time. Here, it decides that two latent variables are enough to explain the image and z3
zi
t is not generated.
Right: Inference in SQAIR starts with the Propagation (PROP) phase. PROP iterates over latent variables from
the previous time-step t − 1 and updates them based on the new observation xt. The blue RNN runs forward in
time to update the hidden state of each object, to model its change in appearance and location throughout time.
The orange RNN runs across all current objects and models the relations between different objects. Here, when
attending to z1
t−1, it decides that the corresponding object has disappeared from the frame and forgets it. Next,
the Discovery (DISC) phase detects new objects as in AIR, but in SQAIR it is also conditioned on the results of
PROP, to prevent rediscovering objects. See Figure 3 for details of the colored RNNS.

3 Sequential Attend-Infer-Repeat

While capable of decomposing a scene into objects, AIR only describes single images. Should we
want a similar decomposition of an image sequence, it would be desirable to do so in a temporally
consistent manner. For example, we might want to detect objects of the scene as well as infer
dynamics and track identities of any persistent objects. Thus, we introduce Sequential Attend, Infer,
Repeat (SQAIR), whereby AIR is augmented with a state-space model (SSM) to achieve temporal
consistency in the generated images of the sequence. The resulting probabilistic model is composed
of two parts: Discovery (DISC), which is responsible for detecting (or introducing, in the case of the
generation) new objects at every time-step (essentially equivalent to AIR), and Propagation (PROP),
responsible for updating (or forgetting) latent variables from the previous time-step given the new
observation (image), effectively implementing the temporal SSM. We now formally introduce SQAIR
by ﬁrst describing its generative model and then the inference network.

Generative Model The model assumes that at every-time step, objects are ﬁrst propagated from the
previous time-step (PROP). Then, new objects are introduced (DISC). Let t ∈ N be the current time-
step. Let Pt be the set of objects propagated from the previous time-step and let Dt be the set of objects
discovered at the current time-step, and let Ot = Pt ∪Dt be the set of all objects present at time-step t.
Consequently, at every time step, the model retains a set of latent variables zPt
t}i∈Pt , and

t = {zi

3

generates a set of new latent variables zDt
the representation of the ith object zi
t
(as in AIR): zwhat,i
and zwhere,i
t
of the object, respectively. zpres,i
given time-step or not.

t

t

t = {zi
..= [zwhat,i
t

t}i∈Dt. Together they form zt
, zwhere,i

..= [zPt
], where
t
] is composed of three components
are real vector-valued variables representing appearance and location
is a binary variable representing whether the object is present at the

, zpres,i
t

, zDt
t

t

t

t

, zwhere,i

from pD(cid:0)zi

At the ﬁrst time-step (t = 1) there are no objects to propagate, so we sample D1, the number of
objects at t = 1, from the discovery prior pD(D1). Then for each object i ∈ Dt, we sample latent
(cid:1). At time t = 2, the propagation step models which
variables zwhat,i
objects from t = 1 are propagated to t = 2, and which objects disappear from the frame, using the
binary random variable (zpres,i
)i∈Pt. The discovery step at t = 2 models new objects that enter
the frame, with a similar procedure to t = 1: sample D2 (which depends on zP2
2 ) then sample
(zwhat,i
)i∈D2 . This procedure of propagation and discovery recurs for t = 2, . . . T . Once
2
the zt have been formed, we may generate images xt using the exact same generative distribution
pθ(xt | zt) as in AIR (cf. Equation (1), Fig. 1, and Algorithm 1). In full, the generative model is:

, zwhere,i
2

1 | D1

t

p(x1:T , z1:T , D1:T ) = pD(D1, zD1
1 )

pD(Dt, zDt
t

|zPt

t )pP (zPt
t

|zt−1)pθ(xt|zt),

(3)

T
(cid:89)

t=2

|zPt
The discovery prior pD(Dt, zDt
t ) samples latent variables for new objects that enter the frame.
t
The propagation prior pP (zPt
|zt−1) samples latent variables for objects that persist in the frame
t
and removes latents of objects that disappear from the frame, thereby modelling dynamics and
appearance changes. Both priors are learned during training. The exact forms of the priors are given
in Appendix B.

Inference Similarly to AIR, inference in SQAIR can capture the number of objects and the representa-
tion describing the location and appearance of each object that is necessary to explain every image in
a sequence. As with generation, inference is divided into PROP and DISC. During PROP, the inference
network achieves two tasks. Firstly, the latent variables from the previous time step are used to infer
the current ones, modelling the change in location and appearance of the corresponding objects,
thereby attaining temporal consistency. This is implemented by the temporal RNN RT
φ , with hidden
states hT
t (recurs in t). Crucially, it does not access the current image directly, but uses the output of
the relation RNN (cf. Santoro et al., 2017). The relation RNN takes relations between objects into
account, thereby implementing the explaining away phenomenon; it is essential for capturing any
interactions between objects as well as occlusion (or overlap, if one object is occluded by another).
See Figure 7 for an example. These two RNNs together decide whether to retain or to forget objects
that have been propagated from the previous time step. During DISC, the network infers further latent
variables that are needed to describe any new objects that have entered the frame. All latent variables
remaining after PROP and DISC are passed on to the next time step.

See Figures 2 and 3 for the inference network structure . The full variational posterior is deﬁned as

qφ(D1:t, z1:T | x1:T ) =

(cid:16)

qD
φ

Dt, zDt
t

| xt, zPt
t

(cid:17) (cid:89)

(cid:16)

qP
φ

t | zi
zi

t−1, hT,i

t

, hR,i
t

(cid:17)

.

(4)

T
(cid:89)

t=1

i∈Ot−1

Discovery, described by qD
φ , is very similar to the full posterior of AIR, cf. Equation (2). The only
difference is the conditioning on zPt
, which allows for a different number of discovered objects at
t
each time-step and also for objects explained by PROP not to be explained again. The second term, or
qP
φ , describes propagation. The detailed structures of qD
φ are shown in Figure 3, while all the
pertinent algorithms and equations can be found in Appendices A and C, respectively.

φ and qP

Learning We train SQAIR as an importance-weighted auto-encoder (IWAE) of Burda et al., 2016.
Speciﬁcally, we maximise the importance-weighted evidence lower-bound LIWAE, namely

LIWAE = Ex1:T ∼pdata(x1:T )

Eq

log

(cid:34)

(cid:34)

1
K

K
(cid:88)

k=1

pθ(x1:T , z1:T )
qφ(z1:T | x1:T )

(cid:35)(cid:35)

.

(5)

To optimise the above, we use RMSPROP, K = 5 and batch size of 32. We use the VIMCO gradient
estimator of Mnih and Rezende, 2016 to backpropagate through the discrete latent variables zpres,

4

Figure 3: Left: Interaction between PROP and DISC in
SQAIR. Firstly, objects are propagated to time t, and
object i = 7 is dropped. Secondly, DISC tries to dis-
cover new objects. Here, it manages to ﬁnd two objects:
i = 9 and i = 10. The process recurs for all remaining
time-steps. Blue arrows update the temporal hidden
state, orange ones infer relations between objects, pink
ones correspond to discovery. Bottom: Information
ﬂow in a single discovery block (left) and propagation
block (right). In DISC we ﬁrst predict where and extract
a glimpse. We then predict what and presence. PROP
starts with extracting a glimpse at a candidate location
and updating where. Then it follows a procedure similar
to DISC, but takes the respective latent variables from
the previous time-step into account. It is approximately
two times more computationally expensive than DISC.
For details, see Algorithms 2 and 3 in Appendix A.

and use reparameterisation for the continuous ones (Kingma and Welling, 2013). We also tried to
use NVIL of Mnih and Gregor, 2014 as in the original work on AIR, but found it very sensitive to
hyper-parameters, fragile and generally under-performing.

4 Experiments

We evaluate SQAIR on two datasets. Firstly, we perform an extensive evaluation on moving MNIST
digits, where we show that it can learn to reliably detect, track and generate moving digits (Section 4.1).
Moreover, we show that SQAIR can simulate moving objects into the future — an outcome it has not
been trained for. We also study the utility of learned representations for a downstream task. Secondly,
we apply SQAIR to real-world pedestrian CCTV data from static cameras (DukeMTMC, Ristani et al.,
2016), where we perform background subtraction as pre-processing. In this experiment, we show that
SQAIR learns to detect, track, predict and generate walking pedestrians without human supervision.

4.1 Moving multi-MNIST

The dataset consists of sequences of length 10 of multiple moving MNIST digits. All images are of
size 50 × 50 and there are zero, one or two digits in every frame (with equal probability). Sequences
are generated such that no objects overlap in the ﬁrst frame, and all objects are present through
the sequence; the digits can move out of the frame, but always come back. See Appendix F for an
experiment on a harder version of this dataset. There are 60,000 training and 10,000 testing sequences
created from the respective MNIST datasets. We train two variants of SQAIR: the MLP-SQAIR uses

5

Figure 4: Input images (top) and SQAIR reconstructions with marked glimpse locations (bottom). For more
examples, see Figure 13 in Appendix H.

Figure 5: Samples from SQAIR. Both motion and appearance are consistent through time, thanks to the
propagation part of the model. For more examples, see Figure 15 in Appendix H.

only fully-connected networks, while the CONV-SQAIR replaces the networks used to encode images
and glimpses with convolutional ones; it also uses a subpixel-convolution network as the glimpse
decoder (Shi et al., 2016). See Appendix D for details of the model architectures and the training
procedure.

We use AIR and VRNN (Chung et al., 2015) as baselines for comparison. VRNN can be thought of
as a sequential VAE with an RNN as its deterministic backbone. Being similar to a VAE, its latent
variables are not structured, nor easily interpretable. For a fair comparison, we control the latent
dimensionality of VRNN and the number of learnable parameters. We provide implementation details
in Appendix D.3.

The quantitative analysis consists of comparing all models in terms of the marginal log-likelihood
log pθ(x1:T ) evaluated as the LIWAE bound with K = 1000 particles, reconstruction quality evaluated
as a single-sample approximation of Eqφ[log pθ(x1:T | z1:T )] and the KL-divergence between the
approximate posterior and the prior (Table 1). Additionally, we measure the accuracy of the number
of objects modelled by SQAIR and AIR. SQAIR achieves superior performance across a range of
metrics — its convolutional variant outperforms both AIR and the corresponding VRNN in terms of
model evidence and reconstruction performance. The KL divergence for SQAIR is almost twice as
low as for VRNN and by a yet larger factor for AIR. We can interpret KL values as an indicator of the
ability to compress, and we can treat SQAIR/AIR type of scheme as a version of run-length encoding.
While VRNN has to use information to explicitly describe every part of the image, even if some parts
are empty, SQAIR can explicitly allocate content information (zwhat) to speciﬁc parts of the image
(indicated by zwhere). AIR exhibits the highest values of KL, but this is due to encoding every frame
of the sequence independently — its prior cannot take what and where at the previous time-step into
account, hence higher KL. The ﬁfth column of Table 1 details the object counting accuracy, that is
indicative of the quality of the approximate posterior. It is measured as the sum of zpres
for a given
frame against the true number of objects in that frame. As there is no zpres for VRNN no score is
provided. Perhaps surprisingly, this metric is much higher for SQAIR than for AIR. This is because
AIR mistakenly infers overlapping objects as a single object. Since SQAIR can incorporate temporal

t

Figure 6: The ﬁrst three frames are input to SQAIR, which generated the rest conditional on the ﬁrst frames.

6

Figure 7: Inputs, reconstructions with
marked glimpse locations and recon-
structed glimpses for AIR (left) and
SQAIR (right). SQAIR can model par-
tially visible and heavily overlapping
objects by aggregating temporal infor-
mation.

CONV-SQAIR
MLP-SQAIR
MLP-AIR
CONV-VRNN
MLP-VRNN

log pθ(x1:T )
6784.8
6617.6
6443.6
6561.9
5959.3

log pθ(x1:T | z1:T ) KL(qφ || pθ) Counting Addition
0.9990
134.6
0.9998
164.5
0.8644
352.6
0.8536
270.2
218.3
0.8059

6923.8
6786.5
6830.6
6737.8
6108.7

0.9974
0.9986
0.9058
n/a
n/a

Table 1: SQAIR achieves higher performance than the baselines across a range of metrics. The third column
refers to the Kullback-Leibler (KL) divergence between the approximate posterior and the prior. Counting refers
to accuracy of the inferred number of objects present in the scene, while addition stands for the accuracy of a
supervised digit addition experiment, where a classiﬁer is trained on the learned latent representations of each
frame.

information, it does not exhibit this failure mode (cf. Figure 7). Next, we gauge the utility of the
learnt representations by using them to determine the sum of the digits present in the image (Table 1,
column six). To do so, we train a 19-way classiﬁer (mapping from any combination of up to two digits
in the range [0, 9] to their sum) on the extracted representations and use the summed labels of digits
present in the frame as the target. Appendix D contains details of the experiment. SQAIR signiﬁcantly
outperforms AIR and both variants of VRNN on this tasks. VRNN under-performs due to the inability
of disentangling overlapping objects, while both VRNN and AIR suffer from low temporal consistency
of learned representations, see Appendix H. Finally, we evaluate SQAIR qualitatively by analyzing
reconstructions and samples produced by the model against reconstructions and samples from VRNN.
We observe that samples and reconstructions from SQAIR are of better quality and, unlike VRNN,
preserve motion and appearance consistently through time. See Appendix H for direct comparison
and additional examples. Furthermore, we examine conditional generation, where we look at samples
from the generative model of SQAIR conditioned on three images from a real sequence (see Figure 6).
We see that the model can preserve appearance over time, and that the simulated objects follow
similar trajectories, which hints at good learning of the motion model (see Appendix H for more
examples). Figure 7 shows reconstructions and corresponding glimpses of AIR and SQAIR. Unlike
SQAIR, AIR is unable to recognize objects from partial observations, nor can it distinguish strongly
overlapping objects (it treats them as a single object; columns ﬁve and six in the ﬁgure). We analyze
failure cases of SQAIR in Appendix G.

4.2 Generative Modelling of Walking Pedestrians

To evaluate the model in a more challenging, real-world setting, we turn to data from static CCTV
cameras of the DukeMTMC dataset (Ristani et al., 2016). As part of pre-precessing, we use standard
background subtraction algorithms (Itseez, 2015). In this experiment, we use 3150 training and 350
validation sequences of length 5. For details of model architectures, training and data pre-processing,
see Appendix E. We evaluate the model qualitatively by examining reconstructions, conditional
samples (conditioned on the ﬁrst four frames) and samples from the prior (Figure 8 and Appendix I).
We see that the model learns to reliably detect and track walking pedestrians, even when they are
close to each other.

There are some spurious detections and re-detections of the same objects, which is mostly caused by
imperfections of the background subtraction pipeline — backgrounds are often noisy and there are
sudden appearance changes when a part of a person is treated as background in the pre-processing
pipeline. The object counting accuracy in this experiment is 0.5712 on the validation dataset, and we
noticed that it does increase with the size of the training set. We also had to use early stopping to
prevent overﬁtting, and the model was trained for only 315k iterations (> 1M for MNIST experiments).
Hence, we conjecture that accuracy and marginal likelihood can be further improved by using a
bigger dataset.

7

Figure 8: Inputs on the top, reconstructions in the second row, samples in the third row; rows four and ﬁve
contain inputs and conditional generation: the ﬁrst four frames in the last row are reconstructions, while the
remaining ones are predicted by sampling from the prior. There is no ground-truth, since we used sequences of
length ﬁve of training and validation.

5 Related Work

Object Tracking There have been many approaches to modelling objects in images and videos.
Object detection and tracking are typically learned in a supervised manner, where object bounding
boxes and often additional labels are part of the training data. Single-object tracking commonly use
Siamese networks, which can be seen as an RNN unrolled over two time-steps (Valmadre et al., 2017).
Recently, Kosiorek et al., 2017 used an RNN with an attention mechanism in the HART model to
predict bounding boxes for single objects, while robustly modelling their motion and appearance.
Multi-object tracking is typically attained by detecting objects and performing data association on
bounding-boxes (Bewley et al., 2016). Schulter et al., 2017 used an end-to-end supervised approach
that detects objects and performs data association. In the unsupervised setting, where the training
data consists of only images or videos, the dominant approach is to distill the inductive bias of
spatial consistency into a discriminative model. Cho et al., 2015 detect single objects and their
parts in images, and Kwak et al., 2015; Xiao and Jae Lee, 2016 incorporate temporal consistency
to better track single objects. SQAIR is unsupervised and hence it does not rely on bounding boxes
nor additional labels for training, while being able to learn arbitrary motion and appearance models
similarly to HART (Kosiorek et al., 2017). At the same time, is inherently multi-object and performs
data association implicitly (cf. Appendix A). Unlike the other unsupervised approaches, temporal
consistency is baked into the model structure of SQAIR and further enforced by lower KL divergence
when an object is tracked.

Video Prediction Many works on video prediction learn a deterministic model conditioned on the
current frame to predict the future ones (Ranzato et al., 2014; Srivastava et al., 2015). Since these
models do not model uncertainty in the prediction, they can suffer from the multiple futures problem
— since perfect prediction is impossible, the model produces blurry predictions which are a mean of
possible outcomes. This is addressed in stochastic latent variable models trained using variational
inference to generate multiple plausible videos given a sequence of images (Babaeizadeh et al., 2017;
Denton and Fergus, 2018). Unlike SQAIR, these approaches do not model objects or their positions
explicitly, thus the representations they learn are of limited interpretability.

Learning Decomposed Representations of Images and Videos Learning decomposed representa-
tions of object appearance and position lies at the heart of our model. This problem can be also
seen as perceptual grouping, which involves modelling pixels as spatial mixtures of entities. Greff,
Rasmus, et al., 2016 and Greff, Steenkiste, et al., 2017 learn to decompose images into separate
entities by iterative reﬁnement of spatial clusters using either learned updates or the Expectation
Maximization algorithm; Ilin et al., 2017 and Steenkiste et al., 2018 extend these approaches to videos,
achieving very similar results to SQAIR. Perhaps the most similar work to ours is the concurrently
developed model of Hsieh et al., 2018. The above approaches rely on iterative inference procedures,

8

but do not exhibit the object-counting behaviour of SQAIR. For this reason, their computational
complexities are proportional to the predeﬁned maximum number of objects, while SQAIR can be
more computationally efﬁcient by adapting to the number of objects currently present in an image.
Another interesting line of work is the GAN-based unsupervised video generation that decomposes
motion and content (Tulyakov et al., 2018; Denton and Birodkar, 2017). These methods learn
interpretable features of content and motion, but deal only with single objects and do not explicitly
model their locations. Nonetheless, adversarial approaches to learning structured probabilistic models
of objects offer a plausible alternative direction of research.
Bayesian Nonparametric Models To the best of our knowledge, Neiswanger and Wood, 2012 is the
only known approach that models pixels belonging to a variable number of objects in a video together
with their locations in the generative sense. This work uses a Bayesian nonparametric (BNP) model,
which relies on mixtures of Dirichlet processes to cluster pixels belonging to an object. However,
the choice of the model necessitates complex inference algorithms involving Gibbs sampling and
Sequential Monte Carlo, to the extent that any sensible approximation of the marginal likelihood is
infeasible. It also uses a ﬁxed likelihood function, while ours is learnable.
The object appearance-persistence-disappearance model in SQAIR is reminiscent of the Markov
Indian buffet process (MIBP) of Gael et al., 2009, another BNP model. MIBP was used as a
model for blind source separation, where multiple sources contribute toward an audio signal, and
can appear, persist, disappear and reappear independently. The prior in SQAIR is similar, but the
crucial differences are that SQAIR combines the BNP prior with ﬂexible neural network models for
the dynamics and likelihood, as well as variational learning via amortized inference. The interface
between deep learning and BNP, and graphical models in general, remains a fertile area of research.

6 Discussion

In this paper we proposed SQAIR, a probabilistic model that extends AIR to image sequences, and
thereby achieves temporally consistent reconstructions and samples. In doing so, we enhanced AIR’s
capability of disentangling overlapping objects and identifying partially observed objects.

This work continues the thread of Greff, Steenkiste, et al., 2017, Steenkiste et al., 2018 and, together
with Hsieh et al., 2018, presents unsupervised object detection & tracking with learnable likelihoods
by the means of generative modelling of objects. In particular, our work is the ﬁrst one to explicitly
model object presence, appearance and location through time. Being a generative model, SQAIR can
be used for conditional generation, where it can extrapolate sequences into the future. As such, it
would be interesting to use it in a reinforcement learning setting in conjunction with Imagination-
Augmented Agents (Weber et al., 2017) or more generally as a world model (Ha and Schmidhuber,
2018), especially for settings with simple backgrounds, e. g., games like Montezuma’s Revenge or
Pacman.

The framework offers various avenues of further research; SQAIR leads to interpretable representa-
tions, but the interpretability of what variables can be further enhanced by using alternative objectives
that disentangle factors of variation in the objects (Kim and Mnih, 2018). Moreover, in its current
state, SQAIR can work only with simple backgrounds and static cameras. In future work, we would
like to address this shortcoming, as well as speed up the sequential inference process whose com-
plexity is linear in the number of objects. The generative model, which currently assumes additive
image composition, can be further improved by e. g., autoregressive modelling (Oord et al., 2016).
It can lead to higher ﬁdelity of the model and improved handling of occluded objects. Finally, the
SQAIR model is very complex, and it would be useful to perform a series of ablation studies to further
investigate the roles of different components.

Acknowledgements

We would like to thank Ali Eslami for his help in implementing AIR, Alex Bewley and Martin
Engelcke for discussions and valuable insights and anonymous reviewers for their constructive
feedback. Additionally, we acknowledge that HK and YWT’s research leading to these results
has received funding from the European Research Council under the European Union’s Seventh
Framework Programme (FP7/2007-2013) ERC grant agreement no. 617071.

9

References

In: ICIP.

arXiv: 1509.00519.

Babaeizadeh, M., C. Finn, D. Erhan, R. H. Campbell, and S. Levine (2017). “Stochastic Variational

Video Prediction”. In: CoRR. arXiv: 1710.11252.

Bewley, A., Z. Ge, L. Ott, F. T. Ramos, and B. Upcroft (2016). “Simple online and realtime tracking”.

Burda, Y., R. Grosse, and R. Salakhutdinov (2016). “Importance Weighted Autoencoders”. In: ICLR.

Cho, M., S. Kwak, C. Schmid, and J. Ponce (2015). “Unsupervised object discovery and localization
in the wild: Part-based matching with bottom-up region proposals”. In: CoRR. arXiv: 1501.06170.
Chung, J., K. Kastner, L. Dinh, K. Goel, A. Courville, and Y. Bengio (2015). “A Recurrent Latent

Variable Model for Sequential Data”. In: NIPS. arXiv: 1506.02216.

Clevert, D.-A., T. Unterthiner, and S. Hochreiter (2015). “Fast and Accurate Deep Network Learning

by Exponential Linear Units (ELUs)”. In: CoRR. arXiv: 1511.07289.

Denton, E. and V. Birodkar (2017). “Unsupervised learning of disentangled representations from

video”. In: NIPS.

Denton, E. and R. Fergus (2018). “Stochastic Video Generation with a Learned Prior”. In: ICML.
Eslami, S. M. A., N. Heess, T. Weber, Y. Tassa, D. Szepesvari, K. Kavukcuoglu, and G. E. Hinton
(2016). “Attend, Infer, Repeat: Fast Scene Understanding with Generative Models”. In: NIPS.
arXiv: 1603.08575.

Gael, J. V., Y. W. Teh, and Z. Ghahramani (2009). “The Inﬁnite Factorial Hidden Markov Model”. In:

Graves, A., G. Wayne, M. Reynolds, T. Harley, I. Danihelka, A. Grabska-Barwi´nska, S. G. Col-
menarejo, E. Grefenstette, T. Ramalho, J. Agapiou, A. P. Badia, K. M. Hermann, Y. Zwols, G.
Ostrovski, A. Cain, H. King, C. Summerﬁeld, P. Blunsom, K. Kavukcuoglu, and D. Hassabis
(2016). “Hybrid computing using a neural network with dynamic external memory”. In: Nature
538.7626.

Greff, K., A. Rasmus, M. Berglund, T. H. Hao, H. Valpola, and J. Schmidhuber (2016). “Tagger:

Deep Unsupervised Perceptual Grouping”. In: NIPS.

Greff, K., S. van Steenkiste, and J. Schmidhuber (2017). “Neural Expectation Maximization”. In:

NIPS.

NIPS.

Gulrajani, I., K. Kumar, F. Ahmed, A. A. Taiga, F. Visin, D. Vazquez, and A. Courville (2016).

“Pixelvae: A latent variable model for natural images”. In: CoRR. arXiv: 1611.05013.

Ha, D. and J. Schmidhuber (2018). “World Models”. In: CoRR. arXiv: 1603.10122.
Hsieh, J.-T., B. Liu, D.-A. Huang, L. Fei-Fei, and J. C. Niebles (2018). “Learning to Decompose and

Disentangle Representations for Video Prediction”. In: NIPS.

Ilin, A., I. Prémont-Schwarz, T. H. Hao, A. Rasmus, R. Boney, and H. Valpola (2017). “Recurrent

Itseez (2015). Open Source Computer Vision Library. https://github.com/itseez/opencv.
Jacobsen, J.-H., J. Van Gemert, Z. Lou, and A. W. M. Smeulders (2016). “Structured Receptive Fields

Ladder Networks”. In: NIPS.

in CNNs”. In: CVPR.

Jaderberg, M., K. Simonyan, A. Zisserman, and K. Kavukcuoglu (2015). “Spatial Transformer

Networks”. In: NIPS. DOI: 10.1038/nbt.3343. arXiv: 1506.02025v1.

Kemp, C. and J. B. Tenenbaum (2008). “The discovery of structural form”. In: Proceedings of the

National Academy of Sciences 105.31.

Kim, H. and A. Mnih (2018). “Disentangling by factorising”. In: ICML. arXiv: 1802.05983.
Kingma, D. P. and J. Ba (2015). “Adam: A Method for Stochastic Optimization”. In: ICLR. arXiv:

Kingma, D. P. and M. Welling (2013). “Auto-encoding variational bayes”. In: arXiv preprint

Kosiorek, A. R., A. Bewley, and I. Posner (2017). “Hierarchical Attentive Recurrent Tracking”. In:

1412.6980.

arXiv:1312.6114.

NIPS. arXiv: 1706.09262.

Kwak, S., M. Cho, I. Laptev, J. Ponce, and C. Schmid (2015). “Unsupervised object discovery and

tracking in video collections”. In: ICCV. IEEE.

LeCun, Y., Y. Bengio, and G. Hinton (2015). “Deep learning”. In: Nature 521.7553.
LeCun, Y., B. Boser, J. S. Denker, D. Henderson, R. E. Howard, W. Hubbard, and L. D. Jackel (1989).

“Backpropagation applied to handwritten zip code recognition”. In: Neural computation 1.4.

Maddison, C. J., J. Lawson, G. Tucker, N. Heess, M. Norouzi, A. Mnih, A. Doucet, and Y. Teh (2017).

“Filtering Variational Objectives”. In: Advances in Neural Information Processing Systems.

10

Mnih, A. and K. Gregor (2014). “Neural Variational Inference and Learning in Belief Networks”. In:

Mnih, A. and D. J. Rezende (2016). “Variational inference for Monte Carlo objectives”. In: ICML.

ICML. arXiv: 1402.0030v2.

arXiv: 1602.06725.

Neiswanger, W. and F. Wood (2012). “Unsupervised Detection and Tracking of Arbitrary Objects

with Dependent Dirichlet Process Mixtures”. In: CoRR. arXiv: 1210.3288.

Oord, A. van den, N. Kalchbrenner, O. Vinyals, L. Espeholt, A. Graves, and K. Kavukcuoglu (2016).

“Conditional Image Generation with PixelCNN Decoders”. In: NIPS. arXiv: 1606.05328.

Ranzato, M., A. Szlam, J. Bruna, M. Mathieu, R. Collobert, and S. Chopra (2014). “Video (language)
modeling: a baseline for generative models of natural videos”. In: CoRR. arXiv: 1412.6604.
Ristani, E., F. Solera, R. Zou, R. Cucchiara, and C. Tomasi (2016). “Performance measures and a

data set for multi-target, multi-camera tracking”. In: ECCV. Springer.

Santoro, A., D. Raposo, D. G. Barrett, M. Malinowski, R. Pascanu, P. Battaglia, and T. Lillicrap
(2017). “A simple neural network module for relational reasoning”. In: NIPS. arXiv: 1706.01427.
Schulter, S., P. Vernaza, W. Choi, and M. K. Chandraker (2017). “Deep Network Flow for Multi-object

Tracking”. In: CVPR.

Shi, W., J. Caballero, F. Huszar, J. Totz, A. P. Aitken, R. Bishop, D. Rueckert, and Z. Wang (2016).
“Real-Time Single Image and Video Super-Resolution Using an Efﬁcient Sub-Pixel Convolutional
Neural Network”. In: CVPR.

Srivastava, N., E. Mansimov, and R. Salakhudinov (2015). “Unsupervised learning of video represen-

tations using lstms”. In: ICML.

Steenkiste, S. van, M. Chang, K. Greff, and J. Schmidhuber (2018). “Relational Neural Expectation

Maximization: Unsupervised Discovery of Objects and their Interactions”. In: ICLR.

Tieleman, T. and G. Hinton (2012). Lecture 6.5—RmsProp: Divide the gradient by a running average

of its recent magnitude. COURSERA: Neural Networks for Machine Learning.

Tulyakov, S., M.-Y. Liu, X. Yang, and J. Kautz (2018). “Mocogan: Decomposing motion and content

for video generation”. In: CVPR.

Valmadre, J., L. Bertinetto, J. F. Henriques, A. Vedaldi, and P. H. S. Torr (2017). “End-to-end
representation learning for Correlation Filter based tracking”. In: CVPR. arXiv: 1704.06036.
Weber, T., S. Racanière, D. P. Reichert, L. Buesing, A. Guez, D. J. Rezende, A. P. Badia, O. Vinyals,
N. Heess, Y. Li, et al. (2017). “Imagination-augmented agents for deep reinforcement learning”. In:
NIPS.

Xiao, F. and Y. Jae Lee (2016). “Track and segment: An iterative unsupervised approach for video

Zaheer, M., S. Kottur, S. Ravanbakhsh, B. Póczos, R. R. Salakhutdinov, and A. J. Smola (2017).

object proposals”. In: CVPR.

“Deep Sets”. In: NIPS.

11

A Algorithms

Image generation, described by Algorithm 1, is exactly the same for SQAIR and AIR. Algorithms 2
and 3 describe inference in SQAIR. Note that DISC is equivalent to AIR if no latent variables are
present in the inputs.

If a function has multiple inputs and if not stated otherwise, all the inputs are concatenated and
linearly projected into some ﬁxed-dimensional space, e. g., Lines 9 and 15 in Algorithm 2. Spatial
Transformer (ST, e. g., Line 7 in Algorithm 2) has no learnable parameters: it samples a uniform
grid of points from an image x, where the grid is transformed according to parameters zwhere. f 1
φ is
implemented as a perceptron with a single hidden layer. Statistics of qP and qD are a result of
applying a two-layer multilayer perceptron (MLP) to their respective conditioning sets. Different
distributions q do not share parameters of their MLPs. The glimpse encoder hglimpse
(Lines 8 and 12
in Algorithm 2 and Line 12 in Algorithm 3; they share parameters) and the image encoder henc
(Line 3 in Algorithm 3) are implemented as two-layer MLPs or convolutional neural networks (CNNs),
depending on the experiment (see Appendices D and E for details).

φ

φ

One of the important details of PROP is the proposal glimpse extracted in lines Lines 6 and 7 of
Algorithm 2. It has a dual purpose. Firstly, it acts as an information bottleneck in PROP, limiting
the ﬂow of information from the current observation xt to the updated latent variables zt. Secondly,
even though the information is limited, it can still provide a high-resolution view of the object
corresponding to the currently updated latent variable, given that the location of the proposal glimpse
correctly predicts motion of this object. Initially, our implementation used encoding of the raw
observation (henc
φ (xt), similarly to Line 3 in Algorithm 3) as an input to the relation-RNN (Line 9
in Algorithm 2). We have also experimented with other bottlenecks: (1) low resolution image as
an input to the image encoder and (2) a low-dimensional projection of the image encoding before
the relation-RNN. Both approaches have led to ID swaps, where the order of explaining objects
were sometimes swapped for different frames of the sequence (see Figure 10 in Appendix G for an
example). Using encoded proposal glimpse extracted from a predicted location has solved this issue.

To condition DISC on propagated latent variables (Line 4 in Algorithm 3), we encode the latter by
using a two-layer MLP similarly to Zaheer et al., 2017,

lt =

(cid:88)

i∈Pt

(cid:16)

MLP

zwhat,i
t

, zwhere,i

t

(cid:17)

.

(6)

Note that other encoding schemes are possible, though we have experimented only with this one.

- latent variables from the current time-step.

(cid:1) // Indices of all present latent variables.

Algorithm 1: Image Generation

Input

: zwhat
t

, zwhere
t

t

1 Ot = indices (cid:0)zwhat
2 y0
t = 0
3 for i ∈ Ot do
(cid:16)
yatt,i
zwhat,i
= f dec
t
t
θ
t + ST−1 (cid:16)
t = yi−1
yi
6 ˆxt ∼ N (cid:0)x | yn, σ2

xI(cid:1)

4

5

Output : ˆx

(cid:17)

// Decode the glimpse.

yatt,i
t

, zwhere,i

t

(cid:17)

12

Algorithm 2: Inference for Propagation
Input

t−1 , zpres

:xt - image at the current time-step,
t−1 , zwhere
zwhat
hT
t−1 - hidden states from the previous time-step.
, zwhat,0
t

, zwhere,0

t

1 hR,0
t
2 j = 0 // Index of the object processed in the last iteration.
3 for i ∈ Ot−1 do
if zpres,i
4

= initialize()

t−1 - latent variables from the previous time-step

(cid:16)

(cid:17)

ˆzwhere,i
t

t−1 == 0 then
continue
, hT,i
zwhere,i
= f 1
t
t−1
φ
(cid:17)
(cid:16)
xt, ˆzwhere,i
ˆgi
t = ST
t
(cid:0)ˆgi
t = hglimpse
ˆei
t
φ
, hR,i
wR,i
t = RR
t
φ
state, see Equation (14).
zwhere | zwhere,k
zwhere,i
t
(cid:17)

t, zwhat,i
ˆei

t−1

t−1

(cid:16)

∼ qP
φ
(cid:16)
xt, zwhere,i
gi
t = ST
t
(cid:0)gi
t = hglimpse
ei
t
φ
, hT,i
wT,i
t = RT
t
φ
zwhat,i
∼ qP
t
φ
(cid:16)
zpres,i
∼ qP
t
φ
j = i

(cid:16)

Output : zwhat,Pt

, zwhere,Pt

, zpres,Pt

t

t

t

(cid:17)

, wR,i
t

// Proposal location.

// Extract a glimpse from a proposal location.

(cid:1) // Encode the proposal glimpse.
(cid:16)
, zwhat,j
t

t−1, hR,j

, zwhere,i
t−1

, hT,i

t

(cid:17)

, zwhere,j

t

// Relational

// Extract the final glimpse.

t

(cid:17)

, hT,i

(cid:1) // Encode the final glimpse.
(cid:16)
t−1, hR,i
t, zwhere,i
ei
t
, wR,i
, wT,i
t
t
, zwhere,i

t, zwhat,i
t−1 , zwhat,i

, wR,i
t

, wT,i
t

t−1

t

t

(cid:17)

zpres | zpres,i

zwhat | ei

// Temporal state, see Equation (15).
(cid:17)

// Equation (13).

// Maximum index among the propagated latent variables.

Algorithm 3: Inference for Discovery
Input

: xt - image at the current time-step,
zPt
t
N - maximum number of inference steps for discovery.

- propagated latent variables for the current time-step,

(cid:1) // Encode latent variables.

, zwhere,i−1

t

, hD,i−1
t

(cid:17)

= initialize()

, zwhere,0
1 hD,0
, zwhat,0
t
t
t
(cid:17)
(cid:16)
zPt
2 j = max_index
t
3 et = henc
(cid:0)zwhat
, zpres
4 lt = henc
t
t
5 for i ∈ [j + 1, . . . , j + N ] do

, zwhere
t

φ

φ (xt) // Encode the image.

(cid:16)

et, lt, zwhat,i−1
t
(cid:17)

zpres | wD,i

t

, hD,i

wD,i
t = RD
t
φ
(cid:16)
zpres,i
∼ qD
t
φ
if zpres,i = 0 then

break

(cid:16)

(cid:17)

zwhere | wD,i
(cid:17)

t

zwhere,i
t

∼ qD
φ
(cid:16)
xt, zwhere,i
t
(cid:0)gi
(cid:0)zwhat
| ei
t
t
, zwhere,Dt

gi
t = ST
t = hglimpse
ei
φ
zwhat,i
∼ qD
t
φ
Output : zwhat,Dt

t

(cid:1)

t

t

, zpres,Dt

t

(cid:1) // Encode the glimpse.

13

5

6

7

8

9

10

11

12

13

14

15

16

6

7

8

9

10

11

12

13

B Details for the Generative Model of SQAIR

In implementation, we upper bound the number of objects at any given time by N . In detail, the
discovery prior is given by
pD(cid:16)

= pD(Dt | Pt)

)pD(zwhere,i
t

pD(zwhat,i
t

)δ1(zpres,i
t

Dt, zDt
t

| zPt
t

(cid:89)

(7)

),

(cid:17)

i∈Dt
pD(Dt | Pt) = Categorical (Dt; N − Pt, pθ(Pt)) ,
(8)
where δx(·) is the delta function at x, Categorical(k; K, p) implies k ∈ {0, 1, . . . , K} with proba-
bilities p0, p1, . . . , pK and pD(zwhat,i
) are ﬁxed isotropic Gaussians. The propagation
prior is given by
pP (cid:16)
zPt
t

), pD(zwhere,i
t

t−1 , ht−1

zwhere,i
t

zwhat,i
t

| zpres,i

zpres,i
t

pP (cid:16)

pP (cid:16)

pP (cid:16)

| ht−1

| ht−1

| zt−1

(cid:89)

(9)

=

(cid:17)

(cid:17)

(cid:17)

(cid:17)

,

t

i∈Pt
zpres,i
t

pP (cid:16)

(cid:17)

t−1 , ht−1
with fθ a scalar-valued function with range [0, 1] and pP (zwhat,i
t
factorised Gaussians parameterised by some function of ht−1.

= Bernoulli(zpres,i

| zpres,i

t

; fθ(ht−1))δ1(zpres,i

t−1 ),

(10)

|ht−1), pP (zwhere,i

t

|ht−1) both

C Details for the Inference of SQAIR

The propagation inference network qP
(cid:16)

qP
φ

zPt
t

| xt, zt−1, hT,Pt

φ is given as below,
(cid:16)
qP
φ

(cid:89)

=

(cid:17)

t

i∈Ot−1

t | xt, zi
zi

t−1, hT,i

t

, hR,i
t

(cid:17)

,

(11)

t

with hR,i
the hidden state of the relation RNN (see Equation (14)). Its role is to capture information
from the observation xt as well as to model dependencies between different objects. The propagation
posterior for a single object can be expanded as follows,
(cid:16)
zi
t | xt, zi
(cid:16)

t−1, hT,i

, hR,i
t

qP
φ

=

(cid:17)

(cid:17)

t

zwhere,i
t

| zwhat,i
t−1

, zwhere,i
t−1

, hT,i

t−1, hR,i

t

zwhat,i
t

| xt, zwhere,i
t

, zwhat,i
t−1

, hT,i
t

, hR,i
t

qP
φ

qP
φ

(cid:16)

(cid:16)

(cid:17)

(cid:17)

(12)

t

t

.

, hR,i
t

zpres,i
t

, zpres,i

, zwhere,i

| zwhat,i
t

t−1 , hT,i

qP
φ
In the second line, we condition the object location zwhere,i
on its previous appearance and location
as well as its dynamics and relation with other objects. In the third line, current appearance zwhat,i
is conditioned on the new location. Both zwhere,i
are modelled as factorised Gaussians.
Finally, presence depends on the new appearance and location as well as the presence of the same
object at the previous time-step. More speciﬁcally,
, zpres,i
(cid:16)
zwhat,i
t

| zwhat,i
t
(cid:16)

and zwhat,i
t

t−1 , hT,i

= Bernoulli

δ1(zpres,i

, zwhere,i

, zwhere,i

zpres,i
t

zpres,i
t

, hR,i
t

, hR,i
t

, hT,i
t

t−1 ),

| fφ

(13)

qP
φ

(cid:17)(cid:17)

(cid:16)

(cid:17)

t

t

t

t

t

t

where the second term is the delta distribution centered on the presence of this object at the previous
time-step. If it was not there, it cannot be propagated. Let j ∈ {0, . . . , i − 1} be the index of the
most recent present object before object i. Hidden states are updated as follows,
, zwhere,j

, hT,i

(14)

(cid:17)

(cid:16)

,

xt, zwhat,i
t−1

, zwhere,i
t−1

t−1, hR,i−1

t

hR,i
t = RR
φ

, zwhat,j
t

t

hT,i
t = RT
φ

(cid:16)
xt, zwhere,i
t

, hT,i

t−1, hR,i

t

(cid:17)

,

(15)

φ and RR

where RT
φ are temporal and propagation RNNS, respectively. Note that in Eq. (14) the RNN
does not have direct access to the image xt, but rather accesses it by extracting an attention glimpse
at a proposal location, predicted from hT,i
. This might seem like a minor detail, but in
t−1
practice structuring computation this way prevents ID swaps from occurring, cf. Appendix G. For
computational details, please see Algorithms 2 and 3 in Appendix A.

t−1 and zwhere,i

14

D Details of the moving-MNIST Experiments

D.1 SQAIR and AIR Training Details

All models are trained by maximising the evidence lower bound (ELBO) LIW AE (Equation (5)) with
the RMSPROP optimizer (Tieleman and Hinton, 2012) with momentum equal to 0.9. We use the
learning rate of 10−5 and decrease it to 1
3 · 10−5 after 400k and to 10−6 after 1000k training iterations.
Models are trained for the maximum of 2 · 106 training iterations; we apply early stopping in case
of overﬁtting. SQAIR models are trained with a curriculum of sequences of increasing length: we
start with three time-steps, and increase by one time-step every 105 training steps until reaching the
maximum length of 10. When training AIR, we treated all time-steps of a sequence as independent,
and we trained it on all data (sequences of length ten, split into ten independent sequences of length
one).

D.2 SQAIR and AIR Model Architectures

All models use glimpse size of 20 × 20 and exponential linear unit (ELU) (Clevert et al., 2015)
non-linearities for all layers except RNNS and output layers. MLP-SQAIR uses fully-connected layers
for all networks. In both variants of SQAIR, the RD
φ RNNS are the vanilla RNNS. The
propagation prior RNN and the temporal RNN RT
φ use gated recurrent unit (GRU). AIR follows the
same architecture as MLP-SQAIR. All fully-connected layers and RNNS in MLP-SQAIR and AIR have
256 units; they have 2.9M and 1.7M trainable parameters, respectively.

φ and RR

CONV-SQAIR differs from the MLP version in that it uses CNNs for the glimpse and image encoders
and a subpixel-CNN (Shi et al., 2016) for the glimpse decoder. All fully connected layers and RNNS
have 128 units. The encoders share the CNN, which is followed by a single fully-connected layer
(different for each encoder). The CNN has four convolutional layers with [16, 32, 32, 64] features
maps and strides of [2, 2, 1, 1]. The glimpse decoder is composed of two fully-connected layers with
[256, 800] hidden units, whose outputs are reshaped into 32 features maps of size 5 × 5, followed by
a subpixel-CNN with three layers of [32, 64, 64] feature maps and strides of [1, 2, 2]. All ﬁlters are of
size 3 × 3. CONV-SQAIR has 2.6M trainable parameters.

We have experimented with different sizes of fully-connected layers and RNNS; we kept the size of
all layers the same and altered it in increments of 32 units. Values greater than 256 for MLP-SQAIR
and 128 for CONV-SQAIR resulted in overﬁtting. Models with as few as 32 units per layer (< 0.9M
trainable parameters for MLP-SQAIR) displayed the same qualitative behaviour as reported models,
but showed lower quantitative performance.

The output likelihood used in both SQAIR and AIR is Gaussian with a ﬁxed standard deviation set to
0.3, as used by Eslami et al., 2016. We tried using a learnable scalar standard deviation, but decided
not to report it due to unsable behaviour in the early stages of training. Typically, standard deviation
would converge to a low value early in training, which leads to high penalties for reconstruction
mistakes. In this regime, it is beneﬁcial for the model to perform no inference steps (zpres is always
equal to zero), and the model never learns. Fixing standard deviation for the ﬁrst 10k iterations and
then learning it solves this issue, but it introduces unnecessary complexity into the training procedure.

D.3 VRNN Implementation and Training Details

Our VRNN implementation is based on the implementation4 of Filtering Variational Objectives (FIVO)
by Maddison et al., 2017. We use an LSTM with hidden size J for the deterministic backbone of the
VRNN. At time t, the LSTM receives ψx(xt−1) and ψz(zt−1) as input and outputs ot, where ψx is
a data feature extractor and ψz is a latent feature extractor. The output is mapped to the mean and
standard deviation of the Gaussian prior pθ(zt | xt−1) by an MLP. The likelihood pθ(xt | zt, xt−1) is
a Gaussian, with mean given by ψdec(ψz(zt), ot) and standard deviation ﬁxed to be 0.3 as for SQAIR
and AIR. The inference network qφ(zt | zt−1, xt) is a Gaussian with mean and standard deviation
given by the output of separate MLPs with inputs [ot, ψx(xt)].
All aforementioned MLPs use the same number of hidden units H and the same number of hidden
layers L. The CONV-VRNN uses a CNN for ψx and a transposed CNN for ψdec. The MLP-VRNN
uses an MLP with H (cid:48) hidden units and L(cid:48) hidden layers for both. ELU were used throughout as
activations. The latent dimensionality was ﬁxed to 165, which is the upper bound of the number of

4https://github.com/tensorflow/models/tree/master/research/fivo

15

Table 2: Number of trainable parameters for the reported models.

CONV-SQAIR MLP-SQAIR MLP-AIR

CONV-VRNN MLP-VRNN

number of parameters

2.6M

2.9M

1.7M

2.6M

2.1M

latent dimensions that can be used per time-step in SQAIR or AIR. Training was done by optimising
the FIVO bound, which is known to be tighter than the IWAE bound for sequential latent variable
models (Maddison et al., 2017). We also veriﬁed that this was the case with our models on the
moving-MNIST data. We train with the RMSPROP optimizer with a learning rate of 10−5, momentum
equal to 0.9, and training until convergence of test FIVO bound.

For each of MLP-VRNN and CONV-VRNN, we experimented with three architectures:
small/medium/large. We used H=H (cid:48)=J=128/256/512 and L=L(cid:48)=2/3/4 for MLP-VRNN, giving
number of parameters of 1.2M/2.1M/9.8M. For CONV-VRNN, the number of features maps we
used was [32, 32, 64, 64], [32, 32, 32, 64, 64, 64] and [32, 32, 32, 64, 64, 64, 64, 64, 64], with strides
of [2, 2, 2, 2], [1, 2, 1, 2, 1, 2] and [1, 2, 1, 2, 1, 2, 1, 1, 1], all with 3 × 3 ﬁlters, H=J=128/256/512
and L=1, giving number of parameters of 0.8M/2.6M/6.1M. The largest convolutional encoder
architecture is very similar to that in Gulrajani et al., 2016 applied to MNIST.

We have chosen the medium-sized models for comparison with SQAIR due to overﬁtting encountered
in larger models.

D.4 Addition Experiment

We perform the addition experiment by feeding latent representations extracted from the considered
models into a 19-way classiﬁer, as there are 19 possible outputs (addition of two digits between 0
and 9). The classiﬁer is implemented as an MLP with two hidden layers with 256 ELU units each
and a softmax output. For AIR and SQAIR, we use concatenated zwhat variables multiplied by the
corresponding zpres variables, while for VRNN we use the whole 165-dimensional latent vector. We
train the model over 107 training iterations with the ADAM optimizer (Kingma and Ba, 2015) with
default parameters (in tensorﬂow).

E Details of the DukeMTMC Experiments

We take videos from cameras one, two, ﬁve, six and eight from the DukeMTMC dataset (Ristani et al.,
2016). As pre-processing, we invert colors and subtract backgrounds using standard OpenCV tools
(Itseez, 2015), downsample to the resolution of 240 × 175, convert to gray-scale and randomly crop
fragments of size 64 × 64. Finally, we generate 3500 sequences of length ﬁve such that the maximum
number of objects present in any single frame is three and we split them into training and validation
sets with the ratio of 9 : 1.

We use the same training procedure as for the MNIST experiments. The only exception is the learning
curriculum, which goes from three to ﬁve time-steps, since this is the maximum length of the
sequences.

The reported model is similar to CONV-SQAIR. We set the glimpse size to 28 × 12 to account for the
expected aspect ratio of pedestrians. Glimpse and image encoders share a CNN with [16, 32, 64, 64]
feature maps and strides of [2, 2, 2, 1] followed by a fully-connected layer (different for each encoder).
The glimpse decoder is implemented as a two-layer fully-connected network with 128 and 1344 units,
whose outputs are reshaped into 64 feature maps of size 7 × 3, followed by a subpixel-CNN with two
layers of [64, 64] feature maps and strides of [2, 2]. All remaining fully-connected layers in the model
have 128 units. The total number of trainable parameters is 3.5M.

F Harder multi-MNIST Experiment

We created a version of the multi-MNIST dataset, where objects can appear or disappear at an arbitrary
point in time. It differs from the dataset described in Section 4.1, where all digits are present
throughout the sequence. All other dataset parameters are the same as in Section 4.1. Figure 9 shows
an example sequence and MLP-SQAIR reconstructions with marked glimpse locations. The model
has no trouble detecting new digits in the middle of the sequence and rediscovering a digit that was
previously present.

16

Figure 9: SQAIR trained on a harder version of moving-textscmnist. Input images (top) and SQAIR reconstructions
with marked glimpse locations (bottom)

G Failure cases of SQAIR

Figure 10: Examples of ID swaps in
a version of SQAIR without proposal
glimpse extraction in PROP (see Ap-
pendix A for details). Bounding box
colours correspond to object index
(or its identity). When PROP is al-
lowed the same access to the image
as DISC, then it often prefers to ig-
nore latent variables, which leads to
swapped inference order.

Figure 11: Examples of re-detections
in MLP-SQAIR.
Bounding box
colours correspond to object iden-
tity, assigned to it upon discovery.
In some training runs, SQAIR con-
verges to a solution, where objects
are re-detected in the second frame,
and PROP starts tracking only in the
third frame (left). Occasionally, an
object can be re-detected after it has
severely overlapped with another one
(top right). Sometimes the model de-
cides to use only DISC and repeatedly
discovers all objects (bottom right).
These failure mode seem to be mutu-
ally exclusive – they come from dif-
ferent training runs.

Figure 12: Two failed reconstructions of SQAIR. Left: SQAIR re-detects objects in the second time-step. Instead
of 5 and 2, however, it reconstructs them as 6 and 7. Interestingly, reconstructions are consistent through the
rest of the sequence. Right: At the second time-step, overlapping 6 and 8 are explained as 6 and a small 0. The
model realizes its mistake in the third time-step, re-detects both digits and reconstructs them properly.

17

H Reconstruction and Samples from the Moving-MNIST Dataset

H.1 Reconstructions

Figure 13: Sequences of input (ﬁrst row) and SQAIR reconstructions with marked glimpse locations. Reconstruc-
tions are all temporally consistent.

18

Figure 14: Sequences of input (ﬁrst row) and CONV-VRNN reconstructions. They are not temporally consistent.
The reconstruction at time t = 1 is typically of lower quality and often different than the rest of the sequence.

19

H.2 Samples

Figure 15: Samples from SQAIR. Both motion and appearance are temporally consistent. In the last sample, the
model introduces the third object despite the fact that it has seen only up to two objects in training.

20

Figure 16: Samples from CONV-VRNN. They show lack of temporal consistency. Objects in the generated
frames change between consecutive time-steps and they do not resamble digits from the training set.

21

H.3 Conditional Generation

Figure 17: Conditional generation from SQAIR, which sees only the ﬁrst three frames in every case. Top is the
input sequence (and the remaining ground-truth), while bottom is reconstruction (ﬁrst three time-steps) and then
generation.

22

I Reconstruction and Samples from the DukeMTMC Dataset

Figure 18: Sequences of input (ﬁrst row) and SQAIR reconstructions with marked glimpse locations. While not
perfect (spurious detections, missed objects), they are temporally consistent and similar in appearance to the
inputs.

23

Figure 19: Samples with marked glimpse locations from SQAIR trained on the DukeMTMC dataset. Both
appearance and motion is spatially consistent. Generated objects are similar in appearance to pedestrians in the
training data. Samples are noisy, but so is the dataset.

24

Figure 20: Conditional generation from SQAIR, which sees only the ﬁrst four frames in every case. Top is the
input sequence (and the remaining ground-truth), while bottom is reconstruction (ﬁrst four time-steps) and then
generation.

25

