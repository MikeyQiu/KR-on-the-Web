TRex: A Tomography Reconstruction Proximal
Framework for Robust Sparse View X-Ray
Applications

Mohamed Aly, Guangming Zang, Wolfgang Heidrich, and Peter Wonka

1

6
1
0
2
 
n
u
J
 

1
1
 
 
]

C
O
.
h
t
a
m

[
 
 
1
v
1
0
6
3
0
.
6
0
6
1
:
v
i
X
r
a

Abstract—We present TRex, a ﬂexible and robust Tomographic
Reconstruction framework using proximal algorithms. We pro-
vide an overview and perform an experimental comparison
between the famous iterative reconstruction methods in terms of
reconstruction quality in sparse view situations. We then derive
the proximal operators for the four best methods. We show the
ﬂexibility of our framework by deriving solvers for two noise
models: Gaussian and Poisson; and by plugging in three powerful
regularizers. We compare our framework to state of the art
methods, and show superior quality on both synthetic and real
datasets.

Index Terms—Image reconstruction, X-ray imaging and com-
puted tomography, Simultaneous Algebraic Reconstruction Tech-
nique, SART, Proximal Algorithms, Cone beam X-ray tomogra-
phy

I. INTRODUCTION

Reducing the dosage in X-ray tomography is a very impor-
tant issue in medical applications, since long term exposure
to X-rays can have adverse health effects. This can be done
in at least two ways: (a) reducing the X-ray beam power,
which leads to increased measurement noise at the detectors;
or (b) acquiring fewer projections to reduce the acquisition
time [1]. This makes the reconstruction problem even more
ill-posed, since less information is collected from the volume
to be reconstructed; and one has to use non-linear regularizers
(priors) to achieve a reasonable result. This is typically done
using iterative solvers [2], [3].

Iterative algorithms for X-ray tomography reconstruction
have been around for years. In fact, one of the ﬁrst imple-
mented tomography reconstruction algorithm was an iterative
one [4]–[6]. However, non-iterative,
transform-based algo-
rithms, such as the ﬁltered back projection (FBP) [7]–[9], have
been more popular due to their speed and low computational
cost. Moreover, most commercial X-ray CT scanners employ
some variant of FBP in their reconstruction software [10].
Recently, interest has been ignited again in iterative algorithms
because, although they are more computationally demanding,
they are much more ﬂexible and yield superior reconstruction
quality by employing powerful priors.

Thus, in this work, we study iterative reconstruction tech-
niques. We present TRex, a ﬂexible proximal framework

M Aly is with the Visual Computing Center, KAUST, KSA and is on leave

from Computer Engineering, Cairo University, Egypt

G Zang is with the Visual Computing Center, KAUST, KSA
W Heidrich is with the Visual Computing Center, KAUST, KSA
P Wonka is with the Visual Computing Center, KAUST, KSA

for robust X-Ray tomography reconstruction in sparse view
applications. TRex uses iterative algorithms, especially the
SART (Simultaneous ART) [11], [12], to solve the tomography
proximal operator. We show that they are better suited for
this task and produce better performance than state of the art,
combined with different noise models in the data terms and
with different powerful regularizers. Up to our knowledge, this
is the ﬁrst time these methods have been used to directly solve
the tomography proximal operator.

We start by conducting a thorough comparison of the
famous iterative algorithms including SART [11], ART (Al-
gebraic Reconstruction Technique) [11], SIRT (Simultaneous
Iterative Reconstruction Technique) [13], BSSART (Block
Simpliﬁed SART) [14], BICAV (Block Iterative Component
Averaging) [15], Conjugate Gradient (CG) [16], and OS-SQS
(Ordered Subset-Separable Quadratic Surrogates) [17]–[21].
We establish that SART provides the best performance in
the sparse view measurements situations, followed closely by
ART, OS-SQS, and BICAV.

We then describe our framework, TRex, which is based on
using proximal algorithms [22], [23] together with these iter-
ative methods. We derive proximal operators for SART, ART,
BICAV, and OS-SQS. We show how to use these proximal
operators to minimize two data ﬁtting terms: (a) least squares
(LS) that assumes a Gaussian noise model; and (b) weighted
least squares (WLS) that assumes an approximation to a
Poisson noise model [24]. We also show how to plug in dif-
ferent powerful regularizers; namely Isotropic Total Variation
(ITV) [25], Anisotropic Total Variation (ATV) [26], and Sum
of Absolute Differences (SAD) [27]. We perform thorough
comparisons between the different proximal operators, data
terms, and regularizers using real and synthetic data.

Finally, we compare our framework to state of the art
methods, namely the ADMM method from Ramani et al.
[28] and the OS-SQS method (with and without momentum
method) from Kim et al. [29], and show that our framework
gives superior reconstruction quality. Please consult [30] for
further details, expanded experiments, and more results.
In summary, we provide the following contributions:

1) We present TRex, a ﬂexible proximal reconstruction
framework that relies on iterative methods for directly
solving the tomography proximal operator.

2) We perform a thorough experimental comparison of
famous iterative reconstruction methods on synthetic and
real datasets.

3) We derive proximal operators for SART, ART, BICAV,

and OS-SQS; and compare them.

4) We derive solvers for different data terms assuming
different noise models, namely Gaussian and Poisson
models, using the derived proximal operators, and show
how to use our framework with different powerful reg-
ularizers.

5) We compare our framework to state of the art methods
and show that it produces superior reconstructions.
6) We make our code—which is based on the ASTRA
toolbox [31]—and data publicly available at https://
github.com/mohamedadaly/TRex.

This paper is organized as follows. In Sec. II we present
related work. An overview of the famous iterative algorithms
is detailed in Sec. III. The different proximal operators are
derived in Sec. IV. The TRex framework is explained in Sec.
V, where we show the general algorithm together with three
regularizers and two data terms. The experiments and datasets
are presented in Sec. VI, and ﬁnally the conclusions are given
in Sec. VII.

II. RELATED WORK

There are two general approaches for X-ray tomography
reconstruction: transform-based methods and iterative methods
[1], [4]. Transform methods rely on the Radon transform
and its inverse introduced in 1917. The most widely used
reconstruction method is the Filtered Backprojection (FBP)
algorithm introduced [1], [4]. Transform methods are usually
viewed as much faster than iterative methods, and have there-
fore been the method of choice for X-ray scanner manufac-
turers [10].

Iterative methods, on the other hand, use algebraic tech-
niques to solve the reconstruction problem. They generally
model the problem as a linear system and solve it using
established numerical methods [1]. ART, and its many variants,
are among the best known iterative reconstruction algorithms
[5], [11], [12], [32]–[34]. They use variations of the projection
method of Kaczmarz [35] and have modest memory require-
ments, and have been shown to yield better reconstruction
results than transform methods. They are matrix free, and work
without having to explicitly store the system matrix. OS-SQS
and related methods [17], [19], [20] are closely related to ART
and have similar properties to SIRT [36]. They have also been
shown [29] to be accelerated using momentum techniques.

Iterative methods provide more ﬂexibility in incorporating
prior information into the reconstruction process. For example,
instead of assuming a Gaussian noise model and minimizing
a least squares data term, one can easily use iterative methods
with other noise models, such as the Poisson noise model [2],
[17], [24], [37], [38] that boils down to solving WLS problem
instead. Priors are also easy to use with iterative methods.
For example, the Total Variation [25] prior has been used for
tomography reconstruction [39], [40].

Proximal algorithms have been widely used in many prob-
lems in machine learning and signal processing [22], [23],
[41], [42]. They have also been used in tomography recon-
struction [39], [40]. For example, [40] used the Alternating

2

Direction Method of Multipliers (ADMM) [22] with total
variation prior, where the data term was optimized using CG
[16]. [26] discussed using the Chambolle-Pock algorithm [43]
for tomography reconstruction with different priors. [28] used
ADMM with Preconditioned CG (PCG) [44] for optimizing
the weighted least squares data term. [21] used Linearized
ADMM [23] (also known as Inexact Split Uzawa [45]) with
Ordered Subset-based methods [19] for optimizing the data
term and FISTA [46] for optimizing the prior term. However,
none of these methods used the iterative algorithms we study
in this work as their data term solver, which provides superior
reconstruction as we will show.

There are currently a number of open source software
packages for tomography reconstruction. SNARK09 [47] is
one of the oldest. The Reconstruction ToolKit (RTK) [48]
is a high performance C++ toolkit focusing on 3D cone
beam reconstruction that is based on the image processing
package Insight ToolKit (ITK). It includes implementations of
several algorithms, including FDK, SART, and an ADMM TV-
regularized solver with CG [40]. The ASTRA toolbox [31] is a
Matlab-based GPU-accelerated toolbox for tomography recon-
struction. It includes implementations of several algorithms,
including SART, SIRT, FBP, among others. We modify and
extend ASTRA to implement our algorithms and generate the
experiments in this work.

III. ITERATIVE ALGORITHMS

Algorithm 1 Outline of Iterative Algorithms
Require: A ∈ Rm×n, α ∈ R, p ∈ Rm
1: Initialize: x(0)
2: for all t = 1 . . . T do
3:
4:
5:
6:
7: end for

for all subsets S ∈ S do
x(t+1) = x(t) + α∆x(t)
x(t+1) = clip(x(t+1))

end for

return volume reconstruction x ∈ Rn

The tomography problem can be represented as solving a

linear system [1], [4]

Ax = p,

(1)

where x ∈ Rn is the unknown volume in vector form,
A ∈ Rm×n is the projection system matrix, and p ∈ Rm
represents the measured line projections (sinogram). The iter-
ative algorithms that we study in this work all have the same
general outline in Alg. 1, but differ in the update formula in
step 4. The subset S in step 3 can be only 1 projection ray
as in ART i.e. there are m subsets Si = {i | i = 1 . . . m}; can
contain all the rays in a projection view as in SART i.e. there
are m/s subsets where s is the number of projection views;
or can contain the whole projection rays as in SIRT i.e. there
is only one subset S = {1, . . . , m}. Step 5 clips the negative
values of the volume, which is assumed to be non-negative.
The update step ∆x(t) is typically a function of (a subset
of) the forward projection error pS − ASx(t) that is then back

3

projected with some normalization procedure. It can take the
form

∆x(t) = Φ

(cid:16)

S , pS − ASx(t)(cid:17)
AT

and C perform scaling for the relevant entries. It has been
shown [14], [50] that SIRT converges to a solution of the
WLS problem

where the function Φ(·) computes the required update, AS
contains a subset of the rows of A, similarly for pS–please
see below. This can be seen as an approximation to the actual
gradient AT (p − Ax) of the least square objective

arg min
x

(cid:107)Ax − p(cid:107)2
2

and so these algorithms can be viewed as variations of
(stochastic) gradient descent [29] where they differ on how
they approximate the gradient. We also notice that the inner
loop in step 3 for all these algorithms takes roughly the same
time, since it involves one full sweep over the rows of A.

Below we quickly review the different methods, and Table

I provides a summary of their important properties.

1) ART:

[5], [6] is the ﬁrst algebraic method, and is
based on Kaczmarz alternating projection algorithm [35]. ART
treats each row of A in turn, and updates the current estimate
according to

x(t+1)
j

= x(t)

j + α

pi − (cid:80)
(cid:80)

k aikx(t)
k a2
ik

k

aij for i = 1 . . . m,

where x(t)
is the jth voxel at time t, aij is the entry in the
j
ith row and jth column of A and α ∈ R is the relaxation
parameter. This update is performed once for each row of A,
and one iteration includes a full pass over all the m rows.
The term (cid:80)
is the forward projection of the volume
estimate for the ith ray (equation or row), the difference in the
numerator is the projection error, that is then back projected
by multiplying the transpose of the ith row. It has been shown
that ART converges to a least-norm solution to the consistent
system of equations [49] i.e. it solves

k aikx(t)

k

x(cid:63) = arg min

(cid:107)x(cid:107)2

2 s. t. Ax = p.

x

(2)

In matrix notation, this can be also expressed as

x(t+1) = x(t) + αAT

i R−1 (cid:16)

pi − Aix(t)(cid:17)

where Ai ∈ Rn is the ith row of A and R ∈ Rm×m =
diag(ri) is a diagonal matrix where ri = (cid:80)
2 is
the squared-norm of the ith row Ai.

ij = (cid:107)Ai(cid:107)2

j a2

2) SIRT:

[13] performs the updates simultaneously i.e.
updates the volume once instead of updating it per each row
Ai. The update equation becomes

x(t+1)
j

= x(t)

j + α

1
(cid:80)m
i=1 aij

m
(cid:88)

i=1

pi − (cid:80)n
(cid:80)n

k=1 aikx(t)
k=1 aik

k

aij.

In matrix form this becomes

x

x(cid:63) = arg min

(cid:107)Ax − p(cid:107)2

(Ax − p)T R−1(Ax − p)

R−1 = min
x

(3)
for 0 < α < 2. SIRT has been shown [36] to be closely
related, and in fact quite equivalent in terms of convergence
properties, to the OS-SQS method. It has also been shown to
converge best for α = 2 − (cid:15) for a small 0 < (cid:15) (cid:28) 1.

3) SART:

[11] is a tradeoff between ART and SIRT, in
that it updates the volume after processing all the rows in a
particular projection view. The update equation becomes
k=1 aikx(t)
k=1 aik

pi − (cid:80)n
(cid:80)n

1
i∈S aij

= x(t)

x(t+1)
j

j + α

(cid:88)

aij

(cid:80)

k

i∈S

for S ∈ S where the summation i ∈ S is across all rows (rays)
in projection view S for all views S. This has been shown to
provide faster convergence than ART and better reconstruction
results than SIRT [51], [52]. In matrix form it becomes
pS − ASx(t)(cid:17)

x(t+1) = x(t) + αC −1

S R−1 (cid:16)

S AT

where AS ∈ Rs×n contains the s rows in projection S,
pS contains the corresponding s rays from the projection
measurements, R contains the row sums as in SIRT, while
CS = diag(cS
j ) contains the column sums restricted to the
rows in S i.e. cS
i∈S aij. There is still no proof of
convergence for SART in the literature, but there are proofs
for variants of SART, such as BSSART and BICAV below,
that converge to a minimum-norm solution like ART. This
motivates us to assume that SART solves approximately the
least norm problem in Eq. 2.

j = (cid:80)

4) BSSART:

[14] is a slight simpliﬁcation of SART, where
the column sums in the update equation are done over all the
rows of A instead of just over the rows in the current view,
which is quite similar to SIRT. The update equation becomes

x(t+1)
j

= x(t)

j + α

1
(cid:80)m
i=1 aij

(cid:88)

i∈S

pi − (cid:80)n
(cid:80)n

k=1 aikx(t)
k=1 aik

k

aij

for S ∈ S , which provides a slight speedup since the
column sums are now independent of the iteration. The matrix
formulation becomes

x(t+1) = x(t) + αC −1AT

S R−1 (cid:16)

pS − ASx(t)(cid:17)

where the diagonal matrices are both independent of the
projection view S as in SIRT. BSSART has been shown [14]
to converge to the minimum norm solution

x(cid:63) = arg min

(cid:107)x(cid:107)2

2 s. t. Ax = p

x

x(t+1) = x(t) + αC −1AT R−1 (cid:16)

p − Ax(t)(cid:17)

as ART for 0 < α < 2.

where C ∈ Rn×n = diag(cj) is a diagonal matrix where
cj = (cid:80)
i aij is the sum of column j of A and R = diag(ri)
where ri = (cid:80)
j aij is the sum of row i of A. In each iteration,
SIRT performs a full forward projection Ax(t), computes the
residual, and then back projects it. The diagonal matrices R

5) BICAV:

[14], [15] is another closely-related algorithm
to SART. It updates the volume after each projection view
according to

x(t+1)
j

= x(t)

j + α

1
cS
j

(cid:88)

i∈S

pi − (cid:80)n
(cid:80)n

k=1 aikx(t)
k=1 a2
ik

k

aij

Update Step

Subset

Solved Problem

Converges

Method

ART [5]

SIRT [13]

SART [11]

BSSART [14]

BICAV [15]

OS-SQS [19]

x(t+1)
j

= x(t)

j + α

x(t+1) = x(t) + αAT

k

pi − (cid:80)
k aikx(t)
(cid:80)
k a2
ik
i R−1 (cid:16)

pi − Aix(t)(cid:17)

aij

x(t+1)
j

= x(t)

j + α

1
(cid:80)m
i=1 aij

m
(cid:88)

i=1

k=1 aikx(t)
k=1 aik

k

pi − (cid:80)n
(cid:80)n
p − Ax(t)(cid:17)

aij

x(t+1) = x(t) + αC−1AT R−1 (cid:16)

x(t+1)
j

= x(t)

j + α

x(t+1) = x(t) + αC−1

x(t+1)
j

= x(t)

j + α

(cid:88)

i∈S

(cid:80)

1
i∈S aij
S AT

S R−1 (cid:16)

k

k=1 aikx(t)
k=1 aik

pi − (cid:80)n
(cid:80)n
p − AS x(t)(cid:17)

aij

1
(cid:80)m
i=1 aij

(cid:88)

i∈S

S R−1 (cid:16)

k

pi − (cid:80)n
k=1 aikx(t)
(cid:80)n
k=1 aik
pS − AS x(t)(cid:17)

aij

x(t+1) = x(t) + αC−1AT

x(t+1)
j

= x(t)

j + α

(cid:80)

x(t+1) = x(t) + αC−1

1
i∈S {aij (cid:54)= 0}
S R−1 (cid:16)
S AT

(cid:88)

pi − (cid:80)n
(cid:80)n
pS − AS x(t)(cid:17)

i∈S

k=1 aikx(t)
k=1 a2
ik

k

aij

x(t+1)
j

= x(t)

j +

(cid:0)(cid:80)m

αs

x(t+1) = x(t) + αsC−1AT
S

k=1 akj
(cid:16)

(cid:1)

(cid:80)n
i=1 aki
pS − AS x(t)(cid:17)

i∈S

(cid:32)

(cid:88)

pi −

(cid:33)

aikx(t)
k

aij

n
(cid:88)

k=1

CGLS [16], [44]

x(t+1) = x(t) + αtΦ (cid:0)AT (p − Ax(t))(cid:1)

4

Yes

No

Yes

Yes

No

Yes

x(cid:63) = arg minx (cid:107)Ax − p(cid:107)2

R−1

Yes

one
ray

all
rays

one
view

one
view

one
view

one
view

all
rays

x(cid:63) = arg min

(cid:107)x(cid:107)2
2

x

s. t. Ax = p

x(cid:63) ≈ arg min

(cid:107)x(cid:107)2
2

s. t. Ax = p

x(cid:63) = arg min

(cid:107)x(cid:107)2
2

s. t. Ax = p

x(cid:63) = arg min

(cid:107)x(cid:107)2
2

s. t. Ax = p

x

x

x

x(cid:63) ≈ (cid:107)Ax − p(cid:107)2
2

x(cid:63) = (cid:107)Ax − p(cid:107)2
2

Table I: Summary of iterative methods and their properties. The ﬁrst line in the update step is voxel-based, while the second
is the matrix formulation. See Sec. III for details.

j = (cid:80)

for S ∈ S where cS
i∈S{aij (cid:54)= 0} and {aij (cid:54)= 0} =
1 when aij is non-zero is 0 otherwise. The difference from
SART is that it computes the squared norm of the rows of A
and counts the number of non-zero entries in the columns of
A. The matrix formulation is

where the matrix C = diag(AT A1m) = diag(cj) where 1m
is the vector of m ones. OS-SQS is a special case of the
SQS method, which processes all the rows of A at once like
SIRT. Simultaneous SQS, i.e. without ordered subsets, has
been shown [19] to converge to a least square solution

x(t+1) = x(t) + αC −1

S AT

S R−1 (cid:16)

pS − ASx(t)(cid:17)

where now ri = (cid:80)
ij = (cid:107)Ai(cid:107)2
j ). It
is shown [14] that BICAV converges to the minimum-norm
solution

2 and CS = diag(cS

j a2

(cid:107)x(cid:107)2 s. t. Ax = p

min
x

for 0 < α < 2.
6) OS-SQS:

[19], [29] is closely related to SART. It is
usually derived from a majorization-minimization perspective
[17], [19], [20], [29], but with a speciﬁc choice of surrogate
functions and parameters [20] the update equation becomes

x(t+1)
j

= x(t)

j + α

s
cj

(cid:88)

i∈S

(cid:32)

pi −

n
(cid:88)

k=1

(cid:33)

aikx(t)
k

aij

for S ∈ S where s is the number of subsets S in S (number of
inner iterations), cj = ((cid:80)m
i=1 aki), and in general
k=1 akj
the set S can contain more than one projection view. In matrix
form it becomes

(cid:80)n

x(t+1) = x(t) + αsC −1AT
S

(cid:16)

pS − ASx(t)(cid:17)

x(cid:63) = arg min

(cid:107)Ax − p(cid:107)2
2,

x

(4)

and a special case of relaxed OS-SQS converges, where the re-
laxation parameter becomes iteration-dependent and decreases
over time [53]. However, OS-SQS with ﬁxed α is not known
to converge. Therefore, like SART, we assume that it solves
the LS problem in Eq. 4 above approximately.

7) CGLS:

[16], [44] is a type of Conjugate Gradient that
solves the least squares normal equations directly. Like SIRT,
it updates the constraint once per full sweep over the projection
rays. The update equation in matrix notation is

x(t+1) = x(t) + αtΦ(AT (p − Ax(t)))

where the update step is a function of the backprojection of the
projection error, and the parameter αt depends on the speciﬁc
version of CGLS (here we use the Fletcher-Reeves update rule
[16]). CGLS is proven to be convergent to the solution of the
LS problem in Eq. 4.

x(cid:63) = arg min

(cid:107)Ax − p(cid:107)2
2.

x

Note that the function Φ(·) is more complicated than other
iterative algorithms, and involves several steps with a couple
of auxiliary variables [16].

IV. TOMOGRAPHY PROXIMAL OPERATORS

Proximal algorithms are a class of optimization algorithms
that are quite ﬂexible and powerful [22], [23], [42]. They are
generally used to efﬁciently solve non-smooth, constrained,
distributed, or large scale optimization problems. They are
more modular than other optimization problems, in the sense
that they provide a few lines of code that depend on solving
smaller conventional, and usually simpler, optimization prob-
lems called proximal operator. The proximal operator [23],
[41], [42] for a function h(·) is a generalization of projections
on convex sets, and can be thought of intuitively as getting
closer to the optimal solution while staying close to the current
estimate. Formally it is deﬁned as

proxλh(u) = arg min

h(x) +

(cid:107)x − u(cid:107)2
2,

(5)

x

1
2λ

where x, u ∈ Rn and λ is a regularization parameter. Many
proximal operators of common functions are easy to compute,
and often admit a closed form solution. Computing the prox-
imal operator of a certain function opens the way to solving
hard optimization problems involving this function and other
regularization terms e.g. smoothing norms or sparsity inducing
norms, which otherwise is not generally easy. We will derive
tomography proximal operators for SART, ART, BICAV, and
OS-SQS, where the objective is to solve

proxλh(u) = arg min

(cid:107)Ax − p(cid:107)2

2 +

(cid:107)x − u(cid:107)2
2.

(6)

1
2λ

A. SART, ART, and BICAV

They (approximately) solve the least-norm problem

x(cid:63) = arg min

(cid:107)x(cid:107)2

2 s. t. Ax = p.

What we want is a solver for Eq. 6. This is equivalent to
solving

min
x

2λ(cid:107)Ax − p(cid:107)2
√

2 + (cid:107)x − u(cid:107)2
2.

Introduce new variables y =
The problem becomes

2λ(p − Ax) and z = x − u.

x

x

5

where ˜x ∈ Rm+n, ˜A ∈ Rm×m+n, and ˜p ∈ Rm. This is now a
consistent under-determined linear system, and can be solved
using either ART, SART, or BICAV.

Although we introduced new variables y and z and in-
creased the dimensionality of the problem from n to n + m,
we can solve the modiﬁed algorithm efﬁciently with very
little computational overhead. Instead of solving explicitly for
the optimal y(cid:63) and z(cid:63), we can manipulate the algorithm to
solve directly for the optimal x(cid:63). For example, for SART, the
initialization and update equation for ˜x become

˜x(0)
j

= 0,

˜x(t+1)
j

= ˜x(t)

j + α

(cid:80)

i∈S

k

˜pi−(cid:80)
k ˜aik ˜x(t)
(cid:80)
k ˜aik
i∈S ˜aij

(cid:80)

˜aij

,

(9)

which can be expanded in terms of y, z, and A as

y(0) = 0m
z(0) = 0n

y(t+1)
j

= y(t)

j +

z(t+1)
j

= z(t)

j + α

√

˜pi−

α (cid:80)

i∈S

√

˜pi−

(cid:80)

i∈S

2λ (cid:80)
√
2λ (cid:80)
1
2λ (cid:80)
√
2λ (cid:80)
√
2λ (cid:80)

k −y(t)

i

k aikz(t)
k aik+1

δij

,

k −y(t)

i

k aikz(t)
k aik+1
i∈S aij

√

2λaij

,

where δij = 1 when i = j and 0 otherwise. Using the fact that
√
k aikuk and simplifying
z = x − u and ˜pi =
we arrive at

2λpi −

2λ (cid:80)

√

y(0) = 0m
x(0) = u

y(t+1)
j

= y(t)

j + α

x(t+1)
j

= x(t)

j + α

k − y(t)

i

δij,

√

(cid:88)

i∈S
(cid:80)

i∈S

√

2λ (cid:80)

2λpi −
√

√

2λ (cid:80)
√
2λ (cid:80)
2λpi−
√
2λ (cid:80)
√
2λ (cid:80)

k aikx(t)
k aik + 1
k aikx(t)
k aik+1
i∈S aij

k −y(t)

i

√

2λaij

.

(7)

Following the same line of reasoning, we can arrive at
similar update formulas for both ART and BICAV. The steps
are summarized in Table II. Alg. 2 provides an outline of the
proximal operator.

min
y,z

s. t.

(cid:107)y(cid:107)2

2 + (cid:107)z(cid:107)2
2
√

√

B. OS-SQS

y +

2λAz =

2λ(p − Au).

(8)

We want to express the proximal operator problem

Rewriting Eq. 8 we arrive at

miny,z

subject to

(cid:2) I

(cid:13)
(cid:20) y
(cid:13)
(cid:13)
z
(cid:13)
(cid:20) y
2λA (cid:3)
z

√

(cid:21)(cid:13)
2
(cid:13)
(cid:13)
(cid:13)
2

(cid:21)

√

=

2λ (p − Au)

which can be written as

min˜x
s. t.

(cid:107)˜x(cid:107)2
2
˜A˜x = ˜p,

proxλh(u) = arg min

h(x) +

1
2λ

(cid:107)x − u(cid:107)2
2

in the form of the LS problem that can be solved (approxi-
mately) by OS-SQS i.e.

x(cid:63) = arg min

(cid:107)Ax − p(cid:107)2
2.

x

x

Rewrite as

arg min
x

2λ(cid:107)Ax − p(cid:107)2

2 + (cid:107)x − u(cid:107)2
2,

6

Converges

Method

ART [5]

SART [11]

BICAV [15]

k − y(t)

i

for i ∈ S

k − y(t)

i

√

2λaij for j = 1 . . . n

y(t+1)
i

= y(t)

i + α

x(t+1)
j

= x(t)

j + α

y(t+1)
i

= y(t)

i + α

x(t+1)
j

= x(t)

j + α

y(t+1)
i

= y(t)

i + α

x(t+1)
j

= x(t)

j + α

√

√

2λpi −

2λpi −

√

2λpi −
√

√

(cid:80)

i∈S

√

2λpj −

√

(cid:80)

i∈S

Update Step

√

2λ (cid:80)
√

2λ (cid:80)

2λ (cid:80)
√

2λ (cid:80)
k aikx(t)
k a2
ik + 1
2λ (cid:80)
k aikx(t)
k a2
ik + 1
k aikx(t)
2λ (cid:80)
k aik + 1
√
2λ (cid:80)
2λ (cid:80)
2λ (cid:80)
2λ (cid:80)
k ajkx(t)
k a2
jk + 1
√
2λ (cid:80)

√
√

√

k aikx
k aik+1
i∈S aij

2λ (cid:80)

2λpi−

2λpi−

k aikx
ik+1

2λ (cid:80)
k a2
i∈S {aij (cid:54)= 0}

(cid:80)

k − y(t)

i

for i ∈ S

(t)
k −y

(t)
i

√

2λaij

k − y(t)

j

for i ∈ S

(t)
k −y

(t)
i

√

2λaij

for j = 1 . . . n

for j = 1 . . . n


 for j = 1 . . . n

Yes

No

Yes

No

OS-SQS [19]

x(t+1)
j

= x(t)

j + α

aikx(t)

k )aij + uj − x(t)

j


2λ

s
2λcj + 1

(pj −

(cid:88)

i∈S

(cid:88)

k

Table II: Summary of the proximal operators update steps. See Sec. IV for details.

Algorithm 2 SART, ART, and BICAV Proximal Operator
Require: A ∈ Rm×n, α, λ ∈ R, p ∈ Rm, u ∈ Rn
1: Initialize:

x(0) = u
y(0) = 0m

2: for all t = 1 . . . T do
3:
4:

for all subsets S ∈ S do

Update according to Table II:

x(t+1)
j
y(t+1)
i

= x(t)
= y(t)

j + α∆x(t)
i + α∆y(t)

j

i

for j = 1 . . . n

for i ∈ S

x(t+1) = clip(x(t+1))

5:
6:
7: end for

end for

return x(cid:63) = arg minx (cid:107)Ax − p(cid:107)2

2 + 1

2λ (cid:107)x − u(cid:107)2

2

which is equivalent to

outline.

(cid:20) √
(cid:13)
(cid:13)
(cid:13)
(cid:13)

arg min
x

⇐⇒ arg min

x

(cid:21)

x −

2λA
I
(cid:13)
(cid:13)
2
˜Ax − ˜p
(cid:13)
(cid:13)
(cid:13)
(cid:13)
2

(cid:20) √

2λp
u

(cid:21)(cid:13)
2
(cid:13)
(cid:13)
(cid:13)
2

where

˜A =

˜p =

(cid:20) √

(cid:20) √

(cid:21)

(cid:21)

2λA
I

2λp
u

∈ Rm+n×n

∈ Rm+n.

The weighting matrix ˜C ∈ Rn×n now becomes

˜C = diag( ˜AT ˜A1)

= diag (cid:0)(2λAT A + I)1(cid:1)
= diag (cid:0)2λAT A1 + 1(cid:1)

and its diagonal entries are

˜cj = 2λcj + 1.
Write the matrix update equation in terms of ˜A and ˜p as
(cid:16)

x(t+1) = x(t) + αs ˜C −1 ˜AT
S

˜pS − ˜ASx(t)(cid:17)
(cid:104) √

√

= x(t) + αs ˜C −1 [
= x(t) + αs ˜C −1(2λAT

2λAT

S I ]

S (pS −AS x(t))+(u−x(t))).

2λ(pS −AS x(t))
u−x(t)

(cid:105)

In component form it becomes

x(t+1)
j

= x(t)

j + α

2λ (cid:80)

i∈S (pj −(cid:80)

k aikx(t)

k )aij +uj −x(t)

j

(cid:17).

(cid:16)

s
˜cj

The steps are summarized in Table II. Alg. 3 gives an

V. TREX PROXIMAL FRAMEWORK

A. Proximal Algorithm

ﬁtting problem, namely

The overall problem we want to solve is a regularized data

arg min
x

f (x) + g(Kx),

(10)

where f (·) is a data ﬁtting term that measures how much the
solution ﬁts the data and that depends on the measurement
noise model assumed, K ∈ Rd×n is a matrix, and g(·) is
a regularization term that imposes constraints on acceptable
solutions. We will use the Linearized ADMM method [22],
[23] (also known as Inexact Split Uzawa [45], [54] or Proximal

Algorithm 3 OS-SQS Proximal Operator
Require: A ∈ Rm×n, α, λ ∈ R, p ∈ Rm, u ∈ Rn
1: Initialize:

and this gives the modiﬁed x step

x(t+1) = arg min

f (x) +

(cid:107)Kx − z(t) + y(t)(cid:107)2+

for j = 1 . . . n according

(x − x(t))T S(x − x(t))

(cid:107)Kx(cid:107)2 − ρ(cid:104)Kx, z(t) − y(t)(cid:105)+

f (x) +

(cid:107)Kx(cid:107)2 − ρ(cid:104)x, K T (z(t) − y(t))(cid:105)+

x(0) = 0n

2: for all t = 1 . . . T do
3:
4:

for all subsets S ∈ S do
j + α∆x(t)
= x(t)

x(t+1)
j

j

x(t+1) = clip(x(t+1))

to Table II.

5:
6:
7: end for

end for

return x(cid:63) = arg minx (cid:107)Ax − p(cid:107)2

2 + 1

2λ (cid:107)x − u(cid:107)2

2

ADMM [55]–[58]), for solving this problem for different data
terms and different regularizers.

It rewrites Eq. 10 into the equivalent form

f (x) + g(z)

arg min
x,z
s. t. Kx = z,

writes out the scaled augmented Lagrangian function [23]

Lρ(x, z, y) = f (x) + g(z) +

(cid:107)Kx − z + y(cid:107)2
2,

ρ
2

and then applies alternating minimization for the variables x,
z, and y in turn:

x(t+1) = arg min

f (x) +

z(t+1) = arg min

g(z) +

x

z

(cid:107)Kx − z(t) + y(t)(cid:107)2

ρ
2
ρ
(cid:107)Kx(t+1) − z + y(t)(cid:107)2
2

y(t+1) = y(t) + Kx(t+1) − z(t+1).

The problem with the x step is that it contains the quadratic
term (cid:107)Kx(cid:107)2 = xT K T Kx in the minimization makes it hard
to minimize since it’s not straightforward. We can cancel out
that term by adding the following proximal term that makes it
strongly convex and keeps the solution close to the previous
iteration

to the objective fundtion where the special matrix S is

1
2

(cid:107)x − xk(cid:107)2

S =

(x − xk)T S(x − xk)

1
2

1
µ

S =

I − ρK T K

7

x

x

x

x

(cid:107)x − x(t)(cid:107)2
S

1
2
= arg min

f (x) +

1
2
= arg min

ρ
2

ρ
2

ρ
2

(cid:107)x(cid:107)2

1
2
= arg min

S − (cid:104)x, Sx(t)(cid:105)
f (x)+

1
2µ
= arg min

x

f (x)+
(cid:107)x − x(t) − µρK T (cid:16)

1
2µ

(cid:107)x − µρK T (z(t) − y(t)) − µSx(t)(cid:107)2

z(t) − y(t) − Kx(t)(cid:17)

(cid:107)2

which is simply the proximal operator of f (x) with input
x(t) + µρ (cid:0)z(t) − u(t) − K T Kx(t)(cid:1) i.e.
the iterations now
become

x(t+1) = proxµf

(cid:16)

x(t) + µρK T (cid:16)
Kx(t+1) + y(t)(cid:17)
(cid:16)

z(t+1) = proxρ−1g
y(t+1) = y(t) + Kx(t+1) − z(t+1).

z(t) − y(t) − Kx(t)(cid:17)(cid:17)

The algorithm is convergent for any ρ > 0 and µ > 1/ρ(cid:107)K(cid:107)2
[21], [23]. The steps are summarized in Alg. 4. This frame-
work is very ﬂexible, and we will show how to solve for
different data terms and different regularizers.

Algorithm 4 Linearized ADMM
Require: K ∈ Rd×n, ρ, µ ∈ R such that µρ(cid:107)K(cid:107)2 < 1, initial

values x(0) ∈ Rn and z(0) ∈ Rd

1: Initialize y(0) = 0d
2: for all t = 1 . . . T do
3:

4:

5:
6: end for

(cid:0)x(t) − ρµK T (Kx(t) − z(t) + y(t))(cid:1)

x(t+1) = proxµf
z(t+1) = proxρ−1g
y(t+1) = y(t) + Kx(t+1) − z(t+1)

(cid:0)Kx(t+1) + y(t)(cid:1)

return x(T ) = arg minx f (x) + g(Kx)

B. Data Terms

We will consider the following data ﬁdelity terms, which

correspond to speciﬁc noise models:

1) Gaussian Noise: Assume the measurements pi∀i =

1, . . . m follow the model

pi = aT

i x + εi

(11)
where the noise ε ∼ N(0, σ2) follows a Gaussian distribution.
Maximizing the projection data log-likelihood
i x(cid:1)2

(cid:0)pi − aT

LG(p) ∝ −

(12)

(cid:88)

i

8

is equivalent to minimizing the LS (cid:96)2 norm data term

fG(x) = (cid:107)Ax − p(cid:107)2

2 =

(AT

i x − pi)2.

(13)

m
(cid:88)

i=1

We can solve proximal operator proxλfG
of the algorithms from Table II.

(·) directly using any

2) Poisson Noise: It can be shown that assuming an approx-
imated Poisson noise model leads to a WLS data term, where
the weights are proportional to the detector measurements [2],
[17], [24], [37]. Indeed, the actual measurements produced by
the X-ray CT scanner represent X-ray photon energy reaching
the detector as compared to the energy leaving the X-ray gun.
These are related to each other and to the linear attenuation
coefﬁcient according to Beer-Lambert law [59]:

It = Ioe−

´

µ(l)dl

where It
is the transmitted intensity as measured by the
detector, Io is the emitted intensity from the source, µ(l) is the
linear attenuation coefﬁcient of the material as a function of
length l. The exponent represents the line integrals (projection
data) we are dealing with. In particular, assuming that the X-
ray photons are monochromatic (have only one single energy)
i.e. ignoring beam hardening, the projection line integral data
at detector i is obtained from the physical measurements as

where I i

pi = − ln

I i
t
I i
o
t is the intensity measured by detector i and I i

o is
the emitted intensity. The detector measurements are stochastic
in nature, and assuming a Poisson distribution with mean
I i
o exp(−pi) we get

(14)

t ∼ P(I i
I i

oe−pi ) ≈ P(I i

oe−AT

i x).

on detector i i.e. wi ∝ I i
t . Typically, the weights wi are
normalized to have a maximum of 1, and we could apply any
non-decreasing mapping on wi, e.g. the square root, before
feeding into the optimization problem, see Sec. VI-C.

Maximizing the likelihood is equivalent to minimizing the

WLS data term

fP(x) = (cid:107)Ax − p(cid:107)2

W =

wi(aT

i x − pi)2

(17)

m
(cid:88)

i=1

where (cid:107)x(cid:107)W = xT W x and W = diag(wi) ∈ Rm×m is a
diagonal matrix containing weights for each measurement.

We can solve the proximal operator

proxλfP

(u) = min

x

(cid:107)Ax − p(cid:107)2

W +

(cid:107)x − u(cid:107)2

(18)

1
2λ

as follows. Deﬁne ˜p ∈ Rm and ˜A ∈ Rm×n as

where W 1

2 = diag (cid:0)√

(cid:107) ˜Ax − ˜p(cid:107)2

1
2 p
1
2 A

˜p = W
˜A = W
(cid:1) . We get
2 = ( ˜Ax − ˜p)T ( ˜Ax − ˜p)
(cid:17)T (cid:16)

wi

(cid:16)

W

1
2 (Ax − p)

=

W

1
2 (Ax − p)

(cid:17)

= (Ax − p)T W
= (cid:107)Ax − p(cid:107)2
W .

1
2 W

1
2 (Ax − p)

Now this is in the form that can be solved with the algorithms
in Table II

proxλfP

(u) = min

x

(cid:107) ˜Ax − ˜p(cid:107)2 +

(cid:107)x − u(cid:107)2

1
2λ

with input matrix ˜A and projections ˜p.

Using the ML approach, we maximize the log-likelihood of

C. Regularizers

the measured data:

LP (x) =

(cid:88)

I i
t ln

(cid:16)

i x(cid:17)

oe−AT
I i

− I i

oe−AT

i x =

(cid:88)

(cid:0)AT

φi

The regularizers impose constraints on the reconstruction

volume. We consider the following regularizers:

i

1) Isotropic Total Variation (ITV):

It is the sum of the

i x(cid:1)
(15)

i

where

φi(q) = I i

t ln (cid:0)I i

oe−q(cid:1) − I i

oe−q.

Applying a second-order Taylor’s expansion for φi(q)
around an estimate of the ith line integral pi from Equation
14 [37]:

φi(q) ≈ φi(pi) +

(pi)(q − pi) +

dφi
dq

1
2

d2φi
dq2 (pi)(q − pi)2

= (I i

t ln I i

t − I i

t ) −

(q − pi)2

I i
t
2

The ﬁrst term is independent of q and can be dropped (since we
are interested in minimizing LP (x)). Substituting in Equation
15, we end up with the approximated log-likelihood

LG(x) ≈ −

(cid:0)AT

i x − pi

(cid:1)2

= −

(cid:88)

wi

(cid:0)AT

i x − pi

(cid:1) 2

I i
t
2

(cid:88)

i

(16)
where wi is the weight for projection measurement i and is
proportional to the measurement of the incident X-ray intensity

gradient magnitude at each voxel [25], [26], [43] i.e.

(cid:88)

hITV(x) = gITV(Kx) = σ(cid:107)x(cid:107)TV = σ

(cid:107)∇xi(cid:107)2

(19)

where ∇xi = [ ∇x1
i containing the horizontal forward different ∇x1
vertical forward difference ∇x2
form of Eq. 10

i
i ]T is the discrete gradient at voxel
i and the
i . It can be represented in the

i ∇x2

hITV(x) = gITV(Kx)
by deﬁning the matrix K = D ∈ R2n×n to be the forward
difference matrix that produces the discrete gradient ∇x ∈
R2n





∇xi
...
∇xn
and deﬁning for u ∈ R2n = (cid:2)uT

∇x =




1


 = Dx

· · · uT
n

(cid:3)T

gITV(u) = σ

(cid:107)ui(cid:107)2

(cid:88)

i

The proximal operator proxλgITV

(u) is [43], [45]

proxλgITV

(ui) = u −

λσui
max(λσ, (cid:107)ui(cid:107)2)

(20)

where ui ∈ R2 is the ith component of u. Intuitively it projects
back the vector ui to be on the Euclidean ball of radius σ.

2) Anisotropic Total Variation (ATV): It is a simpliﬁcation

of ITV [39], and is deﬁned as

hATV(x) = σ(cid:107)∇x(cid:107)1

(21)

which is the (cid:96)1 norm of the gradient ∇x of the volume. It can
be written in the form of Eq. 10

hATV(x) = gATV(Kx)

by deﬁning K = D as in the ITV case and deﬁning for u ∈
R2n

gATV(u) = σ(cid:107)u(cid:107)1 = σ

(cid:107)ui(cid:107)1.

(cid:88)

i

The proximal operator proxλgATV

(u) is [43], [45]

proxλgITV

(ui) = sign(ui) (cid:12) max(0, |ui| − σ)

(22)

which is the soft thresholding function [26], where the max
and product are component-wise operations.

3) Sum of Absolute Differences (SAD): It is an extension
to the ATV by adding more forward differences around each
voxel [27]. In particular, it sums the differences of the voxels
in the 3 × 3 neighborhood around each voxel

hSAD(x) = σ

|xi − xk|

(23)

(cid:88)

(cid:88)

i

k∈N (i)

where N (i) contains the voxels in the neighborhood around
voxel i. It can be written similarly in the form

hSAD(x) = gSAD(Kx)
by deﬁning K ∈ R8n×n that computes the 8 forward differ-
ences in the 3 × 3 neighborhood and deﬁning for u ∈ R8n

gSAD(u) = σ(cid:107)u(cid:107)1 = σ

(cid:107)ui(cid:107)1.

(cid:88)

i

The proximal operator proxλgATV

(u) is similar to the ATV case:

proxλgITV

(ui) = sign(ui) (cid:12) max(0, |ui| − σ).

(24)

The SAD prior has been shown [27] to produce excellent
results in stochastic tomography reconstruction.

VI. EXPERIMENTS
A. Datasets and Implementation Details

We present experiments on two simulated phantoms and one
real dataset, see Fig. 1. The phantoms are: the modiﬁed 2D
Shepp-Logan head phantom [60]; and a 2D slice of the NCAT
phantom [61]. The phantoms were generated at a resolution of
512 × 512 pixels, and ground truth sinograms were generated
in ASTRA using a fan beam geometry with 888 detectors,
isotropic pixels of 1 mm, isotropic detectors of 1.0239 mm,
and source-to-detector distance of 949.075 mm. We assumed
Poisson measurement noise with emitted intensity count I0 =
105 to generate the noisy projections used.

9

The real dataset is a 2D slice of a 3D cone beam scan of
a mouse from the Exxim Cobra software 1. The data contains
194 projections (over 194 degrees) of a fan beam geometry
with 512 detectors of size 0.16176 mm, source-to-detector
distance of 529.29 mm, source-to-isocenter distance of 395.73
mm, and reconstructed volume of 512×512 pixels of isotropic
size 0.12 mm. We ran 500 iterations of BSSART with α = 0.1
to generate the ground truth volume, but we note that results
on this dataset should be taken with a grain of salt. We measure
performance in terms of SNR (signal-to-noise ratio) deﬁned as

SNR(x, ˆx) = 10 log

(cid:80)

j ˆx2
j
j (xj − ˆxj)2

(cid:80)

where x ∈ Rn is the current estimate of the volume and ˆx ∈
Rn is the ground truth volume.

We clip the reconstruction estimate x at the end of each
inner iteration (i.e. after each update step) using this function

clip(x) = max(0, x)

to get rid of negative voxel values.

We implemented all methods using ASTRA with a mix of
C++ and Matlab code. The iterative algorithms not present
in ASTRA, namely BICAV, BSSART, and OS-SQS, were
implemented in C++. The proximal operators were also im-
plemented in C++. The Linearized ADMM was implemented
in Matlab. We also modiﬁed existing algorithms in ASTRA
to suit our needs e.g. compute SNR, report run times, etc. All
experiments were run on one core of an Intel Xeon E5-280
2.7 GHz with 64 GB RAM.

B. Iterative Algorithms Comparison

We ﬁrst compare the different iterative algorithms presented
in Sec. III on the datasets. We set the number of subsets in OS-
SQS to the number of projections to have a fair comparison
with SART, since we noticed that increasing the number of
subsets increases the convergence rate. We compare different
values of α, namely 0.1, 1, and 1.99. We compare convergence
per iteration since all methods are roughly equal in runtime, as
each outer iteration contains (roughly) one forward and one
backward projection. This is conﬁrmed in Fig. 3. Note that
our implementation is not optimized for any of the methods,
and the processing time is just an indication. We initialize all
methods with uniform volume x(0) = 0n.

Fig. 2 shows the SNR per iteration for 15, 30, 90 projec-
tions for 30 iterations. Fig. 4 shows the the maximum SNR
over 30 iterations for different number of equally distributed
projections from 15 to 180. From the ﬁgures, we make the
following conclusions:

• The simulated projections closely resemble the results
from the real dataset, which suggests that the measure-
ment noise model is reﬂective of real data.

• With fewer projections (15 or 30 projections), using larger
values α = 1.99 gives faster and better convergence.
• With many projections, moderate values α = 1 produces
a fast convergence that then falls off and is overtaken by
α = 0.1.

1available from http://www.exxim-cc.com/

10

(a) Modiﬁed Shepp-Logan

(b) NCAT

(c) Mouse

Figure 1: The datasets used. (c) shows the ground truth converged result from the projections.

• SART provides the fastest convergence within a handful
of iterations, and is consistently better for fewer pro-
jections. However, it is overtaken by ART and others
for many projections. This provides the motivation to
use it in the proximal framework, since typically the
tomography solver is invoked for only a few iterations
per outer iteration of ADMM for example [28].

that

• With more projections, e.g. 90, we notice that the SNR for
a few methods go up and then down. This doesn’t mean,
they are not converging. The objective
however,
function is the reprojection error not the SNR. This can
be explained by the fact of the presence of noise, and that
at some point the algorithm starts ﬁtting the noise in the
measurements [1]. Usually these kinds of algorithms are
run interactively where the user inspects the reconstruc-
tion quality every few iterations and stops the procedure
when it starts to deteriorate, which motivates Fig. 4.
• Even though BICAV, SIRT, and BSSART have formal
proofs of convergence, their convergence speed per iter-
ation is in fact much lower than SART or (this version
of) OS-SQS, that lack these proofs.

• The faster convergence and best results are achieved by
SART, followed by ART, OS-SQS, and BICAV. They
work better with α = 1 for few projections, and with
α = 0.1 for more projections.

• CGLS,

that was used before for solving tomography
problems [26], [28], performs quite poorly compared to
the other iterative algorithms.

• Using plain iterative methods does not give acceptable
results with fewer projections. Thus we focus next on
using regularizers in the proximal framework with SART,
ART, OS-SQS, and BICAV and fewer projections, namely
30 projections.

C. Poisson Model Mapping Functions Comparison

We investigate different mapping functions for the Poisson
noise model fP(·) in Eq. 17 using the ITV regularizer from
Eq. 19 using the ADMM algorithm. We compare applying
different mapping functions on the weights, since we noticed

√

√
wi, and the cubic root r3 = 3

it improves the performance for some proximal operators. In
particular, we try three functions: identity r1(wi) = wi, the
wi. Figure 5
square root r2 =
shows results for the three datasets for 15 and 30 projections
with σ = 0.1 in Eq. 19. We set ρ = 100 and µ = 1/ρ(cid:107)K(cid:107)2
except for OS-SQS which was tuned manually as this default
value didn’t provide good performance.

We note the following that using mapping r1 is generally
worse than r2 and r3. This is especially true for OS-SQS,
BICAV, and ART. We believe this is due to the normalizing
matrix C, where in this case it includes sum of squares of
entries in the matrix A that are typically < 1. This makes
them even smaller, and taking the square or cubic root of the
weights, which are also < 1, makes them bigger to counter-
balance the former effect, and make the two terms of the
optimization problem in Eq. 5 of the same order. This is not
the case in SART where the C matrix contains sums of entries
of A. We also note that ART and SART provide very similar
performance, closely followed by BICAV and then OS-SQS.
This is also conﬁrmed in the comparison in Sec. VI-E.

D. Data Terms and Regularizers Comparison

We compare the different data terms and regularizers de-
ﬁned in Sec. V. We solve the tomography proximal operator
(step 3 in Alg. 4) using 2 iterations of the SART proximal
operator (from Table II), using α = 1.99 with for 15 and 30
projections (see Sec. VI-B). We use σ = 0.05 and ρ = 25 for
15 projections; σ = 0.1 and ρ = 50 for 30 projections; and set
µ = 1/ρ(cid:107)K(cid:107)2. We initialize all methods with uniform volume
x(0) = 0n. We estimated the matrix norm (cid:107)K(cid:107) using the
power method. Fig. 6 shows the results for the three datasets,
where we plot against the number of SART iterations. We note
the following:

• Using the proximal framework provides signiﬁcantly bet-
ter results than the unregularized iterative methods in Sec.
VI-B. This is expected since adding a powerful regular-
izer constrains the reconstruction to better resemble the
ground truth.

• The Poisson noise model fP(·) is better than the Gaussian
noise model fG(·) for the datasets, specially with more

11

(a) Modiﬁed Shepp-Logan

(b) NCAT

(c) Mouse

Figure 2: Iterative Algorithms Comparison. Plots show SNR per iteration. Solid lines have α = 1, dashed lines have
α = 1.99, and dotted lines have α = 0.1.

12

(a) Modiﬁed Shepp-Logan

(b) NCAT

(c) Mouse

Figure 3: Running Time Comparison. Curves show SNR per running time for 90 projections . Compare with Fig. 2 (bottom
row).

(a) Modiﬁed Shepp-Logan

(b) NCAT

(c) Mouse

Figure 4: Effect of the number of projections. Plots show the maximum SNR achieved over 30 iterations per number of
projections used.

projections. This is consistent with the noise model used
to generate the noisy simulated sinograms, and with the
physical noise model in the real dataset.

• With more projections, more regularization (higher σ)
produces better results while for fewer projections less
regularization is sufﬁcient . This is expected because
using more projections adds more constraints (rows in
the projection matrix A) that need better regularization
to get good results.

• The SAD regularizer is better for all datasets.

E. Proximal Operators Comparison

We compare the different proximal operators from Sec. IV
(SART, ART, OS-SQS, and BICAV) and Table II using our
proximal framework in Alg. 4. We use the best regularizer
from Sec. VI-D, i.e. SAD regularizer, and both the Poisson

and Gaussian noise models. For the Poisson model, we use
r1 mapping for SART, and r3 for ART, BICAV, and OS-SQS
since r1 does produce good results (see Sec. VI-C). We set
σ = 0.05 and ρ = 50 for 15 projections; and σ = 0.1 and
ρ = 100 for 30 projections. We set µ = 1/ρ(cid:107)K(cid:107)2 except for OS-
SQS which had to be tuned manually. We note the following:

• The Poisson model is consistently better than the Gaus-

sian model for all operators and all datasets.

• SART proximal operator is generally better than other
proximal operators, and ART and BICAV are quite com-
petitive.

• OS-SQS provides the worst performance. We think this
has to do with structure of the update formula in Table
II, where the gradient update AT
S (pS − ASx(t)) is added
to the difference between the current estimate and the
input to the proximal operator u − x(t), where the scaling

13

(a) Modiﬁed Shepp-Logan

(b) NCAT

(c) Mouse

Figure 5: TRex Poisson Model Mapping Functions Comparison. Curves show SNR per iteration for the Poisson noise
models with mapping functions r1 (diamonds), r2 (asterisks), and r3 (squares). See Sec. VI-C.

(a) Modiﬁed Shepp-Logan

(b) NCAT

(c) Mouse

Figure 6: Data Terms and Regularizers Comparison. Plots show SNR per iteration for the Gaussian (solid curves) and
Poisson (dashed curves)noise models with ITV (blue), ATV (red), and SAD (green) regularizers. The black curve shows the
results for SART. See Sec. VI-D.

between the two terms has to be adjusted properly. That
is the reason µ had to be carefully tuned to get better
results.

The ADMM-PCG minimizes a combination of a WLS data

term and regularization term

F. Comparison to State of the Art

We compare our framework to two state of the art methods:
the ADMM-PCG method of Ramani et al. [28] and the OS-
MOM method from Kim et al. [29] that combines ordered
subsets with momentum. We don’t compare to the method
of Nien et al. [21] because the authors indicate that
the
performance is closely matched by the OS-MOM method and
is quite similar.

min
x

1
2

(cid:107)p − Ax(cid:107)2

W + λ

κr(cid:107)Rxr(cid:107)1

n
(cid:88)

r=1

where κr ∈ R are spatial weights that govern the spatial
resolution in the reconstruction and Rxr ∈ Rd is the vector
of wavelet decomposition at voxel xr. It uses 2 iterations
of PCG to solve the proximal operator of the data term, as
opposed to our framework that uses SART, ART, ... etc. We
run the Matlab code available online from the author as part

14

(a) Modiﬁed Shepp-Logan

(b) NCAT

(c) Mouse

Figure 7: TRex Proximal Operators Comparison. Plots show SNR per iteration for the Gaussian (solid curves) and Poisson
(dashed curves) noise models with SAD regularizer. See Sec. VI-E.

of the IRT toolbox2. The default procedure for choosing the
parameters didn’t work well with our datasets, so we had to
manually tweak the parameters, [28]. We set ν = 2 × 105,
λ = 10−3, and µ = 10−4 for 15 projections and µ = 10−3
for 30 projections. We use the Wavelet decomposition basis
with the (cid:96)1 norm regularizer.

The OS-Mom also minimizes a WLS data term and regu-

larization term

min
x

1
2

(cid:107)p − Ax(cid:107)2

W + β

ψ(∇xr)

n
(cid:88)

r=1

where ψ(·) is an edge preserving potential function and
∇xr ∈ R2 is the gradient at voxel xr. We implemented
the Momentum 2 method (Table IV in [29]) within the IRT
toolbox. We use the settings from the paper for the regularizer
i.e. the Fair potential

ψ(t) =

+ b(b − a)

+ (a − b) log(1 + b

(cid:32)

ab2
2

2

(cid:12)
(cid:12)
(cid:12)
(cid:12)

t
δ

(cid:12)
(cid:12)
(cid:12)
(cid:12)

δ2
b3

(cid:12)
(cid:12)
(cid:12)
(cid:12)

t
δ

(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:33)

(cid:12)
(cid:12)
(cid:12)
(cid:12)

t
δ

(cid:12)
(cid:12)
(cid:12)
(cid:12)

)

with δ = 10, a = 0.0558, and b = 1.6395, and bit reversal
for subset ordering. We tweaked β and M [29] to get good
performance. We set β = 0.05 and M = 5 subsets for
15 projections and β = 0.1 and M = 10 subsets for 30
projections. We use relaxation with parameter 10−3 to help
the convergence. We also compare to plain OS method without
momentum with the same WLS data term and regularizer as
OS-Mom.

Fig. 8 shows a comparison with these two algorithm. The
TRex uses the SART proximal operator with Poisson noise
model and r1 mapping and SAD regularizer. We set σ = 0.05
and ρ = 25 for 15 projections and σ = 0.1 and ρ = 50 for 30
projections, and set µ = 1/ρ(cid:107)K(cid:107)2. We initialize all methods
with a uniform volume x(0) = 0n. Fig. 9 shows sample

2available from http://web.eecs.umich.edu/~fessler/code/

reconstruction results for 30 projections after 30 iterations.
We note the following:

• The ADMM-PCG method’s performance is quite bad
with these datasets. They require a lot of tweaking to get
them to work correctly since the automated estimation
methods described in [28] didn’t work. Moreover, the
method seems very sensitive to the values of the param-
eters, and thus is harder to tweak.

• The OS-Mom method indeed accelerates the convergence
of the OS method at early iterations [29]. However, its
performance is not consistent across datasets, where some
times it is good and most of the time the SNR starts
decreasing after a while, even with relaxation.

• TRex with SART and SAD consistently performs better
and ends up with higher SNR than ADMM-PCG or
OS-Mom. Moreover, it is easier to tweak and not very
sensitive to the choice of parameters. Note that for NCAT
and Mouse, using TRex, we get SNR with 15 projections
that equals the SNR we get with 30 projections using
plain SART.

VII. CONCLUSIONS
We presented TRex, a ﬂexible proximal framework for
robust tomography reconstruction in sparse view applications.
TRex relies on using iterative methods, e.g. SART, for directly
solving the tomography proximal operator. We ﬁrst compare
the famous tomography iterative solvers, and then derive prox-
imal operators for the best four methods. We then show how to
use TRex to solve using different noise models (Gaussian and
Poisson) and using different powerful regularizers (ITV, ATV,
and SAD). We show that TRex outperforms state of the art
methods, namely ADMM-PCG [28] and OS-Mom [29], and
is easy to tune. We conclude that SART—even though is not
guaranteed to converge—offers the best tomography solver for
sparse view applications, followed closely by ART and BICAV.

15

(a) Modiﬁed Shepp-Logan

(b) NCAT

(c) Mouse

Figure 8: TRex Comparison to Sate of the Art. Plots show SNR per iteration. The TRex framework uses SART with Poisson
model and SAD regularizer. The dotted curve shows the baseline plain SART (from Sec. VI-B). See Sec. VI-F.

(a) Modiﬁed Shepp-Logan

(b) NCAT

(c) Mouse

Figure 9: TRex Comparison to Sate of the Art. Reconstruction results for 30 projections after 30 iterations. TRex uses SART
with Poisson model and SAD regularizer. See Sec. VI-F.

We plan to extend this work in several ways: (a) study how
to incorporate momentum acceleration into SART as in [29];
(b) study how to use preconditioners with SART such as the
Fourier-based cone ﬁlter preconditioners [44]; (c) study other
applications such as low-dosage X-ray tomography, which
changes the nature of the measurement noise [62]; and (d)
implement and apply TRex to 3D cone beam reconstruction
and compare to other famous packages such as RTK [40].

ACKNOWLEDGMENTS

This work was supported by KAUST baseline and research

center funding.

REFERENCES

[1] G. T. Herman, Fundamentals of computerized tomography: image recon-
struction from projections. Springer Science & Business Media, 2009.
[2] J.-B. Thibault, K. D. Sauer, C. A. Bouman, and J. Hsieh, “A three-
dimensional statistical approach to improved image quality for multislice
helical ct,” Medical physics, vol. 34, no. 11, pp. 4526–4544, 2007.
[3] R. Zhang, J.-B. Thibault, C. A. Bouman, K. D. Sauer, and J. Hsieh,
“Model-based iterative reconstruction for dual-energy x-ray ct using a
joint quadratic likelihood model,” Medical Imaging, IEEE Transactions
on, vol. 33, no. 1, pp. 117–134, 2014.

[4] A. C. Kak and M. Slaney, Principles of computerized tomographic
imaging. Society for Industrial and Applied Mathematics, 2001.
[5] R. Gordon, R. Bender, and G. T. Herman, “Algebraic reconstruction
techniques (art) for three-dimensional electron microscopy and x-ray
photography,” Journal of theoretical Biology, vol. 29, no. 3, pp. 471–
481, 1970.

[6] R. Gordon and G. T. Herman, “Reconstruction of pictures from their
projections,” Communications of the ACM, vol. 14, no. 12, pp. 759–
768, 1971.

[7] G. Ramachandran and A. Lakshminarayanan, “Three-dimensional re-
construction from radiographs and electron micrographs: application
of convolutions instead of fourier transforms,” PNAS, vol. 68, no. 9,
pp. 2236–2240, 1971.

[8] L. A. Shepp and B. F. Logan, “The fourier reconstruction of a head
section,” Nuclear Science, IEEE Transactions on, vol. 21, no. 3, pp. 21–
43, 1974.

[9] L. Feldkamp, L. Davis, and J. Kress, “Practical cone-beam algorithm,”
Journal of the Optical Society of America, vol. 1, no. 6, pp. 612–619,
1984.

[10] X. Pan, E. Y. Sidky, and M. Vannier, “Why do commercial ct scanners
still employ traditional, ﬁltered back-projection for image reconstruc-
tion?,” Inverse problems, vol. 25, no. 12, p. 123009, 2009.

[11] A. Andersen and A. C. Kak, “Simultaneous algebraic reconstruction
technique (sart): a superior implementation of the art algorithm,” Ultra-
sonic imaging, vol. 6, no. 1, pp. 81–94, 1984.

[12] A. H. Andersen, “Algebraic reconstruction in ct from limited views,”
Medical Imaging, IEEE Transactions on, vol. 8, no. 1, pp. 50–55, 1989.
[13] P. Gilbert, “Iterative methods for the reconstruction of three-dimensional
objects from projections,” J. theor. Biol, vol. 36, no. 105, pp. 117–127,
1972.

[14] Y. Censor and T. Elfving, “Block-iterative algorithms with diagonally
scaled oblique projections for the linear feasibility problem,” SIAM
Journal on Matrix Analysis and Applications, vol. 24, no. 1, pp. 40–
58, 2002.

[15] Y. Censor, D. Gordon, and R. Gordon, “Bicav: A block-iterative parallel
algorithm for sparse systems with pixel-related weighting,” Medical
Imaging, IEEE Transactions on, vol. 20, no. 10, pp. 1050–1060, 2001.
[16] A. Björck, Numerical methods for least squares problems. Siam, 1996.
[17] A. R. De Pierro, “A modiﬁed expectation maximization algorithm
for penalized likelihood estimation in emission tomography.,” IEEE
Transactions on Medical Imaging, vol. 14, no. 1, pp. 132–137, 1994.

[18] H. M. Hudson and R. S. Larkin, “Accelerated image reconstruction using
ordered subsets of projection data,” Medical Imaging, IEEE Transactions
on, vol. 13, no. 4, pp. 601–609, 1994.

[19] H. Erdogan and J. A. Fessler, “Ordered subsets algorithms for trans-
mission tomography,” Physics in medicine and biology, vol. 44, no. 11,
p. 2835, 1999.

16

[20] D. Kim, D. Pal, J.-B. Thibault, and J. A. Fessler, “Accelerating ordered
subsets image reconstruction for x-ray ct using spatially nonuniform
optimization transfer,” Medical Imaging, IEEE Transactions on, vol. 32,
no. 11, pp. 1965–1978, 2013.

[21] H. Nien and J. Fessler, “Fast x-ray ct image reconstruction using a
linearized augmented lagrangian method with ordered subsets,” Medical
Imaging, IEEE Transactions on, vol. 34, pp. 388–399, Feb 2015.
[22] S. Boyd, N. Parikh, E. Chu, B. Peleato, and J. Eckstein, “Distributed
optimization and statistical learning via the alternating direction method
of multipliers,” Foundations and Trends R(cid:13) in Machine Learning, vol. 3,
no. 1, pp. 1–122, 2011.

[23] N. Parikh and S. Boyd, “Proximal algorithms,” Foundations and Trends

in Optimization, vol. 1, no. 3, pp. 123–231, 2013.

[24] N. H. Clinthorne, T.-S. Pan, P.-C. Chiao, W. Rogers, and J. Stamos,
“Preconditioning methods for improved convergence rates in iterative
reconstructions,” Medical Imaging, IEEE Transactions on, vol. 12, no. 1,
pp. 78–83, 1993.

[25] L. I. Rudin, S. Osher, and E. Fatemi, “Nonlinear total variation based
noise removal algorithms,” Physica D: Nonlinear Phenomena, vol. 60,
no. 1, pp. 259–268, 1992.

[26] E. Y. Sidky, J. H. Jørgensen, and X. Pan, “Convex optimization problem
prototyping for image reconstruction in computed tomography with the
chambolle–pock algorithm,” Physics in medicine and biology, vol. 57,
no. 10, p. 3065, 2012.

[27] J. Gregson, M. Krimerman, M. B. Hullin, and W. Heidrich, “Stochastic
tomography and its applications in 3d imaging of mixing ﬂuids,” ACM
Trans. Graph. (Proc. SIGGRAPH 2012), vol. 31, no. 4, pp. 52:1–52:10,
2012.

[28] S. Ramani and J. A. Fessler, “A splitting-based iterative algorithm for
accelerated statistical x-ray ct reconstruction,” Medical Imaging, IEEE
Transactions on, vol. 31, no. 3, pp. 677–688, 2012.

[29] D. Kim, S. Ramani, and J. A. Fessler, “Combining ordered subsets
and momentum for accelerated x-ray ct image reconstruction,” Medical
Imaging, IEEE Transactions on, vol. 34, no. 1, pp. 167–178, 2015.
[30] M. Aly, G. Zang, W. Heidrich, and P. Won, “A tomography recon-
struction proximal framework for robust sparse view x-ray applications,”
arXiv preprint arXiv:xyz.

[31] W. van Aarle, W. J. Palenstijn, J. De Beenhouwer, T. Altantzis, S. Bals,
K. J. Batenburg, and J. Sijbers, “The astra toolbox: A platform for
in electron tomography,” Ultrami-
advanced algorithm development
croscopy, vol. 157, pp. 35–47, 2015.

[32] A. Lent, “A convergent algorithm for maximum entropy image restora-
tion, with a medical x-ray application,” Image Analysis and Evaluation,
pp. 249–257, 1977.

[33] L. A. Shepp and Y. Vardi, “Maximum likelihood reconstruction for
emission tomography,” Medical Imaging, IEEE Transactions on, vol. 1,
no. 2, pp. 113–122, 1982.

[34] Y. Censor, “Finite series-expansion reconstruction methods,” Proceed-

ings of the IEEE, vol. 71, no. 3, pp. 409–419, 1983.

[35] S. Kaczmarz, “Angenäherte auﬂösung von systemen linearer gleichun-
gen,” Bulletin International de l’Academie Polonaise des Sciences et des
Lettres, vol. 35, pp. 355–357, 1937.

[36] J. Gregor and J. A. Fessler, “Comparison of sirt and sqs for regularized
weighted least squares image reconstruction,” Computational Imaging,
IEEE Transactions on, vol. 1, no. 1, pp. 44–55, 2015.

[37] I. A. Elbakri and J. A. Fessler, “Statistical image reconstruction for
polyenergetic x-ray computed tomography,” Medical Imaging, IEEE
Transactions on, vol. 21, no. 2, pp. 89–99, 2002.

[38] J. Wang, T. Li, H. Lu, and Z. Liang, “Penalized weighted least-squares
approach to sinogram noise reduction and image reconstruction for low-
dose x-ray computed tomography,” Medical Imaging, IEEE Transactions
on, vol. 25, no. 10, pp. 1272–1283, 2006.

[39] E. Y. Sidky and X. Pan, “Image reconstruction in circular cone-beam
total-variation minimization,”

computed tomography by constrained,
Physics in medicine and biology, vol. 53, no. 17, p. 4777, 2008.
[40] C. Mory, B. Zhang, V. Auvray, M. Grass, D. Schafer, F. Peyrin, S. Rit,
P. Douek, and L. Boussel, “Ecg-gated c-arm computed tomography using
l1 regularization,” in Signal Processing Conference (EUSIPCO), 2012
Proceedings of the 20th European, pp. 2728–2732, IEEE, 2012.
[41] H. H. Bauschke and P. L. Combettes, Convex analysis and monotone
operator theory in Hilbert spaces. Springer Science & Business Media,
2011.

[42] P. L. Combettes and J.-C. Pesquet, “Proximal splitting methods in signal
processing,” in Fixed-point algorithms for inverse problems in science
and engineering, pp. 185–212, Springer, 2011.

17

[43] A. Chambolle and T. Pock, “A ﬁrst-order primal-dual algorithm for
convex problems with applications to imaging,” Journal of Mathematical
Imaging and Vision, vol. 40, no. 1, pp. 120–145, 2011.

[44] J. A. Fessler and S. D. Booth, “Conjugate-gradient preconditioning
methods for shift-variant pet image reconstruction,” Image Processing,
IEEE Transactions on, vol. 8, no. 5, pp. 688–699, 1999.

[45] E. Esser, X. Zhang, and T. F. Chan, “A general framework for a class
of ﬁrst order primal-dual algorithms for convex optimization in imaging
science,” SIAM Journal on Imaging Sciences, vol. 3, no. 4, pp. 1015–
1046, 2010.

[46] A. Beck and M. Teboulle, “A fast iterative shrinkage-thresholding algo-
rithm for linear inverse problems,” SIAM Journal on Imaging Sciences,
vol. 2, no. 1, pp. 183–202, 2009.

[47] J. Klukowska, R. Davidi, and G. T. Herman, “Snark09–a software
package for reconstruction of 2d images from 1d projections,” Computer
methods and programs in biomedicine, vol. 110, no. 3, pp. 424–440,
2013.

[48] S. Rit, M. V. Oliva, S. Brousmiche, R. Labarbe, D. Sarrut, and G. C.
Sharp, “The reconstruction toolkit (rtk), an open-source cone-beam ct
reconstruction toolkit based on the insight toolkit (itk),” in Journal of
Physics: Conference Series, vol. 489, p. 012079, IOP Publishing, 2014.
[49] K. Tanabe, “Projection method for solving a singular system of linear
equations and its applications,” Numerische Mathematik, vol. 17, no. 3,
pp. 203–214, 1971.

[50] M. Jiang and G. Wang, “Convergence of the simultaneous algebraic
reconstruction technique (sart),” Image Processing, IEEE Transactions
on, vol. 12, no. 8, pp. 957–961, 2003.

[51] K. Mueller and R. Yagel, “Rapid 3-d cone-beam reconstruction with the
simultaneous algebraic reconstruction technique (sart) using 2-d texture
mapping hardware,” Medical Imaging, IEEE Transactions on, vol. 19,
no. 12, pp. 1227–1237, 2000.

[52] K. Mueller, R. Yagel, and J. J. Wheller, “Fast

implementations of
algebraic methods for three-dimensional reconstruction from cone-beam
data,” Medical Imaging, IEEE Transactions on, vol. 18, no. 6, pp. 538–
548, 1999.

[53] S. Ahn and J. A. Fessler, “Globally convergent image reconstruction
for emission tomography using relaxed ordered subsets algorithms,”
Medical Imaging, IEEE Transactions on, vol. 22, no. 5, pp. 613–626,
2003.

[54] X. Zhang, M. Burger, and S. Osher, “A uniﬁed primal-dual algorithm
framework based on bregman iteration,” Journal of Scientiﬁc Computing,
vol. 46, no. 1, pp. 20–46, 2011.

[55] J. Eckstein, “Some saddle-function splitting methods for convex pro-
gramming,” Optimization Methods and Software, vol. 4, no. 1, pp. 75–
83, 1994.

[56] M. Fazel, T. K. Pong, D. Sun, and P. Tseng, “Hankel matrix rank
minimization with applications to system identiﬁcation and realization,”
SIAM Journal on Matrix Analysis and Applications, vol. 34, no. 3,
pp. 946–977, 2013.

[57] C. Chen, R. H. Chan, S. Ma, and J. Yang, “Inertial proximal admm for
linearly constrained separable convex optimization,” SIAM Journal on
Imaging Sciences, vol. 8, no. 4, pp. 2239–2267, 2015.

[58] G. Yuan and B. Ghanem, “l0tv: A new method for image restoration in
the presence of impulse noise,” in CVPR, vol. 23, pp. 2448–2478, 2015.
[59] J. Hsieh, Computed Tomography: Principles, Design, Artifacts, and

Recent Advances. SPIE Press, 2009.

[60] P. A. Toft and J. A. Sørensen, The Radon transform-theory and im-
plementation. PhD thesis, Technical University of DenmarkDanmarks
Tekniske Universitet, Department of Informatics and Mathematical Mod-
elingInstitut for Informatik og Matematisk Modellering, 1996.

[61] W. P. Segars and B. M. Tsui, “Study of the efﬁcacy of respiratory gating
in myocardial spect using the new 4-d ncat phantom,” Nuclear Science,
IEEE Transactions on, vol. 49, no. 3, pp. 675–679, 2002.

[62] J. Xu and B. M. Tsui, “Quantifying the importance of the statistical as-
sumption in statistical x-ray ct image reconstruction,” Medical Imaging,
IEEE Transactions on, vol. 33, no. 1, pp. 61–73, 2014.

