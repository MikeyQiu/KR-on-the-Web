8
1
0
2
 
r
p
A
 
7
2
 
 
]

G
L
.
s
c
[
 
 
2
v
2
1
4
9
0
.
0
1
7
1
:
v
i
X
r
a

Published as a conference paper at ICLR 2018

mixup: BEYOND EMPIRICAL RISK MINIMIZATION

Hongyi Zhang
MIT

Moustapha Cisse, Yann N. Dauphin, David Lopez-Paz∗
FAIR

ABSTRACT

Large deep neural networks are powerful, but exhibit undesirable behaviors such
as memorization and sensitivity to adversarial examples. In this work, we propose
mixup, a simple learning principle to alleviate these issues. In essence, mixup trains
a neural network on convex combinations of pairs of examples and their labels.
By doing so, mixup regularizes the neural network to favor simple linear behavior
in-between training examples. Our experiments on the ImageNet-2012, CIFAR-10,
CIFAR-100, Google commands and UCI datasets show that mixup improves the
generalization of state-of-the-art neural network architectures. We also ﬁnd that
mixup reduces the memorization of corrupt labels, increases the robustness to
adversarial examples, and stabilizes the training of generative adversarial networks.

1

INTRODUCTION

Large deep neural networks have enabled breakthroughs in ﬁelds such as computer vision (Krizhevsky
et al., 2012), speech recognition (Hinton et al., 2012), and reinforcement learning (Silver et al., 2016).
In most successful applications, these neural networks share two commonalities. First, they are
trained as to minimize their average error over the training data, a learning rule also known as the
Empirical Risk Minimization (ERM) principle (Vapnik, 1998). Second, the size of these state-of-the-
art neural networks scales linearly with the number of training examples. For instance, the network of
104 images in the CIFAR-10 dataset,
Springenberg et al. (2015) used 106 parameters to model the 5
the network of (Simonyan & Zisserman, 2015) used 108 parameters to model the 106 images in the
1010 parameters to model
ImageNet-2012 dataset, and the network of Chelba et al. (2013) used 2
the 109 words in the One Billion Word dataset.

·

·

Strikingly, a classical result in learning theory (Vapnik & Chervonenkis, 1971) tells us that the
convergence of ERM is guaranteed as long as the size of the learning machine (e.g., the neural
network) does not increase with the number of training data. Here, the size of a learning machine is
measured in terms of its number of parameters or, relatedly, its VC-complexity (Harvey et al., 2017).

This contradiction challenges the suitability of ERM to train our current neural network models, as
highlighted in recent research. On the one hand, ERM allows large neural networks to memorize
(instead of generalize from) the training data even in the presence of strong regularization, or in
classiﬁcation problems where the labels are assigned at random (Zhang et al., 2017). On the other
hand, neural networks trained with ERM change their predictions drastically when evaluated on
examples just outside the training distribution (Szegedy et al., 2014), also known as adversarial
examples. This evidence suggests that ERM is unable to explain or provide generalization on testing
distributions that differ only slightly from the training data. However, what is the alternative to ERM?

The method of choice to train on similar but different examples to the training data is known as data
augmentation (Simard et al., 1998), formalized by the Vicinal Risk Minimization (VRM) principle
(Chapelle et al., 2000). In VRM, human knowledge is required to describe a vicinity or neighborhood
around each example in the training data. Then, additional virtual examples can be drawn from the
vicinity distribution of the training examples to enlarge the support of the training distribution. For
instance, when performing image classiﬁcation, it is common to deﬁne the vicinity of one image
as the set of its horizontal reﬂections, slight rotations, and mild scalings. While data augmentation
consistently leads to improved generalization (Simard et al., 1998), the procedure is dataset-dependent,
and thus requires the use of expert knowledge. Furthermore, data augmentation assumes that the

∗Alphabetical order.

1

Published as a conference paper at ICLR 2018

examples in the vicinity share the same class, and does not model the vicinity relation across examples
of different classes.

Contribution Motivated by these issues, we introduce a simple and data-agnostic data augmenta-
tion routine, termed mixup (Section 2). In a nutshell, mixup constructs virtual training examples

˜x = λxi + (1
˜y = λyi + (1

λ)xj,
λ)yj,

−
−

where xi, xj are raw input vectors
where yi, yj are one-hot label encodings

(xi, yi) and (xj, yj) are two examples drawn at random from our training data, and λ
[0, 1].
Therefore, mixup extends the training distribution by incorporating the prior knowledge that linear
interpolations of feature vectors should lead to linear interpolations of the associated targets. mixup
can be implemented in a few lines of code, and introduces minimal computation overhead.

∈

Despite its simplicity, mixup allows a new state-of-the-art performance in the CIFAR-10, CIFAR-
100, and ImageNet-2012 image classiﬁcation datasets (Sections 3.1 and 3.2). Furthermore, mixup
increases the robustness of neural networks when learning from corrupt labels (Section 3.4), or facing
adversarial examples (Section 3.5). Finally, mixup improves generalization on speech (Sections 3.3)
and tabular (Section 3.6) data, and can be used to stabilize the training of GANs (Section 3.7). The
source-code necessary to replicate our CIFAR-10 experiments is available at:

https://github.com/facebookresearch/mixup-cifar10.

To understand the effects of various design choices in mixup, we conduct a thorough set of ablation
study experiments (Section 3.8). The results suggest that mixup performs signiﬁcantly better than
related methods in previous work, and each of the design choices contributes to the ﬁnal performance.
We conclude by exploring the connections to prior work (Section 4), as well as offering some points
for discussion (Section 5).

2 FROM EMPIRICAL RISK MINIMIZATION TO mixup

In supervised learning, we are interested in ﬁnding a function f
that describes the relationship
between a random feature vector X and a random target vector Y , which follow the joint distribution
P (X, Y ). To this end, we ﬁrst deﬁne a loss function (cid:96) that penalizes the differences between
predictions f (x) and actual targets y, for examples (x, y)
P . Then, we minimize the average of
the loss function (cid:96) over the data distribution P , also known as the expected risk:

∈ F

∼

(cid:90)

R(f ) =

(cid:96)(f (x), y)dP (x, y).

Unfortunately, the distribution P is unknown in most practical situations. Instead, we usually have
P for all i = 1, . . . , n. Using
access to a set of training data
the training data

n
i=1, where (xi, yi)
(xi, yi)
}
{
, we may approximate P by the empirical distribution

∼

=

D

D

Pδ(x, y) =

δ(x = xi, y = yi),

1
n

n
(cid:88)

i=1

where δ(x = xi, y = yi) is a Dirac mass centered at (xi, yi). Using the empirical distribution Pδ, we
can now approximate the expected risk by the empirical risk:

(cid:90)

Rδ(f ) =

(cid:96)(f (x), y)dPδ(x, y) =

(cid:96)(f (xi), yi).

(1)

1
n

n
(cid:88)

i=1

Learning the function f by minimizing (1) is known as the Empirical Risk Minimization (ERM)
principle (Vapnik, 1998). While efﬁcient to compute, the empirical risk (1) monitors the behaviour
of f only at a ﬁnite set of n examples. When considering functions with a number parameters
comparable to n (such as large neural networks), one trivial way to minimize (1) is to memorize the
training data (Zhang et al., 2017). Memorization, in turn, leads to the undesirable behaviour of f
outside the training data (Szegedy et al., 2014).

2

Published as a conference paper at ICLR 2018

# y1, y2 should be one-hot vectors
for (x1, y1), (x2, y2) in zip(loader1, loader2):

lam = numpy.random.beta(alpha, alpha)
x = Variable(lam * x1 + (1. - lam) * x2)
y = Variable(lam * y1 + (1. - lam) * y2)
optimizer.zero_grad()

loss(net(x), y).backward()

optimizer.step()

(a) One epoch of mixup training in PyTorch.

Figure 1: Illustration of mixup, which converges to ERM as α

0.

→

(b) Effect of mixup (α = 1) on a
toy problem. Green: Class 0. Or-
ange: Class 1. Blue shading indicates
p(y = 1|x).

However, the na¨ıve estimate Pδ is one out of many possible choices to approximate the true distribu-
tion P . For instance, in the Vicinal Risk Minimization (VRM) principle (Chapelle et al., 2000), the
distribution P is approximated by

Pν(˜x, ˜y) =

xi, yi),
ν(˜x, ˜y
|

1
n

n
(cid:88)

i=1

where ν is a vicinity distribution that measures the probability of ﬁnding the virtual feature-target
pair (˜x, ˜y) in the vicinity of the training feature-target pair (xi, yi). In particular, Chapelle et al.
xi, σ2)δ(˜y = yi), which is equivalent
(2000) considered Gaussian vicinities ν(˜x, ˜y
xi, yi) =
−
N
|
to augmenting the training data with additive Gaussian noise. To learn using VRM, we sample the
m
(˜xi, ˜yi)
ν :=
i=1, and minimize the empirical vicinal
vicinal distribution to construct a dataset
}
{
risk:
m
(cid:88)

(˜x

D

Rν(f ) =

(cid:96)(f (˜xi), ˜yi).

1
m

i=1

The contribution of this paper is to propose a generic vicinal distribution, called mixup:

xi, yi) =
µ(˜x, ˜y
|

[δ(˜x = λ

xi + (1

λ)

xj, ˜y = λ

yi + (1

λ)

yj)] ,

·

−

·

·

−

·

1
n

n
(cid:88)

j

E
λ

Beta(α, α), for α
where λ
∞
produces virtual feature-target vectors

(0,

∼

∈

). In a nutshell, sampling from the mixup vicinal distribution

˜x = λxi + (1
˜y = λyi + (1

λ)xj,
λ)yj,

−
−

where (xi, yi) and (xj, yj) are two feature-target vectors drawn at random from the training data, and
λ
[0, 1]. The mixup hyper-parameter α controls the strength of interpolation between feature-target
pairs, recovering the ERM principle as α

0.

∈

→

The implementation of mixup training is straightforward, and introduces a minimal computation
overhead. Figure 1a shows the few lines of code necessary to implement mixup training in PyTorch.
Finally, we mention alternative design choices. First, in preliminary experiments we ﬁnd that convex
combinations of three or more examples with weights sampled from a Dirichlet distribution does not
provide further gain, but increases the computation cost of mixup. Second, our current implementation
uses a single data loader to obtain one minibatch, and then mixup is applied to the same minibatch
after random shufﬂing. We found this strategy works equally well, while reducing I/O requirements.
Third, interpolating only between inputs with equal label did not lead to the performance gains of
mixup discussed in the sequel. More empirical comparison can be found in Section 3.8.

What is mixup doing? The mixup vicinal distribution can be understood as a form of data aug-
mentation that encourages the model f to behave linearly in-between training examples. We argue
that this linear behaviour reduces the amount of undesirable oscillations when predicting outside the
training examples. Also, linearity is a good inductive bias from the perspective of Occam’s razor,

3

Published as a conference paper at ICLR 2018

(a) Prediction errors in-between training data. Evalu-
ated at x = λxi +(1−λ)xj, a prediction is counted as
a “miss” if it does not belong to {yi, yj}. The model
trained with mixup has fewer misses.

(b) Norm of the gradients of the model w.r.t. input
in-between training data, evaluated at x = λxi +
(1 − λ)xj. The model trained with mixup has smaller
gradient norms.

Figure 2: mixup leads to more robust model behaviors in-between the training data.

Method

Epochs Top-1 Error Top-5 Error

ERM (Goyal et al., 2017)
mixup α = 0.2

ERM (Goyal et al., 2017)
mixup α = 0.2

ResNeXt-101 32*4d ERM (Xie et al., 2016)

ResNeXt-101 64*4d ERM (Xie et al., 2016)

Model

ResNet-50

ResNet-101

ResNet-50

ResNet-101

ERM
mixup α = 0.4

mixup α = 0.4

ERM
mixup α = 0.2

ERM
mixup α = 0.2

mixup α = 0.4

ResNeXt-101 32*4d ERM

90
90

90
90

100
90
90

100
90

200
200

200
200

200
200

23.5
23.3

22.1
21.5

21.2
21.2
20.7

20.4
19.8

23.6
22.1

22.0
20.8

21.3
20.1

-
6.6

-
5.6

-
5.6
5.3

5.3
4.9

7.0
6.1

6.1
5.4

5.9
5.0

Table 1: Validation errors for ERM and mixup on the development set of ImageNet-2012.

since it is one of the simplest possible behaviors. Figure 1b shows that mixup leads to decision
boundaries that transition linearly from class to class, providing a smoother estimate of uncertainty.
Figure 2 illustrate the average behaviors of two neural network models trained on the CIFAR-10
dataset using ERM and mixup. Both models have the same architecture, are trained with the same
procedure, and are evaluated at the same points in-between randomly sampled training data. The
model trained with mixup is more stable in terms of model predictions and gradient norms in-between
training samples.

3 EXPERIMENTS

3.1

IMAGENET CLASSIFICATION

We evaluate mixup on the ImageNet-2012 classiﬁcation dataset (Russakovsky et al., 2015). This
dataset contains 1.3 million training images and 50,000 validation images, from a total of 1,000 classes.
For training, we follow standard data augmentation practices: scale and aspect ratio distortions,
random crops, and horizontal ﬂips (Goyal et al., 2017). During evaluation, only the 224
224 central
crop of each image is tested. We use mixup and ERM to train several state-of-the-art ImageNet-2012
classiﬁcation models, and report both top-1 and top-5 error rates in Table 1.

×

4

Published as a conference paper at ICLR 2018

Dataset

Model

ERM mixup

CIFAR-10

CIFAR-100

PreAct ResNet-18
WideResNet-28-10
DenseNet-BC-190

PreAct ResNet-18
WideResNet-28-10
DenseNet-BC-190

5.6
3.8
3.7

25.6
19.4
19.0

4.2
2.7
2.7

21.1
17.5
16.8

(a) Test errors for the CIFAR experiments.

Figure 3: Test errors for ERM and mixup on the CIFAR experiments.

(b) Test error evolution for the best
ERM and mixup models.

For all the experiments in this section, we use data-parallel distributed training in Caffe21 with
a minibatch size of 1,024. We use the learning rate schedule described in (Goyal et al., 2017).
Speciﬁcally, the learning rate is increased linearly from 0.1 to 0.4 during the ﬁrst 5 epochs, and it is
then divided by 10 after 30, 60 and 80 epochs when training for 90 epochs; or after 60, 120 and 180
epochs when training for 200 epochs.

∈

For mixup, we ﬁnd that α
[0.1, 0.4] leads to improved performance over ERM, whereas for large α,
mixup leads to underﬁtting. We also ﬁnd that models with higher capacities and/or longer training
runs are the ones to beneﬁt the most from mixup. For example, when trained for 90 epochs, the mixup
variants of ResNet-101 and ResNeXt-101 obtain a greater improvement (0.5% to 0.6%) over their
ERM analogues than the gain of smaller models such as ResNet-50 (0.2%). When trained for 200
epochs, the top-1 error of the mixup variant of ResNet-50 is further reduced by 1.2% compared to the
90 epoch run, whereas its ERM analogue stays the same.

3.2 CIFAR-10 AND CIFAR-100

We conduct additional image classiﬁcation experiments on the CIFAR-10 and CIFAR-100 datasets
to further evaluate the generalization performance of mixup. In particular, we compare ERM and
mixup training for: PreAct ResNet-18 (He et al., 2016) as implemented in (Liu, 2017), WideResNet-
28-10 (Zagoruyko & Komodakis, 2016a) as implemented in (Zagoruyko & Komodakis, 2016b), and
DenseNet (Huang et al., 2017) as implemented in (Veit, 2017). For DenseNet, we change the growth
rate to 40 to follow the DenseNet-BC-190 speciﬁcation from (Huang et al., 2017). For mixup, we
ﬁx α = 1, which results in interpolations λ uniformly distributed between zero and one. All models
are trained on a single Nvidia Tesla P100 GPU using PyTorch2 for 200 epochs on the training set
with 128 examples per minibatch, and evaluated on the test set. Learning rates start at 0.1 and are
divided by 10 after 100 and 150 epochs for all models except WideResNet. For WideResNet, we
follow (Zagoruyko & Komodakis, 2016a) and divide the learning rate by 10 after 60, 120 and 180
epochs. Weight decay is set to 10−4. We do not use dropout in these experiments.

We summarize our results in Figure 3a. In both CIFAR-10 and CIFAR-100 classiﬁcation problems,
the models trained using mixup signiﬁcantly outperform their analogues trained with ERM. As seen
in Figure 3b, mixup and ERM converge at a similar speed to their best test errors. Note that the
DenseNet models in (Huang et al., 2017) were trained for 300 epochs with further learning rate
decays scheduled at the 150 and 225 epochs, which may explain the discrepancy the performance of
DenseNet reported in Figure 3a and the original result of Huang et al. (2017).

3.3 SPEECH DATA

Next, we perform speech recognition experiments using the Google commands dataset (Warden,
2017). The dataset contains 65,000 utterances, where each utterance is about one-second long and
belongs to one out of 30 classes. The classes correspond to voice commands such as yes, no, down,
left, as pronounced by a few thousand different speakers. To preprocess the utterances, we ﬁrst

1https://caffe2.ai
2http://pytorch.org

5

Published as a conference paper at ICLR 2018

Model

Method

Validation set Test set

LeNet

VGG-11

ERM
mixup (α = 0.1)
mixup (α = 0.2)

ERM
mixup (α = 0.1)
mixup (α = 0.2)

9.8
10.1
10.2

5.0
4.0
3.9

10.3
10.8
11.3

4.6
3.8
3.4

Figure 4: Classiﬁcation errors of ERM and mixup on the Google commands dataset.

extract normalized spectrograms from the original waveforms at a sampling rate of 16 kHz. Next, we
101. For speech data, it is reasonable to
zero-pad the spectrograms to equalize their sizes at 160
apply mixup both at the waveform and spectrogram levels. Here, we apply mixup at the spectrogram
level just before feeding the data to the network.

×

For this experiment, we compare a LeNet (Lecun et al., 2001) and a VGG-11 (Simonyan & Zisserman,
2015) architecture, each of them composed by two convolutional and two fully-connected layers.
We train each model for 30 epochs with minibatches of 100 examples, using Adam as the optimizer
10−3 and is divided by 10
(Kingma & Ba, 2015). Training starts with a learning rate equal to 3
every 10 epochs. For mixup, we use a warm-up period of ﬁve epochs where we train the network on
original training examples, since we ﬁnd it speeds up initial convergence. Table 4 shows that mixup
outperforms ERM on this task, specially when using VGG-11, the model with larger capacity.

×

3.4 MEMORIZATION OF CORRUPTED LABELS

Following Zhang et al. (2017), we evaluate the robustness of ERM and mixup models against randomly
corrupted labels. We hypothesize that increasing the strength of mixup interpolation α should generate
virtual examples further from the training examples, making memorization more difﬁcult to achieve.
In particular, it should be easier to learn interpolations between real examples compared to memorizing
interpolations involving random labels. We adapt an open-source implementation (Zhang, 2017)
to generate three CIFAR-10 training sets, where 20%, 50%, or 80% of the labels are replaced by
random noise, respectively. All the test labels are kept intact for evaluation. Dropout (Srivastava
et al., 2014) is considered the state-of-the-art method for learning with corrupted labels (Arpit et al.,
2017). Thus, we compare in these experiments mixup, dropout, mixup + dropout, and ERM. For
mixup, we choose α
; for dropout, we add one dropout layer in each PreAct block after
∈ {
the ReLU activation layer between two convolution layers, as suggested in (Zagoruyko & Komodakis,
2016a). We choose the dropout probability p
. For the combination of mixup
∈ {
}
and dropout, we choose α
and p
. These experiments use the PreAct
}
∈ {
ResNet-18 (He et al., 2016) model implemented in (Liu, 2017). All the other settings are the same as
in Section 3.2.

0.5, 0.7, 0.8, 0.9
0.3, 0.5, 0.7

1, 2, 8, 32
}

1, 2, 4, 8
}

∈ {

We summarize our results in Table 2, where we note the best test error achieved during the training
session, as well as the ﬁnal test error after 200 epochs. To quantify the amount of memorization, we
also evaluate the training errors at the last epoch on real labels and corrupted labels. As the training
progresses with a smaller learning rate (e.g. less than 0.01), the ERM model starts to overﬁt the
corrupted labels. When using a large probability (e.g. 0.7 or 0.8), dropout can effectively reduce
overﬁtting. mixup with a large α (e.g. 8 or 32) outperforms dropout on both the best and last epoch
test errors, and achieves lower training error on real labels while remaining resistant to noisy labels.
Interestingly, mixup + dropout performs the best of all, showing that the two methods are compatible.

3.5 ROBUSTNESS TO ADVERSARIAL EXAMPLES

One undesirable consequence of models trained using ERM is their fragility to adversarial exam-
ples (Szegedy et al., 2014). Adversarial examples are obtained by adding tiny (visually imperceptible)
perturbations to legitimate examples in order to deteriorate the performance of the model. The adver-
sarial noise is generated by ascending the gradient of the loss surface with respect to the legitimate
example. Improving the robustness to adversarial examples is a topic of active research.

6

Published as a conference paper at ICLR 2018

Label corruption Method

Test error

Training error

Real Corrupted

ERM
ERM + dropout (p = 0.7)
mixup (α = 8)
mixup + dropout (α = 4, p = 0.1)

ERM
ERM + dropout (p = 0.8)
mixup (α = 32)
mixup + dropout (α = 8, p = 0.3)

ERM
ERM + dropout (p = 0.8)
mixup (α = 32)
mixup + dropout (α = 8, p = 0.3)

Best

12.7
8.8
5.9
6.2

18.8
14.1
11.3
10.9

36.5
30.9
25.3
24.0

Last

16.6
10.4
6.4
6.2

44.6
15.5
12.7
10.9

73.9
35.1
30.9
24.8

0.05
5.26
2.27
1.92

0.26
12.71
5.84
7.56

0.62
29.84
18.92
19.70

0.28
83.55
86.32
85.02

0.64
86.98
85.71
87.90

0.83
86.37
85.44
87.67

20%

50%

80%

Table 2: Results on the corrupted label experiments for the best models.

Metric Method

FGSM I-FGSM

Metric Method

FGSM I-FGSM

Top-1

Top-5

ERM
mixup

ERM
mixup

90.7
75.2

63.1
49.1

99.9
99.6

93.4
95.8

Top-1

Top-5

ERM
mixup

ERM
mixup

57.0
46.0

24.8
17.4

57.3
40.9

18.1
11.8

(a) White box attacks.

(b) Black box attacks.

Table 3: Classiﬁcation errors of ERM and mixup models when tested on adversarial examples.

Among the several methods aiming to solve this problem, some have proposed to penalize the norm of
the Jacobian of the model to control its Lipschitz constant (Drucker & Le Cun, 1992; Cisse et al., 2017;
Bartlett et al., 2017; Hein & Andriushchenko, 2017). Other approaches perform data augmentation
by producing and training on adversarial examples (Goodfellow et al., 2015). Unfortunately, all
of these methods add signiﬁcant computational overhead to ERM. Here, we show that mixup can
signiﬁcantly improve the robustness of neural networks without hindering the speed of ERM by
penalizing the norm of the gradient of the loss w.r.t a given input along the most plausible directions
(e.g. the directions to other training points). Indeed, Figure 2 shows that mixup results in models
having a smaller loss and gradient norm between examples compared to vanilla ERM.

To assess the robustness of mixup models to adversarial examples, we use three ResNet-101 models:
two of them trained using ERM on ImageNet-2012, and the third trained using mixup. In the ﬁrst
set of experiments, we study the robustness of one ERM model and the mixup model against white
box attacks. That is, for each of the two models, we use the model itself to generate adversarial
examples, either using the Fast Gradient Sign Method (FGSM) or the Iterative FGSM (I-FGSM)
methods (Goodfellow et al., 2015), allowing a maximum perturbation of (cid:15) = 4 for every pixel. For
I-FGSM, we use 10 iterations with equal step size. In the second set of experiments, we evaluate
robustness against black box attacks. That is, we use the ﬁrst ERM model to produce adversarial
examples using FGSM and I-FGSM. Then, we test the robustness of the second ERM model and the
mixup model to these examples. The results of both settings are summarized in Table 3.

For the FGSM white box attack, the mixup model is 2.7 times more robust than the ERM model in
terms of Top-1 error. For the FGSM black box attack, the mixup model is 1.25 times more robust
than the ERM model in terms of Top-1 error. Also, while both mixup and ERM are not robust to
white box I-FGSM attacks, mixup is about 40% more robust than ERM in the black box I-FGSM
setting. Overall, mixup produces neural networks that are signiﬁcantly more robust than ERM against
adversarial examples in white box and black settings without additional overhead compared to ERM.

7

Published as a conference paper at ICLR 2018

Dataset

ERM mixup

Dataset

ERM mixup

Abalone
Arcene
Arrhythmia

74.0
57.6
56.6

73.6
48.0
46.3

Htru2
Iris
Phishing

2.0
21.3
16.3

2.0
17.3
15.2

Table 4: ERM and mixup classiﬁcation errors on the UCI datasets.

ERM GAN

mixup GAN (α = 0.2)

Figure 5: Effect of mixup on stabilizing GAN training at iterations 10, 100, 1000, 10000, and 20000.

3.6 TABULAR DATA

To further explore the performance of mixup on non-image data, we performed a series of experiments
on six arbitrary classiﬁcation problems drawn from the UCI dataset (Lichman, 2013). The neural
networks in this section are fully-connected, and have two hidden layers of 128 ReLU units. The
parameters of these neural networks are learned using Adam (Kingma & Ba, 2015) with default
hyper-parameters, over 10 epochs of mini-batches of size 16. Table 4 shows that mixup improves the
average test error on four out of the six considered datasets, and never underperforms ERM.

3.7 STABILIZATION OF GENERATIVE ADVERSARIAL NETWORKS (GANS)

Generative Adversarial Networks, also known as GANs (Goodfellow et al., 2014), are a powerful
family of implicit generative models. In GANs, a generator and a discriminator compete against
each other to model a distribution P . On the one hand, the generator g competes to transform noise
vectors z
P . On the other hand, the
discriminator competes to distinguish between real samples x and fake samples g(z). Mathematically,
training a GAN is equivalent to solving the optimization problem

Q into fake samples g(z) that resemble real samples x

∼

∼

max
g

min
d

E
x,z

(cid:96)(d(x), 1) + (cid:96)(d(g(z)), 0),

where (cid:96) is the binary cross entropy loss. Unfortunately, solving the previous min-max equation is a
notoriously difﬁcult optimization problem (Goodfellow, 2016), since the discriminator often provides
the generator with vanishing gradients. We argue that mixup should stabilize GAN training because it
acts as a regularizer on the gradients of the discriminator, akin to the binary classiﬁer in Figure 1b.
Then, the smoothness of the discriminator guarantees a stable source of gradient information to the
generator. The mixup formulation of GANs is:

max
g

min
d

E
x,z,λ

(cid:96)(d(λx + (1

λ)g(z)), λ).

−

Figure 5 illustrates the stabilizing effect of mixup the training of GAN (orange samples) when
modeling two toy datasets (blue samples). The neural networks in these experiments are fully-
connected and have three hidden layers of 512 ReLU units. The generator network accepts two-
dimensional Gaussian noise vectors. The networks are trained for 20,000 mini-batches of size
128 using the Adam optimizer with default parameters, where the discriminator is trained for ﬁve
iterations before every generator iteration. The training of mixup GANs seems promisingly robust to
hyper-parameter and architectural choices.

8

Published as a conference paper at ICLR 2018

Method

Speciﬁcation

ERM

mixup

mix labels and latent
representations
(AC + RP)

mix inputs only

AC + RP
AC + KNN

Layer 1
Layer 2
Layer 3
Layer 4
Layer 5

label smoothing
(Szegedy et al., 2016)

mix inputs +
label smoothing
(AC + RP)

add Gaussian noise
to inputs

(cid:15) = 0.05
(cid:15) = 0.1
(cid:15) = 0.2

(cid:15) = 0.05
(cid:15) = 0.1
(cid:15) = 0.2
(cid:15) = 0.4

σ = 0.05
σ = 0.1
σ = 0.2

SC + KNN (Chawla et al., 2002)
AC + KNN
SC + RP
AC + RP

Modiﬁed

Weight decay

Input Target
(cid:55)

(cid:55)

10−4

5

×

(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:51)
(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:51)
(cid:51)

(cid:55)
(cid:55)
(cid:55)

(cid:51)
(cid:51)
(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:51)

5.53
(cid:51) 4.24
(cid:51) 4.98
(cid:51) 4.44
(cid:51) 4.56
(cid:51) 5.39
(cid:51) 5.95
(cid:51) 5.39
(cid:55)
(cid:55)
(cid:55)
(cid:55)

5.45
5.43
5.23
5.17
(cid:51) 5.25
(cid:51) 5.33
(cid:51) 5.34
(cid:51) 5.02
(cid:51) 5.08
(cid:51) 4.98
(cid:51) 5.25
(cid:55)
(cid:55)
(cid:55)

5.53
6.41
7.16

10−4

5.18

4.68
5.26

4.51
4.61
5.55
5.43
5.15

5.52
5.48
5.55
5.72

5.02
5.17
5.06

5.40
5.09
5.06
5.39

5.04
5.86
7.24

Table 5: Results of the ablation studies on the CIFAR-10 dataset. Reported are the median test errors
of the last 10 epochs. A tick ((cid:51)) means the component is different from standard ERM training,
whereas a cross ((cid:55)) means it follows the standard training practice. AC: mix between all classes. SC:
mix within the same class. RP: mix between random pairs. KNN: mix between k-nearest neighbors
(k=200). Please refer to the text for details about the experiments and interpretations.

3.8 ABLATION STUDIES

mixup is a data augmentation method that consists of only two parts: random convex combination of
raw inputs, and correspondingly, convex combination of one-hot label encodings. However, there are
several design choices to make. For example, on how to augment the inputs, we could have chosen
to interpolate the latent representations (i.e. feature maps) of a neural network, and we could have
chosen to interpolate only between the nearest neighbors, or only between inputs of the same class.
When the inputs to interpolate come from two different classes, we could have chosen to assign a
single label to the synthetic input, for example using the label of the input that weights more in the
convex combination. To compare mixup with these alternative possibilities, we run a set of ablation
study experiments using the PreAct ResNet-18 architecture on the CIFAR-10 dataset.
Speciﬁcally, for each of the data augmentation methods, we test two weight decay settings (10−4
10−4 which works well for ERM). All the other settings and
which works well for mixup, and 5
hyperparameters are the same as reported in Section 3.2.

×

To compare interpolating raw inputs with interpolating latent representations, we test on random
convex combination of the learned representations before each residual block (denoted Layer 1-4)
or before the uppermost “average pooling + fully connected” layer (denoted Layer 5). To compare
mixing random pairs of inputs (RP) with mixing nearest neighbors (KNN), we ﬁrst compute the 200
nearest neighbors for each training sample, either from the same class (SC) or from all the classes
(AC). Then during training, for each sample in a minibatch, we replace the sample with a synthetic
sample by convex combination with a random draw from its nearest neighbors. To compare mixing
all the classes (AC) with mixing within the same class (SC), we convex combine a minibatch with a

9

Published as a conference paper at ICLR 2018

random permutation of its sample index, where the permutation is done in a per-batch basis (AC) or a
per-class basis (SC). To compare mixing inputs and labels with mixing inputs only, we either use a
convex combination of the two one-hot encodings as the target, or select the one-hot encoding of the
closer training sample as the target. For label smoothing, we follow Szegedy et al. (2016) and use
(cid:15)
9(cid:15)
10 as the target for incorrect classes, and 1
10 as the target for the correct class.Adding Gaussian
noise to inputs is used as another baseline. We report the median test errors of the last 10 epochs.
Results are shown in Table 5.

−

From the ablation study experiments, we have the following observations. First, mixup is the best
data augmentation method we test, and is signiﬁcantly better than the second best method (mix input
+ label smoothing). Second, the effect of regularization can be seen by comparing the test error with a
small weight decay (10−4) with a large one (5
10−4). For example, for ERM a large weight decay
works better, whereas for mixup a small weight decay is preferred, conﬁrming its regularization effects.
We also see an increasing advantage of large weight decay when interpolating in higher layers of latent
representations, indicating decreasing strength of regularization. Among all the input interpolation
methods, mixing random pairs from all classes (AC + RP) has the strongest regularization effect.
Label smoothing and adding Gaussian noise have a relatively small regularization effect. Finally,
we note that the SMOTE algorithm (Chawla et al., 2002) does not lead to a noticeable gain in
performance.

×

4 RELATED WORK

Data augmentation lies at the heart of all successful applications of deep learning, ranging from image
classiﬁcation (Krizhevsky et al., 2012) to speech recognition (Graves et al., 2013; Amodei et al.,
2016). In all cases, substantial domain knowledge is leveraged to design suitable data transformations
leading to improved generalization. In image classiﬁcation, for example, one routinely uses rotation,
translation, cropping, resizing, ﬂipping (Lecun et al., 2001; Simonyan & Zisserman, 2015), and
random erasing (Zhong et al., 2017) to enforce visually plausible invariances in the model through
the training data. Similarly, in speech recognition, noise injection is a prevalent practice to improve
the robustness and accuracy of the trained models (Amodei et al., 2016).

More related to mixup, Chawla et al. (2002) propose to augment the rare class in an imbalanced
dataset by interpolating the nearest neighbors; DeVries & Taylor (2017) show that interpolation and
extrapolation the nearest neighbors of the same class in feature space can improve generalization.
However, their proposals only operate among the nearest neighbors within a certain class at the
input / feature level, and hence does not account for changes in the corresponding labels. Recent
approaches have also proposed to regularize the output distribution of a neural network by label
smoothing (Szegedy et al., 2016), or penalizing high-conﬁdence softmax distributions (Pereyra et al.,
2017). These methods bear similarities with mixup in the sense that supervision depends on multiple
smooth labels, rather than on single hard labels as in traditional ERM. However, the label smoothing
in these works is applied or regularized independently from the associated feature values.

mixup enjoys several desirable aspects of previous data augmentation and regularization schemes
without suffering from their drawbacks. Like the method of DeVries & Taylor (2017), it does not
require signiﬁcant domain knowledge. Like label smoothing, the supervision of every example is not
overly dominated by the ground-truth label. Unlike both of these approaches, the mixup transformation
establishes a linear relationship between data augmentation and the supervision signal. We believe
that this leads to a strong regularizer that improves generalization as demonstrated by our experiments.
The linearity constraint, through its effect on the derivatives of the function approximated, also relates
mixup to other methods such as Sobolev training of neural networks (Czarnecki et al., 2017) or
WGAN-GP (Gulrajani et al., 2017).

5 DISCUSSION

We have proposed mixup, a data-agnostic and straightforward data augmentation principle. We
have shown that mixup is a form of vicinal risk minimization, which trains on virtual examples
constructed as the linear interpolation of two random examples from the training set and their labels.
Incorporating mixup into existing training pipelines reduces to a few lines of code, and introduces
little or no computational overhead. Throughout an extensive evaluation, we have shown that mixup

10

Published as a conference paper at ICLR 2018

improves the generalization error of state-of-the-art models on ImageNet, CIFAR, speech, and
tabular datasets. Furthermore, mixup helps to combat memorization of corrupt labels, sensitivity to
adversarial examples, and instability in adversarial training.

In our experiments, the following trend is consistent: with increasingly large α, the training error on
real data increases, while the generalization gap decreases. This sustains our hypothesis that mixup
implicitly controls model complexity. However, we do not yet have a good theory for understanding
the ‘sweet spot’ of this bias-variance trade-off. For example, in CIFAR-10 classiﬁcation we can
get very low training error on real data even when α
(i.e., training only on averages of pairs
of real examples), whereas in ImageNet classiﬁcation, the training error on real data increases
signiﬁcantly with α
. Based on our ImageNet and Google commands experiments with different
model architectures, we conjecture that increasing the model capacity would make training error less
sensitive to large α, hence giving mixup a more signiﬁcant advantage.

→ ∞

→ ∞

mixup also opens up several possibilities for further exploration. First, is it possible to make
similar ideas work on other types of supervised learning problems, such as regression and structured
prediction? While generalizing mixup to regression problems is straightforward, its application
to structured prediction problems such as image segmentation remains less obvious. Second, can
similar methods prove helpful beyond supervised learning? The interpolation principle seems like a
reasonable inductive bias which might also help in unsupervised, semi-supervised, and reinforcement
learning. Can we extend mixup to feature-label extrapolation to guarantee a robust model behavior
far away from the training data? Although our discussion of these directions is still speculative, we
are excited about the possibilities mixup opens up, and hope that our observations will prove useful
for future development.

We would like to thank Priya Goyal, Yossi Adi and the PyTorch team. We also thank the Anonymous
Review 2 for proposing the mixup + dropout experiments.

ACKNOWLEDGEMENTS

REFERENCES

D. Amodei, S. Ananthanarayanan, R. Anubhai, J. Bai, E. Battenberg, C. Case, J. Casper, B. Catanzaro, Q. Cheng,
G. Chen, et al. Deep speech 2: End-to-end speech recognition in English and Mandarin. In ICML, 2016.

D. Arpit, S. Jastrzebski, N. Ballas, D. Krueger, E. Bengio, M. S. Kanwal, T. Maharaj, A. Fischer, A. Courville,

Y. Bengio, et al. A closer look at memorization in deep networks. ICML, 2017.

P. Bartlett, D. J. Foster, and M. Telgarsky. Spectrally-normalized margin bounds for neural networks. NIPS,

2017.

O. Chapelle, J. Weston, L. Bottou, and V. Vapnik. Vicinal risk minimization. NIPS, 2000.

N. V. Chawla, K. W. Bowyer, L. O. Hall, and W. P. Kegelmeyer. SMOTE: synthetic minority over-sampling

technique. Journal of artiﬁcial intelligence research, 16:321–357, 2002.

C. Chelba, T. Mikolov, M. Schuster, Q. Ge, T. Brants, P. Koehn, and T. Robinson. One billion word benchmark

for measuring progress in statistical language modeling. arXiv, 2013.

M. Cisse, P. Bojanowski, E. Grave, Y. Dauphin, and N. Usunier. Parseval networks: Improving robustness to

adversarial examples. ICML, 2017.

W. M. Czarnecki, S. Osindero, M. Jaderberg, G. ´Swirszcz, and R. Pascanu. Sobolev training for neural networks.

NIPS, 2017.

T. DeVries and G. W. Taylor. Dataset augmentation in feature space. ICLR Workshops, 2017.

H. Drucker and Y. Le Cun.

Improving generalization performance using double backpropagation.

IEEE

Transactions on Neural Networks, 3(6):991–997, 1992.

I. Goodfellow. Tutorial: Generative adversarial networks. NIPS, 2016.

I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio.

Generative adversarial nets. NIPS, 2014.

11

Published as a conference paper at ICLR 2018

IEEE, 2013.

NIPS, 2017.

JMLR, 2017.

2017.

NIPS, 2012.

I. J. Goodfellow, J. Shlens, and C. Szegedy. Explaining and harnessing adversarial examples. ICLR, 2015.

P. Goyal, P. Doll´ar, R. Girshick, P. Noordhuis, L. Wesolowski, A. Kyrola, A. Tulloch, Y. Jia, and K. He. Accurate,

large minibatch SGD: Training ImageNet in 1 hour. arXiv, 2017.

A. Graves, A.-r. Mohamed, and G. Hinton. Speech recognition with deep recurrent neural networks. In ICASSP.

I. Gulrajani, F. Ahmed, M. Arjovsky, V. Dumoulin, and A. Courville. Improved training of Wasserstein GANs.

N. Harvey, C. Liaw, and A. Mehrabian. Nearly-tight VC-dimension bounds for piecewise linear neural networks.

K. He, X. Zhang, S. Ren, and J. Sun. Identity mappings in deep residual networks. ECCV, 2016.

M. Hein and M. Andriushchenko. Formal guarantees on the robustness of a classiﬁer against adversarial

manipulation. NIPS, 2017.

G. Hinton, L. Deng, D. Yu, G. E. Dahl, A.-r. Mohamed, N. Jaitly, A. Senior, V. Vanhoucke, P. Nguyen, T. N.
Sainath, et al. Deep neural networks for acoustic modeling in speech recognition: The shared views of four
research groups. IEEE Signal Processing Magazine, 2012.

G. Huang, Z. Liu, L. van der Maaten, and K. Q. Weinberger. Densely connected convolutional networks. CVPR,

D. Kingma and J. Ba. Adam: A method for stochastic optimization. ICLR, 2015.

A. Krizhevsky, I. Sutskever, and G. E. Hinton. ImageNet classiﬁcation with deep convolutional neural networks.

Y. Lecun, L. Bottou, Y. Bengio, and P. Haffner. Gradient-based learning applied to document recognition.

Proceedings of IEEE, 2001.

M. Lichman. UCI machine learning repository, 2013.

K. Liu, 2017. URL https://github.com/kuangliu/pytorch-cifar.

G. Pereyra, G. Tucker, J. Chorowski, Ł. Kaiser, and G. Hinton. Regularizing neural networks by penalizing

conﬁdent output distributions. ICLR Workshops, 2017.

O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein,

A. C. Berg, and L. Fei-Fei. ImageNet large scale visual recognition challenge. IJCV, 2015.

D. Silver, A. Huang, C. J. Maddison, A. Guez, L. Sifre, G. Van Den Driessche, J. Schrittwieser, I. Antonoglou,
V. Panneershelvam, M. Lanctot, et al. Mastering the game of Go with deep neural networks and tree search.
Nature, 2016.

P. Simard, Y. LeCun, J. Denker, and B. Victorri. Transformation invariance in pattern recognitiontangent distance

and tangent propagation. Neural networks: tricks of the trade, 1998.

K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale image recognition. ICLR,

2015.

net. ICLR Workshops, 2015.

J. T. Springenberg, A. Dosovitskiy, T. Brox, and M. Riedmiller. Striving for simplicity: The all convolutional

N. Srivastava, G. E. Hinton, A. Krizhevsky, I. Sutskever, and R. Salakhutdinov. Dropout: a simple way to
prevent neural networks from overﬁtting. Journal of Machine Learning Research, 15(1):1929–1958, 2014.

C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Erhan, I. J. Goodfellow, and R. Fergus. Intriguing properties

of neural networks. ICLR, 2014.

C. Szegedy, V. Vanhoucke, S. Ioffe, J. Shlens, and Z. Wojna. Rethinking the Inception architecture for computer

vision. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2016.

V. N. Vapnik. Statistical learning theory. J. Wiley, 1998.

V. Vapnik and A. Y. Chervonenkis. On the uniform convergence of relative frequencies of events to their

probabilities. Theory of Probability and its Applications, 1971.

12

Published as a conference paper at ICLR 2018

A. Veit, 2017. URL https://github.com/andreasveit.

P. Warden,

2017.

URL

https://research.googleblog.com/2017/08/

launching-speech-commands-dataset.html.

S. Xie, R. Girshick, P. Doll´ar, Z. Tu, and K. He. Aggregated residual transformations for deep neural networks.

CVPR, 2016.

S. Zagoruyko and N. Komodakis. Wide residual networks. BMVC, 2016a.

S. Zagoruyko and N. Komodakis,
wide-residual-networks.

2016b.

URL https://github.com/szagoruyko/

C. Zhang, S. Bengio, M. Hardt, B. Recht, and O. Vinyals. Understanding deep learning requires rethinking

generalization. ICLR, 2017.

C. Zhang, 2017. URL https://github.com/pluskid/fitting-random-labels.

Z. Zhong, L. Zheng, G. Kang, S. Li, and Y. Yang. Random erasing data augmentation. arXiv, 2017.

13

8
1
0
2
 
r
p
A
 
7
2
 
 
]

G
L
.
s
c
[
 
 
2
v
2
1
4
9
0
.
0
1
7
1
:
v
i
X
r
a

Published as a conference paper at ICLR 2018

mixup: BEYOND EMPIRICAL RISK MINIMIZATION

Hongyi Zhang
MIT

Moustapha Cisse, Yann N. Dauphin, David Lopez-Paz∗
FAIR

ABSTRACT

Large deep neural networks are powerful, but exhibit undesirable behaviors such
as memorization and sensitivity to adversarial examples. In this work, we propose
mixup, a simple learning principle to alleviate these issues. In essence, mixup trains
a neural network on convex combinations of pairs of examples and their labels.
By doing so, mixup regularizes the neural network to favor simple linear behavior
in-between training examples. Our experiments on the ImageNet-2012, CIFAR-10,
CIFAR-100, Google commands and UCI datasets show that mixup improves the
generalization of state-of-the-art neural network architectures. We also ﬁnd that
mixup reduces the memorization of corrupt labels, increases the robustness to
adversarial examples, and stabilizes the training of generative adversarial networks.

1

INTRODUCTION

Large deep neural networks have enabled breakthroughs in ﬁelds such as computer vision (Krizhevsky
et al., 2012), speech recognition (Hinton et al., 2012), and reinforcement learning (Silver et al., 2016).
In most successful applications, these neural networks share two commonalities. First, they are
trained as to minimize their average error over the training data, a learning rule also known as the
Empirical Risk Minimization (ERM) principle (Vapnik, 1998). Second, the size of these state-of-the-
art neural networks scales linearly with the number of training examples. For instance, the network of
104 images in the CIFAR-10 dataset,
Springenberg et al. (2015) used 106 parameters to model the 5
the network of (Simonyan & Zisserman, 2015) used 108 parameters to model the 106 images in the
1010 parameters to model
ImageNet-2012 dataset, and the network of Chelba et al. (2013) used 2
the 109 words in the One Billion Word dataset.

·

·

Strikingly, a classical result in learning theory (Vapnik & Chervonenkis, 1971) tells us that the
convergence of ERM is guaranteed as long as the size of the learning machine (e.g., the neural
network) does not increase with the number of training data. Here, the size of a learning machine is
measured in terms of its number of parameters or, relatedly, its VC-complexity (Harvey et al., 2017).

This contradiction challenges the suitability of ERM to train our current neural network models, as
highlighted in recent research. On the one hand, ERM allows large neural networks to memorize
(instead of generalize from) the training data even in the presence of strong regularization, or in
classiﬁcation problems where the labels are assigned at random (Zhang et al., 2017). On the other
hand, neural networks trained with ERM change their predictions drastically when evaluated on
examples just outside the training distribution (Szegedy et al., 2014), also known as adversarial
examples. This evidence suggests that ERM is unable to explain or provide generalization on testing
distributions that differ only slightly from the training data. However, what is the alternative to ERM?

The method of choice to train on similar but different examples to the training data is known as data
augmentation (Simard et al., 1998), formalized by the Vicinal Risk Minimization (VRM) principle
(Chapelle et al., 2000). In VRM, human knowledge is required to describe a vicinity or neighborhood
around each example in the training data. Then, additional virtual examples can be drawn from the
vicinity distribution of the training examples to enlarge the support of the training distribution. For
instance, when performing image classiﬁcation, it is common to deﬁne the vicinity of one image
as the set of its horizontal reﬂections, slight rotations, and mild scalings. While data augmentation
consistently leads to improved generalization (Simard et al., 1998), the procedure is dataset-dependent,
and thus requires the use of expert knowledge. Furthermore, data augmentation assumes that the

∗Alphabetical order.

1

Published as a conference paper at ICLR 2018

examples in the vicinity share the same class, and does not model the vicinity relation across examples
of different classes.

Contribution Motivated by these issues, we introduce a simple and data-agnostic data augmenta-
tion routine, termed mixup (Section 2). In a nutshell, mixup constructs virtual training examples

˜x = λxi + (1
˜y = λyi + (1

λ)xj,
λ)yj,

−
−

where xi, xj are raw input vectors
where yi, yj are one-hot label encodings

(xi, yi) and (xj, yj) are two examples drawn at random from our training data, and λ
[0, 1].
Therefore, mixup extends the training distribution by incorporating the prior knowledge that linear
interpolations of feature vectors should lead to linear interpolations of the associated targets. mixup
can be implemented in a few lines of code, and introduces minimal computation overhead.

∈

Despite its simplicity, mixup allows a new state-of-the-art performance in the CIFAR-10, CIFAR-
100, and ImageNet-2012 image classiﬁcation datasets (Sections 3.1 and 3.2). Furthermore, mixup
increases the robustness of neural networks when learning from corrupt labels (Section 3.4), or facing
adversarial examples (Section 3.5). Finally, mixup improves generalization on speech (Sections 3.3)
and tabular (Section 3.6) data, and can be used to stabilize the training of GANs (Section 3.7). The
source-code necessary to replicate our CIFAR-10 experiments is available at:

https://github.com/facebookresearch/mixup-cifar10.

To understand the effects of various design choices in mixup, we conduct a thorough set of ablation
study experiments (Section 3.8). The results suggest that mixup performs signiﬁcantly better than
related methods in previous work, and each of the design choices contributes to the ﬁnal performance.
We conclude by exploring the connections to prior work (Section 4), as well as offering some points
for discussion (Section 5).

2 FROM EMPIRICAL RISK MINIMIZATION TO mixup

In supervised learning, we are interested in ﬁnding a function f
that describes the relationship
between a random feature vector X and a random target vector Y , which follow the joint distribution
P (X, Y ). To this end, we ﬁrst deﬁne a loss function (cid:96) that penalizes the differences between
predictions f (x) and actual targets y, for examples (x, y)
P . Then, we minimize the average of
the loss function (cid:96) over the data distribution P , also known as the expected risk:

∈ F

∼

(cid:90)

R(f ) =

(cid:96)(f (x), y)dP (x, y).

Unfortunately, the distribution P is unknown in most practical situations. Instead, we usually have
P for all i = 1, . . . , n. Using
access to a set of training data
the training data

n
i=1, where (xi, yi)
(xi, yi)
}
{
, we may approximate P by the empirical distribution

∼

=

D

D

Pδ(x, y) =

δ(x = xi, y = yi),

1
n

n
(cid:88)

i=1

where δ(x = xi, y = yi) is a Dirac mass centered at (xi, yi). Using the empirical distribution Pδ, we
can now approximate the expected risk by the empirical risk:

(cid:90)

Rδ(f ) =

(cid:96)(f (x), y)dPδ(x, y) =

(cid:96)(f (xi), yi).

(1)

1
n

n
(cid:88)

i=1

Learning the function f by minimizing (1) is known as the Empirical Risk Minimization (ERM)
principle (Vapnik, 1998). While efﬁcient to compute, the empirical risk (1) monitors the behaviour
of f only at a ﬁnite set of n examples. When considering functions with a number parameters
comparable to n (such as large neural networks), one trivial way to minimize (1) is to memorize the
training data (Zhang et al., 2017). Memorization, in turn, leads to the undesirable behaviour of f
outside the training data (Szegedy et al., 2014).

2

Published as a conference paper at ICLR 2018

# y1, y2 should be one-hot vectors
for (x1, y1), (x2, y2) in zip(loader1, loader2):

lam = numpy.random.beta(alpha, alpha)
x = Variable(lam * x1 + (1. - lam) * x2)
y = Variable(lam * y1 + (1. - lam) * y2)
optimizer.zero_grad()

loss(net(x), y).backward()

optimizer.step()

(a) One epoch of mixup training in PyTorch.

Figure 1: Illustration of mixup, which converges to ERM as α

0.

→

(b) Effect of mixup (α = 1) on a
toy problem. Green: Class 0. Or-
ange: Class 1. Blue shading indicates
p(y = 1|x).

However, the na¨ıve estimate Pδ is one out of many possible choices to approximate the true distribu-
tion P . For instance, in the Vicinal Risk Minimization (VRM) principle (Chapelle et al., 2000), the
distribution P is approximated by

Pν(˜x, ˜y) =

xi, yi),
ν(˜x, ˜y
|

1
n

n
(cid:88)

i=1

where ν is a vicinity distribution that measures the probability of ﬁnding the virtual feature-target
pair (˜x, ˜y) in the vicinity of the training feature-target pair (xi, yi). In particular, Chapelle et al.
xi, σ2)δ(˜y = yi), which is equivalent
(2000) considered Gaussian vicinities ν(˜x, ˜y
xi, yi) =
−
N
|
to augmenting the training data with additive Gaussian noise. To learn using VRM, we sample the
m
(˜xi, ˜yi)
ν :=
i=1, and minimize the empirical vicinal
vicinal distribution to construct a dataset
}
{
risk:
m
(cid:88)

(˜x

D

Rν(f ) =

(cid:96)(f (˜xi), ˜yi).

1
m

i=1

The contribution of this paper is to propose a generic vicinal distribution, called mixup:

xi, yi) =
µ(˜x, ˜y
|

[δ(˜x = λ

xi + (1

λ)

xj, ˜y = λ

yi + (1

λ)

yj)] ,

·

−

·

·

−

·

1
n

n
(cid:88)

j

E
λ

Beta(α, α), for α
where λ
∞
produces virtual feature-target vectors

(0,

∼

∈

). In a nutshell, sampling from the mixup vicinal distribution

˜x = λxi + (1
˜y = λyi + (1

λ)xj,
λ)yj,

−
−

where (xi, yi) and (xj, yj) are two feature-target vectors drawn at random from the training data, and
λ
[0, 1]. The mixup hyper-parameter α controls the strength of interpolation between feature-target
pairs, recovering the ERM principle as α

0.

∈

→

The implementation of mixup training is straightforward, and introduces a minimal computation
overhead. Figure 1a shows the few lines of code necessary to implement mixup training in PyTorch.
Finally, we mention alternative design choices. First, in preliminary experiments we ﬁnd that convex
combinations of three or more examples with weights sampled from a Dirichlet distribution does not
provide further gain, but increases the computation cost of mixup. Second, our current implementation
uses a single data loader to obtain one minibatch, and then mixup is applied to the same minibatch
after random shufﬂing. We found this strategy works equally well, while reducing I/O requirements.
Third, interpolating only between inputs with equal label did not lead to the performance gains of
mixup discussed in the sequel. More empirical comparison can be found in Section 3.8.

What is mixup doing? The mixup vicinal distribution can be understood as a form of data aug-
mentation that encourages the model f to behave linearly in-between training examples. We argue
that this linear behaviour reduces the amount of undesirable oscillations when predicting outside the
training examples. Also, linearity is a good inductive bias from the perspective of Occam’s razor,

3

Published as a conference paper at ICLR 2018

(a) Prediction errors in-between training data. Evalu-
ated at x = λxi +(1−λ)xj, a prediction is counted as
a “miss” if it does not belong to {yi, yj}. The model
trained with mixup has fewer misses.

(b) Norm of the gradients of the model w.r.t. input
in-between training data, evaluated at x = λxi +
(1 − λ)xj. The model trained with mixup has smaller
gradient norms.

Figure 2: mixup leads to more robust model behaviors in-between the training data.

Method

Epochs Top-1 Error Top-5 Error

ERM (Goyal et al., 2017)
mixup α = 0.2

ERM (Goyal et al., 2017)
mixup α = 0.2

ResNeXt-101 32*4d ERM (Xie et al., 2016)

ResNeXt-101 64*4d ERM (Xie et al., 2016)

Model

ResNet-50

ResNet-101

ResNet-50

ResNet-101

ERM
mixup α = 0.4

mixup α = 0.4

ERM
mixup α = 0.2

ERM
mixup α = 0.2

mixup α = 0.4

ResNeXt-101 32*4d ERM

90
90

90
90

100
90
90

100
90

200
200

200
200

200
200

23.5
23.3

22.1
21.5

21.2
21.2
20.7

20.4
19.8

23.6
22.1

22.0
20.8

21.3
20.1

-
6.6

-
5.6

-
5.6
5.3

5.3
4.9

7.0
6.1

6.1
5.4

5.9
5.0

Table 1: Validation errors for ERM and mixup on the development set of ImageNet-2012.

since it is one of the simplest possible behaviors. Figure 1b shows that mixup leads to decision
boundaries that transition linearly from class to class, providing a smoother estimate of uncertainty.
Figure 2 illustrate the average behaviors of two neural network models trained on the CIFAR-10
dataset using ERM and mixup. Both models have the same architecture, are trained with the same
procedure, and are evaluated at the same points in-between randomly sampled training data. The
model trained with mixup is more stable in terms of model predictions and gradient norms in-between
training samples.

3 EXPERIMENTS

3.1

IMAGENET CLASSIFICATION

We evaluate mixup on the ImageNet-2012 classiﬁcation dataset (Russakovsky et al., 2015). This
dataset contains 1.3 million training images and 50,000 validation images, from a total of 1,000 classes.
For training, we follow standard data augmentation practices: scale and aspect ratio distortions,
random crops, and horizontal ﬂips (Goyal et al., 2017). During evaluation, only the 224
224 central
crop of each image is tested. We use mixup and ERM to train several state-of-the-art ImageNet-2012
classiﬁcation models, and report both top-1 and top-5 error rates in Table 1.

×

4

Published as a conference paper at ICLR 2018

Dataset

Model

ERM mixup

CIFAR-10

CIFAR-100

PreAct ResNet-18
WideResNet-28-10
DenseNet-BC-190

PreAct ResNet-18
WideResNet-28-10
DenseNet-BC-190

5.6
3.8
3.7

25.6
19.4
19.0

4.2
2.7
2.7

21.1
17.5
16.8

(a) Test errors for the CIFAR experiments.

Figure 3: Test errors for ERM and mixup on the CIFAR experiments.

(b) Test error evolution for the best
ERM and mixup models.

For all the experiments in this section, we use data-parallel distributed training in Caffe21 with
a minibatch size of 1,024. We use the learning rate schedule described in (Goyal et al., 2017).
Speciﬁcally, the learning rate is increased linearly from 0.1 to 0.4 during the ﬁrst 5 epochs, and it is
then divided by 10 after 30, 60 and 80 epochs when training for 90 epochs; or after 60, 120 and 180
epochs when training for 200 epochs.

∈

For mixup, we ﬁnd that α
[0.1, 0.4] leads to improved performance over ERM, whereas for large α,
mixup leads to underﬁtting. We also ﬁnd that models with higher capacities and/or longer training
runs are the ones to beneﬁt the most from mixup. For example, when trained for 90 epochs, the mixup
variants of ResNet-101 and ResNeXt-101 obtain a greater improvement (0.5% to 0.6%) over their
ERM analogues than the gain of smaller models such as ResNet-50 (0.2%). When trained for 200
epochs, the top-1 error of the mixup variant of ResNet-50 is further reduced by 1.2% compared to the
90 epoch run, whereas its ERM analogue stays the same.

3.2 CIFAR-10 AND CIFAR-100

We conduct additional image classiﬁcation experiments on the CIFAR-10 and CIFAR-100 datasets
to further evaluate the generalization performance of mixup. In particular, we compare ERM and
mixup training for: PreAct ResNet-18 (He et al., 2016) as implemented in (Liu, 2017), WideResNet-
28-10 (Zagoruyko & Komodakis, 2016a) as implemented in (Zagoruyko & Komodakis, 2016b), and
DenseNet (Huang et al., 2017) as implemented in (Veit, 2017). For DenseNet, we change the growth
rate to 40 to follow the DenseNet-BC-190 speciﬁcation from (Huang et al., 2017). For mixup, we
ﬁx α = 1, which results in interpolations λ uniformly distributed between zero and one. All models
are trained on a single Nvidia Tesla P100 GPU using PyTorch2 for 200 epochs on the training set
with 128 examples per minibatch, and evaluated on the test set. Learning rates start at 0.1 and are
divided by 10 after 100 and 150 epochs for all models except WideResNet. For WideResNet, we
follow (Zagoruyko & Komodakis, 2016a) and divide the learning rate by 10 after 60, 120 and 180
epochs. Weight decay is set to 10−4. We do not use dropout in these experiments.

We summarize our results in Figure 3a. In both CIFAR-10 and CIFAR-100 classiﬁcation problems,
the models trained using mixup signiﬁcantly outperform their analogues trained with ERM. As seen
in Figure 3b, mixup and ERM converge at a similar speed to their best test errors. Note that the
DenseNet models in (Huang et al., 2017) were trained for 300 epochs with further learning rate
decays scheduled at the 150 and 225 epochs, which may explain the discrepancy the performance of
DenseNet reported in Figure 3a and the original result of Huang et al. (2017).

3.3 SPEECH DATA

Next, we perform speech recognition experiments using the Google commands dataset (Warden,
2017). The dataset contains 65,000 utterances, where each utterance is about one-second long and
belongs to one out of 30 classes. The classes correspond to voice commands such as yes, no, down,
left, as pronounced by a few thousand different speakers. To preprocess the utterances, we ﬁrst

1https://caffe2.ai
2http://pytorch.org

5

Published as a conference paper at ICLR 2018

Model

Method

Validation set Test set

LeNet

VGG-11

ERM
mixup (α = 0.1)
mixup (α = 0.2)

ERM
mixup (α = 0.1)
mixup (α = 0.2)

9.8
10.1
10.2

5.0
4.0
3.9

10.3
10.8
11.3

4.6
3.8
3.4

Figure 4: Classiﬁcation errors of ERM and mixup on the Google commands dataset.

extract normalized spectrograms from the original waveforms at a sampling rate of 16 kHz. Next, we
101. For speech data, it is reasonable to
zero-pad the spectrograms to equalize their sizes at 160
apply mixup both at the waveform and spectrogram levels. Here, we apply mixup at the spectrogram
level just before feeding the data to the network.

×

For this experiment, we compare a LeNet (Lecun et al., 2001) and a VGG-11 (Simonyan & Zisserman,
2015) architecture, each of them composed by two convolutional and two fully-connected layers.
We train each model for 30 epochs with minibatches of 100 examples, using Adam as the optimizer
10−3 and is divided by 10
(Kingma & Ba, 2015). Training starts with a learning rate equal to 3
every 10 epochs. For mixup, we use a warm-up period of ﬁve epochs where we train the network on
original training examples, since we ﬁnd it speeds up initial convergence. Table 4 shows that mixup
outperforms ERM on this task, specially when using VGG-11, the model with larger capacity.

×

3.4 MEMORIZATION OF CORRUPTED LABELS

Following Zhang et al. (2017), we evaluate the robustness of ERM and mixup models against randomly
corrupted labels. We hypothesize that increasing the strength of mixup interpolation α should generate
virtual examples further from the training examples, making memorization more difﬁcult to achieve.
In particular, it should be easier to learn interpolations between real examples compared to memorizing
interpolations involving random labels. We adapt an open-source implementation (Zhang, 2017)
to generate three CIFAR-10 training sets, where 20%, 50%, or 80% of the labels are replaced by
random noise, respectively. All the test labels are kept intact for evaluation. Dropout (Srivastava
et al., 2014) is considered the state-of-the-art method for learning with corrupted labels (Arpit et al.,
2017). Thus, we compare in these experiments mixup, dropout, mixup + dropout, and ERM. For
mixup, we choose α
; for dropout, we add one dropout layer in each PreAct block after
∈ {
the ReLU activation layer between two convolution layers, as suggested in (Zagoruyko & Komodakis,
2016a). We choose the dropout probability p
. For the combination of mixup
∈ {
}
and dropout, we choose α
and p
. These experiments use the PreAct
}
∈ {
ResNet-18 (He et al., 2016) model implemented in (Liu, 2017). All the other settings are the same as
in Section 3.2.

0.5, 0.7, 0.8, 0.9
0.3, 0.5, 0.7

1, 2, 8, 32
}

1, 2, 4, 8
}

∈ {

We summarize our results in Table 2, where we note the best test error achieved during the training
session, as well as the ﬁnal test error after 200 epochs. To quantify the amount of memorization, we
also evaluate the training errors at the last epoch on real labels and corrupted labels. As the training
progresses with a smaller learning rate (e.g. less than 0.01), the ERM model starts to overﬁt the
corrupted labels. When using a large probability (e.g. 0.7 or 0.8), dropout can effectively reduce
overﬁtting. mixup with a large α (e.g. 8 or 32) outperforms dropout on both the best and last epoch
test errors, and achieves lower training error on real labels while remaining resistant to noisy labels.
Interestingly, mixup + dropout performs the best of all, showing that the two methods are compatible.

3.5 ROBUSTNESS TO ADVERSARIAL EXAMPLES

One undesirable consequence of models trained using ERM is their fragility to adversarial exam-
ples (Szegedy et al., 2014). Adversarial examples are obtained by adding tiny (visually imperceptible)
perturbations to legitimate examples in order to deteriorate the performance of the model. The adver-
sarial noise is generated by ascending the gradient of the loss surface with respect to the legitimate
example. Improving the robustness to adversarial examples is a topic of active research.

6

Published as a conference paper at ICLR 2018

Label corruption Method

Test error

Training error

Real Corrupted

ERM
ERM + dropout (p = 0.7)
mixup (α = 8)
mixup + dropout (α = 4, p = 0.1)

ERM
ERM + dropout (p = 0.8)
mixup (α = 32)
mixup + dropout (α = 8, p = 0.3)

ERM
ERM + dropout (p = 0.8)
mixup (α = 32)
mixup + dropout (α = 8, p = 0.3)

Best

12.7
8.8
5.9
6.2

18.8
14.1
11.3
10.9

36.5
30.9
25.3
24.0

Last

16.6
10.4
6.4
6.2

44.6
15.5
12.7
10.9

73.9
35.1
30.9
24.8

0.05
5.26
2.27
1.92

0.26
12.71
5.84
7.56

0.62
29.84
18.92
19.70

0.28
83.55
86.32
85.02

0.64
86.98
85.71
87.90

0.83
86.37
85.44
87.67

20%

50%

80%

Table 2: Results on the corrupted label experiments for the best models.

Metric Method

FGSM I-FGSM

Metric Method

FGSM I-FGSM

Top-1

Top-5

ERM
mixup

ERM
mixup

90.7
75.2

63.1
49.1

99.9
99.6

93.4
95.8

Top-1

Top-5

ERM
mixup

ERM
mixup

57.0
46.0

24.8
17.4

57.3
40.9

18.1
11.8

(a) White box attacks.

(b) Black box attacks.

Table 3: Classiﬁcation errors of ERM and mixup models when tested on adversarial examples.

Among the several methods aiming to solve this problem, some have proposed to penalize the norm of
the Jacobian of the model to control its Lipschitz constant (Drucker & Le Cun, 1992; Cisse et al., 2017;
Bartlett et al., 2017; Hein & Andriushchenko, 2017). Other approaches perform data augmentation
by producing and training on adversarial examples (Goodfellow et al., 2015). Unfortunately, all
of these methods add signiﬁcant computational overhead to ERM. Here, we show that mixup can
signiﬁcantly improve the robustness of neural networks without hindering the speed of ERM by
penalizing the norm of the gradient of the loss w.r.t a given input along the most plausible directions
(e.g. the directions to other training points). Indeed, Figure 2 shows that mixup results in models
having a smaller loss and gradient norm between examples compared to vanilla ERM.

To assess the robustness of mixup models to adversarial examples, we use three ResNet-101 models:
two of them trained using ERM on ImageNet-2012, and the third trained using mixup. In the ﬁrst
set of experiments, we study the robustness of one ERM model and the mixup model against white
box attacks. That is, for each of the two models, we use the model itself to generate adversarial
examples, either using the Fast Gradient Sign Method (FGSM) or the Iterative FGSM (I-FGSM)
methods (Goodfellow et al., 2015), allowing a maximum perturbation of (cid:15) = 4 for every pixel. For
I-FGSM, we use 10 iterations with equal step size. In the second set of experiments, we evaluate
robustness against black box attacks. That is, we use the ﬁrst ERM model to produce adversarial
examples using FGSM and I-FGSM. Then, we test the robustness of the second ERM model and the
mixup model to these examples. The results of both settings are summarized in Table 3.

For the FGSM white box attack, the mixup model is 2.7 times more robust than the ERM model in
terms of Top-1 error. For the FGSM black box attack, the mixup model is 1.25 times more robust
than the ERM model in terms of Top-1 error. Also, while both mixup and ERM are not robust to
white box I-FGSM attacks, mixup is about 40% more robust than ERM in the black box I-FGSM
setting. Overall, mixup produces neural networks that are signiﬁcantly more robust than ERM against
adversarial examples in white box and black settings without additional overhead compared to ERM.

7

Published as a conference paper at ICLR 2018

Dataset

ERM mixup

Dataset

ERM mixup

Abalone
Arcene
Arrhythmia

74.0
57.6
56.6

73.6
48.0
46.3

Htru2
Iris
Phishing

2.0
21.3
16.3

2.0
17.3
15.2

Table 4: ERM and mixup classiﬁcation errors on the UCI datasets.

ERM GAN

mixup GAN (α = 0.2)

Figure 5: Effect of mixup on stabilizing GAN training at iterations 10, 100, 1000, 10000, and 20000.

3.6 TABULAR DATA

To further explore the performance of mixup on non-image data, we performed a series of experiments
on six arbitrary classiﬁcation problems drawn from the UCI dataset (Lichman, 2013). The neural
networks in this section are fully-connected, and have two hidden layers of 128 ReLU units. The
parameters of these neural networks are learned using Adam (Kingma & Ba, 2015) with default
hyper-parameters, over 10 epochs of mini-batches of size 16. Table 4 shows that mixup improves the
average test error on four out of the six considered datasets, and never underperforms ERM.

3.7 STABILIZATION OF GENERATIVE ADVERSARIAL NETWORKS (GANS)

Generative Adversarial Networks, also known as GANs (Goodfellow et al., 2014), are a powerful
family of implicit generative models. In GANs, a generator and a discriminator compete against
each other to model a distribution P . On the one hand, the generator g competes to transform noise
vectors z
P . On the other hand, the
discriminator competes to distinguish between real samples x and fake samples g(z). Mathematically,
training a GAN is equivalent to solving the optimization problem

Q into fake samples g(z) that resemble real samples x

∼

∼

max
g

min
d

E
x,z

(cid:96)(d(x), 1) + (cid:96)(d(g(z)), 0),

where (cid:96) is the binary cross entropy loss. Unfortunately, solving the previous min-max equation is a
notoriously difﬁcult optimization problem (Goodfellow, 2016), since the discriminator often provides
the generator with vanishing gradients. We argue that mixup should stabilize GAN training because it
acts as a regularizer on the gradients of the discriminator, akin to the binary classiﬁer in Figure 1b.
Then, the smoothness of the discriminator guarantees a stable source of gradient information to the
generator. The mixup formulation of GANs is:

max
g

min
d

E
x,z,λ

(cid:96)(d(λx + (1

λ)g(z)), λ).

−

Figure 5 illustrates the stabilizing effect of mixup the training of GAN (orange samples) when
modeling two toy datasets (blue samples). The neural networks in these experiments are fully-
connected and have three hidden layers of 512 ReLU units. The generator network accepts two-
dimensional Gaussian noise vectors. The networks are trained for 20,000 mini-batches of size
128 using the Adam optimizer with default parameters, where the discriminator is trained for ﬁve
iterations before every generator iteration. The training of mixup GANs seems promisingly robust to
hyper-parameter and architectural choices.

8

Published as a conference paper at ICLR 2018

Method

Speciﬁcation

ERM

mixup

mix labels and latent
representations
(AC + RP)

mix inputs only

AC + RP
AC + KNN

Layer 1
Layer 2
Layer 3
Layer 4
Layer 5

label smoothing
(Szegedy et al., 2016)

mix inputs +
label smoothing
(AC + RP)

add Gaussian noise
to inputs

(cid:15) = 0.05
(cid:15) = 0.1
(cid:15) = 0.2

(cid:15) = 0.05
(cid:15) = 0.1
(cid:15) = 0.2
(cid:15) = 0.4

σ = 0.05
σ = 0.1
σ = 0.2

SC + KNN (Chawla et al., 2002)
AC + KNN
SC + RP
AC + RP

Modiﬁed

Weight decay

Input Target
(cid:55)

(cid:55)

10−4

5

×

(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:51)
(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:51)
(cid:51)

(cid:55)
(cid:55)
(cid:55)

(cid:51)
(cid:51)
(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:51)

5.53
(cid:51) 4.24
(cid:51) 4.98
(cid:51) 4.44
(cid:51) 4.56
(cid:51) 5.39
(cid:51) 5.95
(cid:51) 5.39
(cid:55)
(cid:55)
(cid:55)
(cid:55)

5.45
5.43
5.23
5.17
(cid:51) 5.25
(cid:51) 5.33
(cid:51) 5.34
(cid:51) 5.02
(cid:51) 5.08
(cid:51) 4.98
(cid:51) 5.25
(cid:55)
(cid:55)
(cid:55)

5.53
6.41
7.16

10−4

5.18

4.68
5.26

4.51
4.61
5.55
5.43
5.15

5.52
5.48
5.55
5.72

5.02
5.17
5.06

5.40
5.09
5.06
5.39

5.04
5.86
7.24

Table 5: Results of the ablation studies on the CIFAR-10 dataset. Reported are the median test errors
of the last 10 epochs. A tick ((cid:51)) means the component is different from standard ERM training,
whereas a cross ((cid:55)) means it follows the standard training practice. AC: mix between all classes. SC:
mix within the same class. RP: mix between random pairs. KNN: mix between k-nearest neighbors
(k=200). Please refer to the text for details about the experiments and interpretations.

3.8 ABLATION STUDIES

mixup is a data augmentation method that consists of only two parts: random convex combination of
raw inputs, and correspondingly, convex combination of one-hot label encodings. However, there are
several design choices to make. For example, on how to augment the inputs, we could have chosen
to interpolate the latent representations (i.e. feature maps) of a neural network, and we could have
chosen to interpolate only between the nearest neighbors, or only between inputs of the same class.
When the inputs to interpolate come from two different classes, we could have chosen to assign a
single label to the synthetic input, for example using the label of the input that weights more in the
convex combination. To compare mixup with these alternative possibilities, we run a set of ablation
study experiments using the PreAct ResNet-18 architecture on the CIFAR-10 dataset.
Speciﬁcally, for each of the data augmentation methods, we test two weight decay settings (10−4
10−4 which works well for ERM). All the other settings and
which works well for mixup, and 5
hyperparameters are the same as reported in Section 3.2.

×

To compare interpolating raw inputs with interpolating latent representations, we test on random
convex combination of the learned representations before each residual block (denoted Layer 1-4)
or before the uppermost “average pooling + fully connected” layer (denoted Layer 5). To compare
mixing random pairs of inputs (RP) with mixing nearest neighbors (KNN), we ﬁrst compute the 200
nearest neighbors for each training sample, either from the same class (SC) or from all the classes
(AC). Then during training, for each sample in a minibatch, we replace the sample with a synthetic
sample by convex combination with a random draw from its nearest neighbors. To compare mixing
all the classes (AC) with mixing within the same class (SC), we convex combine a minibatch with a

9

Published as a conference paper at ICLR 2018

random permutation of its sample index, where the permutation is done in a per-batch basis (AC) or a
per-class basis (SC). To compare mixing inputs and labels with mixing inputs only, we either use a
convex combination of the two one-hot encodings as the target, or select the one-hot encoding of the
closer training sample as the target. For label smoothing, we follow Szegedy et al. (2016) and use
(cid:15)
9(cid:15)
10 as the target for incorrect classes, and 1
10 as the target for the correct class.Adding Gaussian
noise to inputs is used as another baseline. We report the median test errors of the last 10 epochs.
Results are shown in Table 5.

−

From the ablation study experiments, we have the following observations. First, mixup is the best
data augmentation method we test, and is signiﬁcantly better than the second best method (mix input
+ label smoothing). Second, the effect of regularization can be seen by comparing the test error with a
small weight decay (10−4) with a large one (5
10−4). For example, for ERM a large weight decay
works better, whereas for mixup a small weight decay is preferred, conﬁrming its regularization effects.
We also see an increasing advantage of large weight decay when interpolating in higher layers of latent
representations, indicating decreasing strength of regularization. Among all the input interpolation
methods, mixing random pairs from all classes (AC + RP) has the strongest regularization effect.
Label smoothing and adding Gaussian noise have a relatively small regularization effect. Finally,
we note that the SMOTE algorithm (Chawla et al., 2002) does not lead to a noticeable gain in
performance.

×

4 RELATED WORK

Data augmentation lies at the heart of all successful applications of deep learning, ranging from image
classiﬁcation (Krizhevsky et al., 2012) to speech recognition (Graves et al., 2013; Amodei et al.,
2016). In all cases, substantial domain knowledge is leveraged to design suitable data transformations
leading to improved generalization. In image classiﬁcation, for example, one routinely uses rotation,
translation, cropping, resizing, ﬂipping (Lecun et al., 2001; Simonyan & Zisserman, 2015), and
random erasing (Zhong et al., 2017) to enforce visually plausible invariances in the model through
the training data. Similarly, in speech recognition, noise injection is a prevalent practice to improve
the robustness and accuracy of the trained models (Amodei et al., 2016).

More related to mixup, Chawla et al. (2002) propose to augment the rare class in an imbalanced
dataset by interpolating the nearest neighbors; DeVries & Taylor (2017) show that interpolation and
extrapolation the nearest neighbors of the same class in feature space can improve generalization.
However, their proposals only operate among the nearest neighbors within a certain class at the
input / feature level, and hence does not account for changes in the corresponding labels. Recent
approaches have also proposed to regularize the output distribution of a neural network by label
smoothing (Szegedy et al., 2016), or penalizing high-conﬁdence softmax distributions (Pereyra et al.,
2017). These methods bear similarities with mixup in the sense that supervision depends on multiple
smooth labels, rather than on single hard labels as in traditional ERM. However, the label smoothing
in these works is applied or regularized independently from the associated feature values.

mixup enjoys several desirable aspects of previous data augmentation and regularization schemes
without suffering from their drawbacks. Like the method of DeVries & Taylor (2017), it does not
require signiﬁcant domain knowledge. Like label smoothing, the supervision of every example is not
overly dominated by the ground-truth label. Unlike both of these approaches, the mixup transformation
establishes a linear relationship between data augmentation and the supervision signal. We believe
that this leads to a strong regularizer that improves generalization as demonstrated by our experiments.
The linearity constraint, through its effect on the derivatives of the function approximated, also relates
mixup to other methods such as Sobolev training of neural networks (Czarnecki et al., 2017) or
WGAN-GP (Gulrajani et al., 2017).

5 DISCUSSION

We have proposed mixup, a data-agnostic and straightforward data augmentation principle. We
have shown that mixup is a form of vicinal risk minimization, which trains on virtual examples
constructed as the linear interpolation of two random examples from the training set and their labels.
Incorporating mixup into existing training pipelines reduces to a few lines of code, and introduces
little or no computational overhead. Throughout an extensive evaluation, we have shown that mixup

10

Published as a conference paper at ICLR 2018

improves the generalization error of state-of-the-art models on ImageNet, CIFAR, speech, and
tabular datasets. Furthermore, mixup helps to combat memorization of corrupt labels, sensitivity to
adversarial examples, and instability in adversarial training.

In our experiments, the following trend is consistent: with increasingly large α, the training error on
real data increases, while the generalization gap decreases. This sustains our hypothesis that mixup
implicitly controls model complexity. However, we do not yet have a good theory for understanding
the ‘sweet spot’ of this bias-variance trade-off. For example, in CIFAR-10 classiﬁcation we can
get very low training error on real data even when α
(i.e., training only on averages of pairs
of real examples), whereas in ImageNet classiﬁcation, the training error on real data increases
signiﬁcantly with α
. Based on our ImageNet and Google commands experiments with different
model architectures, we conjecture that increasing the model capacity would make training error less
sensitive to large α, hence giving mixup a more signiﬁcant advantage.

→ ∞

→ ∞

mixup also opens up several possibilities for further exploration. First, is it possible to make
similar ideas work on other types of supervised learning problems, such as regression and structured
prediction? While generalizing mixup to regression problems is straightforward, its application
to structured prediction problems such as image segmentation remains less obvious. Second, can
similar methods prove helpful beyond supervised learning? The interpolation principle seems like a
reasonable inductive bias which might also help in unsupervised, semi-supervised, and reinforcement
learning. Can we extend mixup to feature-label extrapolation to guarantee a robust model behavior
far away from the training data? Although our discussion of these directions is still speculative, we
are excited about the possibilities mixup opens up, and hope that our observations will prove useful
for future development.

We would like to thank Priya Goyal, Yossi Adi and the PyTorch team. We also thank the Anonymous
Review 2 for proposing the mixup + dropout experiments.

ACKNOWLEDGEMENTS

REFERENCES

D. Amodei, S. Ananthanarayanan, R. Anubhai, J. Bai, E. Battenberg, C. Case, J. Casper, B. Catanzaro, Q. Cheng,
G. Chen, et al. Deep speech 2: End-to-end speech recognition in English and Mandarin. In ICML, 2016.

D. Arpit, S. Jastrzebski, N. Ballas, D. Krueger, E. Bengio, M. S. Kanwal, T. Maharaj, A. Fischer, A. Courville,

Y. Bengio, et al. A closer look at memorization in deep networks. ICML, 2017.

P. Bartlett, D. J. Foster, and M. Telgarsky. Spectrally-normalized margin bounds for neural networks. NIPS,

2017.

O. Chapelle, J. Weston, L. Bottou, and V. Vapnik. Vicinal risk minimization. NIPS, 2000.

N. V. Chawla, K. W. Bowyer, L. O. Hall, and W. P. Kegelmeyer. SMOTE: synthetic minority over-sampling

technique. Journal of artiﬁcial intelligence research, 16:321–357, 2002.

C. Chelba, T. Mikolov, M. Schuster, Q. Ge, T. Brants, P. Koehn, and T. Robinson. One billion word benchmark

for measuring progress in statistical language modeling. arXiv, 2013.

M. Cisse, P. Bojanowski, E. Grave, Y. Dauphin, and N. Usunier. Parseval networks: Improving robustness to

adversarial examples. ICML, 2017.

W. M. Czarnecki, S. Osindero, M. Jaderberg, G. ´Swirszcz, and R. Pascanu. Sobolev training for neural networks.

NIPS, 2017.

T. DeVries and G. W. Taylor. Dataset augmentation in feature space. ICLR Workshops, 2017.

H. Drucker and Y. Le Cun.

Improving generalization performance using double backpropagation.

IEEE

Transactions on Neural Networks, 3(6):991–997, 1992.

I. Goodfellow. Tutorial: Generative adversarial networks. NIPS, 2016.

I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio.

Generative adversarial nets. NIPS, 2014.

11

Published as a conference paper at ICLR 2018

IEEE, 2013.

NIPS, 2017.

JMLR, 2017.

2017.

NIPS, 2012.

I. J. Goodfellow, J. Shlens, and C. Szegedy. Explaining and harnessing adversarial examples. ICLR, 2015.

P. Goyal, P. Doll´ar, R. Girshick, P. Noordhuis, L. Wesolowski, A. Kyrola, A. Tulloch, Y. Jia, and K. He. Accurate,

large minibatch SGD: Training ImageNet in 1 hour. arXiv, 2017.

A. Graves, A.-r. Mohamed, and G. Hinton. Speech recognition with deep recurrent neural networks. In ICASSP.

I. Gulrajani, F. Ahmed, M. Arjovsky, V. Dumoulin, and A. Courville. Improved training of Wasserstein GANs.

N. Harvey, C. Liaw, and A. Mehrabian. Nearly-tight VC-dimension bounds for piecewise linear neural networks.

K. He, X. Zhang, S. Ren, and J. Sun. Identity mappings in deep residual networks. ECCV, 2016.

M. Hein and M. Andriushchenko. Formal guarantees on the robustness of a classiﬁer against adversarial

manipulation. NIPS, 2017.

G. Hinton, L. Deng, D. Yu, G. E. Dahl, A.-r. Mohamed, N. Jaitly, A. Senior, V. Vanhoucke, P. Nguyen, T. N.
Sainath, et al. Deep neural networks for acoustic modeling in speech recognition: The shared views of four
research groups. IEEE Signal Processing Magazine, 2012.

G. Huang, Z. Liu, L. van der Maaten, and K. Q. Weinberger. Densely connected convolutional networks. CVPR,

D. Kingma and J. Ba. Adam: A method for stochastic optimization. ICLR, 2015.

A. Krizhevsky, I. Sutskever, and G. E. Hinton. ImageNet classiﬁcation with deep convolutional neural networks.

Y. Lecun, L. Bottou, Y. Bengio, and P. Haffner. Gradient-based learning applied to document recognition.

Proceedings of IEEE, 2001.

M. Lichman. UCI machine learning repository, 2013.

K. Liu, 2017. URL https://github.com/kuangliu/pytorch-cifar.

G. Pereyra, G. Tucker, J. Chorowski, Ł. Kaiser, and G. Hinton. Regularizing neural networks by penalizing

conﬁdent output distributions. ICLR Workshops, 2017.

O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein,

A. C. Berg, and L. Fei-Fei. ImageNet large scale visual recognition challenge. IJCV, 2015.

D. Silver, A. Huang, C. J. Maddison, A. Guez, L. Sifre, G. Van Den Driessche, J. Schrittwieser, I. Antonoglou,
V. Panneershelvam, M. Lanctot, et al. Mastering the game of Go with deep neural networks and tree search.
Nature, 2016.

P. Simard, Y. LeCun, J. Denker, and B. Victorri. Transformation invariance in pattern recognitiontangent distance

and tangent propagation. Neural networks: tricks of the trade, 1998.

K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale image recognition. ICLR,

2015.

net. ICLR Workshops, 2015.

J. T. Springenberg, A. Dosovitskiy, T. Brox, and M. Riedmiller. Striving for simplicity: The all convolutional

N. Srivastava, G. E. Hinton, A. Krizhevsky, I. Sutskever, and R. Salakhutdinov. Dropout: a simple way to
prevent neural networks from overﬁtting. Journal of Machine Learning Research, 15(1):1929–1958, 2014.

C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Erhan, I. J. Goodfellow, and R. Fergus. Intriguing properties

of neural networks. ICLR, 2014.

C. Szegedy, V. Vanhoucke, S. Ioffe, J. Shlens, and Z. Wojna. Rethinking the Inception architecture for computer

vision. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2016.

V. N. Vapnik. Statistical learning theory. J. Wiley, 1998.

V. Vapnik and A. Y. Chervonenkis. On the uniform convergence of relative frequencies of events to their

probabilities. Theory of Probability and its Applications, 1971.

12

Published as a conference paper at ICLR 2018

A. Veit, 2017. URL https://github.com/andreasveit.

P. Warden,

2017.

URL

https://research.googleblog.com/2017/08/

launching-speech-commands-dataset.html.

S. Xie, R. Girshick, P. Doll´ar, Z. Tu, and K. He. Aggregated residual transformations for deep neural networks.

CVPR, 2016.

S. Zagoruyko and N. Komodakis. Wide residual networks. BMVC, 2016a.

S. Zagoruyko and N. Komodakis,
wide-residual-networks.

2016b.

URL https://github.com/szagoruyko/

C. Zhang, S. Bengio, M. Hardt, B. Recht, and O. Vinyals. Understanding deep learning requires rethinking

generalization. ICLR, 2017.

C. Zhang, 2017. URL https://github.com/pluskid/fitting-random-labels.

Z. Zhong, L. Zheng, G. Kang, S. Li, and Y. Yang. Random erasing data augmentation. arXiv, 2017.

13

8
1
0
2
 
r
p
A
 
7
2
 
 
]

G
L
.
s
c
[
 
 
2
v
2
1
4
9
0
.
0
1
7
1
:
v
i
X
r
a

Published as a conference paper at ICLR 2018

mixup: BEYOND EMPIRICAL RISK MINIMIZATION

Hongyi Zhang
MIT

Moustapha Cisse, Yann N. Dauphin, David Lopez-Paz∗
FAIR

ABSTRACT

Large deep neural networks are powerful, but exhibit undesirable behaviors such
as memorization and sensitivity to adversarial examples. In this work, we propose
mixup, a simple learning principle to alleviate these issues. In essence, mixup trains
a neural network on convex combinations of pairs of examples and their labels.
By doing so, mixup regularizes the neural network to favor simple linear behavior
in-between training examples. Our experiments on the ImageNet-2012, CIFAR-10,
CIFAR-100, Google commands and UCI datasets show that mixup improves the
generalization of state-of-the-art neural network architectures. We also ﬁnd that
mixup reduces the memorization of corrupt labels, increases the robustness to
adversarial examples, and stabilizes the training of generative adversarial networks.

1

INTRODUCTION

Large deep neural networks have enabled breakthroughs in ﬁelds such as computer vision (Krizhevsky
et al., 2012), speech recognition (Hinton et al., 2012), and reinforcement learning (Silver et al., 2016).
In most successful applications, these neural networks share two commonalities. First, they are
trained as to minimize their average error over the training data, a learning rule also known as the
Empirical Risk Minimization (ERM) principle (Vapnik, 1998). Second, the size of these state-of-the-
art neural networks scales linearly with the number of training examples. For instance, the network of
104 images in the CIFAR-10 dataset,
Springenberg et al. (2015) used 106 parameters to model the 5
the network of (Simonyan & Zisserman, 2015) used 108 parameters to model the 106 images in the
1010 parameters to model
ImageNet-2012 dataset, and the network of Chelba et al. (2013) used 2
the 109 words in the One Billion Word dataset.

·

·

Strikingly, a classical result in learning theory (Vapnik & Chervonenkis, 1971) tells us that the
convergence of ERM is guaranteed as long as the size of the learning machine (e.g., the neural
network) does not increase with the number of training data. Here, the size of a learning machine is
measured in terms of its number of parameters or, relatedly, its VC-complexity (Harvey et al., 2017).

This contradiction challenges the suitability of ERM to train our current neural network models, as
highlighted in recent research. On the one hand, ERM allows large neural networks to memorize
(instead of generalize from) the training data even in the presence of strong regularization, or in
classiﬁcation problems where the labels are assigned at random (Zhang et al., 2017). On the other
hand, neural networks trained with ERM change their predictions drastically when evaluated on
examples just outside the training distribution (Szegedy et al., 2014), also known as adversarial
examples. This evidence suggests that ERM is unable to explain or provide generalization on testing
distributions that differ only slightly from the training data. However, what is the alternative to ERM?

The method of choice to train on similar but different examples to the training data is known as data
augmentation (Simard et al., 1998), formalized by the Vicinal Risk Minimization (VRM) principle
(Chapelle et al., 2000). In VRM, human knowledge is required to describe a vicinity or neighborhood
around each example in the training data. Then, additional virtual examples can be drawn from the
vicinity distribution of the training examples to enlarge the support of the training distribution. For
instance, when performing image classiﬁcation, it is common to deﬁne the vicinity of one image
as the set of its horizontal reﬂections, slight rotations, and mild scalings. While data augmentation
consistently leads to improved generalization (Simard et al., 1998), the procedure is dataset-dependent,
and thus requires the use of expert knowledge. Furthermore, data augmentation assumes that the

∗Alphabetical order.

1

Published as a conference paper at ICLR 2018

examples in the vicinity share the same class, and does not model the vicinity relation across examples
of different classes.

Contribution Motivated by these issues, we introduce a simple and data-agnostic data augmenta-
tion routine, termed mixup (Section 2). In a nutshell, mixup constructs virtual training examples

˜x = λxi + (1
˜y = λyi + (1

λ)xj,
λ)yj,

−
−

where xi, xj are raw input vectors
where yi, yj are one-hot label encodings

(xi, yi) and (xj, yj) are two examples drawn at random from our training data, and λ
[0, 1].
Therefore, mixup extends the training distribution by incorporating the prior knowledge that linear
interpolations of feature vectors should lead to linear interpolations of the associated targets. mixup
can be implemented in a few lines of code, and introduces minimal computation overhead.

∈

Despite its simplicity, mixup allows a new state-of-the-art performance in the CIFAR-10, CIFAR-
100, and ImageNet-2012 image classiﬁcation datasets (Sections 3.1 and 3.2). Furthermore, mixup
increases the robustness of neural networks when learning from corrupt labels (Section 3.4), or facing
adversarial examples (Section 3.5). Finally, mixup improves generalization on speech (Sections 3.3)
and tabular (Section 3.6) data, and can be used to stabilize the training of GANs (Section 3.7). The
source-code necessary to replicate our CIFAR-10 experiments is available at:

https://github.com/facebookresearch/mixup-cifar10.

To understand the effects of various design choices in mixup, we conduct a thorough set of ablation
study experiments (Section 3.8). The results suggest that mixup performs signiﬁcantly better than
related methods in previous work, and each of the design choices contributes to the ﬁnal performance.
We conclude by exploring the connections to prior work (Section 4), as well as offering some points
for discussion (Section 5).

2 FROM EMPIRICAL RISK MINIMIZATION TO mixup

In supervised learning, we are interested in ﬁnding a function f
that describes the relationship
between a random feature vector X and a random target vector Y , which follow the joint distribution
P (X, Y ). To this end, we ﬁrst deﬁne a loss function (cid:96) that penalizes the differences between
predictions f (x) and actual targets y, for examples (x, y)
P . Then, we minimize the average of
the loss function (cid:96) over the data distribution P , also known as the expected risk:

∈ F

∼

(cid:90)

R(f ) =

(cid:96)(f (x), y)dP (x, y).

Unfortunately, the distribution P is unknown in most practical situations. Instead, we usually have
P for all i = 1, . . . , n. Using
access to a set of training data
the training data

n
i=1, where (xi, yi)
(xi, yi)
}
{
, we may approximate P by the empirical distribution

∼

=

D

D

Pδ(x, y) =

δ(x = xi, y = yi),

1
n

n
(cid:88)

i=1

where δ(x = xi, y = yi) is a Dirac mass centered at (xi, yi). Using the empirical distribution Pδ, we
can now approximate the expected risk by the empirical risk:

(cid:90)

Rδ(f ) =

(cid:96)(f (x), y)dPδ(x, y) =

(cid:96)(f (xi), yi).

(1)

1
n

n
(cid:88)

i=1

Learning the function f by minimizing (1) is known as the Empirical Risk Minimization (ERM)
principle (Vapnik, 1998). While efﬁcient to compute, the empirical risk (1) monitors the behaviour
of f only at a ﬁnite set of n examples. When considering functions with a number parameters
comparable to n (such as large neural networks), one trivial way to minimize (1) is to memorize the
training data (Zhang et al., 2017). Memorization, in turn, leads to the undesirable behaviour of f
outside the training data (Szegedy et al., 2014).

2

Published as a conference paper at ICLR 2018

# y1, y2 should be one-hot vectors
for (x1, y1), (x2, y2) in zip(loader1, loader2):

lam = numpy.random.beta(alpha, alpha)
x = Variable(lam * x1 + (1. - lam) * x2)
y = Variable(lam * y1 + (1. - lam) * y2)
optimizer.zero_grad()

loss(net(x), y).backward()

optimizer.step()

(a) One epoch of mixup training in PyTorch.

Figure 1: Illustration of mixup, which converges to ERM as α

0.

→

(b) Effect of mixup (α = 1) on a
toy problem. Green: Class 0. Or-
ange: Class 1. Blue shading indicates
p(y = 1|x).

However, the na¨ıve estimate Pδ is one out of many possible choices to approximate the true distribu-
tion P . For instance, in the Vicinal Risk Minimization (VRM) principle (Chapelle et al., 2000), the
distribution P is approximated by

Pν(˜x, ˜y) =

xi, yi),
ν(˜x, ˜y
|

1
n

n
(cid:88)

i=1

where ν is a vicinity distribution that measures the probability of ﬁnding the virtual feature-target
pair (˜x, ˜y) in the vicinity of the training feature-target pair (xi, yi). In particular, Chapelle et al.
xi, σ2)δ(˜y = yi), which is equivalent
(2000) considered Gaussian vicinities ν(˜x, ˜y
xi, yi) =
−
N
|
to augmenting the training data with additive Gaussian noise. To learn using VRM, we sample the
m
(˜xi, ˜yi)
ν :=
i=1, and minimize the empirical vicinal
vicinal distribution to construct a dataset
}
{
risk:
m
(cid:88)

(˜x

D

Rν(f ) =

(cid:96)(f (˜xi), ˜yi).

1
m

i=1

The contribution of this paper is to propose a generic vicinal distribution, called mixup:

xi, yi) =
µ(˜x, ˜y
|

[δ(˜x = λ

xi + (1

λ)

xj, ˜y = λ

yi + (1

λ)

yj)] ,

·

−

·

·

−

·

1
n

n
(cid:88)

j

E
λ

Beta(α, α), for α
where λ
∞
produces virtual feature-target vectors

(0,

∼

∈

). In a nutshell, sampling from the mixup vicinal distribution

˜x = λxi + (1
˜y = λyi + (1

λ)xj,
λ)yj,

−
−

where (xi, yi) and (xj, yj) are two feature-target vectors drawn at random from the training data, and
λ
[0, 1]. The mixup hyper-parameter α controls the strength of interpolation between feature-target
pairs, recovering the ERM principle as α

0.

∈

→

The implementation of mixup training is straightforward, and introduces a minimal computation
overhead. Figure 1a shows the few lines of code necessary to implement mixup training in PyTorch.
Finally, we mention alternative design choices. First, in preliminary experiments we ﬁnd that convex
combinations of three or more examples with weights sampled from a Dirichlet distribution does not
provide further gain, but increases the computation cost of mixup. Second, our current implementation
uses a single data loader to obtain one minibatch, and then mixup is applied to the same minibatch
after random shufﬂing. We found this strategy works equally well, while reducing I/O requirements.
Third, interpolating only between inputs with equal label did not lead to the performance gains of
mixup discussed in the sequel. More empirical comparison can be found in Section 3.8.

What is mixup doing? The mixup vicinal distribution can be understood as a form of data aug-
mentation that encourages the model f to behave linearly in-between training examples. We argue
that this linear behaviour reduces the amount of undesirable oscillations when predicting outside the
training examples. Also, linearity is a good inductive bias from the perspective of Occam’s razor,

3

Published as a conference paper at ICLR 2018

(a) Prediction errors in-between training data. Evalu-
ated at x = λxi +(1−λ)xj, a prediction is counted as
a “miss” if it does not belong to {yi, yj}. The model
trained with mixup has fewer misses.

(b) Norm of the gradients of the model w.r.t. input
in-between training data, evaluated at x = λxi +
(1 − λ)xj. The model trained with mixup has smaller
gradient norms.

Figure 2: mixup leads to more robust model behaviors in-between the training data.

Method

Epochs Top-1 Error Top-5 Error

ERM (Goyal et al., 2017)
mixup α = 0.2

ERM (Goyal et al., 2017)
mixup α = 0.2

ResNeXt-101 32*4d ERM (Xie et al., 2016)

ResNeXt-101 64*4d ERM (Xie et al., 2016)

Model

ResNet-50

ResNet-101

ResNet-50

ResNet-101

ERM
mixup α = 0.4

mixup α = 0.4

ERM
mixup α = 0.2

ERM
mixup α = 0.2

mixup α = 0.4

ResNeXt-101 32*4d ERM

90
90

90
90

100
90
90

100
90

200
200

200
200

200
200

23.5
23.3

22.1
21.5

21.2
21.2
20.7

20.4
19.8

23.6
22.1

22.0
20.8

21.3
20.1

-
6.6

-
5.6

-
5.6
5.3

5.3
4.9

7.0
6.1

6.1
5.4

5.9
5.0

Table 1: Validation errors for ERM and mixup on the development set of ImageNet-2012.

since it is one of the simplest possible behaviors. Figure 1b shows that mixup leads to decision
boundaries that transition linearly from class to class, providing a smoother estimate of uncertainty.
Figure 2 illustrate the average behaviors of two neural network models trained on the CIFAR-10
dataset using ERM and mixup. Both models have the same architecture, are trained with the same
procedure, and are evaluated at the same points in-between randomly sampled training data. The
model trained with mixup is more stable in terms of model predictions and gradient norms in-between
training samples.

3 EXPERIMENTS

3.1

IMAGENET CLASSIFICATION

We evaluate mixup on the ImageNet-2012 classiﬁcation dataset (Russakovsky et al., 2015). This
dataset contains 1.3 million training images and 50,000 validation images, from a total of 1,000 classes.
For training, we follow standard data augmentation practices: scale and aspect ratio distortions,
random crops, and horizontal ﬂips (Goyal et al., 2017). During evaluation, only the 224
224 central
crop of each image is tested. We use mixup and ERM to train several state-of-the-art ImageNet-2012
classiﬁcation models, and report both top-1 and top-5 error rates in Table 1.

×

4

Published as a conference paper at ICLR 2018

Dataset

Model

ERM mixup

CIFAR-10

CIFAR-100

PreAct ResNet-18
WideResNet-28-10
DenseNet-BC-190

PreAct ResNet-18
WideResNet-28-10
DenseNet-BC-190

5.6
3.8
3.7

25.6
19.4
19.0

4.2
2.7
2.7

21.1
17.5
16.8

(a) Test errors for the CIFAR experiments.

Figure 3: Test errors for ERM and mixup on the CIFAR experiments.

(b) Test error evolution for the best
ERM and mixup models.

For all the experiments in this section, we use data-parallel distributed training in Caffe21 with
a minibatch size of 1,024. We use the learning rate schedule described in (Goyal et al., 2017).
Speciﬁcally, the learning rate is increased linearly from 0.1 to 0.4 during the ﬁrst 5 epochs, and it is
then divided by 10 after 30, 60 and 80 epochs when training for 90 epochs; or after 60, 120 and 180
epochs when training for 200 epochs.

∈

For mixup, we ﬁnd that α
[0.1, 0.4] leads to improved performance over ERM, whereas for large α,
mixup leads to underﬁtting. We also ﬁnd that models with higher capacities and/or longer training
runs are the ones to beneﬁt the most from mixup. For example, when trained for 90 epochs, the mixup
variants of ResNet-101 and ResNeXt-101 obtain a greater improvement (0.5% to 0.6%) over their
ERM analogues than the gain of smaller models such as ResNet-50 (0.2%). When trained for 200
epochs, the top-1 error of the mixup variant of ResNet-50 is further reduced by 1.2% compared to the
90 epoch run, whereas its ERM analogue stays the same.

3.2 CIFAR-10 AND CIFAR-100

We conduct additional image classiﬁcation experiments on the CIFAR-10 and CIFAR-100 datasets
to further evaluate the generalization performance of mixup. In particular, we compare ERM and
mixup training for: PreAct ResNet-18 (He et al., 2016) as implemented in (Liu, 2017), WideResNet-
28-10 (Zagoruyko & Komodakis, 2016a) as implemented in (Zagoruyko & Komodakis, 2016b), and
DenseNet (Huang et al., 2017) as implemented in (Veit, 2017). For DenseNet, we change the growth
rate to 40 to follow the DenseNet-BC-190 speciﬁcation from (Huang et al., 2017). For mixup, we
ﬁx α = 1, which results in interpolations λ uniformly distributed between zero and one. All models
are trained on a single Nvidia Tesla P100 GPU using PyTorch2 for 200 epochs on the training set
with 128 examples per minibatch, and evaluated on the test set. Learning rates start at 0.1 and are
divided by 10 after 100 and 150 epochs for all models except WideResNet. For WideResNet, we
follow (Zagoruyko & Komodakis, 2016a) and divide the learning rate by 10 after 60, 120 and 180
epochs. Weight decay is set to 10−4. We do not use dropout in these experiments.

We summarize our results in Figure 3a. In both CIFAR-10 and CIFAR-100 classiﬁcation problems,
the models trained using mixup signiﬁcantly outperform their analogues trained with ERM. As seen
in Figure 3b, mixup and ERM converge at a similar speed to their best test errors. Note that the
DenseNet models in (Huang et al., 2017) were trained for 300 epochs with further learning rate
decays scheduled at the 150 and 225 epochs, which may explain the discrepancy the performance of
DenseNet reported in Figure 3a and the original result of Huang et al. (2017).

3.3 SPEECH DATA

Next, we perform speech recognition experiments using the Google commands dataset (Warden,
2017). The dataset contains 65,000 utterances, where each utterance is about one-second long and
belongs to one out of 30 classes. The classes correspond to voice commands such as yes, no, down,
left, as pronounced by a few thousand different speakers. To preprocess the utterances, we ﬁrst

1https://caffe2.ai
2http://pytorch.org

5

Published as a conference paper at ICLR 2018

Model

Method

Validation set Test set

LeNet

VGG-11

ERM
mixup (α = 0.1)
mixup (α = 0.2)

ERM
mixup (α = 0.1)
mixup (α = 0.2)

9.8
10.1
10.2

5.0
4.0
3.9

10.3
10.8
11.3

4.6
3.8
3.4

Figure 4: Classiﬁcation errors of ERM and mixup on the Google commands dataset.

extract normalized spectrograms from the original waveforms at a sampling rate of 16 kHz. Next, we
101. For speech data, it is reasonable to
zero-pad the spectrograms to equalize their sizes at 160
apply mixup both at the waveform and spectrogram levels. Here, we apply mixup at the spectrogram
level just before feeding the data to the network.

×

For this experiment, we compare a LeNet (Lecun et al., 2001) and a VGG-11 (Simonyan & Zisserman,
2015) architecture, each of them composed by two convolutional and two fully-connected layers.
We train each model for 30 epochs with minibatches of 100 examples, using Adam as the optimizer
10−3 and is divided by 10
(Kingma & Ba, 2015). Training starts with a learning rate equal to 3
every 10 epochs. For mixup, we use a warm-up period of ﬁve epochs where we train the network on
original training examples, since we ﬁnd it speeds up initial convergence. Table 4 shows that mixup
outperforms ERM on this task, specially when using VGG-11, the model with larger capacity.

×

3.4 MEMORIZATION OF CORRUPTED LABELS

Following Zhang et al. (2017), we evaluate the robustness of ERM and mixup models against randomly
corrupted labels. We hypothesize that increasing the strength of mixup interpolation α should generate
virtual examples further from the training examples, making memorization more difﬁcult to achieve.
In particular, it should be easier to learn interpolations between real examples compared to memorizing
interpolations involving random labels. We adapt an open-source implementation (Zhang, 2017)
to generate three CIFAR-10 training sets, where 20%, 50%, or 80% of the labels are replaced by
random noise, respectively. All the test labels are kept intact for evaluation. Dropout (Srivastava
et al., 2014) is considered the state-of-the-art method for learning with corrupted labels (Arpit et al.,
2017). Thus, we compare in these experiments mixup, dropout, mixup + dropout, and ERM. For
mixup, we choose α
; for dropout, we add one dropout layer in each PreAct block after
∈ {
the ReLU activation layer between two convolution layers, as suggested in (Zagoruyko & Komodakis,
2016a). We choose the dropout probability p
. For the combination of mixup
∈ {
}
and dropout, we choose α
and p
. These experiments use the PreAct
}
∈ {
ResNet-18 (He et al., 2016) model implemented in (Liu, 2017). All the other settings are the same as
in Section 3.2.

0.5, 0.7, 0.8, 0.9
0.3, 0.5, 0.7

1, 2, 8, 32
}

1, 2, 4, 8
}

∈ {

We summarize our results in Table 2, where we note the best test error achieved during the training
session, as well as the ﬁnal test error after 200 epochs. To quantify the amount of memorization, we
also evaluate the training errors at the last epoch on real labels and corrupted labels. As the training
progresses with a smaller learning rate (e.g. less than 0.01), the ERM model starts to overﬁt the
corrupted labels. When using a large probability (e.g. 0.7 or 0.8), dropout can effectively reduce
overﬁtting. mixup with a large α (e.g. 8 or 32) outperforms dropout on both the best and last epoch
test errors, and achieves lower training error on real labels while remaining resistant to noisy labels.
Interestingly, mixup + dropout performs the best of all, showing that the two methods are compatible.

3.5 ROBUSTNESS TO ADVERSARIAL EXAMPLES

One undesirable consequence of models trained using ERM is their fragility to adversarial exam-
ples (Szegedy et al., 2014). Adversarial examples are obtained by adding tiny (visually imperceptible)
perturbations to legitimate examples in order to deteriorate the performance of the model. The adver-
sarial noise is generated by ascending the gradient of the loss surface with respect to the legitimate
example. Improving the robustness to adversarial examples is a topic of active research.

6

Published as a conference paper at ICLR 2018

Label corruption Method

Test error

Training error

Real Corrupted

ERM
ERM + dropout (p = 0.7)
mixup (α = 8)
mixup + dropout (α = 4, p = 0.1)

ERM
ERM + dropout (p = 0.8)
mixup (α = 32)
mixup + dropout (α = 8, p = 0.3)

ERM
ERM + dropout (p = 0.8)
mixup (α = 32)
mixup + dropout (α = 8, p = 0.3)

Best

12.7
8.8
5.9
6.2

18.8
14.1
11.3
10.9

36.5
30.9
25.3
24.0

Last

16.6
10.4
6.4
6.2

44.6
15.5
12.7
10.9

73.9
35.1
30.9
24.8

0.05
5.26
2.27
1.92

0.26
12.71
5.84
7.56

0.62
29.84
18.92
19.70

0.28
83.55
86.32
85.02

0.64
86.98
85.71
87.90

0.83
86.37
85.44
87.67

20%

50%

80%

Table 2: Results on the corrupted label experiments for the best models.

Metric Method

FGSM I-FGSM

Metric Method

FGSM I-FGSM

Top-1

Top-5

ERM
mixup

ERM
mixup

90.7
75.2

63.1
49.1

99.9
99.6

93.4
95.8

Top-1

Top-5

ERM
mixup

ERM
mixup

57.0
46.0

24.8
17.4

57.3
40.9

18.1
11.8

(a) White box attacks.

(b) Black box attacks.

Table 3: Classiﬁcation errors of ERM and mixup models when tested on adversarial examples.

Among the several methods aiming to solve this problem, some have proposed to penalize the norm of
the Jacobian of the model to control its Lipschitz constant (Drucker & Le Cun, 1992; Cisse et al., 2017;
Bartlett et al., 2017; Hein & Andriushchenko, 2017). Other approaches perform data augmentation
by producing and training on adversarial examples (Goodfellow et al., 2015). Unfortunately, all
of these methods add signiﬁcant computational overhead to ERM. Here, we show that mixup can
signiﬁcantly improve the robustness of neural networks without hindering the speed of ERM by
penalizing the norm of the gradient of the loss w.r.t a given input along the most plausible directions
(e.g. the directions to other training points). Indeed, Figure 2 shows that mixup results in models
having a smaller loss and gradient norm between examples compared to vanilla ERM.

To assess the robustness of mixup models to adversarial examples, we use three ResNet-101 models:
two of them trained using ERM on ImageNet-2012, and the third trained using mixup. In the ﬁrst
set of experiments, we study the robustness of one ERM model and the mixup model against white
box attacks. That is, for each of the two models, we use the model itself to generate adversarial
examples, either using the Fast Gradient Sign Method (FGSM) or the Iterative FGSM (I-FGSM)
methods (Goodfellow et al., 2015), allowing a maximum perturbation of (cid:15) = 4 for every pixel. For
I-FGSM, we use 10 iterations with equal step size. In the second set of experiments, we evaluate
robustness against black box attacks. That is, we use the ﬁrst ERM model to produce adversarial
examples using FGSM and I-FGSM. Then, we test the robustness of the second ERM model and the
mixup model to these examples. The results of both settings are summarized in Table 3.

For the FGSM white box attack, the mixup model is 2.7 times more robust than the ERM model in
terms of Top-1 error. For the FGSM black box attack, the mixup model is 1.25 times more robust
than the ERM model in terms of Top-1 error. Also, while both mixup and ERM are not robust to
white box I-FGSM attacks, mixup is about 40% more robust than ERM in the black box I-FGSM
setting. Overall, mixup produces neural networks that are signiﬁcantly more robust than ERM against
adversarial examples in white box and black settings without additional overhead compared to ERM.

7

Published as a conference paper at ICLR 2018

Dataset

ERM mixup

Dataset

ERM mixup

Abalone
Arcene
Arrhythmia

74.0
57.6
56.6

73.6
48.0
46.3

Htru2
Iris
Phishing

2.0
21.3
16.3

2.0
17.3
15.2

Table 4: ERM and mixup classiﬁcation errors on the UCI datasets.

ERM GAN

mixup GAN (α = 0.2)

Figure 5: Effect of mixup on stabilizing GAN training at iterations 10, 100, 1000, 10000, and 20000.

3.6 TABULAR DATA

To further explore the performance of mixup on non-image data, we performed a series of experiments
on six arbitrary classiﬁcation problems drawn from the UCI dataset (Lichman, 2013). The neural
networks in this section are fully-connected, and have two hidden layers of 128 ReLU units. The
parameters of these neural networks are learned using Adam (Kingma & Ba, 2015) with default
hyper-parameters, over 10 epochs of mini-batches of size 16. Table 4 shows that mixup improves the
average test error on four out of the six considered datasets, and never underperforms ERM.

3.7 STABILIZATION OF GENERATIVE ADVERSARIAL NETWORKS (GANS)

Generative Adversarial Networks, also known as GANs (Goodfellow et al., 2014), are a powerful
family of implicit generative models. In GANs, a generator and a discriminator compete against
each other to model a distribution P . On the one hand, the generator g competes to transform noise
vectors z
P . On the other hand, the
discriminator competes to distinguish between real samples x and fake samples g(z). Mathematically,
training a GAN is equivalent to solving the optimization problem

Q into fake samples g(z) that resemble real samples x

∼

∼

max
g

min
d

E
x,z

(cid:96)(d(x), 1) + (cid:96)(d(g(z)), 0),

where (cid:96) is the binary cross entropy loss. Unfortunately, solving the previous min-max equation is a
notoriously difﬁcult optimization problem (Goodfellow, 2016), since the discriminator often provides
the generator with vanishing gradients. We argue that mixup should stabilize GAN training because it
acts as a regularizer on the gradients of the discriminator, akin to the binary classiﬁer in Figure 1b.
Then, the smoothness of the discriminator guarantees a stable source of gradient information to the
generator. The mixup formulation of GANs is:

max
g

min
d

E
x,z,λ

(cid:96)(d(λx + (1

λ)g(z)), λ).

−

Figure 5 illustrates the stabilizing effect of mixup the training of GAN (orange samples) when
modeling two toy datasets (blue samples). The neural networks in these experiments are fully-
connected and have three hidden layers of 512 ReLU units. The generator network accepts two-
dimensional Gaussian noise vectors. The networks are trained for 20,000 mini-batches of size
128 using the Adam optimizer with default parameters, where the discriminator is trained for ﬁve
iterations before every generator iteration. The training of mixup GANs seems promisingly robust to
hyper-parameter and architectural choices.

8

Published as a conference paper at ICLR 2018

Method

Speciﬁcation

ERM

mixup

mix labels and latent
representations
(AC + RP)

mix inputs only

AC + RP
AC + KNN

Layer 1
Layer 2
Layer 3
Layer 4
Layer 5

label smoothing
(Szegedy et al., 2016)

mix inputs +
label smoothing
(AC + RP)

add Gaussian noise
to inputs

(cid:15) = 0.05
(cid:15) = 0.1
(cid:15) = 0.2

(cid:15) = 0.05
(cid:15) = 0.1
(cid:15) = 0.2
(cid:15) = 0.4

σ = 0.05
σ = 0.1
σ = 0.2

SC + KNN (Chawla et al., 2002)
AC + KNN
SC + RP
AC + RP

Modiﬁed

Weight decay

Input Target
(cid:55)

(cid:55)

10−4

5

×

(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:51)
(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:51)
(cid:51)

(cid:55)
(cid:55)
(cid:55)

(cid:51)
(cid:51)
(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:51)

5.53
(cid:51) 4.24
(cid:51) 4.98
(cid:51) 4.44
(cid:51) 4.56
(cid:51) 5.39
(cid:51) 5.95
(cid:51) 5.39
(cid:55)
(cid:55)
(cid:55)
(cid:55)

5.45
5.43
5.23
5.17
(cid:51) 5.25
(cid:51) 5.33
(cid:51) 5.34
(cid:51) 5.02
(cid:51) 5.08
(cid:51) 4.98
(cid:51) 5.25
(cid:55)
(cid:55)
(cid:55)

5.53
6.41
7.16

10−4

5.18

4.68
5.26

4.51
4.61
5.55
5.43
5.15

5.52
5.48
5.55
5.72

5.02
5.17
5.06

5.40
5.09
5.06
5.39

5.04
5.86
7.24

Table 5: Results of the ablation studies on the CIFAR-10 dataset. Reported are the median test errors
of the last 10 epochs. A tick ((cid:51)) means the component is different from standard ERM training,
whereas a cross ((cid:55)) means it follows the standard training practice. AC: mix between all classes. SC:
mix within the same class. RP: mix between random pairs. KNN: mix between k-nearest neighbors
(k=200). Please refer to the text for details about the experiments and interpretations.

3.8 ABLATION STUDIES

mixup is a data augmentation method that consists of only two parts: random convex combination of
raw inputs, and correspondingly, convex combination of one-hot label encodings. However, there are
several design choices to make. For example, on how to augment the inputs, we could have chosen
to interpolate the latent representations (i.e. feature maps) of a neural network, and we could have
chosen to interpolate only between the nearest neighbors, or only between inputs of the same class.
When the inputs to interpolate come from two different classes, we could have chosen to assign a
single label to the synthetic input, for example using the label of the input that weights more in the
convex combination. To compare mixup with these alternative possibilities, we run a set of ablation
study experiments using the PreAct ResNet-18 architecture on the CIFAR-10 dataset.
Speciﬁcally, for each of the data augmentation methods, we test two weight decay settings (10−4
10−4 which works well for ERM). All the other settings and
which works well for mixup, and 5
hyperparameters are the same as reported in Section 3.2.

×

To compare interpolating raw inputs with interpolating latent representations, we test on random
convex combination of the learned representations before each residual block (denoted Layer 1-4)
or before the uppermost “average pooling + fully connected” layer (denoted Layer 5). To compare
mixing random pairs of inputs (RP) with mixing nearest neighbors (KNN), we ﬁrst compute the 200
nearest neighbors for each training sample, either from the same class (SC) or from all the classes
(AC). Then during training, for each sample in a minibatch, we replace the sample with a synthetic
sample by convex combination with a random draw from its nearest neighbors. To compare mixing
all the classes (AC) with mixing within the same class (SC), we convex combine a minibatch with a

9

Published as a conference paper at ICLR 2018

random permutation of its sample index, where the permutation is done in a per-batch basis (AC) or a
per-class basis (SC). To compare mixing inputs and labels with mixing inputs only, we either use a
convex combination of the two one-hot encodings as the target, or select the one-hot encoding of the
closer training sample as the target. For label smoothing, we follow Szegedy et al. (2016) and use
(cid:15)
9(cid:15)
10 as the target for incorrect classes, and 1
10 as the target for the correct class.Adding Gaussian
noise to inputs is used as another baseline. We report the median test errors of the last 10 epochs.
Results are shown in Table 5.

−

From the ablation study experiments, we have the following observations. First, mixup is the best
data augmentation method we test, and is signiﬁcantly better than the second best method (mix input
+ label smoothing). Second, the effect of regularization can be seen by comparing the test error with a
small weight decay (10−4) with a large one (5
10−4). For example, for ERM a large weight decay
works better, whereas for mixup a small weight decay is preferred, conﬁrming its regularization effects.
We also see an increasing advantage of large weight decay when interpolating in higher layers of latent
representations, indicating decreasing strength of regularization. Among all the input interpolation
methods, mixing random pairs from all classes (AC + RP) has the strongest regularization effect.
Label smoothing and adding Gaussian noise have a relatively small regularization effect. Finally,
we note that the SMOTE algorithm (Chawla et al., 2002) does not lead to a noticeable gain in
performance.

×

4 RELATED WORK

Data augmentation lies at the heart of all successful applications of deep learning, ranging from image
classiﬁcation (Krizhevsky et al., 2012) to speech recognition (Graves et al., 2013; Amodei et al.,
2016). In all cases, substantial domain knowledge is leveraged to design suitable data transformations
leading to improved generalization. In image classiﬁcation, for example, one routinely uses rotation,
translation, cropping, resizing, ﬂipping (Lecun et al., 2001; Simonyan & Zisserman, 2015), and
random erasing (Zhong et al., 2017) to enforce visually plausible invariances in the model through
the training data. Similarly, in speech recognition, noise injection is a prevalent practice to improve
the robustness and accuracy of the trained models (Amodei et al., 2016).

More related to mixup, Chawla et al. (2002) propose to augment the rare class in an imbalanced
dataset by interpolating the nearest neighbors; DeVries & Taylor (2017) show that interpolation and
extrapolation the nearest neighbors of the same class in feature space can improve generalization.
However, their proposals only operate among the nearest neighbors within a certain class at the
input / feature level, and hence does not account for changes in the corresponding labels. Recent
approaches have also proposed to regularize the output distribution of a neural network by label
smoothing (Szegedy et al., 2016), or penalizing high-conﬁdence softmax distributions (Pereyra et al.,
2017). These methods bear similarities with mixup in the sense that supervision depends on multiple
smooth labels, rather than on single hard labels as in traditional ERM. However, the label smoothing
in these works is applied or regularized independently from the associated feature values.

mixup enjoys several desirable aspects of previous data augmentation and regularization schemes
without suffering from their drawbacks. Like the method of DeVries & Taylor (2017), it does not
require signiﬁcant domain knowledge. Like label smoothing, the supervision of every example is not
overly dominated by the ground-truth label. Unlike both of these approaches, the mixup transformation
establishes a linear relationship between data augmentation and the supervision signal. We believe
that this leads to a strong regularizer that improves generalization as demonstrated by our experiments.
The linearity constraint, through its effect on the derivatives of the function approximated, also relates
mixup to other methods such as Sobolev training of neural networks (Czarnecki et al., 2017) or
WGAN-GP (Gulrajani et al., 2017).

5 DISCUSSION

We have proposed mixup, a data-agnostic and straightforward data augmentation principle. We
have shown that mixup is a form of vicinal risk minimization, which trains on virtual examples
constructed as the linear interpolation of two random examples from the training set and their labels.
Incorporating mixup into existing training pipelines reduces to a few lines of code, and introduces
little or no computational overhead. Throughout an extensive evaluation, we have shown that mixup

10

Published as a conference paper at ICLR 2018

improves the generalization error of state-of-the-art models on ImageNet, CIFAR, speech, and
tabular datasets. Furthermore, mixup helps to combat memorization of corrupt labels, sensitivity to
adversarial examples, and instability in adversarial training.

In our experiments, the following trend is consistent: with increasingly large α, the training error on
real data increases, while the generalization gap decreases. This sustains our hypothesis that mixup
implicitly controls model complexity. However, we do not yet have a good theory for understanding
the ‘sweet spot’ of this bias-variance trade-off. For example, in CIFAR-10 classiﬁcation we can
get very low training error on real data even when α
(i.e., training only on averages of pairs
of real examples), whereas in ImageNet classiﬁcation, the training error on real data increases
signiﬁcantly with α
. Based on our ImageNet and Google commands experiments with different
model architectures, we conjecture that increasing the model capacity would make training error less
sensitive to large α, hence giving mixup a more signiﬁcant advantage.

→ ∞

→ ∞

mixup also opens up several possibilities for further exploration. First, is it possible to make
similar ideas work on other types of supervised learning problems, such as regression and structured
prediction? While generalizing mixup to regression problems is straightforward, its application
to structured prediction problems such as image segmentation remains less obvious. Second, can
similar methods prove helpful beyond supervised learning? The interpolation principle seems like a
reasonable inductive bias which might also help in unsupervised, semi-supervised, and reinforcement
learning. Can we extend mixup to feature-label extrapolation to guarantee a robust model behavior
far away from the training data? Although our discussion of these directions is still speculative, we
are excited about the possibilities mixup opens up, and hope that our observations will prove useful
for future development.

We would like to thank Priya Goyal, Yossi Adi and the PyTorch team. We also thank the Anonymous
Review 2 for proposing the mixup + dropout experiments.

ACKNOWLEDGEMENTS

REFERENCES

D. Amodei, S. Ananthanarayanan, R. Anubhai, J. Bai, E. Battenberg, C. Case, J. Casper, B. Catanzaro, Q. Cheng,
G. Chen, et al. Deep speech 2: End-to-end speech recognition in English and Mandarin. In ICML, 2016.

D. Arpit, S. Jastrzebski, N. Ballas, D. Krueger, E. Bengio, M. S. Kanwal, T. Maharaj, A. Fischer, A. Courville,

Y. Bengio, et al. A closer look at memorization in deep networks. ICML, 2017.

P. Bartlett, D. J. Foster, and M. Telgarsky. Spectrally-normalized margin bounds for neural networks. NIPS,

2017.

O. Chapelle, J. Weston, L. Bottou, and V. Vapnik. Vicinal risk minimization. NIPS, 2000.

N. V. Chawla, K. W. Bowyer, L. O. Hall, and W. P. Kegelmeyer. SMOTE: synthetic minority over-sampling

technique. Journal of artiﬁcial intelligence research, 16:321–357, 2002.

C. Chelba, T. Mikolov, M. Schuster, Q. Ge, T. Brants, P. Koehn, and T. Robinson. One billion word benchmark

for measuring progress in statistical language modeling. arXiv, 2013.

M. Cisse, P. Bojanowski, E. Grave, Y. Dauphin, and N. Usunier. Parseval networks: Improving robustness to

adversarial examples. ICML, 2017.

W. M. Czarnecki, S. Osindero, M. Jaderberg, G. ´Swirszcz, and R. Pascanu. Sobolev training for neural networks.

NIPS, 2017.

T. DeVries and G. W. Taylor. Dataset augmentation in feature space. ICLR Workshops, 2017.

H. Drucker and Y. Le Cun.

Improving generalization performance using double backpropagation.

IEEE

Transactions on Neural Networks, 3(6):991–997, 1992.

I. Goodfellow. Tutorial: Generative adversarial networks. NIPS, 2016.

I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio.

Generative adversarial nets. NIPS, 2014.

11

Published as a conference paper at ICLR 2018

IEEE, 2013.

NIPS, 2017.

JMLR, 2017.

2017.

NIPS, 2012.

I. J. Goodfellow, J. Shlens, and C. Szegedy. Explaining and harnessing adversarial examples. ICLR, 2015.

P. Goyal, P. Doll´ar, R. Girshick, P. Noordhuis, L. Wesolowski, A. Kyrola, A. Tulloch, Y. Jia, and K. He. Accurate,

large minibatch SGD: Training ImageNet in 1 hour. arXiv, 2017.

A. Graves, A.-r. Mohamed, and G. Hinton. Speech recognition with deep recurrent neural networks. In ICASSP.

I. Gulrajani, F. Ahmed, M. Arjovsky, V. Dumoulin, and A. Courville. Improved training of Wasserstein GANs.

N. Harvey, C. Liaw, and A. Mehrabian. Nearly-tight VC-dimension bounds for piecewise linear neural networks.

K. He, X. Zhang, S. Ren, and J. Sun. Identity mappings in deep residual networks. ECCV, 2016.

M. Hein and M. Andriushchenko. Formal guarantees on the robustness of a classiﬁer against adversarial

manipulation. NIPS, 2017.

G. Hinton, L. Deng, D. Yu, G. E. Dahl, A.-r. Mohamed, N. Jaitly, A. Senior, V. Vanhoucke, P. Nguyen, T. N.
Sainath, et al. Deep neural networks for acoustic modeling in speech recognition: The shared views of four
research groups. IEEE Signal Processing Magazine, 2012.

G. Huang, Z. Liu, L. van der Maaten, and K. Q. Weinberger. Densely connected convolutional networks. CVPR,

D. Kingma and J. Ba. Adam: A method for stochastic optimization. ICLR, 2015.

A. Krizhevsky, I. Sutskever, and G. E. Hinton. ImageNet classiﬁcation with deep convolutional neural networks.

Y. Lecun, L. Bottou, Y. Bengio, and P. Haffner. Gradient-based learning applied to document recognition.

Proceedings of IEEE, 2001.

M. Lichman. UCI machine learning repository, 2013.

K. Liu, 2017. URL https://github.com/kuangliu/pytorch-cifar.

G. Pereyra, G. Tucker, J. Chorowski, Ł. Kaiser, and G. Hinton. Regularizing neural networks by penalizing

conﬁdent output distributions. ICLR Workshops, 2017.

O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein,

A. C. Berg, and L. Fei-Fei. ImageNet large scale visual recognition challenge. IJCV, 2015.

D. Silver, A. Huang, C. J. Maddison, A. Guez, L. Sifre, G. Van Den Driessche, J. Schrittwieser, I. Antonoglou,
V. Panneershelvam, M. Lanctot, et al. Mastering the game of Go with deep neural networks and tree search.
Nature, 2016.

P. Simard, Y. LeCun, J. Denker, and B. Victorri. Transformation invariance in pattern recognitiontangent distance

and tangent propagation. Neural networks: tricks of the trade, 1998.

K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale image recognition. ICLR,

2015.

net. ICLR Workshops, 2015.

J. T. Springenberg, A. Dosovitskiy, T. Brox, and M. Riedmiller. Striving for simplicity: The all convolutional

N. Srivastava, G. E. Hinton, A. Krizhevsky, I. Sutskever, and R. Salakhutdinov. Dropout: a simple way to
prevent neural networks from overﬁtting. Journal of Machine Learning Research, 15(1):1929–1958, 2014.

C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Erhan, I. J. Goodfellow, and R. Fergus. Intriguing properties

of neural networks. ICLR, 2014.

C. Szegedy, V. Vanhoucke, S. Ioffe, J. Shlens, and Z. Wojna. Rethinking the Inception architecture for computer

vision. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2016.

V. N. Vapnik. Statistical learning theory. J. Wiley, 1998.

V. Vapnik and A. Y. Chervonenkis. On the uniform convergence of relative frequencies of events to their

probabilities. Theory of Probability and its Applications, 1971.

12

Published as a conference paper at ICLR 2018

A. Veit, 2017. URL https://github.com/andreasveit.

P. Warden,

2017.

URL

https://research.googleblog.com/2017/08/

launching-speech-commands-dataset.html.

S. Xie, R. Girshick, P. Doll´ar, Z. Tu, and K. He. Aggregated residual transformations for deep neural networks.

CVPR, 2016.

S. Zagoruyko and N. Komodakis. Wide residual networks. BMVC, 2016a.

S. Zagoruyko and N. Komodakis,
wide-residual-networks.

2016b.

URL https://github.com/szagoruyko/

C. Zhang, S. Bengio, M. Hardt, B. Recht, and O. Vinyals. Understanding deep learning requires rethinking

generalization. ICLR, 2017.

C. Zhang, 2017. URL https://github.com/pluskid/fitting-random-labels.

Z. Zhong, L. Zheng, G. Kang, S. Li, and Y. Yang. Random erasing data augmentation. arXiv, 2017.

13

8
1
0
2
 
r
p
A
 
7
2
 
 
]

G
L
.
s
c
[
 
 
2
v
2
1
4
9
0
.
0
1
7
1
:
v
i
X
r
a

Published as a conference paper at ICLR 2018

mixup: BEYOND EMPIRICAL RISK MINIMIZATION

Hongyi Zhang
MIT

Moustapha Cisse, Yann N. Dauphin, David Lopez-Paz∗
FAIR

ABSTRACT

Large deep neural networks are powerful, but exhibit undesirable behaviors such
as memorization and sensitivity to adversarial examples. In this work, we propose
mixup, a simple learning principle to alleviate these issues. In essence, mixup trains
a neural network on convex combinations of pairs of examples and their labels.
By doing so, mixup regularizes the neural network to favor simple linear behavior
in-between training examples. Our experiments on the ImageNet-2012, CIFAR-10,
CIFAR-100, Google commands and UCI datasets show that mixup improves the
generalization of state-of-the-art neural network architectures. We also ﬁnd that
mixup reduces the memorization of corrupt labels, increases the robustness to
adversarial examples, and stabilizes the training of generative adversarial networks.

1

INTRODUCTION

Large deep neural networks have enabled breakthroughs in ﬁelds such as computer vision (Krizhevsky
et al., 2012), speech recognition (Hinton et al., 2012), and reinforcement learning (Silver et al., 2016).
In most successful applications, these neural networks share two commonalities. First, they are
trained as to minimize their average error over the training data, a learning rule also known as the
Empirical Risk Minimization (ERM) principle (Vapnik, 1998). Second, the size of these state-of-the-
art neural networks scales linearly with the number of training examples. For instance, the network of
104 images in the CIFAR-10 dataset,
Springenberg et al. (2015) used 106 parameters to model the 5
the network of (Simonyan & Zisserman, 2015) used 108 parameters to model the 106 images in the
1010 parameters to model
ImageNet-2012 dataset, and the network of Chelba et al. (2013) used 2
the 109 words in the One Billion Word dataset.

·

·

Strikingly, a classical result in learning theory (Vapnik & Chervonenkis, 1971) tells us that the
convergence of ERM is guaranteed as long as the size of the learning machine (e.g., the neural
network) does not increase with the number of training data. Here, the size of a learning machine is
measured in terms of its number of parameters or, relatedly, its VC-complexity (Harvey et al., 2017).

This contradiction challenges the suitability of ERM to train our current neural network models, as
highlighted in recent research. On the one hand, ERM allows large neural networks to memorize
(instead of generalize from) the training data even in the presence of strong regularization, or in
classiﬁcation problems where the labels are assigned at random (Zhang et al., 2017). On the other
hand, neural networks trained with ERM change their predictions drastically when evaluated on
examples just outside the training distribution (Szegedy et al., 2014), also known as adversarial
examples. This evidence suggests that ERM is unable to explain or provide generalization on testing
distributions that differ only slightly from the training data. However, what is the alternative to ERM?

The method of choice to train on similar but different examples to the training data is known as data
augmentation (Simard et al., 1998), formalized by the Vicinal Risk Minimization (VRM) principle
(Chapelle et al., 2000). In VRM, human knowledge is required to describe a vicinity or neighborhood
around each example in the training data. Then, additional virtual examples can be drawn from the
vicinity distribution of the training examples to enlarge the support of the training distribution. For
instance, when performing image classiﬁcation, it is common to deﬁne the vicinity of one image
as the set of its horizontal reﬂections, slight rotations, and mild scalings. While data augmentation
consistently leads to improved generalization (Simard et al., 1998), the procedure is dataset-dependent,
and thus requires the use of expert knowledge. Furthermore, data augmentation assumes that the

∗Alphabetical order.

1

Published as a conference paper at ICLR 2018

examples in the vicinity share the same class, and does not model the vicinity relation across examples
of different classes.

Contribution Motivated by these issues, we introduce a simple and data-agnostic data augmenta-
tion routine, termed mixup (Section 2). In a nutshell, mixup constructs virtual training examples

˜x = λxi + (1
˜y = λyi + (1

λ)xj,
λ)yj,

−
−

where xi, xj are raw input vectors
where yi, yj are one-hot label encodings

(xi, yi) and (xj, yj) are two examples drawn at random from our training data, and λ
[0, 1].
Therefore, mixup extends the training distribution by incorporating the prior knowledge that linear
interpolations of feature vectors should lead to linear interpolations of the associated targets. mixup
can be implemented in a few lines of code, and introduces minimal computation overhead.

∈

Despite its simplicity, mixup allows a new state-of-the-art performance in the CIFAR-10, CIFAR-
100, and ImageNet-2012 image classiﬁcation datasets (Sections 3.1 and 3.2). Furthermore, mixup
increases the robustness of neural networks when learning from corrupt labels (Section 3.4), or facing
adversarial examples (Section 3.5). Finally, mixup improves generalization on speech (Sections 3.3)
and tabular (Section 3.6) data, and can be used to stabilize the training of GANs (Section 3.7). The
source-code necessary to replicate our CIFAR-10 experiments is available at:

https://github.com/facebookresearch/mixup-cifar10.

To understand the effects of various design choices in mixup, we conduct a thorough set of ablation
study experiments (Section 3.8). The results suggest that mixup performs signiﬁcantly better than
related methods in previous work, and each of the design choices contributes to the ﬁnal performance.
We conclude by exploring the connections to prior work (Section 4), as well as offering some points
for discussion (Section 5).

2 FROM EMPIRICAL RISK MINIMIZATION TO mixup

In supervised learning, we are interested in ﬁnding a function f
that describes the relationship
between a random feature vector X and a random target vector Y , which follow the joint distribution
P (X, Y ). To this end, we ﬁrst deﬁne a loss function (cid:96) that penalizes the differences between
predictions f (x) and actual targets y, for examples (x, y)
P . Then, we minimize the average of
the loss function (cid:96) over the data distribution P , also known as the expected risk:

∈ F

∼

(cid:90)

R(f ) =

(cid:96)(f (x), y)dP (x, y).

Unfortunately, the distribution P is unknown in most practical situations. Instead, we usually have
P for all i = 1, . . . , n. Using
access to a set of training data
the training data

n
i=1, where (xi, yi)
(xi, yi)
}
{
, we may approximate P by the empirical distribution

∼

=

D

D

Pδ(x, y) =

δ(x = xi, y = yi),

1
n

n
(cid:88)

i=1

where δ(x = xi, y = yi) is a Dirac mass centered at (xi, yi). Using the empirical distribution Pδ, we
can now approximate the expected risk by the empirical risk:

(cid:90)

Rδ(f ) =

(cid:96)(f (x), y)dPδ(x, y) =

(cid:96)(f (xi), yi).

(1)

1
n

n
(cid:88)

i=1

Learning the function f by minimizing (1) is known as the Empirical Risk Minimization (ERM)
principle (Vapnik, 1998). While efﬁcient to compute, the empirical risk (1) monitors the behaviour
of f only at a ﬁnite set of n examples. When considering functions with a number parameters
comparable to n (such as large neural networks), one trivial way to minimize (1) is to memorize the
training data (Zhang et al., 2017). Memorization, in turn, leads to the undesirable behaviour of f
outside the training data (Szegedy et al., 2014).

2

Published as a conference paper at ICLR 2018

# y1, y2 should be one-hot vectors
for (x1, y1), (x2, y2) in zip(loader1, loader2):

lam = numpy.random.beta(alpha, alpha)
x = Variable(lam * x1 + (1. - lam) * x2)
y = Variable(lam * y1 + (1. - lam) * y2)
optimizer.zero_grad()

loss(net(x), y).backward()

optimizer.step()

(a) One epoch of mixup training in PyTorch.

Figure 1: Illustration of mixup, which converges to ERM as α

0.

→

(b) Effect of mixup (α = 1) on a
toy problem. Green: Class 0. Or-
ange: Class 1. Blue shading indicates
p(y = 1|x).

However, the na¨ıve estimate Pδ is one out of many possible choices to approximate the true distribu-
tion P . For instance, in the Vicinal Risk Minimization (VRM) principle (Chapelle et al., 2000), the
distribution P is approximated by

Pν(˜x, ˜y) =

xi, yi),
ν(˜x, ˜y
|

1
n

n
(cid:88)

i=1

where ν is a vicinity distribution that measures the probability of ﬁnding the virtual feature-target
pair (˜x, ˜y) in the vicinity of the training feature-target pair (xi, yi). In particular, Chapelle et al.
xi, σ2)δ(˜y = yi), which is equivalent
(2000) considered Gaussian vicinities ν(˜x, ˜y
xi, yi) =
−
N
|
to augmenting the training data with additive Gaussian noise. To learn using VRM, we sample the
m
(˜xi, ˜yi)
ν :=
i=1, and minimize the empirical vicinal
vicinal distribution to construct a dataset
}
{
risk:
m
(cid:88)

(˜x

D

Rν(f ) =

(cid:96)(f (˜xi), ˜yi).

1
m

i=1

The contribution of this paper is to propose a generic vicinal distribution, called mixup:

xi, yi) =
µ(˜x, ˜y
|

[δ(˜x = λ

xi + (1

λ)

xj, ˜y = λ

yi + (1

λ)

yj)] ,

·

−

·

·

−

·

1
n

n
(cid:88)

j

E
λ

Beta(α, α), for α
where λ
∞
produces virtual feature-target vectors

(0,

∼

∈

). In a nutshell, sampling from the mixup vicinal distribution

˜x = λxi + (1
˜y = λyi + (1

λ)xj,
λ)yj,

−
−

where (xi, yi) and (xj, yj) are two feature-target vectors drawn at random from the training data, and
λ
[0, 1]. The mixup hyper-parameter α controls the strength of interpolation between feature-target
pairs, recovering the ERM principle as α

0.

∈

→

The implementation of mixup training is straightforward, and introduces a minimal computation
overhead. Figure 1a shows the few lines of code necessary to implement mixup training in PyTorch.
Finally, we mention alternative design choices. First, in preliminary experiments we ﬁnd that convex
combinations of three or more examples with weights sampled from a Dirichlet distribution does not
provide further gain, but increases the computation cost of mixup. Second, our current implementation
uses a single data loader to obtain one minibatch, and then mixup is applied to the same minibatch
after random shufﬂing. We found this strategy works equally well, while reducing I/O requirements.
Third, interpolating only between inputs with equal label did not lead to the performance gains of
mixup discussed in the sequel. More empirical comparison can be found in Section 3.8.

What is mixup doing? The mixup vicinal distribution can be understood as a form of data aug-
mentation that encourages the model f to behave linearly in-between training examples. We argue
that this linear behaviour reduces the amount of undesirable oscillations when predicting outside the
training examples. Also, linearity is a good inductive bias from the perspective of Occam’s razor,

3

Published as a conference paper at ICLR 2018

(a) Prediction errors in-between training data. Evalu-
ated at x = λxi +(1−λ)xj, a prediction is counted as
a “miss” if it does not belong to {yi, yj}. The model
trained with mixup has fewer misses.

(b) Norm of the gradients of the model w.r.t. input
in-between training data, evaluated at x = λxi +
(1 − λ)xj. The model trained with mixup has smaller
gradient norms.

Figure 2: mixup leads to more robust model behaviors in-between the training data.

Method

Epochs Top-1 Error Top-5 Error

ERM (Goyal et al., 2017)
mixup α = 0.2

ERM (Goyal et al., 2017)
mixup α = 0.2

ResNeXt-101 32*4d ERM (Xie et al., 2016)

ResNeXt-101 64*4d ERM (Xie et al., 2016)

Model

ResNet-50

ResNet-101

ResNet-50

ResNet-101

ERM
mixup α = 0.4

mixup α = 0.4

ERM
mixup α = 0.2

ERM
mixup α = 0.2

mixup α = 0.4

ResNeXt-101 32*4d ERM

90
90

90
90

100
90
90

100
90

200
200

200
200

200
200

23.5
23.3

22.1
21.5

21.2
21.2
20.7

20.4
19.8

23.6
22.1

22.0
20.8

21.3
20.1

-
6.6

-
5.6

-
5.6
5.3

5.3
4.9

7.0
6.1

6.1
5.4

5.9
5.0

Table 1: Validation errors for ERM and mixup on the development set of ImageNet-2012.

since it is one of the simplest possible behaviors. Figure 1b shows that mixup leads to decision
boundaries that transition linearly from class to class, providing a smoother estimate of uncertainty.
Figure 2 illustrate the average behaviors of two neural network models trained on the CIFAR-10
dataset using ERM and mixup. Both models have the same architecture, are trained with the same
procedure, and are evaluated at the same points in-between randomly sampled training data. The
model trained with mixup is more stable in terms of model predictions and gradient norms in-between
training samples.

3 EXPERIMENTS

3.1

IMAGENET CLASSIFICATION

We evaluate mixup on the ImageNet-2012 classiﬁcation dataset (Russakovsky et al., 2015). This
dataset contains 1.3 million training images and 50,000 validation images, from a total of 1,000 classes.
For training, we follow standard data augmentation practices: scale and aspect ratio distortions,
random crops, and horizontal ﬂips (Goyal et al., 2017). During evaluation, only the 224
224 central
crop of each image is tested. We use mixup and ERM to train several state-of-the-art ImageNet-2012
classiﬁcation models, and report both top-1 and top-5 error rates in Table 1.

×

4

Published as a conference paper at ICLR 2018

Dataset

Model

ERM mixup

CIFAR-10

CIFAR-100

PreAct ResNet-18
WideResNet-28-10
DenseNet-BC-190

PreAct ResNet-18
WideResNet-28-10
DenseNet-BC-190

5.6
3.8
3.7

25.6
19.4
19.0

4.2
2.7
2.7

21.1
17.5
16.8

(a) Test errors for the CIFAR experiments.

Figure 3: Test errors for ERM and mixup on the CIFAR experiments.

(b) Test error evolution for the best
ERM and mixup models.

For all the experiments in this section, we use data-parallel distributed training in Caffe21 with
a minibatch size of 1,024. We use the learning rate schedule described in (Goyal et al., 2017).
Speciﬁcally, the learning rate is increased linearly from 0.1 to 0.4 during the ﬁrst 5 epochs, and it is
then divided by 10 after 30, 60 and 80 epochs when training for 90 epochs; or after 60, 120 and 180
epochs when training for 200 epochs.

∈

For mixup, we ﬁnd that α
[0.1, 0.4] leads to improved performance over ERM, whereas for large α,
mixup leads to underﬁtting. We also ﬁnd that models with higher capacities and/or longer training
runs are the ones to beneﬁt the most from mixup. For example, when trained for 90 epochs, the mixup
variants of ResNet-101 and ResNeXt-101 obtain a greater improvement (0.5% to 0.6%) over their
ERM analogues than the gain of smaller models such as ResNet-50 (0.2%). When trained for 200
epochs, the top-1 error of the mixup variant of ResNet-50 is further reduced by 1.2% compared to the
90 epoch run, whereas its ERM analogue stays the same.

3.2 CIFAR-10 AND CIFAR-100

We conduct additional image classiﬁcation experiments on the CIFAR-10 and CIFAR-100 datasets
to further evaluate the generalization performance of mixup. In particular, we compare ERM and
mixup training for: PreAct ResNet-18 (He et al., 2016) as implemented in (Liu, 2017), WideResNet-
28-10 (Zagoruyko & Komodakis, 2016a) as implemented in (Zagoruyko & Komodakis, 2016b), and
DenseNet (Huang et al., 2017) as implemented in (Veit, 2017). For DenseNet, we change the growth
rate to 40 to follow the DenseNet-BC-190 speciﬁcation from (Huang et al., 2017). For mixup, we
ﬁx α = 1, which results in interpolations λ uniformly distributed between zero and one. All models
are trained on a single Nvidia Tesla P100 GPU using PyTorch2 for 200 epochs on the training set
with 128 examples per minibatch, and evaluated on the test set. Learning rates start at 0.1 and are
divided by 10 after 100 and 150 epochs for all models except WideResNet. For WideResNet, we
follow (Zagoruyko & Komodakis, 2016a) and divide the learning rate by 10 after 60, 120 and 180
epochs. Weight decay is set to 10−4. We do not use dropout in these experiments.

We summarize our results in Figure 3a. In both CIFAR-10 and CIFAR-100 classiﬁcation problems,
the models trained using mixup signiﬁcantly outperform their analogues trained with ERM. As seen
in Figure 3b, mixup and ERM converge at a similar speed to their best test errors. Note that the
DenseNet models in (Huang et al., 2017) were trained for 300 epochs with further learning rate
decays scheduled at the 150 and 225 epochs, which may explain the discrepancy the performance of
DenseNet reported in Figure 3a and the original result of Huang et al. (2017).

3.3 SPEECH DATA

Next, we perform speech recognition experiments using the Google commands dataset (Warden,
2017). The dataset contains 65,000 utterances, where each utterance is about one-second long and
belongs to one out of 30 classes. The classes correspond to voice commands such as yes, no, down,
left, as pronounced by a few thousand different speakers. To preprocess the utterances, we ﬁrst

1https://caffe2.ai
2http://pytorch.org

5

Published as a conference paper at ICLR 2018

Model

Method

Validation set Test set

LeNet

VGG-11

ERM
mixup (α = 0.1)
mixup (α = 0.2)

ERM
mixup (α = 0.1)
mixup (α = 0.2)

9.8
10.1
10.2

5.0
4.0
3.9

10.3
10.8
11.3

4.6
3.8
3.4

Figure 4: Classiﬁcation errors of ERM and mixup on the Google commands dataset.

extract normalized spectrograms from the original waveforms at a sampling rate of 16 kHz. Next, we
101. For speech data, it is reasonable to
zero-pad the spectrograms to equalize their sizes at 160
apply mixup both at the waveform and spectrogram levels. Here, we apply mixup at the spectrogram
level just before feeding the data to the network.

×

For this experiment, we compare a LeNet (Lecun et al., 2001) and a VGG-11 (Simonyan & Zisserman,
2015) architecture, each of them composed by two convolutional and two fully-connected layers.
We train each model for 30 epochs with minibatches of 100 examples, using Adam as the optimizer
10−3 and is divided by 10
(Kingma & Ba, 2015). Training starts with a learning rate equal to 3
every 10 epochs. For mixup, we use a warm-up period of ﬁve epochs where we train the network on
original training examples, since we ﬁnd it speeds up initial convergence. Table 4 shows that mixup
outperforms ERM on this task, specially when using VGG-11, the model with larger capacity.

×

3.4 MEMORIZATION OF CORRUPTED LABELS

Following Zhang et al. (2017), we evaluate the robustness of ERM and mixup models against randomly
corrupted labels. We hypothesize that increasing the strength of mixup interpolation α should generate
virtual examples further from the training examples, making memorization more difﬁcult to achieve.
In particular, it should be easier to learn interpolations between real examples compared to memorizing
interpolations involving random labels. We adapt an open-source implementation (Zhang, 2017)
to generate three CIFAR-10 training sets, where 20%, 50%, or 80% of the labels are replaced by
random noise, respectively. All the test labels are kept intact for evaluation. Dropout (Srivastava
et al., 2014) is considered the state-of-the-art method for learning with corrupted labels (Arpit et al.,
2017). Thus, we compare in these experiments mixup, dropout, mixup + dropout, and ERM. For
mixup, we choose α
; for dropout, we add one dropout layer in each PreAct block after
∈ {
the ReLU activation layer between two convolution layers, as suggested in (Zagoruyko & Komodakis,
2016a). We choose the dropout probability p
. For the combination of mixup
∈ {
}
and dropout, we choose α
and p
. These experiments use the PreAct
}
∈ {
ResNet-18 (He et al., 2016) model implemented in (Liu, 2017). All the other settings are the same as
in Section 3.2.

0.5, 0.7, 0.8, 0.9
0.3, 0.5, 0.7

1, 2, 8, 32
}

1, 2, 4, 8
}

∈ {

We summarize our results in Table 2, where we note the best test error achieved during the training
session, as well as the ﬁnal test error after 200 epochs. To quantify the amount of memorization, we
also evaluate the training errors at the last epoch on real labels and corrupted labels. As the training
progresses with a smaller learning rate (e.g. less than 0.01), the ERM model starts to overﬁt the
corrupted labels. When using a large probability (e.g. 0.7 or 0.8), dropout can effectively reduce
overﬁtting. mixup with a large α (e.g. 8 or 32) outperforms dropout on both the best and last epoch
test errors, and achieves lower training error on real labels while remaining resistant to noisy labels.
Interestingly, mixup + dropout performs the best of all, showing that the two methods are compatible.

3.5 ROBUSTNESS TO ADVERSARIAL EXAMPLES

One undesirable consequence of models trained using ERM is their fragility to adversarial exam-
ples (Szegedy et al., 2014). Adversarial examples are obtained by adding tiny (visually imperceptible)
perturbations to legitimate examples in order to deteriorate the performance of the model. The adver-
sarial noise is generated by ascending the gradient of the loss surface with respect to the legitimate
example. Improving the robustness to adversarial examples is a topic of active research.

6

Published as a conference paper at ICLR 2018

Label corruption Method

Test error

Training error

Real Corrupted

ERM
ERM + dropout (p = 0.7)
mixup (α = 8)
mixup + dropout (α = 4, p = 0.1)

ERM
ERM + dropout (p = 0.8)
mixup (α = 32)
mixup + dropout (α = 8, p = 0.3)

ERM
ERM + dropout (p = 0.8)
mixup (α = 32)
mixup + dropout (α = 8, p = 0.3)

Best

12.7
8.8
5.9
6.2

18.8
14.1
11.3
10.9

36.5
30.9
25.3
24.0

Last

16.6
10.4
6.4
6.2

44.6
15.5
12.7
10.9

73.9
35.1
30.9
24.8

0.05
5.26
2.27
1.92

0.26
12.71
5.84
7.56

0.62
29.84
18.92
19.70

0.28
83.55
86.32
85.02

0.64
86.98
85.71
87.90

0.83
86.37
85.44
87.67

20%

50%

80%

Table 2: Results on the corrupted label experiments for the best models.

Metric Method

FGSM I-FGSM

Metric Method

FGSM I-FGSM

Top-1

Top-5

ERM
mixup

ERM
mixup

90.7
75.2

63.1
49.1

99.9
99.6

93.4
95.8

Top-1

Top-5

ERM
mixup

ERM
mixup

57.0
46.0

24.8
17.4

57.3
40.9

18.1
11.8

(a) White box attacks.

(b) Black box attacks.

Table 3: Classiﬁcation errors of ERM and mixup models when tested on adversarial examples.

Among the several methods aiming to solve this problem, some have proposed to penalize the norm of
the Jacobian of the model to control its Lipschitz constant (Drucker & Le Cun, 1992; Cisse et al., 2017;
Bartlett et al., 2017; Hein & Andriushchenko, 2017). Other approaches perform data augmentation
by producing and training on adversarial examples (Goodfellow et al., 2015). Unfortunately, all
of these methods add signiﬁcant computational overhead to ERM. Here, we show that mixup can
signiﬁcantly improve the robustness of neural networks without hindering the speed of ERM by
penalizing the norm of the gradient of the loss w.r.t a given input along the most plausible directions
(e.g. the directions to other training points). Indeed, Figure 2 shows that mixup results in models
having a smaller loss and gradient norm between examples compared to vanilla ERM.

To assess the robustness of mixup models to adversarial examples, we use three ResNet-101 models:
two of them trained using ERM on ImageNet-2012, and the third trained using mixup. In the ﬁrst
set of experiments, we study the robustness of one ERM model and the mixup model against white
box attacks. That is, for each of the two models, we use the model itself to generate adversarial
examples, either using the Fast Gradient Sign Method (FGSM) or the Iterative FGSM (I-FGSM)
methods (Goodfellow et al., 2015), allowing a maximum perturbation of (cid:15) = 4 for every pixel. For
I-FGSM, we use 10 iterations with equal step size. In the second set of experiments, we evaluate
robustness against black box attacks. That is, we use the ﬁrst ERM model to produce adversarial
examples using FGSM and I-FGSM. Then, we test the robustness of the second ERM model and the
mixup model to these examples. The results of both settings are summarized in Table 3.

For the FGSM white box attack, the mixup model is 2.7 times more robust than the ERM model in
terms of Top-1 error. For the FGSM black box attack, the mixup model is 1.25 times more robust
than the ERM model in terms of Top-1 error. Also, while both mixup and ERM are not robust to
white box I-FGSM attacks, mixup is about 40% more robust than ERM in the black box I-FGSM
setting. Overall, mixup produces neural networks that are signiﬁcantly more robust than ERM against
adversarial examples in white box and black settings without additional overhead compared to ERM.

7

Published as a conference paper at ICLR 2018

Dataset

ERM mixup

Dataset

ERM mixup

Abalone
Arcene
Arrhythmia

74.0
57.6
56.6

73.6
48.0
46.3

Htru2
Iris
Phishing

2.0
21.3
16.3

2.0
17.3
15.2

Table 4: ERM and mixup classiﬁcation errors on the UCI datasets.

ERM GAN

mixup GAN (α = 0.2)

Figure 5: Effect of mixup on stabilizing GAN training at iterations 10, 100, 1000, 10000, and 20000.

3.6 TABULAR DATA

To further explore the performance of mixup on non-image data, we performed a series of experiments
on six arbitrary classiﬁcation problems drawn from the UCI dataset (Lichman, 2013). The neural
networks in this section are fully-connected, and have two hidden layers of 128 ReLU units. The
parameters of these neural networks are learned using Adam (Kingma & Ba, 2015) with default
hyper-parameters, over 10 epochs of mini-batches of size 16. Table 4 shows that mixup improves the
average test error on four out of the six considered datasets, and never underperforms ERM.

3.7 STABILIZATION OF GENERATIVE ADVERSARIAL NETWORKS (GANS)

Generative Adversarial Networks, also known as GANs (Goodfellow et al., 2014), are a powerful
family of implicit generative models. In GANs, a generator and a discriminator compete against
each other to model a distribution P . On the one hand, the generator g competes to transform noise
vectors z
P . On the other hand, the
discriminator competes to distinguish between real samples x and fake samples g(z). Mathematically,
training a GAN is equivalent to solving the optimization problem

Q into fake samples g(z) that resemble real samples x

∼

∼

max
g

min
d

E
x,z

(cid:96)(d(x), 1) + (cid:96)(d(g(z)), 0),

where (cid:96) is the binary cross entropy loss. Unfortunately, solving the previous min-max equation is a
notoriously difﬁcult optimization problem (Goodfellow, 2016), since the discriminator often provides
the generator with vanishing gradients. We argue that mixup should stabilize GAN training because it
acts as a regularizer on the gradients of the discriminator, akin to the binary classiﬁer in Figure 1b.
Then, the smoothness of the discriminator guarantees a stable source of gradient information to the
generator. The mixup formulation of GANs is:

max
g

min
d

E
x,z,λ

(cid:96)(d(λx + (1

λ)g(z)), λ).

−

Figure 5 illustrates the stabilizing effect of mixup the training of GAN (orange samples) when
modeling two toy datasets (blue samples). The neural networks in these experiments are fully-
connected and have three hidden layers of 512 ReLU units. The generator network accepts two-
dimensional Gaussian noise vectors. The networks are trained for 20,000 mini-batches of size
128 using the Adam optimizer with default parameters, where the discriminator is trained for ﬁve
iterations before every generator iteration. The training of mixup GANs seems promisingly robust to
hyper-parameter and architectural choices.

8

Published as a conference paper at ICLR 2018

Method

Speciﬁcation

ERM

mixup

mix labels and latent
representations
(AC + RP)

mix inputs only

AC + RP
AC + KNN

Layer 1
Layer 2
Layer 3
Layer 4
Layer 5

label smoothing
(Szegedy et al., 2016)

mix inputs +
label smoothing
(AC + RP)

add Gaussian noise
to inputs

(cid:15) = 0.05
(cid:15) = 0.1
(cid:15) = 0.2

(cid:15) = 0.05
(cid:15) = 0.1
(cid:15) = 0.2
(cid:15) = 0.4

σ = 0.05
σ = 0.1
σ = 0.2

SC + KNN (Chawla et al., 2002)
AC + KNN
SC + RP
AC + RP

Modiﬁed

Weight decay

Input Target
(cid:55)

(cid:55)

10−4

5

×

(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:51)
(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:51)
(cid:51)

(cid:55)
(cid:55)
(cid:55)

(cid:51)
(cid:51)
(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:51)

5.53
(cid:51) 4.24
(cid:51) 4.98
(cid:51) 4.44
(cid:51) 4.56
(cid:51) 5.39
(cid:51) 5.95
(cid:51) 5.39
(cid:55)
(cid:55)
(cid:55)
(cid:55)

5.45
5.43
5.23
5.17
(cid:51) 5.25
(cid:51) 5.33
(cid:51) 5.34
(cid:51) 5.02
(cid:51) 5.08
(cid:51) 4.98
(cid:51) 5.25
(cid:55)
(cid:55)
(cid:55)

5.53
6.41
7.16

10−4

5.18

4.68
5.26

4.51
4.61
5.55
5.43
5.15

5.52
5.48
5.55
5.72

5.02
5.17
5.06

5.40
5.09
5.06
5.39

5.04
5.86
7.24

Table 5: Results of the ablation studies on the CIFAR-10 dataset. Reported are the median test errors
of the last 10 epochs. A tick ((cid:51)) means the component is different from standard ERM training,
whereas a cross ((cid:55)) means it follows the standard training practice. AC: mix between all classes. SC:
mix within the same class. RP: mix between random pairs. KNN: mix between k-nearest neighbors
(k=200). Please refer to the text for details about the experiments and interpretations.

3.8 ABLATION STUDIES

mixup is a data augmentation method that consists of only two parts: random convex combination of
raw inputs, and correspondingly, convex combination of one-hot label encodings. However, there are
several design choices to make. For example, on how to augment the inputs, we could have chosen
to interpolate the latent representations (i.e. feature maps) of a neural network, and we could have
chosen to interpolate only between the nearest neighbors, or only between inputs of the same class.
When the inputs to interpolate come from two different classes, we could have chosen to assign a
single label to the synthetic input, for example using the label of the input that weights more in the
convex combination. To compare mixup with these alternative possibilities, we run a set of ablation
study experiments using the PreAct ResNet-18 architecture on the CIFAR-10 dataset.
Speciﬁcally, for each of the data augmentation methods, we test two weight decay settings (10−4
10−4 which works well for ERM). All the other settings and
which works well for mixup, and 5
hyperparameters are the same as reported in Section 3.2.

×

To compare interpolating raw inputs with interpolating latent representations, we test on random
convex combination of the learned representations before each residual block (denoted Layer 1-4)
or before the uppermost “average pooling + fully connected” layer (denoted Layer 5). To compare
mixing random pairs of inputs (RP) with mixing nearest neighbors (KNN), we ﬁrst compute the 200
nearest neighbors for each training sample, either from the same class (SC) or from all the classes
(AC). Then during training, for each sample in a minibatch, we replace the sample with a synthetic
sample by convex combination with a random draw from its nearest neighbors. To compare mixing
all the classes (AC) with mixing within the same class (SC), we convex combine a minibatch with a

9

Published as a conference paper at ICLR 2018

random permutation of its sample index, where the permutation is done in a per-batch basis (AC) or a
per-class basis (SC). To compare mixing inputs and labels with mixing inputs only, we either use a
convex combination of the two one-hot encodings as the target, or select the one-hot encoding of the
closer training sample as the target. For label smoothing, we follow Szegedy et al. (2016) and use
(cid:15)
9(cid:15)
10 as the target for incorrect classes, and 1
10 as the target for the correct class.Adding Gaussian
noise to inputs is used as another baseline. We report the median test errors of the last 10 epochs.
Results are shown in Table 5.

−

From the ablation study experiments, we have the following observations. First, mixup is the best
data augmentation method we test, and is signiﬁcantly better than the second best method (mix input
+ label smoothing). Second, the effect of regularization can be seen by comparing the test error with a
small weight decay (10−4) with a large one (5
10−4). For example, for ERM a large weight decay
works better, whereas for mixup a small weight decay is preferred, conﬁrming its regularization effects.
We also see an increasing advantage of large weight decay when interpolating in higher layers of latent
representations, indicating decreasing strength of regularization. Among all the input interpolation
methods, mixing random pairs from all classes (AC + RP) has the strongest regularization effect.
Label smoothing and adding Gaussian noise have a relatively small regularization effect. Finally,
we note that the SMOTE algorithm (Chawla et al., 2002) does not lead to a noticeable gain in
performance.

×

4 RELATED WORK

Data augmentation lies at the heart of all successful applications of deep learning, ranging from image
classiﬁcation (Krizhevsky et al., 2012) to speech recognition (Graves et al., 2013; Amodei et al.,
2016). In all cases, substantial domain knowledge is leveraged to design suitable data transformations
leading to improved generalization. In image classiﬁcation, for example, one routinely uses rotation,
translation, cropping, resizing, ﬂipping (Lecun et al., 2001; Simonyan & Zisserman, 2015), and
random erasing (Zhong et al., 2017) to enforce visually plausible invariances in the model through
the training data. Similarly, in speech recognition, noise injection is a prevalent practice to improve
the robustness and accuracy of the trained models (Amodei et al., 2016).

More related to mixup, Chawla et al. (2002) propose to augment the rare class in an imbalanced
dataset by interpolating the nearest neighbors; DeVries & Taylor (2017) show that interpolation and
extrapolation the nearest neighbors of the same class in feature space can improve generalization.
However, their proposals only operate among the nearest neighbors within a certain class at the
input / feature level, and hence does not account for changes in the corresponding labels. Recent
approaches have also proposed to regularize the output distribution of a neural network by label
smoothing (Szegedy et al., 2016), or penalizing high-conﬁdence softmax distributions (Pereyra et al.,
2017). These methods bear similarities with mixup in the sense that supervision depends on multiple
smooth labels, rather than on single hard labels as in traditional ERM. However, the label smoothing
in these works is applied or regularized independently from the associated feature values.

mixup enjoys several desirable aspects of previous data augmentation and regularization schemes
without suffering from their drawbacks. Like the method of DeVries & Taylor (2017), it does not
require signiﬁcant domain knowledge. Like label smoothing, the supervision of every example is not
overly dominated by the ground-truth label. Unlike both of these approaches, the mixup transformation
establishes a linear relationship between data augmentation and the supervision signal. We believe
that this leads to a strong regularizer that improves generalization as demonstrated by our experiments.
The linearity constraint, through its effect on the derivatives of the function approximated, also relates
mixup to other methods such as Sobolev training of neural networks (Czarnecki et al., 2017) or
WGAN-GP (Gulrajani et al., 2017).

5 DISCUSSION

We have proposed mixup, a data-agnostic and straightforward data augmentation principle. We
have shown that mixup is a form of vicinal risk minimization, which trains on virtual examples
constructed as the linear interpolation of two random examples from the training set and their labels.
Incorporating mixup into existing training pipelines reduces to a few lines of code, and introduces
little or no computational overhead. Throughout an extensive evaluation, we have shown that mixup

10

Published as a conference paper at ICLR 2018

improves the generalization error of state-of-the-art models on ImageNet, CIFAR, speech, and
tabular datasets. Furthermore, mixup helps to combat memorization of corrupt labels, sensitivity to
adversarial examples, and instability in adversarial training.

In our experiments, the following trend is consistent: with increasingly large α, the training error on
real data increases, while the generalization gap decreases. This sustains our hypothesis that mixup
implicitly controls model complexity. However, we do not yet have a good theory for understanding
the ‘sweet spot’ of this bias-variance trade-off. For example, in CIFAR-10 classiﬁcation we can
get very low training error on real data even when α
(i.e., training only on averages of pairs
of real examples), whereas in ImageNet classiﬁcation, the training error on real data increases
signiﬁcantly with α
. Based on our ImageNet and Google commands experiments with different
model architectures, we conjecture that increasing the model capacity would make training error less
sensitive to large α, hence giving mixup a more signiﬁcant advantage.

→ ∞

→ ∞

mixup also opens up several possibilities for further exploration. First, is it possible to make
similar ideas work on other types of supervised learning problems, such as regression and structured
prediction? While generalizing mixup to regression problems is straightforward, its application
to structured prediction problems such as image segmentation remains less obvious. Second, can
similar methods prove helpful beyond supervised learning? The interpolation principle seems like a
reasonable inductive bias which might also help in unsupervised, semi-supervised, and reinforcement
learning. Can we extend mixup to feature-label extrapolation to guarantee a robust model behavior
far away from the training data? Although our discussion of these directions is still speculative, we
are excited about the possibilities mixup opens up, and hope that our observations will prove useful
for future development.

We would like to thank Priya Goyal, Yossi Adi and the PyTorch team. We also thank the Anonymous
Review 2 for proposing the mixup + dropout experiments.

ACKNOWLEDGEMENTS

REFERENCES

D. Amodei, S. Ananthanarayanan, R. Anubhai, J. Bai, E. Battenberg, C. Case, J. Casper, B. Catanzaro, Q. Cheng,
G. Chen, et al. Deep speech 2: End-to-end speech recognition in English and Mandarin. In ICML, 2016.

D. Arpit, S. Jastrzebski, N. Ballas, D. Krueger, E. Bengio, M. S. Kanwal, T. Maharaj, A. Fischer, A. Courville,

Y. Bengio, et al. A closer look at memorization in deep networks. ICML, 2017.

P. Bartlett, D. J. Foster, and M. Telgarsky. Spectrally-normalized margin bounds for neural networks. NIPS,

2017.

O. Chapelle, J. Weston, L. Bottou, and V. Vapnik. Vicinal risk minimization. NIPS, 2000.

N. V. Chawla, K. W. Bowyer, L. O. Hall, and W. P. Kegelmeyer. SMOTE: synthetic minority over-sampling

technique. Journal of artiﬁcial intelligence research, 16:321–357, 2002.

C. Chelba, T. Mikolov, M. Schuster, Q. Ge, T. Brants, P. Koehn, and T. Robinson. One billion word benchmark

for measuring progress in statistical language modeling. arXiv, 2013.

M. Cisse, P. Bojanowski, E. Grave, Y. Dauphin, and N. Usunier. Parseval networks: Improving robustness to

adversarial examples. ICML, 2017.

W. M. Czarnecki, S. Osindero, M. Jaderberg, G. ´Swirszcz, and R. Pascanu. Sobolev training for neural networks.

NIPS, 2017.

T. DeVries and G. W. Taylor. Dataset augmentation in feature space. ICLR Workshops, 2017.

H. Drucker and Y. Le Cun.

Improving generalization performance using double backpropagation.

IEEE

Transactions on Neural Networks, 3(6):991–997, 1992.

I. Goodfellow. Tutorial: Generative adversarial networks. NIPS, 2016.

I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio.

Generative adversarial nets. NIPS, 2014.

11

Published as a conference paper at ICLR 2018

IEEE, 2013.

NIPS, 2017.

JMLR, 2017.

2017.

NIPS, 2012.

I. J. Goodfellow, J. Shlens, and C. Szegedy. Explaining and harnessing adversarial examples. ICLR, 2015.

P. Goyal, P. Doll´ar, R. Girshick, P. Noordhuis, L. Wesolowski, A. Kyrola, A. Tulloch, Y. Jia, and K. He. Accurate,

large minibatch SGD: Training ImageNet in 1 hour. arXiv, 2017.

A. Graves, A.-r. Mohamed, and G. Hinton. Speech recognition with deep recurrent neural networks. In ICASSP.

I. Gulrajani, F. Ahmed, M. Arjovsky, V. Dumoulin, and A. Courville. Improved training of Wasserstein GANs.

N. Harvey, C. Liaw, and A. Mehrabian. Nearly-tight VC-dimension bounds for piecewise linear neural networks.

K. He, X. Zhang, S. Ren, and J. Sun. Identity mappings in deep residual networks. ECCV, 2016.

M. Hein and M. Andriushchenko. Formal guarantees on the robustness of a classiﬁer against adversarial

manipulation. NIPS, 2017.

G. Hinton, L. Deng, D. Yu, G. E. Dahl, A.-r. Mohamed, N. Jaitly, A. Senior, V. Vanhoucke, P. Nguyen, T. N.
Sainath, et al. Deep neural networks for acoustic modeling in speech recognition: The shared views of four
research groups. IEEE Signal Processing Magazine, 2012.

G. Huang, Z. Liu, L. van der Maaten, and K. Q. Weinberger. Densely connected convolutional networks. CVPR,

D. Kingma and J. Ba. Adam: A method for stochastic optimization. ICLR, 2015.

A. Krizhevsky, I. Sutskever, and G. E. Hinton. ImageNet classiﬁcation with deep convolutional neural networks.

Y. Lecun, L. Bottou, Y. Bengio, and P. Haffner. Gradient-based learning applied to document recognition.

Proceedings of IEEE, 2001.

M. Lichman. UCI machine learning repository, 2013.

K. Liu, 2017. URL https://github.com/kuangliu/pytorch-cifar.

G. Pereyra, G. Tucker, J. Chorowski, Ł. Kaiser, and G. Hinton. Regularizing neural networks by penalizing

conﬁdent output distributions. ICLR Workshops, 2017.

O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein,

A. C. Berg, and L. Fei-Fei. ImageNet large scale visual recognition challenge. IJCV, 2015.

D. Silver, A. Huang, C. J. Maddison, A. Guez, L. Sifre, G. Van Den Driessche, J. Schrittwieser, I. Antonoglou,
V. Panneershelvam, M. Lanctot, et al. Mastering the game of Go with deep neural networks and tree search.
Nature, 2016.

P. Simard, Y. LeCun, J. Denker, and B. Victorri. Transformation invariance in pattern recognitiontangent distance

and tangent propagation. Neural networks: tricks of the trade, 1998.

K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale image recognition. ICLR,

2015.

net. ICLR Workshops, 2015.

J. T. Springenberg, A. Dosovitskiy, T. Brox, and M. Riedmiller. Striving for simplicity: The all convolutional

N. Srivastava, G. E. Hinton, A. Krizhevsky, I. Sutskever, and R. Salakhutdinov. Dropout: a simple way to
prevent neural networks from overﬁtting. Journal of Machine Learning Research, 15(1):1929–1958, 2014.

C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Erhan, I. J. Goodfellow, and R. Fergus. Intriguing properties

of neural networks. ICLR, 2014.

C. Szegedy, V. Vanhoucke, S. Ioffe, J. Shlens, and Z. Wojna. Rethinking the Inception architecture for computer

vision. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2016.

V. N. Vapnik. Statistical learning theory. J. Wiley, 1998.

V. Vapnik and A. Y. Chervonenkis. On the uniform convergence of relative frequencies of events to their

probabilities. Theory of Probability and its Applications, 1971.

12

Published as a conference paper at ICLR 2018

A. Veit, 2017. URL https://github.com/andreasveit.

P. Warden,

2017.

URL

https://research.googleblog.com/2017/08/

launching-speech-commands-dataset.html.

S. Xie, R. Girshick, P. Doll´ar, Z. Tu, and K. He. Aggregated residual transformations for deep neural networks.

CVPR, 2016.

S. Zagoruyko and N. Komodakis. Wide residual networks. BMVC, 2016a.

S. Zagoruyko and N. Komodakis,
wide-residual-networks.

2016b.

URL https://github.com/szagoruyko/

C. Zhang, S. Bengio, M. Hardt, B. Recht, and O. Vinyals. Understanding deep learning requires rethinking

generalization. ICLR, 2017.

C. Zhang, 2017. URL https://github.com/pluskid/fitting-random-labels.

Z. Zhong, L. Zheng, G. Kang, S. Li, and Y. Yang. Random erasing data augmentation. arXiv, 2017.

13

