8
1
0
2
 
y
a
M
 
6
 
 
]

G
L
.
s
c
[
 
 
1
v
2
4
2
2
0
.
5
0
8
1
:
v
i
X
r
a

Reachability Analysis of Deep Neural Networks
with Provable Guarantees*

Wenjie Ruan1, Xiaowei Huang2, Marta Kwiatkowska1
1 Department of Computer Science, University of Oxford, UK
{wenjie.ruan; marta.kwiatkowska}@cs.ox.ac.uk
2 Department of Computer Science, University of Liverpool, UK
xiaowei.huang@liverpool.ac.uk

Abstract

Verifying correctness of deep neural networks (DNNs) is challenging. We
study a generic reachability problem for feed-forward DNNs which, for a given
set of inputs to the network and a Lipschitz-continuous function over its outputs,
computes the lower and upper bound on the function values. Because the network
and the function are Lipschitz continuous, all values in the interval between the
lower and upper bound are reachable. We show how to obtain the safety veriﬁ-
cation problem, the output range analysis problem and a robustness measure by
instantiating the reachability problem. We present a novel algorithm based on
adaptive nested optimisation to solve the reachability problem. The technique has
been implemented and evaluated on a range of DNNs, demonstrating its efﬁciency,
scalability and ability to handle a broader class of networks than state-of-the-art
veriﬁcation approaches.

1

Introduction

Concerns have been raised about the suitability of deep neural networks (DNNs), or
systems with DNN components, for deployment in safety-critical applications, see e.g.,
[2, 3]. To ease this concern and gain users’ trust, DNNs need to be certiﬁed similarly to
systems such as airplanes and automobiles. In this paper, we propose to study a generic
reachability problem which, for a given DNN, an input subspace and a function over
the outputs of the network, computes the upper and lower bounds over the values of
the function. The function is generic, with the only requirement that it is Lipschitz
continuous. We argue that this problem is fundamental for certiﬁcation of DNNs, as
it can be instantiated into several key correctness problems, including adversarial ex-
ample generation [4, 5], safety veriﬁcation [6, 7, 8], output range analysis [9, 10], and
robustness comparison.

*This is the long version of the conference paper accepted in IJCAI-2018, see [1].

1

To certify a system, a certiﬁcation approach needs to provide not only a result but
also a guarantee over the result, such as the error bounds. Existing approaches for
analysing DNNs with a guarantee work by either reducing the problem to a constraint
satisfaction problem that can be solved by MILP [9, 11, 12, 13], SAT [14] or SMT
[7, 12] techniques, or applying search algorithms over discretised vector spaces [6,
15]. Even though they are able to achieve guarantees, they suffer from two major
weaknesses. Firstly, their subjects of study are restricted. More speciﬁcally, they can
only work with layers conducting linear transformations (such as convolutional and
fully-connected layers) and simple non-linear transformations (such as ReLU), and
cannot work with other important layers, such as the sigmoid, max pooling and softmax
layers that are widely used in state-of-the-art networks. Secondly, the scalability of the
constraint-based approaches is signiﬁcantly limited by both the capability of the solvers
and the size of the network, and they can only work with networks with a few hundreds
of hidden neurons. However, state-of-the-art networks usually have millions, or even
billions, of hidden neurons.

This paper proposes a novel approach to tackle the generic reachability problem,
which does not suffer from the above weaknesses and provides provable guarantees in
terms of the upper and lower bounds over the errors. The approach is inspired by re-
cent advances made in the area of global optimisation [16, 17]. For the input subspace
deﬁned over a set of input dimensions, an adaptive nested optimisation algorithm is de-
veloped. The performance of our algorithm is not dependent on the size of the network
and it can therefore scale to work with large networks.

Our algorithm assumes certain knowledge about the DNN. However, instead of di-
rectly translating the activation functions and their parameters (i.e., weights and bias)
into linear constraints, it needs a Lipschitz constant of the network. For this, we show
that several layers that cannot be directly translated into linear constraints are actu-
ally Lipschitz continuous, and we are able to compute a tight Lipschitz constant by
analysing the activation functions and their parameters.

We develop a software tool DeepGO1 and evaluate its performance by comparing
with existing constraint-based approaches, namely, SHERLOCK [10] and Reluplex
[7]. We also demonstrate our tool on DNNs that are beyond the capability of existing
tools.

2 Related Works

We discuss several threads of work concerning problems that can be obtained by in-
stantiating our generic reachability problem. Their instantiations are explained in the
paper. Due to space limitations, this review is by no means complete.

Safety Veriﬁcation There are two ways of achieving safety veriﬁcation for DNNs. The
ﬁrst is to reduce the problem into a constraint solving problem. Notable works include,
e.g., [18, 7]. However, they can only work with small networks with hundreds of hidden
neurons. The second is to discretise the vector spaces of the input or hidden layers
and then apply exhaustive search algorithms or Monte Carlo tree search algorithm on

1Available on https://github.com/trustAI/DeepGO.

2

the discretised spaces. The guarantees are achieved by establishing local assumptions
such as minimality of manipulations in [6] and minimum conﬁdence gap for Lipschitz
networks in [15].

Adversarial Example Generation Most existing works, e.g., [4, 5, 19, 20, 21], apply
various heuristic algorithms, generally using search algorithms based on gradient de-
scent or evolutionary techniques. [22] construct a saliency map of the importance of
the pixels based on gradient descent and then modify the pixels. In contrast with our
approach based on global optimisation and works on safety veriﬁcation, these methods
may be able to ﬁnd adversarial examples efﬁciently, but are not able to conclude the
nonexistence of adversarial examples when the algorithm fails to ﬁnd one.

Output Range Analysis The safety veriﬁcation approach can be adapted to work on
this problem. Moreover, [9] consider determining whether an output value of a DNN
is reachable from a given input subspace, and propose an MILP solution. [10] study
the range of output values from a given input subspace. Their method interleaves local
search (based on gradient descent) with global search (based on reduction to MILP).
Both approaches can only work with small networks.

3 Lipschitz Continuity of DNNs

This section shows that feed-forward DNNs are Lipschitz continuous. Let f : Rn →
Rm be a N -layer network such that, for a given input x ∈ Rn, f (x) = {c1, c2, ..., cm} ∈
Rm represents the conﬁdence values for m classiﬁcation labels. Speciﬁcally, we have
f (x) = fN (fN −1(...f1(x; W1, b1); W2, b2); ...); WN , bN ) where Wi and bi for i =
1, 2, ..., N are learnable parameters and fi(zi−1; Wi−1, bi−1) is the function mapping
from the output of layer i − 1 to the output of layer i such that zi−1 is the output of
layer i − 1. Without loss of generality, we normalise the input to lie x ∈ [0, 1]n. The
output f (x) is usually normalised to be in [0, 1]m with a softmax layer.

Deﬁnition 1 (Lipschitz Continuity) Given two metric spaces (X, dX ) and (Y, dY ),
where dX and dY are the metrics on the sets X and Y respectively, a function f :
X → Y is called Lipschitz continuous if there exists a real constant K ≥ 0 such that,
for all x1, x2 ∈ X:

dY (f (x1), f (x2)) ≤ KdX (x1, x2).

(1)

K is called the Lipschitz constant for the function f . The smallest K is called the Best
Lipschitz constant, denoted as Kbest.

In [4], the authors show that deep neural networks with half-rectiﬁed layers (i.e., con-
volutional or fully connected layers with ReLU activation functions), max pooling
and contrast-normalization layers are Lipschitz continuous. They prove that the up-
per bound of the Lipschitz constant can be estimated via the operator norm of learned
parameters W .

Next, we show that the softmax layer, sigmoid and Hyperbolic tangent activation

functions also satisfy Lipschitz continuity. First we need the following lemma [23].

3

Lemma 1 Let f : Rn → Rm, if ||∂f (x)/∂x|| ≤ K for all x ∈ [a, b]n, then f is
Lipschitz continuous on [a, b]n and K is its Lipschitz constant, where || ∗ || represents
a norm operator.

Based on this lemma, we have the following theorem.

Theorem 1 Convolutional or fully connected layers with the sigmoid activation func-
tion s(W x + b), Hyperbolic tangent activation function t(W x + b), and softmax func-

tion p(x)j are Lipschitz continuous and their Lipschitz constants are
supi,j((cid:107)xi(cid:107) +(cid:13)

(cid:13)
(cid:13)), respectively.

(cid:13)xixj

1
2

(cid:107)W (cid:107),(cid:107)W (cid:107), and

Proof 1 First of all, we show that the norm operators of their Jacobian matrices are
bounded.

(1) Layer with sigmoid activation s(q) = 1/(1 + e−q) with q = W x + b:

(2) Layer with Hyperbolic tangent activation function t(q) = 2/(1 + e−2q) − 1

with q = W x + b:

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂s(x)
∂x

=

(cid:13)
(cid:13)
(cid:13)
(cid:13)

(cid:13)
∂s(q)
(cid:13)
(cid:13)
∂q
(cid:13)
(cid:13)s(q) ◦ (1 − s(q))(cid:13)
≤ (cid:13)

∂q
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)

≤

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂s(q)
∂q

∂q
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)

(cid:13)(cid:107)W (cid:107) ≤

(cid:107)W (cid:107)

(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
1
2

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂t(x)
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)
≤ (cid:13)

∂t(q)
∂q

(cid:13)
(cid:13)
(cid:13)
(cid:13)
∂q
(cid:13)
(cid:13)
(cid:13)
(cid:13)
=
(cid:13)
(cid:13)
(cid:13)
(cid:13)
∂x
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)1 − t(q) ◦ t(q))(cid:13)
(cid:13)(cid:107)W (cid:107) ≤ (cid:107)W (cid:107)

∂t(q)
∂q

∂q
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)

(cid:13)
(cid:13)
(cid:13)
(cid:13)

≤

(3) Layer with softmax function p(x)j = exj /((cid:80)n

k=1 exk ) for j = 1, ..., m and

n = m (dimensions of input and output of softmax are the same):

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂p(x)j
∂xi

(cid:13)
(cid:13)
(cid:13)
(cid:13)

=

(cid:26) xi(1 − xj), i = j
−xixj, i (cid:54)= j

((cid:107)xi(cid:107) +(cid:13)

(cid:13)xixj

(cid:13)
(cid:13))

≤ sup
i,j

Since the softmax layer is the last layer of a deep neural network, we can estimate
its supremum based on Lipschitz constants of previous layers and box constraints of
DNN’s input.

The ﬁnal conclusion follows by Lemma 1 and the fact that all the layer functions

are bounded on their Jacobian matrix.

4 Problem Formulation

Let o : [0, 1]m → R be a Lipschitz continuous function statistically evaluating the out-
puts of the network. Our problem is to ﬁnd its upper and lower bounds given the set X (cid:48)
of inputs to the network. Because both the network f and the function o are Lipschitz
continuous, all values between the upper and lower bounds have a corresponding input,
i.e., are reachable.

4

(2)

(3)

(4)

Deﬁnition 2 (Reachability of Neural Network) Let X (cid:48) ⊆ [0, 1]n be an input sub-
space and f : Rn → Rm a network. The reachability of f over the function o under
an error tolerance (cid:15) ≥ 0 is a set R(o, X (cid:48), (cid:15)) = [l, u] such that

(5)

(6)

l ≥ inf

x(cid:48)∈X (cid:48)

o(f (x(cid:48))) − (cid:15) and u ≤ sup
x(cid:48)∈X (cid:48)

o(f (x(cid:48))) + (cid:15).

We write u(o, X (cid:48), (cid:15)) = u and l(o, X (cid:48), (cid:15)) = l for the upper and lower bound, respec-
tively. Then the reachability diameter is

D(o, X (cid:48), (cid:15)) = u(o, X (cid:48), (cid:15)) − l(o, X (cid:48), (cid:15)).

Assuming these notations, we may write D(o, X (cid:48), (cid:15); f ) if we need to explicitly refer to
the network f .

In the following, we instantiate o with a few concrete functions, and show that
several key veriﬁcation problems for DNNs can be reduced to our reachability problem.

Deﬁnition 3 (Output Range Analysis) Given a class label j ∈ [1, .., m], we let o =
Πj such that Πj((c1, ..., cm)) = cj.

We write cj(x) = Πj(f (x)) for the network’s conﬁdence in classifying x as label j.
Intuitively, output range [10] quantiﬁes how a certain output of a deep neural network
(i.e., classiﬁcation probability of a certain label j) varies in response to a set of DNN
inputs with an error tolerance (cid:15). Output range analysis can be easily generalised to logit
2 range analysis.

We show that the safety veriﬁcation problem [6] can be reduced to solving the

reachability problem.

Deﬁnition 4 (Safety) A network f is safe with respect to an input x and an input
subspace X (cid:48) ⊆ [0, 1]n with x ∈ X (cid:48), written as S(f, x, X (cid:48)), if

∀x(cid:48) ∈ X (cid:48) : arg max

cj(x(cid:48)) = arg max

cj(x)

j

j

(7)

We have the following reduction theorem.

Theorem 2 A network f is safe with respect to x and X (cid:48) s.t. x ∈ X (cid:48) if and only if
u(⊕, X (cid:48), (cid:15)) ≤ 0, where ⊕(c1, ..., cm) = maxi∈{1..m}(Πi(c1, ..., cm)−Πj(c1, ..., cm))
and j = arg maxj cj(x). The error bound of the safety decision problem by this
reduction is 2(cid:15).

It is not hard to see that the adversarial example generation [4], which is to ﬁnd an
input x(cid:48) ∈ X (cid:48) such that arg maxj cj(x(cid:48)) (cid:54)= arg maxj cj(x), is the dual problem of the
safety problem.

The following two problems deﬁne the robustness comparisons between the net-

works and/or the inputs.

in, e.g., [22, 10].

2Logit output is the output of the layer before the softmax layer. The study of logit outputs is conducted

5

Deﬁnition 5 (Robustness) Given two homogeneous3 networks f and g, we say that f
is strictly more robust than g with respect to a function o, an input subspace X (cid:48) and an
error bound (cid:15), written as Ro,X (cid:48),(cid:15)(f, g), if D(o, X (cid:48), (cid:15); f ) < D(o, X (cid:48), (cid:15); g).

Deﬁnition 6 Given two input subspaces X (cid:48) and X (cid:48)(cid:48) and a network f , we say that f
is more robust on X (cid:48) than on X (cid:48)(cid:48) with respect to a statistical function o and an error
bound (cid:15), written as Rf,o,(cid:15)(X (cid:48), X (cid:48)(cid:48)), if D(o, X (cid:48), (cid:15)) < D(o, X (cid:48)(cid:48), (cid:15)).

Thus, by instantiating the function o, we can quantify the output/logit range of
a network, evaluate whether a network is safe, and compare the robustness of two
homogeneous networks or two input subspaces for a given network.

5 Conﬁdence Reachability with Guarantees

Section 3 shows that a trained deep neural network is Lipschitz continuous regardless
of its layer depth, activation functions and number of neurons. Now, to solve the reach-
ability problem, we need to ﬁnd the global minimum and maximum values given an
input subspace, assuming that we have a Lipschitz constant K for the function o·f . In
the following, we let w = o·f be the concatenated function. Without loss of general-
ity, we assume the input space X (cid:48) is a box-constraint, which is clearly feasible since
images are usually normalized into [0, 1]n before being fed into a neural network.

The computation of the minimum value is reduced to solving the following opti-
mization problem with guaranteed convergence to the global minimum (the maximiza-
tion problem can be transferred into a minimization problem):

min
x

w(x), s.t. x ∈ [a, b]n

(8)

However, the above problem is very difﬁcult since w(x) is a highly non-convex func-
tion which cannot be guaranteed to reach the global minimum by regular optimization
schemes based on gradient descent. Inspired by an idea from optimisation, see e.g.,
[24, 25], we design another continuous function h(x, y), which serves as a lower bound
of the original function w(x). Speciﬁcally, we need

∀x, y ∈ [a, b]n, h(x, y) ≤ w(x) and h(x, x) = w(x)

(9)

Furthermore, for i ≥ 0, we let Yi = {y0, y1, ..., yi} be a ﬁnite set containing i + 1
points from the input space [a, b]n, and let Yi ⊆ Yk when k > i, then we can deﬁne a
function H(x; Yi) = maxy∈Yi h(x, y) which satisﬁes the following relation:

H(x; Yi) < H(x; Yk) ≤ w(x), ∀i < k

We use li = inf x∈[a,b]n H(x; Yi) to denote the minimum value of H(x; Yi) for

x ∈ [a, b]n. Then we have

(10)

(11)

l0 < l1 < ... < li−1 < li ≤ inf

w(x)

x∈[a,b]n

3 Here, two networks are homogeneous if they are applied on the same classiﬁcation task but may have

different network architectures (layer numbers, layer types, etc) and/or parameters.

6

Figure 1: A lower-bound function designed via Lipschitz constant

Similarly, we need a sequence of upper bounds ui to have

l0 < ... < li ≤ inf

w(x) ≤ ui < ... < u0

x∈[a,b]n

By Expression (12), we can have the following:

lim
i→∞

li = min

x∈[a,b]n

w(x) and lim
i→∞

(ui − li) = 0

(12)

(13)

Therefore, we can asymptotically approach the global minimum. Practically, we
execute a ﬁnite number of iterations by using an error tolerance (cid:15) to control the ter-
mination. In next sections, we present our approach, which constructs a sequence of
lower and upper bounds, and show that it can converge with an error bound. To han-
dle the high-dimensionality of DNNs, our approach is inspired by the idea of adaptive
nested optimisation in [16], with signiﬁcant differences in the detailed algorithm and
convergence proof.

5.1 One-dimensional Case

We ﬁrst introduce an algorithm which works over one dimension of the input, and
therefore is able to handle the case of x ∈ [a, b] in Eqn. (8). The multi-dimensional op-
timisation algorithm will be discussed in Section 5.2 by utilising the one-dimensional
algorithm.

We deﬁne the following lower-bound function.

h(x, y) = w(y) − K|x − y|

H(x; Yi) = max
y∈Yi

w(y) − K|x − y|

(14)

where K > Kbest is a Lipschitz constant of w and H(x; Yi) intuitively represents the
lower-bound sawtooth function shown as Figure 1. The set of points Yi is constructed

7

recursively. Assuming that, after (i−1)-th iteration, we have Yi−1 = {y0, y1, .., yi−1},
whose elements are in ascending order, and sets

w(Yi−1) = {w(y0), w(y1), .., w(yi−1)}

Li−1 = {l0, l1, ..., li−1}

Ui−1 = {u0, u1, ..., ui−1}

Zi−1 = {z1, ..., zi−1}

The elements in sets w(Yi−1), Li−1 and Ui−1 have been deﬁned earlier. The set Zi−1
records the smallest values zk computed in an interval [yk−1, yk].

In i-th iteration, we do the following sequentially:

• Compute yi = arg inf x∈[a,b] H(x; Yi−1) as follows. Let z∗ = min Zi−1 and k

be the index of the interval [yk−1, yk] where z∗ is computed. Then we let

yi =

yk−1 + yk
2

−

w(yk) − w(yk−1)
2K

• Let Yi = Yi−1 ∪ {yi}, then reorder Yi in ascending order, and update w(Yi) =

and have that yi ∈ (yk−1, yk).

w(Yi−1) ∪ {w(yi)}.

• Calculate

zi−1 =

w(yi) + w(yk−1)
2

−

K(yi − yk−1)
2

zi =

w(yk) + w(yi)
2

−

K(yk − yi)
2

(15)

(16)

(17)

and update Zi = (Zi−1 \ {z∗}) ∪ {zi−1, zi}.

• Calculate the new lower bound li = inf x∈[a,b] H(x; Yi) by letting li = min Zi,

and updating Li = Li−1 ∪ {li}.

• Calculate the new upper bound ui = miny∈Yi w(y) by letting ui = min{ui−1, w(yi)}.

We terminate the iteration whenever |ui −li| ≤ (cid:15), and let the global minimum value

be y∗ = minx∈[a,b] H(x; Yi) and the minimum objective function be w∗ = w(y∗).

Intuitively, as shown in Fig. 1, we iteratively generate lower bounds (by selecting in
each iteration the lowest point in the saw-tooth function in the ﬁgure) by continuously
reﬁning a piecewise-linear lower bound function, which is guaranteed to below the
original function due to Lipschitz continuity. The upper bound is the lowest evaluation
value of the original function so far.

8

5.1.1 Convergence Analysis

In the following, we show the convergence of this algorithm to the global minimum by
proving the following conditions.

• Convergence Condition 1: lim
i→∞

li = min
x∈[a,b]

w(x)

• Convergence Condition 2: limi→∞(ui − li) = 0

Proof 2 (Monotonicity of Lower/Upper Bound Sequences) First, we prove that the
lower bound sequence Li is strictly monotonic. Because

li = min Zi = min{(Zi−1 \ {z∗}) ∪ {zi−1, zi}}

(18)

and li−1 = min Zi. To show that li > li−1, we need to prove zi−1 > z∗ and zi > z∗.
By the algorithm, z∗ is computed from interval [yk−1, yk], so we have

We then have

z∗ =

w(yk) + w(yk−1)
2

−

K(yk − yk−1)
2

zi−1 − z∗ =

w(yi) − w(yk) − K(yi − yk)
2

(19)

(20)

Since yi < yk and K > Kbest, by Lipschitz continuity we have zi−1 > z∗. Similarly,
we can prove zi > z∗. Thus li > li−1 is guaranteed.

Second, the monotonicity of upper bounds ui can be seen from the algorithm, since

ui is updated to min{ui, w(yi)} in every iteration.

Proof 3 (Convergence Condition 1)
Since Yi−1 ⊆ Yi, we have H(x; Yi−1) ≤ H(x; Yi). Based on Proof 2, we also have
li−1 < li. Then since

li = inf

x∈[a,b]

H(x; Yi) ≤ min
x∈[a,b]

w(x)

(21)

the lower bound sequence {l0, l1, ..., li} is strictly monotonically increasing and bounded
from above by minx∈[a,b] w(x). Thus limi→∞ li = minx∈[a,b] w(x) holds.

Proof 4 (Convergence Condition 2)
Since limi→∞ li = minx∈[a,b] w(x), we show limi→∞(ui − li) = 0 by showing that
limi→∞ ui = minx∈[a,b] w(x). Since Yi = Yi−1 ∪ {yi} and yi ∈ X = [a, b], we have
limi→∞ Yi = X. Then we have limi→∞ ui = limi→∞ inf y∈Yi w(y) = inf w(X).
Since X = [a, b] is a closed interval, we can prove limi→∞ ui = inf w(X) =
minx∈[a,b] w(x).

9

5.1.2 Dynamically Improving the Lipschitz Constant

A Lipschitz constant closer to Kbest can greatly improve the speed of convergence
of the algorithm. We design a practical approach to dynamically update the current
Lipschitz constant according to the information obtained from the previous iteration:
(cid:12)
(cid:12)
(cid:12)
(cid:12)
j=1,...,i−1
(cid:12)
where η > 1. We emphasise that, because

w(yj) − w(yj−1)
yj − yj−1

K = η max

(22)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

lim
i→∞

max
j=1,...,i−1

η

w(yj) − w(yj−1)
yj − yj−1

= η sup
y∈[a,b]

dw
dy

> Kbest

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

this dynamic update does not compromise the convergence.

5.2 Multi-dimensional Case

The basic idea is to decompose a multi-dimensional optimization problem into a se-
quence of nested one-dimensional subproblems. Then the minima of those one-dimensional
minimization subproblems are back-propagated into the original dimension and the ﬁ-
nal global minimum is obtained.

min
x∈[ai,bi]n

w(x) = min

... min

w(x1, ..., xn)

x1∈[a1,b1]

xn∈[an,bn]

(23)

We ﬁrst introduce the deﬁnition of k-th level subproblem.

Deﬁnition 7 The k-th level optimization subproblem, written as φk(x1, ..., xk), is de-
ﬁned as follows: for 1 ≤ k ≤ n − 1,

φk(x1, ..., xk) =

min
xk+1∈[ak+1,bk+1]

φk+1(x1, ..., xk, xk+1)

and for k = n,

φn(x1, ..., xn) = w(x1, x2, ..., xn).

Combining Expression (23) and Deﬁnition 7, we have that

min
x∈[ai,bi]n

w(x) = min

φ1(x1)

x1∈[a1,b1]

which is actually a one-dimensional optimization problem and therefore can be solved
by the method in Section 5.1.

However, when evaluating the objective function φ1(x1) at x1 = a1, we need to

project a1 into the next one-dimensional subproblem

min
x2∈[a2,b2]

φ2(a1, x2)

We recursively perform the projection until we reach the n-th level one-dimensional
subproblem,

min
xn∈[an,bn]

φn(a1, a2, ..., an−1, xn)

Once solved, we back-propagate objective function values to the ﬁrst-level φ1(a1) and
continue searching from this level until the error bound is reached.

10

5.2.1 Convergence Analysis

We use mathematical induction to prove convergence for the multi-dimension case.

• Base case: for all x ∈ R, limi→∞ li = inf x∈[a,b] w(x) and limi→∞(ui − li) = 0

hold.

• Inductive step: if, for all x ∈ Rk, limi→∞ li = inf x∈[a,b]k w(x) and limi→∞(ui−
li) = 0 are satisﬁed, then, for all x ∈ Rk+1, limi→∞ li = inf x∈[a,b]k+1 w(x) and
limi→∞(ui − li) = 0 hold.

The base case (i.e., one-dimensional case) is already proved in Section 5.1. Now we
prove the inductive step.

Proof 5 By the nested optimization scheme, we have

min
x∈[ai,bi]k+1

w(x) = min
x∈[a,b]

Φ(x)

Φ(x) = min

w(x, y)

y∈[ai,bi]k
Since miny∈[ai,bi]k w(x, y) is bounded by an interval error (cid:15)y, assuming Φ∗(x) is the
accurate global minimum, then we have

Φ∗(x) − (cid:15)y ≤ Φ(x) ≤ Φ∗(x) + (cid:15)y

So the k+1-dimensional problem is reduced to the one-dimensional problem minx∈[a,b] Φ(x).
The difference from the real one-dimensional case is that evaluation of Φ(x) is not ac-
curate but bounded by |Φ(x) − Φ∗(x)| ≤ (cid:15)y, ∀x ∈ [a, b], where Φ∗(x) is the accurate
function evaluation.

Assuming that the minimal value obtained from our method is Φ∗

min = minx∈[a,b] Φ∗(x)

0, ..., l∗

0, ..., u∗

i } and {u∗

under accurate function evaluation, then the corresponding lower and upper bound se-
quences are {l∗

i }, respectively.
For the inaccurate evaluation case, we assume Φmin = minx∈[a,b] Φ(x), and its
lower and bound sequences are, respectively, {l0, ..., li} and {u0, ..., ui}. The ter-
mination criteria for both cases are |u∗
i | ≤ (cid:15)x and |ui − li| ≤ (cid:15)x, and φ∗
i − l∗
represents the ideal global minimum. Then we have φ∗ − (cid:15)x ≤ li. Assuming that
l∗
i ∈ [xk, xk+1] and xk, xk+1 are adjacent evaluation points, then due to the fact that
l∗
i = inf x∈[a,b] H(x; Yi) we have

φ∗ − (cid:15)x ≤ l∗

i =

Φ∗(xk) + Φ∗(xk+1)
2

−

L(xk+1 − xk)
2

Since |Φ(xi) − Φ∗(xi)| ≤ (cid:15)y, ∀i = k, k + 1, we thus have

φ∗ − (cid:15)x ≤

Φ(xk) + Φ(xk+1)
2

+ (cid:15)y −

L(xk+1 − xk)
2

Based on the search scheme, we know that

li =

Φ(xk) + Φ(xk+1)
2

−

L(xk+1 − xk)
2

(24)

11

and thus we have φ∗ − li ≤ (cid:15)y + (cid:15)x.

Similarly, we can get

φ∗ + (cid:15)x ≥ u∗

i = inf
y∈Yi

Φ∗(y) ≥ ui − (cid:15)y

(25)

so ui − φ∗ ≤ (cid:15)x + (cid:15)y. By φ∗ − li ≤ (cid:15)y + (cid:15)x and the termination criteria ui − li ≤ (cid:15)x,
we have li − (cid:15)y ≤ φ∗ ≤ ui + (cid:15)y, i.e., the accurate global minimum is also bounded.

The proof indicates that the overall error bound of the nested scheme only increases
linearly w.r.t. the bounds in the one-dimensional case. Moreover, an adaptive approach
can be applied to optimise its performance without compromising convergence. The
key observation is to relax the strict subordination inherent in the nested scheme and
simultaneously consider all the univariate subproblems arising in the course of multidi-
mensional optimization. For all the generated subproblems that are active, a numerical
measure is applied. Then an iteration of the multidimensional optimization consists
in choosing the subproblem with maximal measurement and carrying out a new trial
within this subproblem. The measure is deﬁned to be the maximal interval characteris-
tics generated by the one-dimensional optimisation algorithm.

6 Proof of NP-completeness

In this section, we prove the NP-completeness of our generic reachability problem.

6.1 Upper Bound

First of all, we show that the one-dimension optimisation case is linear with respect to
the error bound (cid:15). As shown in Figure 1, we have that

w(yk−1) − z∗ = K(yi − yk−1)
w(yk) − z∗ = K(yk − yi)

w(yk) − w(yk−1) = K(yk − yi) − K(yi − yk−1)

So we have

Moreover, we have

w(yk) + w(yi) − K(yk − yi) −

w(yk) + w(yk−1)
2

+

K(yk − yk−1)
2

= w(yi)

Based on Equation (17) and (19), we have

2zi − z∗ = w(yi)

12

Therefore, we have zi − z∗ =
z∗ ≤ l∗, and u∗ − l∗ > (cid:15) before convergence, we have

w(yi) − z∗
2

. Now, since we have that w(yi) ≥ u∗ and

zi − z∗ >

1
2

(cid:15)

Therefore, the improvement for each iteration is of linear with respect to the error
bound (cid:15), which means that the optimisation procedure will converge in linear time with
respect to the size of region [a, b].

For the multiple dimensional case, we notice that, in Equation (23), to reach the
global optimum, not all the dimensions xi for i ∈ [1..n] need to be changed and the
ordering between dimensions matter. Therefore, we can have a non-deterministic al-
gorithm which guesses a subset of dimensions together with their ordering. These are
dimensions that need to be changed to lead from the original input to the global opti-
mum. This guess can be done in polynomial time.

Then, we can apply the one-dimensional optimisation algorithm backward from the
last dimension to the ﬁrst dimension. Because of the polynomial time convergence of
the one-dimensional case, this procedure can be completed in polynomial time.

Therefore, the entire procedure can be completed in polynomial time with a non-

deterministic algorithm, i.e., in NP.

6.2 Lower Bound

We have a reduction from the 3-SAT problem, which is known to be NP-complete. A
3-SAT Boolean formula ϕ is of the form c1 ∧ ... ∧ cm, where each clause ci is of the
form li1 ∨ li2 ∨ li3. Each literal lij, for 1 ≤ i ≤ m and 1 ≤ j ≤ 3, is a variable
v or its negation ¬v, such that v ∈ {v1, ..., vn}. The 3-SAT problem is to decide the
existence of a truth-value assignment to the boolean variables V = {v1, ..., vn} such
that the formula ϕ is True.

6.2.1 Construction of DNN

We let varij ∈ V and sgnij ∈ {p, n} be the variable and the sign of the literal lij,
respectively. Given a formula ϕ, we construct a DNN f which implements a classiﬁ-
cation problem. The DNN has four layers {Li}i∈[1..4], within which L2, L3 are hidden
layers, L1 is the input layer, and L4 is the output layer. It has n input neurons and m
output neurons.

Input Layer The input layer L1 has n neurons, each of which represents a variable
in V .

First Hidden Layer – Fully Connected with ReLU The hidden layer L2 has 2n
neurons, such that every two neurons correspond to a variable in V . Given a variable
vi, we write pvi and nvi to denote the two neurons for vi such that

pvi = ReLU (vi)
nvi = ReLU (−1 ∗ vi)

13

(26)

It is noted that, the above functions can be implemented as a fully connected function,
by letting the coefﬁcients from variables other than vi be 0.

Second Hidden Layer – Fully Connected with ReLU The hidden layer L3 has m
neurons, each of which represents a clause. Let cvi be the neuron representing the
clause ci. Then for a clause ci = li1 ∨ li2 ∨ li3, we have

cvi = ReLU (xvi1 + xvi2 + xvi3)

(27)

where for k ∈ {1, 2, 3}, we have

xvik =

(cid:26) nvj
pvj

if sgnik = n and varik = vj for some j
if sgnik = p and varik = vj for some j

Intuitively, cvi takes either a positive value or zero. For the latter case, none of the
three literals are satisﬁed.

Output Layer – Fully Connected Without ReLU The output layer L4 has m neu-
rons, each of which represents a clause. Let ncvi be the neuron representing the clause
ci. Then we have

ncvi = −1 ∗ cvi

(28)

Intuitively, this layer simply negates all the values from the previous layer.

6.2.2 Statistical Evaluation Function o

After the output, we let o be the following function

ov = max{ncvi | i ∈ [1..m]}

(29)

That is, o gets the maximal value of all the outputs. Because cvi ≥ 0 and ncvi ≤ 0, we
have that ov ≤ 0.

6.2.3 Reduction

First, we show that for any point x ∈ Rn, there exists a point x0 ∈ {−1, 1}n such that,
w(x) (cid:54)= 0 if and only if w(x0) (cid:54)= 0. Recall that w is a concatenation of the network f
with o, i.e., w = o · f . For any input dimension i ∈ [1..n], we let

x0(i) =

(cid:26) 1
−1

if x(i) ≥ 0
if x(i) < 0

Therefore, by construction, we have that cvi = 0 if and only if cv0
i = 0. After passing
through L4 and the function o, we have that ov = 0 if and only ov0 = 0. This is
equivalent to w(x) (cid:54)= 0 if and only if w(x0) (cid:54)= 0.

Then, for every truth-assignment a : V → {T rue, F alse}, we associate with
it a point x ∈ {−1, 1}n by letting x(i) = 1 if a(i) = T rue and x(i) = −1 if
a(i) = F alse.

14

Figure 2: Comparison with SHERLOCK and Reluplex

Finally, we show that the formula ϕ is satisﬁable if and only if the function w = o·f

cannot reach value 0. This is done by only considering those points in {−1, 1}n.

(⇒) If ϕ is satisﬁable then by construction, in the second hidden layer, cvi > 0
for all i ∈ [1..m]. Therefore, in the output layer, we have ncvi < 0 for all i ∈ [1..m].
Finally, with the function o, we have ov < 0, i.e., the function w cannot reach value 0.
(⇐) We prove by contradiction. If ϕ is unsatisﬁable, then there must exist a clause
which is unsatisﬁable. Then by construction, we have cvi = 0 for some i ∈ [1..m].
This results in ncvi = 0 and ov = 0, which contradicts with the hypothesis that w
cannot reach 0.

Figure 3: The four features and the architecture of DNN-1 and DNN-7

7 Experiments

7.1 Comparison with State-of-the-art Methods

Two methods are chosen as baseline methods in this paper:

• Reluplex [7]: an SMT-based method for solving queries on DNNs with ReLU

15

Figure 4: Left: boxplots of conﬁdence reachability diameters for 7 DNNs, based on 4 × 20
analyses of each DNN. Right: boxplot of conﬁdence reachability diameters for 4 features, based
on 7 × 20 analyses of each feature. The red line represents the median value: a lower value
indicates a more robust model or feature.

activations; we apply a bisection scheme to compute an interval until an error is
reached

• SHERLOCK [10]: a MILP-based method dedicated to output range analysis on

DNNs with ReLU activations.

Our software is implemented in Matlab 2018a, running on a notebook computer
with i7-7700HQ CPU and 16GB RAM. Since Reluplex and SHERLOCK (not open-
sourced) are designed on different software platforms, we take their experimental re-
sults from [10], whose experimental environment is a Linux workstation with 63GB
RAM and 23-Cores CPU (more powerful than ours) and (cid:15) = 0.01. Following the
experimental setup in [10], we use their data (2-input and 1-output functions) to train
six neural networks with various numbers and types of layers and neurons. The input
subspace is X (cid:48) = [0, 10]2.

The comparison results are given in Fig. 2. They show that, while the performance
of both Reluplex and SHERLOCK is considerably affected by the increase in the num-
ber of neurons and layers, our method is not. For the six benchmark neural networks,
our average computation time is around 5s, 36 fold improvement over SHERLOCK
and nearly 100 fold improvement over Reluplex (excluding timeouts). We note that
our method is running on a notebook PC, which is signiﬁcantly less powerful than the
23-core CPU stations used for SHERLOCK and Reluplex.

7.2 Safety and Robustness Veriﬁcation by Reachability Analysis

We use our tool to conduct logit and output range analysis. Seven convolutional neural
networks, represented as DNN-1,...,DNN-7, were trained on the MNIST dataset. Im-
ages are resized into 14 × 14 to enforce that a DNN with deeper layers tends to over-ﬁt.
The networks have different layer types, including ReLu, dropout and normalization,
and the number of layers ranges from 5 to 19. Testing accuracies range from 95% to
99%, and (cid:15) = 0.05 is used in our experiments.

16

Figure 5: Left: an original image (logit is 11.806, conﬁdence of output being ‘0’ is 99.95%),
where area marked by dashed line is the feature. Middle: an image on the conﬁdence lower
bound. Right: an image on the conﬁdence upper bound; for the output label ‘0’, the feature’s
output range is [74.36%, 99.98%], and logit reachability is [7.007, 13.403]

We randomly choose 20 images (2 images per label) and manually choose 4 fea-
tures such that each feature contains 8 pixels, i.e., X (cid:48) = [0, 1]8. Fig. 3 illustrates the
four features and the architecture of two DNNs with the shallowest and deepest layers,
i.e., DNN-1 and DNN-7.

Safety Veriﬁcation Fig. 5 shows an example: for DNN-1, Feature-4 is guaranteed to
be safe with respect to the image x and the input subspace X (cid:48). Speciﬁcally, the reach-
ability interval is R(Π0, X (cid:48), (cid:15)) = [74.36%, 99.98%], which means that l(Π0, X (cid:48), (cid:15)) =
74.36%. By this, we have u(⊕−0, X (cid:48), (cid:15)) ≤ (1 − 0.7436) < 0.7436 = l(Π0, X (cid:48), (cid:15)).
Then, by Theorem 2, we have S(DNN-1, x, X (cid:48)). Intuitively, no matter how we manip-
ulate this feature, the worst case is to reduce the conﬁdence of output being ‘0’ from
99.95% (its original conﬁdence probability) to 74.36%.

Statistical Comparison of Safety Fig. 6 compares the ratios of safe images for dif-
ferent DNNs and features. It shows that: i) no DNN is 100% safe on those features:
DNN-6 is the safest one and DNN-1, DNN-2 and DNN-3 are less safe, which means a
DNN with well chosen layers are safer than those DNNs with very shallow or deeper
layers; and ii) the safety performance of different DNNs is consistent for the same fea-
ture, which suggests that the feature matters – some features are easily perturbed to
yield adversarial examples, e.g., Feature-1 and Feature-2.
Statistical Comparison of Robustness Fig. 4 compares the robustness of networks
and features with two boxplots over the reachability diameters, where the function o is
Πj for a suitable j. We can see that DNN-6 and DNN-5 are the two most robust, while
DNN-1, DNN-2 and DNN-3 are less robust. Moreover, Feature-1 and Feature-2 are
less robust than Feature-3 and Feature-4.

We have thus demonstrated that reachability analysis with our tool can be used
to quantify the safety and robustness of deep learning models. In the following, we
perform a comparison of networks over a ﬁxed feature.

Safety Comparison of Networks By Fig. 7, DNN-4 and DNN-6 are guaranteed to
be safe w.r.t. the subspace deﬁned by Feature-3. Moreover, the output range of DNN-
7 is [1.8%, 100.0%], which means that we can generate adversarial images by only

17

Figure 6: Ratios of safe images for 7 DNNs and 4 features

perturbing this feature, among which the worst one is as shown in the ﬁgure with a
conﬁdence 1.8%. Thus, reachability analysis not only enables qualitative safety ver-
iﬁcation (i.e., safe or not safe), but also allows benchmarking of safety of different
deep learning models in a principled, quantitive manner (i.e., how safe) by quantify-
ing the ‘worst’ adversarial example. Moreover, compared to retraining the model with
‘regular’ adversarial images, these ‘worst’ adversarial images are more effective in im-
proving the robustness of DNNs [27].

Robustness Comparison of Networks The bar chart in Fig. 7 shows the reachability
diameters of the networks over Feature-3, where the function o is Πj. DNN-4 is the
most robust one, and its output range is [94.2%, 100%].

7.3 A Comprehensive Comparison with the State-of-the-arts

This section presents a comprehensive, high-level comparison of our method with sev-
eral existing approaches that have been used for either range analysis or veriﬁcation
of DNNs, including SHERLOCK [10], Reluplex [7], Planet [26], MIP [11, 9] and
BaB [12], as shown in Fig. 8. We investigate these approaches from the following
seven aspects:

1. core techniques,

2. workable layer types,

3. running time on ACAS Xu,

4. computational complexity,

18

Figure 7: A detailed example comparing the safety and robustness of DNNs for image ’9’ and
Feature-3: the top number in the caption of each ﬁgure is logit and the bottom one is conﬁdence;
the unsafe cases are all misclassiﬁed as ‘8’; the last bar chart shows their conﬁdence reachability
diameters.

5. applicable to state-of-the-art networks,

6. input constraints, and

7. maximum number of layers in tested DNNs.

We are incomparable to approaches based on exhaustive search (such as DLV [6] and
SafeCV [15]) because we have a different way of expressing guarantees.

Core Techniques Most existing approaches (SHERLOCK, Reluplex, Planet, MIP) are
based on reduction to constraint solving, except for BaB which mixes constraint solv-
ing with local search. On the other hand, our method is based on global optimization
and assumes Lipschitz continuity of the networks. As indicated in Section 3, all known
layers used in classiﬁcation tasks are Lipschitz continuous.

Workable Layer Types While we are able to work with all known layers used in
classiﬁcation tasks because they are Lipschitz continuous (proved in Section 3 of the
paper), Planet, MIP and BaB can only work with Relu and Maxpooling, and SHER-
LOCK and Reluplex can only work with Relu.

Running Time on ACAS-Xu Network We collect running time data from [12] on
the ACAS-Xu network, and ﬁnd that our approach has similar performance to BaB,
and better than the others. No experiments for SHERLOCK are available. We reiterate
that, compared to their experimental platform (Desktop PC with i7-5930K CPU, 32GB

19

RAM), ours is less powerful (Laptop PC with i7-7700HQ CPU, 16GB RAM). We em-
phasise that, although our approach performs well on this network, the actual strength
of our approach is not the running time on small networks such as ACAS-Xu, but the
ability to work with large-scale networks (such as those shown in Section 6.2).

Computational Complexity While all the mentioned approaches are in the same com-
plexity class, NP, the complexity of our method is with respect to the number of input
dimensions to be changed, as opposed to the number of hidden neurons. It is known
that the number of hidden neurons is much larger than the number of input dimensions,
e.g., there are nearly 6.5 × 106 neurons in AlexNet.

Applicable to State-of-the-art Networks We are able to work with state-of-the-art
networks with millions of neurons. However, the other tools (Reluplex, Planet, MIP,
BaB) can only work with hundreds of neurons. SHERLOCK can work with thousands
of neurons thanks to its interleaving of MILP with local search.

Maximum Number of Layers in Tested DNNs We have validated our method on
networks with 19 layers, whereas the other approaches are validated on up to 6 layers.
In summary, the key advantages of our approach are as follows: i) the ability to
work with large-scale state-of-the-art networks; ii) lower computational complexity,
i.e., NP-completeness with respect to the input dimensions to be changed, instead of
the number of hidden neurons; and iii) the wide range of types of layers that can be
handled.

8 Conclusion

We propose, design and implement a reachability analysis tool for deep neural net-
works, which has provable guarantees and can be applied to neural networks with deep
layers and nonlinear activation functions. The experiments demonstrate that our tool
can be utilized to verify the safety of deep neural networks and quantitatively com-
pare their robustness. We envision that this work marks an important step towards a
practical, guaranteed safety veriﬁcation for DNNs. Future work includes parallelizing
this method in GPUs to improve its scalability on large-scale models trained on Im-
ageNet, and a generalisation to other deep learning models such as RNNs and deep
reinforcement learning.

9 Acknowledgements

WR and MK are supported by the EPSRC Programme Grant on Mobile Autonomy
(EP/M019918/1). XH acknowledges NVIDIA Corporation for its support with the
donation of the Titan Xp GPU, and is partially supported by NSFC (no. 61772232).

20

References

[1] W. Ruan, X. Huang, and M. Kwiatkowska, “Reachability analysis of deep neural
networks with provable guarantees,” The 27th International Joint Conference on
Artiﬁcial Intelligence (IJCAI), 2018.

[2] D. Amodei, C. Olah, J. Steinhardt, P. Christiano, J. Schulman, and D. Man´e,
“Concrete problems in ai safety,” arXiv preprint arXiv:1606.06565, 2016.
[Online]. Available: https://arxiv.org/pdf/1606.06565.pdf

[3] Y. Sun, M. Wu, W. Ruan, X. Huang, M. Kwiatkowska, and D. Kroening, “Con-
colic testing for deep neural networks,” arXiv preprint arXiv:1805.00089v1,
2018.

[4] C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Erhan, I. Goodfellow, and
R. Fergus, “Intriguing properties of neural networks,” arXiv:1312.6199v4, 2013.

[5] I. J. Goodfellow, J. Shlens, and C. Szegedy, “Explaining and Harnessing Adver-

sarial Examples,” ArXiv e-prints, Dec. 2014.

[6] X. Huang, M. Kwiatkowska, S. Wang, and M. Wu, “Safety veriﬁcation of deep
neural networks,” in Computer Aided Veriﬁcation. Springer Berlin Heidelberg,
2017, pp. 3–29.

[7] G. Katz, C. Barrett, D. Dill, K. Julian, and M. Kochenderfer, “Reluplex:
An efﬁcient smt solver for verifying deep neural networks,” arXiv preprint
arXiv:1702.01135, 2017.

[8] W. Ruan, M. Wu, Y. Sun, X. Huang, D. Kroening, and M. Kwiatkowska, “Global
robustness evaluation of deep neural networks with provable guarantees for L0
norm,” arXiv preprint arXiv:1804.05805v1, 2018.

[9] A. Lomuscio and L. Maganti, “An approach to reachability analysis for
feed-forward relu neural networks,” CoRR, vol. abs/1706.07351, 2017. [Online].
Available: http://arxiv.org/abs/1706.07351

[10] S. Dutta, S. Jha, S. Sanakaranarayanan, and A. Tiwari, “Output range analysis for

deep neural networks,” arXiv preprint arXiv:1709.09130, 2017.

[11] C.-H. Cheng, G. N¨uhrenberg, and H. Ruess, “Maximum resilience of artiﬁ-
cial neural networks,” in Automated Technology for Veriﬁcation and Analysis,
D. D’Souza and K. Narayan Kumar, Eds. Cham: Springer International Pub-
lishing, 2017, pp. 251–268.

[12] R. Bunel,

I. Turkaslan, P. H. Torr, P. Kohli, and M. P. Kumar, “Piece-
wise linear neural network veriﬁcation: A comparative study,” arXiv preprint
arXiv:1711.00455, 2017.

[13] W. Xiang, H.-D. Tran, and T. T. Johnson, “Output reachable set estimation and
veriﬁcation for multi-layer neural networks,” arXiv preprint arXiv:1708.03322,
2017.

21

[14] N. Narodytska, S. P. Kasiviswanathan, L. Ryzhyk, M. Sagiv, and T. Walsh,
“Verifying properties of binarized deep neural networks,” CoRR, vol.
abs/1709.06662, 2017. [Online]. Available: https://arxiv.org/abs/1709.06662

[15] M. Wicker, X. Huang, and M. Kwiatkowska, “Feature-guided black-box safety
testing of deep neural networks,” in Proc. 24th International Conference on Tools
and Algorithms for the Construction and Analysis of Systems (TACAS’18), 2018,
pp. 408–426.

[16] V. Gergel, V. Grishagin, and A. Gergel, “Adaptive nested optimization scheme for
multidimensional global search,” Journal of Global Optimization, vol. 66, no. 1,
pp. 35–51, 2016.

[17] V. Grishagin, R. Israﬁlov, and Y. Sergeyev, “Convergence conditions and numeri-
cal comparison of global optimization methods based on dimensionality reduction
schemes,” Applied Mathematics and Computation, vol. 318, pp. 270–280, 2018.

[18] L. Pulina and A. Tacchella, “An abstraction-reﬁnement approach to veriﬁcation
Springer Berlin

of artiﬁcial neural networks,” in Computer Aided Veriﬁcation.
Heidelberg, 2010, pp. 243–257.

[19] A. M. Nguyen, J. Yosinski, and J. Clune, “Deep neural networks are easily
fooled: High conﬁdence predictions for unrecognizable images,” CoRR, vol.
abs/1412.1897, 2014. [Online]. Available: http://arxiv.org/abs/1412.1897

[20] S. Moosavi-Dezfooli, A. Fawzi, O. Fawzi, and P. Frossard, “Universal adversarial
perturbations,” CoRR, vol. abs/1610.08401, 2016. [Online]. Available: http:
//arxiv.org/abs/1610.08401

[21] N. Carlini and D. A. Wagner, “Towards evaluating the robustness of
neural networks,” CoRR, vol. abs/1608.04644, 2016. [Online]. Available:
http://arxiv.org/abs/1608.04644

[22] N. Papernot, P. D. McDaniel, S. Jha, M. Fredrikson, Z. B. Celik, and
A. Swami, “The limitations of deep learning in adversarial settings,” CoRR, vol.
abs/1511.07528, 2015. [Online]. Available: http://arxiv.org/abs/1511.07528

[23] H. H. Sohrab, Basic real analysis. Springer, 2003, vol. 231.

[24] S. Piyavskii, “An algorithm for ﬁnding the absolute extremum of a function,”
USSR Computational Mathematics and Mathematical Physics, vol. 12, no. 4, pp.
57–67, 1972.

[25] A. Torn and A. Zilinskas, Global Optimization. New York, NY, USA: Springer-

Verlag New York, Inc., 1989.

[26] R. Ehlers, “Formal veriﬁcation of piece-wise linear feed-forward neural net-
works,” in International Symposium on Automated Technology for Veriﬁcation
and Analysis. Springer, 2017, pp. 269–286.

22

[27] J. Z. Kolter and E. Wong, “Provable defenses against adversarial examples via the
convex outer adversarial polytope,” arXiv preprint arXiv:1711.00851, 2017.

23

.
]
2
1
[

B
a
B
d
n
a

]
9

,

1
1
[
P
I
M

,
]
6
2
[

t
e
n
a
l
P

,
]
7
[

x
e
l
p
u
l
e
R

,
]
0
1
[

K
C
O
L
R
E
H
S

:
s
d
o
h
t
e
m

t
r
a
-
e
h
t
-
f
o
-
e
t
a
t
s

h
t
i

w
n
o
s
i
r
a
p
m
o
c

l
e
v
e
l
-
h
g
i
h
A

:
8

e
r
u
g
i
F

24

8
1
0
2
 
y
a
M
 
6
 
 
]

G
L
.
s
c
[
 
 
1
v
2
4
2
2
0
.
5
0
8
1
:
v
i
X
r
a

Reachability Analysis of Deep Neural Networks
with Provable Guarantees*

Wenjie Ruan1, Xiaowei Huang2, Marta Kwiatkowska1
1 Department of Computer Science, University of Oxford, UK
{wenjie.ruan; marta.kwiatkowska}@cs.ox.ac.uk
2 Department of Computer Science, University of Liverpool, UK
xiaowei.huang@liverpool.ac.uk

Abstract

Verifying correctness of deep neural networks (DNNs) is challenging. We
study a generic reachability problem for feed-forward DNNs which, for a given
set of inputs to the network and a Lipschitz-continuous function over its outputs,
computes the lower and upper bound on the function values. Because the network
and the function are Lipschitz continuous, all values in the interval between the
lower and upper bound are reachable. We show how to obtain the safety veriﬁ-
cation problem, the output range analysis problem and a robustness measure by
instantiating the reachability problem. We present a novel algorithm based on
adaptive nested optimisation to solve the reachability problem. The technique has
been implemented and evaluated on a range of DNNs, demonstrating its efﬁciency,
scalability and ability to handle a broader class of networks than state-of-the-art
veriﬁcation approaches.

1

Introduction

Concerns have been raised about the suitability of deep neural networks (DNNs), or
systems with DNN components, for deployment in safety-critical applications, see e.g.,
[2, 3]. To ease this concern and gain users’ trust, DNNs need to be certiﬁed similarly to
systems such as airplanes and automobiles. In this paper, we propose to study a generic
reachability problem which, for a given DNN, an input subspace and a function over
the outputs of the network, computes the upper and lower bounds over the values of
the function. The function is generic, with the only requirement that it is Lipschitz
continuous. We argue that this problem is fundamental for certiﬁcation of DNNs, as
it can be instantiated into several key correctness problems, including adversarial ex-
ample generation [4, 5], safety veriﬁcation [6, 7, 8], output range analysis [9, 10], and
robustness comparison.

*This is the long version of the conference paper accepted in IJCAI-2018, see [1].

1

To certify a system, a certiﬁcation approach needs to provide not only a result but
also a guarantee over the result, such as the error bounds. Existing approaches for
analysing DNNs with a guarantee work by either reducing the problem to a constraint
satisfaction problem that can be solved by MILP [9, 11, 12, 13], SAT [14] or SMT
[7, 12] techniques, or applying search algorithms over discretised vector spaces [6,
15]. Even though they are able to achieve guarantees, they suffer from two major
weaknesses. Firstly, their subjects of study are restricted. More speciﬁcally, they can
only work with layers conducting linear transformations (such as convolutional and
fully-connected layers) and simple non-linear transformations (such as ReLU), and
cannot work with other important layers, such as the sigmoid, max pooling and softmax
layers that are widely used in state-of-the-art networks. Secondly, the scalability of the
constraint-based approaches is signiﬁcantly limited by both the capability of the solvers
and the size of the network, and they can only work with networks with a few hundreds
of hidden neurons. However, state-of-the-art networks usually have millions, or even
billions, of hidden neurons.

This paper proposes a novel approach to tackle the generic reachability problem,
which does not suffer from the above weaknesses and provides provable guarantees in
terms of the upper and lower bounds over the errors. The approach is inspired by re-
cent advances made in the area of global optimisation [16, 17]. For the input subspace
deﬁned over a set of input dimensions, an adaptive nested optimisation algorithm is de-
veloped. The performance of our algorithm is not dependent on the size of the network
and it can therefore scale to work with large networks.

Our algorithm assumes certain knowledge about the DNN. However, instead of di-
rectly translating the activation functions and their parameters (i.e., weights and bias)
into linear constraints, it needs a Lipschitz constant of the network. For this, we show
that several layers that cannot be directly translated into linear constraints are actu-
ally Lipschitz continuous, and we are able to compute a tight Lipschitz constant by
analysing the activation functions and their parameters.

We develop a software tool DeepGO1 and evaluate its performance by comparing
with existing constraint-based approaches, namely, SHERLOCK [10] and Reluplex
[7]. We also demonstrate our tool on DNNs that are beyond the capability of existing
tools.

2 Related Works

We discuss several threads of work concerning problems that can be obtained by in-
stantiating our generic reachability problem. Their instantiations are explained in the
paper. Due to space limitations, this review is by no means complete.

Safety Veriﬁcation There are two ways of achieving safety veriﬁcation for DNNs. The
ﬁrst is to reduce the problem into a constraint solving problem. Notable works include,
e.g., [18, 7]. However, they can only work with small networks with hundreds of hidden
neurons. The second is to discretise the vector spaces of the input or hidden layers
and then apply exhaustive search algorithms or Monte Carlo tree search algorithm on

1Available on https://github.com/trustAI/DeepGO.

2

the discretised spaces. The guarantees are achieved by establishing local assumptions
such as minimality of manipulations in [6] and minimum conﬁdence gap for Lipschitz
networks in [15].

Adversarial Example Generation Most existing works, e.g., [4, 5, 19, 20, 21], apply
various heuristic algorithms, generally using search algorithms based on gradient de-
scent or evolutionary techniques. [22] construct a saliency map of the importance of
the pixels based on gradient descent and then modify the pixels. In contrast with our
approach based on global optimisation and works on safety veriﬁcation, these methods
may be able to ﬁnd adversarial examples efﬁciently, but are not able to conclude the
nonexistence of adversarial examples when the algorithm fails to ﬁnd one.

Output Range Analysis The safety veriﬁcation approach can be adapted to work on
this problem. Moreover, [9] consider determining whether an output value of a DNN
is reachable from a given input subspace, and propose an MILP solution. [10] study
the range of output values from a given input subspace. Their method interleaves local
search (based on gradient descent) with global search (based on reduction to MILP).
Both approaches can only work with small networks.

3 Lipschitz Continuity of DNNs

This section shows that feed-forward DNNs are Lipschitz continuous. Let f : Rn →
Rm be a N -layer network such that, for a given input x ∈ Rn, f (x) = {c1, c2, ..., cm} ∈
Rm represents the conﬁdence values for m classiﬁcation labels. Speciﬁcally, we have
f (x) = fN (fN −1(...f1(x; W1, b1); W2, b2); ...); WN , bN ) where Wi and bi for i =
1, 2, ..., N are learnable parameters and fi(zi−1; Wi−1, bi−1) is the function mapping
from the output of layer i − 1 to the output of layer i such that zi−1 is the output of
layer i − 1. Without loss of generality, we normalise the input to lie x ∈ [0, 1]n. The
output f (x) is usually normalised to be in [0, 1]m with a softmax layer.

Deﬁnition 1 (Lipschitz Continuity) Given two metric spaces (X, dX ) and (Y, dY ),
where dX and dY are the metrics on the sets X and Y respectively, a function f :
X → Y is called Lipschitz continuous if there exists a real constant K ≥ 0 such that,
for all x1, x2 ∈ X:

dY (f (x1), f (x2)) ≤ KdX (x1, x2).

(1)

K is called the Lipschitz constant for the function f . The smallest K is called the Best
Lipschitz constant, denoted as Kbest.

In [4], the authors show that deep neural networks with half-rectiﬁed layers (i.e., con-
volutional or fully connected layers with ReLU activation functions), max pooling
and contrast-normalization layers are Lipschitz continuous. They prove that the up-
per bound of the Lipschitz constant can be estimated via the operator norm of learned
parameters W .

Next, we show that the softmax layer, sigmoid and Hyperbolic tangent activation

functions also satisfy Lipschitz continuity. First we need the following lemma [23].

3

Lemma 1 Let f : Rn → Rm, if ||∂f (x)/∂x|| ≤ K for all x ∈ [a, b]n, then f is
Lipschitz continuous on [a, b]n and K is its Lipschitz constant, where || ∗ || represents
a norm operator.

Based on this lemma, we have the following theorem.

Theorem 1 Convolutional or fully connected layers with the sigmoid activation func-
tion s(W x + b), Hyperbolic tangent activation function t(W x + b), and softmax func-

tion p(x)j are Lipschitz continuous and their Lipschitz constants are
supi,j((cid:107)xi(cid:107) +(cid:13)

(cid:13)
(cid:13)), respectively.

(cid:13)xixj

1
2

(cid:107)W (cid:107),(cid:107)W (cid:107), and

Proof 1 First of all, we show that the norm operators of their Jacobian matrices are
bounded.

(1) Layer with sigmoid activation s(q) = 1/(1 + e−q) with q = W x + b:

(2) Layer with Hyperbolic tangent activation function t(q) = 2/(1 + e−2q) − 1

with q = W x + b:

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂s(x)
∂x

=

(cid:13)
(cid:13)
(cid:13)
(cid:13)

(cid:13)
∂s(q)
(cid:13)
(cid:13)
∂q
(cid:13)
(cid:13)s(q) ◦ (1 − s(q))(cid:13)
≤ (cid:13)

∂q
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)

≤

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂s(q)
∂q

∂q
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)

(cid:13)(cid:107)W (cid:107) ≤

(cid:107)W (cid:107)

(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
1
2

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂t(x)
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)
≤ (cid:13)

∂t(q)
∂q

(cid:13)
(cid:13)
(cid:13)
(cid:13)
∂q
(cid:13)
(cid:13)
(cid:13)
(cid:13)
=
(cid:13)
(cid:13)
(cid:13)
(cid:13)
∂x
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)1 − t(q) ◦ t(q))(cid:13)
(cid:13)(cid:107)W (cid:107) ≤ (cid:107)W (cid:107)

∂t(q)
∂q

∂q
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)

(cid:13)
(cid:13)
(cid:13)
(cid:13)

≤

(3) Layer with softmax function p(x)j = exj /((cid:80)n

k=1 exk ) for j = 1, ..., m and

n = m (dimensions of input and output of softmax are the same):

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂p(x)j
∂xi

(cid:13)
(cid:13)
(cid:13)
(cid:13)

=

(cid:26) xi(1 − xj), i = j
−xixj, i (cid:54)= j

((cid:107)xi(cid:107) +(cid:13)

(cid:13)xixj

(cid:13)
(cid:13))

≤ sup
i,j

Since the softmax layer is the last layer of a deep neural network, we can estimate
its supremum based on Lipschitz constants of previous layers and box constraints of
DNN’s input.

The ﬁnal conclusion follows by Lemma 1 and the fact that all the layer functions

are bounded on their Jacobian matrix.

4 Problem Formulation

Let o : [0, 1]m → R be a Lipschitz continuous function statistically evaluating the out-
puts of the network. Our problem is to ﬁnd its upper and lower bounds given the set X (cid:48)
of inputs to the network. Because both the network f and the function o are Lipschitz
continuous, all values between the upper and lower bounds have a corresponding input,
i.e., are reachable.

4

(2)

(3)

(4)

Deﬁnition 2 (Reachability of Neural Network) Let X (cid:48) ⊆ [0, 1]n be an input sub-
space and f : Rn → Rm a network. The reachability of f over the function o under
an error tolerance (cid:15) ≥ 0 is a set R(o, X (cid:48), (cid:15)) = [l, u] such that

(5)

(6)

l ≥ inf

x(cid:48)∈X (cid:48)

o(f (x(cid:48))) − (cid:15) and u ≤ sup
x(cid:48)∈X (cid:48)

o(f (x(cid:48))) + (cid:15).

We write u(o, X (cid:48), (cid:15)) = u and l(o, X (cid:48), (cid:15)) = l for the upper and lower bound, respec-
tively. Then the reachability diameter is

D(o, X (cid:48), (cid:15)) = u(o, X (cid:48), (cid:15)) − l(o, X (cid:48), (cid:15)).

Assuming these notations, we may write D(o, X (cid:48), (cid:15); f ) if we need to explicitly refer to
the network f .

In the following, we instantiate o with a few concrete functions, and show that
several key veriﬁcation problems for DNNs can be reduced to our reachability problem.

Deﬁnition 3 (Output Range Analysis) Given a class label j ∈ [1, .., m], we let o =
Πj such that Πj((c1, ..., cm)) = cj.

We write cj(x) = Πj(f (x)) for the network’s conﬁdence in classifying x as label j.
Intuitively, output range [10] quantiﬁes how a certain output of a deep neural network
(i.e., classiﬁcation probability of a certain label j) varies in response to a set of DNN
inputs with an error tolerance (cid:15). Output range analysis can be easily generalised to logit
2 range analysis.

We show that the safety veriﬁcation problem [6] can be reduced to solving the

reachability problem.

Deﬁnition 4 (Safety) A network f is safe with respect to an input x and an input
subspace X (cid:48) ⊆ [0, 1]n with x ∈ X (cid:48), written as S(f, x, X (cid:48)), if

∀x(cid:48) ∈ X (cid:48) : arg max

cj(x(cid:48)) = arg max

cj(x)

j

j

(7)

We have the following reduction theorem.

Theorem 2 A network f is safe with respect to x and X (cid:48) s.t. x ∈ X (cid:48) if and only if
u(⊕, X (cid:48), (cid:15)) ≤ 0, where ⊕(c1, ..., cm) = maxi∈{1..m}(Πi(c1, ..., cm)−Πj(c1, ..., cm))
and j = arg maxj cj(x). The error bound of the safety decision problem by this
reduction is 2(cid:15).

It is not hard to see that the adversarial example generation [4], which is to ﬁnd an
input x(cid:48) ∈ X (cid:48) such that arg maxj cj(x(cid:48)) (cid:54)= arg maxj cj(x), is the dual problem of the
safety problem.

The following two problems deﬁne the robustness comparisons between the net-

works and/or the inputs.

in, e.g., [22, 10].

2Logit output is the output of the layer before the softmax layer. The study of logit outputs is conducted

5

Deﬁnition 5 (Robustness) Given two homogeneous3 networks f and g, we say that f
is strictly more robust than g with respect to a function o, an input subspace X (cid:48) and an
error bound (cid:15), written as Ro,X (cid:48),(cid:15)(f, g), if D(o, X (cid:48), (cid:15); f ) < D(o, X (cid:48), (cid:15); g).

Deﬁnition 6 Given two input subspaces X (cid:48) and X (cid:48)(cid:48) and a network f , we say that f
is more robust on X (cid:48) than on X (cid:48)(cid:48) with respect to a statistical function o and an error
bound (cid:15), written as Rf,o,(cid:15)(X (cid:48), X (cid:48)(cid:48)), if D(o, X (cid:48), (cid:15)) < D(o, X (cid:48)(cid:48), (cid:15)).

Thus, by instantiating the function o, we can quantify the output/logit range of
a network, evaluate whether a network is safe, and compare the robustness of two
homogeneous networks or two input subspaces for a given network.

5 Conﬁdence Reachability with Guarantees

Section 3 shows that a trained deep neural network is Lipschitz continuous regardless
of its layer depth, activation functions and number of neurons. Now, to solve the reach-
ability problem, we need to ﬁnd the global minimum and maximum values given an
input subspace, assuming that we have a Lipschitz constant K for the function o·f . In
the following, we let w = o·f be the concatenated function. Without loss of general-
ity, we assume the input space X (cid:48) is a box-constraint, which is clearly feasible since
images are usually normalized into [0, 1]n before being fed into a neural network.

The computation of the minimum value is reduced to solving the following opti-
mization problem with guaranteed convergence to the global minimum (the maximiza-
tion problem can be transferred into a minimization problem):

min
x

w(x), s.t. x ∈ [a, b]n

(8)

However, the above problem is very difﬁcult since w(x) is a highly non-convex func-
tion which cannot be guaranteed to reach the global minimum by regular optimization
schemes based on gradient descent. Inspired by an idea from optimisation, see e.g.,
[24, 25], we design another continuous function h(x, y), which serves as a lower bound
of the original function w(x). Speciﬁcally, we need

∀x, y ∈ [a, b]n, h(x, y) ≤ w(x) and h(x, x) = w(x)

(9)

Furthermore, for i ≥ 0, we let Yi = {y0, y1, ..., yi} be a ﬁnite set containing i + 1
points from the input space [a, b]n, and let Yi ⊆ Yk when k > i, then we can deﬁne a
function H(x; Yi) = maxy∈Yi h(x, y) which satisﬁes the following relation:

H(x; Yi) < H(x; Yk) ≤ w(x), ∀i < k

We use li = inf x∈[a,b]n H(x; Yi) to denote the minimum value of H(x; Yi) for

x ∈ [a, b]n. Then we have

(10)

(11)

l0 < l1 < ... < li−1 < li ≤ inf

w(x)

x∈[a,b]n

3 Here, two networks are homogeneous if they are applied on the same classiﬁcation task but may have

different network architectures (layer numbers, layer types, etc) and/or parameters.

6

Figure 1: A lower-bound function designed via Lipschitz constant

Similarly, we need a sequence of upper bounds ui to have

l0 < ... < li ≤ inf

w(x) ≤ ui < ... < u0

x∈[a,b]n

By Expression (12), we can have the following:

lim
i→∞

li = min

x∈[a,b]n

w(x) and lim
i→∞

(ui − li) = 0

(12)

(13)

Therefore, we can asymptotically approach the global minimum. Practically, we
execute a ﬁnite number of iterations by using an error tolerance (cid:15) to control the ter-
mination. In next sections, we present our approach, which constructs a sequence of
lower and upper bounds, and show that it can converge with an error bound. To han-
dle the high-dimensionality of DNNs, our approach is inspired by the idea of adaptive
nested optimisation in [16], with signiﬁcant differences in the detailed algorithm and
convergence proof.

5.1 One-dimensional Case

We ﬁrst introduce an algorithm which works over one dimension of the input, and
therefore is able to handle the case of x ∈ [a, b] in Eqn. (8). The multi-dimensional op-
timisation algorithm will be discussed in Section 5.2 by utilising the one-dimensional
algorithm.

We deﬁne the following lower-bound function.

h(x, y) = w(y) − K|x − y|

H(x; Yi) = max
y∈Yi

w(y) − K|x − y|

(14)

where K > Kbest is a Lipschitz constant of w and H(x; Yi) intuitively represents the
lower-bound sawtooth function shown as Figure 1. The set of points Yi is constructed

7

recursively. Assuming that, after (i−1)-th iteration, we have Yi−1 = {y0, y1, .., yi−1},
whose elements are in ascending order, and sets

w(Yi−1) = {w(y0), w(y1), .., w(yi−1)}

Li−1 = {l0, l1, ..., li−1}

Ui−1 = {u0, u1, ..., ui−1}

Zi−1 = {z1, ..., zi−1}

The elements in sets w(Yi−1), Li−1 and Ui−1 have been deﬁned earlier. The set Zi−1
records the smallest values zk computed in an interval [yk−1, yk].

In i-th iteration, we do the following sequentially:

• Compute yi = arg inf x∈[a,b] H(x; Yi−1) as follows. Let z∗ = min Zi−1 and k

be the index of the interval [yk−1, yk] where z∗ is computed. Then we let

yi =

yk−1 + yk
2

−

w(yk) − w(yk−1)
2K

• Let Yi = Yi−1 ∪ {yi}, then reorder Yi in ascending order, and update w(Yi) =

and have that yi ∈ (yk−1, yk).

w(Yi−1) ∪ {w(yi)}.

• Calculate

zi−1 =

w(yi) + w(yk−1)
2

−

K(yi − yk−1)
2

zi =

w(yk) + w(yi)
2

−

K(yk − yi)
2

(15)

(16)

(17)

and update Zi = (Zi−1 \ {z∗}) ∪ {zi−1, zi}.

• Calculate the new lower bound li = inf x∈[a,b] H(x; Yi) by letting li = min Zi,

and updating Li = Li−1 ∪ {li}.

• Calculate the new upper bound ui = miny∈Yi w(y) by letting ui = min{ui−1, w(yi)}.

We terminate the iteration whenever |ui −li| ≤ (cid:15), and let the global minimum value

be y∗ = minx∈[a,b] H(x; Yi) and the minimum objective function be w∗ = w(y∗).

Intuitively, as shown in Fig. 1, we iteratively generate lower bounds (by selecting in
each iteration the lowest point in the saw-tooth function in the ﬁgure) by continuously
reﬁning a piecewise-linear lower bound function, which is guaranteed to below the
original function due to Lipschitz continuity. The upper bound is the lowest evaluation
value of the original function so far.

8

5.1.1 Convergence Analysis

In the following, we show the convergence of this algorithm to the global minimum by
proving the following conditions.

• Convergence Condition 1: lim
i→∞

li = min
x∈[a,b]

w(x)

• Convergence Condition 2: limi→∞(ui − li) = 0

Proof 2 (Monotonicity of Lower/Upper Bound Sequences) First, we prove that the
lower bound sequence Li is strictly monotonic. Because

li = min Zi = min{(Zi−1 \ {z∗}) ∪ {zi−1, zi}}

(18)

and li−1 = min Zi. To show that li > li−1, we need to prove zi−1 > z∗ and zi > z∗.
By the algorithm, z∗ is computed from interval [yk−1, yk], so we have

We then have

z∗ =

w(yk) + w(yk−1)
2

−

K(yk − yk−1)
2

zi−1 − z∗ =

w(yi) − w(yk) − K(yi − yk)
2

(19)

(20)

Since yi < yk and K > Kbest, by Lipschitz continuity we have zi−1 > z∗. Similarly,
we can prove zi > z∗. Thus li > li−1 is guaranteed.

Second, the monotonicity of upper bounds ui can be seen from the algorithm, since

ui is updated to min{ui, w(yi)} in every iteration.

Proof 3 (Convergence Condition 1)
Since Yi−1 ⊆ Yi, we have H(x; Yi−1) ≤ H(x; Yi). Based on Proof 2, we also have
li−1 < li. Then since

li = inf

x∈[a,b]

H(x; Yi) ≤ min
x∈[a,b]

w(x)

(21)

the lower bound sequence {l0, l1, ..., li} is strictly monotonically increasing and bounded
from above by minx∈[a,b] w(x). Thus limi→∞ li = minx∈[a,b] w(x) holds.

Proof 4 (Convergence Condition 2)
Since limi→∞ li = minx∈[a,b] w(x), we show limi→∞(ui − li) = 0 by showing that
limi→∞ ui = minx∈[a,b] w(x). Since Yi = Yi−1 ∪ {yi} and yi ∈ X = [a, b], we have
limi→∞ Yi = X. Then we have limi→∞ ui = limi→∞ inf y∈Yi w(y) = inf w(X).
Since X = [a, b] is a closed interval, we can prove limi→∞ ui = inf w(X) =
minx∈[a,b] w(x).

9

5.1.2 Dynamically Improving the Lipschitz Constant

A Lipschitz constant closer to Kbest can greatly improve the speed of convergence
of the algorithm. We design a practical approach to dynamically update the current
Lipschitz constant according to the information obtained from the previous iteration:
(cid:12)
(cid:12)
(cid:12)
(cid:12)
j=1,...,i−1
(cid:12)
where η > 1. We emphasise that, because

w(yj) − w(yj−1)
yj − yj−1

K = η max

(22)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

lim
i→∞

max
j=1,...,i−1

η

w(yj) − w(yj−1)
yj − yj−1

= η sup
y∈[a,b]

dw
dy

> Kbest

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

this dynamic update does not compromise the convergence.

5.2 Multi-dimensional Case

The basic idea is to decompose a multi-dimensional optimization problem into a se-
quence of nested one-dimensional subproblems. Then the minima of those one-dimensional
minimization subproblems are back-propagated into the original dimension and the ﬁ-
nal global minimum is obtained.

min
x∈[ai,bi]n

w(x) = min

... min

w(x1, ..., xn)

x1∈[a1,b1]

xn∈[an,bn]

(23)

We ﬁrst introduce the deﬁnition of k-th level subproblem.

Deﬁnition 7 The k-th level optimization subproblem, written as φk(x1, ..., xk), is de-
ﬁned as follows: for 1 ≤ k ≤ n − 1,

φk(x1, ..., xk) =

min
xk+1∈[ak+1,bk+1]

φk+1(x1, ..., xk, xk+1)

and for k = n,

φn(x1, ..., xn) = w(x1, x2, ..., xn).

Combining Expression (23) and Deﬁnition 7, we have that

min
x∈[ai,bi]n

w(x) = min

φ1(x1)

x1∈[a1,b1]

which is actually a one-dimensional optimization problem and therefore can be solved
by the method in Section 5.1.

However, when evaluating the objective function φ1(x1) at x1 = a1, we need to

project a1 into the next one-dimensional subproblem

min
x2∈[a2,b2]

φ2(a1, x2)

We recursively perform the projection until we reach the n-th level one-dimensional
subproblem,

min
xn∈[an,bn]

φn(a1, a2, ..., an−1, xn)

Once solved, we back-propagate objective function values to the ﬁrst-level φ1(a1) and
continue searching from this level until the error bound is reached.

10

5.2.1 Convergence Analysis

We use mathematical induction to prove convergence for the multi-dimension case.

• Base case: for all x ∈ R, limi→∞ li = inf x∈[a,b] w(x) and limi→∞(ui − li) = 0

hold.

• Inductive step: if, for all x ∈ Rk, limi→∞ li = inf x∈[a,b]k w(x) and limi→∞(ui−
li) = 0 are satisﬁed, then, for all x ∈ Rk+1, limi→∞ li = inf x∈[a,b]k+1 w(x) and
limi→∞(ui − li) = 0 hold.

The base case (i.e., one-dimensional case) is already proved in Section 5.1. Now we
prove the inductive step.

Proof 5 By the nested optimization scheme, we have

min
x∈[ai,bi]k+1

w(x) = min
x∈[a,b]

Φ(x)

Φ(x) = min

w(x, y)

y∈[ai,bi]k
Since miny∈[ai,bi]k w(x, y) is bounded by an interval error (cid:15)y, assuming Φ∗(x) is the
accurate global minimum, then we have

Φ∗(x) − (cid:15)y ≤ Φ(x) ≤ Φ∗(x) + (cid:15)y

So the k+1-dimensional problem is reduced to the one-dimensional problem minx∈[a,b] Φ(x).
The difference from the real one-dimensional case is that evaluation of Φ(x) is not ac-
curate but bounded by |Φ(x) − Φ∗(x)| ≤ (cid:15)y, ∀x ∈ [a, b], where Φ∗(x) is the accurate
function evaluation.

Assuming that the minimal value obtained from our method is Φ∗

min = minx∈[a,b] Φ∗(x)

0, ..., l∗

0, ..., u∗

i } and {u∗

under accurate function evaluation, then the corresponding lower and upper bound se-
quences are {l∗

i }, respectively.
For the inaccurate evaluation case, we assume Φmin = minx∈[a,b] Φ(x), and its
lower and bound sequences are, respectively, {l0, ..., li} and {u0, ..., ui}. The ter-
mination criteria for both cases are |u∗
i | ≤ (cid:15)x and |ui − li| ≤ (cid:15)x, and φ∗
i − l∗
represents the ideal global minimum. Then we have φ∗ − (cid:15)x ≤ li. Assuming that
l∗
i ∈ [xk, xk+1] and xk, xk+1 are adjacent evaluation points, then due to the fact that
l∗
i = inf x∈[a,b] H(x; Yi) we have

φ∗ − (cid:15)x ≤ l∗

i =

Φ∗(xk) + Φ∗(xk+1)
2

−

L(xk+1 − xk)
2

Since |Φ(xi) − Φ∗(xi)| ≤ (cid:15)y, ∀i = k, k + 1, we thus have

φ∗ − (cid:15)x ≤

Φ(xk) + Φ(xk+1)
2

+ (cid:15)y −

L(xk+1 − xk)
2

Based on the search scheme, we know that

li =

Φ(xk) + Φ(xk+1)
2

−

L(xk+1 − xk)
2

(24)

11

and thus we have φ∗ − li ≤ (cid:15)y + (cid:15)x.

Similarly, we can get

φ∗ + (cid:15)x ≥ u∗

i = inf
y∈Yi

Φ∗(y) ≥ ui − (cid:15)y

(25)

so ui − φ∗ ≤ (cid:15)x + (cid:15)y. By φ∗ − li ≤ (cid:15)y + (cid:15)x and the termination criteria ui − li ≤ (cid:15)x,
we have li − (cid:15)y ≤ φ∗ ≤ ui + (cid:15)y, i.e., the accurate global minimum is also bounded.

The proof indicates that the overall error bound of the nested scheme only increases
linearly w.r.t. the bounds in the one-dimensional case. Moreover, an adaptive approach
can be applied to optimise its performance without compromising convergence. The
key observation is to relax the strict subordination inherent in the nested scheme and
simultaneously consider all the univariate subproblems arising in the course of multidi-
mensional optimization. For all the generated subproblems that are active, a numerical
measure is applied. Then an iteration of the multidimensional optimization consists
in choosing the subproblem with maximal measurement and carrying out a new trial
within this subproblem. The measure is deﬁned to be the maximal interval characteris-
tics generated by the one-dimensional optimisation algorithm.

6 Proof of NP-completeness

In this section, we prove the NP-completeness of our generic reachability problem.

6.1 Upper Bound

First of all, we show that the one-dimension optimisation case is linear with respect to
the error bound (cid:15). As shown in Figure 1, we have that

w(yk−1) − z∗ = K(yi − yk−1)
w(yk) − z∗ = K(yk − yi)

w(yk) − w(yk−1) = K(yk − yi) − K(yi − yk−1)

So we have

Moreover, we have

w(yk) + w(yi) − K(yk − yi) −

w(yk) + w(yk−1)
2

+

K(yk − yk−1)
2

= w(yi)

Based on Equation (17) and (19), we have

2zi − z∗ = w(yi)

12

Therefore, we have zi − z∗ =
z∗ ≤ l∗, and u∗ − l∗ > (cid:15) before convergence, we have

w(yi) − z∗
2

. Now, since we have that w(yi) ≥ u∗ and

zi − z∗ >

1
2

(cid:15)

Therefore, the improvement for each iteration is of linear with respect to the error
bound (cid:15), which means that the optimisation procedure will converge in linear time with
respect to the size of region [a, b].

For the multiple dimensional case, we notice that, in Equation (23), to reach the
global optimum, not all the dimensions xi for i ∈ [1..n] need to be changed and the
ordering between dimensions matter. Therefore, we can have a non-deterministic al-
gorithm which guesses a subset of dimensions together with their ordering. These are
dimensions that need to be changed to lead from the original input to the global opti-
mum. This guess can be done in polynomial time.

Then, we can apply the one-dimensional optimisation algorithm backward from the
last dimension to the ﬁrst dimension. Because of the polynomial time convergence of
the one-dimensional case, this procedure can be completed in polynomial time.

Therefore, the entire procedure can be completed in polynomial time with a non-

deterministic algorithm, i.e., in NP.

6.2 Lower Bound

We have a reduction from the 3-SAT problem, which is known to be NP-complete. A
3-SAT Boolean formula ϕ is of the form c1 ∧ ... ∧ cm, where each clause ci is of the
form li1 ∨ li2 ∨ li3. Each literal lij, for 1 ≤ i ≤ m and 1 ≤ j ≤ 3, is a variable
v or its negation ¬v, such that v ∈ {v1, ..., vn}. The 3-SAT problem is to decide the
existence of a truth-value assignment to the boolean variables V = {v1, ..., vn} such
that the formula ϕ is True.

6.2.1 Construction of DNN

We let varij ∈ V and sgnij ∈ {p, n} be the variable and the sign of the literal lij,
respectively. Given a formula ϕ, we construct a DNN f which implements a classiﬁ-
cation problem. The DNN has four layers {Li}i∈[1..4], within which L2, L3 are hidden
layers, L1 is the input layer, and L4 is the output layer. It has n input neurons and m
output neurons.

Input Layer The input layer L1 has n neurons, each of which represents a variable
in V .

First Hidden Layer – Fully Connected with ReLU The hidden layer L2 has 2n
neurons, such that every two neurons correspond to a variable in V . Given a variable
vi, we write pvi and nvi to denote the two neurons for vi such that

pvi = ReLU (vi)
nvi = ReLU (−1 ∗ vi)

13

(26)

It is noted that, the above functions can be implemented as a fully connected function,
by letting the coefﬁcients from variables other than vi be 0.

Second Hidden Layer – Fully Connected with ReLU The hidden layer L3 has m
neurons, each of which represents a clause. Let cvi be the neuron representing the
clause ci. Then for a clause ci = li1 ∨ li2 ∨ li3, we have

cvi = ReLU (xvi1 + xvi2 + xvi3)

(27)

where for k ∈ {1, 2, 3}, we have

xvik =

(cid:26) nvj
pvj

if sgnik = n and varik = vj for some j
if sgnik = p and varik = vj for some j

Intuitively, cvi takes either a positive value or zero. For the latter case, none of the
three literals are satisﬁed.

Output Layer – Fully Connected Without ReLU The output layer L4 has m neu-
rons, each of which represents a clause. Let ncvi be the neuron representing the clause
ci. Then we have

ncvi = −1 ∗ cvi

(28)

Intuitively, this layer simply negates all the values from the previous layer.

6.2.2 Statistical Evaluation Function o

After the output, we let o be the following function

ov = max{ncvi | i ∈ [1..m]}

(29)

That is, o gets the maximal value of all the outputs. Because cvi ≥ 0 and ncvi ≤ 0, we
have that ov ≤ 0.

6.2.3 Reduction

First, we show that for any point x ∈ Rn, there exists a point x0 ∈ {−1, 1}n such that,
w(x) (cid:54)= 0 if and only if w(x0) (cid:54)= 0. Recall that w is a concatenation of the network f
with o, i.e., w = o · f . For any input dimension i ∈ [1..n], we let

x0(i) =

(cid:26) 1
−1

if x(i) ≥ 0
if x(i) < 0

Therefore, by construction, we have that cvi = 0 if and only if cv0
i = 0. After passing
through L4 and the function o, we have that ov = 0 if and only ov0 = 0. This is
equivalent to w(x) (cid:54)= 0 if and only if w(x0) (cid:54)= 0.

Then, for every truth-assignment a : V → {T rue, F alse}, we associate with
it a point x ∈ {−1, 1}n by letting x(i) = 1 if a(i) = T rue and x(i) = −1 if
a(i) = F alse.

14

Figure 2: Comparison with SHERLOCK and Reluplex

Finally, we show that the formula ϕ is satisﬁable if and only if the function w = o·f

cannot reach value 0. This is done by only considering those points in {−1, 1}n.

(⇒) If ϕ is satisﬁable then by construction, in the second hidden layer, cvi > 0
for all i ∈ [1..m]. Therefore, in the output layer, we have ncvi < 0 for all i ∈ [1..m].
Finally, with the function o, we have ov < 0, i.e., the function w cannot reach value 0.
(⇐) We prove by contradiction. If ϕ is unsatisﬁable, then there must exist a clause
which is unsatisﬁable. Then by construction, we have cvi = 0 for some i ∈ [1..m].
This results in ncvi = 0 and ov = 0, which contradicts with the hypothesis that w
cannot reach 0.

Figure 3: The four features and the architecture of DNN-1 and DNN-7

7 Experiments

7.1 Comparison with State-of-the-art Methods

Two methods are chosen as baseline methods in this paper:

• Reluplex [7]: an SMT-based method for solving queries on DNNs with ReLU

15

Figure 4: Left: boxplots of conﬁdence reachability diameters for 7 DNNs, based on 4 × 20
analyses of each DNN. Right: boxplot of conﬁdence reachability diameters for 4 features, based
on 7 × 20 analyses of each feature. The red line represents the median value: a lower value
indicates a more robust model or feature.

activations; we apply a bisection scheme to compute an interval until an error is
reached

• SHERLOCK [10]: a MILP-based method dedicated to output range analysis on

DNNs with ReLU activations.

Our software is implemented in Matlab 2018a, running on a notebook computer
with i7-7700HQ CPU and 16GB RAM. Since Reluplex and SHERLOCK (not open-
sourced) are designed on different software platforms, we take their experimental re-
sults from [10], whose experimental environment is a Linux workstation with 63GB
RAM and 23-Cores CPU (more powerful than ours) and (cid:15) = 0.01. Following the
experimental setup in [10], we use their data (2-input and 1-output functions) to train
six neural networks with various numbers and types of layers and neurons. The input
subspace is X (cid:48) = [0, 10]2.

The comparison results are given in Fig. 2. They show that, while the performance
of both Reluplex and SHERLOCK is considerably affected by the increase in the num-
ber of neurons and layers, our method is not. For the six benchmark neural networks,
our average computation time is around 5s, 36 fold improvement over SHERLOCK
and nearly 100 fold improvement over Reluplex (excluding timeouts). We note that
our method is running on a notebook PC, which is signiﬁcantly less powerful than the
23-core CPU stations used for SHERLOCK and Reluplex.

7.2 Safety and Robustness Veriﬁcation by Reachability Analysis

We use our tool to conduct logit and output range analysis. Seven convolutional neural
networks, represented as DNN-1,...,DNN-7, were trained on the MNIST dataset. Im-
ages are resized into 14 × 14 to enforce that a DNN with deeper layers tends to over-ﬁt.
The networks have different layer types, including ReLu, dropout and normalization,
and the number of layers ranges from 5 to 19. Testing accuracies range from 95% to
99%, and (cid:15) = 0.05 is used in our experiments.

16

Figure 5: Left: an original image (logit is 11.806, conﬁdence of output being ‘0’ is 99.95%),
where area marked by dashed line is the feature. Middle: an image on the conﬁdence lower
bound. Right: an image on the conﬁdence upper bound; for the output label ‘0’, the feature’s
output range is [74.36%, 99.98%], and logit reachability is [7.007, 13.403]

We randomly choose 20 images (2 images per label) and manually choose 4 fea-
tures such that each feature contains 8 pixels, i.e., X (cid:48) = [0, 1]8. Fig. 3 illustrates the
four features and the architecture of two DNNs with the shallowest and deepest layers,
i.e., DNN-1 and DNN-7.

Safety Veriﬁcation Fig. 5 shows an example: for DNN-1, Feature-4 is guaranteed to
be safe with respect to the image x and the input subspace X (cid:48). Speciﬁcally, the reach-
ability interval is R(Π0, X (cid:48), (cid:15)) = [74.36%, 99.98%], which means that l(Π0, X (cid:48), (cid:15)) =
74.36%. By this, we have u(⊕−0, X (cid:48), (cid:15)) ≤ (1 − 0.7436) < 0.7436 = l(Π0, X (cid:48), (cid:15)).
Then, by Theorem 2, we have S(DNN-1, x, X (cid:48)). Intuitively, no matter how we manip-
ulate this feature, the worst case is to reduce the conﬁdence of output being ‘0’ from
99.95% (its original conﬁdence probability) to 74.36%.

Statistical Comparison of Safety Fig. 6 compares the ratios of safe images for dif-
ferent DNNs and features. It shows that: i) no DNN is 100% safe on those features:
DNN-6 is the safest one and DNN-1, DNN-2 and DNN-3 are less safe, which means a
DNN with well chosen layers are safer than those DNNs with very shallow or deeper
layers; and ii) the safety performance of different DNNs is consistent for the same fea-
ture, which suggests that the feature matters – some features are easily perturbed to
yield adversarial examples, e.g., Feature-1 and Feature-2.
Statistical Comparison of Robustness Fig. 4 compares the robustness of networks
and features with two boxplots over the reachability diameters, where the function o is
Πj for a suitable j. We can see that DNN-6 and DNN-5 are the two most robust, while
DNN-1, DNN-2 and DNN-3 are less robust. Moreover, Feature-1 and Feature-2 are
less robust than Feature-3 and Feature-4.

We have thus demonstrated that reachability analysis with our tool can be used
to quantify the safety and robustness of deep learning models. In the following, we
perform a comparison of networks over a ﬁxed feature.

Safety Comparison of Networks By Fig. 7, DNN-4 and DNN-6 are guaranteed to
be safe w.r.t. the subspace deﬁned by Feature-3. Moreover, the output range of DNN-
7 is [1.8%, 100.0%], which means that we can generate adversarial images by only

17

Figure 6: Ratios of safe images for 7 DNNs and 4 features

perturbing this feature, among which the worst one is as shown in the ﬁgure with a
conﬁdence 1.8%. Thus, reachability analysis not only enables qualitative safety ver-
iﬁcation (i.e., safe or not safe), but also allows benchmarking of safety of different
deep learning models in a principled, quantitive manner (i.e., how safe) by quantify-
ing the ‘worst’ adversarial example. Moreover, compared to retraining the model with
‘regular’ adversarial images, these ‘worst’ adversarial images are more effective in im-
proving the robustness of DNNs [27].

Robustness Comparison of Networks The bar chart in Fig. 7 shows the reachability
diameters of the networks over Feature-3, where the function o is Πj. DNN-4 is the
most robust one, and its output range is [94.2%, 100%].

7.3 A Comprehensive Comparison with the State-of-the-arts

This section presents a comprehensive, high-level comparison of our method with sev-
eral existing approaches that have been used for either range analysis or veriﬁcation
of DNNs, including SHERLOCK [10], Reluplex [7], Planet [26], MIP [11, 9] and
BaB [12], as shown in Fig. 8. We investigate these approaches from the following
seven aspects:

1. core techniques,

2. workable layer types,

3. running time on ACAS Xu,

4. computational complexity,

18

Figure 7: A detailed example comparing the safety and robustness of DNNs for image ’9’ and
Feature-3: the top number in the caption of each ﬁgure is logit and the bottom one is conﬁdence;
the unsafe cases are all misclassiﬁed as ‘8’; the last bar chart shows their conﬁdence reachability
diameters.

5. applicable to state-of-the-art networks,

6. input constraints, and

7. maximum number of layers in tested DNNs.

We are incomparable to approaches based on exhaustive search (such as DLV [6] and
SafeCV [15]) because we have a different way of expressing guarantees.

Core Techniques Most existing approaches (SHERLOCK, Reluplex, Planet, MIP) are
based on reduction to constraint solving, except for BaB which mixes constraint solv-
ing with local search. On the other hand, our method is based on global optimization
and assumes Lipschitz continuity of the networks. As indicated in Section 3, all known
layers used in classiﬁcation tasks are Lipschitz continuous.

Workable Layer Types While we are able to work with all known layers used in
classiﬁcation tasks because they are Lipschitz continuous (proved in Section 3 of the
paper), Planet, MIP and BaB can only work with Relu and Maxpooling, and SHER-
LOCK and Reluplex can only work with Relu.

Running Time on ACAS-Xu Network We collect running time data from [12] on
the ACAS-Xu network, and ﬁnd that our approach has similar performance to BaB,
and better than the others. No experiments for SHERLOCK are available. We reiterate
that, compared to their experimental platform (Desktop PC with i7-5930K CPU, 32GB

19

RAM), ours is less powerful (Laptop PC with i7-7700HQ CPU, 16GB RAM). We em-
phasise that, although our approach performs well on this network, the actual strength
of our approach is not the running time on small networks such as ACAS-Xu, but the
ability to work with large-scale networks (such as those shown in Section 6.2).

Computational Complexity While all the mentioned approaches are in the same com-
plexity class, NP, the complexity of our method is with respect to the number of input
dimensions to be changed, as opposed to the number of hidden neurons. It is known
that the number of hidden neurons is much larger than the number of input dimensions,
e.g., there are nearly 6.5 × 106 neurons in AlexNet.

Applicable to State-of-the-art Networks We are able to work with state-of-the-art
networks with millions of neurons. However, the other tools (Reluplex, Planet, MIP,
BaB) can only work with hundreds of neurons. SHERLOCK can work with thousands
of neurons thanks to its interleaving of MILP with local search.

Maximum Number of Layers in Tested DNNs We have validated our method on
networks with 19 layers, whereas the other approaches are validated on up to 6 layers.
In summary, the key advantages of our approach are as follows: i) the ability to
work with large-scale state-of-the-art networks; ii) lower computational complexity,
i.e., NP-completeness with respect to the input dimensions to be changed, instead of
the number of hidden neurons; and iii) the wide range of types of layers that can be
handled.

8 Conclusion

We propose, design and implement a reachability analysis tool for deep neural net-
works, which has provable guarantees and can be applied to neural networks with deep
layers and nonlinear activation functions. The experiments demonstrate that our tool
can be utilized to verify the safety of deep neural networks and quantitatively com-
pare their robustness. We envision that this work marks an important step towards a
practical, guaranteed safety veriﬁcation for DNNs. Future work includes parallelizing
this method in GPUs to improve its scalability on large-scale models trained on Im-
ageNet, and a generalisation to other deep learning models such as RNNs and deep
reinforcement learning.

9 Acknowledgements

WR and MK are supported by the EPSRC Programme Grant on Mobile Autonomy
(EP/M019918/1). XH acknowledges NVIDIA Corporation for its support with the
donation of the Titan Xp GPU, and is partially supported by NSFC (no. 61772232).

20

References

[1] W. Ruan, X. Huang, and M. Kwiatkowska, “Reachability analysis of deep neural
networks with provable guarantees,” The 27th International Joint Conference on
Artiﬁcial Intelligence (IJCAI), 2018.

[2] D. Amodei, C. Olah, J. Steinhardt, P. Christiano, J. Schulman, and D. Man´e,
“Concrete problems in ai safety,” arXiv preprint arXiv:1606.06565, 2016.
[Online]. Available: https://arxiv.org/pdf/1606.06565.pdf

[3] Y. Sun, M. Wu, W. Ruan, X. Huang, M. Kwiatkowska, and D. Kroening, “Con-
colic testing for deep neural networks,” arXiv preprint arXiv:1805.00089v1,
2018.

[4] C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Erhan, I. Goodfellow, and
R. Fergus, “Intriguing properties of neural networks,” arXiv:1312.6199v4, 2013.

[5] I. J. Goodfellow, J. Shlens, and C. Szegedy, “Explaining and Harnessing Adver-

sarial Examples,” ArXiv e-prints, Dec. 2014.

[6] X. Huang, M. Kwiatkowska, S. Wang, and M. Wu, “Safety veriﬁcation of deep
neural networks,” in Computer Aided Veriﬁcation. Springer Berlin Heidelberg,
2017, pp. 3–29.

[7] G. Katz, C. Barrett, D. Dill, K. Julian, and M. Kochenderfer, “Reluplex:
An efﬁcient smt solver for verifying deep neural networks,” arXiv preprint
arXiv:1702.01135, 2017.

[8] W. Ruan, M. Wu, Y. Sun, X. Huang, D. Kroening, and M. Kwiatkowska, “Global
robustness evaluation of deep neural networks with provable guarantees for L0
norm,” arXiv preprint arXiv:1804.05805v1, 2018.

[9] A. Lomuscio and L. Maganti, “An approach to reachability analysis for
feed-forward relu neural networks,” CoRR, vol. abs/1706.07351, 2017. [Online].
Available: http://arxiv.org/abs/1706.07351

[10] S. Dutta, S. Jha, S. Sanakaranarayanan, and A. Tiwari, “Output range analysis for

deep neural networks,” arXiv preprint arXiv:1709.09130, 2017.

[11] C.-H. Cheng, G. N¨uhrenberg, and H. Ruess, “Maximum resilience of artiﬁ-
cial neural networks,” in Automated Technology for Veriﬁcation and Analysis,
D. D’Souza and K. Narayan Kumar, Eds. Cham: Springer International Pub-
lishing, 2017, pp. 251–268.

[12] R. Bunel,

I. Turkaslan, P. H. Torr, P. Kohli, and M. P. Kumar, “Piece-
wise linear neural network veriﬁcation: A comparative study,” arXiv preprint
arXiv:1711.00455, 2017.

[13] W. Xiang, H.-D. Tran, and T. T. Johnson, “Output reachable set estimation and
veriﬁcation for multi-layer neural networks,” arXiv preprint arXiv:1708.03322,
2017.

21

[14] N. Narodytska, S. P. Kasiviswanathan, L. Ryzhyk, M. Sagiv, and T. Walsh,
“Verifying properties of binarized deep neural networks,” CoRR, vol.
abs/1709.06662, 2017. [Online]. Available: https://arxiv.org/abs/1709.06662

[15] M. Wicker, X. Huang, and M. Kwiatkowska, “Feature-guided black-box safety
testing of deep neural networks,” in Proc. 24th International Conference on Tools
and Algorithms for the Construction and Analysis of Systems (TACAS’18), 2018,
pp. 408–426.

[16] V. Gergel, V. Grishagin, and A. Gergel, “Adaptive nested optimization scheme for
multidimensional global search,” Journal of Global Optimization, vol. 66, no. 1,
pp. 35–51, 2016.

[17] V. Grishagin, R. Israﬁlov, and Y. Sergeyev, “Convergence conditions and numeri-
cal comparison of global optimization methods based on dimensionality reduction
schemes,” Applied Mathematics and Computation, vol. 318, pp. 270–280, 2018.

[18] L. Pulina and A. Tacchella, “An abstraction-reﬁnement approach to veriﬁcation
Springer Berlin

of artiﬁcial neural networks,” in Computer Aided Veriﬁcation.
Heidelberg, 2010, pp. 243–257.

[19] A. M. Nguyen, J. Yosinski, and J. Clune, “Deep neural networks are easily
fooled: High conﬁdence predictions for unrecognizable images,” CoRR, vol.
abs/1412.1897, 2014. [Online]. Available: http://arxiv.org/abs/1412.1897

[20] S. Moosavi-Dezfooli, A. Fawzi, O. Fawzi, and P. Frossard, “Universal adversarial
perturbations,” CoRR, vol. abs/1610.08401, 2016. [Online]. Available: http:
//arxiv.org/abs/1610.08401

[21] N. Carlini and D. A. Wagner, “Towards evaluating the robustness of
neural networks,” CoRR, vol. abs/1608.04644, 2016. [Online]. Available:
http://arxiv.org/abs/1608.04644

[22] N. Papernot, P. D. McDaniel, S. Jha, M. Fredrikson, Z. B. Celik, and
A. Swami, “The limitations of deep learning in adversarial settings,” CoRR, vol.
abs/1511.07528, 2015. [Online]. Available: http://arxiv.org/abs/1511.07528

[23] H. H. Sohrab, Basic real analysis. Springer, 2003, vol. 231.

[24] S. Piyavskii, “An algorithm for ﬁnding the absolute extremum of a function,”
USSR Computational Mathematics and Mathematical Physics, vol. 12, no. 4, pp.
57–67, 1972.

[25] A. Torn and A. Zilinskas, Global Optimization. New York, NY, USA: Springer-

Verlag New York, Inc., 1989.

[26] R. Ehlers, “Formal veriﬁcation of piece-wise linear feed-forward neural net-
works,” in International Symposium on Automated Technology for Veriﬁcation
and Analysis. Springer, 2017, pp. 269–286.

22

[27] J. Z. Kolter and E. Wong, “Provable defenses against adversarial examples via the
convex outer adversarial polytope,” arXiv preprint arXiv:1711.00851, 2017.

23

.
]
2
1
[

B
a
B
d
n
a

]
9

,

1
1
[
P
I
M

,
]
6
2
[

t
e
n
a
l
P

,
]
7
[

x
e
l
p
u
l
e
R

,
]
0
1
[

K
C
O
L
R
E
H
S

:
s
d
o
h
t
e
m

t
r
a
-
e
h
t
-
f
o
-
e
t
a
t
s

h
t
i

w
n
o
s
i
r
a
p
m
o
c

l
e
v
e
l
-
h
g
i
h
A

:
8

e
r
u
g
i
F

24

8
1
0
2
 
y
a
M
 
6
 
 
]

G
L
.
s
c
[
 
 
1
v
2
4
2
2
0
.
5
0
8
1
:
v
i
X
r
a

Reachability Analysis of Deep Neural Networks
with Provable Guarantees*

Wenjie Ruan1, Xiaowei Huang2, Marta Kwiatkowska1
1 Department of Computer Science, University of Oxford, UK
{wenjie.ruan; marta.kwiatkowska}@cs.ox.ac.uk
2 Department of Computer Science, University of Liverpool, UK
xiaowei.huang@liverpool.ac.uk

Abstract

Verifying correctness of deep neural networks (DNNs) is challenging. We
study a generic reachability problem for feed-forward DNNs which, for a given
set of inputs to the network and a Lipschitz-continuous function over its outputs,
computes the lower and upper bound on the function values. Because the network
and the function are Lipschitz continuous, all values in the interval between the
lower and upper bound are reachable. We show how to obtain the safety veriﬁ-
cation problem, the output range analysis problem and a robustness measure by
instantiating the reachability problem. We present a novel algorithm based on
adaptive nested optimisation to solve the reachability problem. The technique has
been implemented and evaluated on a range of DNNs, demonstrating its efﬁciency,
scalability and ability to handle a broader class of networks than state-of-the-art
veriﬁcation approaches.

1

Introduction

Concerns have been raised about the suitability of deep neural networks (DNNs), or
systems with DNN components, for deployment in safety-critical applications, see e.g.,
[2, 3]. To ease this concern and gain users’ trust, DNNs need to be certiﬁed similarly to
systems such as airplanes and automobiles. In this paper, we propose to study a generic
reachability problem which, for a given DNN, an input subspace and a function over
the outputs of the network, computes the upper and lower bounds over the values of
the function. The function is generic, with the only requirement that it is Lipschitz
continuous. We argue that this problem is fundamental for certiﬁcation of DNNs, as
it can be instantiated into several key correctness problems, including adversarial ex-
ample generation [4, 5], safety veriﬁcation [6, 7, 8], output range analysis [9, 10], and
robustness comparison.

*This is the long version of the conference paper accepted in IJCAI-2018, see [1].

1

To certify a system, a certiﬁcation approach needs to provide not only a result but
also a guarantee over the result, such as the error bounds. Existing approaches for
analysing DNNs with a guarantee work by either reducing the problem to a constraint
satisfaction problem that can be solved by MILP [9, 11, 12, 13], SAT [14] or SMT
[7, 12] techniques, or applying search algorithms over discretised vector spaces [6,
15]. Even though they are able to achieve guarantees, they suffer from two major
weaknesses. Firstly, their subjects of study are restricted. More speciﬁcally, they can
only work with layers conducting linear transformations (such as convolutional and
fully-connected layers) and simple non-linear transformations (such as ReLU), and
cannot work with other important layers, such as the sigmoid, max pooling and softmax
layers that are widely used in state-of-the-art networks. Secondly, the scalability of the
constraint-based approaches is signiﬁcantly limited by both the capability of the solvers
and the size of the network, and they can only work with networks with a few hundreds
of hidden neurons. However, state-of-the-art networks usually have millions, or even
billions, of hidden neurons.

This paper proposes a novel approach to tackle the generic reachability problem,
which does not suffer from the above weaknesses and provides provable guarantees in
terms of the upper and lower bounds over the errors. The approach is inspired by re-
cent advances made in the area of global optimisation [16, 17]. For the input subspace
deﬁned over a set of input dimensions, an adaptive nested optimisation algorithm is de-
veloped. The performance of our algorithm is not dependent on the size of the network
and it can therefore scale to work with large networks.

Our algorithm assumes certain knowledge about the DNN. However, instead of di-
rectly translating the activation functions and their parameters (i.e., weights and bias)
into linear constraints, it needs a Lipschitz constant of the network. For this, we show
that several layers that cannot be directly translated into linear constraints are actu-
ally Lipschitz continuous, and we are able to compute a tight Lipschitz constant by
analysing the activation functions and their parameters.

We develop a software tool DeepGO1 and evaluate its performance by comparing
with existing constraint-based approaches, namely, SHERLOCK [10] and Reluplex
[7]. We also demonstrate our tool on DNNs that are beyond the capability of existing
tools.

2 Related Works

We discuss several threads of work concerning problems that can be obtained by in-
stantiating our generic reachability problem. Their instantiations are explained in the
paper. Due to space limitations, this review is by no means complete.

Safety Veriﬁcation There are two ways of achieving safety veriﬁcation for DNNs. The
ﬁrst is to reduce the problem into a constraint solving problem. Notable works include,
e.g., [18, 7]. However, they can only work with small networks with hundreds of hidden
neurons. The second is to discretise the vector spaces of the input or hidden layers
and then apply exhaustive search algorithms or Monte Carlo tree search algorithm on

1Available on https://github.com/trustAI/DeepGO.

2

the discretised spaces. The guarantees are achieved by establishing local assumptions
such as minimality of manipulations in [6] and minimum conﬁdence gap for Lipschitz
networks in [15].

Adversarial Example Generation Most existing works, e.g., [4, 5, 19, 20, 21], apply
various heuristic algorithms, generally using search algorithms based on gradient de-
scent or evolutionary techniques. [22] construct a saliency map of the importance of
the pixels based on gradient descent and then modify the pixels. In contrast with our
approach based on global optimisation and works on safety veriﬁcation, these methods
may be able to ﬁnd adversarial examples efﬁciently, but are not able to conclude the
nonexistence of adversarial examples when the algorithm fails to ﬁnd one.

Output Range Analysis The safety veriﬁcation approach can be adapted to work on
this problem. Moreover, [9] consider determining whether an output value of a DNN
is reachable from a given input subspace, and propose an MILP solution. [10] study
the range of output values from a given input subspace. Their method interleaves local
search (based on gradient descent) with global search (based on reduction to MILP).
Both approaches can only work with small networks.

3 Lipschitz Continuity of DNNs

This section shows that feed-forward DNNs are Lipschitz continuous. Let f : Rn →
Rm be a N -layer network such that, for a given input x ∈ Rn, f (x) = {c1, c2, ..., cm} ∈
Rm represents the conﬁdence values for m classiﬁcation labels. Speciﬁcally, we have
f (x) = fN (fN −1(...f1(x; W1, b1); W2, b2); ...); WN , bN ) where Wi and bi for i =
1, 2, ..., N are learnable parameters and fi(zi−1; Wi−1, bi−1) is the function mapping
from the output of layer i − 1 to the output of layer i such that zi−1 is the output of
layer i − 1. Without loss of generality, we normalise the input to lie x ∈ [0, 1]n. The
output f (x) is usually normalised to be in [0, 1]m with a softmax layer.

Deﬁnition 1 (Lipschitz Continuity) Given two metric spaces (X, dX ) and (Y, dY ),
where dX and dY are the metrics on the sets X and Y respectively, a function f :
X → Y is called Lipschitz continuous if there exists a real constant K ≥ 0 such that,
for all x1, x2 ∈ X:

dY (f (x1), f (x2)) ≤ KdX (x1, x2).

(1)

K is called the Lipschitz constant for the function f . The smallest K is called the Best
Lipschitz constant, denoted as Kbest.

In [4], the authors show that deep neural networks with half-rectiﬁed layers (i.e., con-
volutional or fully connected layers with ReLU activation functions), max pooling
and contrast-normalization layers are Lipschitz continuous. They prove that the up-
per bound of the Lipschitz constant can be estimated via the operator norm of learned
parameters W .

Next, we show that the softmax layer, sigmoid and Hyperbolic tangent activation

functions also satisfy Lipschitz continuity. First we need the following lemma [23].

3

Lemma 1 Let f : Rn → Rm, if ||∂f (x)/∂x|| ≤ K for all x ∈ [a, b]n, then f is
Lipschitz continuous on [a, b]n and K is its Lipschitz constant, where || ∗ || represents
a norm operator.

Based on this lemma, we have the following theorem.

Theorem 1 Convolutional or fully connected layers with the sigmoid activation func-
tion s(W x + b), Hyperbolic tangent activation function t(W x + b), and softmax func-

tion p(x)j are Lipschitz continuous and their Lipschitz constants are
supi,j((cid:107)xi(cid:107) +(cid:13)

(cid:13)
(cid:13)), respectively.

(cid:13)xixj

1
2

(cid:107)W (cid:107),(cid:107)W (cid:107), and

Proof 1 First of all, we show that the norm operators of their Jacobian matrices are
bounded.

(1) Layer with sigmoid activation s(q) = 1/(1 + e−q) with q = W x + b:

(2) Layer with Hyperbolic tangent activation function t(q) = 2/(1 + e−2q) − 1

with q = W x + b:

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂s(x)
∂x

=

(cid:13)
(cid:13)
(cid:13)
(cid:13)

(cid:13)
∂s(q)
(cid:13)
(cid:13)
∂q
(cid:13)
(cid:13)s(q) ◦ (1 − s(q))(cid:13)
≤ (cid:13)

∂q
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)

≤

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂s(q)
∂q

∂q
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)

(cid:13)(cid:107)W (cid:107) ≤

(cid:107)W (cid:107)

(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
1
2

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂t(x)
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)
≤ (cid:13)

∂t(q)
∂q

(cid:13)
(cid:13)
(cid:13)
(cid:13)
∂q
(cid:13)
(cid:13)
(cid:13)
(cid:13)
=
(cid:13)
(cid:13)
(cid:13)
(cid:13)
∂x
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)1 − t(q) ◦ t(q))(cid:13)
(cid:13)(cid:107)W (cid:107) ≤ (cid:107)W (cid:107)

∂t(q)
∂q

∂q
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)

(cid:13)
(cid:13)
(cid:13)
(cid:13)

≤

(3) Layer with softmax function p(x)j = exj /((cid:80)n

k=1 exk ) for j = 1, ..., m and

n = m (dimensions of input and output of softmax are the same):

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂p(x)j
∂xi

(cid:13)
(cid:13)
(cid:13)
(cid:13)

=

(cid:26) xi(1 − xj), i = j
−xixj, i (cid:54)= j

((cid:107)xi(cid:107) +(cid:13)

(cid:13)xixj

(cid:13)
(cid:13))

≤ sup
i,j

Since the softmax layer is the last layer of a deep neural network, we can estimate
its supremum based on Lipschitz constants of previous layers and box constraints of
DNN’s input.

The ﬁnal conclusion follows by Lemma 1 and the fact that all the layer functions

are bounded on their Jacobian matrix.

4 Problem Formulation

Let o : [0, 1]m → R be a Lipschitz continuous function statistically evaluating the out-
puts of the network. Our problem is to ﬁnd its upper and lower bounds given the set X (cid:48)
of inputs to the network. Because both the network f and the function o are Lipschitz
continuous, all values between the upper and lower bounds have a corresponding input,
i.e., are reachable.

4

(2)

(3)

(4)

Deﬁnition 2 (Reachability of Neural Network) Let X (cid:48) ⊆ [0, 1]n be an input sub-
space and f : Rn → Rm a network. The reachability of f over the function o under
an error tolerance (cid:15) ≥ 0 is a set R(o, X (cid:48), (cid:15)) = [l, u] such that

(5)

(6)

l ≥ inf

x(cid:48)∈X (cid:48)

o(f (x(cid:48))) − (cid:15) and u ≤ sup
x(cid:48)∈X (cid:48)

o(f (x(cid:48))) + (cid:15).

We write u(o, X (cid:48), (cid:15)) = u and l(o, X (cid:48), (cid:15)) = l for the upper and lower bound, respec-
tively. Then the reachability diameter is

D(o, X (cid:48), (cid:15)) = u(o, X (cid:48), (cid:15)) − l(o, X (cid:48), (cid:15)).

Assuming these notations, we may write D(o, X (cid:48), (cid:15); f ) if we need to explicitly refer to
the network f .

In the following, we instantiate o with a few concrete functions, and show that
several key veriﬁcation problems for DNNs can be reduced to our reachability problem.

Deﬁnition 3 (Output Range Analysis) Given a class label j ∈ [1, .., m], we let o =
Πj such that Πj((c1, ..., cm)) = cj.

We write cj(x) = Πj(f (x)) for the network’s conﬁdence in classifying x as label j.
Intuitively, output range [10] quantiﬁes how a certain output of a deep neural network
(i.e., classiﬁcation probability of a certain label j) varies in response to a set of DNN
inputs with an error tolerance (cid:15). Output range analysis can be easily generalised to logit
2 range analysis.

We show that the safety veriﬁcation problem [6] can be reduced to solving the

reachability problem.

Deﬁnition 4 (Safety) A network f is safe with respect to an input x and an input
subspace X (cid:48) ⊆ [0, 1]n with x ∈ X (cid:48), written as S(f, x, X (cid:48)), if

∀x(cid:48) ∈ X (cid:48) : arg max

cj(x(cid:48)) = arg max

cj(x)

j

j

(7)

We have the following reduction theorem.

Theorem 2 A network f is safe with respect to x and X (cid:48) s.t. x ∈ X (cid:48) if and only if
u(⊕, X (cid:48), (cid:15)) ≤ 0, where ⊕(c1, ..., cm) = maxi∈{1..m}(Πi(c1, ..., cm)−Πj(c1, ..., cm))
and j = arg maxj cj(x). The error bound of the safety decision problem by this
reduction is 2(cid:15).

It is not hard to see that the adversarial example generation [4], which is to ﬁnd an
input x(cid:48) ∈ X (cid:48) such that arg maxj cj(x(cid:48)) (cid:54)= arg maxj cj(x), is the dual problem of the
safety problem.

The following two problems deﬁne the robustness comparisons between the net-

works and/or the inputs.

in, e.g., [22, 10].

2Logit output is the output of the layer before the softmax layer. The study of logit outputs is conducted

5

Deﬁnition 5 (Robustness) Given two homogeneous3 networks f and g, we say that f
is strictly more robust than g with respect to a function o, an input subspace X (cid:48) and an
error bound (cid:15), written as Ro,X (cid:48),(cid:15)(f, g), if D(o, X (cid:48), (cid:15); f ) < D(o, X (cid:48), (cid:15); g).

Deﬁnition 6 Given two input subspaces X (cid:48) and X (cid:48)(cid:48) and a network f , we say that f
is more robust on X (cid:48) than on X (cid:48)(cid:48) with respect to a statistical function o and an error
bound (cid:15), written as Rf,o,(cid:15)(X (cid:48), X (cid:48)(cid:48)), if D(o, X (cid:48), (cid:15)) < D(o, X (cid:48)(cid:48), (cid:15)).

Thus, by instantiating the function o, we can quantify the output/logit range of
a network, evaluate whether a network is safe, and compare the robustness of two
homogeneous networks or two input subspaces for a given network.

5 Conﬁdence Reachability with Guarantees

Section 3 shows that a trained deep neural network is Lipschitz continuous regardless
of its layer depth, activation functions and number of neurons. Now, to solve the reach-
ability problem, we need to ﬁnd the global minimum and maximum values given an
input subspace, assuming that we have a Lipschitz constant K for the function o·f . In
the following, we let w = o·f be the concatenated function. Without loss of general-
ity, we assume the input space X (cid:48) is a box-constraint, which is clearly feasible since
images are usually normalized into [0, 1]n before being fed into a neural network.

The computation of the minimum value is reduced to solving the following opti-
mization problem with guaranteed convergence to the global minimum (the maximiza-
tion problem can be transferred into a minimization problem):

min
x

w(x), s.t. x ∈ [a, b]n

(8)

However, the above problem is very difﬁcult since w(x) is a highly non-convex func-
tion which cannot be guaranteed to reach the global minimum by regular optimization
schemes based on gradient descent. Inspired by an idea from optimisation, see e.g.,
[24, 25], we design another continuous function h(x, y), which serves as a lower bound
of the original function w(x). Speciﬁcally, we need

∀x, y ∈ [a, b]n, h(x, y) ≤ w(x) and h(x, x) = w(x)

(9)

Furthermore, for i ≥ 0, we let Yi = {y0, y1, ..., yi} be a ﬁnite set containing i + 1
points from the input space [a, b]n, and let Yi ⊆ Yk when k > i, then we can deﬁne a
function H(x; Yi) = maxy∈Yi h(x, y) which satisﬁes the following relation:

H(x; Yi) < H(x; Yk) ≤ w(x), ∀i < k

We use li = inf x∈[a,b]n H(x; Yi) to denote the minimum value of H(x; Yi) for

x ∈ [a, b]n. Then we have

(10)

(11)

l0 < l1 < ... < li−1 < li ≤ inf

w(x)

x∈[a,b]n

3 Here, two networks are homogeneous if they are applied on the same classiﬁcation task but may have

different network architectures (layer numbers, layer types, etc) and/or parameters.

6

Figure 1: A lower-bound function designed via Lipschitz constant

Similarly, we need a sequence of upper bounds ui to have

l0 < ... < li ≤ inf

w(x) ≤ ui < ... < u0

x∈[a,b]n

By Expression (12), we can have the following:

lim
i→∞

li = min

x∈[a,b]n

w(x) and lim
i→∞

(ui − li) = 0

(12)

(13)

Therefore, we can asymptotically approach the global minimum. Practically, we
execute a ﬁnite number of iterations by using an error tolerance (cid:15) to control the ter-
mination. In next sections, we present our approach, which constructs a sequence of
lower and upper bounds, and show that it can converge with an error bound. To han-
dle the high-dimensionality of DNNs, our approach is inspired by the idea of adaptive
nested optimisation in [16], with signiﬁcant differences in the detailed algorithm and
convergence proof.

5.1 One-dimensional Case

We ﬁrst introduce an algorithm which works over one dimension of the input, and
therefore is able to handle the case of x ∈ [a, b] in Eqn. (8). The multi-dimensional op-
timisation algorithm will be discussed in Section 5.2 by utilising the one-dimensional
algorithm.

We deﬁne the following lower-bound function.

h(x, y) = w(y) − K|x − y|

H(x; Yi) = max
y∈Yi

w(y) − K|x − y|

(14)

where K > Kbest is a Lipschitz constant of w and H(x; Yi) intuitively represents the
lower-bound sawtooth function shown as Figure 1. The set of points Yi is constructed

7

recursively. Assuming that, after (i−1)-th iteration, we have Yi−1 = {y0, y1, .., yi−1},
whose elements are in ascending order, and sets

w(Yi−1) = {w(y0), w(y1), .., w(yi−1)}

Li−1 = {l0, l1, ..., li−1}

Ui−1 = {u0, u1, ..., ui−1}

Zi−1 = {z1, ..., zi−1}

The elements in sets w(Yi−1), Li−1 and Ui−1 have been deﬁned earlier. The set Zi−1
records the smallest values zk computed in an interval [yk−1, yk].

In i-th iteration, we do the following sequentially:

• Compute yi = arg inf x∈[a,b] H(x; Yi−1) as follows. Let z∗ = min Zi−1 and k

be the index of the interval [yk−1, yk] where z∗ is computed. Then we let

yi =

yk−1 + yk
2

−

w(yk) − w(yk−1)
2K

• Let Yi = Yi−1 ∪ {yi}, then reorder Yi in ascending order, and update w(Yi) =

and have that yi ∈ (yk−1, yk).

w(Yi−1) ∪ {w(yi)}.

• Calculate

zi−1 =

w(yi) + w(yk−1)
2

−

K(yi − yk−1)
2

zi =

w(yk) + w(yi)
2

−

K(yk − yi)
2

(15)

(16)

(17)

and update Zi = (Zi−1 \ {z∗}) ∪ {zi−1, zi}.

• Calculate the new lower bound li = inf x∈[a,b] H(x; Yi) by letting li = min Zi,

and updating Li = Li−1 ∪ {li}.

• Calculate the new upper bound ui = miny∈Yi w(y) by letting ui = min{ui−1, w(yi)}.

We terminate the iteration whenever |ui −li| ≤ (cid:15), and let the global minimum value

be y∗ = minx∈[a,b] H(x; Yi) and the minimum objective function be w∗ = w(y∗).

Intuitively, as shown in Fig. 1, we iteratively generate lower bounds (by selecting in
each iteration the lowest point in the saw-tooth function in the ﬁgure) by continuously
reﬁning a piecewise-linear lower bound function, which is guaranteed to below the
original function due to Lipschitz continuity. The upper bound is the lowest evaluation
value of the original function so far.

8

5.1.1 Convergence Analysis

In the following, we show the convergence of this algorithm to the global minimum by
proving the following conditions.

• Convergence Condition 1: lim
i→∞

li = min
x∈[a,b]

w(x)

• Convergence Condition 2: limi→∞(ui − li) = 0

Proof 2 (Monotonicity of Lower/Upper Bound Sequences) First, we prove that the
lower bound sequence Li is strictly monotonic. Because

li = min Zi = min{(Zi−1 \ {z∗}) ∪ {zi−1, zi}}

(18)

and li−1 = min Zi. To show that li > li−1, we need to prove zi−1 > z∗ and zi > z∗.
By the algorithm, z∗ is computed from interval [yk−1, yk], so we have

We then have

z∗ =

w(yk) + w(yk−1)
2

−

K(yk − yk−1)
2

zi−1 − z∗ =

w(yi) − w(yk) − K(yi − yk)
2

(19)

(20)

Since yi < yk and K > Kbest, by Lipschitz continuity we have zi−1 > z∗. Similarly,
we can prove zi > z∗. Thus li > li−1 is guaranteed.

Second, the monotonicity of upper bounds ui can be seen from the algorithm, since

ui is updated to min{ui, w(yi)} in every iteration.

Proof 3 (Convergence Condition 1)
Since Yi−1 ⊆ Yi, we have H(x; Yi−1) ≤ H(x; Yi). Based on Proof 2, we also have
li−1 < li. Then since

li = inf

x∈[a,b]

H(x; Yi) ≤ min
x∈[a,b]

w(x)

(21)

the lower bound sequence {l0, l1, ..., li} is strictly monotonically increasing and bounded
from above by minx∈[a,b] w(x). Thus limi→∞ li = minx∈[a,b] w(x) holds.

Proof 4 (Convergence Condition 2)
Since limi→∞ li = minx∈[a,b] w(x), we show limi→∞(ui − li) = 0 by showing that
limi→∞ ui = minx∈[a,b] w(x). Since Yi = Yi−1 ∪ {yi} and yi ∈ X = [a, b], we have
limi→∞ Yi = X. Then we have limi→∞ ui = limi→∞ inf y∈Yi w(y) = inf w(X).
Since X = [a, b] is a closed interval, we can prove limi→∞ ui = inf w(X) =
minx∈[a,b] w(x).

9

5.1.2 Dynamically Improving the Lipschitz Constant

A Lipschitz constant closer to Kbest can greatly improve the speed of convergence
of the algorithm. We design a practical approach to dynamically update the current
Lipschitz constant according to the information obtained from the previous iteration:
(cid:12)
(cid:12)
(cid:12)
(cid:12)
j=1,...,i−1
(cid:12)
where η > 1. We emphasise that, because

w(yj) − w(yj−1)
yj − yj−1

K = η max

(22)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

lim
i→∞

max
j=1,...,i−1

η

w(yj) − w(yj−1)
yj − yj−1

= η sup
y∈[a,b]

dw
dy

> Kbest

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

this dynamic update does not compromise the convergence.

5.2 Multi-dimensional Case

The basic idea is to decompose a multi-dimensional optimization problem into a se-
quence of nested one-dimensional subproblems. Then the minima of those one-dimensional
minimization subproblems are back-propagated into the original dimension and the ﬁ-
nal global minimum is obtained.

min
x∈[ai,bi]n

w(x) = min

... min

w(x1, ..., xn)

x1∈[a1,b1]

xn∈[an,bn]

(23)

We ﬁrst introduce the deﬁnition of k-th level subproblem.

Deﬁnition 7 The k-th level optimization subproblem, written as φk(x1, ..., xk), is de-
ﬁned as follows: for 1 ≤ k ≤ n − 1,

φk(x1, ..., xk) =

min
xk+1∈[ak+1,bk+1]

φk+1(x1, ..., xk, xk+1)

and for k = n,

φn(x1, ..., xn) = w(x1, x2, ..., xn).

Combining Expression (23) and Deﬁnition 7, we have that

min
x∈[ai,bi]n

w(x) = min

φ1(x1)

x1∈[a1,b1]

which is actually a one-dimensional optimization problem and therefore can be solved
by the method in Section 5.1.

However, when evaluating the objective function φ1(x1) at x1 = a1, we need to

project a1 into the next one-dimensional subproblem

min
x2∈[a2,b2]

φ2(a1, x2)

We recursively perform the projection until we reach the n-th level one-dimensional
subproblem,

min
xn∈[an,bn]

φn(a1, a2, ..., an−1, xn)

Once solved, we back-propagate objective function values to the ﬁrst-level φ1(a1) and
continue searching from this level until the error bound is reached.

10

5.2.1 Convergence Analysis

We use mathematical induction to prove convergence for the multi-dimension case.

• Base case: for all x ∈ R, limi→∞ li = inf x∈[a,b] w(x) and limi→∞(ui − li) = 0

hold.

• Inductive step: if, for all x ∈ Rk, limi→∞ li = inf x∈[a,b]k w(x) and limi→∞(ui−
li) = 0 are satisﬁed, then, for all x ∈ Rk+1, limi→∞ li = inf x∈[a,b]k+1 w(x) and
limi→∞(ui − li) = 0 hold.

The base case (i.e., one-dimensional case) is already proved in Section 5.1. Now we
prove the inductive step.

Proof 5 By the nested optimization scheme, we have

min
x∈[ai,bi]k+1

w(x) = min
x∈[a,b]

Φ(x)

Φ(x) = min

w(x, y)

y∈[ai,bi]k
Since miny∈[ai,bi]k w(x, y) is bounded by an interval error (cid:15)y, assuming Φ∗(x) is the
accurate global minimum, then we have

Φ∗(x) − (cid:15)y ≤ Φ(x) ≤ Φ∗(x) + (cid:15)y

So the k+1-dimensional problem is reduced to the one-dimensional problem minx∈[a,b] Φ(x).
The difference from the real one-dimensional case is that evaluation of Φ(x) is not ac-
curate but bounded by |Φ(x) − Φ∗(x)| ≤ (cid:15)y, ∀x ∈ [a, b], where Φ∗(x) is the accurate
function evaluation.

Assuming that the minimal value obtained from our method is Φ∗

min = minx∈[a,b] Φ∗(x)

0, ..., l∗

0, ..., u∗

i } and {u∗

under accurate function evaluation, then the corresponding lower and upper bound se-
quences are {l∗

i }, respectively.
For the inaccurate evaluation case, we assume Φmin = minx∈[a,b] Φ(x), and its
lower and bound sequences are, respectively, {l0, ..., li} and {u0, ..., ui}. The ter-
mination criteria for both cases are |u∗
i | ≤ (cid:15)x and |ui − li| ≤ (cid:15)x, and φ∗
i − l∗
represents the ideal global minimum. Then we have φ∗ − (cid:15)x ≤ li. Assuming that
l∗
i ∈ [xk, xk+1] and xk, xk+1 are adjacent evaluation points, then due to the fact that
l∗
i = inf x∈[a,b] H(x; Yi) we have

φ∗ − (cid:15)x ≤ l∗

i =

Φ∗(xk) + Φ∗(xk+1)
2

−

L(xk+1 − xk)
2

Since |Φ(xi) − Φ∗(xi)| ≤ (cid:15)y, ∀i = k, k + 1, we thus have

φ∗ − (cid:15)x ≤

Φ(xk) + Φ(xk+1)
2

+ (cid:15)y −

L(xk+1 − xk)
2

Based on the search scheme, we know that

li =

Φ(xk) + Φ(xk+1)
2

−

L(xk+1 − xk)
2

(24)

11

and thus we have φ∗ − li ≤ (cid:15)y + (cid:15)x.

Similarly, we can get

φ∗ + (cid:15)x ≥ u∗

i = inf
y∈Yi

Φ∗(y) ≥ ui − (cid:15)y

(25)

so ui − φ∗ ≤ (cid:15)x + (cid:15)y. By φ∗ − li ≤ (cid:15)y + (cid:15)x and the termination criteria ui − li ≤ (cid:15)x,
we have li − (cid:15)y ≤ φ∗ ≤ ui + (cid:15)y, i.e., the accurate global minimum is also bounded.

The proof indicates that the overall error bound of the nested scheme only increases
linearly w.r.t. the bounds in the one-dimensional case. Moreover, an adaptive approach
can be applied to optimise its performance without compromising convergence. The
key observation is to relax the strict subordination inherent in the nested scheme and
simultaneously consider all the univariate subproblems arising in the course of multidi-
mensional optimization. For all the generated subproblems that are active, a numerical
measure is applied. Then an iteration of the multidimensional optimization consists
in choosing the subproblem with maximal measurement and carrying out a new trial
within this subproblem. The measure is deﬁned to be the maximal interval characteris-
tics generated by the one-dimensional optimisation algorithm.

6 Proof of NP-completeness

In this section, we prove the NP-completeness of our generic reachability problem.

6.1 Upper Bound

First of all, we show that the one-dimension optimisation case is linear with respect to
the error bound (cid:15). As shown in Figure 1, we have that

w(yk−1) − z∗ = K(yi − yk−1)
w(yk) − z∗ = K(yk − yi)

w(yk) − w(yk−1) = K(yk − yi) − K(yi − yk−1)

So we have

Moreover, we have

w(yk) + w(yi) − K(yk − yi) −

w(yk) + w(yk−1)
2

+

K(yk − yk−1)
2

= w(yi)

Based on Equation (17) and (19), we have

2zi − z∗ = w(yi)

12

Therefore, we have zi − z∗ =
z∗ ≤ l∗, and u∗ − l∗ > (cid:15) before convergence, we have

w(yi) − z∗
2

. Now, since we have that w(yi) ≥ u∗ and

zi − z∗ >

1
2

(cid:15)

Therefore, the improvement for each iteration is of linear with respect to the error
bound (cid:15), which means that the optimisation procedure will converge in linear time with
respect to the size of region [a, b].

For the multiple dimensional case, we notice that, in Equation (23), to reach the
global optimum, not all the dimensions xi for i ∈ [1..n] need to be changed and the
ordering between dimensions matter. Therefore, we can have a non-deterministic al-
gorithm which guesses a subset of dimensions together with their ordering. These are
dimensions that need to be changed to lead from the original input to the global opti-
mum. This guess can be done in polynomial time.

Then, we can apply the one-dimensional optimisation algorithm backward from the
last dimension to the ﬁrst dimension. Because of the polynomial time convergence of
the one-dimensional case, this procedure can be completed in polynomial time.

Therefore, the entire procedure can be completed in polynomial time with a non-

deterministic algorithm, i.e., in NP.

6.2 Lower Bound

We have a reduction from the 3-SAT problem, which is known to be NP-complete. A
3-SAT Boolean formula ϕ is of the form c1 ∧ ... ∧ cm, where each clause ci is of the
form li1 ∨ li2 ∨ li3. Each literal lij, for 1 ≤ i ≤ m and 1 ≤ j ≤ 3, is a variable
v or its negation ¬v, such that v ∈ {v1, ..., vn}. The 3-SAT problem is to decide the
existence of a truth-value assignment to the boolean variables V = {v1, ..., vn} such
that the formula ϕ is True.

6.2.1 Construction of DNN

We let varij ∈ V and sgnij ∈ {p, n} be the variable and the sign of the literal lij,
respectively. Given a formula ϕ, we construct a DNN f which implements a classiﬁ-
cation problem. The DNN has four layers {Li}i∈[1..4], within which L2, L3 are hidden
layers, L1 is the input layer, and L4 is the output layer. It has n input neurons and m
output neurons.

Input Layer The input layer L1 has n neurons, each of which represents a variable
in V .

First Hidden Layer – Fully Connected with ReLU The hidden layer L2 has 2n
neurons, such that every two neurons correspond to a variable in V . Given a variable
vi, we write pvi and nvi to denote the two neurons for vi such that

pvi = ReLU (vi)
nvi = ReLU (−1 ∗ vi)

13

(26)

It is noted that, the above functions can be implemented as a fully connected function,
by letting the coefﬁcients from variables other than vi be 0.

Second Hidden Layer – Fully Connected with ReLU The hidden layer L3 has m
neurons, each of which represents a clause. Let cvi be the neuron representing the
clause ci. Then for a clause ci = li1 ∨ li2 ∨ li3, we have

cvi = ReLU (xvi1 + xvi2 + xvi3)

(27)

where for k ∈ {1, 2, 3}, we have

xvik =

(cid:26) nvj
pvj

if sgnik = n and varik = vj for some j
if sgnik = p and varik = vj for some j

Intuitively, cvi takes either a positive value or zero. For the latter case, none of the
three literals are satisﬁed.

Output Layer – Fully Connected Without ReLU The output layer L4 has m neu-
rons, each of which represents a clause. Let ncvi be the neuron representing the clause
ci. Then we have

ncvi = −1 ∗ cvi

(28)

Intuitively, this layer simply negates all the values from the previous layer.

6.2.2 Statistical Evaluation Function o

After the output, we let o be the following function

ov = max{ncvi | i ∈ [1..m]}

(29)

That is, o gets the maximal value of all the outputs. Because cvi ≥ 0 and ncvi ≤ 0, we
have that ov ≤ 0.

6.2.3 Reduction

First, we show that for any point x ∈ Rn, there exists a point x0 ∈ {−1, 1}n such that,
w(x) (cid:54)= 0 if and only if w(x0) (cid:54)= 0. Recall that w is a concatenation of the network f
with o, i.e., w = o · f . For any input dimension i ∈ [1..n], we let

x0(i) =

(cid:26) 1
−1

if x(i) ≥ 0
if x(i) < 0

Therefore, by construction, we have that cvi = 0 if and only if cv0
i = 0. After passing
through L4 and the function o, we have that ov = 0 if and only ov0 = 0. This is
equivalent to w(x) (cid:54)= 0 if and only if w(x0) (cid:54)= 0.

Then, for every truth-assignment a : V → {T rue, F alse}, we associate with
it a point x ∈ {−1, 1}n by letting x(i) = 1 if a(i) = T rue and x(i) = −1 if
a(i) = F alse.

14

Figure 2: Comparison with SHERLOCK and Reluplex

Finally, we show that the formula ϕ is satisﬁable if and only if the function w = o·f

cannot reach value 0. This is done by only considering those points in {−1, 1}n.

(⇒) If ϕ is satisﬁable then by construction, in the second hidden layer, cvi > 0
for all i ∈ [1..m]. Therefore, in the output layer, we have ncvi < 0 for all i ∈ [1..m].
Finally, with the function o, we have ov < 0, i.e., the function w cannot reach value 0.
(⇐) We prove by contradiction. If ϕ is unsatisﬁable, then there must exist a clause
which is unsatisﬁable. Then by construction, we have cvi = 0 for some i ∈ [1..m].
This results in ncvi = 0 and ov = 0, which contradicts with the hypothesis that w
cannot reach 0.

Figure 3: The four features and the architecture of DNN-1 and DNN-7

7 Experiments

7.1 Comparison with State-of-the-art Methods

Two methods are chosen as baseline methods in this paper:

• Reluplex [7]: an SMT-based method for solving queries on DNNs with ReLU

15

Figure 4: Left: boxplots of conﬁdence reachability diameters for 7 DNNs, based on 4 × 20
analyses of each DNN. Right: boxplot of conﬁdence reachability diameters for 4 features, based
on 7 × 20 analyses of each feature. The red line represents the median value: a lower value
indicates a more robust model or feature.

activations; we apply a bisection scheme to compute an interval until an error is
reached

• SHERLOCK [10]: a MILP-based method dedicated to output range analysis on

DNNs with ReLU activations.

Our software is implemented in Matlab 2018a, running on a notebook computer
with i7-7700HQ CPU and 16GB RAM. Since Reluplex and SHERLOCK (not open-
sourced) are designed on different software platforms, we take their experimental re-
sults from [10], whose experimental environment is a Linux workstation with 63GB
RAM and 23-Cores CPU (more powerful than ours) and (cid:15) = 0.01. Following the
experimental setup in [10], we use their data (2-input and 1-output functions) to train
six neural networks with various numbers and types of layers and neurons. The input
subspace is X (cid:48) = [0, 10]2.

The comparison results are given in Fig. 2. They show that, while the performance
of both Reluplex and SHERLOCK is considerably affected by the increase in the num-
ber of neurons and layers, our method is not. For the six benchmark neural networks,
our average computation time is around 5s, 36 fold improvement over SHERLOCK
and nearly 100 fold improvement over Reluplex (excluding timeouts). We note that
our method is running on a notebook PC, which is signiﬁcantly less powerful than the
23-core CPU stations used for SHERLOCK and Reluplex.

7.2 Safety and Robustness Veriﬁcation by Reachability Analysis

We use our tool to conduct logit and output range analysis. Seven convolutional neural
networks, represented as DNN-1,...,DNN-7, were trained on the MNIST dataset. Im-
ages are resized into 14 × 14 to enforce that a DNN with deeper layers tends to over-ﬁt.
The networks have different layer types, including ReLu, dropout and normalization,
and the number of layers ranges from 5 to 19. Testing accuracies range from 95% to
99%, and (cid:15) = 0.05 is used in our experiments.

16

Figure 5: Left: an original image (logit is 11.806, conﬁdence of output being ‘0’ is 99.95%),
where area marked by dashed line is the feature. Middle: an image on the conﬁdence lower
bound. Right: an image on the conﬁdence upper bound; for the output label ‘0’, the feature’s
output range is [74.36%, 99.98%], and logit reachability is [7.007, 13.403]

We randomly choose 20 images (2 images per label) and manually choose 4 fea-
tures such that each feature contains 8 pixels, i.e., X (cid:48) = [0, 1]8. Fig. 3 illustrates the
four features and the architecture of two DNNs with the shallowest and deepest layers,
i.e., DNN-1 and DNN-7.

Safety Veriﬁcation Fig. 5 shows an example: for DNN-1, Feature-4 is guaranteed to
be safe with respect to the image x and the input subspace X (cid:48). Speciﬁcally, the reach-
ability interval is R(Π0, X (cid:48), (cid:15)) = [74.36%, 99.98%], which means that l(Π0, X (cid:48), (cid:15)) =
74.36%. By this, we have u(⊕−0, X (cid:48), (cid:15)) ≤ (1 − 0.7436) < 0.7436 = l(Π0, X (cid:48), (cid:15)).
Then, by Theorem 2, we have S(DNN-1, x, X (cid:48)). Intuitively, no matter how we manip-
ulate this feature, the worst case is to reduce the conﬁdence of output being ‘0’ from
99.95% (its original conﬁdence probability) to 74.36%.

Statistical Comparison of Safety Fig. 6 compares the ratios of safe images for dif-
ferent DNNs and features. It shows that: i) no DNN is 100% safe on those features:
DNN-6 is the safest one and DNN-1, DNN-2 and DNN-3 are less safe, which means a
DNN with well chosen layers are safer than those DNNs with very shallow or deeper
layers; and ii) the safety performance of different DNNs is consistent for the same fea-
ture, which suggests that the feature matters – some features are easily perturbed to
yield adversarial examples, e.g., Feature-1 and Feature-2.
Statistical Comparison of Robustness Fig. 4 compares the robustness of networks
and features with two boxplots over the reachability diameters, where the function o is
Πj for a suitable j. We can see that DNN-6 and DNN-5 are the two most robust, while
DNN-1, DNN-2 and DNN-3 are less robust. Moreover, Feature-1 and Feature-2 are
less robust than Feature-3 and Feature-4.

We have thus demonstrated that reachability analysis with our tool can be used
to quantify the safety and robustness of deep learning models. In the following, we
perform a comparison of networks over a ﬁxed feature.

Safety Comparison of Networks By Fig. 7, DNN-4 and DNN-6 are guaranteed to
be safe w.r.t. the subspace deﬁned by Feature-3. Moreover, the output range of DNN-
7 is [1.8%, 100.0%], which means that we can generate adversarial images by only

17

Figure 6: Ratios of safe images for 7 DNNs and 4 features

perturbing this feature, among which the worst one is as shown in the ﬁgure with a
conﬁdence 1.8%. Thus, reachability analysis not only enables qualitative safety ver-
iﬁcation (i.e., safe or not safe), but also allows benchmarking of safety of different
deep learning models in a principled, quantitive manner (i.e., how safe) by quantify-
ing the ‘worst’ adversarial example. Moreover, compared to retraining the model with
‘regular’ adversarial images, these ‘worst’ adversarial images are more effective in im-
proving the robustness of DNNs [27].

Robustness Comparison of Networks The bar chart in Fig. 7 shows the reachability
diameters of the networks over Feature-3, where the function o is Πj. DNN-4 is the
most robust one, and its output range is [94.2%, 100%].

7.3 A Comprehensive Comparison with the State-of-the-arts

This section presents a comprehensive, high-level comparison of our method with sev-
eral existing approaches that have been used for either range analysis or veriﬁcation
of DNNs, including SHERLOCK [10], Reluplex [7], Planet [26], MIP [11, 9] and
BaB [12], as shown in Fig. 8. We investigate these approaches from the following
seven aspects:

1. core techniques,

2. workable layer types,

3. running time on ACAS Xu,

4. computational complexity,

18

Figure 7: A detailed example comparing the safety and robustness of DNNs for image ’9’ and
Feature-3: the top number in the caption of each ﬁgure is logit and the bottom one is conﬁdence;
the unsafe cases are all misclassiﬁed as ‘8’; the last bar chart shows their conﬁdence reachability
diameters.

5. applicable to state-of-the-art networks,

6. input constraints, and

7. maximum number of layers in tested DNNs.

We are incomparable to approaches based on exhaustive search (such as DLV [6] and
SafeCV [15]) because we have a different way of expressing guarantees.

Core Techniques Most existing approaches (SHERLOCK, Reluplex, Planet, MIP) are
based on reduction to constraint solving, except for BaB which mixes constraint solv-
ing with local search. On the other hand, our method is based on global optimization
and assumes Lipschitz continuity of the networks. As indicated in Section 3, all known
layers used in classiﬁcation tasks are Lipschitz continuous.

Workable Layer Types While we are able to work with all known layers used in
classiﬁcation tasks because they are Lipschitz continuous (proved in Section 3 of the
paper), Planet, MIP and BaB can only work with Relu and Maxpooling, and SHER-
LOCK and Reluplex can only work with Relu.

Running Time on ACAS-Xu Network We collect running time data from [12] on
the ACAS-Xu network, and ﬁnd that our approach has similar performance to BaB,
and better than the others. No experiments for SHERLOCK are available. We reiterate
that, compared to their experimental platform (Desktop PC with i7-5930K CPU, 32GB

19

RAM), ours is less powerful (Laptop PC with i7-7700HQ CPU, 16GB RAM). We em-
phasise that, although our approach performs well on this network, the actual strength
of our approach is not the running time on small networks such as ACAS-Xu, but the
ability to work with large-scale networks (such as those shown in Section 6.2).

Computational Complexity While all the mentioned approaches are in the same com-
plexity class, NP, the complexity of our method is with respect to the number of input
dimensions to be changed, as opposed to the number of hidden neurons. It is known
that the number of hidden neurons is much larger than the number of input dimensions,
e.g., there are nearly 6.5 × 106 neurons in AlexNet.

Applicable to State-of-the-art Networks We are able to work with state-of-the-art
networks with millions of neurons. However, the other tools (Reluplex, Planet, MIP,
BaB) can only work with hundreds of neurons. SHERLOCK can work with thousands
of neurons thanks to its interleaving of MILP with local search.

Maximum Number of Layers in Tested DNNs We have validated our method on
networks with 19 layers, whereas the other approaches are validated on up to 6 layers.
In summary, the key advantages of our approach are as follows: i) the ability to
work with large-scale state-of-the-art networks; ii) lower computational complexity,
i.e., NP-completeness with respect to the input dimensions to be changed, instead of
the number of hidden neurons; and iii) the wide range of types of layers that can be
handled.

8 Conclusion

We propose, design and implement a reachability analysis tool for deep neural net-
works, which has provable guarantees and can be applied to neural networks with deep
layers and nonlinear activation functions. The experiments demonstrate that our tool
can be utilized to verify the safety of deep neural networks and quantitatively com-
pare their robustness. We envision that this work marks an important step towards a
practical, guaranteed safety veriﬁcation for DNNs. Future work includes parallelizing
this method in GPUs to improve its scalability on large-scale models trained on Im-
ageNet, and a generalisation to other deep learning models such as RNNs and deep
reinforcement learning.

9 Acknowledgements

WR and MK are supported by the EPSRC Programme Grant on Mobile Autonomy
(EP/M019918/1). XH acknowledges NVIDIA Corporation for its support with the
donation of the Titan Xp GPU, and is partially supported by NSFC (no. 61772232).

20

References

[1] W. Ruan, X. Huang, and M. Kwiatkowska, “Reachability analysis of deep neural
networks with provable guarantees,” The 27th International Joint Conference on
Artiﬁcial Intelligence (IJCAI), 2018.

[2] D. Amodei, C. Olah, J. Steinhardt, P. Christiano, J. Schulman, and D. Man´e,
“Concrete problems in ai safety,” arXiv preprint arXiv:1606.06565, 2016.
[Online]. Available: https://arxiv.org/pdf/1606.06565.pdf

[3] Y. Sun, M. Wu, W. Ruan, X. Huang, M. Kwiatkowska, and D. Kroening, “Con-
colic testing for deep neural networks,” arXiv preprint arXiv:1805.00089v1,
2018.

[4] C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Erhan, I. Goodfellow, and
R. Fergus, “Intriguing properties of neural networks,” arXiv:1312.6199v4, 2013.

[5] I. J. Goodfellow, J. Shlens, and C. Szegedy, “Explaining and Harnessing Adver-

sarial Examples,” ArXiv e-prints, Dec. 2014.

[6] X. Huang, M. Kwiatkowska, S. Wang, and M. Wu, “Safety veriﬁcation of deep
neural networks,” in Computer Aided Veriﬁcation. Springer Berlin Heidelberg,
2017, pp. 3–29.

[7] G. Katz, C. Barrett, D. Dill, K. Julian, and M. Kochenderfer, “Reluplex:
An efﬁcient smt solver for verifying deep neural networks,” arXiv preprint
arXiv:1702.01135, 2017.

[8] W. Ruan, M. Wu, Y. Sun, X. Huang, D. Kroening, and M. Kwiatkowska, “Global
robustness evaluation of deep neural networks with provable guarantees for L0
norm,” arXiv preprint arXiv:1804.05805v1, 2018.

[9] A. Lomuscio and L. Maganti, “An approach to reachability analysis for
feed-forward relu neural networks,” CoRR, vol. abs/1706.07351, 2017. [Online].
Available: http://arxiv.org/abs/1706.07351

[10] S. Dutta, S. Jha, S. Sanakaranarayanan, and A. Tiwari, “Output range analysis for

deep neural networks,” arXiv preprint arXiv:1709.09130, 2017.

[11] C.-H. Cheng, G. N¨uhrenberg, and H. Ruess, “Maximum resilience of artiﬁ-
cial neural networks,” in Automated Technology for Veriﬁcation and Analysis,
D. D’Souza and K. Narayan Kumar, Eds. Cham: Springer International Pub-
lishing, 2017, pp. 251–268.

[12] R. Bunel,

I. Turkaslan, P. H. Torr, P. Kohli, and M. P. Kumar, “Piece-
wise linear neural network veriﬁcation: A comparative study,” arXiv preprint
arXiv:1711.00455, 2017.

[13] W. Xiang, H.-D. Tran, and T. T. Johnson, “Output reachable set estimation and
veriﬁcation for multi-layer neural networks,” arXiv preprint arXiv:1708.03322,
2017.

21

[14] N. Narodytska, S. P. Kasiviswanathan, L. Ryzhyk, M. Sagiv, and T. Walsh,
“Verifying properties of binarized deep neural networks,” CoRR, vol.
abs/1709.06662, 2017. [Online]. Available: https://arxiv.org/abs/1709.06662

[15] M. Wicker, X. Huang, and M. Kwiatkowska, “Feature-guided black-box safety
testing of deep neural networks,” in Proc. 24th International Conference on Tools
and Algorithms for the Construction and Analysis of Systems (TACAS’18), 2018,
pp. 408–426.

[16] V. Gergel, V. Grishagin, and A. Gergel, “Adaptive nested optimization scheme for
multidimensional global search,” Journal of Global Optimization, vol. 66, no. 1,
pp. 35–51, 2016.

[17] V. Grishagin, R. Israﬁlov, and Y. Sergeyev, “Convergence conditions and numeri-
cal comparison of global optimization methods based on dimensionality reduction
schemes,” Applied Mathematics and Computation, vol. 318, pp. 270–280, 2018.

[18] L. Pulina and A. Tacchella, “An abstraction-reﬁnement approach to veriﬁcation
Springer Berlin

of artiﬁcial neural networks,” in Computer Aided Veriﬁcation.
Heidelberg, 2010, pp. 243–257.

[19] A. M. Nguyen, J. Yosinski, and J. Clune, “Deep neural networks are easily
fooled: High conﬁdence predictions for unrecognizable images,” CoRR, vol.
abs/1412.1897, 2014. [Online]. Available: http://arxiv.org/abs/1412.1897

[20] S. Moosavi-Dezfooli, A. Fawzi, O. Fawzi, and P. Frossard, “Universal adversarial
perturbations,” CoRR, vol. abs/1610.08401, 2016. [Online]. Available: http:
//arxiv.org/abs/1610.08401

[21] N. Carlini and D. A. Wagner, “Towards evaluating the robustness of
neural networks,” CoRR, vol. abs/1608.04644, 2016. [Online]. Available:
http://arxiv.org/abs/1608.04644

[22] N. Papernot, P. D. McDaniel, S. Jha, M. Fredrikson, Z. B. Celik, and
A. Swami, “The limitations of deep learning in adversarial settings,” CoRR, vol.
abs/1511.07528, 2015. [Online]. Available: http://arxiv.org/abs/1511.07528

[23] H. H. Sohrab, Basic real analysis. Springer, 2003, vol. 231.

[24] S. Piyavskii, “An algorithm for ﬁnding the absolute extremum of a function,”
USSR Computational Mathematics and Mathematical Physics, vol. 12, no. 4, pp.
57–67, 1972.

[25] A. Torn and A. Zilinskas, Global Optimization. New York, NY, USA: Springer-

Verlag New York, Inc., 1989.

[26] R. Ehlers, “Formal veriﬁcation of piece-wise linear feed-forward neural net-
works,” in International Symposium on Automated Technology for Veriﬁcation
and Analysis. Springer, 2017, pp. 269–286.

22

[27] J. Z. Kolter and E. Wong, “Provable defenses against adversarial examples via the
convex outer adversarial polytope,” arXiv preprint arXiv:1711.00851, 2017.

23

.
]
2
1
[

B
a
B
d
n
a

]
9

,

1
1
[
P
I
M

,
]
6
2
[

t
e
n
a
l
P

,
]
7
[

x
e
l
p
u
l
e
R

,
]
0
1
[

K
C
O
L
R
E
H
S

:
s
d
o
h
t
e
m

t
r
a
-
e
h
t
-
f
o
-
e
t
a
t
s

h
t
i

w
n
o
s
i
r
a
p
m
o
c

l
e
v
e
l
-
h
g
i
h
A

:
8

e
r
u
g
i
F

24

8
1
0
2
 
y
a
M
 
6
 
 
]

G
L
.
s
c
[
 
 
1
v
2
4
2
2
0
.
5
0
8
1
:
v
i
X
r
a

Reachability Analysis of Deep Neural Networks
with Provable Guarantees*

Wenjie Ruan1, Xiaowei Huang2, Marta Kwiatkowska1
1 Department of Computer Science, University of Oxford, UK
{wenjie.ruan; marta.kwiatkowska}@cs.ox.ac.uk
2 Department of Computer Science, University of Liverpool, UK
xiaowei.huang@liverpool.ac.uk

Abstract

Verifying correctness of deep neural networks (DNNs) is challenging. We
study a generic reachability problem for feed-forward DNNs which, for a given
set of inputs to the network and a Lipschitz-continuous function over its outputs,
computes the lower and upper bound on the function values. Because the network
and the function are Lipschitz continuous, all values in the interval between the
lower and upper bound are reachable. We show how to obtain the safety veriﬁ-
cation problem, the output range analysis problem and a robustness measure by
instantiating the reachability problem. We present a novel algorithm based on
adaptive nested optimisation to solve the reachability problem. The technique has
been implemented and evaluated on a range of DNNs, demonstrating its efﬁciency,
scalability and ability to handle a broader class of networks than state-of-the-art
veriﬁcation approaches.

1

Introduction

Concerns have been raised about the suitability of deep neural networks (DNNs), or
systems with DNN components, for deployment in safety-critical applications, see e.g.,
[2, 3]. To ease this concern and gain users’ trust, DNNs need to be certiﬁed similarly to
systems such as airplanes and automobiles. In this paper, we propose to study a generic
reachability problem which, for a given DNN, an input subspace and a function over
the outputs of the network, computes the upper and lower bounds over the values of
the function. The function is generic, with the only requirement that it is Lipschitz
continuous. We argue that this problem is fundamental for certiﬁcation of DNNs, as
it can be instantiated into several key correctness problems, including adversarial ex-
ample generation [4, 5], safety veriﬁcation [6, 7, 8], output range analysis [9, 10], and
robustness comparison.

*This is the long version of the conference paper accepted in IJCAI-2018, see [1].

1

To certify a system, a certiﬁcation approach needs to provide not only a result but
also a guarantee over the result, such as the error bounds. Existing approaches for
analysing DNNs with a guarantee work by either reducing the problem to a constraint
satisfaction problem that can be solved by MILP [9, 11, 12, 13], SAT [14] or SMT
[7, 12] techniques, or applying search algorithms over discretised vector spaces [6,
15]. Even though they are able to achieve guarantees, they suffer from two major
weaknesses. Firstly, their subjects of study are restricted. More speciﬁcally, they can
only work with layers conducting linear transformations (such as convolutional and
fully-connected layers) and simple non-linear transformations (such as ReLU), and
cannot work with other important layers, such as the sigmoid, max pooling and softmax
layers that are widely used in state-of-the-art networks. Secondly, the scalability of the
constraint-based approaches is signiﬁcantly limited by both the capability of the solvers
and the size of the network, and they can only work with networks with a few hundreds
of hidden neurons. However, state-of-the-art networks usually have millions, or even
billions, of hidden neurons.

This paper proposes a novel approach to tackle the generic reachability problem,
which does not suffer from the above weaknesses and provides provable guarantees in
terms of the upper and lower bounds over the errors. The approach is inspired by re-
cent advances made in the area of global optimisation [16, 17]. For the input subspace
deﬁned over a set of input dimensions, an adaptive nested optimisation algorithm is de-
veloped. The performance of our algorithm is not dependent on the size of the network
and it can therefore scale to work with large networks.

Our algorithm assumes certain knowledge about the DNN. However, instead of di-
rectly translating the activation functions and their parameters (i.e., weights and bias)
into linear constraints, it needs a Lipschitz constant of the network. For this, we show
that several layers that cannot be directly translated into linear constraints are actu-
ally Lipschitz continuous, and we are able to compute a tight Lipschitz constant by
analysing the activation functions and their parameters.

We develop a software tool DeepGO1 and evaluate its performance by comparing
with existing constraint-based approaches, namely, SHERLOCK [10] and Reluplex
[7]. We also demonstrate our tool on DNNs that are beyond the capability of existing
tools.

2 Related Works

We discuss several threads of work concerning problems that can be obtained by in-
stantiating our generic reachability problem. Their instantiations are explained in the
paper. Due to space limitations, this review is by no means complete.

Safety Veriﬁcation There are two ways of achieving safety veriﬁcation for DNNs. The
ﬁrst is to reduce the problem into a constraint solving problem. Notable works include,
e.g., [18, 7]. However, they can only work with small networks with hundreds of hidden
neurons. The second is to discretise the vector spaces of the input or hidden layers
and then apply exhaustive search algorithms or Monte Carlo tree search algorithm on

1Available on https://github.com/trustAI/DeepGO.

2

the discretised spaces. The guarantees are achieved by establishing local assumptions
such as minimality of manipulations in [6] and minimum conﬁdence gap for Lipschitz
networks in [15].

Adversarial Example Generation Most existing works, e.g., [4, 5, 19, 20, 21], apply
various heuristic algorithms, generally using search algorithms based on gradient de-
scent or evolutionary techniques. [22] construct a saliency map of the importance of
the pixels based on gradient descent and then modify the pixels. In contrast with our
approach based on global optimisation and works on safety veriﬁcation, these methods
may be able to ﬁnd adversarial examples efﬁciently, but are not able to conclude the
nonexistence of adversarial examples when the algorithm fails to ﬁnd one.

Output Range Analysis The safety veriﬁcation approach can be adapted to work on
this problem. Moreover, [9] consider determining whether an output value of a DNN
is reachable from a given input subspace, and propose an MILP solution. [10] study
the range of output values from a given input subspace. Their method interleaves local
search (based on gradient descent) with global search (based on reduction to MILP).
Both approaches can only work with small networks.

3 Lipschitz Continuity of DNNs

This section shows that feed-forward DNNs are Lipschitz continuous. Let f : Rn →
Rm be a N -layer network such that, for a given input x ∈ Rn, f (x) = {c1, c2, ..., cm} ∈
Rm represents the conﬁdence values for m classiﬁcation labels. Speciﬁcally, we have
f (x) = fN (fN −1(...f1(x; W1, b1); W2, b2); ...); WN , bN ) where Wi and bi for i =
1, 2, ..., N are learnable parameters and fi(zi−1; Wi−1, bi−1) is the function mapping
from the output of layer i − 1 to the output of layer i such that zi−1 is the output of
layer i − 1. Without loss of generality, we normalise the input to lie x ∈ [0, 1]n. The
output f (x) is usually normalised to be in [0, 1]m with a softmax layer.

Deﬁnition 1 (Lipschitz Continuity) Given two metric spaces (X, dX ) and (Y, dY ),
where dX and dY are the metrics on the sets X and Y respectively, a function f :
X → Y is called Lipschitz continuous if there exists a real constant K ≥ 0 such that,
for all x1, x2 ∈ X:

dY (f (x1), f (x2)) ≤ KdX (x1, x2).

(1)

K is called the Lipschitz constant for the function f . The smallest K is called the Best
Lipschitz constant, denoted as Kbest.

In [4], the authors show that deep neural networks with half-rectiﬁed layers (i.e., con-
volutional or fully connected layers with ReLU activation functions), max pooling
and contrast-normalization layers are Lipschitz continuous. They prove that the up-
per bound of the Lipschitz constant can be estimated via the operator norm of learned
parameters W .

Next, we show that the softmax layer, sigmoid and Hyperbolic tangent activation

functions also satisfy Lipschitz continuity. First we need the following lemma [23].

3

Lemma 1 Let f : Rn → Rm, if ||∂f (x)/∂x|| ≤ K for all x ∈ [a, b]n, then f is
Lipschitz continuous on [a, b]n and K is its Lipschitz constant, where || ∗ || represents
a norm operator.

Based on this lemma, we have the following theorem.

Theorem 1 Convolutional or fully connected layers with the sigmoid activation func-
tion s(W x + b), Hyperbolic tangent activation function t(W x + b), and softmax func-

tion p(x)j are Lipschitz continuous and their Lipschitz constants are
supi,j((cid:107)xi(cid:107) +(cid:13)

(cid:13)
(cid:13)), respectively.

(cid:13)xixj

1
2

(cid:107)W (cid:107),(cid:107)W (cid:107), and

Proof 1 First of all, we show that the norm operators of their Jacobian matrices are
bounded.

(1) Layer with sigmoid activation s(q) = 1/(1 + e−q) with q = W x + b:

(2) Layer with Hyperbolic tangent activation function t(q) = 2/(1 + e−2q) − 1

with q = W x + b:

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂s(x)
∂x

=

(cid:13)
(cid:13)
(cid:13)
(cid:13)

(cid:13)
∂s(q)
(cid:13)
(cid:13)
∂q
(cid:13)
(cid:13)s(q) ◦ (1 − s(q))(cid:13)
≤ (cid:13)

∂q
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)

≤

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂s(q)
∂q

∂q
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)

(cid:13)(cid:107)W (cid:107) ≤

(cid:107)W (cid:107)

(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)
1
2

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂t(x)
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)
≤ (cid:13)

∂t(q)
∂q

(cid:13)
(cid:13)
(cid:13)
(cid:13)
∂q
(cid:13)
(cid:13)
(cid:13)
(cid:13)
=
(cid:13)
(cid:13)
(cid:13)
(cid:13)
∂x
(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13)1 − t(q) ◦ t(q))(cid:13)
(cid:13)(cid:107)W (cid:107) ≤ (cid:107)W (cid:107)

∂t(q)
∂q

∂q
∂x

(cid:13)
(cid:13)
(cid:13)
(cid:13)

(cid:13)
(cid:13)
(cid:13)
(cid:13)

≤

(3) Layer with softmax function p(x)j = exj /((cid:80)n

k=1 exk ) for j = 1, ..., m and

n = m (dimensions of input and output of softmax are the same):

(cid:13)
(cid:13)
(cid:13)
(cid:13)

∂p(x)j
∂xi

(cid:13)
(cid:13)
(cid:13)
(cid:13)

=

(cid:26) xi(1 − xj), i = j
−xixj, i (cid:54)= j

((cid:107)xi(cid:107) +(cid:13)

(cid:13)xixj

(cid:13)
(cid:13))

≤ sup
i,j

Since the softmax layer is the last layer of a deep neural network, we can estimate
its supremum based on Lipschitz constants of previous layers and box constraints of
DNN’s input.

The ﬁnal conclusion follows by Lemma 1 and the fact that all the layer functions

are bounded on their Jacobian matrix.

4 Problem Formulation

Let o : [0, 1]m → R be a Lipschitz continuous function statistically evaluating the out-
puts of the network. Our problem is to ﬁnd its upper and lower bounds given the set X (cid:48)
of inputs to the network. Because both the network f and the function o are Lipschitz
continuous, all values between the upper and lower bounds have a corresponding input,
i.e., are reachable.

4

(2)

(3)

(4)

Deﬁnition 2 (Reachability of Neural Network) Let X (cid:48) ⊆ [0, 1]n be an input sub-
space and f : Rn → Rm a network. The reachability of f over the function o under
an error tolerance (cid:15) ≥ 0 is a set R(o, X (cid:48), (cid:15)) = [l, u] such that

(5)

(6)

l ≥ inf

x(cid:48)∈X (cid:48)

o(f (x(cid:48))) − (cid:15) and u ≤ sup
x(cid:48)∈X (cid:48)

o(f (x(cid:48))) + (cid:15).

We write u(o, X (cid:48), (cid:15)) = u and l(o, X (cid:48), (cid:15)) = l for the upper and lower bound, respec-
tively. Then the reachability diameter is

D(o, X (cid:48), (cid:15)) = u(o, X (cid:48), (cid:15)) − l(o, X (cid:48), (cid:15)).

Assuming these notations, we may write D(o, X (cid:48), (cid:15); f ) if we need to explicitly refer to
the network f .

In the following, we instantiate o with a few concrete functions, and show that
several key veriﬁcation problems for DNNs can be reduced to our reachability problem.

Deﬁnition 3 (Output Range Analysis) Given a class label j ∈ [1, .., m], we let o =
Πj such that Πj((c1, ..., cm)) = cj.

We write cj(x) = Πj(f (x)) for the network’s conﬁdence in classifying x as label j.
Intuitively, output range [10] quantiﬁes how a certain output of a deep neural network
(i.e., classiﬁcation probability of a certain label j) varies in response to a set of DNN
inputs with an error tolerance (cid:15). Output range analysis can be easily generalised to logit
2 range analysis.

We show that the safety veriﬁcation problem [6] can be reduced to solving the

reachability problem.

Deﬁnition 4 (Safety) A network f is safe with respect to an input x and an input
subspace X (cid:48) ⊆ [0, 1]n with x ∈ X (cid:48), written as S(f, x, X (cid:48)), if

∀x(cid:48) ∈ X (cid:48) : arg max

cj(x(cid:48)) = arg max

cj(x)

j

j

(7)

We have the following reduction theorem.

Theorem 2 A network f is safe with respect to x and X (cid:48) s.t. x ∈ X (cid:48) if and only if
u(⊕, X (cid:48), (cid:15)) ≤ 0, where ⊕(c1, ..., cm) = maxi∈{1..m}(Πi(c1, ..., cm)−Πj(c1, ..., cm))
and j = arg maxj cj(x). The error bound of the safety decision problem by this
reduction is 2(cid:15).

It is not hard to see that the adversarial example generation [4], which is to ﬁnd an
input x(cid:48) ∈ X (cid:48) such that arg maxj cj(x(cid:48)) (cid:54)= arg maxj cj(x), is the dual problem of the
safety problem.

The following two problems deﬁne the robustness comparisons between the net-

works and/or the inputs.

in, e.g., [22, 10].

2Logit output is the output of the layer before the softmax layer. The study of logit outputs is conducted

5

Deﬁnition 5 (Robustness) Given two homogeneous3 networks f and g, we say that f
is strictly more robust than g with respect to a function o, an input subspace X (cid:48) and an
error bound (cid:15), written as Ro,X (cid:48),(cid:15)(f, g), if D(o, X (cid:48), (cid:15); f ) < D(o, X (cid:48), (cid:15); g).

Deﬁnition 6 Given two input subspaces X (cid:48) and X (cid:48)(cid:48) and a network f , we say that f
is more robust on X (cid:48) than on X (cid:48)(cid:48) with respect to a statistical function o and an error
bound (cid:15), written as Rf,o,(cid:15)(X (cid:48), X (cid:48)(cid:48)), if D(o, X (cid:48), (cid:15)) < D(o, X (cid:48)(cid:48), (cid:15)).

Thus, by instantiating the function o, we can quantify the output/logit range of
a network, evaluate whether a network is safe, and compare the robustness of two
homogeneous networks or two input subspaces for a given network.

5 Conﬁdence Reachability with Guarantees

Section 3 shows that a trained deep neural network is Lipschitz continuous regardless
of its layer depth, activation functions and number of neurons. Now, to solve the reach-
ability problem, we need to ﬁnd the global minimum and maximum values given an
input subspace, assuming that we have a Lipschitz constant K for the function o·f . In
the following, we let w = o·f be the concatenated function. Without loss of general-
ity, we assume the input space X (cid:48) is a box-constraint, which is clearly feasible since
images are usually normalized into [0, 1]n before being fed into a neural network.

The computation of the minimum value is reduced to solving the following opti-
mization problem with guaranteed convergence to the global minimum (the maximiza-
tion problem can be transferred into a minimization problem):

min
x

w(x), s.t. x ∈ [a, b]n

(8)

However, the above problem is very difﬁcult since w(x) is a highly non-convex func-
tion which cannot be guaranteed to reach the global minimum by regular optimization
schemes based on gradient descent. Inspired by an idea from optimisation, see e.g.,
[24, 25], we design another continuous function h(x, y), which serves as a lower bound
of the original function w(x). Speciﬁcally, we need

∀x, y ∈ [a, b]n, h(x, y) ≤ w(x) and h(x, x) = w(x)

(9)

Furthermore, for i ≥ 0, we let Yi = {y0, y1, ..., yi} be a ﬁnite set containing i + 1
points from the input space [a, b]n, and let Yi ⊆ Yk when k > i, then we can deﬁne a
function H(x; Yi) = maxy∈Yi h(x, y) which satisﬁes the following relation:

H(x; Yi) < H(x; Yk) ≤ w(x), ∀i < k

We use li = inf x∈[a,b]n H(x; Yi) to denote the minimum value of H(x; Yi) for

x ∈ [a, b]n. Then we have

(10)

(11)

l0 < l1 < ... < li−1 < li ≤ inf

w(x)

x∈[a,b]n

3 Here, two networks are homogeneous if they are applied on the same classiﬁcation task but may have

different network architectures (layer numbers, layer types, etc) and/or parameters.

6

Figure 1: A lower-bound function designed via Lipschitz constant

Similarly, we need a sequence of upper bounds ui to have

l0 < ... < li ≤ inf

w(x) ≤ ui < ... < u0

x∈[a,b]n

By Expression (12), we can have the following:

lim
i→∞

li = min

x∈[a,b]n

w(x) and lim
i→∞

(ui − li) = 0

(12)

(13)

Therefore, we can asymptotically approach the global minimum. Practically, we
execute a ﬁnite number of iterations by using an error tolerance (cid:15) to control the ter-
mination. In next sections, we present our approach, which constructs a sequence of
lower and upper bounds, and show that it can converge with an error bound. To han-
dle the high-dimensionality of DNNs, our approach is inspired by the idea of adaptive
nested optimisation in [16], with signiﬁcant differences in the detailed algorithm and
convergence proof.

5.1 One-dimensional Case

We ﬁrst introduce an algorithm which works over one dimension of the input, and
therefore is able to handle the case of x ∈ [a, b] in Eqn. (8). The multi-dimensional op-
timisation algorithm will be discussed in Section 5.2 by utilising the one-dimensional
algorithm.

We deﬁne the following lower-bound function.

h(x, y) = w(y) − K|x − y|

H(x; Yi) = max
y∈Yi

w(y) − K|x − y|

(14)

where K > Kbest is a Lipschitz constant of w and H(x; Yi) intuitively represents the
lower-bound sawtooth function shown as Figure 1. The set of points Yi is constructed

7

recursively. Assuming that, after (i−1)-th iteration, we have Yi−1 = {y0, y1, .., yi−1},
whose elements are in ascending order, and sets

w(Yi−1) = {w(y0), w(y1), .., w(yi−1)}

Li−1 = {l0, l1, ..., li−1}

Ui−1 = {u0, u1, ..., ui−1}

Zi−1 = {z1, ..., zi−1}

The elements in sets w(Yi−1), Li−1 and Ui−1 have been deﬁned earlier. The set Zi−1
records the smallest values zk computed in an interval [yk−1, yk].

In i-th iteration, we do the following sequentially:

• Compute yi = arg inf x∈[a,b] H(x; Yi−1) as follows. Let z∗ = min Zi−1 and k

be the index of the interval [yk−1, yk] where z∗ is computed. Then we let

yi =

yk−1 + yk
2

−

w(yk) − w(yk−1)
2K

• Let Yi = Yi−1 ∪ {yi}, then reorder Yi in ascending order, and update w(Yi) =

and have that yi ∈ (yk−1, yk).

w(Yi−1) ∪ {w(yi)}.

• Calculate

zi−1 =

w(yi) + w(yk−1)
2

−

K(yi − yk−1)
2

zi =

w(yk) + w(yi)
2

−

K(yk − yi)
2

(15)

(16)

(17)

and update Zi = (Zi−1 \ {z∗}) ∪ {zi−1, zi}.

• Calculate the new lower bound li = inf x∈[a,b] H(x; Yi) by letting li = min Zi,

and updating Li = Li−1 ∪ {li}.

• Calculate the new upper bound ui = miny∈Yi w(y) by letting ui = min{ui−1, w(yi)}.

We terminate the iteration whenever |ui −li| ≤ (cid:15), and let the global minimum value

be y∗ = minx∈[a,b] H(x; Yi) and the minimum objective function be w∗ = w(y∗).

Intuitively, as shown in Fig. 1, we iteratively generate lower bounds (by selecting in
each iteration the lowest point in the saw-tooth function in the ﬁgure) by continuously
reﬁning a piecewise-linear lower bound function, which is guaranteed to below the
original function due to Lipschitz continuity. The upper bound is the lowest evaluation
value of the original function so far.

8

5.1.1 Convergence Analysis

In the following, we show the convergence of this algorithm to the global minimum by
proving the following conditions.

• Convergence Condition 1: lim
i→∞

li = min
x∈[a,b]

w(x)

• Convergence Condition 2: limi→∞(ui − li) = 0

Proof 2 (Monotonicity of Lower/Upper Bound Sequences) First, we prove that the
lower bound sequence Li is strictly monotonic. Because

li = min Zi = min{(Zi−1 \ {z∗}) ∪ {zi−1, zi}}

(18)

and li−1 = min Zi. To show that li > li−1, we need to prove zi−1 > z∗ and zi > z∗.
By the algorithm, z∗ is computed from interval [yk−1, yk], so we have

We then have

z∗ =

w(yk) + w(yk−1)
2

−

K(yk − yk−1)
2

zi−1 − z∗ =

w(yi) − w(yk) − K(yi − yk)
2

(19)

(20)

Since yi < yk and K > Kbest, by Lipschitz continuity we have zi−1 > z∗. Similarly,
we can prove zi > z∗. Thus li > li−1 is guaranteed.

Second, the monotonicity of upper bounds ui can be seen from the algorithm, since

ui is updated to min{ui, w(yi)} in every iteration.

Proof 3 (Convergence Condition 1)
Since Yi−1 ⊆ Yi, we have H(x; Yi−1) ≤ H(x; Yi). Based on Proof 2, we also have
li−1 < li. Then since

li = inf

x∈[a,b]

H(x; Yi) ≤ min
x∈[a,b]

w(x)

(21)

the lower bound sequence {l0, l1, ..., li} is strictly monotonically increasing and bounded
from above by minx∈[a,b] w(x). Thus limi→∞ li = minx∈[a,b] w(x) holds.

Proof 4 (Convergence Condition 2)
Since limi→∞ li = minx∈[a,b] w(x), we show limi→∞(ui − li) = 0 by showing that
limi→∞ ui = minx∈[a,b] w(x). Since Yi = Yi−1 ∪ {yi} and yi ∈ X = [a, b], we have
limi→∞ Yi = X. Then we have limi→∞ ui = limi→∞ inf y∈Yi w(y) = inf w(X).
Since X = [a, b] is a closed interval, we can prove limi→∞ ui = inf w(X) =
minx∈[a,b] w(x).

9

5.1.2 Dynamically Improving the Lipschitz Constant

A Lipschitz constant closer to Kbest can greatly improve the speed of convergence
of the algorithm. We design a practical approach to dynamically update the current
Lipschitz constant according to the information obtained from the previous iteration:
(cid:12)
(cid:12)
(cid:12)
(cid:12)
j=1,...,i−1
(cid:12)
where η > 1. We emphasise that, because

w(yj) − w(yj−1)
yj − yj−1

K = η max

(22)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

lim
i→∞

max
j=1,...,i−1

η

w(yj) − w(yj−1)
yj − yj−1

= η sup
y∈[a,b]

dw
dy

> Kbest

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

this dynamic update does not compromise the convergence.

5.2 Multi-dimensional Case

The basic idea is to decompose a multi-dimensional optimization problem into a se-
quence of nested one-dimensional subproblems. Then the minima of those one-dimensional
minimization subproblems are back-propagated into the original dimension and the ﬁ-
nal global minimum is obtained.

min
x∈[ai,bi]n

w(x) = min

... min

w(x1, ..., xn)

x1∈[a1,b1]

xn∈[an,bn]

(23)

We ﬁrst introduce the deﬁnition of k-th level subproblem.

Deﬁnition 7 The k-th level optimization subproblem, written as φk(x1, ..., xk), is de-
ﬁned as follows: for 1 ≤ k ≤ n − 1,

φk(x1, ..., xk) =

min
xk+1∈[ak+1,bk+1]

φk+1(x1, ..., xk, xk+1)

and for k = n,

φn(x1, ..., xn) = w(x1, x2, ..., xn).

Combining Expression (23) and Deﬁnition 7, we have that

min
x∈[ai,bi]n

w(x) = min

φ1(x1)

x1∈[a1,b1]

which is actually a one-dimensional optimization problem and therefore can be solved
by the method in Section 5.1.

However, when evaluating the objective function φ1(x1) at x1 = a1, we need to

project a1 into the next one-dimensional subproblem

min
x2∈[a2,b2]

φ2(a1, x2)

We recursively perform the projection until we reach the n-th level one-dimensional
subproblem,

min
xn∈[an,bn]

φn(a1, a2, ..., an−1, xn)

Once solved, we back-propagate objective function values to the ﬁrst-level φ1(a1) and
continue searching from this level until the error bound is reached.

10

5.2.1 Convergence Analysis

We use mathematical induction to prove convergence for the multi-dimension case.

• Base case: for all x ∈ R, limi→∞ li = inf x∈[a,b] w(x) and limi→∞(ui − li) = 0

hold.

• Inductive step: if, for all x ∈ Rk, limi→∞ li = inf x∈[a,b]k w(x) and limi→∞(ui−
li) = 0 are satisﬁed, then, for all x ∈ Rk+1, limi→∞ li = inf x∈[a,b]k+1 w(x) and
limi→∞(ui − li) = 0 hold.

The base case (i.e., one-dimensional case) is already proved in Section 5.1. Now we
prove the inductive step.

Proof 5 By the nested optimization scheme, we have

min
x∈[ai,bi]k+1

w(x) = min
x∈[a,b]

Φ(x)

Φ(x) = min

w(x, y)

y∈[ai,bi]k
Since miny∈[ai,bi]k w(x, y) is bounded by an interval error (cid:15)y, assuming Φ∗(x) is the
accurate global minimum, then we have

Φ∗(x) − (cid:15)y ≤ Φ(x) ≤ Φ∗(x) + (cid:15)y

So the k+1-dimensional problem is reduced to the one-dimensional problem minx∈[a,b] Φ(x).
The difference from the real one-dimensional case is that evaluation of Φ(x) is not ac-
curate but bounded by |Φ(x) − Φ∗(x)| ≤ (cid:15)y, ∀x ∈ [a, b], where Φ∗(x) is the accurate
function evaluation.

Assuming that the minimal value obtained from our method is Φ∗

min = minx∈[a,b] Φ∗(x)

0, ..., l∗

0, ..., u∗

i } and {u∗

under accurate function evaluation, then the corresponding lower and upper bound se-
quences are {l∗

i }, respectively.
For the inaccurate evaluation case, we assume Φmin = minx∈[a,b] Φ(x), and its
lower and bound sequences are, respectively, {l0, ..., li} and {u0, ..., ui}. The ter-
mination criteria for both cases are |u∗
i | ≤ (cid:15)x and |ui − li| ≤ (cid:15)x, and φ∗
i − l∗
represents the ideal global minimum. Then we have φ∗ − (cid:15)x ≤ li. Assuming that
l∗
i ∈ [xk, xk+1] and xk, xk+1 are adjacent evaluation points, then due to the fact that
l∗
i = inf x∈[a,b] H(x; Yi) we have

φ∗ − (cid:15)x ≤ l∗

i =

Φ∗(xk) + Φ∗(xk+1)
2

−

L(xk+1 − xk)
2

Since |Φ(xi) − Φ∗(xi)| ≤ (cid:15)y, ∀i = k, k + 1, we thus have

φ∗ − (cid:15)x ≤

Φ(xk) + Φ(xk+1)
2

+ (cid:15)y −

L(xk+1 − xk)
2

Based on the search scheme, we know that

li =

Φ(xk) + Φ(xk+1)
2

−

L(xk+1 − xk)
2

(24)

11

and thus we have φ∗ − li ≤ (cid:15)y + (cid:15)x.

Similarly, we can get

φ∗ + (cid:15)x ≥ u∗

i = inf
y∈Yi

Φ∗(y) ≥ ui − (cid:15)y

(25)

so ui − φ∗ ≤ (cid:15)x + (cid:15)y. By φ∗ − li ≤ (cid:15)y + (cid:15)x and the termination criteria ui − li ≤ (cid:15)x,
we have li − (cid:15)y ≤ φ∗ ≤ ui + (cid:15)y, i.e., the accurate global minimum is also bounded.

The proof indicates that the overall error bound of the nested scheme only increases
linearly w.r.t. the bounds in the one-dimensional case. Moreover, an adaptive approach
can be applied to optimise its performance without compromising convergence. The
key observation is to relax the strict subordination inherent in the nested scheme and
simultaneously consider all the univariate subproblems arising in the course of multidi-
mensional optimization. For all the generated subproblems that are active, a numerical
measure is applied. Then an iteration of the multidimensional optimization consists
in choosing the subproblem with maximal measurement and carrying out a new trial
within this subproblem. The measure is deﬁned to be the maximal interval characteris-
tics generated by the one-dimensional optimisation algorithm.

6 Proof of NP-completeness

In this section, we prove the NP-completeness of our generic reachability problem.

6.1 Upper Bound

First of all, we show that the one-dimension optimisation case is linear with respect to
the error bound (cid:15). As shown in Figure 1, we have that

w(yk−1) − z∗ = K(yi − yk−1)
w(yk) − z∗ = K(yk − yi)

w(yk) − w(yk−1) = K(yk − yi) − K(yi − yk−1)

So we have

Moreover, we have

w(yk) + w(yi) − K(yk − yi) −

w(yk) + w(yk−1)
2

+

K(yk − yk−1)
2

= w(yi)

Based on Equation (17) and (19), we have

2zi − z∗ = w(yi)

12

Therefore, we have zi − z∗ =
z∗ ≤ l∗, and u∗ − l∗ > (cid:15) before convergence, we have

w(yi) − z∗
2

. Now, since we have that w(yi) ≥ u∗ and

zi − z∗ >

1
2

(cid:15)

Therefore, the improvement for each iteration is of linear with respect to the error
bound (cid:15), which means that the optimisation procedure will converge in linear time with
respect to the size of region [a, b].

For the multiple dimensional case, we notice that, in Equation (23), to reach the
global optimum, not all the dimensions xi for i ∈ [1..n] need to be changed and the
ordering between dimensions matter. Therefore, we can have a non-deterministic al-
gorithm which guesses a subset of dimensions together with their ordering. These are
dimensions that need to be changed to lead from the original input to the global opti-
mum. This guess can be done in polynomial time.

Then, we can apply the one-dimensional optimisation algorithm backward from the
last dimension to the ﬁrst dimension. Because of the polynomial time convergence of
the one-dimensional case, this procedure can be completed in polynomial time.

Therefore, the entire procedure can be completed in polynomial time with a non-

deterministic algorithm, i.e., in NP.

6.2 Lower Bound

We have a reduction from the 3-SAT problem, which is known to be NP-complete. A
3-SAT Boolean formula ϕ is of the form c1 ∧ ... ∧ cm, where each clause ci is of the
form li1 ∨ li2 ∨ li3. Each literal lij, for 1 ≤ i ≤ m and 1 ≤ j ≤ 3, is a variable
v or its negation ¬v, such that v ∈ {v1, ..., vn}. The 3-SAT problem is to decide the
existence of a truth-value assignment to the boolean variables V = {v1, ..., vn} such
that the formula ϕ is True.

6.2.1 Construction of DNN

We let varij ∈ V and sgnij ∈ {p, n} be the variable and the sign of the literal lij,
respectively. Given a formula ϕ, we construct a DNN f which implements a classiﬁ-
cation problem. The DNN has four layers {Li}i∈[1..4], within which L2, L3 are hidden
layers, L1 is the input layer, and L4 is the output layer. It has n input neurons and m
output neurons.

Input Layer The input layer L1 has n neurons, each of which represents a variable
in V .

First Hidden Layer – Fully Connected with ReLU The hidden layer L2 has 2n
neurons, such that every two neurons correspond to a variable in V . Given a variable
vi, we write pvi and nvi to denote the two neurons for vi such that

pvi = ReLU (vi)
nvi = ReLU (−1 ∗ vi)

13

(26)

It is noted that, the above functions can be implemented as a fully connected function,
by letting the coefﬁcients from variables other than vi be 0.

Second Hidden Layer – Fully Connected with ReLU The hidden layer L3 has m
neurons, each of which represents a clause. Let cvi be the neuron representing the
clause ci. Then for a clause ci = li1 ∨ li2 ∨ li3, we have

cvi = ReLU (xvi1 + xvi2 + xvi3)

(27)

where for k ∈ {1, 2, 3}, we have

xvik =

(cid:26) nvj
pvj

if sgnik = n and varik = vj for some j
if sgnik = p and varik = vj for some j

Intuitively, cvi takes either a positive value or zero. For the latter case, none of the
three literals are satisﬁed.

Output Layer – Fully Connected Without ReLU The output layer L4 has m neu-
rons, each of which represents a clause. Let ncvi be the neuron representing the clause
ci. Then we have

ncvi = −1 ∗ cvi

(28)

Intuitively, this layer simply negates all the values from the previous layer.

6.2.2 Statistical Evaluation Function o

After the output, we let o be the following function

ov = max{ncvi | i ∈ [1..m]}

(29)

That is, o gets the maximal value of all the outputs. Because cvi ≥ 0 and ncvi ≤ 0, we
have that ov ≤ 0.

6.2.3 Reduction

First, we show that for any point x ∈ Rn, there exists a point x0 ∈ {−1, 1}n such that,
w(x) (cid:54)= 0 if and only if w(x0) (cid:54)= 0. Recall that w is a concatenation of the network f
with o, i.e., w = o · f . For any input dimension i ∈ [1..n], we let

x0(i) =

(cid:26) 1
−1

if x(i) ≥ 0
if x(i) < 0

Therefore, by construction, we have that cvi = 0 if and only if cv0
i = 0. After passing
through L4 and the function o, we have that ov = 0 if and only ov0 = 0. This is
equivalent to w(x) (cid:54)= 0 if and only if w(x0) (cid:54)= 0.

Then, for every truth-assignment a : V → {T rue, F alse}, we associate with
it a point x ∈ {−1, 1}n by letting x(i) = 1 if a(i) = T rue and x(i) = −1 if
a(i) = F alse.

14

Figure 2: Comparison with SHERLOCK and Reluplex

Finally, we show that the formula ϕ is satisﬁable if and only if the function w = o·f

cannot reach value 0. This is done by only considering those points in {−1, 1}n.

(⇒) If ϕ is satisﬁable then by construction, in the second hidden layer, cvi > 0
for all i ∈ [1..m]. Therefore, in the output layer, we have ncvi < 0 for all i ∈ [1..m].
Finally, with the function o, we have ov < 0, i.e., the function w cannot reach value 0.
(⇐) We prove by contradiction. If ϕ is unsatisﬁable, then there must exist a clause
which is unsatisﬁable. Then by construction, we have cvi = 0 for some i ∈ [1..m].
This results in ncvi = 0 and ov = 0, which contradicts with the hypothesis that w
cannot reach 0.

Figure 3: The four features and the architecture of DNN-1 and DNN-7

7 Experiments

7.1 Comparison with State-of-the-art Methods

Two methods are chosen as baseline methods in this paper:

• Reluplex [7]: an SMT-based method for solving queries on DNNs with ReLU

15

Figure 4: Left: boxplots of conﬁdence reachability diameters for 7 DNNs, based on 4 × 20
analyses of each DNN. Right: boxplot of conﬁdence reachability diameters for 4 features, based
on 7 × 20 analyses of each feature. The red line represents the median value: a lower value
indicates a more robust model or feature.

activations; we apply a bisection scheme to compute an interval until an error is
reached

• SHERLOCK [10]: a MILP-based method dedicated to output range analysis on

DNNs with ReLU activations.

Our software is implemented in Matlab 2018a, running on a notebook computer
with i7-7700HQ CPU and 16GB RAM. Since Reluplex and SHERLOCK (not open-
sourced) are designed on different software platforms, we take their experimental re-
sults from [10], whose experimental environment is a Linux workstation with 63GB
RAM and 23-Cores CPU (more powerful than ours) and (cid:15) = 0.01. Following the
experimental setup in [10], we use their data (2-input and 1-output functions) to train
six neural networks with various numbers and types of layers and neurons. The input
subspace is X (cid:48) = [0, 10]2.

The comparison results are given in Fig. 2. They show that, while the performance
of both Reluplex and SHERLOCK is considerably affected by the increase in the num-
ber of neurons and layers, our method is not. For the six benchmark neural networks,
our average computation time is around 5s, 36 fold improvement over SHERLOCK
and nearly 100 fold improvement over Reluplex (excluding timeouts). We note that
our method is running on a notebook PC, which is signiﬁcantly less powerful than the
23-core CPU stations used for SHERLOCK and Reluplex.

7.2 Safety and Robustness Veriﬁcation by Reachability Analysis

We use our tool to conduct logit and output range analysis. Seven convolutional neural
networks, represented as DNN-1,...,DNN-7, were trained on the MNIST dataset. Im-
ages are resized into 14 × 14 to enforce that a DNN with deeper layers tends to over-ﬁt.
The networks have different layer types, including ReLu, dropout and normalization,
and the number of layers ranges from 5 to 19. Testing accuracies range from 95% to
99%, and (cid:15) = 0.05 is used in our experiments.

16

Figure 5: Left: an original image (logit is 11.806, conﬁdence of output being ‘0’ is 99.95%),
where area marked by dashed line is the feature. Middle: an image on the conﬁdence lower
bound. Right: an image on the conﬁdence upper bound; for the output label ‘0’, the feature’s
output range is [74.36%, 99.98%], and logit reachability is [7.007, 13.403]

We randomly choose 20 images (2 images per label) and manually choose 4 fea-
tures such that each feature contains 8 pixels, i.e., X (cid:48) = [0, 1]8. Fig. 3 illustrates the
four features and the architecture of two DNNs with the shallowest and deepest layers,
i.e., DNN-1 and DNN-7.

Safety Veriﬁcation Fig. 5 shows an example: for DNN-1, Feature-4 is guaranteed to
be safe with respect to the image x and the input subspace X (cid:48). Speciﬁcally, the reach-
ability interval is R(Π0, X (cid:48), (cid:15)) = [74.36%, 99.98%], which means that l(Π0, X (cid:48), (cid:15)) =
74.36%. By this, we have u(⊕−0, X (cid:48), (cid:15)) ≤ (1 − 0.7436) < 0.7436 = l(Π0, X (cid:48), (cid:15)).
Then, by Theorem 2, we have S(DNN-1, x, X (cid:48)). Intuitively, no matter how we manip-
ulate this feature, the worst case is to reduce the conﬁdence of output being ‘0’ from
99.95% (its original conﬁdence probability) to 74.36%.

Statistical Comparison of Safety Fig. 6 compares the ratios of safe images for dif-
ferent DNNs and features. It shows that: i) no DNN is 100% safe on those features:
DNN-6 is the safest one and DNN-1, DNN-2 and DNN-3 are less safe, which means a
DNN with well chosen layers are safer than those DNNs with very shallow or deeper
layers; and ii) the safety performance of different DNNs is consistent for the same fea-
ture, which suggests that the feature matters – some features are easily perturbed to
yield adversarial examples, e.g., Feature-1 and Feature-2.
Statistical Comparison of Robustness Fig. 4 compares the robustness of networks
and features with two boxplots over the reachability diameters, where the function o is
Πj for a suitable j. We can see that DNN-6 and DNN-5 are the two most robust, while
DNN-1, DNN-2 and DNN-3 are less robust. Moreover, Feature-1 and Feature-2 are
less robust than Feature-3 and Feature-4.

We have thus demonstrated that reachability analysis with our tool can be used
to quantify the safety and robustness of deep learning models. In the following, we
perform a comparison of networks over a ﬁxed feature.

Safety Comparison of Networks By Fig. 7, DNN-4 and DNN-6 are guaranteed to
be safe w.r.t. the subspace deﬁned by Feature-3. Moreover, the output range of DNN-
7 is [1.8%, 100.0%], which means that we can generate adversarial images by only

17

Figure 6: Ratios of safe images for 7 DNNs and 4 features

perturbing this feature, among which the worst one is as shown in the ﬁgure with a
conﬁdence 1.8%. Thus, reachability analysis not only enables qualitative safety ver-
iﬁcation (i.e., safe or not safe), but also allows benchmarking of safety of different
deep learning models in a principled, quantitive manner (i.e., how safe) by quantify-
ing the ‘worst’ adversarial example. Moreover, compared to retraining the model with
‘regular’ adversarial images, these ‘worst’ adversarial images are more effective in im-
proving the robustness of DNNs [27].

Robustness Comparison of Networks The bar chart in Fig. 7 shows the reachability
diameters of the networks over Feature-3, where the function o is Πj. DNN-4 is the
most robust one, and its output range is [94.2%, 100%].

7.3 A Comprehensive Comparison with the State-of-the-arts

This section presents a comprehensive, high-level comparison of our method with sev-
eral existing approaches that have been used for either range analysis or veriﬁcation
of DNNs, including SHERLOCK [10], Reluplex [7], Planet [26], MIP [11, 9] and
BaB [12], as shown in Fig. 8. We investigate these approaches from the following
seven aspects:

1. core techniques,

2. workable layer types,

3. running time on ACAS Xu,

4. computational complexity,

18

Figure 7: A detailed example comparing the safety and robustness of DNNs for image ’9’ and
Feature-3: the top number in the caption of each ﬁgure is logit and the bottom one is conﬁdence;
the unsafe cases are all misclassiﬁed as ‘8’; the last bar chart shows their conﬁdence reachability
diameters.

5. applicable to state-of-the-art networks,

6. input constraints, and

7. maximum number of layers in tested DNNs.

We are incomparable to approaches based on exhaustive search (such as DLV [6] and
SafeCV [15]) because we have a different way of expressing guarantees.

Core Techniques Most existing approaches (SHERLOCK, Reluplex, Planet, MIP) are
based on reduction to constraint solving, except for BaB which mixes constraint solv-
ing with local search. On the other hand, our method is based on global optimization
and assumes Lipschitz continuity of the networks. As indicated in Section 3, all known
layers used in classiﬁcation tasks are Lipschitz continuous.

Workable Layer Types While we are able to work with all known layers used in
classiﬁcation tasks because they are Lipschitz continuous (proved in Section 3 of the
paper), Planet, MIP and BaB can only work with Relu and Maxpooling, and SHER-
LOCK and Reluplex can only work with Relu.

Running Time on ACAS-Xu Network We collect running time data from [12] on
the ACAS-Xu network, and ﬁnd that our approach has similar performance to BaB,
and better than the others. No experiments for SHERLOCK are available. We reiterate
that, compared to their experimental platform (Desktop PC with i7-5930K CPU, 32GB

19

RAM), ours is less powerful (Laptop PC with i7-7700HQ CPU, 16GB RAM). We em-
phasise that, although our approach performs well on this network, the actual strength
of our approach is not the running time on small networks such as ACAS-Xu, but the
ability to work with large-scale networks (such as those shown in Section 6.2).

Computational Complexity While all the mentioned approaches are in the same com-
plexity class, NP, the complexity of our method is with respect to the number of input
dimensions to be changed, as opposed to the number of hidden neurons. It is known
that the number of hidden neurons is much larger than the number of input dimensions,
e.g., there are nearly 6.5 × 106 neurons in AlexNet.

Applicable to State-of-the-art Networks We are able to work with state-of-the-art
networks with millions of neurons. However, the other tools (Reluplex, Planet, MIP,
BaB) can only work with hundreds of neurons. SHERLOCK can work with thousands
of neurons thanks to its interleaving of MILP with local search.

Maximum Number of Layers in Tested DNNs We have validated our method on
networks with 19 layers, whereas the other approaches are validated on up to 6 layers.
In summary, the key advantages of our approach are as follows: i) the ability to
work with large-scale state-of-the-art networks; ii) lower computational complexity,
i.e., NP-completeness with respect to the input dimensions to be changed, instead of
the number of hidden neurons; and iii) the wide range of types of layers that can be
handled.

8 Conclusion

We propose, design and implement a reachability analysis tool for deep neural net-
works, which has provable guarantees and can be applied to neural networks with deep
layers and nonlinear activation functions. The experiments demonstrate that our tool
can be utilized to verify the safety of deep neural networks and quantitatively com-
pare their robustness. We envision that this work marks an important step towards a
practical, guaranteed safety veriﬁcation for DNNs. Future work includes parallelizing
this method in GPUs to improve its scalability on large-scale models trained on Im-
ageNet, and a generalisation to other deep learning models such as RNNs and deep
reinforcement learning.

9 Acknowledgements

WR and MK are supported by the EPSRC Programme Grant on Mobile Autonomy
(EP/M019918/1). XH acknowledges NVIDIA Corporation for its support with the
donation of the Titan Xp GPU, and is partially supported by NSFC (no. 61772232).

20

References

[1] W. Ruan, X. Huang, and M. Kwiatkowska, “Reachability analysis of deep neural
networks with provable guarantees,” The 27th International Joint Conference on
Artiﬁcial Intelligence (IJCAI), 2018.

[2] D. Amodei, C. Olah, J. Steinhardt, P. Christiano, J. Schulman, and D. Man´e,
“Concrete problems in ai safety,” arXiv preprint arXiv:1606.06565, 2016.
[Online]. Available: https://arxiv.org/pdf/1606.06565.pdf

[3] Y. Sun, M. Wu, W. Ruan, X. Huang, M. Kwiatkowska, and D. Kroening, “Con-
colic testing for deep neural networks,” arXiv preprint arXiv:1805.00089v1,
2018.

[4] C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Erhan, I. Goodfellow, and
R. Fergus, “Intriguing properties of neural networks,” arXiv:1312.6199v4, 2013.

[5] I. J. Goodfellow, J. Shlens, and C. Szegedy, “Explaining and Harnessing Adver-

sarial Examples,” ArXiv e-prints, Dec. 2014.

[6] X. Huang, M. Kwiatkowska, S. Wang, and M. Wu, “Safety veriﬁcation of deep
neural networks,” in Computer Aided Veriﬁcation. Springer Berlin Heidelberg,
2017, pp. 3–29.

[7] G. Katz, C. Barrett, D. Dill, K. Julian, and M. Kochenderfer, “Reluplex:
An efﬁcient smt solver for verifying deep neural networks,” arXiv preprint
arXiv:1702.01135, 2017.

[8] W. Ruan, M. Wu, Y. Sun, X. Huang, D. Kroening, and M. Kwiatkowska, “Global
robustness evaluation of deep neural networks with provable guarantees for L0
norm,” arXiv preprint arXiv:1804.05805v1, 2018.

[9] A. Lomuscio and L. Maganti, “An approach to reachability analysis for
feed-forward relu neural networks,” CoRR, vol. abs/1706.07351, 2017. [Online].
Available: http://arxiv.org/abs/1706.07351

[10] S. Dutta, S. Jha, S. Sanakaranarayanan, and A. Tiwari, “Output range analysis for

deep neural networks,” arXiv preprint arXiv:1709.09130, 2017.

[11] C.-H. Cheng, G. N¨uhrenberg, and H. Ruess, “Maximum resilience of artiﬁ-
cial neural networks,” in Automated Technology for Veriﬁcation and Analysis,
D. D’Souza and K. Narayan Kumar, Eds. Cham: Springer International Pub-
lishing, 2017, pp. 251–268.

[12] R. Bunel,

I. Turkaslan, P. H. Torr, P. Kohli, and M. P. Kumar, “Piece-
wise linear neural network veriﬁcation: A comparative study,” arXiv preprint
arXiv:1711.00455, 2017.

[13] W. Xiang, H.-D. Tran, and T. T. Johnson, “Output reachable set estimation and
veriﬁcation for multi-layer neural networks,” arXiv preprint arXiv:1708.03322,
2017.

21

[14] N. Narodytska, S. P. Kasiviswanathan, L. Ryzhyk, M. Sagiv, and T. Walsh,
“Verifying properties of binarized deep neural networks,” CoRR, vol.
abs/1709.06662, 2017. [Online]. Available: https://arxiv.org/abs/1709.06662

[15] M. Wicker, X. Huang, and M. Kwiatkowska, “Feature-guided black-box safety
testing of deep neural networks,” in Proc. 24th International Conference on Tools
and Algorithms for the Construction and Analysis of Systems (TACAS’18), 2018,
pp. 408–426.

[16] V. Gergel, V. Grishagin, and A. Gergel, “Adaptive nested optimization scheme for
multidimensional global search,” Journal of Global Optimization, vol. 66, no. 1,
pp. 35–51, 2016.

[17] V. Grishagin, R. Israﬁlov, and Y. Sergeyev, “Convergence conditions and numeri-
cal comparison of global optimization methods based on dimensionality reduction
schemes,” Applied Mathematics and Computation, vol. 318, pp. 270–280, 2018.

[18] L. Pulina and A. Tacchella, “An abstraction-reﬁnement approach to veriﬁcation
Springer Berlin

of artiﬁcial neural networks,” in Computer Aided Veriﬁcation.
Heidelberg, 2010, pp. 243–257.

[19] A. M. Nguyen, J. Yosinski, and J. Clune, “Deep neural networks are easily
fooled: High conﬁdence predictions for unrecognizable images,” CoRR, vol.
abs/1412.1897, 2014. [Online]. Available: http://arxiv.org/abs/1412.1897

[20] S. Moosavi-Dezfooli, A. Fawzi, O. Fawzi, and P. Frossard, “Universal adversarial
perturbations,” CoRR, vol. abs/1610.08401, 2016. [Online]. Available: http:
//arxiv.org/abs/1610.08401

[21] N. Carlini and D. A. Wagner, “Towards evaluating the robustness of
neural networks,” CoRR, vol. abs/1608.04644, 2016. [Online]. Available:
http://arxiv.org/abs/1608.04644

[22] N. Papernot, P. D. McDaniel, S. Jha, M. Fredrikson, Z. B. Celik, and
A. Swami, “The limitations of deep learning in adversarial settings,” CoRR, vol.
abs/1511.07528, 2015. [Online]. Available: http://arxiv.org/abs/1511.07528

[23] H. H. Sohrab, Basic real analysis. Springer, 2003, vol. 231.

[24] S. Piyavskii, “An algorithm for ﬁnding the absolute extremum of a function,”
USSR Computational Mathematics and Mathematical Physics, vol. 12, no. 4, pp.
57–67, 1972.

[25] A. Torn and A. Zilinskas, Global Optimization. New York, NY, USA: Springer-

Verlag New York, Inc., 1989.

[26] R. Ehlers, “Formal veriﬁcation of piece-wise linear feed-forward neural net-
works,” in International Symposium on Automated Technology for Veriﬁcation
and Analysis. Springer, 2017, pp. 269–286.

22

[27] J. Z. Kolter and E. Wong, “Provable defenses against adversarial examples via the
convex outer adversarial polytope,” arXiv preprint arXiv:1711.00851, 2017.

23

.
]
2
1
[

B
a
B
d
n
a

]
9

,

1
1
[
P
I
M

,
]
6
2
[

t
e
n
a
l
P

,
]
7
[

x
e
l
p
u
l
e
R

,
]
0
1
[

K
C
O
L
R
E
H
S

:
s
d
o
h
t
e
m

t
r
a
-
e
h
t
-
f
o
-
e
t
a
t
s

h
t
i

w
n
o
s
i
r
a
p
m
o
c

l
e
v
e
l
-
h
g
i
h
A

:
8

e
r
u
g
i
F

24

