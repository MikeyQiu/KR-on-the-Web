Averaging Weights Leads to Wider Optima and Better Generalization

9
1
0
2
 
b
e
F
 
5
2
 
 
]

G
L
.
s
c
[
 
 
3
v
7
0
4
5
0
.
3
0
8
1
:
v
i
X
r
a

Pavel Izmailov∗1 Dmitrii Podoprikhin∗2,3 Timur Garipov∗4,5 Dmitry Vetrov2,3 Andrew Gordon Wilson1
1Cornell University, 2Higher School of Economics, 3Samsung-HSE Laboratory,
4Samsung AI Center in Moscow, 5Lomonosov Moscow State University

Abstract

Deep neural networks are typically trained by
optimizing a loss function with an SGD vari-
ant, in conjunction with a decaying learning
rate, until convergence. We show that simple
averaging of multiple points along the trajec-
tory of SGD, with a cyclical or constant learn-
ing rate,
leads to better generalization than
conventional training. We also show that this
Stochastic Weight Averaging (SWA) procedure
ﬁnds much ﬂatter solutions than SGD, and ap-
proximates the recent Fast Geometric Ensem-
bling (FGE) approach with a single model.
Using SWA we achieve notable improvement
in test accuracy over conventional SGD train-
ing on a range of state-of-the-art residual net-
works, PyramidNets, DenseNets, and Shake-
Shake networks on CIFAR-10, CIFAR-100,
In short, SWA is extremely
and ImageNet.
easy to implement, improves generalization,
and has almost no computational overhead.

1

INTRODUCTION

With a better understanding of the loss surfaces for mul-
tilayer networks, we can accelerate the convergence, sta-
bility, and accuracy of training procedures in deep learn-
ing. Recent work [Garipov et al., 2018, Draxler et al.,
2018] shows that local optima found by SGD can be con-
nected by simple curves of near constant loss. Building
upon this insight, Garipov et al. [2018] also developed
Fast Geometric Ensembling (FGE) to sample multiple
nearby points in weight space to create high performing
ensembles in the time required to train a single DNN.

FGE uses a high frequency cyclical learning rate with
SGD to select networks to ensemble. In Figure 1 (left)

∗Equal contribution.

we see that the weights of the networks ensembled by
FGE are on the periphery of the most desirable solu-
tions. This observation suggests it is promising to aver-
age these points in weight space, and use a network with
these averaged weights, instead of forming an ensemble
by averaging the outputs of networks in model space. Al-
though the general idea of maintaining a running aver-
age of weights traversed by SGD dates back to Ruppert
[1988], this procedure is not typically used to train neural
networks. It is sometimes applied as an exponentially de-
caying running average in combination with a decaying
learning rate (where it is called an exponential moving
average), which smooths the trajectory of conventional
SGD but does not perform very differently. However, we
show that an equally weighted average of the points tra-
versed by SGD with a cyclical or high constant learning
rate, which we refer to as Stochastic Weight Averaging
(SWA), has many surprising and promising features for
training deep neural networks, leading to a better under-
standing of the geometry of their loss surfaces. Indeed,
SWA with cyclical or constant learning rates can be used
as a drop-in replacement for standard SGD training of
multilayer networks — but with improved generalization
and essentially no overhead. In particular:

•

•

We show that SGD with cyclical [e.g., Loshchilov
and Hutter, 2017] and constant learning rates tra-
verses regions of weight space corresponding to
high-performing networks. We ﬁnd that while these
models are moving around this optimal set they
never reach its central points. We show that we can
move into this more desirable space of points by av-
eraging the weights proposed over SGD iterations.

While FGE ensembles [Garipov et al., 2018] can
be trained in the same time as a single model, test
predictions for an ensemble of k models requires k
times more computation. We show that SWA can
be interpreted as an approximation to FGE ensem-
bles but with the test-time, convenience, and inter-

Figure 1: Illustrations of SWA and SGD with a Preactivation ResNet-164 on CIFAR-1001. Left: test error surface
for three FGE samples and the corresponding SWA solution (averaging in weight space). Middle and Right: test
error and train loss surfaces showing the weights proposed by SGD (at convergence) and SWA, starting from the same
initialization of SGD after 125 training epochs.

pretability of a single model.

•

•

•

We demonstrate that SWA leads to solutions that are
wider than the optima found by SGD. Keskar et al.
[2017] and Hochreiter and Schmidhuber [1997]
conjecture that the width of the optima is critically
related to generalization. We illustrate that the loss
on the train is shifted with respect to the test er-
ror (Figure 1, middle and right panels, and sections
3, 4). We show that SGD generally converges to
a point near the boundary of the wide ﬂat region
of optimal points. SWA on the other hand is able
to ﬁnd a point centered in this region, often with
slightly worse train loss but with substantially bet-
ter test error.

We show that the loss function is asymmetric in the
direction connecting SWA with SGD. In this direc-
tion, SGD is near the periphery of sharp ascent. Part
of the reason SWA improves generalization is that it
ﬁnds solutions in ﬂat regions of the training loss in
such directions.

In particular,

SWA achieves notable improvement for training
a broad range of architectures over several con-
running
sequential benchmarks.
SWA for just 10 epochs on ImageNet we are
able to achieve 0.8% improvement for ResNet-
50 and DenseNet-161, and 0.6% improvement for
ResNet-150. We achieve improvement of over 1.3%
on CIFAR-100 and of over 0.4% on CIFAR-10
with Preactivation ResNet-164, VGG-16 and Wide
ResNet-28-10. We also achieve substantial im-
provement for the recent Shake-Shake Networks
and PyramidNets.

•

SWA is extremely easy to implement and has vir-
tually no computational overhead compared to the
conventional training schemes.

•

We provide an implementation of SWA at
https://github.com/timgaripov/swa.

We emphasize that SWA is ﬁnding a solution in the same
basin of attraction as SGD, as can be seen in Figure 1,
but in a ﬂatter region of the training loss. SGD typically
ﬁnds points on the periphery of a set of good weights. By
running SGD with a cyclical or high constant learning
rate, we traverse the surface of this set of points, and
by averaging we ﬁnd a more centred solution in a ﬂatter
region of the training loss. Further, the training loss for
SWA is often slightly worse than for SGD suggesting that
SWA solution is not a local optimum of the loss. In the
title of this paper, optima is used in a general sense to
mean solutions (converged points of a given procedure),
rather than different local minima of the same objective.

2 RELATED WORK

This paper is fundamentally about better understanding
the geometry of loss surfaces and generalization in deep
learning. We follow the trajectory of weights traversed
by SGD, leading to new geometric insights and the in-
tuition that SWA will lead to better results than standard
training. Empirically, we make the discovery that SWA
notably improves training of many state-of-the-art deep
neural networks over a range of consequential bench-
marks, with essentially no overhead.

The procedures for training neural networks are con-
stantly being improved. New methods are being pro-
posed for architecture design, regularization and opti-
mization. The SWA approach is related to work in both
optimization and regularization.

In optimization, there is great interest in how differ-

1 Suppose we have three weight vectors w1, w2, w3. We set
u = (w2 −w1), v = (w3 −w1)−(cid:104)w3 − w1, w2 − w1(cid:105)/(cid:107)w2 −
w1(cid:107)2 · (w2 − w1). Then the normalized vectors ˆu = u/(cid:107)u(cid:107),
ˆv = v/(cid:107)v(cid:107) form an orthonormal basis in the plane contain-
ing w1, w2, w3. To visualize the loss in this plane, we deﬁne
a Cartesian grid in the basis ˆu, ˆv and evaluate the networks
corresponding to each of the points in the grid. A point P
with coordinates (x, y) in the plane would then be given by
P = w1 + x · ˆu + y · ˆv.

ent types of local solutions affect generalization in deep
learning. Keskar et al. [2017] claim that SGD is more
likely to converge to broad local optima than batch gra-
dient methods, which tend to converge to sharp optima.
Moreover, they argue that the broad optima found by
SGD are more likely to have good test performance, even
if the training loss is worse than for the sharp optima.
On the other hand Dinh et al. [2017] argue that all the
known deﬁnitions of sharpness are unsatisfactory and
cannot on their own explain generalization. Chaudhari
et al. [2017] propose the Entropy-SGD method that ex-
plicitly forces optimization towards wide valleys. They
report that although the optima found by Entropy-SGD
are wider than those found by conventional SGD, the
generalization performance is still comparable.

The SWA method is based on averaging multiple points
along the trajectory of SGD with cyclical or constant
learning rates. The general idea of maintaining a running
average of weights proposed by SGD was ﬁrst consid-
ered in convex optimization by Ruppert [1988] and later
by Polyak and Juditsky [1992]. However, this procedure
is not typically used to train neural networks. Practi-
tioners instead sometimes use an exponentially decay-
ing running average of the weights found by SGD with
a decaying learning rate, which smooths the trajectory of
SGD but performs comparably.

SWA is making use of multiple samples gathered through
exploration of the set of points corresponding to high per-
forming networks. To enforce exploration we run SGD
with constant or cyclical learning rates. Mandt et al.
[2017] show that under several simplifying assumptions
running SGD with a constant learning rate is equivalent
to sampling from a Gaussian distribution centered at the
minimum of the loss, and the covariance of this Gaussian
is controlled by the learning rate. Following this expla-
nation from [Mandt et al., 2017], we can interpret points
proposed by SGD as being constrained to the surface of
a sphere, since they come from a high dimensional Gaus-
sian distribution. SWA effectively allows us to go inside
the sphere to ﬁnd higher density solutions.

In a procedure called Fast Geometric Ensembling (FGE),
Garipov et al. [2018] showed that using a cyclical learn-
ing rate it is possible to gather models that are spatially
close to each other but produce diverse predictions. They
used the gathered models to train ensembles with no
computational overhead compared to training a single
DNN model.
In recent work Neklyudov et al. [2018]
also discuss an efﬁcient approach for model averaging
of Bayesian neural networks. SWA was inspired by fol-
lowing the trajectories of FGE proposals, in order to ﬁnd
a single model that would approximate an FGE ensem-
ble, but provide greater interpretability, convenience, and

test-time scalability.

Dropout [Srivastava et al., 2014] is an extremely popu-
lar approach to regularizing DNNs. Across each mini-
batch used for SGD, a different architecture is created
by randomly dropping out neurons. The authors make
analogies between dropout, ensembling, and Bayesian
model averaging. At test time, an ensemble approach
is proposed, but then approximated with similar results
by multiplying each connection by the dropout rate. At a
high level, SWA and Dropout are both at once regulariz-
ers and training procedures, motivated to approximate an
ensemble. Each approach implements these high level
ideas quite differently, and as we show in our experi-
ments, can be combined for improved performance.

3 STOCHASTIC WEIGHT AVERAGING

We present Stochastic Weight Averaging (SWA) and an-
alyze its properties. In section 3.1, we consider trajec-
tories of SGD with a constant and cyclical learning rate,
which helps understand the geometry of SGD training
for neural networks, and motivates the SWA procedure.
Then in section 3.2 we present the SWA algorithm in
detail, in section 3.3 we derive its complexity, and in
section 3.4 we analyze the width of solutions found by
SWA versus conventional SGD training. In section 3.5
we then examine the relationship between SWA and the
recently proposed Fast Geometric Ensembling [Garipov
et al., 2018]. Finally, in section 3.6 we consider SWA
from the perspective of stochastic convex optimization.

We note the name SWA has two meanings: on the one
hand, it is an average of SGD weights. On the other,
with a cyclical or constant learning rate, SGD proposals
are approximately sampling from the loss surface of the
DNN, leading to stochastic weights.

3.1 ANALYSIS OF SGD TRAJECTORIES

SWA is based on averaging the samples proposed by
SGD using a learning rate schedule that allows explo-
ration of the region of weight space corresponding to
high-performing networks.
In particular we consider
cyclical and constant learning rate schedules.

The cyclical learning rate schedule that we adopt is in-
spired by Garipov et al. [2018] and Smith and Topin
[2017]. In each cycle we linearly decrease the learning
rate from α1 to α2. The formula for the learning rate at
iteration i is given by

t(i))α1 + t(i)α2,

α(i) = (1
1
c

t(i) =

−
(mod(i

1, c) + 1) .

−

corresponding to DNNs with high accuracy. The main
difference between the two approaches is that the indi-
vidual proposals of SGD with a cyclical learning rate
schedule are in general much more accurate than the pro-
posals of a ﬁxed-learning rate SGD. After making a large
step, SGD with a cyclical learning rate spends several
epochs ﬁne-tuning the resulting point with a decreasing
learning rate. SGD with a ﬁxed learning rate on the other
hand is always making steps of relatively large sizes, ex-
ploring more efﬁciently than with a cyclical learning rate,
but the individual proposals are worse.

Another important insight we can get from Figure 3 is
that while the train loss and test error surfaces are quali-
tatively similar, they are not perfectly aligned. The shift
between train and test suggests that more robust central
points in the set of high-performing networks can lead to
better generalization. Indeed, if we average several pro-
posals from the optimization trajectories, we get a more
robust point that has a substantially higher test perfor-
mance than the individual proposals of SGD, and is es-
sentially centered on the shifted mode for test error. We
further discuss the reasons for this behaviour in sections
3.4, 3.5, 3.6.

3.2 SWA ALGORITHM

We now present the details of the Stochastic Weight Av-
eraging algorithm, a simple but effective modiﬁcation for
training neural networks, motivated by our observations
in section 3.1.

Following Garipov et al. [2018], we start with a pre-
trained model ˆw. We will refer to the number of epochs
required to train a given DNN with the conventional
training procedure as its training budget and will denote
it by B. The pretrained model ˆw can be trained with the
conventional training procedure for full training budget
or reduced number of epochs (e.g. 0.75B). In the lat-
ter case we just stop the training early without modify-
ing the learning rate schedule. Starting from ˆw we con-
tinue training, using a cyclical or constant learning rate
schedule. When using a cyclical learning rate we capture
the models wi that correspond to the minimum values of
the learning rate (see Figure 2), following Garipov et al.
[2018]. For constant learning rates we capture models
at each epoch. Next, we average the weights of all the
captured networks wi to get our ﬁnal model wSWA.

Note that for cyclical learning rate schedule, the SWA
algorithm is related to FGE [Garipov et al., 2018], except
that instead of averaging the predictions of the models,
we average their weights, and we use a different type of
learning rate cycle. In section 3.5 we show how SWA
can approximate FGE, but with a single model.

Figure 2: Top: cyclical learning rate as a function of
iteration. Bottom: test error as a function of iteration
for cyclical learning rate schedule with Preactivation-
ResNet-164 on CIFAR-100. Circles indicate iterations
corresponding to the minimum learning rates.

α2 and the cycle length c
The base learning rates α1
≥
are the hyper-parameters of the method. Here by itera-
tion we assume the processing of one batch of data. Fig-
ure 2 illustrates the cyclical learning rate schedule and
the test error of the corresponding points. Note that un-
like the cyclical learning rate schedule of Garipov et al.
[2018] and Smith and Topin [2017], here we propose to
use a discontinuous schedule that jumps directly from
the minimum to maximum learning rates, and does not
steadily increase the learning rate as part of the cycle.
We use this more abrupt cycle because for our purposes
exploration is more important than the accuracy of indi-
vidual proposals. For even greater exploration, we also
consider constant learning rates α(i) = α1.

We run SGD with cyclical and constant learning rate
schedules starting from a pretrained point for a Preacti-
vation ResNet-164 on CIFAR-100. We then use the ﬁrst,
middle and last point of each of the trajectories to de-
ﬁne a 2-dimensional plane in the weight space contain-
ing all afﬁne combinations of these points. In Figure 3
we plot the loss on train and error on test for points in
these planes. We then project the other points of the tra-
jectory to the plane of the plot. Note that the trajectories
do not generally lie in the plane of the plot, except for the
ﬁrst, last and middle points, showed by black crosses in
the ﬁgure. Therefore for other points of the trajectories it
is not possible to tell the value of train loss and test error
from the plots.

The key insight from Figure 3 is that both methods ex-
plore points close to the periphery of the set of high-
performing networks. The visualizations suggest that
both methods are doing exploration in the region of space

Figure 3: The L2-regularized cross-entropy train loss and test error surfaces of a Preactivation ResNet-164 on CIFAR-
100 in the plane containing the ﬁrst, middle and last points (indicated by black crosses) in the trajectories with (left
two) cyclical and (right two) constant learning rate schedules.

Algorithm 1 Stochastic Weight Averaging

Require:

weights ˆw, LR bounds α1, α2,
cycle length c (for constant learning rate c = 1), num-
ber of iterations n

Ensure: wSWA

ˆw

w
←
wSWA
for i
α
Calculate LR for the iteration
{
}
w
α
Stochastic gradient update
}
{
if mod(i, c) = 0 then

Initialize weights with ˆw
{
w
←
1, 2, . . . , n do
←
α(i)
←
w
←

i(w)

∇L

−

}

nmodels
wSWA

i/c
{
wSWA·nmodels+w
nmodels+1

Number of models
}

Update average
{

}

←
←

end if
end for
Compute BatchNorm statistics for wSWA weights
{

}

Batch normalization.
If the DNN uses batch normal-
ization [Ioffe and Szegedy, 2015], we run one additional
pass over the data, as in Garipov et al. [2018], to compute
the running mean and standard deviation of the activa-
tions for each layer of the network with wSWA weights
after the training is ﬁnished, since these statistics are
not collected during training. For most deep learning li-
braries, such as PyTorch or Tensorﬂow, one can typically
collect these statistics by making a forward pass over the
data in training mode.

The SWA procedure is summarized in Algorithm 1.

3.3 COMPUTATIONAL COMPLEXITY

The time and memory overhead of SWA compared to
conventional training is negligible. During training, we
need to maintain a copy of the running average of DNN
weights. Note however that the memory consumption
in storing a DNN is dominated by its activations rather
than its weights, and thus is only slightly increased by the
SWA procedure, even for large DNNs (e.g., on the order
of 10%). After the training is complete we only need to

store the model that aggregates the average, leading to
the same memory requirements as standard training.

During training extra time is only spent to update the ag-
gregated weight average. This operation is of the form

wSWA

wSWA

nmodels + w

·

←

nmodels + 1

,

and it only requires computing a weighted sum of the
weights of two DNNs. As we apply this operation at
most once per epoch, SWA and SGD require practically
the same amount of computation. Indeed, a similar op-
eration is performed as a part of each gradient step, and
each epoch consists of hundreds of gradient steps.

3.4 SOLUTION WIDTH

Keskar et al. [2017] and Chaudhari et al. [2017] conjec-
ture that the width of a local optimum is related to gen-
eralization. The general explanation for the importance
of width is that the surfaces of train loss and test error
are shifted with respect to each other and it is thus de-
sirable to converge to the modes of broad optima, which
stay approximately optimal under small perturbations. In
this section we compare the solutions found by SWA and
SGD and show that SWA generally leads to much wider
solutions.

Let wSWA and wSGD denote the weights of DNNs trained
using SWA and conventional SGD, respectively. Con-
sider the rays

wSWA(t, d) = wSWA + t
wSGD(t, d) = wSGD + t

d,

d,

·

·

which follow a direction vector d on the unit sphere,
starting at wSWA and wSGD, respectively.
In Figure 4
we plot train loss and test error of wSWA(t, di) and
wSGD(t, di) as a function of t for 10 random directions
di, i = 1, 2, . . . , 10 drawn from a uniform distribution
on the unit sphere. For this visualization we use a Preac-
tivation ResNet-164 on CIFAR-100.

First, while the loss values on train for wSGD and wSWA
are quite similar (and in fact wSGD has a slightly lower

Figure 4: (Left) Test error and (Right) L2-regularized cross-entropy train loss as a function of a point on a random ray
starting at SWA (blue) and SGD (green) solutions for Preactivation ResNet-164 on CIFAR-100. Each line corresponds
to a different random ray.

Figure 5: L2-regularized cross-entropy train loss and test error as a function of a point on the line connecting SWA
and SGD solutions on CIFAR-100. Left: Preactivation ResNet-164. Right: VGG-16.

train loss), the test error for wSGD is lower by 1.5% (at
the converged value corresponding to t = 0). Further,
the shapes of both train loss and test error curves are con-
siderably wider for wSWA than for wSGD, suggesting that
SWA indeed converges to a wider solution: we have to
step much further away from wSWA to increase error by a
given amount. We even see the error curve for SGD has
an inﬂection point that is not present for these distances
with SWA.

Notice that in Figure 4 any of the random directions from
wSGD increase test error. However, we know that the di-
rection from wSGD to wSWA would decrease test error,
since wSWA has considerably lower test error than wSGD.
In other words, the path from wSGD to wSWA is qualita-
tively different from all directions shown in Figure 4, be-
cause along this direction wSGD is far from optimal. We
therefore consider the line segment connecting wSGD and
wSWA:

w(t) = t

wSGD + (1

t)

wSWA .

·

−

·

In Figure 5 we plot the train loss and test error of w(t)
as a function of signed distance from wSWA for Preacti-
vation ResNet-164 and VGG-16 on CIFAR-100.

We can extract several key insights about wSWA and wSGD
from Figure 5. First, the train loss and test error plots
are indeed substantially shifted, and the point obtained
by minimizing the train loss is far from optimal on test.

Second, wSGD lies near the boundary of a wide ﬂat region
of the train loss. Further, the loss is very steep near wSGD.

Keskar et al. [2017] argue that the loss near sharp op-
tima found by SGD with very large batches are actu-
ally ﬂat in most directions, but there exist directions in
which the optima are extremely steep. They conjecture
that because of this sharpness the generalization perfor-
mance of large batch optimization is substantially worse
than that of solutions found by small batch SGD. Re-
markably, in our experiments in this section we observe
that there exist directions of steep ascent even for small
batch optima, and that SWA provides even wider solu-
tions (at least along random directions) with better gen-
eralization. Indeed, we can see clearly in Figure 5 that
SWA is not ﬁnding a different minima than SGD, but
rather a ﬂatter region in the same basin of attraction. We
can also see clearly that the signiﬁcant asymmetry of the
loss function in certain directions, such as the direction
SWA to SGD, has a role in understanding why SWA pro-
vides better generalization than SGD. In these directions
SWA ﬁnds a much ﬂatter solution than SGD, which can
be near the periphery of sharp ascent.

3.5 CONNECTION TO ENSEMBLING

Garipov et al. [2018] proposed the Fast Geometric En-
sembling (FGE) procedure for training ensembles in the

time required to train a single model. Using a cyclical
learning rate, FGE generates a sequence of points that
are close to each other in the weight space, but produce
diverse predictions. In SWA instead of averaging the pre-
dictions of the models we average their weights. How-
ever, the predictions proposed by FGE ensembles and
SWA models have similar properties.

Let f (
) denote the predictions of a neural network
·
parametrized by weights w. We will assume that f is
a scalar (e.g. the probability for a particular class) twice
continuously differentiable function with respect to w.

Consider points wi proposed by FGE. These points are
close in the weight space by design, and concentrated
around their average wSWA = 1
i=1 wi. We denote
n
∆i = wi
i=1 ∆i = 0. Ensembling the
networks corresponds to averaging the function values

wSWA. Note (cid:80)n

(cid:80)n

−

¯f =

1
n

n
(cid:88)

i=1

f (wi).

Consider the linearization of f at wSWA.

f (wj) = f (wSWA) +

f (wSWA), ∆j

(cid:104)∇

+ O(
(cid:107)

(cid:105)

∆j

2),
(cid:107)

,
(cid:104)·

where
denotes the dot product. Thus, the difference
between averaging the weights and averaging the predic-
tions

·(cid:105)

¯f

−

f (wSWA) =

1
n

n
(cid:88)

(cid:0)

(cid:104)∇

i=1

f (wSWA), ∆i

∆i
+ O(
(cid:107)

(cid:107)

(cid:105)

2)(cid:1)

=

f (wSWA),

∆i

+ O(∆2) = O(∆2),

(cid:42)

∇

(cid:43)

1
n

n
(cid:88)

i=1

where ∆ = maxn
. Note that the difference be-
tween the predictions of different perturbed networks is

i=1 (cid:107)

∆i

(cid:107)

f (wi)

f (wj) =

f (wSWA), ∆i

−

(cid:104)∇

∆j

(cid:105)

−

+ O(∆2),

and is thus of the ﬁrst order of smallness, while the
difference between averaging predictions and averaging
weights is of the second order of smallness. Note that for
the points proposed by FGE the distances between pro-
posals are relatively small by design, which justiﬁes the
local analysis.

To analyze the difference between ensembling and av-
eraging the weights of FGE proposals in practice, we
run FGE for 20 epochs and compare the predictions of
different models on the test dataset with a Preactivation
ResNet-164 [He et al., 2016] on CIFAR-100. The norm
of the difference between the class probabilities of con-
secutive FGE proposals averaged over the test dataset is
0.126. We then average the weights of the proposals
and compute the class probabilities on the test dataset.

The norm of difference of the probabilities for the SWA
model and the FGE ensemble is 0.079, which is substan-
tially smaller than the difference between the probabili-
ties of consecutive FGE proposals. Further, the fraction
of objects for which consecutive FGE proposals output
the same labels is not greater than 87.33%. For FGE
and SWA the fraction of identically labeled objects is
95.26%.

The theoretical considerations and empirical results pre-
sented in this section suggest that SWA can approximate
the FGE ensemble with a single model.

3.6 CONNECTION TO CONVEX

MINIMIZATION

Mandt et al. [2017] showed that under strong simplify-
ing assumptions SGD with a ﬁxed learning rate approx-
imately samples from a Gaussian distribution centered
at the minimum of the loss. Suppose this is the case
when we run SGD with a ﬁxed learning rate for train-
ing a DNN.

Let us denote the dimensionality of the weight space of
the neural network by d. Denote the samples produced
by SGD by wi, i = 1, 2, . . . , k. Assume the points wi
are concentrated around the local optimum ˆw. The SWA
solution is given by wSWA = 1
i=1 wi. The points wi
n
( ˆw, Σ)
are samples from a multidimensional Gaussian
for some covariance matrix Σ deﬁned by the curvature of
the loss, batch size and the learning rate. Note that the
samples from a multidimensional Gaussian are concen-
trated on the ellipsoid

(cid:80)k

N

(cid:110)
z

Rd

Σ− 1

2 (z

∈

| (cid:107)

ˆw)
(cid:107)

−

= √d

(cid:111)

,

and the probability mass for a sample to end up inside the
ellipsoid near ˆw is negligible. On the other hand, wSWA
is guaranteed to converge to ˆw as k

.
→ ∞

Moreover, Polyak and Juditsky [1992] showed that aver-
aging SGD proposals achieves the best possible conver-
gence rate among all stochastic gradient algorithms. The
proof relies on the convexity of the underlying problem
and in general there are no convergence guarantees if the
loss function is non-convex [see e.g. Ghadimi and Lan,
2013]. While DNN loss functions are known to be non-
convex [e.g. Choromanska et al., 2015], over the trajec-
tory of SGD these loss surfaces are approximately con-
vex [e.g. Goodfellow et al., 2015]. However, even when
the loss is locally non-convex, SWA can improve gen-
eralization. For example, in Figure 5 we see that SWA
converges to a central point of the training loss.

In other words, there are a set of points that all achieve
low training loss. By running SGD with a high constant

Table 1: Accuracies (%) of SWA, SGD and FGE methods on CIFAR-100 and CIFAR-10 datasets for different training
budgets. Accuracies for the FGE ensemble are from Garipov et al. [2018].

DNN (Budget)

SGD

FGE (1 Budget)

1 Budget

VGG-16 (200)
ResNet-164 (150)
WRN-28-10 (200)
PyramidNet-272 (300)

VGG-16 (200)
ResNet-164 (150)
WRN-28-10 (200)
ShakeShake-2x64d (1800)

72.55
78.49
80.82
83.41

93.25
95.28
96.18
96.93

0.10
0.36
0.23
0.21

0.16
0.10
0.11
0.10

±
±
±
±

±
±
±
±

CIFAR-100
74.26
79.84
82.27
–

CIFAR-10
93.52
95.45
96.36
–

73.91
79.77
81.46

0.12
0.17
0.23

93.59
95.56
96.45

0.16
0.11
0.11

±
±
±
–

±
±
±
–

SWA
1.25 Budgets

74.17
80.18
81.91
83.93

93.70
95.77
96.64
97.16

0.15
0.23
0.27
0.18

0.22
0.04
0.08
0.10

±
±
±
±

±
±
±
±

1.5 Budgets

74.27
80.35
82.15
84.16

93.64
95.83
96.79
97.12

0.25
0.16
0.27
0.15

0.18
0.03
0.05
0.06

±
±
±
±

±
±
±
±

or cyclical schedule, we traverse over the surface of this
set. Then by averaging the corresponding iterates, we get
to move inside the set. This observation explains both
convergence rates and generalization. In deep learning
we mostly observe beneﬁts in generalization from av-
eraging. Averaging can move to a more central point,
which means one has to move further from this point to
increase the loss by a given amount, in virtually any di-
rection. By contrast, conventional SGD with a decaying
schedule will converge to a point on the periphery of this
set. With different initializations conventional SGD will
ﬁnd different points on the boundary, of solutions with
low training loss, but it will not move inside.

4 EXPERIMENTS

We compare SWA against conventional SGD training
on CIFAR-10, CIFAR-100 and ImageNet ILSVRC-2012
[Russakovsky et al., 2012]. We also compare to Fast Ge-
ometric Ensembling (FGE) [Garipov et al., 2018], but
we note that FGE is an ensemble whereas SWA corre-
sponds to a single model. Conventional SGD training
uses a standard decaying learning rate schedule (details
in the Appendix) until convergence. We found an ex-
ponentially decaying average of SGD to perform com-
parably to conventional SGD at convergence. We re-
lease the code for reproducing the results in this paper
at https://github.com/timgaripov/swa.

4.1 CIFAR DATASETS

For the experiments on CIFAR datasets we use VGG-
16 [Simonyan and Zisserman, 2014], a 164-layer
Preactivation-ResNet [He et al., 2016] and Wide ResNet-
28-10 [Zagoruyko and Komodakis, 2016] models. Ad-
ditionally, we experiment with the recent Shake-Shake-

2x64d [Gastaldi, 2017] on CIFAR-10 and PyramidNet-
272 (bottleneck, α = 200) [Han et al., 2016] on CIFAR-
100. All models are trained using L2-regularization, and
VGG-16 also uses dropout.

For each model we deﬁne budget as the number of
epochs required to train the model until convergence with
conventional SGD training, such that we do not see im-
provement with SGD beyond this budget. We use the
same budgets for VGG, Preactivation ResNet and Wide
ResNet models as Garipov et al. [2018]. For Shake-
Shake and PyramidNets we use the budgets indicated by
the papers that proposed these models [Gastaldi, 2017,
Han et al., 2016]. We report the results of SWA training
within 1, 1.25 and 1.5 budgets of epochs.

For VGG, Wide ResNet and Preactivation-ResNet mod-
75% of the
els we ﬁrst run standard SGD training for
training budget, and then use the weights at the last epoch
as an initialization for SWA with a ﬁxed learning rate
schedule. We ran SWA for 0.25, 0.5 and 0.75 budget
to complete the training within 1, 1.25 and 1.5 budgets
respectively.

≈

For Shake-Shake and PyramidNet architectures we do
not report the results in one budget. For these models
we use a full budget to get an initialization for the proce-
dure, and then train with a cyclical learning rate schedule
for 0.25 and 0.5 budgets. We used long cycles of small
learning rates for Shake-Shake, because this architecture
already involves many stochastic components.

We present the details of the learning rate schedules for
each of these models in the Appendix.

For each model we also report the results of conventional
SGD training, which we denote by SGD. For VGG, Pre-
activation ResNet and Wide ResNet we also provide the
results of the FGE method with one budget reported in

Garipov et al. [2018]. Note that for FGE we report the
accuracy of an ensemble of 6 to 12 networks, while for
SWA we report the accuracy of a single model.

We summarize the experimental results in Table 1. For
all models we report the mean and standard deviation
of test accuracy over 3 runs.
In all conducted experi-
ments SWA substantially outperforms SGD in one bud-
get, and improves further, as we allow more training
epochs. Across different architectures we see consis-
0.5% on CIFAR-10 (excluding
tent improvement by
Shake-Shake, for which SGD performance is already ex-
tremely high) and by 0.75-1.5% on CIFAR-100. Amaz-
ingly, SWA is able to achieve comparable or better per-
formance than FGE ensembles with just one model. On
CIFAR-100 SWA usually needs more than one budget
to get results comparable with FGE ensembles, but on
CIFAR-10 even with 1 budget SWA outperforms FGE.

≈

4.2

IMAGENET

On ImageNet we experimented with ResNet-50, ResNet-
152 [He et al., 2016] and DenseNet-161 [Huang et al.,
2017]. For these architectures we used pretrained mod-
els from PyTorch.torchvision. For each of the
models we ran SWA for 10 epochs with a cyclical learn-
ing rate schedule with the same parameters for all models
(the details can be found in the Appendix), and report the
mean and standard deviation of test error averaged over
3 runs. The results are shown in Table 2.

Table 2: Top-1 accuracies (%) on ImageNet for SWA and
SGD with different architectures.

DNN
ResNet-50
ResNet-152
DenseNet-161

SGD
76.15
78.31
77.65

SWA

5 epochs

10 epochs

76.83
78.82
78.26

0.01
0.01
0.09

±
±
±

76.97
78.94
78.44

0.05
0.07
0.06

±
±
±

For all 3 architectures SWA provides consistent improve-
ment by 0.6-0.9% over the pretrained models.

4.3 EFFECT OF THE LEARNING RATE

SCHEDULE

In this section we explore how the learning rate schedule
affects the performance of SWA. We run experiments on
Preactivation ResNet-164 on CIFAR-100. For all sched-
ules we use the same initialization from a model trained
for 125 epochs using the conventional SGD training. As
a baseline we use a fully-trained model trained with con-
ventional SGD for 150 epochs.

We consider a range of constant and cyclical learning

Figure 6: Test error as a function of training epoch for
SWA with different learning rate schedules with a Preac-
tivation ResNet-164 on CIFAR-100.

rate schedules. For cyclical learning rates we ﬁx the cy-
cle length to 5, and consider the pairs of base learning
10−2, 5
rate parameters (α1, α2)
·
10−4), (10−2, 10−4), (5
10−5)
. Among the
}
10−1, 5
constant learning rates we consider α1
∈ {
10−2, 10−2, 10−3
.
}

∈ {
10−3, 5
·

(10−1, 10−3), (5

·

·

·

We plot the test error of the SWA procedure for different
learning rate schedules as a function of the number of
training epochs in Figure 6.

We ﬁnd that in general the more aggressive constant
learning rate schedule leads to faster convergence of
SWA. In our experiments we found that setting the learn-
ing rate to some intermediate value between the largest
and the smallest learning rate used in the annealing
scheme in conventional training usually gave us the best
results. The approach is however universal and can work
well with different learning rate schedules tailored for
particular tasks.

4.4 DNN TRAINING WITH A FIXED

LEARNING RATE

In this section we show that it is possible to train DNNs
from scratch with a ﬁxed learning rate using SWA. We
run SGD with a ﬁxed learning rate of 0.05 on a Wide
ResNet-28-10 [Zagoruyko and Komodakis, 2016] for
300 epochs from a random initialization on CIFAR-100.
We then averaged the weights at the end of each epoch
from epoch 140 and until the end of training. The ﬁnal
test accuracy of this SWA model was 81.7.

Figure 7 illustrates the test error as a function of the num-
ber of training epochs for SWA and conventional train-
ing. The accuracy of the individual models with weights
65% which is
averaged by SWA stays at the level of
16% less than the accuracy of the SWA model. These re-
sults correspond to our intuition presented in section 3.6
that SGD with a constant learning rate oscillates around

≈

these rich models. We hope that SWA will inspire further
progress in this area.

Acknowledgements. This work was supported by
NSF IIS-1563887, Samsung Research, Samsung Elec-
tronics and Russian Science Foundation grant 17-11-
01027. We also thank Vadim Bereznyuk for helpful com-
ments.

References

P. Chaudhari, Anna Choromanska, S. Soatto, Yann Le-
Cun, C. Baldassi, C. Borgs, J. Chayes, Levent Sagun,
and R. Zecchina. Entropy-sgd: Biasing gradient de-
scent into wide valleys. In International Conference
on Learning Representations (ICLR), 2017.

Anna Choromanska, Mikael Henaff, Michael Mathieu,
G´erard Ben Arous, and Yann LeCun. The loss surfaces
of multilayer networks. In Artiﬁcial Intelligence and
Statistics, pages 192–204, 2015.

Laurent Dinh, Razvan Pascanu, Samy Bengio, and
Yoshua Bengio. Sharp minima can generalize for deep
nets. In International Conference on Machine Learn-
ing, pages 1019–1028, 2017.

Felix Draxler, Kambis Veschgini, Manfred Salmhofer,
and Fred Hamprecht. Essentially no barriers in neu-
ral network energy landscape. In Proceedings of the
35th International Conference on Machine Learning,
pages 1308–1317, 2018.

Timur Garipov, Pavel Izmailov, Dmitrii Podoprikhin,
Dmitry P Vetrov, and Andrew Gordon Wilson. Loss
surfaces, mode connectivity, and fast ensembling of
dnns. arXiv preprint arXiv:1802.10026, 2018.

Xavier Gastaldi.

Shake-shake regularization.

arXiv

preprint arXiv:1705.07485, 2017.

Saeed Ghadimi and Guanghui Lan. Stochastic ﬁrst-and
zeroth-order methods for nonconvex stochastic pro-
SIAM Journal on Optimization, 23(4):
gramming.
2341–2368, 2013.

Ian J Goodfellow, Oriol Vinyals, and Andrew M Saxe.
Qualitatively characterizing neural network optimiza-
tion problems. International Conference on Learning
Representations, 2015.

Dongyoon Han,

Jiwhan Kim,

Deep pyramidal residual networks.
arXiv:1610.02915, 2016.

and Junmo Kim.
arXiv preprint

Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian
Sun. Deep residual learning for image recognition.
In Proceedings of the IEEE conference on computer
vision and pattern recognition, pages 770–778, 2016.

Figure 7: Test error as a function of training epoch for
constant (green) and decaying (blue) learning rate sched-
ules for a Wide ResNet-28-10 on CIFAR-100. In red we
average the points along the trajectory of SGD with con-
stant learning rate starting at epoch 140.

the optimum, but SWA converges.

While being able to train a DNN with a ﬁxed learning
rate is a surprising property of SWA, for practical pur-
poses we recommend initializing SWA from a model pre-
trained with conventional training (possibly for a reduced
number of epochs), as it leads to faster and more stable
convergence than running SWA from scratch.

5 DISCUSSION

We have presented Stochastic Weight Averaging (SWA)
for training neural networks. SWA is extremely easy to
implement, architecture-agnostic, and improves general-
ization performance at virtually no additional cost over
conventional training.

There are so many exciting directions for future research.
SWA does not require each weight in its average to corre-
spond to a good solution, due to the geometry of weights
traversed by the algorithm. It therefore may be possible
to develop SWA for much faster convergence than stan-
dard SGD. One may also be able to combine SWA with
large batch sizes while preserving generalization perfor-
mance, since SWA discovers much broader optima than
conventional SGD training. Furthermore, a cyclic learn-
ing rate enables SWA to explore regions of high poste-
rior density over neural network weights. Such learning
rate schedules could be developed in conjunction with
stochastic MCMC approaches, to encourage exploration
while still providing high quality samples. One could
also develop SWA to average whole regions of good
solutions, using the high-accuracy curves discovered in
Garipov et al. [2018].

A better understanding of the loss surfaces for multilayer
networks will help continue to unlock the potential of

Sepp Hochreiter and J¨urgen Schmidhuber. Flat minima.

Neural Computation, 9(1):1–42, 1997.

Sergey Zagoruyko and Nikos Komodakis. Wide residual
networks. arXiv preprint arXiv:1605.07146, 2016.

Gao Huang, Zhuang Liu, Kilian Q Weinberger, and Lau-
rens van der Maaten. Densely connected convolutional
networks. In Proceedings of the IEEE conference on
computer vision and pattern recognition, volume 1,
page 3, 2017.

Sergey Ioffe and Christian Szegedy. Batch normaliza-
tion: Accelerating deep network training by reducing
In International Conference
internal covariate shift.
on Machine Learning, pages 448–456, 2015.

Nitish Shirish Keskar, Dheevatsa Mudigere, Jorge No-
cedal, Mikhail Smelyanskiy, and Ping Tak Peter Tang.
On large-batch training for deep learning: Generaliza-
tion gap and sharp minima. International Conference
on Learning Representations, 2017.

Ilya Loshchilov and Frank Hutter. Sgdr: stochastic gra-
dient descent with restarts. International Conference
on Learning Representations, 2017.

Stephan Mandt, Matthew D Hoffman, and David M Blei.
Stochastic gradient descent as approximate bayesian
inference. The Journal of Machine Learning Research,
18(1):4873–4907, 2017.

Kirill Neklyudov, Dmitry Molchanov, Arsenii Ashukha,
and Dmitry Vetrov. Variance networks: When expec-
tation does not meet your expectations. arXiv preprint
arXiv:1803.03764, 2018.

Boris T Polyak and Anatoli B Juditsky. Acceleration of
stochastic approximation by averaging. SIAM Journal
on Control and Optimization, 30(4):838–855, 1992.

David Ruppert. Efﬁcient estimations from a slowly
convergent robbins-monro process. Technical report,
Cornell University Operations Research and Industrial
Engineering, 1988.

Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause,
Sanjeev Satheesh, Sean Ma, Zhiheng Huang, Andrej
Karpathy, Aditya Khosla, Michael Bernstein, et al.
Imagenet large scale visual recognition challenge. In-
ternational Journal of Computer Vision, 115(3):211–
252, 2012.

Karen Simonyan and Andrew Zisserman. Very deep con-
volutional networks for large-scale image recognition.
arXiv preprint arXiv:1409.1556, 2014.

Leslie N Smith and Nicholay Topin. Exploring loss
function topology with cyclical learning rates. arXiv
preprint arXiv:1702.04283, 2017.

Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky,
Ilya Sutskever, and Ruslan Salakhutdinov. Dropout:
A simple way to prevent neural networks from overﬁt-
ting. The Journal of Machine Learning Research, 15
(1):1929–1958, 2014.

A Appendix

A.1 EXPERIMENTAL DETAILS

For the experiments on CIFAR datasets (section 4.1) we
used the following implementations (embedded links):

Shake-Shake-2x64d

PyramidNet-272

VGG-16

Preactivation-ResNet-164

Wide ResNet-28-10

•

•

•

•

•

Models for ImageNet are from here. Pretrained networks
can be found here.

SWA learning rates. For PyramidNet SWA uses a
cyclic learning rate with α1 = 0.05 and α2 = 0.001
and cycle length 3. For VGG and Wide ResNet we used
constant learning α1 = 0.01. For ResNet we used con-
stant learning rates α1 = 0.01 on CIFAR-10 and 0.05 on
CIFAR-100.

For Shake-Shake Net we used a custom cyclic learn-
ing rate based on the cosine annealing used when train-
ing Shake-Shake with SGD. Each of the cycles replicate
the learning rates corresponding to epochs 1600
1700
of the standard training and the cycle length c = 100
epochs. The learning rate schedule is depicted in Figure
8 and follows the formula

−

α(i) = 0.1

1 + cos

π

(cid:18)

·

(cid:18)

1600 + epoch(i) mod 100)
1800

·

(cid:19)(cid:19)

,

where epoch(i) is the number of data passes completed
before iteration i.

For all experiments with ImageNet we used cyclic learn-
ing rate schedule with the same hyperparameters α1 =
0.001, α2 = 10−5 and c = 1.

SGD learning rates. For conventional SGD training
we used SGD with momentum 0.9 and with an annealed
learning rate schedule. For VGG, Wide ResNet and Pre-
activation ResNet we ﬁxed the learning rate to α1 for the
ﬁrst half of epochs (0B–0.5B), then linearly decreased
the learning rate to 0.01α1 for the next 40% of epochs
(0.5B–0.9B), and then kept it constant for the last 10%
of epochs (0.9B – 1B). For VGG we set α1 = 0.05,
and for Preactivation ResNet and Wide ResNet we set

Figure 8: Cyclical learning rate used for Shake-Shake as
a function of iteration.

α1 = 0.1. For Shake-Shake Net and PyramidNets
we used the cosine and piecewise-constant learning rate
schedules described in Gastaldi [2017] and Han et al.
[2016] respectively.

A.2 TRAINING RESNET WITH A CONSTANT

LEARNING RATE

In this section we present the experiment on training
Preactivation ResNet-164 using a constant learning rate.
The experimental setup is the same as in section 4.4. We
set the learning rate to α1 = 0.1 and start averaging after
epoch 200. The results are presented in Figure 9.

Figure 9: Test error as a function of training epoch for
constant (green) and decaying (blue) learning rate sched-
ules for a Preactivation ResNet-164 on CIFAR-100. In
red we average the points along the trajectory of SGD
with constant learning rate starting at epoch 200.

Averaging Weights Leads to Wider Optima and Better Generalization

9
1
0
2
 
b
e
F
 
5
2
 
 
]

G
L
.
s
c
[
 
 
3
v
7
0
4
5
0
.
3
0
8
1
:
v
i
X
r
a

Pavel Izmailov∗1 Dmitrii Podoprikhin∗2,3 Timur Garipov∗4,5 Dmitry Vetrov2,3 Andrew Gordon Wilson1
1Cornell University, 2Higher School of Economics, 3Samsung-HSE Laboratory,
4Samsung AI Center in Moscow, 5Lomonosov Moscow State University

Abstract

Deep neural networks are typically trained by
optimizing a loss function with an SGD vari-
ant, in conjunction with a decaying learning
rate, until convergence. We show that simple
averaging of multiple points along the trajec-
tory of SGD, with a cyclical or constant learn-
ing rate,
leads to better generalization than
conventional training. We also show that this
Stochastic Weight Averaging (SWA) procedure
ﬁnds much ﬂatter solutions than SGD, and ap-
proximates the recent Fast Geometric Ensem-
bling (FGE) approach with a single model.
Using SWA we achieve notable improvement
in test accuracy over conventional SGD train-
ing on a range of state-of-the-art residual net-
works, PyramidNets, DenseNets, and Shake-
Shake networks on CIFAR-10, CIFAR-100,
In short, SWA is extremely
and ImageNet.
easy to implement, improves generalization,
and has almost no computational overhead.

1

INTRODUCTION

With a better understanding of the loss surfaces for mul-
tilayer networks, we can accelerate the convergence, sta-
bility, and accuracy of training procedures in deep learn-
ing. Recent work [Garipov et al., 2018, Draxler et al.,
2018] shows that local optima found by SGD can be con-
nected by simple curves of near constant loss. Building
upon this insight, Garipov et al. [2018] also developed
Fast Geometric Ensembling (FGE) to sample multiple
nearby points in weight space to create high performing
ensembles in the time required to train a single DNN.

FGE uses a high frequency cyclical learning rate with
SGD to select networks to ensemble. In Figure 1 (left)

∗Equal contribution.

we see that the weights of the networks ensembled by
FGE are on the periphery of the most desirable solu-
tions. This observation suggests it is promising to aver-
age these points in weight space, and use a network with
these averaged weights, instead of forming an ensemble
by averaging the outputs of networks in model space. Al-
though the general idea of maintaining a running aver-
age of weights traversed by SGD dates back to Ruppert
[1988], this procedure is not typically used to train neural
networks. It is sometimes applied as an exponentially de-
caying running average in combination with a decaying
learning rate (where it is called an exponential moving
average), which smooths the trajectory of conventional
SGD but does not perform very differently. However, we
show that an equally weighted average of the points tra-
versed by SGD with a cyclical or high constant learning
rate, which we refer to as Stochastic Weight Averaging
(SWA), has many surprising and promising features for
training deep neural networks, leading to a better under-
standing of the geometry of their loss surfaces. Indeed,
SWA with cyclical or constant learning rates can be used
as a drop-in replacement for standard SGD training of
multilayer networks — but with improved generalization
and essentially no overhead. In particular:

•

•

We show that SGD with cyclical [e.g., Loshchilov
and Hutter, 2017] and constant learning rates tra-
verses regions of weight space corresponding to
high-performing networks. We ﬁnd that while these
models are moving around this optimal set they
never reach its central points. We show that we can
move into this more desirable space of points by av-
eraging the weights proposed over SGD iterations.

While FGE ensembles [Garipov et al., 2018] can
be trained in the same time as a single model, test
predictions for an ensemble of k models requires k
times more computation. We show that SWA can
be interpreted as an approximation to FGE ensem-
bles but with the test-time, convenience, and inter-

Figure 1: Illustrations of SWA and SGD with a Preactivation ResNet-164 on CIFAR-1001. Left: test error surface
for three FGE samples and the corresponding SWA solution (averaging in weight space). Middle and Right: test
error and train loss surfaces showing the weights proposed by SGD (at convergence) and SWA, starting from the same
initialization of SGD after 125 training epochs.

pretability of a single model.

•

•

•

We demonstrate that SWA leads to solutions that are
wider than the optima found by SGD. Keskar et al.
[2017] and Hochreiter and Schmidhuber [1997]
conjecture that the width of the optima is critically
related to generalization. We illustrate that the loss
on the train is shifted with respect to the test er-
ror (Figure 1, middle and right panels, and sections
3, 4). We show that SGD generally converges to
a point near the boundary of the wide ﬂat region
of optimal points. SWA on the other hand is able
to ﬁnd a point centered in this region, often with
slightly worse train loss but with substantially bet-
ter test error.

We show that the loss function is asymmetric in the
direction connecting SWA with SGD. In this direc-
tion, SGD is near the periphery of sharp ascent. Part
of the reason SWA improves generalization is that it
ﬁnds solutions in ﬂat regions of the training loss in
such directions.

In particular,

SWA achieves notable improvement for training
a broad range of architectures over several con-
running
sequential benchmarks.
SWA for just 10 epochs on ImageNet we are
able to achieve 0.8% improvement for ResNet-
50 and DenseNet-161, and 0.6% improvement for
ResNet-150. We achieve improvement of over 1.3%
on CIFAR-100 and of over 0.4% on CIFAR-10
with Preactivation ResNet-164, VGG-16 and Wide
ResNet-28-10. We also achieve substantial im-
provement for the recent Shake-Shake Networks
and PyramidNets.

•

SWA is extremely easy to implement and has vir-
tually no computational overhead compared to the
conventional training schemes.

•

We provide an implementation of SWA at
https://github.com/timgaripov/swa.

We emphasize that SWA is ﬁnding a solution in the same
basin of attraction as SGD, as can be seen in Figure 1,
but in a ﬂatter region of the training loss. SGD typically
ﬁnds points on the periphery of a set of good weights. By
running SGD with a cyclical or high constant learning
rate, we traverse the surface of this set of points, and
by averaging we ﬁnd a more centred solution in a ﬂatter
region of the training loss. Further, the training loss for
SWA is often slightly worse than for SGD suggesting that
SWA solution is not a local optimum of the loss. In the
title of this paper, optima is used in a general sense to
mean solutions (converged points of a given procedure),
rather than different local minima of the same objective.

2 RELATED WORK

This paper is fundamentally about better understanding
the geometry of loss surfaces and generalization in deep
learning. We follow the trajectory of weights traversed
by SGD, leading to new geometric insights and the in-
tuition that SWA will lead to better results than standard
training. Empirically, we make the discovery that SWA
notably improves training of many state-of-the-art deep
neural networks over a range of consequential bench-
marks, with essentially no overhead.

The procedures for training neural networks are con-
stantly being improved. New methods are being pro-
posed for architecture design, regularization and opti-
mization. The SWA approach is related to work in both
optimization and regularization.

In optimization, there is great interest in how differ-

1 Suppose we have three weight vectors w1, w2, w3. We set
u = (w2 −w1), v = (w3 −w1)−(cid:104)w3 − w1, w2 − w1(cid:105)/(cid:107)w2 −
w1(cid:107)2 · (w2 − w1). Then the normalized vectors ˆu = u/(cid:107)u(cid:107),
ˆv = v/(cid:107)v(cid:107) form an orthonormal basis in the plane contain-
ing w1, w2, w3. To visualize the loss in this plane, we deﬁne
a Cartesian grid in the basis ˆu, ˆv and evaluate the networks
corresponding to each of the points in the grid. A point P
with coordinates (x, y) in the plane would then be given by
P = w1 + x · ˆu + y · ˆv.

ent types of local solutions affect generalization in deep
learning. Keskar et al. [2017] claim that SGD is more
likely to converge to broad local optima than batch gra-
dient methods, which tend to converge to sharp optima.
Moreover, they argue that the broad optima found by
SGD are more likely to have good test performance, even
if the training loss is worse than for the sharp optima.
On the other hand Dinh et al. [2017] argue that all the
known deﬁnitions of sharpness are unsatisfactory and
cannot on their own explain generalization. Chaudhari
et al. [2017] propose the Entropy-SGD method that ex-
plicitly forces optimization towards wide valleys. They
report that although the optima found by Entropy-SGD
are wider than those found by conventional SGD, the
generalization performance is still comparable.

The SWA method is based on averaging multiple points
along the trajectory of SGD with cyclical or constant
learning rates. The general idea of maintaining a running
average of weights proposed by SGD was ﬁrst consid-
ered in convex optimization by Ruppert [1988] and later
by Polyak and Juditsky [1992]. However, this procedure
is not typically used to train neural networks. Practi-
tioners instead sometimes use an exponentially decay-
ing running average of the weights found by SGD with
a decaying learning rate, which smooths the trajectory of
SGD but performs comparably.

SWA is making use of multiple samples gathered through
exploration of the set of points corresponding to high per-
forming networks. To enforce exploration we run SGD
with constant or cyclical learning rates. Mandt et al.
[2017] show that under several simplifying assumptions
running SGD with a constant learning rate is equivalent
to sampling from a Gaussian distribution centered at the
minimum of the loss, and the covariance of this Gaussian
is controlled by the learning rate. Following this expla-
nation from [Mandt et al., 2017], we can interpret points
proposed by SGD as being constrained to the surface of
a sphere, since they come from a high dimensional Gaus-
sian distribution. SWA effectively allows us to go inside
the sphere to ﬁnd higher density solutions.

In a procedure called Fast Geometric Ensembling (FGE),
Garipov et al. [2018] showed that using a cyclical learn-
ing rate it is possible to gather models that are spatially
close to each other but produce diverse predictions. They
used the gathered models to train ensembles with no
computational overhead compared to training a single
DNN model.
In recent work Neklyudov et al. [2018]
also discuss an efﬁcient approach for model averaging
of Bayesian neural networks. SWA was inspired by fol-
lowing the trajectories of FGE proposals, in order to ﬁnd
a single model that would approximate an FGE ensem-
ble, but provide greater interpretability, convenience, and

test-time scalability.

Dropout [Srivastava et al., 2014] is an extremely popu-
lar approach to regularizing DNNs. Across each mini-
batch used for SGD, a different architecture is created
by randomly dropping out neurons. The authors make
analogies between dropout, ensembling, and Bayesian
model averaging. At test time, an ensemble approach
is proposed, but then approximated with similar results
by multiplying each connection by the dropout rate. At a
high level, SWA and Dropout are both at once regulariz-
ers and training procedures, motivated to approximate an
ensemble. Each approach implements these high level
ideas quite differently, and as we show in our experi-
ments, can be combined for improved performance.

3 STOCHASTIC WEIGHT AVERAGING

We present Stochastic Weight Averaging (SWA) and an-
alyze its properties. In section 3.1, we consider trajec-
tories of SGD with a constant and cyclical learning rate,
which helps understand the geometry of SGD training
for neural networks, and motivates the SWA procedure.
Then in section 3.2 we present the SWA algorithm in
detail, in section 3.3 we derive its complexity, and in
section 3.4 we analyze the width of solutions found by
SWA versus conventional SGD training. In section 3.5
we then examine the relationship between SWA and the
recently proposed Fast Geometric Ensembling [Garipov
et al., 2018]. Finally, in section 3.6 we consider SWA
from the perspective of stochastic convex optimization.

We note the name SWA has two meanings: on the one
hand, it is an average of SGD weights. On the other,
with a cyclical or constant learning rate, SGD proposals
are approximately sampling from the loss surface of the
DNN, leading to stochastic weights.

3.1 ANALYSIS OF SGD TRAJECTORIES

SWA is based on averaging the samples proposed by
SGD using a learning rate schedule that allows explo-
ration of the region of weight space corresponding to
high-performing networks.
In particular we consider
cyclical and constant learning rate schedules.

The cyclical learning rate schedule that we adopt is in-
spired by Garipov et al. [2018] and Smith and Topin
[2017]. In each cycle we linearly decrease the learning
rate from α1 to α2. The formula for the learning rate at
iteration i is given by

t(i))α1 + t(i)α2,

α(i) = (1
1
c

t(i) =

−
(mod(i

1, c) + 1) .

−

corresponding to DNNs with high accuracy. The main
difference between the two approaches is that the indi-
vidual proposals of SGD with a cyclical learning rate
schedule are in general much more accurate than the pro-
posals of a ﬁxed-learning rate SGD. After making a large
step, SGD with a cyclical learning rate spends several
epochs ﬁne-tuning the resulting point with a decreasing
learning rate. SGD with a ﬁxed learning rate on the other
hand is always making steps of relatively large sizes, ex-
ploring more efﬁciently than with a cyclical learning rate,
but the individual proposals are worse.

Another important insight we can get from Figure 3 is
that while the train loss and test error surfaces are quali-
tatively similar, they are not perfectly aligned. The shift
between train and test suggests that more robust central
points in the set of high-performing networks can lead to
better generalization. Indeed, if we average several pro-
posals from the optimization trajectories, we get a more
robust point that has a substantially higher test perfor-
mance than the individual proposals of SGD, and is es-
sentially centered on the shifted mode for test error. We
further discuss the reasons for this behaviour in sections
3.4, 3.5, 3.6.

3.2 SWA ALGORITHM

We now present the details of the Stochastic Weight Av-
eraging algorithm, a simple but effective modiﬁcation for
training neural networks, motivated by our observations
in section 3.1.

Following Garipov et al. [2018], we start with a pre-
trained model ˆw. We will refer to the number of epochs
required to train a given DNN with the conventional
training procedure as its training budget and will denote
it by B. The pretrained model ˆw can be trained with the
conventional training procedure for full training budget
or reduced number of epochs (e.g. 0.75B). In the lat-
ter case we just stop the training early without modify-
ing the learning rate schedule. Starting from ˆw we con-
tinue training, using a cyclical or constant learning rate
schedule. When using a cyclical learning rate we capture
the models wi that correspond to the minimum values of
the learning rate (see Figure 2), following Garipov et al.
[2018]. For constant learning rates we capture models
at each epoch. Next, we average the weights of all the
captured networks wi to get our ﬁnal model wSWA.

Note that for cyclical learning rate schedule, the SWA
algorithm is related to FGE [Garipov et al., 2018], except
that instead of averaging the predictions of the models,
we average their weights, and we use a different type of
learning rate cycle. In section 3.5 we show how SWA
can approximate FGE, but with a single model.

Figure 2: Top: cyclical learning rate as a function of
iteration. Bottom: test error as a function of iteration
for cyclical learning rate schedule with Preactivation-
ResNet-164 on CIFAR-100. Circles indicate iterations
corresponding to the minimum learning rates.

α2 and the cycle length c
The base learning rates α1
≥
are the hyper-parameters of the method. Here by itera-
tion we assume the processing of one batch of data. Fig-
ure 2 illustrates the cyclical learning rate schedule and
the test error of the corresponding points. Note that un-
like the cyclical learning rate schedule of Garipov et al.
[2018] and Smith and Topin [2017], here we propose to
use a discontinuous schedule that jumps directly from
the minimum to maximum learning rates, and does not
steadily increase the learning rate as part of the cycle.
We use this more abrupt cycle because for our purposes
exploration is more important than the accuracy of indi-
vidual proposals. For even greater exploration, we also
consider constant learning rates α(i) = α1.

We run SGD with cyclical and constant learning rate
schedules starting from a pretrained point for a Preacti-
vation ResNet-164 on CIFAR-100. We then use the ﬁrst,
middle and last point of each of the trajectories to de-
ﬁne a 2-dimensional plane in the weight space contain-
ing all afﬁne combinations of these points. In Figure 3
we plot the loss on train and error on test for points in
these planes. We then project the other points of the tra-
jectory to the plane of the plot. Note that the trajectories
do not generally lie in the plane of the plot, except for the
ﬁrst, last and middle points, showed by black crosses in
the ﬁgure. Therefore for other points of the trajectories it
is not possible to tell the value of train loss and test error
from the plots.

The key insight from Figure 3 is that both methods ex-
plore points close to the periphery of the set of high-
performing networks. The visualizations suggest that
both methods are doing exploration in the region of space

Figure 3: The L2-regularized cross-entropy train loss and test error surfaces of a Preactivation ResNet-164 on CIFAR-
100 in the plane containing the ﬁrst, middle and last points (indicated by black crosses) in the trajectories with (left
two) cyclical and (right two) constant learning rate schedules.

Algorithm 1 Stochastic Weight Averaging

Require:

weights ˆw, LR bounds α1, α2,
cycle length c (for constant learning rate c = 1), num-
ber of iterations n

Ensure: wSWA

ˆw

w
←
wSWA
for i
α
Calculate LR for the iteration
{
}
w
α
Stochastic gradient update
}
{
if mod(i, c) = 0 then

Initialize weights with ˆw
{
w
←
1, 2, . . . , n do
←
α(i)
←
w
←

i(w)

∇L

−

}

nmodels
wSWA

i/c
{
wSWA·nmodels+w
nmodels+1

Number of models
}

Update average
{

}

←
←

end if
end for
Compute BatchNorm statistics for wSWA weights
{

}

Batch normalization.
If the DNN uses batch normal-
ization [Ioffe and Szegedy, 2015], we run one additional
pass over the data, as in Garipov et al. [2018], to compute
the running mean and standard deviation of the activa-
tions for each layer of the network with wSWA weights
after the training is ﬁnished, since these statistics are
not collected during training. For most deep learning li-
braries, such as PyTorch or Tensorﬂow, one can typically
collect these statistics by making a forward pass over the
data in training mode.

The SWA procedure is summarized in Algorithm 1.

3.3 COMPUTATIONAL COMPLEXITY

The time and memory overhead of SWA compared to
conventional training is negligible. During training, we
need to maintain a copy of the running average of DNN
weights. Note however that the memory consumption
in storing a DNN is dominated by its activations rather
than its weights, and thus is only slightly increased by the
SWA procedure, even for large DNNs (e.g., on the order
of 10%). After the training is complete we only need to

store the model that aggregates the average, leading to
the same memory requirements as standard training.

During training extra time is only spent to update the ag-
gregated weight average. This operation is of the form

wSWA

wSWA

nmodels + w

·

←

nmodels + 1

,

and it only requires computing a weighted sum of the
weights of two DNNs. As we apply this operation at
most once per epoch, SWA and SGD require practically
the same amount of computation. Indeed, a similar op-
eration is performed as a part of each gradient step, and
each epoch consists of hundreds of gradient steps.

3.4 SOLUTION WIDTH

Keskar et al. [2017] and Chaudhari et al. [2017] conjec-
ture that the width of a local optimum is related to gen-
eralization. The general explanation for the importance
of width is that the surfaces of train loss and test error
are shifted with respect to each other and it is thus de-
sirable to converge to the modes of broad optima, which
stay approximately optimal under small perturbations. In
this section we compare the solutions found by SWA and
SGD and show that SWA generally leads to much wider
solutions.

Let wSWA and wSGD denote the weights of DNNs trained
using SWA and conventional SGD, respectively. Con-
sider the rays

wSWA(t, d) = wSWA + t
wSGD(t, d) = wSGD + t

d,

d,

·

·

which follow a direction vector d on the unit sphere,
starting at wSWA and wSGD, respectively.
In Figure 4
we plot train loss and test error of wSWA(t, di) and
wSGD(t, di) as a function of t for 10 random directions
di, i = 1, 2, . . . , 10 drawn from a uniform distribution
on the unit sphere. For this visualization we use a Preac-
tivation ResNet-164 on CIFAR-100.

First, while the loss values on train for wSGD and wSWA
are quite similar (and in fact wSGD has a slightly lower

Figure 4: (Left) Test error and (Right) L2-regularized cross-entropy train loss as a function of a point on a random ray
starting at SWA (blue) and SGD (green) solutions for Preactivation ResNet-164 on CIFAR-100. Each line corresponds
to a different random ray.

Figure 5: L2-regularized cross-entropy train loss and test error as a function of a point on the line connecting SWA
and SGD solutions on CIFAR-100. Left: Preactivation ResNet-164. Right: VGG-16.

train loss), the test error for wSGD is lower by 1.5% (at
the converged value corresponding to t = 0). Further,
the shapes of both train loss and test error curves are con-
siderably wider for wSWA than for wSGD, suggesting that
SWA indeed converges to a wider solution: we have to
step much further away from wSWA to increase error by a
given amount. We even see the error curve for SGD has
an inﬂection point that is not present for these distances
with SWA.

Notice that in Figure 4 any of the random directions from
wSGD increase test error. However, we know that the di-
rection from wSGD to wSWA would decrease test error,
since wSWA has considerably lower test error than wSGD.
In other words, the path from wSGD to wSWA is qualita-
tively different from all directions shown in Figure 4, be-
cause along this direction wSGD is far from optimal. We
therefore consider the line segment connecting wSGD and
wSWA:

w(t) = t

wSGD + (1

t)

wSWA .

·

−

·

In Figure 5 we plot the train loss and test error of w(t)
as a function of signed distance from wSWA for Preacti-
vation ResNet-164 and VGG-16 on CIFAR-100.

We can extract several key insights about wSWA and wSGD
from Figure 5. First, the train loss and test error plots
are indeed substantially shifted, and the point obtained
by minimizing the train loss is far from optimal on test.

Second, wSGD lies near the boundary of a wide ﬂat region
of the train loss. Further, the loss is very steep near wSGD.

Keskar et al. [2017] argue that the loss near sharp op-
tima found by SGD with very large batches are actu-
ally ﬂat in most directions, but there exist directions in
which the optima are extremely steep. They conjecture
that because of this sharpness the generalization perfor-
mance of large batch optimization is substantially worse
than that of solutions found by small batch SGD. Re-
markably, in our experiments in this section we observe
that there exist directions of steep ascent even for small
batch optima, and that SWA provides even wider solu-
tions (at least along random directions) with better gen-
eralization. Indeed, we can see clearly in Figure 5 that
SWA is not ﬁnding a different minima than SGD, but
rather a ﬂatter region in the same basin of attraction. We
can also see clearly that the signiﬁcant asymmetry of the
loss function in certain directions, such as the direction
SWA to SGD, has a role in understanding why SWA pro-
vides better generalization than SGD. In these directions
SWA ﬁnds a much ﬂatter solution than SGD, which can
be near the periphery of sharp ascent.

3.5 CONNECTION TO ENSEMBLING

Garipov et al. [2018] proposed the Fast Geometric En-
sembling (FGE) procedure for training ensembles in the

time required to train a single model. Using a cyclical
learning rate, FGE generates a sequence of points that
are close to each other in the weight space, but produce
diverse predictions. In SWA instead of averaging the pre-
dictions of the models we average their weights. How-
ever, the predictions proposed by FGE ensembles and
SWA models have similar properties.

Let f (
) denote the predictions of a neural network
·
parametrized by weights w. We will assume that f is
a scalar (e.g. the probability for a particular class) twice
continuously differentiable function with respect to w.

Consider points wi proposed by FGE. These points are
close in the weight space by design, and concentrated
around their average wSWA = 1
i=1 wi. We denote
n
∆i = wi
i=1 ∆i = 0. Ensembling the
networks corresponds to averaging the function values

wSWA. Note (cid:80)n

(cid:80)n

−

¯f =

1
n

n
(cid:88)

i=1

f (wi).

Consider the linearization of f at wSWA.

f (wj) = f (wSWA) +

f (wSWA), ∆j

(cid:104)∇

+ O(
(cid:107)

(cid:105)

∆j

2),
(cid:107)

,
(cid:104)·

where
denotes the dot product. Thus, the difference
between averaging the weights and averaging the predic-
tions

·(cid:105)

¯f

−

f (wSWA) =

1
n

n
(cid:88)

(cid:0)

(cid:104)∇

i=1

f (wSWA), ∆i

∆i
+ O(
(cid:107)

(cid:107)

(cid:105)

2)(cid:1)

=

f (wSWA),

∆i

+ O(∆2) = O(∆2),

(cid:42)

∇

(cid:43)

1
n

n
(cid:88)

i=1

where ∆ = maxn
. Note that the difference be-
tween the predictions of different perturbed networks is

i=1 (cid:107)

∆i

(cid:107)

f (wi)

f (wj) =

f (wSWA), ∆i

−

(cid:104)∇

∆j

(cid:105)

−

+ O(∆2),

and is thus of the ﬁrst order of smallness, while the
difference between averaging predictions and averaging
weights is of the second order of smallness. Note that for
the points proposed by FGE the distances between pro-
posals are relatively small by design, which justiﬁes the
local analysis.

To analyze the difference between ensembling and av-
eraging the weights of FGE proposals in practice, we
run FGE for 20 epochs and compare the predictions of
different models on the test dataset with a Preactivation
ResNet-164 [He et al., 2016] on CIFAR-100. The norm
of the difference between the class probabilities of con-
secutive FGE proposals averaged over the test dataset is
0.126. We then average the weights of the proposals
and compute the class probabilities on the test dataset.

The norm of difference of the probabilities for the SWA
model and the FGE ensemble is 0.079, which is substan-
tially smaller than the difference between the probabili-
ties of consecutive FGE proposals. Further, the fraction
of objects for which consecutive FGE proposals output
the same labels is not greater than 87.33%. For FGE
and SWA the fraction of identically labeled objects is
95.26%.

The theoretical considerations and empirical results pre-
sented in this section suggest that SWA can approximate
the FGE ensemble with a single model.

3.6 CONNECTION TO CONVEX

MINIMIZATION

Mandt et al. [2017] showed that under strong simplify-
ing assumptions SGD with a ﬁxed learning rate approx-
imately samples from a Gaussian distribution centered
at the minimum of the loss. Suppose this is the case
when we run SGD with a ﬁxed learning rate for train-
ing a DNN.

Let us denote the dimensionality of the weight space of
the neural network by d. Denote the samples produced
by SGD by wi, i = 1, 2, . . . , k. Assume the points wi
are concentrated around the local optimum ˆw. The SWA
solution is given by wSWA = 1
i=1 wi. The points wi
n
( ˆw, Σ)
are samples from a multidimensional Gaussian
for some covariance matrix Σ deﬁned by the curvature of
the loss, batch size and the learning rate. Note that the
samples from a multidimensional Gaussian are concen-
trated on the ellipsoid

(cid:80)k

N

(cid:110)
z

Rd

Σ− 1

2 (z

∈

| (cid:107)

ˆw)
(cid:107)

−

= √d

(cid:111)

,

and the probability mass for a sample to end up inside the
ellipsoid near ˆw is negligible. On the other hand, wSWA
is guaranteed to converge to ˆw as k

.
→ ∞

Moreover, Polyak and Juditsky [1992] showed that aver-
aging SGD proposals achieves the best possible conver-
gence rate among all stochastic gradient algorithms. The
proof relies on the convexity of the underlying problem
and in general there are no convergence guarantees if the
loss function is non-convex [see e.g. Ghadimi and Lan,
2013]. While DNN loss functions are known to be non-
convex [e.g. Choromanska et al., 2015], over the trajec-
tory of SGD these loss surfaces are approximately con-
vex [e.g. Goodfellow et al., 2015]. However, even when
the loss is locally non-convex, SWA can improve gen-
eralization. For example, in Figure 5 we see that SWA
converges to a central point of the training loss.

In other words, there are a set of points that all achieve
low training loss. By running SGD with a high constant

Table 1: Accuracies (%) of SWA, SGD and FGE methods on CIFAR-100 and CIFAR-10 datasets for different training
budgets. Accuracies for the FGE ensemble are from Garipov et al. [2018].

DNN (Budget)

SGD

FGE (1 Budget)

1 Budget

VGG-16 (200)
ResNet-164 (150)
WRN-28-10 (200)
PyramidNet-272 (300)

VGG-16 (200)
ResNet-164 (150)
WRN-28-10 (200)
ShakeShake-2x64d (1800)

72.55
78.49
80.82
83.41

93.25
95.28
96.18
96.93

0.10
0.36
0.23
0.21

0.16
0.10
0.11
0.10

±
±
±
±

±
±
±
±

CIFAR-100
74.26
79.84
82.27
–

CIFAR-10
93.52
95.45
96.36
–

73.91
79.77
81.46

0.12
0.17
0.23

93.59
95.56
96.45

0.16
0.11
0.11

±
±
±
–

±
±
±
–

SWA
1.25 Budgets

74.17
80.18
81.91
83.93

93.70
95.77
96.64
97.16

0.15
0.23
0.27
0.18

0.22
0.04
0.08
0.10

±
±
±
±

±
±
±
±

1.5 Budgets

74.27
80.35
82.15
84.16

93.64
95.83
96.79
97.12

0.25
0.16
0.27
0.15

0.18
0.03
0.05
0.06

±
±
±
±

±
±
±
±

or cyclical schedule, we traverse over the surface of this
set. Then by averaging the corresponding iterates, we get
to move inside the set. This observation explains both
convergence rates and generalization. In deep learning
we mostly observe beneﬁts in generalization from av-
eraging. Averaging can move to a more central point,
which means one has to move further from this point to
increase the loss by a given amount, in virtually any di-
rection. By contrast, conventional SGD with a decaying
schedule will converge to a point on the periphery of this
set. With different initializations conventional SGD will
ﬁnd different points on the boundary, of solutions with
low training loss, but it will not move inside.

4 EXPERIMENTS

We compare SWA against conventional SGD training
on CIFAR-10, CIFAR-100 and ImageNet ILSVRC-2012
[Russakovsky et al., 2012]. We also compare to Fast Ge-
ometric Ensembling (FGE) [Garipov et al., 2018], but
we note that FGE is an ensemble whereas SWA corre-
sponds to a single model. Conventional SGD training
uses a standard decaying learning rate schedule (details
in the Appendix) until convergence. We found an ex-
ponentially decaying average of SGD to perform com-
parably to conventional SGD at convergence. We re-
lease the code for reproducing the results in this paper
at https://github.com/timgaripov/swa.

4.1 CIFAR DATASETS

For the experiments on CIFAR datasets we use VGG-
16 [Simonyan and Zisserman, 2014], a 164-layer
Preactivation-ResNet [He et al., 2016] and Wide ResNet-
28-10 [Zagoruyko and Komodakis, 2016] models. Ad-
ditionally, we experiment with the recent Shake-Shake-

2x64d [Gastaldi, 2017] on CIFAR-10 and PyramidNet-
272 (bottleneck, α = 200) [Han et al., 2016] on CIFAR-
100. All models are trained using L2-regularization, and
VGG-16 also uses dropout.

For each model we deﬁne budget as the number of
epochs required to train the model until convergence with
conventional SGD training, such that we do not see im-
provement with SGD beyond this budget. We use the
same budgets for VGG, Preactivation ResNet and Wide
ResNet models as Garipov et al. [2018]. For Shake-
Shake and PyramidNets we use the budgets indicated by
the papers that proposed these models [Gastaldi, 2017,
Han et al., 2016]. We report the results of SWA training
within 1, 1.25 and 1.5 budgets of epochs.

For VGG, Wide ResNet and Preactivation-ResNet mod-
75% of the
els we ﬁrst run standard SGD training for
training budget, and then use the weights at the last epoch
as an initialization for SWA with a ﬁxed learning rate
schedule. We ran SWA for 0.25, 0.5 and 0.75 budget
to complete the training within 1, 1.25 and 1.5 budgets
respectively.

≈

For Shake-Shake and PyramidNet architectures we do
not report the results in one budget. For these models
we use a full budget to get an initialization for the proce-
dure, and then train with a cyclical learning rate schedule
for 0.25 and 0.5 budgets. We used long cycles of small
learning rates for Shake-Shake, because this architecture
already involves many stochastic components.

We present the details of the learning rate schedules for
each of these models in the Appendix.

For each model we also report the results of conventional
SGD training, which we denote by SGD. For VGG, Pre-
activation ResNet and Wide ResNet we also provide the
results of the FGE method with one budget reported in

Garipov et al. [2018]. Note that for FGE we report the
accuracy of an ensemble of 6 to 12 networks, while for
SWA we report the accuracy of a single model.

We summarize the experimental results in Table 1. For
all models we report the mean and standard deviation
of test accuracy over 3 runs.
In all conducted experi-
ments SWA substantially outperforms SGD in one bud-
get, and improves further, as we allow more training
epochs. Across different architectures we see consis-
0.5% on CIFAR-10 (excluding
tent improvement by
Shake-Shake, for which SGD performance is already ex-
tremely high) and by 0.75-1.5% on CIFAR-100. Amaz-
ingly, SWA is able to achieve comparable or better per-
formance than FGE ensembles with just one model. On
CIFAR-100 SWA usually needs more than one budget
to get results comparable with FGE ensembles, but on
CIFAR-10 even with 1 budget SWA outperforms FGE.

≈

4.2

IMAGENET

On ImageNet we experimented with ResNet-50, ResNet-
152 [He et al., 2016] and DenseNet-161 [Huang et al.,
2017]. For these architectures we used pretrained mod-
els from PyTorch.torchvision. For each of the
models we ran SWA for 10 epochs with a cyclical learn-
ing rate schedule with the same parameters for all models
(the details can be found in the Appendix), and report the
mean and standard deviation of test error averaged over
3 runs. The results are shown in Table 2.

Table 2: Top-1 accuracies (%) on ImageNet for SWA and
SGD with different architectures.

DNN
ResNet-50
ResNet-152
DenseNet-161

SGD
76.15
78.31
77.65

SWA

5 epochs

10 epochs

76.83
78.82
78.26

0.01
0.01
0.09

±
±
±

76.97
78.94
78.44

0.05
0.07
0.06

±
±
±

For all 3 architectures SWA provides consistent improve-
ment by 0.6-0.9% over the pretrained models.

4.3 EFFECT OF THE LEARNING RATE

SCHEDULE

In this section we explore how the learning rate schedule
affects the performance of SWA. We run experiments on
Preactivation ResNet-164 on CIFAR-100. For all sched-
ules we use the same initialization from a model trained
for 125 epochs using the conventional SGD training. As
a baseline we use a fully-trained model trained with con-
ventional SGD for 150 epochs.

We consider a range of constant and cyclical learning

Figure 6: Test error as a function of training epoch for
SWA with different learning rate schedules with a Preac-
tivation ResNet-164 on CIFAR-100.

rate schedules. For cyclical learning rates we ﬁx the cy-
cle length to 5, and consider the pairs of base learning
10−2, 5
rate parameters (α1, α2)
·
10−4), (10−2, 10−4), (5
10−5)
. Among the
}
10−1, 5
constant learning rates we consider α1
∈ {
10−2, 10−2, 10−3
.
}

∈ {
10−3, 5
·

(10−1, 10−3), (5

·

·

·

We plot the test error of the SWA procedure for different
learning rate schedules as a function of the number of
training epochs in Figure 6.

We ﬁnd that in general the more aggressive constant
learning rate schedule leads to faster convergence of
SWA. In our experiments we found that setting the learn-
ing rate to some intermediate value between the largest
and the smallest learning rate used in the annealing
scheme in conventional training usually gave us the best
results. The approach is however universal and can work
well with different learning rate schedules tailored for
particular tasks.

4.4 DNN TRAINING WITH A FIXED

LEARNING RATE

In this section we show that it is possible to train DNNs
from scratch with a ﬁxed learning rate using SWA. We
run SGD with a ﬁxed learning rate of 0.05 on a Wide
ResNet-28-10 [Zagoruyko and Komodakis, 2016] for
300 epochs from a random initialization on CIFAR-100.
We then averaged the weights at the end of each epoch
from epoch 140 and until the end of training. The ﬁnal
test accuracy of this SWA model was 81.7.

Figure 7 illustrates the test error as a function of the num-
ber of training epochs for SWA and conventional train-
ing. The accuracy of the individual models with weights
65% which is
averaged by SWA stays at the level of
16% less than the accuracy of the SWA model. These re-
sults correspond to our intuition presented in section 3.6
that SGD with a constant learning rate oscillates around

≈

these rich models. We hope that SWA will inspire further
progress in this area.

Acknowledgements. This work was supported by
NSF IIS-1563887, Samsung Research, Samsung Elec-
tronics and Russian Science Foundation grant 17-11-
01027. We also thank Vadim Bereznyuk for helpful com-
ments.

References

P. Chaudhari, Anna Choromanska, S. Soatto, Yann Le-
Cun, C. Baldassi, C. Borgs, J. Chayes, Levent Sagun,
and R. Zecchina. Entropy-sgd: Biasing gradient de-
scent into wide valleys. In International Conference
on Learning Representations (ICLR), 2017.

Anna Choromanska, Mikael Henaff, Michael Mathieu,
G´erard Ben Arous, and Yann LeCun. The loss surfaces
of multilayer networks. In Artiﬁcial Intelligence and
Statistics, pages 192–204, 2015.

Laurent Dinh, Razvan Pascanu, Samy Bengio, and
Yoshua Bengio. Sharp minima can generalize for deep
nets. In International Conference on Machine Learn-
ing, pages 1019–1028, 2017.

Felix Draxler, Kambis Veschgini, Manfred Salmhofer,
and Fred Hamprecht. Essentially no barriers in neu-
ral network energy landscape. In Proceedings of the
35th International Conference on Machine Learning,
pages 1308–1317, 2018.

Timur Garipov, Pavel Izmailov, Dmitrii Podoprikhin,
Dmitry P Vetrov, and Andrew Gordon Wilson. Loss
surfaces, mode connectivity, and fast ensembling of
dnns. arXiv preprint arXiv:1802.10026, 2018.

Xavier Gastaldi.

Shake-shake regularization.

arXiv

preprint arXiv:1705.07485, 2017.

Saeed Ghadimi and Guanghui Lan. Stochastic ﬁrst-and
zeroth-order methods for nonconvex stochastic pro-
SIAM Journal on Optimization, 23(4):
gramming.
2341–2368, 2013.

Ian J Goodfellow, Oriol Vinyals, and Andrew M Saxe.
Qualitatively characterizing neural network optimiza-
tion problems. International Conference on Learning
Representations, 2015.

Dongyoon Han,

Jiwhan Kim,

Deep pyramidal residual networks.
arXiv:1610.02915, 2016.

and Junmo Kim.
arXiv preprint

Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian
Sun. Deep residual learning for image recognition.
In Proceedings of the IEEE conference on computer
vision and pattern recognition, pages 770–778, 2016.

Figure 7: Test error as a function of training epoch for
constant (green) and decaying (blue) learning rate sched-
ules for a Wide ResNet-28-10 on CIFAR-100. In red we
average the points along the trajectory of SGD with con-
stant learning rate starting at epoch 140.

the optimum, but SWA converges.

While being able to train a DNN with a ﬁxed learning
rate is a surprising property of SWA, for practical pur-
poses we recommend initializing SWA from a model pre-
trained with conventional training (possibly for a reduced
number of epochs), as it leads to faster and more stable
convergence than running SWA from scratch.

5 DISCUSSION

We have presented Stochastic Weight Averaging (SWA)
for training neural networks. SWA is extremely easy to
implement, architecture-agnostic, and improves general-
ization performance at virtually no additional cost over
conventional training.

There are so many exciting directions for future research.
SWA does not require each weight in its average to corre-
spond to a good solution, due to the geometry of weights
traversed by the algorithm. It therefore may be possible
to develop SWA for much faster convergence than stan-
dard SGD. One may also be able to combine SWA with
large batch sizes while preserving generalization perfor-
mance, since SWA discovers much broader optima than
conventional SGD training. Furthermore, a cyclic learn-
ing rate enables SWA to explore regions of high poste-
rior density over neural network weights. Such learning
rate schedules could be developed in conjunction with
stochastic MCMC approaches, to encourage exploration
while still providing high quality samples. One could
also develop SWA to average whole regions of good
solutions, using the high-accuracy curves discovered in
Garipov et al. [2018].

A better understanding of the loss surfaces for multilayer
networks will help continue to unlock the potential of

Sepp Hochreiter and J¨urgen Schmidhuber. Flat minima.

Neural Computation, 9(1):1–42, 1997.

Sergey Zagoruyko and Nikos Komodakis. Wide residual
networks. arXiv preprint arXiv:1605.07146, 2016.

Gao Huang, Zhuang Liu, Kilian Q Weinberger, and Lau-
rens van der Maaten. Densely connected convolutional
networks. In Proceedings of the IEEE conference on
computer vision and pattern recognition, volume 1,
page 3, 2017.

Sergey Ioffe and Christian Szegedy. Batch normaliza-
tion: Accelerating deep network training by reducing
In International Conference
internal covariate shift.
on Machine Learning, pages 448–456, 2015.

Nitish Shirish Keskar, Dheevatsa Mudigere, Jorge No-
cedal, Mikhail Smelyanskiy, and Ping Tak Peter Tang.
On large-batch training for deep learning: Generaliza-
tion gap and sharp minima. International Conference
on Learning Representations, 2017.

Ilya Loshchilov and Frank Hutter. Sgdr: stochastic gra-
dient descent with restarts. International Conference
on Learning Representations, 2017.

Stephan Mandt, Matthew D Hoffman, and David M Blei.
Stochastic gradient descent as approximate bayesian
inference. The Journal of Machine Learning Research,
18(1):4873–4907, 2017.

Kirill Neklyudov, Dmitry Molchanov, Arsenii Ashukha,
and Dmitry Vetrov. Variance networks: When expec-
tation does not meet your expectations. arXiv preprint
arXiv:1803.03764, 2018.

Boris T Polyak and Anatoli B Juditsky. Acceleration of
stochastic approximation by averaging. SIAM Journal
on Control and Optimization, 30(4):838–855, 1992.

David Ruppert. Efﬁcient estimations from a slowly
convergent robbins-monro process. Technical report,
Cornell University Operations Research and Industrial
Engineering, 1988.

Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause,
Sanjeev Satheesh, Sean Ma, Zhiheng Huang, Andrej
Karpathy, Aditya Khosla, Michael Bernstein, et al.
Imagenet large scale visual recognition challenge. In-
ternational Journal of Computer Vision, 115(3):211–
252, 2012.

Karen Simonyan and Andrew Zisserman. Very deep con-
volutional networks for large-scale image recognition.
arXiv preprint arXiv:1409.1556, 2014.

Leslie N Smith and Nicholay Topin. Exploring loss
function topology with cyclical learning rates. arXiv
preprint arXiv:1702.04283, 2017.

Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky,
Ilya Sutskever, and Ruslan Salakhutdinov. Dropout:
A simple way to prevent neural networks from overﬁt-
ting. The Journal of Machine Learning Research, 15
(1):1929–1958, 2014.

A Appendix

A.1 EXPERIMENTAL DETAILS

For the experiments on CIFAR datasets (section 4.1) we
used the following implementations (embedded links):

Shake-Shake-2x64d

PyramidNet-272

VGG-16

Preactivation-ResNet-164

Wide ResNet-28-10

•

•

•

•

•

Models for ImageNet are from here. Pretrained networks
can be found here.

SWA learning rates. For PyramidNet SWA uses a
cyclic learning rate with α1 = 0.05 and α2 = 0.001
and cycle length 3. For VGG and Wide ResNet we used
constant learning α1 = 0.01. For ResNet we used con-
stant learning rates α1 = 0.01 on CIFAR-10 and 0.05 on
CIFAR-100.

For Shake-Shake Net we used a custom cyclic learn-
ing rate based on the cosine annealing used when train-
ing Shake-Shake with SGD. Each of the cycles replicate
the learning rates corresponding to epochs 1600
1700
of the standard training and the cycle length c = 100
epochs. The learning rate schedule is depicted in Figure
8 and follows the formula

−

α(i) = 0.1

1 + cos

π

(cid:18)

·

(cid:18)

1600 + epoch(i) mod 100)
1800

·

(cid:19)(cid:19)

,

where epoch(i) is the number of data passes completed
before iteration i.

For all experiments with ImageNet we used cyclic learn-
ing rate schedule with the same hyperparameters α1 =
0.001, α2 = 10−5 and c = 1.

SGD learning rates. For conventional SGD training
we used SGD with momentum 0.9 and with an annealed
learning rate schedule. For VGG, Wide ResNet and Pre-
activation ResNet we ﬁxed the learning rate to α1 for the
ﬁrst half of epochs (0B–0.5B), then linearly decreased
the learning rate to 0.01α1 for the next 40% of epochs
(0.5B–0.9B), and then kept it constant for the last 10%
of epochs (0.9B – 1B). For VGG we set α1 = 0.05,
and for Preactivation ResNet and Wide ResNet we set

Figure 8: Cyclical learning rate used for Shake-Shake as
a function of iteration.

α1 = 0.1. For Shake-Shake Net and PyramidNets
we used the cosine and piecewise-constant learning rate
schedules described in Gastaldi [2017] and Han et al.
[2016] respectively.

A.2 TRAINING RESNET WITH A CONSTANT

LEARNING RATE

In this section we present the experiment on training
Preactivation ResNet-164 using a constant learning rate.
The experimental setup is the same as in section 4.4. We
set the learning rate to α1 = 0.1 and start averaging after
epoch 200. The results are presented in Figure 9.

Figure 9: Test error as a function of training epoch for
constant (green) and decaying (blue) learning rate sched-
ules for a Preactivation ResNet-164 on CIFAR-100. In
red we average the points along the trajectory of SGD
with constant learning rate starting at epoch 200.

