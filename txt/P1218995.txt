Syntactic Scaﬀolds for Semantic Structures

Swabha Swayamdipta♠

Sam Thomson♠

Kenton Lee♦ Luke Zettlemoyer(cid:114) Chris Dyer♥ Noah A. Smith(cid:114)♣

♠Language Technologies Institute, Carnegie Mellon University, Pittsburgh, PA, USA
♦Google AI Language, Seattle WA, USA
(cid:114)Paul G. Allen School of Computer Science & Engineering, University of Washington, Seattle, WA, USA
♥Google DeepMind, London, UK
♣Allen Institute for Artiﬁcial Intelligence, Seattle, WA, USA
{swabha,sammthomson}@cs.cmu.edu {kentonl,cdyer}@google.com
{lsz,nasmith}@cs.washington.edu

8
1
0
2
 
g
u
A
 
0
3
 
 
]
L
C
.
s
c
[
 
 
1
v
5
8
4
0
1
.
8
0
8
1
:
v
i
X
r
a

Abstract

We introduce the syntactic scaﬀold, an ap-
proach to incorporating syntactic informa-
tion into semantic tasks. Syntactic scaﬀolds
avoid expensive syntactic processing at run-
time, only making use of a treebank during
training, through a multitask objective. We im-
prove over strong baselines on PropBank se-
mantics, frame semantics, and coreference res-
olution, achieving competitive performance on
all three tasks.

1

Introduction

As algorithms for the semantic analysis of natu-
ral language sentences have developed, the role
of syntax has been repeatedly revisited. Linguis-
tic theories have argued for a very tight integra-
tion of syntactic and semantic processing (Steed-
man, 2000; Copestake and Flickinger, 2000), and
many systems have used syntactic dependency
or phrase-based parsers as preprocessing for se-
mantic analysis (Gildea and Palmer, 2002; Pun-
yakanok et al., 2008; Das et al., 2014). Mean-
while, some recent methods forgo explicit syntac-
tic processing altogether (Zhou and Xu, 2015; He
et al., 2017; Lee et al., 2017; Peng et al., 2017).

Because annotated training datasets for se-
mantics will always be limited, we expect that
syntax—which oﬀers an incomplete but poten-
tially useful view of semantic structure—will con-
tinue to oﬀer useful inductive bias, encouraging
semantic models toward better generalization. We
address the central question: is there a way for se-
mantic analyzers to beneﬁt from syntax without
the computational cost of syntactic parsing?

We propose a multitask learning approach to
incorporating syntactic information into learned

representations of neural semantics models (§2).
Our approach, the syntactic scaﬀold, minimizes
an auxiliary supervised loss function, derived from
a syntactic treebank. The goal is to steer the dis-
tributed, contextualized representations of words
and spans toward accurate semantic and syntactic
labeling. We avoid the cost of training or execut-
ing a full syntactic parser, and at test time (i.e.,
runtime in applications) the semantic analyzer has
no additional cost over a syntax-free baseline. Fur-
ther, the method does not assume that the syntactic
treebank overlaps the dataset for the primary task.
Many semantic tasks involve labeling spans, in-
cluding semantic role labeling (SRL; Gildea and
Jurafsky, 2002) and coreference resolution (Ng,
2010) (tasks we consider in this paper), as well
as named entity recognition and some reading
comprehension and question answering tasks (Ra-
jpurkar et al., 2016).
These spans are usu-
ally syntactic constituents (cf. PropBank; Palmer
et al., 2005), making phrase-based syntax a natu-
ral choice for a scaﬀold. See Figure 1 for an ex-
ample sentence with syntactic and semantic anno-
tations. Since the scaﬀold task is not an end in
itself, we relax the syntactic parsing problem to
a collection of independent span-level predictions,
with no constraint that they form a valid parse tree.
This means we never need to run a syntactic pars-
ing algorithm.

Our experiments demonstrate that the syntactic
scaﬀold oﬀers a substantial boost to state-of-the-
art baselines for two SRL tasks (§5) and corefer-
ence resolution (§6). Our models use the strongest
available neural network architectures for these
tasks, integrating deep representation learning (He
et al., 2017) and structured prediction at the level
of spans (Kong et al., 2016). For SRL, the base-

Figure 1: An example sentence with syntactic, PropBank and coreference annotations from OntoNotes,
and author-annotated frame-semantic structures. PropBank SRL arguments and coreference mentions are
annotated on top of syntactic constituents. All but one frame-semantic argument (Event) is a syntactic
constituent. Targets evoke frames shown in the color-coded layers.

line itself is a novel globally normalized structured
conditional random ﬁeld, which outperforms the
previous state of the art.1 Syntactic scaﬀolds re-
sult in further improvements over prior work—
3.6 absolute F1 in FrameNet SRL, 1.1 absolute
F1 in PropBank SRL, and 0.6 F1 in coreference
resolution (averaged across three standard scores).
Our code is open source and available at https:
//github.com/swabhs/scaffolding.

2 Syntactic Scaﬀolds

Multitask learning (Caruana, 1997) is a collec-
tion of techniques in which two or more tasks are
learned from data with at least some parameters
shared. We assume there is only one task about
whose performance we are concerned, denoted T1
(in this paper, T1 is either SRL or coreference res-
olution). We use the term “scaﬀold” to refer to
a second task, T2, that can be combined with T1
during multitask learning. A scaﬀold task is only
used during training; it holds no intrinsic interest
beyond biasing the learning of T1, and after learn-
ing is completed, the scaﬀold is discarded.

A syntactic scaﬀold is a task designed to steer
the (shared) model toward awareness of syntactic

1This excludes models initialized with deep, contextual-
ized embeddings (Peters et al., 2018), an approach orthogonal
to ours.

structure.
It could be deﬁned through a syntac-
tic parser that shares some parameters with T1’s
model. Since syntactic parsing is costly, we use
simpler syntactic prediction problems (discussed
below) that do not produce whole trees.

As with multitask learning in general, we do not
assume that the same data are annotated with out-
puts for T1 and T2.
In this work, T2 is deﬁned
using phrase-structure syntactic annotations from
OntoNotes 5.0 (Weischedel et al., 2013; Pradhan
et al., 2013). We experiment with three settings:
one where the corpus for T2 does not overlap with
the training datasets for T1 (frame-SRL) and two
where there is a complete overlap (PropBank SRL
and coreference). Compared to approaches which
require multiple output labels over the same data,
we oﬀer the major advantage of not requiring any
assumptions about, or speciﬁcation of, the rela-
tionship between T1 and T2 output.

3 Related Work

We brieﬂy contrast the syntactic scaﬀold with ex-
isting alternatives.

Pipelines.
In a typical pipeline, T1 and T2 are
separately trained, with the output of T2 used to
deﬁne the inputs to T1 (Wolpert, 1992). Using
syntax as T2 in a pipeline is perhaps the most

common approach for semantic structure predic-
tion (Toutanova et al., 2008; Yang and Mitchell,
2017; Wiseman et al., 2016).2 However, pipelines
introduce the problem of cascading errors (T2’s
mistakes aﬀect the performance, and perhaps the
training, of T1; He et al., 2013). To date, reme-
dies to cascading errors are so computationally ex-
pensive as to be impractical (e.g., Finkel et al.,
2006). A syntactic scaﬀold is quite diﬀerent from
a pipeline since the output of T2 is never explicitly
used.

Latent variables. Another solution is to treat
the output of T2 as a (perhaps structured) la-
tent variable. This approach obviates the need
of supervision for T2 and requires marginalization
(or some approximation to it) in order to reason
about the outputs of T1. Syntax as a latent vari-
able for semantics was explored by Zettlemoyer
and Collins (2005) and Naradowsky et al. (2012).
Apart from avoiding marginalization, the syntactic
scaﬀold oﬀers a way to use auxiliary syntactically-
annotated data as direct supervision for T2, and it
need not overlap the T1 training data.

Joint learning of syntax and semantics. The
motivation behind joint learning of syntactic and
semantic representations is that any one task is
helpful in predicting the other (Llu´ıs and M`arquez,
2008; Llu´ıs et al., 2013; Henderson et al., 2013;
Swayamdipta et al., 2016). This typically re-
quires joint prediction of the outputs of T1 and
T2, which tends to be computationally expensive
at both training and test time.

Part of speech scaﬀolds. Similar to our work,
there have been multitask models that use part-
of-speech tagging as T2, with transition-based de-
pendency parsing (Zhang and Weiss, 2016) and
CCG supertagging (Søgaard and Goldberg, 2016)
as T1. Both of the above approaches assumed par-
allel input data and used both tasks as supervision.
Notably, we simplify our T2, throwing away the
structured aspects of syntactic parsing, whereas
part-of-speech tagging has very little structure
to begin with. While their approach results in
improved token-level representations learned via
supervision from POS tags, these must still be
In-
composed to obtain span representations.

2 There has been some recent work on SRL which com-
pletely forgoes syntactic processing (Zhou and Xu, 2015),
however it has been shown that incorporating syntactic in-
formation still remains useful (He et al., 2017).

stead, our approach learns span-level representa-
tions from phrase-type supervision directly, for se-
mantic tasks. Additionally, these methods explore
architectural variations in RNN layers for includ-
ing supervision, whereas we focus on incorporat-
ing supervision with minimal changes to the base-
line architecture. To the best of our knowledge,
such simpliﬁed syntactic scaﬀolds have not been
tried before.

Word embeddings. Our deﬁnition of a scaﬀold
task almost includes stand-alone methods for es-
timating word embeddings (Mikolov et al., 2013;
Pennington et al., 2014; Peters et al., 2018). Af-
ter training word embeddings, the tasks implied
by models like the skip-gram or ELMo’s language
model become irrelevant to the downstream use of
the embeddings. A noteworthy diﬀerence is that,
rather than pre-training, a scaﬀold is integrated di-
rectly into the training of T1 through a multitask
objective.

Multitask learning. Neural architectures have
often yielded performance gains when trained for
multiple tasks together (Collobert et al., 2011; Lu-
ong et al., 2015; Chen et al., 2017; Hashimoto
et al., 2017). In particular, performance of seman-
tic role labeling tasks improves when done jointly
with other semantic tasks (FitzGerald et al., 2015;
Peng et al., 2017, 2018). Contemporaneously with
this work, Hershcovich et al. (2018) proposed a
multitask learning setting for universal syntactic
dependencies and UCCA semantics (Abend and
Rappoport, 2013). Syntactic scaﬀolds focus on a
primary semantic task, treating syntax as an auxil-
lary, eventually forgettable prediction task.

4 Syntactic Scaﬀold Model

We assume two sources of supervision: a cor-
pus D1 with instances x annotated for the primary
task’s outputs y (semantic role labeling or corefer-
ence resolution), and a treebank D2 with sentences
x, each with a phrase-structure tree z.

4.1 Loss

Each task has an associated loss, and we seek to
minimize the combination of task losses,

(cid:88)

(x,y)∈D1

(cid:88)

(x,z)∈D2

L1(x, y) + δ

L2(x, z)

(1)

with respect to parameters, which are partially
shared, where δ is a tunable hyperparameter. In

Each input

the rest of this section, we describe the scaﬀold
task. We deﬁne the primary tasks in Sections 5–6.
is a sequence of tokens, x =
(cid:104)x1, x2, . . . , xn(cid:105), for some n. We refer to a span
of contiguous tokens in the sentence as xi: j =
(cid:104)xi, xi+1, . . . , x j(cid:105), for any 1 (cid:54) i (cid:54) j (cid:54) n. In our
experiments we consider only spans up to a maxi-
mum length D, resulting in O(nD) spans.

Supervision comes from a phrase-syntactic tree
z for the sentence, comprising a syntactic category
zi: j ∈ C for every span xi: j in x (many spans are
given a null label). We experiment with diﬀerent
sets of labels C (§4.2).

In our model, every span xi: j is represented by
an embedding vector vi: j (see details in §5.3). A
distribution over the category assigned to zi: j is de-
rived from vi: j:

p(zi: j = c | xi: j) = softmax

wc · vi: j

(2)

c

where wc is a parameter vector associated with
category c. We sum the log loss terms for all the
spans in a sentence to give its loss:

L2(x, z) = −

log p(zi: j | xi: j).

(3)

(cid:88)

1(cid:54)i(cid:54) j(cid:54)n
j−i(cid:54)D

4.2 Labels for the Syntactic Scaﬀold Task
Diﬀerent kinds of syntactic labels can be used for
learning syntactically-aware span representations:
• Constituent identity: C = {0, 1}; is a span a

constituent, or not?

• Non-terminal: c is the category of a span,

including a null for non-constituents.

• Non-terminal and parent: c is the category
of a span, concatenated with the category of
its immediate ancestor. null is used for non-
constituents, and for empty ancestors.

• Common non-terminals: Since a majority
of semantic arguments and entity mentions
are labeled with a small number of syntac-
tic categories,3 we experiment with a three-
way classiﬁcation among (i) noun phrase (or
prepositional phrase, for frame SRL); (ii) any
other category; and (iii) null.

In Figure 1, for the span “encouraging them”,
the constituent identity scaﬀold label is 1, the non-
terminal label is S|VP, the non-terminal and par-
ent label is S|VP+par=PP, and the common non-
terminals label is set to OTHER.

3In the OntoNotes corpus, which includes both syntac-
tic and semantic annotations, 44% of semantic arguments are
noun phrases and 13% are prepositional phrases.

5 Semantic Role Labeling

We contribute a new SRL model which contributes
a strong baseline for experiments with syntactic
scaﬀolds. The performance of this baseline itself
is competitive with state-of-the-art methods (§7).

In the FrameNet

FrameNet.
lexicon (Baker
et al., 1998), a frame represents a type of event,
situation, or relationship, and is associated with a
set of semantic roles, called frame elements. A
frame can be evoked by a word or phrase in a sen-
tence, called a target. Each frame element of an
evoked frame can then be realized in the sentence
as a sentential span, called an argument (or it can
be unrealized). Arguments for a given frame do
not overlap.

PropBank. PropBank similarly disambiguates
predicates and identiﬁes argument spans. Tar-
gets are disambiguated to lexically speciﬁc senses
rather than shared frames, and a set of generic
roles is used for all targets, reducing the argument
label space by a factor of 17. Most importantly,
the arguments were annotated on top of syntactic
constituents, directly coupling syntax and seman-
tics. A detailed example for both formalisms is
provided in Figure 1.

Semantic structure prediction is the task of iden-
tifying targets, labeling their frames or senses, and
labeling all their argument spans in a sentence.
Here we assume gold targets and frames, and con-
sider only the SRL task.

Formally, a single input instance for argument
identiﬁcation consists of: an n-word sentence x =
(cid:104)x1, x2, . . . , xn(cid:105), a single target span t = (cid:104)tstart, tend(cid:105),
f . The argu-
and its evoked frame, or sense,
ment labeling task is to produce a segmentation
of the sentence: s = (cid:104)s1, s2, . . . , sm(cid:105) for each in-
put x. A segment s = (cid:104)i, j, yi: j(cid:105) corresponds to
a labeled span of the sentence, where the label
yi: j ∈ Y f ∪ {null} is either a role that the span
ﬁlls, or null if the span does not ﬁll any role. In
the case of PropBank, Y f consists of all possible
roles. The segmentation is constrained so that ar-
gument spans cover the sentence and do not over-
lap (ik+1 = 1 + jk for sk; i1 = 1; jm = n). Segments
of length 1 such that i = j are allowed. A separate
segmentation is predicted for each target annota-
tion in a sentence.

5.1 Semi-Markov CRF

of log-likelihood:

In order to model the non-overlapping arguments
of a given target, we use a semi-Markov condi-
tional random ﬁeld (semi-CRF; Sarawagi et al.,
2004). Semi-CRFs deﬁne a conditional distribu-
tion over labeled segmentations of an input se-
quence, and are globally normalized. A single tar-
get’s arguments can be neatly encoded as a labeled
segmentation by giving the spans in between argu-
ments a reserved null label. Semi-Markov mod-
els are more powerful than BIO tagging schemes,
which have been used successfully for PropBank
SRL (Collobert et al., 2011; Zhou and Xu, 2015,
inter alia), because the semi-Markov assumption
allows scoring variable-length segments, rather
than ﬁxed-length label n-grams as under an (n −
1)-order Markov assumption. Computing the
marginal likelihood with a semi-CRF can be done
using dynamic programming in O(n2) time (§5.2).
By ﬁltering out segments longer than D tokens,
this is reduced to O(nD).

Given an input x, a semi-CRF deﬁnes a condi-
tional distribution p(s | x). Every segment s =
(cid:104)i, j, yi: j(cid:105) is given a real-valued score, ψ((cid:104)i, j, yi: j =
r(cid:105), xi: j) = wr · vi: j, where vi: j is an embedding
of the span (§5.3) and wr is a parameter vector
corresponding to its label. The score of the en-
tire segmentation s is the sum of the scores of
its segments: Ψ(x, s) = (cid:80)m
k=1 ψ(sk, xik: jk ). These
scores are exponentiated and normalized to deﬁne
the probability distribution. The sum-product vari-
ant of the semi-Markov dynamic programming al-
gorithm is used to calculate the normalization term
(required during learning). At test time, the max-
product variant returns the most probable segmen-
tation, ˆs = arg max sΨ(s, x).

The parameters of the semi-CRF are learned to
maximize a criterion related to the conditional log-
likelihood of the gold-standard segments in the
training corpus (§5.2). The learner evaluates and
adjusts segment scores ψ(sk, x) for every span in
the sentence, which in turn involves learning em-
bedded representations for all spans (§5.3).

5.2 Softmax-Margin Objective

Typically CRF and semi-CRF models are trained
to maximize a conditional log-likelihood objec-
tive.
In early experiments, we found that incor-
porating a structured cost was beneﬁcial; we do
so by using a softmax-margin training objective
(Gimpel and Smith, 2010), a “cost-aware” variant

L1 = −

(cid:88)

log

exp Ψ(s∗, x)
Z(x, s∗)

,

(cid:88)

(x,s∗)∈D1
exp {Ψ(s, x) + cost(s, s∗)}.

Z(x, s∗) =

(4)

(5)

s

(cid:88)

s∈s

We design the cost function so that it factors by
predicted span, in the same way Ψ does:

cost(s, s∗) =

cost(s, s∗) =

I(s (cid:60) s∗).

(6)

(cid:88)

s∈s

The softmax-margin criterion, like log-likelihood,
is globally normalized over all of the exponentially
many possible labeled segmentations. The follow-
ing zeroth-order semi-Markov dynamic program
(Sarawagi et al., 2004) eﬃciently computes the
new partition function:
(cid:88)

αi−1 exp{Ψ(s, x) + cost(s, s∗)},

(7)

α j =

s=(cid:104)i, j,yi: j(cid:105)
j−i(cid:54)D

where Z = αn, under the base case α0 = 1.

The prediction under the model can be calcu-
lated using a similar dynamic program with the
following recurrence where γ0 = 1:

γ j = max
s=(cid:104)i, j,yi: j(cid:105)
j−i(cid:54)D

γi−1 exp Ψ(s, x).

(8)

Our model formulation enforces that arguments do
not overlap. We do not enforce any other SRL
constraints, such as non-repetition of core frame
elements (Das et al., 2012).

5.3

Input Span Representation

This section describes the neural architecture used
to obtain the span embedding, vi: j, correspond-
ing to a span xi: j and the target in consideration,
t = (cid:104)tstart, tend(cid:105). For the scaﬀold task, since the
syntactic treebank does not contain annotations for
semantic targets, we use the last verb in the sen-
tence as a placeholder target, wherever target fea-
tures are used. If there are no verbs, we use the
ﬁrst token in the sentence as a placeholder target.
The parameters used to learn v are shared between
the tasks.

We construct an embedding for the span using
• hi and h j: contextualized embeddings for the

words at the span boundary (§5.3.1),

• ui: j: a span summary that pools over the con-

tents of the span (§5.3.2), and

• ai: j: and a hand-engineered feature vector for

the span (§5.3.3).

This embedding is then passed to a feedforward

layer to compute the span representation, vi: j.

5.3.1 Contextualized Token Embeddings

To obtain contextualized embeddings of each to-
ken in the input sequence, we run a bidirectional
LSTM (Graves, 2012) with (cid:96) layers over the full
input sequence. To indicate which token is a pred-
icate, a linearly transformed one-hot embedding v
is used, following Zhou and Xu (2015) and He
et al. (2017). The input vector representing the
token at position q in the sentence is the concate-
nation of a ﬁxed pretrained embedding xq and vq.
When given as input to the bidirectional LSTM,
this yields a hidden state vector hq representing
the qth token in the context of the sentence.

5.3.2 Span Summary
Tokens within a span might convey diﬀerent
amounts of information necessary to label the span
as a semantic argument. Following Lee et al.
(2017), we use an attention mechanism (Bahdanau
et al., 2014) to summarize each span. Each con-
textualized token in the span is passed through a
feed-forward network to obtain a weight, normal-
ized to give σk = softmax
whead · hk, where whead
is a learned parameter. The weights σ are then
used to obtain a vector that summarizes the span,
ui: j = (cid:80)

i(cid:54)k(cid:54) j; j−i<D σk · hk.

i(cid:54)k(cid:54) j

5.3.3 Span Features

We use the following three features for each span:
• width of the span in tokens (Das et al., 2014)
• distance (in tokens) of the span from the tar-

get (T¨ackstr¨om et al., 2015)

• position of the span with respect to the tar-
get (before, after, overlap) (T¨ackstr¨om et al.,
2015)

Each of these features is encoded as a one-hot-
embedding and then linearly transformed to yield
a feature vector, ai: j.

6 Coreference Resolution

Coreference resolution is the task of determin-
ing clusters of mentions that refer to the same
entity. Formally, the input is a document x =
x1, x2, . . . , xn consisting of n words. The goal is
to predict a set of clusters c = {c1, c2, . . .}, where
each cluster c = {s1, s2, . . .} is a set of spans and

each span s = (cid:104)i, j(cid:105) is a pair of indices such that
1 (cid:54) i (cid:54) j (cid:54) n.

As a baseline, we use the model of Lee et al.
(2017), which we describe brieﬂy in this section.
This model decomposes the prediction of coref-
erence clusters into a series of span classiﬁcation
decisions. Every span s predicts an antecedent
ws ∈ Y(s) = {null, s1, s2, . . . , sm}. Labels s1 to
sm indicate a coreference link between s and one
of the m spans that precede it, and null indicates
that s does not link to anything, either because it
is not a mention or it is in a singleton cluster. The
predicted clustering of the spans can be recovered
by aggregating the predicted links.

Analogous to the SRL model (§5), every span
s is represented by an embedding vs, which is
central to the model. For each span s and a po-
tential antecedent a ∈ Y(s), pairwise coreference
scores Ψ(vs, va, φ(s, a)) are computed via feedfor-
ward networks with the span embeddings as input.
φ(s, a) are pairwise discrete features encoding the
distance between span s and span a and metadata,
such as the genre and speaker information. We re-
fer the reader to Lee et al. (2017) for the details of
the scoring function.

The scores from Ψ are normalized over the pos-
sible antecedents Y(s) of each span to induce a
probability distribution for every span:

p(ws = a) = softmax
a∈Y(s)

Ψ(vs, va, φ(s, a))

(9)

In learning, we minimize the negative log-
likelihood marginalized over the possibly correct
antecedents:

L1 = −

(cid:88)

log

(cid:88)

p(ws = a∗)

(10)

s∈D

a∗∈G(s)∩Y(s)

where D is the set of spans in the training dataset,
and G(s) indicates the gold cluster of s if it belongs
to one and {null} otherwise.

To operate under reasonable computational re-
quirements, inference under this model requires a
two-stage beam search, which reduces the number
of span pairs considered. We refer the reader to
Lee et al. (2017) for details.

Input span representation. The input span em-
bedding, vs for coreference resolution and its syn-
tactic scaﬀold follow the deﬁnition used in §5.3,
with the key diﬀerence of using no target features.
Since there is a complete overlap of input sen-
tences between Dsc and Dpr as the coreference an-
notations are also from OntoNotes (Pradhan et al.,

2012), we reuse the v for the scaﬀold task. Addi-
tionally, instead of the entire document, each sen-
tence in it is independently given as input to the
bidirectional LSTMs.

7 Results

We evaluate our models on the test set of
FrameNet 1.5 for frame SRL and on the test set
of OntoNotes for both PropBank SRL and coref-
erence. For the syntactic scaﬀold in each case,
we use syntactic annotations from OntoNotes
5.0 (Weischedel et al., 2013; Pradhan et al.,
2013).4 Further details on experimental settings
and datasets have been elaborated in the supple-
mental material.

Frame SRL. Table 1 shows the performance of
all the scaﬀold models on frame SRL with respect
to prior work and a semi-CRF baseline (§5.1)
without a syntactic scaﬀold. We follow the oﬃ-
cial evaluation from the SemEval shared task for
frame-semantic parsing (Baker et al., 2007).

Prior work for frame SRL has relied on pre-
dicted syntactic trees, in two diﬀerent ways: by
using syntax-based rules to prune out spans of text
that are unlikely to contain any frame’s argument;
and by using syntactic features in their statistical
model (Das et al., 2014; T¨ackstr¨om et al., 2015;
FitzGerald et al., 2015; Kshirsagar et al., 2015).

The best published results on FrameNet 1.5 are
due to Yang and Mitchell (2017). In their sequen-
tial model (seq), they treat argument identiﬁcation
as a sequence-labeling problem using a deep bidi-
rectional LSTM with a CRF layer. In their rela-
tional model (Rel), they treat the same problem as
a span classiﬁcation problem. Finally, they intro-
duce an ensemble to integerate both models, and
use an integer linear program for inference satis-
fying SRL constraints. Though their model does
not do any syntactic pruning, it does use syntactic
features for argument identiﬁcation and labeling.5
Notably, all prior systems for frame SRL listed
in Table 1 use a pipeline of syntax and seman-
tics. Our semi-CRF baseline outperforms all prior
work, without any syntax. This highlights the ben-

4http://cemantix.org/data/ontonotes.html
5Yang and Mitchell (2017) also evaluated on the full
frame-semantic parsing task, which includes frame-SRL as
well as identifying frames. Since our frame SRL performance
improves over theirs, we expect that incorporation into a full
system (e.g., using their frame identiﬁcation module) would
lead to overall beneﬁts as well; this experiment is left to fu-
ture work.

eﬁts of modeling spans and of global normaliza-
tion.

Turning to scaﬀolds, even the most coarse-
grained constituent identity scaﬀold improves the
performance of our syntax-agnostic baseline. The
nonterminal and nonterminal and parent scaﬀolds,
which use more detailed syntactic representations,
improve over this. The greatest improvements
come from the scaﬀold model predicting com-
mon nonterminal labels (NP and PP, which are the
most common syntactic categories of semantic ar-
guments, vs. others): 3.6% absolute improvement
in F1 measure over prior work.

Contemporaneously with this work, Peng et al.
(2018) proposed a system for joint frame-semantic
and semantic dependency parsing. They report re-
sults for joint frame and argument identiﬁcation,
and hence cannot be directly compared in Table 1.
We evaluated their output for argument identiﬁca-
tion only; our semi-CRF baseline model exceeds
their performance by 1 F1, and our common non-
terminal scaﬀold by 3.1 F1.6

Model

Prec. Rec.

Kshirsagar et al. (2015)
Yang and Mitchell (2017) (Rel)
Yang and Mitchell (2017) (Seq)
†Yang and Mitchell (2017) (All)

Semi-CRF baseline

+ constituent identity
+ nonterminal and parent
+ nonterminal
+ common nonterminals

66.0
71.8
63.4
70.2

67.8

68.1
68.8
69.4
69.2

60.4
57.7
66.4
60.2

66.2

67.4
68.2
68.0
69.0

F1

63.1
64.0
64.9
65.5

67.0

67.7
68.5
68.7
69.1

Table 1: Frame SRL results on the test set of
FrameNet 1.5., using gold frames. Ensembles are
denoted by †.

Model

Prec. Rec.

Zhou and Xu (2015)
He et al. (2017)
He et al. (2018a)
Tan et al. (2018)

Semi-CRF baseline

+ common nonterminals

-
81.7
83.9
81.9

84.8

85.1

-
81.6
73.7
83.6

81.2

82.6

F1

81.3
81.7
82.1
82.7

83.0

83.8

Table 2: PropBank sSRL results, using gold pred-
icates, on CoNLL 2012 test. For fair comparison,
we show only non-ensembled models.

6This result is not reported in Table 1 since Peng et al.
(2018) used a preprocessing which renders the test set slightly
larger — the diﬀerence we report is calculated using their test
set.

Model

MUC
Prec. Rec. F1

B3
Prec. Rec. F1

CEAFφ4
Prec. Rec. F1

Avg. F1

Wiseman et al. (2016)
77.5 69.8 73.4
Clark and Manning (2016b) 79.9 69.3 74.2
Clark and Manning (2016a) 79.2 70.4 74.6

66.8 57.0 61.5
71.0 56.5 63.0
69.9 58.0 63.4

62.1 53.9 57.7
63.8 54.3 58.7
63.5 55.5 59.2

Lee et al. (2017)

78.4 73.4 75.8
+ common nonterminals 78.4 74.3 76.3

68.6 61.8 65.0

62.7 59.0 60.8

68.7 62.9 65.7

62.9 60.2 61.5

64.2
65.3
65.7

67.2

67.8

Table 3: Coreference resolution results on the test set on the English CoNLL-2012 shared task. The
average F1 of MUC, B3, and CEAFφ4 is the main evaluation metric. For fair comparison, we show only
non-ensembled models.

PropBank SRL. We use the OntoNotes data
from the CoNLL shared task in 2012 (Pradhan
et al., 2013) for Propbank SRL. Table 2 reports
results using gold predicates.

Recent competitive systems for PropBank SRL
follow the approach of Zhou and Xu (2015), em-
ploying deep architectures, and forgoing the use of
any syntax. He et al. (2017) improve on those re-
sults, and in analysis experiments, show that con-
straints derived using syntax may further improve
performance. Tan et al. (2018) employ a similar
approach but use feed-forward networks with self-
attention. He et al. (2018a) use a span-based clas-
siﬁcation to jointly identify and label argument
spans.

Our syntax-agnostic semi-CRF baseline model
improves on prior work (excluding ELMo), show-
ing again the value of global normalization in se-
mantic structure prediction. We obtain further im-
provement of 0.8 absolute F1 with the best syn-
tactic scaﬀold from the frame SRL task. This in-
dicates that a syntactic inductive bias is beneﬁ-
cial even when using sophisticated neural archi-
tectures.

He et al. (2018a) also provide a setup where ini-
tialization was done with deep contextualized em-
beddings, ELMo (Peters et al., 2018), resulting in
85.5 F1 on the OntoNotes test set. The improve-
ments from ELMo are methodologically orthogonal
to syntactic scaﬀolds.

Since the datasets for learning PropBank se-
mantics and syntactic scaﬀolds completely over-
lap, the performance improvement cannot be at-
tributed to a larger training corpus (or, by exten-
sion, a larger vocabulary), though that might be a
factor for frame SRL.

A syntactic scaﬀold can match the performance
of a pipeline containing carefully extracted syntac-
tic features for semantic prediction (Swayamdipta
et al., 2017). This, along with other recent ap-

proaches (He et al., 2017, 2018b) show that syntax
remains useful, even with strong neural models for
SRL.

Coreference. We report the results on four stan-
dard scores from the CoNLL evaluation: MUC, B3
and CEAFφ4, and their average F1 in Table 3. Prior
competitive coreference resolution systems (Wise-
man et al., 2016; Clark and Manning, 2016b,a) all
incorporate synctactic information in a pipeline,
using features and rules for mention proposals
from predicted syntax.

Our baseline is the model from Lee et al.
(2017), described in §6. Similar to the baseline
model for frame SRL, and in contrast with prior
work, this model does not use any syntax.

We experiment with the best syntactic scaﬀold
from the frame SRL task. We used NP, OTHER, and
null as the labels for the common nonterminals
scaﬀold here, since coreferring mentions are rarely
prepositional phrases. The syntactic scaﬀold out-
performs the baseline by 0.6 absolute F1. Contem-
poraneously, Lee et al. (2018) proposed a model
which takes in account higher order inference and
more aggressive pruning, as well as initialization
with ELMo embeddings, resulting in 73.0 average
F1. All the above are orthogonal to our approach,
and could be incorporated to yield higher gains.

8 Discussion

To investigate the performance of the syntactic
scaﬀold, we focus on the frame SRL results, where
we observed the greatest improvement with re-
spect to a non-syntactic baseline.

We consider a breakdown of the performance
by the syntactic phrase types of the arguments,
provided in FrameNet7 in Figure 2. Not surpris-

7We used FrameNet syntactic phrase annotations for anal-
ysis only, and not in our models, since they are annotated only
for the gold arguments.

Figure 2: Performance breakdown by argu-
ment’s phrase category, sorted left to right by
frequency, for top ten phrase categories.

Figure 3: Performance breakdown by top ten
frame element types, sorted left to right by fre-
quency.

ingly, we observe large improvements in the com-
mon nonterminals used (NP and PP). However,
the phrase type annotations in FrameNet do not
correspond exactly to the OntoNotes phrase cat-
egories. For instance, FrameNet annotates non-
maximal (A) and standard adjective phrases (AJP),
while OntoNotes annotations for noun-phrases are
ﬂat, ignore the underlying adjective phrases. This
explains why the syntax-agnostic baseline is able
to recover the former while the scaﬀold is not.

Similarly, for frequent frame elements, scaﬀold-
ing improves performance across the board, as
shown in Fig. 3. The largest improvements come
for Theme and Goal, which are predominantly re-
alized as noun phrases and prepositional phrases.

9 Conclusion

We introduced syntactic scaﬀolds, a multitask
learning approach to incorporate syntactic bias
into semantic processing tasks. Unlike pipelines
and approaches which jointly model syntax and
semantics, no explicit syntactic processing is re-
quired at runtime. Our method improves the per-
formance of competitive baselines for semantic
role labeling on both FrameNet and PropBank,
and for coreference resolution. While our focus
was on span-based tasks, syntactic scaﬀolds could
be applied in other settings (e.g., dependency and
graph representations). Moreover, scaﬀolds need
not be syntactic; we can imagine, for example, se-
mantic scaﬀolds being used to improve NLP appli-
cations with limited annotated data. It remains an
open empirical question to determine the relative
merits of diﬀerent kinds of scaﬀolds and multi-
task learners, and how they can be most produc-

tively combined. Our code is publicly available at
https://github.com/swabhs/scaffolding.

Acknowledgments

We thank several members of UW-NLP, partic-
ularly Luheng He, as well as David Weiss and
Emily Pitler for thoughtful discussions on prior
versions of this paper. We also thank the three
anonymous reviewers for their valuable feedback.
This work was supported in part by NSF grant IIS-
1562364 and by the NVIDIA Corporation through
the donation of a Tesla GPU.

References

Omri Abend and Ari Rappoport. 2013. Universal Con-
ceptual Cognitive Annotation (UCCA). In ACL.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2014. Neural machine translation by jointly
learning to align and translate. ArXiv:1409.0473.

Collin Baker, Michael Ellsworth, and Katrin Erk. 2007.
SemEval’07 Task 19: Frame semantic structure ex-
traction. In Proc. of SemEval.

Collin F. Baker, Charles J. Fillmore, and John B. Lowe.
1998. The Berkeley FrameNet project. In Proc. of
ACL.

Rich Caruana. 1997. Multitask learning. Machine

Learning, 28(1).

Xinchi Chen, Zhan Shi, Xipeng Qiu, and Xuanjing
Huang. 2017. Adversarial multi-criteria learning for
chinese word segmentation. ArXiv:1704.07556.

Kevin Clark and Christopher D Manning. 2016a. Deep
reinforcement learning for mention-ranking corefer-
ence models. In Proc. of EMNLP.

Kevin Clark and Christopher D. Manning. 2016b. Im-
proving coreference resolution by learning entity-
level distributed representations. In Proc. of ACL.

Luheng He, Kenton Lee, Mike Lewis, and Luke Zettle-
moyer. 2017. Deep semantic role labeling: What
works and what’s next. In Proc. of ACL.

Ronan Collobert, Jason Weston, L´eon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
Journal of Machine Learning Research,
scratch.
12:2493–2537.

Ann Copestake and Dan Flickinger. 2000.

An
open source grammar development environment and
broad-coverage English grammar using HPSG.
In
Proc. of LREC.

Dipanjan Das, Desai Chen, Andr´e FT Martins, Nathan
Frame-
linguistics,

Schneider, and Noah A Smith. 2014.
semantic parsing.
40(1):9–56.

Computational

Dipanjan Das, Andr´e F. T. Martins, and Noah A. Smith.
2012. An exact dual decomposition algorithm for
shallow semantic parsing with constraints. In Proc.
of *SEM.

Jenny Rose Finkel, Christopher D Manning, and An-
drew Y Ng. 2006. Solving the problem of cascading
errors: Approximate bayesian inference for linguis-
tic annotation pipelines. In Proc. of EMNLP.

Nicholas FitzGerald, Oscar T¨ackstr¨om, Kuzman
Ganchev, and Dipanjan Das. 2015. Semantic role
In Proc. of
labeling with neural network factors.
EMNLP.

Shexia He, Zuchao Li, Hai Zhao, and Hongxiao Bai.
2018b. Syntax for semantic role labeling, to be, or
not to be. In Proc. of ACL.

James Henderson, Paola Merlo,

Ivan Titov, and
Gabriele Musillo. 2013. Multi-lingual joint pars-
ing of syntactic and semantic dependencies with a
latent variable model. Computational Linguistics,
39(4):949–998.

Daniel Hershcovich, Omri Abend, and Ari Rappoport.
2018. Multitask parsing across semantic representa-
tions. In Proc. of ACL.

Diederik

P. Kingma

2014.
and
ADAM: A method for stochastic optimization.
ArXiV:1412.6980.

Jimmy Ba.

Lingpeng Kong, Chris Dyer, and Noah A. Smith. 2016.
Segmental Recurrent Neural Networks. In Proc. of
ICLR.

Meghana Kshirsagar, Sam Thomson, Nathan Schnei-
der, Jaime Carbonell, Noah A Smith, and Chris
Dyer. 2015. Frame-semantic role labeling with het-
erogeneous annotations. In Proc. of NAACL.

Kenton Lee, Luheng He, Mike Lewis, and Luke Zettle-
moyer. 2017. End-to-end neural coreference resolu-
tion. In Proc. of EMNLP.

Daniel Gildea and Daniel Jurafsky. 2002. Automatic
labeling of semantic roles. Computational Linguis-
tics, 28(3):245–288.

Kenton Lee, Luheng He, and Luke Zettlemoyer. 2018.
Higher-order coreference resolution with coarse-to-
ﬁne inference. In Proc. of NAACL.

Daniel Gildea and Martha Palmer. 2002. The necessity
of parsing for predicate argument recognition.
In
Proc. of ACL.

Kevin Gimpel and Noah A. Smith. 2010. Softmax-
margin CRFs: Training log-linear models with cost
functions. In Proc. of NAACL.

Alex Graves. 2012. Supervised Sequence Labelling
with Recurrent Neural Networks, volume 385 of
Studies in Computational Intelligence. Springer.

Alex Graves. 2013. Generating sequences with recur-

rent neural networks. ArXiv:1308.0850.

Kazuma Hashimoto, Caiming Xiong, Yoshimasa Tsu-
ruoka, and Richard Socher. 2017. A joint many-task
model: Growing a neural network for multiple NLP
tasks. In Proc. of EMNLP.

He He, Hal Daum´e III, and Jason Eisner. 2013. Dy-
namic feature selection for dependency parsing. In
Proc. of EMNLP.

Luheng He, Kenton Lee, Omer Levy, and Luke Zettle-
moyer. 2018a. Jointly predicting predicates and ar-
guments in neural semantic role labeling. In Proc.
of ACL.

Xavier Llu´ıs, Xavier Carreras, and Llu´ıs M`arquez.
2013.
Joint arc-factored parsing of syntactic and
semantic dependencies. Transactions of the ACL,
1:219–230.

Xavier Llu´ıs and Llu´ıs M`arquez. 2008. A joint model
for parsing syntactic and semantic dependencies. In
Proc. of CoNLL.

Minh-Thang Luong, Quoc V Le, Ilya Sutskever, Oriol
Vinyals, and Lukasz Kaiser. 2015. Multi-task se-
quence to sequence learning. ArXiv:1511.06114.

Tomas Mikolov, Kai Chen, Gregory S. Corrado, and
Jeﬀrey Dean. 2013. Eﬃcient estimation of word
representations in vector space. ArXiv:1301.3781.

Vinod Nair and Geoﬀrey E. Hinton. 2010. Rectiﬁed
linear units improve restricted Boltzmann machines.
In Proc. of ICML.

Jason Naradowsky, Sebastian Riedel, and David A.
Improving NLP through marginal-
In Proc. of

Smith. 2012.
ization of hidden syntactic structure.
EMNLP.

Vincent Ng. 2010. Supervised noun phrase coreference
research: The ﬁrst ﬁfteen years. In Proc. of ACL.

Martha Palmer, Daniel Gildea, and Paul Kingsbury.
2005. The Proposition Bank: An annotated cor-
pus of semantic roles. Computational Linguistics,
31(1):71–106.

Swabha Swayamdipta, Sam Thomson, Chris Dyer, and
Noah A. Smith. 2017. Frame-semantic parsing with
softmax-margin segmental rnns and a syntactic scaf-
fold. Arxiv:1706.09528.

Hao Peng, Sam Thomson, and Noah A. Smith. 2017.
Deep multitask learning for semantic dependency
parsing. In Proc. of ACL.

Hao Peng, Sam Thomson, Swabha Swayamdipta, and
Noah A. Smith. 2018. Learning joint semantic
parsers from disjoint data. In Proc. of NAACL.

Jeﬀrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. GloVe: Global vectors for
word representation. In Proc. of EMNLP.

Matthew E Peters, Mark Neumann, Mohit Iyyer, Matt
Gardner, Christopher Clark, Kenton Lee, and Luke
Zettlemoyer. 2018. Deep contextualized word rep-
resentations. ArXiv:1802.05365.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Hwee Tou Ng, Anders Bj¨orkelund, Olga Uryupina,
Yuchen Zhang, and Zhi Zhong. 2013. Towards ro-
bust linguistic analysis using OntoNotes. In Proc. of
CoNLL.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Olga Uryupina, and Yuchen Zhang. 2012. CoNLL-
2012 shared task: Modeling multilingual unre-
In Proc. of
stricted coreference in OntoNotes.
EMNLP.

Vasin Punyakanok, Dan Roth, and Wen-tau Yih. 2008.
The importance of syntactic parsing and inference in
semantic role labeling. Computational Linguistics,
34(2):257–287.

Pranav Rajpurkar,

Jian Zhang, Konstantin Lopy-
rev, and Percy Liang. 2016. SQuAD: 100,000+
questions for machine comprehension of
text.
ArXiv:1606.05250.

Oscar T¨ackstr¨om, Kuzman Ganchev, and Dipanjan
Das. 2015. Eﬃcient inference and structured learn-
ing for semantic role labeling. Transactions of the
ACL, 3:29–41.

Zhixing Tan, Mingxuan Wang, Jun Xie, Yidong Chen,
and Xiaodong Shi. 2018. Deep semantic role label-
ing with self-attention. In Proc. of AAAI.

Kristina Toutanova, Aria Haghighi, and Christopher D.
joint model for se-
Manning. 2008. A global
mantic role labeling. Computational Linguistics,
34(2):161–191.

Ralph Weischedel, Martha Palmer, Mitchell Marcus,
Eduard Hovy, Sameer Pradhan, Lance Ramshaw,
Nianwen Xue, Ann Taylor, Jeﬀ Kaufman, Michelle
Franchini, et al. 2013. OntoNotes release 5.0
ldc2013t19. Linguistic Data Consortium, Philadel-
phia, PA.

Sam Wiseman, Alexander M Rush, and Stuart M
Shieber. 2016. Learning global features for coref-
erence resolution. In Proc. of NAACL.

David H Wolpert. 1992. Stacked generalization. Neu-

ral networks, 5(2):241–259.

Bishan Yang and Tom Mitchell. 2017. A joint sequen-
tial and relational model for frame-semantic parsing.
In Proc. of EMNLP.

Luke S Zettlemoyer and Michael Collins. 2005. Learn-
ing to map sentences to logical form: Structured
classiﬁcation with probabilistic categorial gram-
mars. In Proc. of UAI.

Yuan Zhang and David Weiss. 2016.

Stack-
propagation: Improved representation learning for
syntax. In Proc. of ACL.

Sunita Sarawagi, William W Cohen, et al. 2004. Semi-
markov conditional random ﬁelds for information
extraction. In Proc. of NIPS, volume 17.

Jie Zhou and Wei Xu. 2015. End-to-end learning of
semantic role labeling using recurrent neural net-
works. In Proc. of ACL.

Anders Søgaard and Yoav Goldberg. 2016. Deep
multi-task learning with low level tasks supervised
at lower layers. In Proc. of ACL.

Rupesh Kumar Srivastava, Klaus Greﬀ, and J¨urgen
Schmidhuber. 2015. Training very deep networks.
In Proc. of NIPS.

Mark Steedman. 2000.

Information structure and
the syntax-phonology interface. Linguistic Inquiry,
31(4):649–689.

Swabha Swayamdipta, Miguel Ballesteros, Chris Dyer,
and Noah A. Smith. 2016. Greedy, joint syntactic-
In Proc. of
semantic parsing with Stack LSTMs.
CoNLL.

We limit the maximum length of spans to D =
15 in FrameNet, resulting in oracle recall of 95%
on the development set, and to 13 in Propbank,
resulting in an oracle recall of 96%. An identical
maximum span length is used for the scaﬀold task.
For the SRL scaﬀolds, we randomly sample in-
stances from OntoNotes to match the size of the
SRL data, and alternate between training an SRL
batch and a scaﬀold batch.
In FrameNet, this
amounts to downsampling OntoNotes. For Prop-
Bank SRL, this amounts to upsampling syntactic
annotations from OntoNotes, since a sentence has
a single syntactic tree, but could have multiple tar-
get annotations, each of which is a training in-
stance.

The mixing ratio, δ is set to 1.0 (tuned across
{0.1, 0.5, 1.0, 1.5}) for frame and PropBank SRL.
We use Adam (Kingma and Ba, 2014) for opti-
mization, at a learning rate of 0.001, and a mini-
batch of size 32. Our dynamic program formula-
tion for loss computation and inference under the
semi-CRF is also batched. To prevent exploding
gradients, the 2-norm of the gradient is clipped
to 1 before a gradient update (Graves, 2013). All
models are trained for a maximum of 20 epochs,
and stopped early based on dev F1.

We extended the AllenNLP library,9 which is
built on top of PyTorch.10 Each experiment was
run on a single TitanX GPU.

For the coreference model, we use the same
hyperparameters and experimental settings from
Lee et al. (2017). The only new hyperparameter
needed for scaﬀolding is the mixing ratio, δ, which
we set to 0.1 based on performance on the valida-
tion set.

A Supplementary Material

A.1 Datasets

We used the full-text portion of FrameNet 1.5 re-
lease8 for frame-semantic role labeling. We use
the same test set as Das et al. (2014), and cre-
ate a validation set by selecting 8 documents from
the train set. The dataset contains 3,139 train sen-
tences with 16,621 target annotations, 387 valida-
tion sentences with 2,282 targets, and 2,420 test
sentences with 4,427 targets. Each target from a
given sentence is treated as an independent train-
ing instance. Following T¨ackstr¨om et al. (2015),
we only use the ﬁrst annotation for each target
with multiple annotations.

We use

the standard splits provided in
OntoNotes for the CoNLL 2012 shared task.
The dataset contains 115,812 train sentences with
278,026 target annotations, 15,680 validation sen-
tences with 38,377 targets, and 12,217 test sen-
tences with 29,669 targets.

We use the English coreference resolution data
from the CoNLL 2012 shared task (Pradhan et al.,
2012), containing 2,802, 343 and 348 documents
for train, validation, and test respectively.

Syntax OntoNotes contains 115,812 training in-
stances for the syntactic scaﬀold. There is no
overlap between FrameNet and OntoNotes train-
ing data.

A.2 Experimental Settings

We used GloVe embeddings (Pennington et al.,
2014) for tokens in the vocabulary, with out of
vocabulary words being initialized randomly. For
frame-SRL, 300 dimensional embeddings were
used, and kept ﬁxed during training. For Prop-
Bank SRL, we used 100 dimensional embed-
dings which were updated during training. A
100-dimensional embedding is learned for indi-
cating target positions, following Zhou and Xu
(2015). Bidirectional LSTMs with highway con-
nections (Srivastava et al., 2015) between 6 layers
are used, each layer containing 300-dimensional
hidden states. A dropout of 0.1 is applied to the
LSTMs. The feed-forward networks are of di-
mension 150 and of depth 2, with rectiﬁed linear
units (Nair and Hinton, 2010). A dropout of 0.2 is
applied to the feed-forward networks.

8A later release, 1.7 is also available, but for ease of com-
parison to other published systems we report results on the
earlier release.

9http://allennlp.org/
10http://pytorch.org/

Syntactic Scaﬀolds for Semantic Structures

Swabha Swayamdipta♠

Sam Thomson♠

Kenton Lee♦ Luke Zettlemoyer(cid:114) Chris Dyer♥ Noah A. Smith(cid:114)♣

♠Language Technologies Institute, Carnegie Mellon University, Pittsburgh, PA, USA
♦Google AI Language, Seattle WA, USA
(cid:114)Paul G. Allen School of Computer Science & Engineering, University of Washington, Seattle, WA, USA
♥Google DeepMind, London, UK
♣Allen Institute for Artiﬁcial Intelligence, Seattle, WA, USA
{swabha,sammthomson}@cs.cmu.edu {kentonl,cdyer}@google.com
{lsz,nasmith}@cs.washington.edu

8
1
0
2
 
g
u
A
 
0
3
 
 
]
L
C
.
s
c
[
 
 
1
v
5
8
4
0
1
.
8
0
8
1
:
v
i
X
r
a

Abstract

We introduce the syntactic scaﬀold, an ap-
proach to incorporating syntactic informa-
tion into semantic tasks. Syntactic scaﬀolds
avoid expensive syntactic processing at run-
time, only making use of a treebank during
training, through a multitask objective. We im-
prove over strong baselines on PropBank se-
mantics, frame semantics, and coreference res-
olution, achieving competitive performance on
all three tasks.

1

Introduction

As algorithms for the semantic analysis of natu-
ral language sentences have developed, the role
of syntax has been repeatedly revisited. Linguis-
tic theories have argued for a very tight integra-
tion of syntactic and semantic processing (Steed-
man, 2000; Copestake and Flickinger, 2000), and
many systems have used syntactic dependency
or phrase-based parsers as preprocessing for se-
mantic analysis (Gildea and Palmer, 2002; Pun-
yakanok et al., 2008; Das et al., 2014). Mean-
while, some recent methods forgo explicit syntac-
tic processing altogether (Zhou and Xu, 2015; He
et al., 2017; Lee et al., 2017; Peng et al., 2017).

Because annotated training datasets for se-
mantics will always be limited, we expect that
syntax—which oﬀers an incomplete but poten-
tially useful view of semantic structure—will con-
tinue to oﬀer useful inductive bias, encouraging
semantic models toward better generalization. We
address the central question: is there a way for se-
mantic analyzers to beneﬁt from syntax without
the computational cost of syntactic parsing?

We propose a multitask learning approach to
incorporating syntactic information into learned

representations of neural semantics models (§2).
Our approach, the syntactic scaﬀold, minimizes
an auxiliary supervised loss function, derived from
a syntactic treebank. The goal is to steer the dis-
tributed, contextualized representations of words
and spans toward accurate semantic and syntactic
labeling. We avoid the cost of training or execut-
ing a full syntactic parser, and at test time (i.e.,
runtime in applications) the semantic analyzer has
no additional cost over a syntax-free baseline. Fur-
ther, the method does not assume that the syntactic
treebank overlaps the dataset for the primary task.
Many semantic tasks involve labeling spans, in-
cluding semantic role labeling (SRL; Gildea and
Jurafsky, 2002) and coreference resolution (Ng,
2010) (tasks we consider in this paper), as well
as named entity recognition and some reading
comprehension and question answering tasks (Ra-
jpurkar et al., 2016).
These spans are usu-
ally syntactic constituents (cf. PropBank; Palmer
et al., 2005), making phrase-based syntax a natu-
ral choice for a scaﬀold. See Figure 1 for an ex-
ample sentence with syntactic and semantic anno-
tations. Since the scaﬀold task is not an end in
itself, we relax the syntactic parsing problem to
a collection of independent span-level predictions,
with no constraint that they form a valid parse tree.
This means we never need to run a syntactic pars-
ing algorithm.

Our experiments demonstrate that the syntactic
scaﬀold oﬀers a substantial boost to state-of-the-
art baselines for two SRL tasks (§5) and corefer-
ence resolution (§6). Our models use the strongest
available neural network architectures for these
tasks, integrating deep representation learning (He
et al., 2017) and structured prediction at the level
of spans (Kong et al., 2016). For SRL, the base-

Figure 1: An example sentence with syntactic, PropBank and coreference annotations from OntoNotes,
and author-annotated frame-semantic structures. PropBank SRL arguments and coreference mentions are
annotated on top of syntactic constituents. All but one frame-semantic argument (Event) is a syntactic
constituent. Targets evoke frames shown in the color-coded layers.

line itself is a novel globally normalized structured
conditional random ﬁeld, which outperforms the
previous state of the art.1 Syntactic scaﬀolds re-
sult in further improvements over prior work—
3.6 absolute F1 in FrameNet SRL, 1.1 absolute
F1 in PropBank SRL, and 0.6 F1 in coreference
resolution (averaged across three standard scores).
Our code is open source and available at https:
//github.com/swabhs/scaffolding.

2 Syntactic Scaﬀolds

Multitask learning (Caruana, 1997) is a collec-
tion of techniques in which two or more tasks are
learned from data with at least some parameters
shared. We assume there is only one task about
whose performance we are concerned, denoted T1
(in this paper, T1 is either SRL or coreference res-
olution). We use the term “scaﬀold” to refer to
a second task, T2, that can be combined with T1
during multitask learning. A scaﬀold task is only
used during training; it holds no intrinsic interest
beyond biasing the learning of T1, and after learn-
ing is completed, the scaﬀold is discarded.

A syntactic scaﬀold is a task designed to steer
the (shared) model toward awareness of syntactic

1This excludes models initialized with deep, contextual-
ized embeddings (Peters et al., 2018), an approach orthogonal
to ours.

structure.
It could be deﬁned through a syntac-
tic parser that shares some parameters with T1’s
model. Since syntactic parsing is costly, we use
simpler syntactic prediction problems (discussed
below) that do not produce whole trees.

As with multitask learning in general, we do not
assume that the same data are annotated with out-
puts for T1 and T2.
In this work, T2 is deﬁned
using phrase-structure syntactic annotations from
OntoNotes 5.0 (Weischedel et al., 2013; Pradhan
et al., 2013). We experiment with three settings:
one where the corpus for T2 does not overlap with
the training datasets for T1 (frame-SRL) and two
where there is a complete overlap (PropBank SRL
and coreference). Compared to approaches which
require multiple output labels over the same data,
we oﬀer the major advantage of not requiring any
assumptions about, or speciﬁcation of, the rela-
tionship between T1 and T2 output.

3 Related Work

We brieﬂy contrast the syntactic scaﬀold with ex-
isting alternatives.

Pipelines.
In a typical pipeline, T1 and T2 are
separately trained, with the output of T2 used to
deﬁne the inputs to T1 (Wolpert, 1992). Using
syntax as T2 in a pipeline is perhaps the most

common approach for semantic structure predic-
tion (Toutanova et al., 2008; Yang and Mitchell,
2017; Wiseman et al., 2016).2 However, pipelines
introduce the problem of cascading errors (T2’s
mistakes aﬀect the performance, and perhaps the
training, of T1; He et al., 2013). To date, reme-
dies to cascading errors are so computationally ex-
pensive as to be impractical (e.g., Finkel et al.,
2006). A syntactic scaﬀold is quite diﬀerent from
a pipeline since the output of T2 is never explicitly
used.

Latent variables. Another solution is to treat
the output of T2 as a (perhaps structured) la-
tent variable. This approach obviates the need
of supervision for T2 and requires marginalization
(or some approximation to it) in order to reason
about the outputs of T1. Syntax as a latent vari-
able for semantics was explored by Zettlemoyer
and Collins (2005) and Naradowsky et al. (2012).
Apart from avoiding marginalization, the syntactic
scaﬀold oﬀers a way to use auxiliary syntactically-
annotated data as direct supervision for T2, and it
need not overlap the T1 training data.

Joint learning of syntax and semantics. The
motivation behind joint learning of syntactic and
semantic representations is that any one task is
helpful in predicting the other (Llu´ıs and M`arquez,
2008; Llu´ıs et al., 2013; Henderson et al., 2013;
Swayamdipta et al., 2016). This typically re-
quires joint prediction of the outputs of T1 and
T2, which tends to be computationally expensive
at both training and test time.

Part of speech scaﬀolds. Similar to our work,
there have been multitask models that use part-
of-speech tagging as T2, with transition-based de-
pendency parsing (Zhang and Weiss, 2016) and
CCG supertagging (Søgaard and Goldberg, 2016)
as T1. Both of the above approaches assumed par-
allel input data and used both tasks as supervision.
Notably, we simplify our T2, throwing away the
structured aspects of syntactic parsing, whereas
part-of-speech tagging has very little structure
to begin with. While their approach results in
improved token-level representations learned via
supervision from POS tags, these must still be
In-
composed to obtain span representations.

2 There has been some recent work on SRL which com-
pletely forgoes syntactic processing (Zhou and Xu, 2015),
however it has been shown that incorporating syntactic in-
formation still remains useful (He et al., 2017).

stead, our approach learns span-level representa-
tions from phrase-type supervision directly, for se-
mantic tasks. Additionally, these methods explore
architectural variations in RNN layers for includ-
ing supervision, whereas we focus on incorporat-
ing supervision with minimal changes to the base-
line architecture. To the best of our knowledge,
such simpliﬁed syntactic scaﬀolds have not been
tried before.

Word embeddings. Our deﬁnition of a scaﬀold
task almost includes stand-alone methods for es-
timating word embeddings (Mikolov et al., 2013;
Pennington et al., 2014; Peters et al., 2018). Af-
ter training word embeddings, the tasks implied
by models like the skip-gram or ELMo’s language
model become irrelevant to the downstream use of
the embeddings. A noteworthy diﬀerence is that,
rather than pre-training, a scaﬀold is integrated di-
rectly into the training of T1 through a multitask
objective.

Multitask learning. Neural architectures have
often yielded performance gains when trained for
multiple tasks together (Collobert et al., 2011; Lu-
ong et al., 2015; Chen et al., 2017; Hashimoto
et al., 2017). In particular, performance of seman-
tic role labeling tasks improves when done jointly
with other semantic tasks (FitzGerald et al., 2015;
Peng et al., 2017, 2018). Contemporaneously with
this work, Hershcovich et al. (2018) proposed a
multitask learning setting for universal syntactic
dependencies and UCCA semantics (Abend and
Rappoport, 2013). Syntactic scaﬀolds focus on a
primary semantic task, treating syntax as an auxil-
lary, eventually forgettable prediction task.

4 Syntactic Scaﬀold Model

We assume two sources of supervision: a cor-
pus D1 with instances x annotated for the primary
task’s outputs y (semantic role labeling or corefer-
ence resolution), and a treebank D2 with sentences
x, each with a phrase-structure tree z.

4.1 Loss

Each task has an associated loss, and we seek to
minimize the combination of task losses,

(cid:88)

(x,y)∈D1

(cid:88)

(x,z)∈D2

L1(x, y) + δ

L2(x, z)

(1)

with respect to parameters, which are partially
shared, where δ is a tunable hyperparameter. In

Each input

the rest of this section, we describe the scaﬀold
task. We deﬁne the primary tasks in Sections 5–6.
is a sequence of tokens, x =
(cid:104)x1, x2, . . . , xn(cid:105), for some n. We refer to a span
of contiguous tokens in the sentence as xi: j =
(cid:104)xi, xi+1, . . . , x j(cid:105), for any 1 (cid:54) i (cid:54) j (cid:54) n. In our
experiments we consider only spans up to a maxi-
mum length D, resulting in O(nD) spans.

Supervision comes from a phrase-syntactic tree
z for the sentence, comprising a syntactic category
zi: j ∈ C for every span xi: j in x (many spans are
given a null label). We experiment with diﬀerent
sets of labels C (§4.2).

In our model, every span xi: j is represented by
an embedding vector vi: j (see details in §5.3). A
distribution over the category assigned to zi: j is de-
rived from vi: j:

p(zi: j = c | xi: j) = softmax

wc · vi: j

(2)

c

where wc is a parameter vector associated with
category c. We sum the log loss terms for all the
spans in a sentence to give its loss:

L2(x, z) = −

log p(zi: j | xi: j).

(3)

(cid:88)

1(cid:54)i(cid:54) j(cid:54)n
j−i(cid:54)D

4.2 Labels for the Syntactic Scaﬀold Task
Diﬀerent kinds of syntactic labels can be used for
learning syntactically-aware span representations:
• Constituent identity: C = {0, 1}; is a span a

constituent, or not?

• Non-terminal: c is the category of a span,

including a null for non-constituents.

• Non-terminal and parent: c is the category
of a span, concatenated with the category of
its immediate ancestor. null is used for non-
constituents, and for empty ancestors.

• Common non-terminals: Since a majority
of semantic arguments and entity mentions
are labeled with a small number of syntac-
tic categories,3 we experiment with a three-
way classiﬁcation among (i) noun phrase (or
prepositional phrase, for frame SRL); (ii) any
other category; and (iii) null.

In Figure 1, for the span “encouraging them”,
the constituent identity scaﬀold label is 1, the non-
terminal label is S|VP, the non-terminal and par-
ent label is S|VP+par=PP, and the common non-
terminals label is set to OTHER.

3In the OntoNotes corpus, which includes both syntac-
tic and semantic annotations, 44% of semantic arguments are
noun phrases and 13% are prepositional phrases.

5 Semantic Role Labeling

We contribute a new SRL model which contributes
a strong baseline for experiments with syntactic
scaﬀolds. The performance of this baseline itself
is competitive with state-of-the-art methods (§7).

In the FrameNet

FrameNet.
lexicon (Baker
et al., 1998), a frame represents a type of event,
situation, or relationship, and is associated with a
set of semantic roles, called frame elements. A
frame can be evoked by a word or phrase in a sen-
tence, called a target. Each frame element of an
evoked frame can then be realized in the sentence
as a sentential span, called an argument (or it can
be unrealized). Arguments for a given frame do
not overlap.

PropBank. PropBank similarly disambiguates
predicates and identiﬁes argument spans. Tar-
gets are disambiguated to lexically speciﬁc senses
rather than shared frames, and a set of generic
roles is used for all targets, reducing the argument
label space by a factor of 17. Most importantly,
the arguments were annotated on top of syntactic
constituents, directly coupling syntax and seman-
tics. A detailed example for both formalisms is
provided in Figure 1.

Semantic structure prediction is the task of iden-
tifying targets, labeling their frames or senses, and
labeling all their argument spans in a sentence.
Here we assume gold targets and frames, and con-
sider only the SRL task.

Formally, a single input instance for argument
identiﬁcation consists of: an n-word sentence x =
(cid:104)x1, x2, . . . , xn(cid:105), a single target span t = (cid:104)tstart, tend(cid:105),
f . The argu-
and its evoked frame, or sense,
ment labeling task is to produce a segmentation
of the sentence: s = (cid:104)s1, s2, . . . , sm(cid:105) for each in-
put x. A segment s = (cid:104)i, j, yi: j(cid:105) corresponds to
a labeled span of the sentence, where the label
yi: j ∈ Y f ∪ {null} is either a role that the span
ﬁlls, or null if the span does not ﬁll any role. In
the case of PropBank, Y f consists of all possible
roles. The segmentation is constrained so that ar-
gument spans cover the sentence and do not over-
lap (ik+1 = 1 + jk for sk; i1 = 1; jm = n). Segments
of length 1 such that i = j are allowed. A separate
segmentation is predicted for each target annota-
tion in a sentence.

5.1 Semi-Markov CRF

of log-likelihood:

In order to model the non-overlapping arguments
of a given target, we use a semi-Markov condi-
tional random ﬁeld (semi-CRF; Sarawagi et al.,
2004). Semi-CRFs deﬁne a conditional distribu-
tion over labeled segmentations of an input se-
quence, and are globally normalized. A single tar-
get’s arguments can be neatly encoded as a labeled
segmentation by giving the spans in between argu-
ments a reserved null label. Semi-Markov mod-
els are more powerful than BIO tagging schemes,
which have been used successfully for PropBank
SRL (Collobert et al., 2011; Zhou and Xu, 2015,
inter alia), because the semi-Markov assumption
allows scoring variable-length segments, rather
than ﬁxed-length label n-grams as under an (n −
1)-order Markov assumption. Computing the
marginal likelihood with a semi-CRF can be done
using dynamic programming in O(n2) time (§5.2).
By ﬁltering out segments longer than D tokens,
this is reduced to O(nD).

Given an input x, a semi-CRF deﬁnes a condi-
tional distribution p(s | x). Every segment s =
(cid:104)i, j, yi: j(cid:105) is given a real-valued score, ψ((cid:104)i, j, yi: j =
r(cid:105), xi: j) = wr · vi: j, where vi: j is an embedding
of the span (§5.3) and wr is a parameter vector
corresponding to its label. The score of the en-
tire segmentation s is the sum of the scores of
its segments: Ψ(x, s) = (cid:80)m
k=1 ψ(sk, xik: jk ). These
scores are exponentiated and normalized to deﬁne
the probability distribution. The sum-product vari-
ant of the semi-Markov dynamic programming al-
gorithm is used to calculate the normalization term
(required during learning). At test time, the max-
product variant returns the most probable segmen-
tation, ˆs = arg max sΨ(s, x).

The parameters of the semi-CRF are learned to
maximize a criterion related to the conditional log-
likelihood of the gold-standard segments in the
training corpus (§5.2). The learner evaluates and
adjusts segment scores ψ(sk, x) for every span in
the sentence, which in turn involves learning em-
bedded representations for all spans (§5.3).

5.2 Softmax-Margin Objective

Typically CRF and semi-CRF models are trained
to maximize a conditional log-likelihood objec-
tive.
In early experiments, we found that incor-
porating a structured cost was beneﬁcial; we do
so by using a softmax-margin training objective
(Gimpel and Smith, 2010), a “cost-aware” variant

L1 = −

(cid:88)

log

exp Ψ(s∗, x)
Z(x, s∗)

,

(cid:88)

(x,s∗)∈D1
exp {Ψ(s, x) + cost(s, s∗)}.

Z(x, s∗) =

(4)

(5)

s

(cid:88)

s∈s

We design the cost function so that it factors by
predicted span, in the same way Ψ does:

cost(s, s∗) =

cost(s, s∗) =

I(s (cid:60) s∗).

(6)

(cid:88)

s∈s

The softmax-margin criterion, like log-likelihood,
is globally normalized over all of the exponentially
many possible labeled segmentations. The follow-
ing zeroth-order semi-Markov dynamic program
(Sarawagi et al., 2004) eﬃciently computes the
new partition function:
(cid:88)

αi−1 exp{Ψ(s, x) + cost(s, s∗)},

(7)

α j =

s=(cid:104)i, j,yi: j(cid:105)
j−i(cid:54)D

where Z = αn, under the base case α0 = 1.

The prediction under the model can be calcu-
lated using a similar dynamic program with the
following recurrence where γ0 = 1:

γ j = max
s=(cid:104)i, j,yi: j(cid:105)
j−i(cid:54)D

γi−1 exp Ψ(s, x).

(8)

Our model formulation enforces that arguments do
not overlap. We do not enforce any other SRL
constraints, such as non-repetition of core frame
elements (Das et al., 2012).

5.3

Input Span Representation

This section describes the neural architecture used
to obtain the span embedding, vi: j, correspond-
ing to a span xi: j and the target in consideration,
t = (cid:104)tstart, tend(cid:105). For the scaﬀold task, since the
syntactic treebank does not contain annotations for
semantic targets, we use the last verb in the sen-
tence as a placeholder target, wherever target fea-
tures are used. If there are no verbs, we use the
ﬁrst token in the sentence as a placeholder target.
The parameters used to learn v are shared between
the tasks.

We construct an embedding for the span using
• hi and h j: contextualized embeddings for the

words at the span boundary (§5.3.1),

• ui: j: a span summary that pools over the con-

tents of the span (§5.3.2), and

• ai: j: and a hand-engineered feature vector for

the span (§5.3.3).

This embedding is then passed to a feedforward

layer to compute the span representation, vi: j.

5.3.1 Contextualized Token Embeddings

To obtain contextualized embeddings of each to-
ken in the input sequence, we run a bidirectional
LSTM (Graves, 2012) with (cid:96) layers over the full
input sequence. To indicate which token is a pred-
icate, a linearly transformed one-hot embedding v
is used, following Zhou and Xu (2015) and He
et al. (2017). The input vector representing the
token at position q in the sentence is the concate-
nation of a ﬁxed pretrained embedding xq and vq.
When given as input to the bidirectional LSTM,
this yields a hidden state vector hq representing
the qth token in the context of the sentence.

5.3.2 Span Summary
Tokens within a span might convey diﬀerent
amounts of information necessary to label the span
as a semantic argument. Following Lee et al.
(2017), we use an attention mechanism (Bahdanau
et al., 2014) to summarize each span. Each con-
textualized token in the span is passed through a
feed-forward network to obtain a weight, normal-
ized to give σk = softmax
whead · hk, where whead
is a learned parameter. The weights σ are then
used to obtain a vector that summarizes the span,
ui: j = (cid:80)

i(cid:54)k(cid:54) j; j−i<D σk · hk.

i(cid:54)k(cid:54) j

5.3.3 Span Features

We use the following three features for each span:
• width of the span in tokens (Das et al., 2014)
• distance (in tokens) of the span from the tar-

get (T¨ackstr¨om et al., 2015)

• position of the span with respect to the tar-
get (before, after, overlap) (T¨ackstr¨om et al.,
2015)

Each of these features is encoded as a one-hot-
embedding and then linearly transformed to yield
a feature vector, ai: j.

6 Coreference Resolution

Coreference resolution is the task of determin-
ing clusters of mentions that refer to the same
entity. Formally, the input is a document x =
x1, x2, . . . , xn consisting of n words. The goal is
to predict a set of clusters c = {c1, c2, . . .}, where
each cluster c = {s1, s2, . . .} is a set of spans and

each span s = (cid:104)i, j(cid:105) is a pair of indices such that
1 (cid:54) i (cid:54) j (cid:54) n.

As a baseline, we use the model of Lee et al.
(2017), which we describe brieﬂy in this section.
This model decomposes the prediction of coref-
erence clusters into a series of span classiﬁcation
decisions. Every span s predicts an antecedent
ws ∈ Y(s) = {null, s1, s2, . . . , sm}. Labels s1 to
sm indicate a coreference link between s and one
of the m spans that precede it, and null indicates
that s does not link to anything, either because it
is not a mention or it is in a singleton cluster. The
predicted clustering of the spans can be recovered
by aggregating the predicted links.

Analogous to the SRL model (§5), every span
s is represented by an embedding vs, which is
central to the model. For each span s and a po-
tential antecedent a ∈ Y(s), pairwise coreference
scores Ψ(vs, va, φ(s, a)) are computed via feedfor-
ward networks with the span embeddings as input.
φ(s, a) are pairwise discrete features encoding the
distance between span s and span a and metadata,
such as the genre and speaker information. We re-
fer the reader to Lee et al. (2017) for the details of
the scoring function.

The scores from Ψ are normalized over the pos-
sible antecedents Y(s) of each span to induce a
probability distribution for every span:

p(ws = a) = softmax
a∈Y(s)

Ψ(vs, va, φ(s, a))

(9)

In learning, we minimize the negative log-
likelihood marginalized over the possibly correct
antecedents:

L1 = −

(cid:88)

log

(cid:88)

p(ws = a∗)

(10)

s∈D

a∗∈G(s)∩Y(s)

where D is the set of spans in the training dataset,
and G(s) indicates the gold cluster of s if it belongs
to one and {null} otherwise.

To operate under reasonable computational re-
quirements, inference under this model requires a
two-stage beam search, which reduces the number
of span pairs considered. We refer the reader to
Lee et al. (2017) for details.

Input span representation. The input span em-
bedding, vs for coreference resolution and its syn-
tactic scaﬀold follow the deﬁnition used in §5.3,
with the key diﬀerence of using no target features.
Since there is a complete overlap of input sen-
tences between Dsc and Dpr as the coreference an-
notations are also from OntoNotes (Pradhan et al.,

2012), we reuse the v for the scaﬀold task. Addi-
tionally, instead of the entire document, each sen-
tence in it is independently given as input to the
bidirectional LSTMs.

7 Results

We evaluate our models on the test set of
FrameNet 1.5 for frame SRL and on the test set
of OntoNotes for both PropBank SRL and coref-
erence. For the syntactic scaﬀold in each case,
we use syntactic annotations from OntoNotes
5.0 (Weischedel et al., 2013; Pradhan et al.,
2013).4 Further details on experimental settings
and datasets have been elaborated in the supple-
mental material.

Frame SRL. Table 1 shows the performance of
all the scaﬀold models on frame SRL with respect
to prior work and a semi-CRF baseline (§5.1)
without a syntactic scaﬀold. We follow the oﬃ-
cial evaluation from the SemEval shared task for
frame-semantic parsing (Baker et al., 2007).

Prior work for frame SRL has relied on pre-
dicted syntactic trees, in two diﬀerent ways: by
using syntax-based rules to prune out spans of text
that are unlikely to contain any frame’s argument;
and by using syntactic features in their statistical
model (Das et al., 2014; T¨ackstr¨om et al., 2015;
FitzGerald et al., 2015; Kshirsagar et al., 2015).

The best published results on FrameNet 1.5 are
due to Yang and Mitchell (2017). In their sequen-
tial model (seq), they treat argument identiﬁcation
as a sequence-labeling problem using a deep bidi-
rectional LSTM with a CRF layer. In their rela-
tional model (Rel), they treat the same problem as
a span classiﬁcation problem. Finally, they intro-
duce an ensemble to integerate both models, and
use an integer linear program for inference satis-
fying SRL constraints. Though their model does
not do any syntactic pruning, it does use syntactic
features for argument identiﬁcation and labeling.5
Notably, all prior systems for frame SRL listed
in Table 1 use a pipeline of syntax and seman-
tics. Our semi-CRF baseline outperforms all prior
work, without any syntax. This highlights the ben-

4http://cemantix.org/data/ontonotes.html
5Yang and Mitchell (2017) also evaluated on the full
frame-semantic parsing task, which includes frame-SRL as
well as identifying frames. Since our frame SRL performance
improves over theirs, we expect that incorporation into a full
system (e.g., using their frame identiﬁcation module) would
lead to overall beneﬁts as well; this experiment is left to fu-
ture work.

eﬁts of modeling spans and of global normaliza-
tion.

Turning to scaﬀolds, even the most coarse-
grained constituent identity scaﬀold improves the
performance of our syntax-agnostic baseline. The
nonterminal and nonterminal and parent scaﬀolds,
which use more detailed syntactic representations,
improve over this. The greatest improvements
come from the scaﬀold model predicting com-
mon nonterminal labels (NP and PP, which are the
most common syntactic categories of semantic ar-
guments, vs. others): 3.6% absolute improvement
in F1 measure over prior work.

Contemporaneously with this work, Peng et al.
(2018) proposed a system for joint frame-semantic
and semantic dependency parsing. They report re-
sults for joint frame and argument identiﬁcation,
and hence cannot be directly compared in Table 1.
We evaluated their output for argument identiﬁca-
tion only; our semi-CRF baseline model exceeds
their performance by 1 F1, and our common non-
terminal scaﬀold by 3.1 F1.6

Model

Prec. Rec.

Kshirsagar et al. (2015)
Yang and Mitchell (2017) (Rel)
Yang and Mitchell (2017) (Seq)
†Yang and Mitchell (2017) (All)

Semi-CRF baseline

+ constituent identity
+ nonterminal and parent
+ nonterminal
+ common nonterminals

66.0
71.8
63.4
70.2

67.8

68.1
68.8
69.4
69.2

60.4
57.7
66.4
60.2

66.2

67.4
68.2
68.0
69.0

F1

63.1
64.0
64.9
65.5

67.0

67.7
68.5
68.7
69.1

Table 1: Frame SRL results on the test set of
FrameNet 1.5., using gold frames. Ensembles are
denoted by †.

Model

Prec. Rec.

Zhou and Xu (2015)
He et al. (2017)
He et al. (2018a)
Tan et al. (2018)

Semi-CRF baseline

+ common nonterminals

-
81.7
83.9
81.9

84.8

85.1

-
81.6
73.7
83.6

81.2

82.6

F1

81.3
81.7
82.1
82.7

83.0

83.8

Table 2: PropBank sSRL results, using gold pred-
icates, on CoNLL 2012 test. For fair comparison,
we show only non-ensembled models.

6This result is not reported in Table 1 since Peng et al.
(2018) used a preprocessing which renders the test set slightly
larger — the diﬀerence we report is calculated using their test
set.

Model

MUC
Prec. Rec. F1

B3
Prec. Rec. F1

CEAFφ4
Prec. Rec. F1

Avg. F1

Wiseman et al. (2016)
77.5 69.8 73.4
Clark and Manning (2016b) 79.9 69.3 74.2
Clark and Manning (2016a) 79.2 70.4 74.6

66.8 57.0 61.5
71.0 56.5 63.0
69.9 58.0 63.4

62.1 53.9 57.7
63.8 54.3 58.7
63.5 55.5 59.2

Lee et al. (2017)

78.4 73.4 75.8
+ common nonterminals 78.4 74.3 76.3

68.6 61.8 65.0

62.7 59.0 60.8

68.7 62.9 65.7

62.9 60.2 61.5

64.2
65.3
65.7

67.2

67.8

Table 3: Coreference resolution results on the test set on the English CoNLL-2012 shared task. The
average F1 of MUC, B3, and CEAFφ4 is the main evaluation metric. For fair comparison, we show only
non-ensembled models.

PropBank SRL. We use the OntoNotes data
from the CoNLL shared task in 2012 (Pradhan
et al., 2013) for Propbank SRL. Table 2 reports
results using gold predicates.

Recent competitive systems for PropBank SRL
follow the approach of Zhou and Xu (2015), em-
ploying deep architectures, and forgoing the use of
any syntax. He et al. (2017) improve on those re-
sults, and in analysis experiments, show that con-
straints derived using syntax may further improve
performance. Tan et al. (2018) employ a similar
approach but use feed-forward networks with self-
attention. He et al. (2018a) use a span-based clas-
siﬁcation to jointly identify and label argument
spans.

Our syntax-agnostic semi-CRF baseline model
improves on prior work (excluding ELMo), show-
ing again the value of global normalization in se-
mantic structure prediction. We obtain further im-
provement of 0.8 absolute F1 with the best syn-
tactic scaﬀold from the frame SRL task. This in-
dicates that a syntactic inductive bias is beneﬁ-
cial even when using sophisticated neural archi-
tectures.

He et al. (2018a) also provide a setup where ini-
tialization was done with deep contextualized em-
beddings, ELMo (Peters et al., 2018), resulting in
85.5 F1 on the OntoNotes test set. The improve-
ments from ELMo are methodologically orthogonal
to syntactic scaﬀolds.

Since the datasets for learning PropBank se-
mantics and syntactic scaﬀolds completely over-
lap, the performance improvement cannot be at-
tributed to a larger training corpus (or, by exten-
sion, a larger vocabulary), though that might be a
factor for frame SRL.

A syntactic scaﬀold can match the performance
of a pipeline containing carefully extracted syntac-
tic features for semantic prediction (Swayamdipta
et al., 2017). This, along with other recent ap-

proaches (He et al., 2017, 2018b) show that syntax
remains useful, even with strong neural models for
SRL.

Coreference. We report the results on four stan-
dard scores from the CoNLL evaluation: MUC, B3
and CEAFφ4, and their average F1 in Table 3. Prior
competitive coreference resolution systems (Wise-
man et al., 2016; Clark and Manning, 2016b,a) all
incorporate synctactic information in a pipeline,
using features and rules for mention proposals
from predicted syntax.

Our baseline is the model from Lee et al.
(2017), described in §6. Similar to the baseline
model for frame SRL, and in contrast with prior
work, this model does not use any syntax.

We experiment with the best syntactic scaﬀold
from the frame SRL task. We used NP, OTHER, and
null as the labels for the common nonterminals
scaﬀold here, since coreferring mentions are rarely
prepositional phrases. The syntactic scaﬀold out-
performs the baseline by 0.6 absolute F1. Contem-
poraneously, Lee et al. (2018) proposed a model
which takes in account higher order inference and
more aggressive pruning, as well as initialization
with ELMo embeddings, resulting in 73.0 average
F1. All the above are orthogonal to our approach,
and could be incorporated to yield higher gains.

8 Discussion

To investigate the performance of the syntactic
scaﬀold, we focus on the frame SRL results, where
we observed the greatest improvement with re-
spect to a non-syntactic baseline.

We consider a breakdown of the performance
by the syntactic phrase types of the arguments,
provided in FrameNet7 in Figure 2. Not surpris-

7We used FrameNet syntactic phrase annotations for anal-
ysis only, and not in our models, since they are annotated only
for the gold arguments.

Figure 2: Performance breakdown by argu-
ment’s phrase category, sorted left to right by
frequency, for top ten phrase categories.

Figure 3: Performance breakdown by top ten
frame element types, sorted left to right by fre-
quency.

ingly, we observe large improvements in the com-
mon nonterminals used (NP and PP). However,
the phrase type annotations in FrameNet do not
correspond exactly to the OntoNotes phrase cat-
egories. For instance, FrameNet annotates non-
maximal (A) and standard adjective phrases (AJP),
while OntoNotes annotations for noun-phrases are
ﬂat, ignore the underlying adjective phrases. This
explains why the syntax-agnostic baseline is able
to recover the former while the scaﬀold is not.

Similarly, for frequent frame elements, scaﬀold-
ing improves performance across the board, as
shown in Fig. 3. The largest improvements come
for Theme and Goal, which are predominantly re-
alized as noun phrases and prepositional phrases.

9 Conclusion

We introduced syntactic scaﬀolds, a multitask
learning approach to incorporate syntactic bias
into semantic processing tasks. Unlike pipelines
and approaches which jointly model syntax and
semantics, no explicit syntactic processing is re-
quired at runtime. Our method improves the per-
formance of competitive baselines for semantic
role labeling on both FrameNet and PropBank,
and for coreference resolution. While our focus
was on span-based tasks, syntactic scaﬀolds could
be applied in other settings (e.g., dependency and
graph representations). Moreover, scaﬀolds need
not be syntactic; we can imagine, for example, se-
mantic scaﬀolds being used to improve NLP appli-
cations with limited annotated data. It remains an
open empirical question to determine the relative
merits of diﬀerent kinds of scaﬀolds and multi-
task learners, and how they can be most produc-

tively combined. Our code is publicly available at
https://github.com/swabhs/scaffolding.

Acknowledgments

We thank several members of UW-NLP, partic-
ularly Luheng He, as well as David Weiss and
Emily Pitler for thoughtful discussions on prior
versions of this paper. We also thank the three
anonymous reviewers for their valuable feedback.
This work was supported in part by NSF grant IIS-
1562364 and by the NVIDIA Corporation through
the donation of a Tesla GPU.

References

Omri Abend and Ari Rappoport. 2013. Universal Con-
ceptual Cognitive Annotation (UCCA). In ACL.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2014. Neural machine translation by jointly
learning to align and translate. ArXiv:1409.0473.

Collin Baker, Michael Ellsworth, and Katrin Erk. 2007.
SemEval’07 Task 19: Frame semantic structure ex-
traction. In Proc. of SemEval.

Collin F. Baker, Charles J. Fillmore, and John B. Lowe.
1998. The Berkeley FrameNet project. In Proc. of
ACL.

Rich Caruana. 1997. Multitask learning. Machine

Learning, 28(1).

Xinchi Chen, Zhan Shi, Xipeng Qiu, and Xuanjing
Huang. 2017. Adversarial multi-criteria learning for
chinese word segmentation. ArXiv:1704.07556.

Kevin Clark and Christopher D Manning. 2016a. Deep
reinforcement learning for mention-ranking corefer-
ence models. In Proc. of EMNLP.

Kevin Clark and Christopher D. Manning. 2016b. Im-
proving coreference resolution by learning entity-
level distributed representations. In Proc. of ACL.

Luheng He, Kenton Lee, Mike Lewis, and Luke Zettle-
moyer. 2017. Deep semantic role labeling: What
works and what’s next. In Proc. of ACL.

Ronan Collobert, Jason Weston, L´eon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
Journal of Machine Learning Research,
scratch.
12:2493–2537.

Ann Copestake and Dan Flickinger. 2000.

An
open source grammar development environment and
broad-coverage English grammar using HPSG.
In
Proc. of LREC.

Dipanjan Das, Desai Chen, Andr´e FT Martins, Nathan
Frame-
linguistics,

Schneider, and Noah A Smith. 2014.
semantic parsing.
40(1):9–56.

Computational

Dipanjan Das, Andr´e F. T. Martins, and Noah A. Smith.
2012. An exact dual decomposition algorithm for
shallow semantic parsing with constraints. In Proc.
of *SEM.

Jenny Rose Finkel, Christopher D Manning, and An-
drew Y Ng. 2006. Solving the problem of cascading
errors: Approximate bayesian inference for linguis-
tic annotation pipelines. In Proc. of EMNLP.

Nicholas FitzGerald, Oscar T¨ackstr¨om, Kuzman
Ganchev, and Dipanjan Das. 2015. Semantic role
In Proc. of
labeling with neural network factors.
EMNLP.

Shexia He, Zuchao Li, Hai Zhao, and Hongxiao Bai.
2018b. Syntax for semantic role labeling, to be, or
not to be. In Proc. of ACL.

James Henderson, Paola Merlo,

Ivan Titov, and
Gabriele Musillo. 2013. Multi-lingual joint pars-
ing of syntactic and semantic dependencies with a
latent variable model. Computational Linguistics,
39(4):949–998.

Daniel Hershcovich, Omri Abend, and Ari Rappoport.
2018. Multitask parsing across semantic representa-
tions. In Proc. of ACL.

Diederik

P. Kingma

2014.
and
ADAM: A method for stochastic optimization.
ArXiV:1412.6980.

Jimmy Ba.

Lingpeng Kong, Chris Dyer, and Noah A. Smith. 2016.
Segmental Recurrent Neural Networks. In Proc. of
ICLR.

Meghana Kshirsagar, Sam Thomson, Nathan Schnei-
der, Jaime Carbonell, Noah A Smith, and Chris
Dyer. 2015. Frame-semantic role labeling with het-
erogeneous annotations. In Proc. of NAACL.

Kenton Lee, Luheng He, Mike Lewis, and Luke Zettle-
moyer. 2017. End-to-end neural coreference resolu-
tion. In Proc. of EMNLP.

Daniel Gildea and Daniel Jurafsky. 2002. Automatic
labeling of semantic roles. Computational Linguis-
tics, 28(3):245–288.

Kenton Lee, Luheng He, and Luke Zettlemoyer. 2018.
Higher-order coreference resolution with coarse-to-
ﬁne inference. In Proc. of NAACL.

Daniel Gildea and Martha Palmer. 2002. The necessity
of parsing for predicate argument recognition.
In
Proc. of ACL.

Kevin Gimpel and Noah A. Smith. 2010. Softmax-
margin CRFs: Training log-linear models with cost
functions. In Proc. of NAACL.

Alex Graves. 2012. Supervised Sequence Labelling
with Recurrent Neural Networks, volume 385 of
Studies in Computational Intelligence. Springer.

Alex Graves. 2013. Generating sequences with recur-

rent neural networks. ArXiv:1308.0850.

Kazuma Hashimoto, Caiming Xiong, Yoshimasa Tsu-
ruoka, and Richard Socher. 2017. A joint many-task
model: Growing a neural network for multiple NLP
tasks. In Proc. of EMNLP.

He He, Hal Daum´e III, and Jason Eisner. 2013. Dy-
namic feature selection for dependency parsing. In
Proc. of EMNLP.

Luheng He, Kenton Lee, Omer Levy, and Luke Zettle-
moyer. 2018a. Jointly predicting predicates and ar-
guments in neural semantic role labeling. In Proc.
of ACL.

Xavier Llu´ıs, Xavier Carreras, and Llu´ıs M`arquez.
2013.
Joint arc-factored parsing of syntactic and
semantic dependencies. Transactions of the ACL,
1:219–230.

Xavier Llu´ıs and Llu´ıs M`arquez. 2008. A joint model
for parsing syntactic and semantic dependencies. In
Proc. of CoNLL.

Minh-Thang Luong, Quoc V Le, Ilya Sutskever, Oriol
Vinyals, and Lukasz Kaiser. 2015. Multi-task se-
quence to sequence learning. ArXiv:1511.06114.

Tomas Mikolov, Kai Chen, Gregory S. Corrado, and
Jeﬀrey Dean. 2013. Eﬃcient estimation of word
representations in vector space. ArXiv:1301.3781.

Vinod Nair and Geoﬀrey E. Hinton. 2010. Rectiﬁed
linear units improve restricted Boltzmann machines.
In Proc. of ICML.

Jason Naradowsky, Sebastian Riedel, and David A.
Improving NLP through marginal-
In Proc. of

Smith. 2012.
ization of hidden syntactic structure.
EMNLP.

Vincent Ng. 2010. Supervised noun phrase coreference
research: The ﬁrst ﬁfteen years. In Proc. of ACL.

Martha Palmer, Daniel Gildea, and Paul Kingsbury.
2005. The Proposition Bank: An annotated cor-
pus of semantic roles. Computational Linguistics,
31(1):71–106.

Swabha Swayamdipta, Sam Thomson, Chris Dyer, and
Noah A. Smith. 2017. Frame-semantic parsing with
softmax-margin segmental rnns and a syntactic scaf-
fold. Arxiv:1706.09528.

Hao Peng, Sam Thomson, and Noah A. Smith. 2017.
Deep multitask learning for semantic dependency
parsing. In Proc. of ACL.

Hao Peng, Sam Thomson, Swabha Swayamdipta, and
Noah A. Smith. 2018. Learning joint semantic
parsers from disjoint data. In Proc. of NAACL.

Jeﬀrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. GloVe: Global vectors for
word representation. In Proc. of EMNLP.

Matthew E Peters, Mark Neumann, Mohit Iyyer, Matt
Gardner, Christopher Clark, Kenton Lee, and Luke
Zettlemoyer. 2018. Deep contextualized word rep-
resentations. ArXiv:1802.05365.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Hwee Tou Ng, Anders Bj¨orkelund, Olga Uryupina,
Yuchen Zhang, and Zhi Zhong. 2013. Towards ro-
bust linguistic analysis using OntoNotes. In Proc. of
CoNLL.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Olga Uryupina, and Yuchen Zhang. 2012. CoNLL-
2012 shared task: Modeling multilingual unre-
In Proc. of
stricted coreference in OntoNotes.
EMNLP.

Vasin Punyakanok, Dan Roth, and Wen-tau Yih. 2008.
The importance of syntactic parsing and inference in
semantic role labeling. Computational Linguistics,
34(2):257–287.

Pranav Rajpurkar,

Jian Zhang, Konstantin Lopy-
rev, and Percy Liang. 2016. SQuAD: 100,000+
questions for machine comprehension of
text.
ArXiv:1606.05250.

Oscar T¨ackstr¨om, Kuzman Ganchev, and Dipanjan
Das. 2015. Eﬃcient inference and structured learn-
ing for semantic role labeling. Transactions of the
ACL, 3:29–41.

Zhixing Tan, Mingxuan Wang, Jun Xie, Yidong Chen,
and Xiaodong Shi. 2018. Deep semantic role label-
ing with self-attention. In Proc. of AAAI.

Kristina Toutanova, Aria Haghighi, and Christopher D.
joint model for se-
Manning. 2008. A global
mantic role labeling. Computational Linguistics,
34(2):161–191.

Ralph Weischedel, Martha Palmer, Mitchell Marcus,
Eduard Hovy, Sameer Pradhan, Lance Ramshaw,
Nianwen Xue, Ann Taylor, Jeﬀ Kaufman, Michelle
Franchini, et al. 2013. OntoNotes release 5.0
ldc2013t19. Linguistic Data Consortium, Philadel-
phia, PA.

Sam Wiseman, Alexander M Rush, and Stuart M
Shieber. 2016. Learning global features for coref-
erence resolution. In Proc. of NAACL.

David H Wolpert. 1992. Stacked generalization. Neu-

ral networks, 5(2):241–259.

Bishan Yang and Tom Mitchell. 2017. A joint sequen-
tial and relational model for frame-semantic parsing.
In Proc. of EMNLP.

Luke S Zettlemoyer and Michael Collins. 2005. Learn-
ing to map sentences to logical form: Structured
classiﬁcation with probabilistic categorial gram-
mars. In Proc. of UAI.

Yuan Zhang and David Weiss. 2016.

Stack-
propagation: Improved representation learning for
syntax. In Proc. of ACL.

Sunita Sarawagi, William W Cohen, et al. 2004. Semi-
markov conditional random ﬁelds for information
extraction. In Proc. of NIPS, volume 17.

Jie Zhou and Wei Xu. 2015. End-to-end learning of
semantic role labeling using recurrent neural net-
works. In Proc. of ACL.

Anders Søgaard and Yoav Goldberg. 2016. Deep
multi-task learning with low level tasks supervised
at lower layers. In Proc. of ACL.

Rupesh Kumar Srivastava, Klaus Greﬀ, and J¨urgen
Schmidhuber. 2015. Training very deep networks.
In Proc. of NIPS.

Mark Steedman. 2000.

Information structure and
the syntax-phonology interface. Linguistic Inquiry,
31(4):649–689.

Swabha Swayamdipta, Miguel Ballesteros, Chris Dyer,
and Noah A. Smith. 2016. Greedy, joint syntactic-
In Proc. of
semantic parsing with Stack LSTMs.
CoNLL.

We limit the maximum length of spans to D =
15 in FrameNet, resulting in oracle recall of 95%
on the development set, and to 13 in Propbank,
resulting in an oracle recall of 96%. An identical
maximum span length is used for the scaﬀold task.
For the SRL scaﬀolds, we randomly sample in-
stances from OntoNotes to match the size of the
SRL data, and alternate between training an SRL
batch and a scaﬀold batch.
In FrameNet, this
amounts to downsampling OntoNotes. For Prop-
Bank SRL, this amounts to upsampling syntactic
annotations from OntoNotes, since a sentence has
a single syntactic tree, but could have multiple tar-
get annotations, each of which is a training in-
stance.

The mixing ratio, δ is set to 1.0 (tuned across
{0.1, 0.5, 1.0, 1.5}) for frame and PropBank SRL.
We use Adam (Kingma and Ba, 2014) for opti-
mization, at a learning rate of 0.001, and a mini-
batch of size 32. Our dynamic program formula-
tion for loss computation and inference under the
semi-CRF is also batched. To prevent exploding
gradients, the 2-norm of the gradient is clipped
to 1 before a gradient update (Graves, 2013). All
models are trained for a maximum of 20 epochs,
and stopped early based on dev F1.

We extended the AllenNLP library,9 which is
built on top of PyTorch.10 Each experiment was
run on a single TitanX GPU.

For the coreference model, we use the same
hyperparameters and experimental settings from
Lee et al. (2017). The only new hyperparameter
needed for scaﬀolding is the mixing ratio, δ, which
we set to 0.1 based on performance on the valida-
tion set.

A Supplementary Material

A.1 Datasets

We used the full-text portion of FrameNet 1.5 re-
lease8 for frame-semantic role labeling. We use
the same test set as Das et al. (2014), and cre-
ate a validation set by selecting 8 documents from
the train set. The dataset contains 3,139 train sen-
tences with 16,621 target annotations, 387 valida-
tion sentences with 2,282 targets, and 2,420 test
sentences with 4,427 targets. Each target from a
given sentence is treated as an independent train-
ing instance. Following T¨ackstr¨om et al. (2015),
we only use the ﬁrst annotation for each target
with multiple annotations.

We use

the standard splits provided in
OntoNotes for the CoNLL 2012 shared task.
The dataset contains 115,812 train sentences with
278,026 target annotations, 15,680 validation sen-
tences with 38,377 targets, and 12,217 test sen-
tences with 29,669 targets.

We use the English coreference resolution data
from the CoNLL 2012 shared task (Pradhan et al.,
2012), containing 2,802, 343 and 348 documents
for train, validation, and test respectively.

Syntax OntoNotes contains 115,812 training in-
stances for the syntactic scaﬀold. There is no
overlap between FrameNet and OntoNotes train-
ing data.

A.2 Experimental Settings

We used GloVe embeddings (Pennington et al.,
2014) for tokens in the vocabulary, with out of
vocabulary words being initialized randomly. For
frame-SRL, 300 dimensional embeddings were
used, and kept ﬁxed during training. For Prop-
Bank SRL, we used 100 dimensional embed-
dings which were updated during training. A
100-dimensional embedding is learned for indi-
cating target positions, following Zhou and Xu
(2015). Bidirectional LSTMs with highway con-
nections (Srivastava et al., 2015) between 6 layers
are used, each layer containing 300-dimensional
hidden states. A dropout of 0.1 is applied to the
LSTMs. The feed-forward networks are of di-
mension 150 and of depth 2, with rectiﬁed linear
units (Nair and Hinton, 2010). A dropout of 0.2 is
applied to the feed-forward networks.

8A later release, 1.7 is also available, but for ease of com-
parison to other published systems we report results on the
earlier release.

9http://allennlp.org/
10http://pytorch.org/

Syntactic Scaﬀolds for Semantic Structures

Swabha Swayamdipta♠

Sam Thomson♠

Kenton Lee♦ Luke Zettlemoyer(cid:114) Chris Dyer♥ Noah A. Smith(cid:114)♣

♠Language Technologies Institute, Carnegie Mellon University, Pittsburgh, PA, USA
♦Google AI Language, Seattle WA, USA
(cid:114)Paul G. Allen School of Computer Science & Engineering, University of Washington, Seattle, WA, USA
♥Google DeepMind, London, UK
♣Allen Institute for Artiﬁcial Intelligence, Seattle, WA, USA
{swabha,sammthomson}@cs.cmu.edu {kentonl,cdyer}@google.com
{lsz,nasmith}@cs.washington.edu

8
1
0
2
 
g
u
A
 
0
3
 
 
]
L
C
.
s
c
[
 
 
1
v
5
8
4
0
1
.
8
0
8
1
:
v
i
X
r
a

Abstract

We introduce the syntactic scaﬀold, an ap-
proach to incorporating syntactic informa-
tion into semantic tasks. Syntactic scaﬀolds
avoid expensive syntactic processing at run-
time, only making use of a treebank during
training, through a multitask objective. We im-
prove over strong baselines on PropBank se-
mantics, frame semantics, and coreference res-
olution, achieving competitive performance on
all three tasks.

1

Introduction

As algorithms for the semantic analysis of natu-
ral language sentences have developed, the role
of syntax has been repeatedly revisited. Linguis-
tic theories have argued for a very tight integra-
tion of syntactic and semantic processing (Steed-
man, 2000; Copestake and Flickinger, 2000), and
many systems have used syntactic dependency
or phrase-based parsers as preprocessing for se-
mantic analysis (Gildea and Palmer, 2002; Pun-
yakanok et al., 2008; Das et al., 2014). Mean-
while, some recent methods forgo explicit syntac-
tic processing altogether (Zhou and Xu, 2015; He
et al., 2017; Lee et al., 2017; Peng et al., 2017).

Because annotated training datasets for se-
mantics will always be limited, we expect that
syntax—which oﬀers an incomplete but poten-
tially useful view of semantic structure—will con-
tinue to oﬀer useful inductive bias, encouraging
semantic models toward better generalization. We
address the central question: is there a way for se-
mantic analyzers to beneﬁt from syntax without
the computational cost of syntactic parsing?

We propose a multitask learning approach to
incorporating syntactic information into learned

representations of neural semantics models (§2).
Our approach, the syntactic scaﬀold, minimizes
an auxiliary supervised loss function, derived from
a syntactic treebank. The goal is to steer the dis-
tributed, contextualized representations of words
and spans toward accurate semantic and syntactic
labeling. We avoid the cost of training or execut-
ing a full syntactic parser, and at test time (i.e.,
runtime in applications) the semantic analyzer has
no additional cost over a syntax-free baseline. Fur-
ther, the method does not assume that the syntactic
treebank overlaps the dataset for the primary task.
Many semantic tasks involve labeling spans, in-
cluding semantic role labeling (SRL; Gildea and
Jurafsky, 2002) and coreference resolution (Ng,
2010) (tasks we consider in this paper), as well
as named entity recognition and some reading
comprehension and question answering tasks (Ra-
jpurkar et al., 2016).
These spans are usu-
ally syntactic constituents (cf. PropBank; Palmer
et al., 2005), making phrase-based syntax a natu-
ral choice for a scaﬀold. See Figure 1 for an ex-
ample sentence with syntactic and semantic anno-
tations. Since the scaﬀold task is not an end in
itself, we relax the syntactic parsing problem to
a collection of independent span-level predictions,
with no constraint that they form a valid parse tree.
This means we never need to run a syntactic pars-
ing algorithm.

Our experiments demonstrate that the syntactic
scaﬀold oﬀers a substantial boost to state-of-the-
art baselines for two SRL tasks (§5) and corefer-
ence resolution (§6). Our models use the strongest
available neural network architectures for these
tasks, integrating deep representation learning (He
et al., 2017) and structured prediction at the level
of spans (Kong et al., 2016). For SRL, the base-

Figure 1: An example sentence with syntactic, PropBank and coreference annotations from OntoNotes,
and author-annotated frame-semantic structures. PropBank SRL arguments and coreference mentions are
annotated on top of syntactic constituents. All but one frame-semantic argument (Event) is a syntactic
constituent. Targets evoke frames shown in the color-coded layers.

line itself is a novel globally normalized structured
conditional random ﬁeld, which outperforms the
previous state of the art.1 Syntactic scaﬀolds re-
sult in further improvements over prior work—
3.6 absolute F1 in FrameNet SRL, 1.1 absolute
F1 in PropBank SRL, and 0.6 F1 in coreference
resolution (averaged across three standard scores).
Our code is open source and available at https:
//github.com/swabhs/scaffolding.

2 Syntactic Scaﬀolds

Multitask learning (Caruana, 1997) is a collec-
tion of techniques in which two or more tasks are
learned from data with at least some parameters
shared. We assume there is only one task about
whose performance we are concerned, denoted T1
(in this paper, T1 is either SRL or coreference res-
olution). We use the term “scaﬀold” to refer to
a second task, T2, that can be combined with T1
during multitask learning. A scaﬀold task is only
used during training; it holds no intrinsic interest
beyond biasing the learning of T1, and after learn-
ing is completed, the scaﬀold is discarded.

A syntactic scaﬀold is a task designed to steer
the (shared) model toward awareness of syntactic

1This excludes models initialized with deep, contextual-
ized embeddings (Peters et al., 2018), an approach orthogonal
to ours.

structure.
It could be deﬁned through a syntac-
tic parser that shares some parameters with T1’s
model. Since syntactic parsing is costly, we use
simpler syntactic prediction problems (discussed
below) that do not produce whole trees.

As with multitask learning in general, we do not
assume that the same data are annotated with out-
puts for T1 and T2.
In this work, T2 is deﬁned
using phrase-structure syntactic annotations from
OntoNotes 5.0 (Weischedel et al., 2013; Pradhan
et al., 2013). We experiment with three settings:
one where the corpus for T2 does not overlap with
the training datasets for T1 (frame-SRL) and two
where there is a complete overlap (PropBank SRL
and coreference). Compared to approaches which
require multiple output labels over the same data,
we oﬀer the major advantage of not requiring any
assumptions about, or speciﬁcation of, the rela-
tionship between T1 and T2 output.

3 Related Work

We brieﬂy contrast the syntactic scaﬀold with ex-
isting alternatives.

Pipelines.
In a typical pipeline, T1 and T2 are
separately trained, with the output of T2 used to
deﬁne the inputs to T1 (Wolpert, 1992). Using
syntax as T2 in a pipeline is perhaps the most

common approach for semantic structure predic-
tion (Toutanova et al., 2008; Yang and Mitchell,
2017; Wiseman et al., 2016).2 However, pipelines
introduce the problem of cascading errors (T2’s
mistakes aﬀect the performance, and perhaps the
training, of T1; He et al., 2013). To date, reme-
dies to cascading errors are so computationally ex-
pensive as to be impractical (e.g., Finkel et al.,
2006). A syntactic scaﬀold is quite diﬀerent from
a pipeline since the output of T2 is never explicitly
used.

Latent variables. Another solution is to treat
the output of T2 as a (perhaps structured) la-
tent variable. This approach obviates the need
of supervision for T2 and requires marginalization
(or some approximation to it) in order to reason
about the outputs of T1. Syntax as a latent vari-
able for semantics was explored by Zettlemoyer
and Collins (2005) and Naradowsky et al. (2012).
Apart from avoiding marginalization, the syntactic
scaﬀold oﬀers a way to use auxiliary syntactically-
annotated data as direct supervision for T2, and it
need not overlap the T1 training data.

Joint learning of syntax and semantics. The
motivation behind joint learning of syntactic and
semantic representations is that any one task is
helpful in predicting the other (Llu´ıs and M`arquez,
2008; Llu´ıs et al., 2013; Henderson et al., 2013;
Swayamdipta et al., 2016). This typically re-
quires joint prediction of the outputs of T1 and
T2, which tends to be computationally expensive
at both training and test time.

Part of speech scaﬀolds. Similar to our work,
there have been multitask models that use part-
of-speech tagging as T2, with transition-based de-
pendency parsing (Zhang and Weiss, 2016) and
CCG supertagging (Søgaard and Goldberg, 2016)
as T1. Both of the above approaches assumed par-
allel input data and used both tasks as supervision.
Notably, we simplify our T2, throwing away the
structured aspects of syntactic parsing, whereas
part-of-speech tagging has very little structure
to begin with. While their approach results in
improved token-level representations learned via
supervision from POS tags, these must still be
In-
composed to obtain span representations.

2 There has been some recent work on SRL which com-
pletely forgoes syntactic processing (Zhou and Xu, 2015),
however it has been shown that incorporating syntactic in-
formation still remains useful (He et al., 2017).

stead, our approach learns span-level representa-
tions from phrase-type supervision directly, for se-
mantic tasks. Additionally, these methods explore
architectural variations in RNN layers for includ-
ing supervision, whereas we focus on incorporat-
ing supervision with minimal changes to the base-
line architecture. To the best of our knowledge,
such simpliﬁed syntactic scaﬀolds have not been
tried before.

Word embeddings. Our deﬁnition of a scaﬀold
task almost includes stand-alone methods for es-
timating word embeddings (Mikolov et al., 2013;
Pennington et al., 2014; Peters et al., 2018). Af-
ter training word embeddings, the tasks implied
by models like the skip-gram or ELMo’s language
model become irrelevant to the downstream use of
the embeddings. A noteworthy diﬀerence is that,
rather than pre-training, a scaﬀold is integrated di-
rectly into the training of T1 through a multitask
objective.

Multitask learning. Neural architectures have
often yielded performance gains when trained for
multiple tasks together (Collobert et al., 2011; Lu-
ong et al., 2015; Chen et al., 2017; Hashimoto
et al., 2017). In particular, performance of seman-
tic role labeling tasks improves when done jointly
with other semantic tasks (FitzGerald et al., 2015;
Peng et al., 2017, 2018). Contemporaneously with
this work, Hershcovich et al. (2018) proposed a
multitask learning setting for universal syntactic
dependencies and UCCA semantics (Abend and
Rappoport, 2013). Syntactic scaﬀolds focus on a
primary semantic task, treating syntax as an auxil-
lary, eventually forgettable prediction task.

4 Syntactic Scaﬀold Model

We assume two sources of supervision: a cor-
pus D1 with instances x annotated for the primary
task’s outputs y (semantic role labeling or corefer-
ence resolution), and a treebank D2 with sentences
x, each with a phrase-structure tree z.

4.1 Loss

Each task has an associated loss, and we seek to
minimize the combination of task losses,

(cid:88)

(x,y)∈D1

(cid:88)

(x,z)∈D2

L1(x, y) + δ

L2(x, z)

(1)

with respect to parameters, which are partially
shared, where δ is a tunable hyperparameter. In

Each input

the rest of this section, we describe the scaﬀold
task. We deﬁne the primary tasks in Sections 5–6.
is a sequence of tokens, x =
(cid:104)x1, x2, . . . , xn(cid:105), for some n. We refer to a span
of contiguous tokens in the sentence as xi: j =
(cid:104)xi, xi+1, . . . , x j(cid:105), for any 1 (cid:54) i (cid:54) j (cid:54) n. In our
experiments we consider only spans up to a maxi-
mum length D, resulting in O(nD) spans.

Supervision comes from a phrase-syntactic tree
z for the sentence, comprising a syntactic category
zi: j ∈ C for every span xi: j in x (many spans are
given a null label). We experiment with diﬀerent
sets of labels C (§4.2).

In our model, every span xi: j is represented by
an embedding vector vi: j (see details in §5.3). A
distribution over the category assigned to zi: j is de-
rived from vi: j:

p(zi: j = c | xi: j) = softmax

wc · vi: j

(2)

c

where wc is a parameter vector associated with
category c. We sum the log loss terms for all the
spans in a sentence to give its loss:

L2(x, z) = −

log p(zi: j | xi: j).

(3)

(cid:88)

1(cid:54)i(cid:54) j(cid:54)n
j−i(cid:54)D

4.2 Labels for the Syntactic Scaﬀold Task
Diﬀerent kinds of syntactic labels can be used for
learning syntactically-aware span representations:
• Constituent identity: C = {0, 1}; is a span a

constituent, or not?

• Non-terminal: c is the category of a span,

including a null for non-constituents.

• Non-terminal and parent: c is the category
of a span, concatenated with the category of
its immediate ancestor. null is used for non-
constituents, and for empty ancestors.

• Common non-terminals: Since a majority
of semantic arguments and entity mentions
are labeled with a small number of syntac-
tic categories,3 we experiment with a three-
way classiﬁcation among (i) noun phrase (or
prepositional phrase, for frame SRL); (ii) any
other category; and (iii) null.

In Figure 1, for the span “encouraging them”,
the constituent identity scaﬀold label is 1, the non-
terminal label is S|VP, the non-terminal and par-
ent label is S|VP+par=PP, and the common non-
terminals label is set to OTHER.

3In the OntoNotes corpus, which includes both syntac-
tic and semantic annotations, 44% of semantic arguments are
noun phrases and 13% are prepositional phrases.

5 Semantic Role Labeling

We contribute a new SRL model which contributes
a strong baseline for experiments with syntactic
scaﬀolds. The performance of this baseline itself
is competitive with state-of-the-art methods (§7).

In the FrameNet

FrameNet.
lexicon (Baker
et al., 1998), a frame represents a type of event,
situation, or relationship, and is associated with a
set of semantic roles, called frame elements. A
frame can be evoked by a word or phrase in a sen-
tence, called a target. Each frame element of an
evoked frame can then be realized in the sentence
as a sentential span, called an argument (or it can
be unrealized). Arguments for a given frame do
not overlap.

PropBank. PropBank similarly disambiguates
predicates and identiﬁes argument spans. Tar-
gets are disambiguated to lexically speciﬁc senses
rather than shared frames, and a set of generic
roles is used for all targets, reducing the argument
label space by a factor of 17. Most importantly,
the arguments were annotated on top of syntactic
constituents, directly coupling syntax and seman-
tics. A detailed example for both formalisms is
provided in Figure 1.

Semantic structure prediction is the task of iden-
tifying targets, labeling their frames or senses, and
labeling all their argument spans in a sentence.
Here we assume gold targets and frames, and con-
sider only the SRL task.

Formally, a single input instance for argument
identiﬁcation consists of: an n-word sentence x =
(cid:104)x1, x2, . . . , xn(cid:105), a single target span t = (cid:104)tstart, tend(cid:105),
f . The argu-
and its evoked frame, or sense,
ment labeling task is to produce a segmentation
of the sentence: s = (cid:104)s1, s2, . . . , sm(cid:105) for each in-
put x. A segment s = (cid:104)i, j, yi: j(cid:105) corresponds to
a labeled span of the sentence, where the label
yi: j ∈ Y f ∪ {null} is either a role that the span
ﬁlls, or null if the span does not ﬁll any role. In
the case of PropBank, Y f consists of all possible
roles. The segmentation is constrained so that ar-
gument spans cover the sentence and do not over-
lap (ik+1 = 1 + jk for sk; i1 = 1; jm = n). Segments
of length 1 such that i = j are allowed. A separate
segmentation is predicted for each target annota-
tion in a sentence.

5.1 Semi-Markov CRF

of log-likelihood:

In order to model the non-overlapping arguments
of a given target, we use a semi-Markov condi-
tional random ﬁeld (semi-CRF; Sarawagi et al.,
2004). Semi-CRFs deﬁne a conditional distribu-
tion over labeled segmentations of an input se-
quence, and are globally normalized. A single tar-
get’s arguments can be neatly encoded as a labeled
segmentation by giving the spans in between argu-
ments a reserved null label. Semi-Markov mod-
els are more powerful than BIO tagging schemes,
which have been used successfully for PropBank
SRL (Collobert et al., 2011; Zhou and Xu, 2015,
inter alia), because the semi-Markov assumption
allows scoring variable-length segments, rather
than ﬁxed-length label n-grams as under an (n −
1)-order Markov assumption. Computing the
marginal likelihood with a semi-CRF can be done
using dynamic programming in O(n2) time (§5.2).
By ﬁltering out segments longer than D tokens,
this is reduced to O(nD).

Given an input x, a semi-CRF deﬁnes a condi-
tional distribution p(s | x). Every segment s =
(cid:104)i, j, yi: j(cid:105) is given a real-valued score, ψ((cid:104)i, j, yi: j =
r(cid:105), xi: j) = wr · vi: j, where vi: j is an embedding
of the span (§5.3) and wr is a parameter vector
corresponding to its label. The score of the en-
tire segmentation s is the sum of the scores of
its segments: Ψ(x, s) = (cid:80)m
k=1 ψ(sk, xik: jk ). These
scores are exponentiated and normalized to deﬁne
the probability distribution. The sum-product vari-
ant of the semi-Markov dynamic programming al-
gorithm is used to calculate the normalization term
(required during learning). At test time, the max-
product variant returns the most probable segmen-
tation, ˆs = arg max sΨ(s, x).

The parameters of the semi-CRF are learned to
maximize a criterion related to the conditional log-
likelihood of the gold-standard segments in the
training corpus (§5.2). The learner evaluates and
adjusts segment scores ψ(sk, x) for every span in
the sentence, which in turn involves learning em-
bedded representations for all spans (§5.3).

5.2 Softmax-Margin Objective

Typically CRF and semi-CRF models are trained
to maximize a conditional log-likelihood objec-
tive.
In early experiments, we found that incor-
porating a structured cost was beneﬁcial; we do
so by using a softmax-margin training objective
(Gimpel and Smith, 2010), a “cost-aware” variant

L1 = −

(cid:88)

log

exp Ψ(s∗, x)
Z(x, s∗)

,

(cid:88)

(x,s∗)∈D1
exp {Ψ(s, x) + cost(s, s∗)}.

Z(x, s∗) =

(4)

(5)

s

(cid:88)

s∈s

We design the cost function so that it factors by
predicted span, in the same way Ψ does:

cost(s, s∗) =

cost(s, s∗) =

I(s (cid:60) s∗).

(6)

(cid:88)

s∈s

The softmax-margin criterion, like log-likelihood,
is globally normalized over all of the exponentially
many possible labeled segmentations. The follow-
ing zeroth-order semi-Markov dynamic program
(Sarawagi et al., 2004) eﬃciently computes the
new partition function:
(cid:88)

αi−1 exp{Ψ(s, x) + cost(s, s∗)},

(7)

α j =

s=(cid:104)i, j,yi: j(cid:105)
j−i(cid:54)D

where Z = αn, under the base case α0 = 1.

The prediction under the model can be calcu-
lated using a similar dynamic program with the
following recurrence where γ0 = 1:

γ j = max
s=(cid:104)i, j,yi: j(cid:105)
j−i(cid:54)D

γi−1 exp Ψ(s, x).

(8)

Our model formulation enforces that arguments do
not overlap. We do not enforce any other SRL
constraints, such as non-repetition of core frame
elements (Das et al., 2012).

5.3

Input Span Representation

This section describes the neural architecture used
to obtain the span embedding, vi: j, correspond-
ing to a span xi: j and the target in consideration,
t = (cid:104)tstart, tend(cid:105). For the scaﬀold task, since the
syntactic treebank does not contain annotations for
semantic targets, we use the last verb in the sen-
tence as a placeholder target, wherever target fea-
tures are used. If there are no verbs, we use the
ﬁrst token in the sentence as a placeholder target.
The parameters used to learn v are shared between
the tasks.

We construct an embedding for the span using
• hi and h j: contextualized embeddings for the

words at the span boundary (§5.3.1),

• ui: j: a span summary that pools over the con-

tents of the span (§5.3.2), and

• ai: j: and a hand-engineered feature vector for

the span (§5.3.3).

This embedding is then passed to a feedforward

layer to compute the span representation, vi: j.

5.3.1 Contextualized Token Embeddings

To obtain contextualized embeddings of each to-
ken in the input sequence, we run a bidirectional
LSTM (Graves, 2012) with (cid:96) layers over the full
input sequence. To indicate which token is a pred-
icate, a linearly transformed one-hot embedding v
is used, following Zhou and Xu (2015) and He
et al. (2017). The input vector representing the
token at position q in the sentence is the concate-
nation of a ﬁxed pretrained embedding xq and vq.
When given as input to the bidirectional LSTM,
this yields a hidden state vector hq representing
the qth token in the context of the sentence.

5.3.2 Span Summary
Tokens within a span might convey diﬀerent
amounts of information necessary to label the span
as a semantic argument. Following Lee et al.
(2017), we use an attention mechanism (Bahdanau
et al., 2014) to summarize each span. Each con-
textualized token in the span is passed through a
feed-forward network to obtain a weight, normal-
ized to give σk = softmax
whead · hk, where whead
is a learned parameter. The weights σ are then
used to obtain a vector that summarizes the span,
ui: j = (cid:80)

i(cid:54)k(cid:54) j; j−i<D σk · hk.

i(cid:54)k(cid:54) j

5.3.3 Span Features

We use the following three features for each span:
• width of the span in tokens (Das et al., 2014)
• distance (in tokens) of the span from the tar-

get (T¨ackstr¨om et al., 2015)

• position of the span with respect to the tar-
get (before, after, overlap) (T¨ackstr¨om et al.,
2015)

Each of these features is encoded as a one-hot-
embedding and then linearly transformed to yield
a feature vector, ai: j.

6 Coreference Resolution

Coreference resolution is the task of determin-
ing clusters of mentions that refer to the same
entity. Formally, the input is a document x =
x1, x2, . . . , xn consisting of n words. The goal is
to predict a set of clusters c = {c1, c2, . . .}, where
each cluster c = {s1, s2, . . .} is a set of spans and

each span s = (cid:104)i, j(cid:105) is a pair of indices such that
1 (cid:54) i (cid:54) j (cid:54) n.

As a baseline, we use the model of Lee et al.
(2017), which we describe brieﬂy in this section.
This model decomposes the prediction of coref-
erence clusters into a series of span classiﬁcation
decisions. Every span s predicts an antecedent
ws ∈ Y(s) = {null, s1, s2, . . . , sm}. Labels s1 to
sm indicate a coreference link between s and one
of the m spans that precede it, and null indicates
that s does not link to anything, either because it
is not a mention or it is in a singleton cluster. The
predicted clustering of the spans can be recovered
by aggregating the predicted links.

Analogous to the SRL model (§5), every span
s is represented by an embedding vs, which is
central to the model. For each span s and a po-
tential antecedent a ∈ Y(s), pairwise coreference
scores Ψ(vs, va, φ(s, a)) are computed via feedfor-
ward networks with the span embeddings as input.
φ(s, a) are pairwise discrete features encoding the
distance between span s and span a and metadata,
such as the genre and speaker information. We re-
fer the reader to Lee et al. (2017) for the details of
the scoring function.

The scores from Ψ are normalized over the pos-
sible antecedents Y(s) of each span to induce a
probability distribution for every span:

p(ws = a) = softmax
a∈Y(s)

Ψ(vs, va, φ(s, a))

(9)

In learning, we minimize the negative log-
likelihood marginalized over the possibly correct
antecedents:

L1 = −

(cid:88)

log

(cid:88)

p(ws = a∗)

(10)

s∈D

a∗∈G(s)∩Y(s)

where D is the set of spans in the training dataset,
and G(s) indicates the gold cluster of s if it belongs
to one and {null} otherwise.

To operate under reasonable computational re-
quirements, inference under this model requires a
two-stage beam search, which reduces the number
of span pairs considered. We refer the reader to
Lee et al. (2017) for details.

Input span representation. The input span em-
bedding, vs for coreference resolution and its syn-
tactic scaﬀold follow the deﬁnition used in §5.3,
with the key diﬀerence of using no target features.
Since there is a complete overlap of input sen-
tences between Dsc and Dpr as the coreference an-
notations are also from OntoNotes (Pradhan et al.,

2012), we reuse the v for the scaﬀold task. Addi-
tionally, instead of the entire document, each sen-
tence in it is independently given as input to the
bidirectional LSTMs.

7 Results

We evaluate our models on the test set of
FrameNet 1.5 for frame SRL and on the test set
of OntoNotes for both PropBank SRL and coref-
erence. For the syntactic scaﬀold in each case,
we use syntactic annotations from OntoNotes
5.0 (Weischedel et al., 2013; Pradhan et al.,
2013).4 Further details on experimental settings
and datasets have been elaborated in the supple-
mental material.

Frame SRL. Table 1 shows the performance of
all the scaﬀold models on frame SRL with respect
to prior work and a semi-CRF baseline (§5.1)
without a syntactic scaﬀold. We follow the oﬃ-
cial evaluation from the SemEval shared task for
frame-semantic parsing (Baker et al., 2007).

Prior work for frame SRL has relied on pre-
dicted syntactic trees, in two diﬀerent ways: by
using syntax-based rules to prune out spans of text
that are unlikely to contain any frame’s argument;
and by using syntactic features in their statistical
model (Das et al., 2014; T¨ackstr¨om et al., 2015;
FitzGerald et al., 2015; Kshirsagar et al., 2015).

The best published results on FrameNet 1.5 are
due to Yang and Mitchell (2017). In their sequen-
tial model (seq), they treat argument identiﬁcation
as a sequence-labeling problem using a deep bidi-
rectional LSTM with a CRF layer. In their rela-
tional model (Rel), they treat the same problem as
a span classiﬁcation problem. Finally, they intro-
duce an ensemble to integerate both models, and
use an integer linear program for inference satis-
fying SRL constraints. Though their model does
not do any syntactic pruning, it does use syntactic
features for argument identiﬁcation and labeling.5
Notably, all prior systems for frame SRL listed
in Table 1 use a pipeline of syntax and seman-
tics. Our semi-CRF baseline outperforms all prior
work, without any syntax. This highlights the ben-

4http://cemantix.org/data/ontonotes.html
5Yang and Mitchell (2017) also evaluated on the full
frame-semantic parsing task, which includes frame-SRL as
well as identifying frames. Since our frame SRL performance
improves over theirs, we expect that incorporation into a full
system (e.g., using their frame identiﬁcation module) would
lead to overall beneﬁts as well; this experiment is left to fu-
ture work.

eﬁts of modeling spans and of global normaliza-
tion.

Turning to scaﬀolds, even the most coarse-
grained constituent identity scaﬀold improves the
performance of our syntax-agnostic baseline. The
nonterminal and nonterminal and parent scaﬀolds,
which use more detailed syntactic representations,
improve over this. The greatest improvements
come from the scaﬀold model predicting com-
mon nonterminal labels (NP and PP, which are the
most common syntactic categories of semantic ar-
guments, vs. others): 3.6% absolute improvement
in F1 measure over prior work.

Contemporaneously with this work, Peng et al.
(2018) proposed a system for joint frame-semantic
and semantic dependency parsing. They report re-
sults for joint frame and argument identiﬁcation,
and hence cannot be directly compared in Table 1.
We evaluated their output for argument identiﬁca-
tion only; our semi-CRF baseline model exceeds
their performance by 1 F1, and our common non-
terminal scaﬀold by 3.1 F1.6

Model

Prec. Rec.

Kshirsagar et al. (2015)
Yang and Mitchell (2017) (Rel)
Yang and Mitchell (2017) (Seq)
†Yang and Mitchell (2017) (All)

Semi-CRF baseline

+ constituent identity
+ nonterminal and parent
+ nonterminal
+ common nonterminals

66.0
71.8
63.4
70.2

67.8

68.1
68.8
69.4
69.2

60.4
57.7
66.4
60.2

66.2

67.4
68.2
68.0
69.0

F1

63.1
64.0
64.9
65.5

67.0

67.7
68.5
68.7
69.1

Table 1: Frame SRL results on the test set of
FrameNet 1.5., using gold frames. Ensembles are
denoted by †.

Model

Prec. Rec.

Zhou and Xu (2015)
He et al. (2017)
He et al. (2018a)
Tan et al. (2018)

Semi-CRF baseline

+ common nonterminals

-
81.7
83.9
81.9

84.8

85.1

-
81.6
73.7
83.6

81.2

82.6

F1

81.3
81.7
82.1
82.7

83.0

83.8

Table 2: PropBank sSRL results, using gold pred-
icates, on CoNLL 2012 test. For fair comparison,
we show only non-ensembled models.

6This result is not reported in Table 1 since Peng et al.
(2018) used a preprocessing which renders the test set slightly
larger — the diﬀerence we report is calculated using their test
set.

Model

MUC
Prec. Rec. F1

B3
Prec. Rec. F1

CEAFφ4
Prec. Rec. F1

Avg. F1

Wiseman et al. (2016)
77.5 69.8 73.4
Clark and Manning (2016b) 79.9 69.3 74.2
Clark and Manning (2016a) 79.2 70.4 74.6

66.8 57.0 61.5
71.0 56.5 63.0
69.9 58.0 63.4

62.1 53.9 57.7
63.8 54.3 58.7
63.5 55.5 59.2

Lee et al. (2017)

78.4 73.4 75.8
+ common nonterminals 78.4 74.3 76.3

68.6 61.8 65.0

62.7 59.0 60.8

68.7 62.9 65.7

62.9 60.2 61.5

64.2
65.3
65.7

67.2

67.8

Table 3: Coreference resolution results on the test set on the English CoNLL-2012 shared task. The
average F1 of MUC, B3, and CEAFφ4 is the main evaluation metric. For fair comparison, we show only
non-ensembled models.

PropBank SRL. We use the OntoNotes data
from the CoNLL shared task in 2012 (Pradhan
et al., 2013) for Propbank SRL. Table 2 reports
results using gold predicates.

Recent competitive systems for PropBank SRL
follow the approach of Zhou and Xu (2015), em-
ploying deep architectures, and forgoing the use of
any syntax. He et al. (2017) improve on those re-
sults, and in analysis experiments, show that con-
straints derived using syntax may further improve
performance. Tan et al. (2018) employ a similar
approach but use feed-forward networks with self-
attention. He et al. (2018a) use a span-based clas-
siﬁcation to jointly identify and label argument
spans.

Our syntax-agnostic semi-CRF baseline model
improves on prior work (excluding ELMo), show-
ing again the value of global normalization in se-
mantic structure prediction. We obtain further im-
provement of 0.8 absolute F1 with the best syn-
tactic scaﬀold from the frame SRL task. This in-
dicates that a syntactic inductive bias is beneﬁ-
cial even when using sophisticated neural archi-
tectures.

He et al. (2018a) also provide a setup where ini-
tialization was done with deep contextualized em-
beddings, ELMo (Peters et al., 2018), resulting in
85.5 F1 on the OntoNotes test set. The improve-
ments from ELMo are methodologically orthogonal
to syntactic scaﬀolds.

Since the datasets for learning PropBank se-
mantics and syntactic scaﬀolds completely over-
lap, the performance improvement cannot be at-
tributed to a larger training corpus (or, by exten-
sion, a larger vocabulary), though that might be a
factor for frame SRL.

A syntactic scaﬀold can match the performance
of a pipeline containing carefully extracted syntac-
tic features for semantic prediction (Swayamdipta
et al., 2017). This, along with other recent ap-

proaches (He et al., 2017, 2018b) show that syntax
remains useful, even with strong neural models for
SRL.

Coreference. We report the results on four stan-
dard scores from the CoNLL evaluation: MUC, B3
and CEAFφ4, and their average F1 in Table 3. Prior
competitive coreference resolution systems (Wise-
man et al., 2016; Clark and Manning, 2016b,a) all
incorporate synctactic information in a pipeline,
using features and rules for mention proposals
from predicted syntax.

Our baseline is the model from Lee et al.
(2017), described in §6. Similar to the baseline
model for frame SRL, and in contrast with prior
work, this model does not use any syntax.

We experiment with the best syntactic scaﬀold
from the frame SRL task. We used NP, OTHER, and
null as the labels for the common nonterminals
scaﬀold here, since coreferring mentions are rarely
prepositional phrases. The syntactic scaﬀold out-
performs the baseline by 0.6 absolute F1. Contem-
poraneously, Lee et al. (2018) proposed a model
which takes in account higher order inference and
more aggressive pruning, as well as initialization
with ELMo embeddings, resulting in 73.0 average
F1. All the above are orthogonal to our approach,
and could be incorporated to yield higher gains.

8 Discussion

To investigate the performance of the syntactic
scaﬀold, we focus on the frame SRL results, where
we observed the greatest improvement with re-
spect to a non-syntactic baseline.

We consider a breakdown of the performance
by the syntactic phrase types of the arguments,
provided in FrameNet7 in Figure 2. Not surpris-

7We used FrameNet syntactic phrase annotations for anal-
ysis only, and not in our models, since they are annotated only
for the gold arguments.

Figure 2: Performance breakdown by argu-
ment’s phrase category, sorted left to right by
frequency, for top ten phrase categories.

Figure 3: Performance breakdown by top ten
frame element types, sorted left to right by fre-
quency.

ingly, we observe large improvements in the com-
mon nonterminals used (NP and PP). However,
the phrase type annotations in FrameNet do not
correspond exactly to the OntoNotes phrase cat-
egories. For instance, FrameNet annotates non-
maximal (A) and standard adjective phrases (AJP),
while OntoNotes annotations for noun-phrases are
ﬂat, ignore the underlying adjective phrases. This
explains why the syntax-agnostic baseline is able
to recover the former while the scaﬀold is not.

Similarly, for frequent frame elements, scaﬀold-
ing improves performance across the board, as
shown in Fig. 3. The largest improvements come
for Theme and Goal, which are predominantly re-
alized as noun phrases and prepositional phrases.

9 Conclusion

We introduced syntactic scaﬀolds, a multitask
learning approach to incorporate syntactic bias
into semantic processing tasks. Unlike pipelines
and approaches which jointly model syntax and
semantics, no explicit syntactic processing is re-
quired at runtime. Our method improves the per-
formance of competitive baselines for semantic
role labeling on both FrameNet and PropBank,
and for coreference resolution. While our focus
was on span-based tasks, syntactic scaﬀolds could
be applied in other settings (e.g., dependency and
graph representations). Moreover, scaﬀolds need
not be syntactic; we can imagine, for example, se-
mantic scaﬀolds being used to improve NLP appli-
cations with limited annotated data. It remains an
open empirical question to determine the relative
merits of diﬀerent kinds of scaﬀolds and multi-
task learners, and how they can be most produc-

tively combined. Our code is publicly available at
https://github.com/swabhs/scaffolding.

Acknowledgments

We thank several members of UW-NLP, partic-
ularly Luheng He, as well as David Weiss and
Emily Pitler for thoughtful discussions on prior
versions of this paper. We also thank the three
anonymous reviewers for their valuable feedback.
This work was supported in part by NSF grant IIS-
1562364 and by the NVIDIA Corporation through
the donation of a Tesla GPU.

References

Omri Abend and Ari Rappoport. 2013. Universal Con-
ceptual Cognitive Annotation (UCCA). In ACL.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2014. Neural machine translation by jointly
learning to align and translate. ArXiv:1409.0473.

Collin Baker, Michael Ellsworth, and Katrin Erk. 2007.
SemEval’07 Task 19: Frame semantic structure ex-
traction. In Proc. of SemEval.

Collin F. Baker, Charles J. Fillmore, and John B. Lowe.
1998. The Berkeley FrameNet project. In Proc. of
ACL.

Rich Caruana. 1997. Multitask learning. Machine

Learning, 28(1).

Xinchi Chen, Zhan Shi, Xipeng Qiu, and Xuanjing
Huang. 2017. Adversarial multi-criteria learning for
chinese word segmentation. ArXiv:1704.07556.

Kevin Clark and Christopher D Manning. 2016a. Deep
reinforcement learning for mention-ranking corefer-
ence models. In Proc. of EMNLP.

Kevin Clark and Christopher D. Manning. 2016b. Im-
proving coreference resolution by learning entity-
level distributed representations. In Proc. of ACL.

Luheng He, Kenton Lee, Mike Lewis, and Luke Zettle-
moyer. 2017. Deep semantic role labeling: What
works and what’s next. In Proc. of ACL.

Ronan Collobert, Jason Weston, L´eon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
Journal of Machine Learning Research,
scratch.
12:2493–2537.

Ann Copestake and Dan Flickinger. 2000.

An
open source grammar development environment and
broad-coverage English grammar using HPSG.
In
Proc. of LREC.

Dipanjan Das, Desai Chen, Andr´e FT Martins, Nathan
Frame-
linguistics,

Schneider, and Noah A Smith. 2014.
semantic parsing.
40(1):9–56.

Computational

Dipanjan Das, Andr´e F. T. Martins, and Noah A. Smith.
2012. An exact dual decomposition algorithm for
shallow semantic parsing with constraints. In Proc.
of *SEM.

Jenny Rose Finkel, Christopher D Manning, and An-
drew Y Ng. 2006. Solving the problem of cascading
errors: Approximate bayesian inference for linguis-
tic annotation pipelines. In Proc. of EMNLP.

Nicholas FitzGerald, Oscar T¨ackstr¨om, Kuzman
Ganchev, and Dipanjan Das. 2015. Semantic role
In Proc. of
labeling with neural network factors.
EMNLP.

Shexia He, Zuchao Li, Hai Zhao, and Hongxiao Bai.
2018b. Syntax for semantic role labeling, to be, or
not to be. In Proc. of ACL.

James Henderson, Paola Merlo,

Ivan Titov, and
Gabriele Musillo. 2013. Multi-lingual joint pars-
ing of syntactic and semantic dependencies with a
latent variable model. Computational Linguistics,
39(4):949–998.

Daniel Hershcovich, Omri Abend, and Ari Rappoport.
2018. Multitask parsing across semantic representa-
tions. In Proc. of ACL.

Diederik

P. Kingma

2014.
and
ADAM: A method for stochastic optimization.
ArXiV:1412.6980.

Jimmy Ba.

Lingpeng Kong, Chris Dyer, and Noah A. Smith. 2016.
Segmental Recurrent Neural Networks. In Proc. of
ICLR.

Meghana Kshirsagar, Sam Thomson, Nathan Schnei-
der, Jaime Carbonell, Noah A Smith, and Chris
Dyer. 2015. Frame-semantic role labeling with het-
erogeneous annotations. In Proc. of NAACL.

Kenton Lee, Luheng He, Mike Lewis, and Luke Zettle-
moyer. 2017. End-to-end neural coreference resolu-
tion. In Proc. of EMNLP.

Daniel Gildea and Daniel Jurafsky. 2002. Automatic
labeling of semantic roles. Computational Linguis-
tics, 28(3):245–288.

Kenton Lee, Luheng He, and Luke Zettlemoyer. 2018.
Higher-order coreference resolution with coarse-to-
ﬁne inference. In Proc. of NAACL.

Daniel Gildea and Martha Palmer. 2002. The necessity
of parsing for predicate argument recognition.
In
Proc. of ACL.

Kevin Gimpel and Noah A. Smith. 2010. Softmax-
margin CRFs: Training log-linear models with cost
functions. In Proc. of NAACL.

Alex Graves. 2012. Supervised Sequence Labelling
with Recurrent Neural Networks, volume 385 of
Studies in Computational Intelligence. Springer.

Alex Graves. 2013. Generating sequences with recur-

rent neural networks. ArXiv:1308.0850.

Kazuma Hashimoto, Caiming Xiong, Yoshimasa Tsu-
ruoka, and Richard Socher. 2017. A joint many-task
model: Growing a neural network for multiple NLP
tasks. In Proc. of EMNLP.

He He, Hal Daum´e III, and Jason Eisner. 2013. Dy-
namic feature selection for dependency parsing. In
Proc. of EMNLP.

Luheng He, Kenton Lee, Omer Levy, and Luke Zettle-
moyer. 2018a. Jointly predicting predicates and ar-
guments in neural semantic role labeling. In Proc.
of ACL.

Xavier Llu´ıs, Xavier Carreras, and Llu´ıs M`arquez.
2013.
Joint arc-factored parsing of syntactic and
semantic dependencies. Transactions of the ACL,
1:219–230.

Xavier Llu´ıs and Llu´ıs M`arquez. 2008. A joint model
for parsing syntactic and semantic dependencies. In
Proc. of CoNLL.

Minh-Thang Luong, Quoc V Le, Ilya Sutskever, Oriol
Vinyals, and Lukasz Kaiser. 2015. Multi-task se-
quence to sequence learning. ArXiv:1511.06114.

Tomas Mikolov, Kai Chen, Gregory S. Corrado, and
Jeﬀrey Dean. 2013. Eﬃcient estimation of word
representations in vector space. ArXiv:1301.3781.

Vinod Nair and Geoﬀrey E. Hinton. 2010. Rectiﬁed
linear units improve restricted Boltzmann machines.
In Proc. of ICML.

Jason Naradowsky, Sebastian Riedel, and David A.
Improving NLP through marginal-
In Proc. of

Smith. 2012.
ization of hidden syntactic structure.
EMNLP.

Vincent Ng. 2010. Supervised noun phrase coreference
research: The ﬁrst ﬁfteen years. In Proc. of ACL.

Martha Palmer, Daniel Gildea, and Paul Kingsbury.
2005. The Proposition Bank: An annotated cor-
pus of semantic roles. Computational Linguistics,
31(1):71–106.

Swabha Swayamdipta, Sam Thomson, Chris Dyer, and
Noah A. Smith. 2017. Frame-semantic parsing with
softmax-margin segmental rnns and a syntactic scaf-
fold. Arxiv:1706.09528.

Hao Peng, Sam Thomson, and Noah A. Smith. 2017.
Deep multitask learning for semantic dependency
parsing. In Proc. of ACL.

Hao Peng, Sam Thomson, Swabha Swayamdipta, and
Noah A. Smith. 2018. Learning joint semantic
parsers from disjoint data. In Proc. of NAACL.

Jeﬀrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. GloVe: Global vectors for
word representation. In Proc. of EMNLP.

Matthew E Peters, Mark Neumann, Mohit Iyyer, Matt
Gardner, Christopher Clark, Kenton Lee, and Luke
Zettlemoyer. 2018. Deep contextualized word rep-
resentations. ArXiv:1802.05365.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Hwee Tou Ng, Anders Bj¨orkelund, Olga Uryupina,
Yuchen Zhang, and Zhi Zhong. 2013. Towards ro-
bust linguistic analysis using OntoNotes. In Proc. of
CoNLL.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Olga Uryupina, and Yuchen Zhang. 2012. CoNLL-
2012 shared task: Modeling multilingual unre-
In Proc. of
stricted coreference in OntoNotes.
EMNLP.

Vasin Punyakanok, Dan Roth, and Wen-tau Yih. 2008.
The importance of syntactic parsing and inference in
semantic role labeling. Computational Linguistics,
34(2):257–287.

Pranav Rajpurkar,

Jian Zhang, Konstantin Lopy-
rev, and Percy Liang. 2016. SQuAD: 100,000+
questions for machine comprehension of
text.
ArXiv:1606.05250.

Oscar T¨ackstr¨om, Kuzman Ganchev, and Dipanjan
Das. 2015. Eﬃcient inference and structured learn-
ing for semantic role labeling. Transactions of the
ACL, 3:29–41.

Zhixing Tan, Mingxuan Wang, Jun Xie, Yidong Chen,
and Xiaodong Shi. 2018. Deep semantic role label-
ing with self-attention. In Proc. of AAAI.

Kristina Toutanova, Aria Haghighi, and Christopher D.
joint model for se-
Manning. 2008. A global
mantic role labeling. Computational Linguistics,
34(2):161–191.

Ralph Weischedel, Martha Palmer, Mitchell Marcus,
Eduard Hovy, Sameer Pradhan, Lance Ramshaw,
Nianwen Xue, Ann Taylor, Jeﬀ Kaufman, Michelle
Franchini, et al. 2013. OntoNotes release 5.0
ldc2013t19. Linguistic Data Consortium, Philadel-
phia, PA.

Sam Wiseman, Alexander M Rush, and Stuart M
Shieber. 2016. Learning global features for coref-
erence resolution. In Proc. of NAACL.

David H Wolpert. 1992. Stacked generalization. Neu-

ral networks, 5(2):241–259.

Bishan Yang and Tom Mitchell. 2017. A joint sequen-
tial and relational model for frame-semantic parsing.
In Proc. of EMNLP.

Luke S Zettlemoyer and Michael Collins. 2005. Learn-
ing to map sentences to logical form: Structured
classiﬁcation with probabilistic categorial gram-
mars. In Proc. of UAI.

Yuan Zhang and David Weiss. 2016.

Stack-
propagation: Improved representation learning for
syntax. In Proc. of ACL.

Sunita Sarawagi, William W Cohen, et al. 2004. Semi-
markov conditional random ﬁelds for information
extraction. In Proc. of NIPS, volume 17.

Jie Zhou and Wei Xu. 2015. End-to-end learning of
semantic role labeling using recurrent neural net-
works. In Proc. of ACL.

Anders Søgaard and Yoav Goldberg. 2016. Deep
multi-task learning with low level tasks supervised
at lower layers. In Proc. of ACL.

Rupesh Kumar Srivastava, Klaus Greﬀ, and J¨urgen
Schmidhuber. 2015. Training very deep networks.
In Proc. of NIPS.

Mark Steedman. 2000.

Information structure and
the syntax-phonology interface. Linguistic Inquiry,
31(4):649–689.

Swabha Swayamdipta, Miguel Ballesteros, Chris Dyer,
and Noah A. Smith. 2016. Greedy, joint syntactic-
In Proc. of
semantic parsing with Stack LSTMs.
CoNLL.

We limit the maximum length of spans to D =
15 in FrameNet, resulting in oracle recall of 95%
on the development set, and to 13 in Propbank,
resulting in an oracle recall of 96%. An identical
maximum span length is used for the scaﬀold task.
For the SRL scaﬀolds, we randomly sample in-
stances from OntoNotes to match the size of the
SRL data, and alternate between training an SRL
batch and a scaﬀold batch.
In FrameNet, this
amounts to downsampling OntoNotes. For Prop-
Bank SRL, this amounts to upsampling syntactic
annotations from OntoNotes, since a sentence has
a single syntactic tree, but could have multiple tar-
get annotations, each of which is a training in-
stance.

The mixing ratio, δ is set to 1.0 (tuned across
{0.1, 0.5, 1.0, 1.5}) for frame and PropBank SRL.
We use Adam (Kingma and Ba, 2014) for opti-
mization, at a learning rate of 0.001, and a mini-
batch of size 32. Our dynamic program formula-
tion for loss computation and inference under the
semi-CRF is also batched. To prevent exploding
gradients, the 2-norm of the gradient is clipped
to 1 before a gradient update (Graves, 2013). All
models are trained for a maximum of 20 epochs,
and stopped early based on dev F1.

We extended the AllenNLP library,9 which is
built on top of PyTorch.10 Each experiment was
run on a single TitanX GPU.

For the coreference model, we use the same
hyperparameters and experimental settings from
Lee et al. (2017). The only new hyperparameter
needed for scaﬀolding is the mixing ratio, δ, which
we set to 0.1 based on performance on the valida-
tion set.

A Supplementary Material

A.1 Datasets

We used the full-text portion of FrameNet 1.5 re-
lease8 for frame-semantic role labeling. We use
the same test set as Das et al. (2014), and cre-
ate a validation set by selecting 8 documents from
the train set. The dataset contains 3,139 train sen-
tences with 16,621 target annotations, 387 valida-
tion sentences with 2,282 targets, and 2,420 test
sentences with 4,427 targets. Each target from a
given sentence is treated as an independent train-
ing instance. Following T¨ackstr¨om et al. (2015),
we only use the ﬁrst annotation for each target
with multiple annotations.

We use

the standard splits provided in
OntoNotes for the CoNLL 2012 shared task.
The dataset contains 115,812 train sentences with
278,026 target annotations, 15,680 validation sen-
tences with 38,377 targets, and 12,217 test sen-
tences with 29,669 targets.

We use the English coreference resolution data
from the CoNLL 2012 shared task (Pradhan et al.,
2012), containing 2,802, 343 and 348 documents
for train, validation, and test respectively.

Syntax OntoNotes contains 115,812 training in-
stances for the syntactic scaﬀold. There is no
overlap between FrameNet and OntoNotes train-
ing data.

A.2 Experimental Settings

We used GloVe embeddings (Pennington et al.,
2014) for tokens in the vocabulary, with out of
vocabulary words being initialized randomly. For
frame-SRL, 300 dimensional embeddings were
used, and kept ﬁxed during training. For Prop-
Bank SRL, we used 100 dimensional embed-
dings which were updated during training. A
100-dimensional embedding is learned for indi-
cating target positions, following Zhou and Xu
(2015). Bidirectional LSTMs with highway con-
nections (Srivastava et al., 2015) between 6 layers
are used, each layer containing 300-dimensional
hidden states. A dropout of 0.1 is applied to the
LSTMs. The feed-forward networks are of di-
mension 150 and of depth 2, with rectiﬁed linear
units (Nair and Hinton, 2010). A dropout of 0.2 is
applied to the feed-forward networks.

8A later release, 1.7 is also available, but for ease of com-
parison to other published systems we report results on the
earlier release.

9http://allennlp.org/
10http://pytorch.org/

Syntactic Scaﬀolds for Semantic Structures

Swabha Swayamdipta♠

Sam Thomson♠

Kenton Lee♦ Luke Zettlemoyer(cid:114) Chris Dyer♥ Noah A. Smith(cid:114)♣

♠Language Technologies Institute, Carnegie Mellon University, Pittsburgh, PA, USA
♦Google AI Language, Seattle WA, USA
(cid:114)Paul G. Allen School of Computer Science & Engineering, University of Washington, Seattle, WA, USA
♥Google DeepMind, London, UK
♣Allen Institute for Artiﬁcial Intelligence, Seattle, WA, USA
{swabha,sammthomson}@cs.cmu.edu {kentonl,cdyer}@google.com
{lsz,nasmith}@cs.washington.edu

8
1
0
2
 
g
u
A
 
0
3
 
 
]
L
C
.
s
c
[
 
 
1
v
5
8
4
0
1
.
8
0
8
1
:
v
i
X
r
a

Abstract

We introduce the syntactic scaﬀold, an ap-
proach to incorporating syntactic informa-
tion into semantic tasks. Syntactic scaﬀolds
avoid expensive syntactic processing at run-
time, only making use of a treebank during
training, through a multitask objective. We im-
prove over strong baselines on PropBank se-
mantics, frame semantics, and coreference res-
olution, achieving competitive performance on
all three tasks.

1

Introduction

As algorithms for the semantic analysis of natu-
ral language sentences have developed, the role
of syntax has been repeatedly revisited. Linguis-
tic theories have argued for a very tight integra-
tion of syntactic and semantic processing (Steed-
man, 2000; Copestake and Flickinger, 2000), and
many systems have used syntactic dependency
or phrase-based parsers as preprocessing for se-
mantic analysis (Gildea and Palmer, 2002; Pun-
yakanok et al., 2008; Das et al., 2014). Mean-
while, some recent methods forgo explicit syntac-
tic processing altogether (Zhou and Xu, 2015; He
et al., 2017; Lee et al., 2017; Peng et al., 2017).

Because annotated training datasets for se-
mantics will always be limited, we expect that
syntax—which oﬀers an incomplete but poten-
tially useful view of semantic structure—will con-
tinue to oﬀer useful inductive bias, encouraging
semantic models toward better generalization. We
address the central question: is there a way for se-
mantic analyzers to beneﬁt from syntax without
the computational cost of syntactic parsing?

We propose a multitask learning approach to
incorporating syntactic information into learned

representations of neural semantics models (§2).
Our approach, the syntactic scaﬀold, minimizes
an auxiliary supervised loss function, derived from
a syntactic treebank. The goal is to steer the dis-
tributed, contextualized representations of words
and spans toward accurate semantic and syntactic
labeling. We avoid the cost of training or execut-
ing a full syntactic parser, and at test time (i.e.,
runtime in applications) the semantic analyzer has
no additional cost over a syntax-free baseline. Fur-
ther, the method does not assume that the syntactic
treebank overlaps the dataset for the primary task.
Many semantic tasks involve labeling spans, in-
cluding semantic role labeling (SRL; Gildea and
Jurafsky, 2002) and coreference resolution (Ng,
2010) (tasks we consider in this paper), as well
as named entity recognition and some reading
comprehension and question answering tasks (Ra-
jpurkar et al., 2016).
These spans are usu-
ally syntactic constituents (cf. PropBank; Palmer
et al., 2005), making phrase-based syntax a natu-
ral choice for a scaﬀold. See Figure 1 for an ex-
ample sentence with syntactic and semantic anno-
tations. Since the scaﬀold task is not an end in
itself, we relax the syntactic parsing problem to
a collection of independent span-level predictions,
with no constraint that they form a valid parse tree.
This means we never need to run a syntactic pars-
ing algorithm.

Our experiments demonstrate that the syntactic
scaﬀold oﬀers a substantial boost to state-of-the-
art baselines for two SRL tasks (§5) and corefer-
ence resolution (§6). Our models use the strongest
available neural network architectures for these
tasks, integrating deep representation learning (He
et al., 2017) and structured prediction at the level
of spans (Kong et al., 2016). For SRL, the base-

Figure 1: An example sentence with syntactic, PropBank and coreference annotations from OntoNotes,
and author-annotated frame-semantic structures. PropBank SRL arguments and coreference mentions are
annotated on top of syntactic constituents. All but one frame-semantic argument (Event) is a syntactic
constituent. Targets evoke frames shown in the color-coded layers.

line itself is a novel globally normalized structured
conditional random ﬁeld, which outperforms the
previous state of the art.1 Syntactic scaﬀolds re-
sult in further improvements over prior work—
3.6 absolute F1 in FrameNet SRL, 1.1 absolute
F1 in PropBank SRL, and 0.6 F1 in coreference
resolution (averaged across three standard scores).
Our code is open source and available at https:
//github.com/swabhs/scaffolding.

2 Syntactic Scaﬀolds

Multitask learning (Caruana, 1997) is a collec-
tion of techniques in which two or more tasks are
learned from data with at least some parameters
shared. We assume there is only one task about
whose performance we are concerned, denoted T1
(in this paper, T1 is either SRL or coreference res-
olution). We use the term “scaﬀold” to refer to
a second task, T2, that can be combined with T1
during multitask learning. A scaﬀold task is only
used during training; it holds no intrinsic interest
beyond biasing the learning of T1, and after learn-
ing is completed, the scaﬀold is discarded.

A syntactic scaﬀold is a task designed to steer
the (shared) model toward awareness of syntactic

1This excludes models initialized with deep, contextual-
ized embeddings (Peters et al., 2018), an approach orthogonal
to ours.

structure.
It could be deﬁned through a syntac-
tic parser that shares some parameters with T1’s
model. Since syntactic parsing is costly, we use
simpler syntactic prediction problems (discussed
below) that do not produce whole trees.

As with multitask learning in general, we do not
assume that the same data are annotated with out-
puts for T1 and T2.
In this work, T2 is deﬁned
using phrase-structure syntactic annotations from
OntoNotes 5.0 (Weischedel et al., 2013; Pradhan
et al., 2013). We experiment with three settings:
one where the corpus for T2 does not overlap with
the training datasets for T1 (frame-SRL) and two
where there is a complete overlap (PropBank SRL
and coreference). Compared to approaches which
require multiple output labels over the same data,
we oﬀer the major advantage of not requiring any
assumptions about, or speciﬁcation of, the rela-
tionship between T1 and T2 output.

3 Related Work

We brieﬂy contrast the syntactic scaﬀold with ex-
isting alternatives.

Pipelines.
In a typical pipeline, T1 and T2 are
separately trained, with the output of T2 used to
deﬁne the inputs to T1 (Wolpert, 1992). Using
syntax as T2 in a pipeline is perhaps the most

common approach for semantic structure predic-
tion (Toutanova et al., 2008; Yang and Mitchell,
2017; Wiseman et al., 2016).2 However, pipelines
introduce the problem of cascading errors (T2’s
mistakes aﬀect the performance, and perhaps the
training, of T1; He et al., 2013). To date, reme-
dies to cascading errors are so computationally ex-
pensive as to be impractical (e.g., Finkel et al.,
2006). A syntactic scaﬀold is quite diﬀerent from
a pipeline since the output of T2 is never explicitly
used.

Latent variables. Another solution is to treat
the output of T2 as a (perhaps structured) la-
tent variable. This approach obviates the need
of supervision for T2 and requires marginalization
(or some approximation to it) in order to reason
about the outputs of T1. Syntax as a latent vari-
able for semantics was explored by Zettlemoyer
and Collins (2005) and Naradowsky et al. (2012).
Apart from avoiding marginalization, the syntactic
scaﬀold oﬀers a way to use auxiliary syntactically-
annotated data as direct supervision for T2, and it
need not overlap the T1 training data.

Joint learning of syntax and semantics. The
motivation behind joint learning of syntactic and
semantic representations is that any one task is
helpful in predicting the other (Llu´ıs and M`arquez,
2008; Llu´ıs et al., 2013; Henderson et al., 2013;
Swayamdipta et al., 2016). This typically re-
quires joint prediction of the outputs of T1 and
T2, which tends to be computationally expensive
at both training and test time.

Part of speech scaﬀolds. Similar to our work,
there have been multitask models that use part-
of-speech tagging as T2, with transition-based de-
pendency parsing (Zhang and Weiss, 2016) and
CCG supertagging (Søgaard and Goldberg, 2016)
as T1. Both of the above approaches assumed par-
allel input data and used both tasks as supervision.
Notably, we simplify our T2, throwing away the
structured aspects of syntactic parsing, whereas
part-of-speech tagging has very little structure
to begin with. While their approach results in
improved token-level representations learned via
supervision from POS tags, these must still be
In-
composed to obtain span representations.

2 There has been some recent work on SRL which com-
pletely forgoes syntactic processing (Zhou and Xu, 2015),
however it has been shown that incorporating syntactic in-
formation still remains useful (He et al., 2017).

stead, our approach learns span-level representa-
tions from phrase-type supervision directly, for se-
mantic tasks. Additionally, these methods explore
architectural variations in RNN layers for includ-
ing supervision, whereas we focus on incorporat-
ing supervision with minimal changes to the base-
line architecture. To the best of our knowledge,
such simpliﬁed syntactic scaﬀolds have not been
tried before.

Word embeddings. Our deﬁnition of a scaﬀold
task almost includes stand-alone methods for es-
timating word embeddings (Mikolov et al., 2013;
Pennington et al., 2014; Peters et al., 2018). Af-
ter training word embeddings, the tasks implied
by models like the skip-gram or ELMo’s language
model become irrelevant to the downstream use of
the embeddings. A noteworthy diﬀerence is that,
rather than pre-training, a scaﬀold is integrated di-
rectly into the training of T1 through a multitask
objective.

Multitask learning. Neural architectures have
often yielded performance gains when trained for
multiple tasks together (Collobert et al., 2011; Lu-
ong et al., 2015; Chen et al., 2017; Hashimoto
et al., 2017). In particular, performance of seman-
tic role labeling tasks improves when done jointly
with other semantic tasks (FitzGerald et al., 2015;
Peng et al., 2017, 2018). Contemporaneously with
this work, Hershcovich et al. (2018) proposed a
multitask learning setting for universal syntactic
dependencies and UCCA semantics (Abend and
Rappoport, 2013). Syntactic scaﬀolds focus on a
primary semantic task, treating syntax as an auxil-
lary, eventually forgettable prediction task.

4 Syntactic Scaﬀold Model

We assume two sources of supervision: a cor-
pus D1 with instances x annotated for the primary
task’s outputs y (semantic role labeling or corefer-
ence resolution), and a treebank D2 with sentences
x, each with a phrase-structure tree z.

4.1 Loss

Each task has an associated loss, and we seek to
minimize the combination of task losses,

(cid:88)

(x,y)∈D1

(cid:88)

(x,z)∈D2

L1(x, y) + δ

L2(x, z)

(1)

with respect to parameters, which are partially
shared, where δ is a tunable hyperparameter. In

Each input

the rest of this section, we describe the scaﬀold
task. We deﬁne the primary tasks in Sections 5–6.
is a sequence of tokens, x =
(cid:104)x1, x2, . . . , xn(cid:105), for some n. We refer to a span
of contiguous tokens in the sentence as xi: j =
(cid:104)xi, xi+1, . . . , x j(cid:105), for any 1 (cid:54) i (cid:54) j (cid:54) n. In our
experiments we consider only spans up to a maxi-
mum length D, resulting in O(nD) spans.

Supervision comes from a phrase-syntactic tree
z for the sentence, comprising a syntactic category
zi: j ∈ C for every span xi: j in x (many spans are
given a null label). We experiment with diﬀerent
sets of labels C (§4.2).

In our model, every span xi: j is represented by
an embedding vector vi: j (see details in §5.3). A
distribution over the category assigned to zi: j is de-
rived from vi: j:

p(zi: j = c | xi: j) = softmax

wc · vi: j

(2)

c

where wc is a parameter vector associated with
category c. We sum the log loss terms for all the
spans in a sentence to give its loss:

L2(x, z) = −

log p(zi: j | xi: j).

(3)

(cid:88)

1(cid:54)i(cid:54) j(cid:54)n
j−i(cid:54)D

4.2 Labels for the Syntactic Scaﬀold Task
Diﬀerent kinds of syntactic labels can be used for
learning syntactically-aware span representations:
• Constituent identity: C = {0, 1}; is a span a

constituent, or not?

• Non-terminal: c is the category of a span,

including a null for non-constituents.

• Non-terminal and parent: c is the category
of a span, concatenated with the category of
its immediate ancestor. null is used for non-
constituents, and for empty ancestors.

• Common non-terminals: Since a majority
of semantic arguments and entity mentions
are labeled with a small number of syntac-
tic categories,3 we experiment with a three-
way classiﬁcation among (i) noun phrase (or
prepositional phrase, for frame SRL); (ii) any
other category; and (iii) null.

In Figure 1, for the span “encouraging them”,
the constituent identity scaﬀold label is 1, the non-
terminal label is S|VP, the non-terminal and par-
ent label is S|VP+par=PP, and the common non-
terminals label is set to OTHER.

3In the OntoNotes corpus, which includes both syntac-
tic and semantic annotations, 44% of semantic arguments are
noun phrases and 13% are prepositional phrases.

5 Semantic Role Labeling

We contribute a new SRL model which contributes
a strong baseline for experiments with syntactic
scaﬀolds. The performance of this baseline itself
is competitive with state-of-the-art methods (§7).

In the FrameNet

FrameNet.
lexicon (Baker
et al., 1998), a frame represents a type of event,
situation, or relationship, and is associated with a
set of semantic roles, called frame elements. A
frame can be evoked by a word or phrase in a sen-
tence, called a target. Each frame element of an
evoked frame can then be realized in the sentence
as a sentential span, called an argument (or it can
be unrealized). Arguments for a given frame do
not overlap.

PropBank. PropBank similarly disambiguates
predicates and identiﬁes argument spans. Tar-
gets are disambiguated to lexically speciﬁc senses
rather than shared frames, and a set of generic
roles is used for all targets, reducing the argument
label space by a factor of 17. Most importantly,
the arguments were annotated on top of syntactic
constituents, directly coupling syntax and seman-
tics. A detailed example for both formalisms is
provided in Figure 1.

Semantic structure prediction is the task of iden-
tifying targets, labeling their frames or senses, and
labeling all their argument spans in a sentence.
Here we assume gold targets and frames, and con-
sider only the SRL task.

Formally, a single input instance for argument
identiﬁcation consists of: an n-word sentence x =
(cid:104)x1, x2, . . . , xn(cid:105), a single target span t = (cid:104)tstart, tend(cid:105),
f . The argu-
and its evoked frame, or sense,
ment labeling task is to produce a segmentation
of the sentence: s = (cid:104)s1, s2, . . . , sm(cid:105) for each in-
put x. A segment s = (cid:104)i, j, yi: j(cid:105) corresponds to
a labeled span of the sentence, where the label
yi: j ∈ Y f ∪ {null} is either a role that the span
ﬁlls, or null if the span does not ﬁll any role. In
the case of PropBank, Y f consists of all possible
roles. The segmentation is constrained so that ar-
gument spans cover the sentence and do not over-
lap (ik+1 = 1 + jk for sk; i1 = 1; jm = n). Segments
of length 1 such that i = j are allowed. A separate
segmentation is predicted for each target annota-
tion in a sentence.

5.1 Semi-Markov CRF

of log-likelihood:

In order to model the non-overlapping arguments
of a given target, we use a semi-Markov condi-
tional random ﬁeld (semi-CRF; Sarawagi et al.,
2004). Semi-CRFs deﬁne a conditional distribu-
tion over labeled segmentations of an input se-
quence, and are globally normalized. A single tar-
get’s arguments can be neatly encoded as a labeled
segmentation by giving the spans in between argu-
ments a reserved null label. Semi-Markov mod-
els are more powerful than BIO tagging schemes,
which have been used successfully for PropBank
SRL (Collobert et al., 2011; Zhou and Xu, 2015,
inter alia), because the semi-Markov assumption
allows scoring variable-length segments, rather
than ﬁxed-length label n-grams as under an (n −
1)-order Markov assumption. Computing the
marginal likelihood with a semi-CRF can be done
using dynamic programming in O(n2) time (§5.2).
By ﬁltering out segments longer than D tokens,
this is reduced to O(nD).

Given an input x, a semi-CRF deﬁnes a condi-
tional distribution p(s | x). Every segment s =
(cid:104)i, j, yi: j(cid:105) is given a real-valued score, ψ((cid:104)i, j, yi: j =
r(cid:105), xi: j) = wr · vi: j, where vi: j is an embedding
of the span (§5.3) and wr is a parameter vector
corresponding to its label. The score of the en-
tire segmentation s is the sum of the scores of
its segments: Ψ(x, s) = (cid:80)m
k=1 ψ(sk, xik: jk ). These
scores are exponentiated and normalized to deﬁne
the probability distribution. The sum-product vari-
ant of the semi-Markov dynamic programming al-
gorithm is used to calculate the normalization term
(required during learning). At test time, the max-
product variant returns the most probable segmen-
tation, ˆs = arg max sΨ(s, x).

The parameters of the semi-CRF are learned to
maximize a criterion related to the conditional log-
likelihood of the gold-standard segments in the
training corpus (§5.2). The learner evaluates and
adjusts segment scores ψ(sk, x) for every span in
the sentence, which in turn involves learning em-
bedded representations for all spans (§5.3).

5.2 Softmax-Margin Objective

Typically CRF and semi-CRF models are trained
to maximize a conditional log-likelihood objec-
tive.
In early experiments, we found that incor-
porating a structured cost was beneﬁcial; we do
so by using a softmax-margin training objective
(Gimpel and Smith, 2010), a “cost-aware” variant

L1 = −

(cid:88)

log

exp Ψ(s∗, x)
Z(x, s∗)

,

(cid:88)

(x,s∗)∈D1
exp {Ψ(s, x) + cost(s, s∗)}.

Z(x, s∗) =

(4)

(5)

s

(cid:88)

s∈s

We design the cost function so that it factors by
predicted span, in the same way Ψ does:

cost(s, s∗) =

cost(s, s∗) =

I(s (cid:60) s∗).

(6)

(cid:88)

s∈s

The softmax-margin criterion, like log-likelihood,
is globally normalized over all of the exponentially
many possible labeled segmentations. The follow-
ing zeroth-order semi-Markov dynamic program
(Sarawagi et al., 2004) eﬃciently computes the
new partition function:
(cid:88)

αi−1 exp{Ψ(s, x) + cost(s, s∗)},

(7)

α j =

s=(cid:104)i, j,yi: j(cid:105)
j−i(cid:54)D

where Z = αn, under the base case α0 = 1.

The prediction under the model can be calcu-
lated using a similar dynamic program with the
following recurrence where γ0 = 1:

γ j = max
s=(cid:104)i, j,yi: j(cid:105)
j−i(cid:54)D

γi−1 exp Ψ(s, x).

(8)

Our model formulation enforces that arguments do
not overlap. We do not enforce any other SRL
constraints, such as non-repetition of core frame
elements (Das et al., 2012).

5.3

Input Span Representation

This section describes the neural architecture used
to obtain the span embedding, vi: j, correspond-
ing to a span xi: j and the target in consideration,
t = (cid:104)tstart, tend(cid:105). For the scaﬀold task, since the
syntactic treebank does not contain annotations for
semantic targets, we use the last verb in the sen-
tence as a placeholder target, wherever target fea-
tures are used. If there are no verbs, we use the
ﬁrst token in the sentence as a placeholder target.
The parameters used to learn v are shared between
the tasks.

We construct an embedding for the span using
• hi and h j: contextualized embeddings for the

words at the span boundary (§5.3.1),

• ui: j: a span summary that pools over the con-

tents of the span (§5.3.2), and

• ai: j: and a hand-engineered feature vector for

the span (§5.3.3).

This embedding is then passed to a feedforward

layer to compute the span representation, vi: j.

5.3.1 Contextualized Token Embeddings

To obtain contextualized embeddings of each to-
ken in the input sequence, we run a bidirectional
LSTM (Graves, 2012) with (cid:96) layers over the full
input sequence. To indicate which token is a pred-
icate, a linearly transformed one-hot embedding v
is used, following Zhou and Xu (2015) and He
et al. (2017). The input vector representing the
token at position q in the sentence is the concate-
nation of a ﬁxed pretrained embedding xq and vq.
When given as input to the bidirectional LSTM,
this yields a hidden state vector hq representing
the qth token in the context of the sentence.

5.3.2 Span Summary
Tokens within a span might convey diﬀerent
amounts of information necessary to label the span
as a semantic argument. Following Lee et al.
(2017), we use an attention mechanism (Bahdanau
et al., 2014) to summarize each span. Each con-
textualized token in the span is passed through a
feed-forward network to obtain a weight, normal-
ized to give σk = softmax
whead · hk, where whead
is a learned parameter. The weights σ are then
used to obtain a vector that summarizes the span,
ui: j = (cid:80)

i(cid:54)k(cid:54) j; j−i<D σk · hk.

i(cid:54)k(cid:54) j

5.3.3 Span Features

We use the following three features for each span:
• width of the span in tokens (Das et al., 2014)
• distance (in tokens) of the span from the tar-

get (T¨ackstr¨om et al., 2015)

• position of the span with respect to the tar-
get (before, after, overlap) (T¨ackstr¨om et al.,
2015)

Each of these features is encoded as a one-hot-
embedding and then linearly transformed to yield
a feature vector, ai: j.

6 Coreference Resolution

Coreference resolution is the task of determin-
ing clusters of mentions that refer to the same
entity. Formally, the input is a document x =
x1, x2, . . . , xn consisting of n words. The goal is
to predict a set of clusters c = {c1, c2, . . .}, where
each cluster c = {s1, s2, . . .} is a set of spans and

each span s = (cid:104)i, j(cid:105) is a pair of indices such that
1 (cid:54) i (cid:54) j (cid:54) n.

As a baseline, we use the model of Lee et al.
(2017), which we describe brieﬂy in this section.
This model decomposes the prediction of coref-
erence clusters into a series of span classiﬁcation
decisions. Every span s predicts an antecedent
ws ∈ Y(s) = {null, s1, s2, . . . , sm}. Labels s1 to
sm indicate a coreference link between s and one
of the m spans that precede it, and null indicates
that s does not link to anything, either because it
is not a mention or it is in a singleton cluster. The
predicted clustering of the spans can be recovered
by aggregating the predicted links.

Analogous to the SRL model (§5), every span
s is represented by an embedding vs, which is
central to the model. For each span s and a po-
tential antecedent a ∈ Y(s), pairwise coreference
scores Ψ(vs, va, φ(s, a)) are computed via feedfor-
ward networks with the span embeddings as input.
φ(s, a) are pairwise discrete features encoding the
distance between span s and span a and metadata,
such as the genre and speaker information. We re-
fer the reader to Lee et al. (2017) for the details of
the scoring function.

The scores from Ψ are normalized over the pos-
sible antecedents Y(s) of each span to induce a
probability distribution for every span:

p(ws = a) = softmax
a∈Y(s)

Ψ(vs, va, φ(s, a))

(9)

In learning, we minimize the negative log-
likelihood marginalized over the possibly correct
antecedents:

L1 = −

(cid:88)

log

(cid:88)

p(ws = a∗)

(10)

s∈D

a∗∈G(s)∩Y(s)

where D is the set of spans in the training dataset,
and G(s) indicates the gold cluster of s if it belongs
to one and {null} otherwise.

To operate under reasonable computational re-
quirements, inference under this model requires a
two-stage beam search, which reduces the number
of span pairs considered. We refer the reader to
Lee et al. (2017) for details.

Input span representation. The input span em-
bedding, vs for coreference resolution and its syn-
tactic scaﬀold follow the deﬁnition used in §5.3,
with the key diﬀerence of using no target features.
Since there is a complete overlap of input sen-
tences between Dsc and Dpr as the coreference an-
notations are also from OntoNotes (Pradhan et al.,

2012), we reuse the v for the scaﬀold task. Addi-
tionally, instead of the entire document, each sen-
tence in it is independently given as input to the
bidirectional LSTMs.

7 Results

We evaluate our models on the test set of
FrameNet 1.5 for frame SRL and on the test set
of OntoNotes for both PropBank SRL and coref-
erence. For the syntactic scaﬀold in each case,
we use syntactic annotations from OntoNotes
5.0 (Weischedel et al., 2013; Pradhan et al.,
2013).4 Further details on experimental settings
and datasets have been elaborated in the supple-
mental material.

Frame SRL. Table 1 shows the performance of
all the scaﬀold models on frame SRL with respect
to prior work and a semi-CRF baseline (§5.1)
without a syntactic scaﬀold. We follow the oﬃ-
cial evaluation from the SemEval shared task for
frame-semantic parsing (Baker et al., 2007).

Prior work for frame SRL has relied on pre-
dicted syntactic trees, in two diﬀerent ways: by
using syntax-based rules to prune out spans of text
that are unlikely to contain any frame’s argument;
and by using syntactic features in their statistical
model (Das et al., 2014; T¨ackstr¨om et al., 2015;
FitzGerald et al., 2015; Kshirsagar et al., 2015).

The best published results on FrameNet 1.5 are
due to Yang and Mitchell (2017). In their sequen-
tial model (seq), they treat argument identiﬁcation
as a sequence-labeling problem using a deep bidi-
rectional LSTM with a CRF layer. In their rela-
tional model (Rel), they treat the same problem as
a span classiﬁcation problem. Finally, they intro-
duce an ensemble to integerate both models, and
use an integer linear program for inference satis-
fying SRL constraints. Though their model does
not do any syntactic pruning, it does use syntactic
features for argument identiﬁcation and labeling.5
Notably, all prior systems for frame SRL listed
in Table 1 use a pipeline of syntax and seman-
tics. Our semi-CRF baseline outperforms all prior
work, without any syntax. This highlights the ben-

4http://cemantix.org/data/ontonotes.html
5Yang and Mitchell (2017) also evaluated on the full
frame-semantic parsing task, which includes frame-SRL as
well as identifying frames. Since our frame SRL performance
improves over theirs, we expect that incorporation into a full
system (e.g., using their frame identiﬁcation module) would
lead to overall beneﬁts as well; this experiment is left to fu-
ture work.

eﬁts of modeling spans and of global normaliza-
tion.

Turning to scaﬀolds, even the most coarse-
grained constituent identity scaﬀold improves the
performance of our syntax-agnostic baseline. The
nonterminal and nonterminal and parent scaﬀolds,
which use more detailed syntactic representations,
improve over this. The greatest improvements
come from the scaﬀold model predicting com-
mon nonterminal labels (NP and PP, which are the
most common syntactic categories of semantic ar-
guments, vs. others): 3.6% absolute improvement
in F1 measure over prior work.

Contemporaneously with this work, Peng et al.
(2018) proposed a system for joint frame-semantic
and semantic dependency parsing. They report re-
sults for joint frame and argument identiﬁcation,
and hence cannot be directly compared in Table 1.
We evaluated their output for argument identiﬁca-
tion only; our semi-CRF baseline model exceeds
their performance by 1 F1, and our common non-
terminal scaﬀold by 3.1 F1.6

Model

Prec. Rec.

Kshirsagar et al. (2015)
Yang and Mitchell (2017) (Rel)
Yang and Mitchell (2017) (Seq)
†Yang and Mitchell (2017) (All)

Semi-CRF baseline

+ constituent identity
+ nonterminal and parent
+ nonterminal
+ common nonterminals

66.0
71.8
63.4
70.2

67.8

68.1
68.8
69.4
69.2

60.4
57.7
66.4
60.2

66.2

67.4
68.2
68.0
69.0

F1

63.1
64.0
64.9
65.5

67.0

67.7
68.5
68.7
69.1

Table 1: Frame SRL results on the test set of
FrameNet 1.5., using gold frames. Ensembles are
denoted by †.

Model

Prec. Rec.

Zhou and Xu (2015)
He et al. (2017)
He et al. (2018a)
Tan et al. (2018)

Semi-CRF baseline

+ common nonterminals

-
81.7
83.9
81.9

84.8

85.1

-
81.6
73.7
83.6

81.2

82.6

F1

81.3
81.7
82.1
82.7

83.0

83.8

Table 2: PropBank sSRL results, using gold pred-
icates, on CoNLL 2012 test. For fair comparison,
we show only non-ensembled models.

6This result is not reported in Table 1 since Peng et al.
(2018) used a preprocessing which renders the test set slightly
larger — the diﬀerence we report is calculated using their test
set.

Model

MUC
Prec. Rec. F1

B3
Prec. Rec. F1

CEAFφ4
Prec. Rec. F1

Avg. F1

Wiseman et al. (2016)
77.5 69.8 73.4
Clark and Manning (2016b) 79.9 69.3 74.2
Clark and Manning (2016a) 79.2 70.4 74.6

66.8 57.0 61.5
71.0 56.5 63.0
69.9 58.0 63.4

62.1 53.9 57.7
63.8 54.3 58.7
63.5 55.5 59.2

Lee et al. (2017)

78.4 73.4 75.8
+ common nonterminals 78.4 74.3 76.3

68.6 61.8 65.0

62.7 59.0 60.8

68.7 62.9 65.7

62.9 60.2 61.5

64.2
65.3
65.7

67.2

67.8

Table 3: Coreference resolution results on the test set on the English CoNLL-2012 shared task. The
average F1 of MUC, B3, and CEAFφ4 is the main evaluation metric. For fair comparison, we show only
non-ensembled models.

PropBank SRL. We use the OntoNotes data
from the CoNLL shared task in 2012 (Pradhan
et al., 2013) for Propbank SRL. Table 2 reports
results using gold predicates.

Recent competitive systems for PropBank SRL
follow the approach of Zhou and Xu (2015), em-
ploying deep architectures, and forgoing the use of
any syntax. He et al. (2017) improve on those re-
sults, and in analysis experiments, show that con-
straints derived using syntax may further improve
performance. Tan et al. (2018) employ a similar
approach but use feed-forward networks with self-
attention. He et al. (2018a) use a span-based clas-
siﬁcation to jointly identify and label argument
spans.

Our syntax-agnostic semi-CRF baseline model
improves on prior work (excluding ELMo), show-
ing again the value of global normalization in se-
mantic structure prediction. We obtain further im-
provement of 0.8 absolute F1 with the best syn-
tactic scaﬀold from the frame SRL task. This in-
dicates that a syntactic inductive bias is beneﬁ-
cial even when using sophisticated neural archi-
tectures.

He et al. (2018a) also provide a setup where ini-
tialization was done with deep contextualized em-
beddings, ELMo (Peters et al., 2018), resulting in
85.5 F1 on the OntoNotes test set. The improve-
ments from ELMo are methodologically orthogonal
to syntactic scaﬀolds.

Since the datasets for learning PropBank se-
mantics and syntactic scaﬀolds completely over-
lap, the performance improvement cannot be at-
tributed to a larger training corpus (or, by exten-
sion, a larger vocabulary), though that might be a
factor for frame SRL.

A syntactic scaﬀold can match the performance
of a pipeline containing carefully extracted syntac-
tic features for semantic prediction (Swayamdipta
et al., 2017). This, along with other recent ap-

proaches (He et al., 2017, 2018b) show that syntax
remains useful, even with strong neural models for
SRL.

Coreference. We report the results on four stan-
dard scores from the CoNLL evaluation: MUC, B3
and CEAFφ4, and their average F1 in Table 3. Prior
competitive coreference resolution systems (Wise-
man et al., 2016; Clark and Manning, 2016b,a) all
incorporate synctactic information in a pipeline,
using features and rules for mention proposals
from predicted syntax.

Our baseline is the model from Lee et al.
(2017), described in §6. Similar to the baseline
model for frame SRL, and in contrast with prior
work, this model does not use any syntax.

We experiment with the best syntactic scaﬀold
from the frame SRL task. We used NP, OTHER, and
null as the labels for the common nonterminals
scaﬀold here, since coreferring mentions are rarely
prepositional phrases. The syntactic scaﬀold out-
performs the baseline by 0.6 absolute F1. Contem-
poraneously, Lee et al. (2018) proposed a model
which takes in account higher order inference and
more aggressive pruning, as well as initialization
with ELMo embeddings, resulting in 73.0 average
F1. All the above are orthogonal to our approach,
and could be incorporated to yield higher gains.

8 Discussion

To investigate the performance of the syntactic
scaﬀold, we focus on the frame SRL results, where
we observed the greatest improvement with re-
spect to a non-syntactic baseline.

We consider a breakdown of the performance
by the syntactic phrase types of the arguments,
provided in FrameNet7 in Figure 2. Not surpris-

7We used FrameNet syntactic phrase annotations for anal-
ysis only, and not in our models, since they are annotated only
for the gold arguments.

Figure 2: Performance breakdown by argu-
ment’s phrase category, sorted left to right by
frequency, for top ten phrase categories.

Figure 3: Performance breakdown by top ten
frame element types, sorted left to right by fre-
quency.

ingly, we observe large improvements in the com-
mon nonterminals used (NP and PP). However,
the phrase type annotations in FrameNet do not
correspond exactly to the OntoNotes phrase cat-
egories. For instance, FrameNet annotates non-
maximal (A) and standard adjective phrases (AJP),
while OntoNotes annotations for noun-phrases are
ﬂat, ignore the underlying adjective phrases. This
explains why the syntax-agnostic baseline is able
to recover the former while the scaﬀold is not.

Similarly, for frequent frame elements, scaﬀold-
ing improves performance across the board, as
shown in Fig. 3. The largest improvements come
for Theme and Goal, which are predominantly re-
alized as noun phrases and prepositional phrases.

9 Conclusion

We introduced syntactic scaﬀolds, a multitask
learning approach to incorporate syntactic bias
into semantic processing tasks. Unlike pipelines
and approaches which jointly model syntax and
semantics, no explicit syntactic processing is re-
quired at runtime. Our method improves the per-
formance of competitive baselines for semantic
role labeling on both FrameNet and PropBank,
and for coreference resolution. While our focus
was on span-based tasks, syntactic scaﬀolds could
be applied in other settings (e.g., dependency and
graph representations). Moreover, scaﬀolds need
not be syntactic; we can imagine, for example, se-
mantic scaﬀolds being used to improve NLP appli-
cations with limited annotated data. It remains an
open empirical question to determine the relative
merits of diﬀerent kinds of scaﬀolds and multi-
task learners, and how they can be most produc-

tively combined. Our code is publicly available at
https://github.com/swabhs/scaffolding.

Acknowledgments

We thank several members of UW-NLP, partic-
ularly Luheng He, as well as David Weiss and
Emily Pitler for thoughtful discussions on prior
versions of this paper. We also thank the three
anonymous reviewers for their valuable feedback.
This work was supported in part by NSF grant IIS-
1562364 and by the NVIDIA Corporation through
the donation of a Tesla GPU.

References

Omri Abend and Ari Rappoport. 2013. Universal Con-
ceptual Cognitive Annotation (UCCA). In ACL.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2014. Neural machine translation by jointly
learning to align and translate. ArXiv:1409.0473.

Collin Baker, Michael Ellsworth, and Katrin Erk. 2007.
SemEval’07 Task 19: Frame semantic structure ex-
traction. In Proc. of SemEval.

Collin F. Baker, Charles J. Fillmore, and John B. Lowe.
1998. The Berkeley FrameNet project. In Proc. of
ACL.

Rich Caruana. 1997. Multitask learning. Machine

Learning, 28(1).

Xinchi Chen, Zhan Shi, Xipeng Qiu, and Xuanjing
Huang. 2017. Adversarial multi-criteria learning for
chinese word segmentation. ArXiv:1704.07556.

Kevin Clark and Christopher D Manning. 2016a. Deep
reinforcement learning for mention-ranking corefer-
ence models. In Proc. of EMNLP.

Kevin Clark and Christopher D. Manning. 2016b. Im-
proving coreference resolution by learning entity-
level distributed representations. In Proc. of ACL.

Luheng He, Kenton Lee, Mike Lewis, and Luke Zettle-
moyer. 2017. Deep semantic role labeling: What
works and what’s next. In Proc. of ACL.

Ronan Collobert, Jason Weston, L´eon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
Journal of Machine Learning Research,
scratch.
12:2493–2537.

Ann Copestake and Dan Flickinger. 2000.

An
open source grammar development environment and
broad-coverage English grammar using HPSG.
In
Proc. of LREC.

Dipanjan Das, Desai Chen, Andr´e FT Martins, Nathan
Frame-
linguistics,

Schneider, and Noah A Smith. 2014.
semantic parsing.
40(1):9–56.

Computational

Dipanjan Das, Andr´e F. T. Martins, and Noah A. Smith.
2012. An exact dual decomposition algorithm for
shallow semantic parsing with constraints. In Proc.
of *SEM.

Jenny Rose Finkel, Christopher D Manning, and An-
drew Y Ng. 2006. Solving the problem of cascading
errors: Approximate bayesian inference for linguis-
tic annotation pipelines. In Proc. of EMNLP.

Nicholas FitzGerald, Oscar T¨ackstr¨om, Kuzman
Ganchev, and Dipanjan Das. 2015. Semantic role
In Proc. of
labeling with neural network factors.
EMNLP.

Shexia He, Zuchao Li, Hai Zhao, and Hongxiao Bai.
2018b. Syntax for semantic role labeling, to be, or
not to be. In Proc. of ACL.

James Henderson, Paola Merlo,

Ivan Titov, and
Gabriele Musillo. 2013. Multi-lingual joint pars-
ing of syntactic and semantic dependencies with a
latent variable model. Computational Linguistics,
39(4):949–998.

Daniel Hershcovich, Omri Abend, and Ari Rappoport.
2018. Multitask parsing across semantic representa-
tions. In Proc. of ACL.

Diederik

P. Kingma

2014.
and
ADAM: A method for stochastic optimization.
ArXiV:1412.6980.

Jimmy Ba.

Lingpeng Kong, Chris Dyer, and Noah A. Smith. 2016.
Segmental Recurrent Neural Networks. In Proc. of
ICLR.

Meghana Kshirsagar, Sam Thomson, Nathan Schnei-
der, Jaime Carbonell, Noah A Smith, and Chris
Dyer. 2015. Frame-semantic role labeling with het-
erogeneous annotations. In Proc. of NAACL.

Kenton Lee, Luheng He, Mike Lewis, and Luke Zettle-
moyer. 2017. End-to-end neural coreference resolu-
tion. In Proc. of EMNLP.

Daniel Gildea and Daniel Jurafsky. 2002. Automatic
labeling of semantic roles. Computational Linguis-
tics, 28(3):245–288.

Kenton Lee, Luheng He, and Luke Zettlemoyer. 2018.
Higher-order coreference resolution with coarse-to-
ﬁne inference. In Proc. of NAACL.

Daniel Gildea and Martha Palmer. 2002. The necessity
of parsing for predicate argument recognition.
In
Proc. of ACL.

Kevin Gimpel and Noah A. Smith. 2010. Softmax-
margin CRFs: Training log-linear models with cost
functions. In Proc. of NAACL.

Alex Graves. 2012. Supervised Sequence Labelling
with Recurrent Neural Networks, volume 385 of
Studies in Computational Intelligence. Springer.

Alex Graves. 2013. Generating sequences with recur-

rent neural networks. ArXiv:1308.0850.

Kazuma Hashimoto, Caiming Xiong, Yoshimasa Tsu-
ruoka, and Richard Socher. 2017. A joint many-task
model: Growing a neural network for multiple NLP
tasks. In Proc. of EMNLP.

He He, Hal Daum´e III, and Jason Eisner. 2013. Dy-
namic feature selection for dependency parsing. In
Proc. of EMNLP.

Luheng He, Kenton Lee, Omer Levy, and Luke Zettle-
moyer. 2018a. Jointly predicting predicates and ar-
guments in neural semantic role labeling. In Proc.
of ACL.

Xavier Llu´ıs, Xavier Carreras, and Llu´ıs M`arquez.
2013.
Joint arc-factored parsing of syntactic and
semantic dependencies. Transactions of the ACL,
1:219–230.

Xavier Llu´ıs and Llu´ıs M`arquez. 2008. A joint model
for parsing syntactic and semantic dependencies. In
Proc. of CoNLL.

Minh-Thang Luong, Quoc V Le, Ilya Sutskever, Oriol
Vinyals, and Lukasz Kaiser. 2015. Multi-task se-
quence to sequence learning. ArXiv:1511.06114.

Tomas Mikolov, Kai Chen, Gregory S. Corrado, and
Jeﬀrey Dean. 2013. Eﬃcient estimation of word
representations in vector space. ArXiv:1301.3781.

Vinod Nair and Geoﬀrey E. Hinton. 2010. Rectiﬁed
linear units improve restricted Boltzmann machines.
In Proc. of ICML.

Jason Naradowsky, Sebastian Riedel, and David A.
Improving NLP through marginal-
In Proc. of

Smith. 2012.
ization of hidden syntactic structure.
EMNLP.

Vincent Ng. 2010. Supervised noun phrase coreference
research: The ﬁrst ﬁfteen years. In Proc. of ACL.

Martha Palmer, Daniel Gildea, and Paul Kingsbury.
2005. The Proposition Bank: An annotated cor-
pus of semantic roles. Computational Linguistics,
31(1):71–106.

Swabha Swayamdipta, Sam Thomson, Chris Dyer, and
Noah A. Smith. 2017. Frame-semantic parsing with
softmax-margin segmental rnns and a syntactic scaf-
fold. Arxiv:1706.09528.

Hao Peng, Sam Thomson, and Noah A. Smith. 2017.
Deep multitask learning for semantic dependency
parsing. In Proc. of ACL.

Hao Peng, Sam Thomson, Swabha Swayamdipta, and
Noah A. Smith. 2018. Learning joint semantic
parsers from disjoint data. In Proc. of NAACL.

Jeﬀrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. GloVe: Global vectors for
word representation. In Proc. of EMNLP.

Matthew E Peters, Mark Neumann, Mohit Iyyer, Matt
Gardner, Christopher Clark, Kenton Lee, and Luke
Zettlemoyer. 2018. Deep contextualized word rep-
resentations. ArXiv:1802.05365.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Hwee Tou Ng, Anders Bj¨orkelund, Olga Uryupina,
Yuchen Zhang, and Zhi Zhong. 2013. Towards ro-
bust linguistic analysis using OntoNotes. In Proc. of
CoNLL.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Olga Uryupina, and Yuchen Zhang. 2012. CoNLL-
2012 shared task: Modeling multilingual unre-
In Proc. of
stricted coreference in OntoNotes.
EMNLP.

Vasin Punyakanok, Dan Roth, and Wen-tau Yih. 2008.
The importance of syntactic parsing and inference in
semantic role labeling. Computational Linguistics,
34(2):257–287.

Pranav Rajpurkar,

Jian Zhang, Konstantin Lopy-
rev, and Percy Liang. 2016. SQuAD: 100,000+
questions for machine comprehension of
text.
ArXiv:1606.05250.

Oscar T¨ackstr¨om, Kuzman Ganchev, and Dipanjan
Das. 2015. Eﬃcient inference and structured learn-
ing for semantic role labeling. Transactions of the
ACL, 3:29–41.

Zhixing Tan, Mingxuan Wang, Jun Xie, Yidong Chen,
and Xiaodong Shi. 2018. Deep semantic role label-
ing with self-attention. In Proc. of AAAI.

Kristina Toutanova, Aria Haghighi, and Christopher D.
joint model for se-
Manning. 2008. A global
mantic role labeling. Computational Linguistics,
34(2):161–191.

Ralph Weischedel, Martha Palmer, Mitchell Marcus,
Eduard Hovy, Sameer Pradhan, Lance Ramshaw,
Nianwen Xue, Ann Taylor, Jeﬀ Kaufman, Michelle
Franchini, et al. 2013. OntoNotes release 5.0
ldc2013t19. Linguistic Data Consortium, Philadel-
phia, PA.

Sam Wiseman, Alexander M Rush, and Stuart M
Shieber. 2016. Learning global features for coref-
erence resolution. In Proc. of NAACL.

David H Wolpert. 1992. Stacked generalization. Neu-

ral networks, 5(2):241–259.

Bishan Yang and Tom Mitchell. 2017. A joint sequen-
tial and relational model for frame-semantic parsing.
In Proc. of EMNLP.

Luke S Zettlemoyer and Michael Collins. 2005. Learn-
ing to map sentences to logical form: Structured
classiﬁcation with probabilistic categorial gram-
mars. In Proc. of UAI.

Yuan Zhang and David Weiss. 2016.

Stack-
propagation: Improved representation learning for
syntax. In Proc. of ACL.

Sunita Sarawagi, William W Cohen, et al. 2004. Semi-
markov conditional random ﬁelds for information
extraction. In Proc. of NIPS, volume 17.

Jie Zhou and Wei Xu. 2015. End-to-end learning of
semantic role labeling using recurrent neural net-
works. In Proc. of ACL.

Anders Søgaard and Yoav Goldberg. 2016. Deep
multi-task learning with low level tasks supervised
at lower layers. In Proc. of ACL.

Rupesh Kumar Srivastava, Klaus Greﬀ, and J¨urgen
Schmidhuber. 2015. Training very deep networks.
In Proc. of NIPS.

Mark Steedman. 2000.

Information structure and
the syntax-phonology interface. Linguistic Inquiry,
31(4):649–689.

Swabha Swayamdipta, Miguel Ballesteros, Chris Dyer,
and Noah A. Smith. 2016. Greedy, joint syntactic-
In Proc. of
semantic parsing with Stack LSTMs.
CoNLL.

We limit the maximum length of spans to D =
15 in FrameNet, resulting in oracle recall of 95%
on the development set, and to 13 in Propbank,
resulting in an oracle recall of 96%. An identical
maximum span length is used for the scaﬀold task.
For the SRL scaﬀolds, we randomly sample in-
stances from OntoNotes to match the size of the
SRL data, and alternate between training an SRL
batch and a scaﬀold batch.
In FrameNet, this
amounts to downsampling OntoNotes. For Prop-
Bank SRL, this amounts to upsampling syntactic
annotations from OntoNotes, since a sentence has
a single syntactic tree, but could have multiple tar-
get annotations, each of which is a training in-
stance.

The mixing ratio, δ is set to 1.0 (tuned across
{0.1, 0.5, 1.0, 1.5}) for frame and PropBank SRL.
We use Adam (Kingma and Ba, 2014) for opti-
mization, at a learning rate of 0.001, and a mini-
batch of size 32. Our dynamic program formula-
tion for loss computation and inference under the
semi-CRF is also batched. To prevent exploding
gradients, the 2-norm of the gradient is clipped
to 1 before a gradient update (Graves, 2013). All
models are trained for a maximum of 20 epochs,
and stopped early based on dev F1.

We extended the AllenNLP library,9 which is
built on top of PyTorch.10 Each experiment was
run on a single TitanX GPU.

For the coreference model, we use the same
hyperparameters and experimental settings from
Lee et al. (2017). The only new hyperparameter
needed for scaﬀolding is the mixing ratio, δ, which
we set to 0.1 based on performance on the valida-
tion set.

A Supplementary Material

A.1 Datasets

We used the full-text portion of FrameNet 1.5 re-
lease8 for frame-semantic role labeling. We use
the same test set as Das et al. (2014), and cre-
ate a validation set by selecting 8 documents from
the train set. The dataset contains 3,139 train sen-
tences with 16,621 target annotations, 387 valida-
tion sentences with 2,282 targets, and 2,420 test
sentences with 4,427 targets. Each target from a
given sentence is treated as an independent train-
ing instance. Following T¨ackstr¨om et al. (2015),
we only use the ﬁrst annotation for each target
with multiple annotations.

We use

the standard splits provided in
OntoNotes for the CoNLL 2012 shared task.
The dataset contains 115,812 train sentences with
278,026 target annotations, 15,680 validation sen-
tences with 38,377 targets, and 12,217 test sen-
tences with 29,669 targets.

We use the English coreference resolution data
from the CoNLL 2012 shared task (Pradhan et al.,
2012), containing 2,802, 343 and 348 documents
for train, validation, and test respectively.

Syntax OntoNotes contains 115,812 training in-
stances for the syntactic scaﬀold. There is no
overlap between FrameNet and OntoNotes train-
ing data.

A.2 Experimental Settings

We used GloVe embeddings (Pennington et al.,
2014) for tokens in the vocabulary, with out of
vocabulary words being initialized randomly. For
frame-SRL, 300 dimensional embeddings were
used, and kept ﬁxed during training. For Prop-
Bank SRL, we used 100 dimensional embed-
dings which were updated during training. A
100-dimensional embedding is learned for indi-
cating target positions, following Zhou and Xu
(2015). Bidirectional LSTMs with highway con-
nections (Srivastava et al., 2015) between 6 layers
are used, each layer containing 300-dimensional
hidden states. A dropout of 0.1 is applied to the
LSTMs. The feed-forward networks are of di-
mension 150 and of depth 2, with rectiﬁed linear
units (Nair and Hinton, 2010). A dropout of 0.2 is
applied to the feed-forward networks.

8A later release, 1.7 is also available, but for ease of com-
parison to other published systems we report results on the
earlier release.

9http://allennlp.org/
10http://pytorch.org/

