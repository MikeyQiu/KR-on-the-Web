Octree Generating Networks:
Efﬁcient Convolutional Architectures for High-resolution 3D Outputs

Maxim Tatarchenko1
tatarchm@cs.uni-freiburg.de

Alexey Dosovitskiy1,2
adosovitskiy@gmail.com

Thomas Brox1
brox@cs.uni-freiburg.de

1University of Freiburg

2Intel Labs

7
1
0
2
 
g
u
A
 
7
 
 
]

V
C
.
s
c
[
 
 
3
v
8
3
4
9
0
.
3
0
7
1
:
v
i
X
r
a

Abstract

We present a deep convolutional decoder architecture
that can generate volumetric 3D outputs in a compute- and
memory-efﬁcient manner by using an octree representation.
The network learns to predict both the structure of the oc-
tree, and the occupancy values of individual cells. This
makes it a particularly valuable technique for generating
3D shapes. In contrast to standard decoders acting on reg-
ular voxel grids, the architecture does not have cubic com-
plexity. This allows representing much higher resolution
outputs with a limited memory budget. We demonstrate this
in several application domains, including 3D convolutional
autoencoders, generation of objects and whole scenes from
high-level representations, and shape from a single image.

1. Introduction

Up-convolutional1 decoder architectures have become
a standard tool for tasks requiring image generation [10,
28, 21] or per-pixel prediction [26, 9]. They consist of
a series of convolutional and up-convolutional (upsam-
pling+convolution) layers operating on regular grids, with
resolution gradually increasing towards the output of the
network. The architecture is trivially generalized to volu-
metric data. However, because of cubic scaling of computa-
tional and memory requirements, training up-convolutional
decoders becomes infeasible for high-resolution three-
dimensional outputs.

Poor scaling can be resolved by exploiting structure in
the data. In many learning tasks, neighboring voxels on a
voxel grid share the same state — for instance, if the voxel
grid represents a binary occupancy map or a multi-class
labeling of a three-dimensional object or a scene. In this
case, data can be efﬁciently represented with octrees — data
structures with adaptive cell size. Large regions of space
sharing the same value can be represented with a single

1Also known as deconvolutional

dense

Octree
level 1

Octree
level 2

Octree
level 3

323

643

1283

Figure 1. The proposed OGN represents its volumetric output as an
octree. Initially estimated rough low-resolution structure is gradu-
ally reﬁned to a desired high resolution. At each level only a sparse
set of spatial locations is predicted. This representation is signiﬁ-
cantly more efﬁcient than a dense voxel grid and allows generating
volumes as large as 5123 voxels on a modern GPU in a single for-
ward pass.

large cell of an octree, resulting in savings in computation
and memory compared to a ﬁne regular grid. At the same
time, ﬁne details are not lost and can still be represented by
small cells of the octree.

We present an octree generating network (OGN) - a con-
volutional decoder operating on octrees. The coarse struc-
ture of the network is illustrated in Figure 1. Similar to a
usual up-convolutional decoder, the representation is grad-
ually convolved with learned ﬁlters and up-sampled. The
difference is that, starting from a certain layer in the net-
work, dense regular grids are replaced by octrees. There-
fore, the OGN predicts large uniform regions of the output
space already at early decoding stages, saving the computa-
tion for the subsequent high-resolution layers. Only regions
containing ﬁne details are processed by these more compu-
tationally demanding layers.

In this paper, we focus on generating shapes represented
as binary occupancy maps. We thoroughly compare OGNs
to standard dense nets on three tasks: auto-encoding shapes,
generating shapes from a high-level description, and recon-
structing 3D objects from single images. OGNs yield the
same accuracy as conventional dense decoders while con-
suming signiﬁcantly less memory and being much faster at

high resolutions. For the ﬁrst time, we can generate shapes
of resolution as large as 5123 voxels in a single forward
pass. Our OGN implementation is publicly available2.

2. Related work

The majority of deep learning approaches generate vol-
umetric data based on convolutional networks with fea-
ture maps and outputs represented as voxel grids. Appli-
cations include single- and multi-view 3D object recon-
struction trained in supervised [15, 6, 8, 18] and unsuper-
vised [38, 13, 20] ways, probabilistic generative modeling
of 3D shapes [37, 36, 30], semantic segmentation [3, 5]
and shape deformation [40]. A fundamental limitation of
these approaches is the low resolution of the output. Mem-
ory and computational requirements of approaches based on
the voxel grid representation scale cubically with the out-
put size. Thus, training networks with resolutions higher
than 643 comes with memory issues on the GPU or re-
quires other measures to save memory, such as reducing
the batch size or generating the volume part-by-part. More-
over, with growing resolution, training times become pro-
hibitively slow.

Computational limitations of the voxel grid representa-
tion led to research on alternative representations of volu-
metric data in deep learning. Tatarchenko et al. [33] pre-
dict RGB images and depth maps for multiple views of
an object, and fuse those into a single 3D model. This
approach is not trainable end to end because of the post-
processing fusion step, and is not applicable to objects with
strong self-occlusion. Sinha et al. [31] convert shapes into
two-dimensional geometry images and process those with
conventional CNNs – an approach only applicable to cer-
tain classes of topologies. Networks producing point clouds
have been applied to object generation [11] and semantic
segmentation [27]. By now, these architectures have been
demonstrated to generate relatively low-resolution outputs.
Scaling these networks to higher resolution is yet to be ex-
plored. Tulsiani et al. [34] assemble objects from volumet-
ric primitives. Yi et al. [39] adapt the idea of graph convolu-
tions in the spectral domain to semantic segmentation of 3D
shapes. Their approach requires all samples to have aligned
eigenbasis functions, thus limiting possible application do-
mains.

Promising alternative representations that are not di-
rectly applicable to generating 3D outputs have been ex-
plored on analysis tasks. Masci et al. [24] proposed
geodesic CNNs for extracting local
features in non-
Euclidean domains. Our approach is largely inspired by
Graham’s sparse convolutional networks [16, 17], which
enable efﬁcient shape analysis by storing a sparse set of
non-trivial features instead of dense feature maps. The

OGN essentially solves the inverse problem by predict-
ing which regions of the output contain high-resolution in-
formation and by restricting extensive calculations only to
those regions.

The recent pre-print by Riegler et al. [29] builds on the
same general idea as our work: designing convolutional net-
works that operate on octrees instead of voxel grids. How-
ever, the implementation and the application range of the
method is very different from our work. When generating
an octree, Riegler et al. assume the octree structure to be
known at test time. This is the case, for example, in seman-
tic segmentation, where the structure of the output octree
can be set to be identical to that of the input. However, in
many important scenarios — any kind of 3D reconstruc-
tion, shape modeling, RGB-D fusion, superresolution —
the structure of the octree is not known in advance and must
be predicted. The method of Riegler et al. is not applicable
in these cases. Moreover, the OGN is more ﬂexible in that
it allows for octrees with an arbitrary number of levels.

3. Octrees

An octree [25] is a 3D grid structure with adaptive cell
size, which allows for lossless reduction of memory con-
sumption compared to a regular voxel grid. Octrees have a
long history in classical 3D reconstruction and depth map
fusion [22, 2, 12, 35, 7, 32]. A function deﬁned on a voxel
grid can be converted into a function deﬁned on an octree.
This can be done by starting from a single cell representing
the entire space and recursively partitioning cells into eight
octants. If every voxel within a cell has the same function
value, this cell is not subdivided and becomes a leaf of the
tree. The set of cells at a certain resolution is referred to as
an octree level. The recursive subdivision process can also
be started not from the whole volume, but from some initial
coarse resolution. Then the maximal octree cell size is given
by this initial resolution. The most straightforward way of
implementing an octree is to store in each cell pointers to its
children. In this case, the time to access an element scales
linearly with the tree’s depth, which can become costly at
high resolutions. We use a more efﬁcient implementation
that exploits hash tables. An octree cell with spatial coordi-
nates x = (x, y, z) at level l is represented as an index-value
pair (m, v), where v can be any kind of discrete or continu-
ous signal. m is calculated from (x, l) using Z-order curves
[14]

m = Z(x, l),

which is a computationally cheap transformation imple-
mented using bit shifts. An octree O is, hence, a set of all
pairs

(1)

(2)

2https://github.com/lmb-freiburg/ogn

O = {(m, v)}.

Fl−1

¯Fl

Fl

...

d1

OGNConv
...
(one or more)

OGNProp

...

c

d2

13
conv

OGNLoss

propagated features

empty

ﬁlled

mixed

Ground truth

Prediction

Figure 2. Single block of an OGN illustrated as 2D quadtree for simplicity. After convolving features Fl−1 of the previous block with
weight ﬁlters, we directly predict the occupancy values of cells at level l using 13 convolutions. Features corresponding to ”ﬁlled” and
”empty” cells are no longer needed and thus not propagated, which yields Fl as the ﬁnal output of this block.

Storing this set as a hash table allows for constant-time ele-
ment access.

When training networks, we will need to compare two
different octrees O1 and O2, i.e. for each cell (x, l) from
O1, query the corresponding signal value v in O2. Since
different octrees have different structure, two situations are
possible. If Z(x, k) is stored at a level k in O2, which is
the same or lower than l, the signal value of this cell can
be uniquely determined. If Z(x, k) is stored at one of the
later levels, the cell is subdivided in O2, and the value of the
whole cell is not deﬁned. To formalize this, we introduce a
function f for querying the signal value of an arbitrary cell
with index m = Z(x, l) from octree O:

(cid:26) v, if ∃k ≤ l : (Z(x, k), v) ∈ O

f (m, O) =

∅, otherwise

,

(3)

where ∅ denotes an unavailable value.

4. Octree Generating Networks

An Octree Generating Network (OGN) is a convolu-
tional decoder that yields an octree as output: both the
structure, i.e. which cells should be subdivided, and the
signal value of each cell. In this work we concentrate on bi-
nary occupancy values v ∈ {0, 1}, but the proposed frame-
work can be easily extended to support arbitrary signals. As
shown in Figure 1, an OGN consists of a block operating
on dense regular grids, followed by an arbitrary number of
hash-table-based octree blocks.

The dense block is a set of conventional 3D convolu-
tional and up-convolutional layers producing a feature map
of size d1 × d2 × d3 × c as output, where {di} are the spatial
dimension and c is the number of channels.

From here on, the representation is processed by our cus-
tom layers operating on octrees. The regular-grid-based fea-
ture map produced by the dense block is converted to a set
of index-value pairs stored as a hash table (with values be-
ing feature vectors), and is further processed in this format.
We organize octree-based layers in blocks, each responsible
for predicting the structure and the content of a single level
of the generated octree.

Figure 2 illustrates the functioning of a single such block
that predicts level l of an octree. For the sake of illustration,
we replaced three-dimensional octrees by two-dimensional
quadtrees. Feature maps in Figure 2 are shown as dense ar-
rays only for simplicity; in fact the green cells are stored in
hash maps, and the white cells are not stored at all. We now
give a high-level overview of the block and then describe its
components in more detail.

Input to the block is a sparse hash-table-based convolu-
tional feature map Fl−1 of resolution (d1·2l−1, d2·2l−1, d3·
2l−1) produced by the previous block. First this feature map
is processed with a series of custom convolutional layers
and one up-convolutional layer with stride 2, all followed
by non-linearities.

This yields a new feature map ¯Fl of resolution (d1·2l, d2·
2l, d3 · 2l). Based on this feature map, we directly predict
the content of level l. For each cell, there is a two-fold
decision to be made: should it be kept at level l, and if yes,

what should be the signal value in this cell? In our case
making this decision can be formulated as classifying the
cell as being in one of three states: ”empty”, ”ﬁlled” or
”mixed”. These states correspond to the outputs of state-
querying function f from eq. (3), with ”empty” and ”ﬁlled”
being the signal values v, and ”mixed” being the state where
the value is not determined. We make this prediction using a
convolutional layer with 13 ﬁlters followed by a three-way
softmax. This classiﬁer is trained in a supervised manner
with targets provided by the ground truth octree.

Finally,

in case the output resolution has not been
reached, features from ¯Fl that correspond to ”mixed” cells
are propagated to the next layer3 and serve as an input fea-
ture map Fl to the next block.

In the following subsections, we describe the compo-
nents of a single octree block in more detail:
the octree-
based convolution, the loss function, and the feature propa-
gation mechanism.

4.1. Convolution

We implemented a custom convolutional layer OGN-
Conv, which operates on feature maps represented as hash
tables instead of usual dense arrays. Our implementation
supports strided convolutions and up-convolutions with ar-
bitrary ﬁlter sizes. It is based on representing convolution as
a single matrix multiplication, similar to standard caffe [19]
code for dense convolutions.

In the dense case, the feature tensor is converted to a
matrix with the im2col operation, then multiplied with the
weight matrix of the layer, and the result is converted back
into a dense feature tensor using the col2im operation. In
OGN, instead of storing full dense feature tensors, only a
sparse set of relevant features is stored at each layer. These
features are stored in a hash table, and we implemented
custom operations to convert a hash table to a feature ma-
trix and back. The resulting matrices are much smaller
than those in the dense case. Convolution then amounts to
multiplying the feature matrix by the weight matrix. Ma-
trix multiplication is executed on GPU with standard opti-
mized functions, and our conversion routines currently run
on CPU. Even with this suboptimal CPU implementation,
computation times are comparable to those of usual dense
convolutions at 323 voxel resolution. At higher resolutions,
OGNConv is much faster than dense convolutions (see sec-
tion 5.2).

Unlike convolutions on regular grids, OGN convolutions
are not shift invariant by design. This is studied in Section
E of the Appendix.

3Additional neighboring cells may have to be propagated if needed by

subsequent convolutional layers. This is described in section 4.3.

4.2. Loss

The classiﬁer at level l of the octree outputs the proba-
bilities of each cell from this level being ”empty”, ”ﬁlled”
or ”mixed”, that is, a three-component prediction vector
pm = (p0
m) for cell with index m. We minimize
the cross-entropy between the network predictions and the
cell states of the ground truth octree OGT , averaged over
the set Ml of cells predicted at layer l:

m, p1

m, p2

Ll =

1
|Ml|

(cid:34) 2

(cid:88)

(cid:88)

m∈Ml

i=0

hi(f (m, OGT )) log pi
m

,

(4)

(cid:35)

where function h yields a one-hot encoding (h0, h1, h2) of
the cell state value returned by f from eq. (3). Loss compu-
tations are encapsulated in our custom OGNLoss layer.

The ﬁnal OGN objective is calculated as a sum of loss

values from all octree levels

L =

Ll.

L
(cid:88)

l=1

(5)

4.3. Feature propagation

At the end of each octree block there is an OGNProp
layer that propagates to the next octree block features from
cells in the ”mixed” state, as well as from neighboring cells
if needed to compute subsequent convolutions. Information
about the cell state can either be taken from the ground truth
octree, or from the network prediction. This spawns two
possible propagation modes: using the known tree structure
(Prop-known) and using the predicted tree structure (Prop-
pred). Section 4.4 describes use cases for these two modes.
The set of features to be propagated depends on the
kernel size in subsequent OGNConv layers. The example
illustrated in Figure 2 only holds for 23 up-convolutions
which do not require any neighboring elements to be com-
puted. To use larger convolutional ﬁlters or multiple convo-
lutional layers, we must propagate not only the features of
the ”mixed” cells, but also the features of the neighboring
cells required for computing the convolution at the locations
of the ”mixed” cells. The size of the required neighborhood
is computed based on the network architecture, before the
training starts. Details are provided in Section C of the Ap-
pendix.

4.4. Training and testing

The OGN decoder is end-to-end trainable using stan-
dard backpropagation. The only subtlety is in selecting the
feature propagation modes during training and testing. At
training time the octree structure of the training samples is
always available, and therefore the Prop-known mode can
be used. At test time, the octree structure may or may not

be available. We have developed two training regimes for
these two cases.

If the tree structure is available at test time, we simply
train the network with Prop-known and test it the same way.
This regime is applicable for tasks like semantic segmenta-
tion, or, more generally, per-voxel prediction tasks, where
the structure of the output is exactly the same as the struc-
ture of the input.

If the tree structure is not available at test time, we start
by training the network with Prop-known, and then ﬁne-
tune it with Prop-pred. This regime is applicable to any
task with volumetric output.

We have also tested other regimes of combining Prop-
pred and Prop-known and found those to perform worse
than the two described variants. This is discussed in more
detail in Section B of the Appendix.

5. Experiments

In our experiments we veriﬁed that the OGN architec-
ture performs on par with the standard dense voxel grid rep-
resentation, while requiring signiﬁcantly less memory and
computation, particularly at high resolutions. The focus of
the experiments is on showcasing the capabilities of the pro-
posed architecture. How to fully exploit the new architec-
ture in practical applications is a separate problem that is
left to future work.

5.1. Experimental setup

For all OGN decoders used in our evaluations, we fol-
lowed the same design pattern: 1 or 2 up-convolutional lay-
ers interleaved with a convolutional layer in the dense block,
followed by multiple octree blocks depending on the output
resolution. In the octree blocks we used 23 up-convolutions.
We also evaluated two other architecture variants, presented
in section 5.3.1. ReLU non-linearities were applied after
each (up-)convolutional layer. The number of channels in
the up-convolutional layers of the octree blocks was set to
32 in the outermost layer, and was increased by 16 in each
preceding octree block. The exact network architectures
used in individual experiments are shown in Section F of
the Appendix.

The networks were trained using ADAM [23] with ini-
tial learning rate 0.001, β1 = 0.9, β2 = 0.999. The learning
rate was decreased by a factor of 10 after 30K and 70K it-
erations. We did not apply any additional regularization.

For quantitative evaluations, we converted the resulting
octrees back to regular voxel grids, and computed the In-
tersection over Union (IoU) measure between the ground
truth model and the predicted model. To quantify the im-
portance of high-resolution representations, in some exper-
iments we upsampled low-resolution network predictions
to high-resolution ground truth using trilinear interpolation,
and later binarization with a threshold of 0.5. We explicitly

specify the ground truth resolution in all experiments where
this was done.

If not indicated otherwise, the results were obtained in

the Prop-pred mode.

5.1.1 Datasets

In our evaluations we used three datasets:

ShapeNet-all Approximately 50.000 CAD models from
13 main categories of the ShapeNet dataset [4], used by
Choy et al. [6]. We also used the renderings provided by
Choy et al. [6].

ShapeNet-cars A subset of ShapeNet-all consisting of

7497 car models.

BlendSwap A dataset of 4 scenes we manually collected
from blendswap.com, a website containing a large col-
lection of Blender models.

All datasets were voxelized in multiple resolutions from
323 to 5123 using the binvox4 tool, and were converted into
octrees. We set the interior parts of individual objects to be
ﬁlled, and the exterior to be empty.

5.2. Computational efﬁciency

We start by empirically demonstrating that OGNs can be
used at high resolutions when the voxel grid representation
becomes impractical both because of the memory require-
ments and the runtime.

The number of elements in a voxel grid is uniquely de-
termined by its resolution, and scales cubically as the latter
increases. The number of elements in an octree depends
on the data, leading to variable scaling rates: from con-
stant for cubic objects aligned with the grid, to cubic for
pathological shapes such as a three-dimensional checker-
board. In practice, octrees corresponding to real-world ob-
jects and scenes scale approximately quadratically, since
they represent smooth two-dimensional surfaces in a three-
dimensional space.

Memory, GB

Iteration time, s

OGN
Dense

OGN
Dense

80

60

40

20

0

40

20

0

32 128

256

512

32 128

256

512

Figure 3. Memory consumption (left) and iteration time (right) of
OGN and a dense network at different output resolutions. Forward
and backward pass, batch size 1.

4http://www.patrickmin.com/binvox

Memory, GB

Iteration time, s
Resolution Dense OGN Dense OGN
0.016
0.06
0.18
0.64
2.06

0.33
0.50
1.62
9.98
(74.28)

0.015
0.19
0.56
3.89
(41.3)

323
643
1283
2563
5123

0.29
0.36
0.43
0.54
0.88

Table 1. Memory consumption and iteration time of OGN and a
dense network at different output resolutions. Batch size 1.

We empirically compare the runtime and memory con-
sumption values for a dense network and OGN, for vary-
ing output resolution. Architectures of the networks are
the same as used in Section 5.4 – three fully connected
layers followed by an up-convolutional decoder. We per-
formed the measurements on an NVidia TitanX Maxwell
GPU, with 12Gb of memory. To provide actual measure-
ments for dense networks at the largest possible resolution,
we performed the comparison with batch size 1. The 5123
dense network does not ﬁt into memory even with batch size
1, so we extrapolated the numbers by ﬁtting cubic curves.

Figure 3 and Table 1 show the results of the comparison.
The OGN is roughly as efﬁcient as its dense counterpart for
low resolutions, but as the resolution grows, it gets drasti-
cally faster and consumes far less memory. At 5123 voxel
resolution, the OGN consumes almost two orders of mag-
nitude less memory and runs 20 times faster. In Section A
of the Appendix we provide a more detailed analysis and
explicitly demonstrate the near-cubic scaling of dense net-
works against the near-quadratic scaling of OGNs.

To put these numbers into perspective, training OGN at
2563 voxel output resolution takes approximately 5 days.
Estimated training time of its dense counterpart would be al-
most a month. Even if the 5123 voxel dense network would
ﬁt into memory, it would take many months to train.

5.3. Autoencoders

Autoencoders and their variants are commonly used for
representation learning from volumetric data
[15, 30].
Therefore, we start by comparing the representational
power of the OGN to that of dense voxel grid networks on
the task of auto-encoding volumetric shapes.

We used the decoder architecture described in section 5.1
both for the OGN and the dense baseline. The architecture
of the encoder is symmetric to the decoder. Both encoders
operate on a dense voxel grid representation5.

We trained the autoencoders on the ShapeNet-cars
dataset in two resolutions: 323 and 643. We used 80% of the
data for training, and 20% for testing. Quantitative results

5In this paper, we focus on generating 3D shapes. Thus, we have not
implemented an octree-based convolutional encoder. This could be done
along the lines of Riegler et al. [29]

are summarized in Table 2. With predicted octree structure,
there is no signiﬁcant difference in performance between
the OGN and the dense baseline.

Network
Dense
OGN+Prop-known
OGN+Prop-pred

323
0.924
0.939
0.924

643
0.890
0.904
0.884

Table 2. Quantitative results for OGN and dense autoencoders.
Predictions were compared with the ground truth at the corre-
sponding resolution, without upsampling.

5.3.1 Flexibility of architecture choice

To show that OGNs are not limited to up-convolutional lay-
ers with 23 ﬁlters, we evaluated two alternative 643 OGN
auto-encoders: one with 43 up-convolutions and one with
23 up-convolutions interleaved with 33 convolutions. The
results are summarized in Table 7. There is no signiﬁ-
cant difference between the architectures for this task. With
larger ﬁlters, the network is roughly twice slower in our cur-
rent implementation, so we used 23 ﬁlters in all further ex-
periments.

5.3.2 Using known structure

Interestingly, OGN with known tree structure outperforms
the network based on a dense voxel grid, both qualitatively
and quantitatively. An example of this effect can be seen in
Figure 4: the dense autoencoder and our autoencoder with
predicted propagation struggle with properly reconstructing
the spoiler of the car. Intuitively, the known tree structure
provides additional shape information to the decoder, thus
simplifying the learning problem. In the autoencoder sce-
nario, however, this may be undesirable if one aims to en-
code all information about a shape in a latent vector. In tasks
like semantic segmentation, the input octree structure could
help introduce shape features implicitly in the learning task.

5.4. 3D shape from high-level information

We trained multiple OGNs for generating shapes from
high-level parameters similar to Dosovitskiy et al. [10]. In
all cases the input of the network is a one-hot encoded ob-
ject ID, and the output is an octree with the object shape.

Mode
OGN+Prop-known
OGN+Prop-pred

2x2 ﬁlters
0.904
0.884

4x4 ﬁlters
0.907
0.885

IntConv
0.907
0.885

Table 3. Using more complex architectures in 643 OGN autoen-
coders does not lead to signiﬁcant performance improvements.

Dense

OGN+Prop-pred OGN+Prop-known

GT

tween pairs of one-hot input ID vectors. Figure 6 shows that
for all intermediate input values the network produces con-
sistent output cars, with the style being smoothly changed
between the two training points.

Figure 4. Using the known tree structure at test time leads to im-
proved performance.

ShapeNet-cars
BlendSwap

64
0.856
0.535

128
0.901
0.649

256
0.865
0.880

512
-
0.969

Table 4. Quantitative evaluation of 3D shapes generated from high-
level information. Lower-resolution predictions from ShapeNet-
cars were upsampled to 2563 ground truth,
scenes from
BlendSwap — to 5123.

643

1283

2563

GT 2563

643

1283

2563

Figure 6. Our networks can generate previously unseen cars by
interpolating between the dataset points, which demonstrates their
generalization capabilities.

5.4.2 BlendSwap

To additionally showcase the beneﬁt of using higher reso-
lutions, we trained OGNs to ﬁt the BlendSwap dataset con-
taining 4 whole scenes.
In contrast to the ShapeNet-cars
dataset, such amount of training data does not allow for any
generalization. The experiment aims to show that OGNs
provide sufﬁcient resolution to represent such high-ﬁdelity
shape data.

Figure 7 shows the generated scenes. In both examples,
643 and 1283 resolutions are inadequate for representing the
details. For the bottom scene, even the 2563 resolution still
struggles with ﬁne-grained details. This example demon-
strates that tasks like end-to-end learning of scene recon-
struction requires high-resolution representations, and the
OGN is an architecture that can provide such resolutions.

These qualitative observations are conﬁrmed quantita-
tively in Table 4. Higher output resolutions allow for more
accurate reconstruction of the samples in the dataset. More
results for this experiment are shown in Section D of the
Appendix, and the accompanying video6.

5.5. Single-image 3D reconstruction

In this experiment we trained networks with our OGN
decoder on the task of single-view 3D reconstruction. To
demonstrate that our dense voxel grid baseline, as already
used in the autoencoder experiment, is a strong baseline, we
compare to the approach by Choy et al. [6]. This approach
operates on 323 voxel grids, and we adopt this resolution
for our ﬁrst experiment. To ensure a fair comparison, we
trained networks on ShapeNet-all, the exact dataset used by
Choy et al. [6]. Following the same dataset splitting strat-
egy, we used 80% of the data for training, and 20% for
testing. As a baseline, we trained a network with a dense

6https://youtu.be/kmMvKNNyYF4

Figure 5. Training samples from the ShapeNet-cars dataset gener-
ated by our networks. Cells at different octree levels vary in size
and are displayed in different shades of gray.

5.4.1 ShapeNet-cars

First, we trained on the whole ShapeNet-cars dataset in
three resolutions: 643, 1283 and 2563. Example outputs
are shown in Figure 5 and quantitative results are presented
in Table 4. Similar to the two-dimensional case [10], the
outputs are accurate in the overall shape, but lack some ﬁne
details. This is not due to the missing resolution, but due to
general limitations of the training data and the learning task.
Table 4 reveals that a resolution of 1283 allows the recon-
struction of a more accurate shape with more details than
a resolution of 643. At an even higher resolution of 2563,
the overall performance decreased again. Even though the
higher-resolution network is architecturally capable of per-
forming better, it is not guaranteed to train better. Noisy gra-
dients from outer high-resolution layers may hamper learn-
ing of deeper layers, resulting in an overall decline in per-
formance. This problem is orthogonal to the issue of de-
signing computationally efﬁcient architectures, which we
aim to solve in this paper. We further discuss this in the
Appendix.

Notably, the network does not only learn to generate ob-
jects from the training dataset, but it can also generalize to
unseen models. We demonstrate this by interpolating be-

643

1283

2563

5123

GT 5123

Figure 7. OGN is used to reproduce large-scale scenes from the dataset, where high resolution is crucial to generate ﬁne-grained structures.

Input

323

643

1283

2563

GT 2563

Category
Plane
Bench
Cabinet
Car
Chair
Monitor
Lamp
Speaker
Firearm
Couch
Table
Cellphone
Watercraft
Mean

R2N2 [6] OGN Dense
0.570
0.481
0.747
0.828
0.481
0.509
0.371
0.650
0.576
0.668
0.545
0.698
0.550
0.590

0.587
0.481
0.729
0.816
0.483
0.502
0.398
0.637
0.593
0.646
0.536
0.702
0.632
0.596

0.513
0.421
0.716
0.798
0.466
0.468
0.381
0.662
0.544
0.628
0.513
0.661
0.513
0.560

Table 5. Single-view 3D reconstruction results on the 323 version
of ShapeNet-all from Choy et al. [6] compared to OGN and a dense
baseline. OGN is competitive with voxel-grid-based networks.

decoder which had the same conﬁguration as our OGN de-
coder. Table 5 shows that compared to single-view recon-
structions from [6], both the OGN and the baseline dense
network compare favorably for most of the classes. In con-
clusion, the OGN is competitive with voxel-grid-based net-
works on the complex task of single-image class-speciﬁc
3D reconstruction.

We also evaluated the effect of resolution on the
ShapeNet-cars dataset. Figure 8 shows that OGNs learned
to infer the 3D shapes of cars in all cases, and that high-
resolution predictions are clearly better than the 323 models
commonly used so far. This is backed up by quantitative
results shown in Table 6: 323 results are signiﬁcantly worse
than the rest. At 2563 performance drops again for the same
reasons as in the decoder experiment in section 5.4.1.

6. Conclusions

We have presented a novel convolutional decoder ar-
chitecture for generating high-resolution 3D outputs repre-
sented as octrees. We have demonstrated that this architec-
ture is ﬂexible in terms of the exact layer conﬁguration, and

Figure 8. Single-image 3D reconstruction on the ShapeNet-cars
dataset using OGN in different resolutions.

Resolution
Single-view 3D 0.641

32

64
0.771

128
0.782

256
0.766

Table 6. Single-image 3D reconstruction results on ShapeNet-cars.
Low-resolution predictions are upsampled to 2563. Commonly
used 323 models are signiﬁcantly worse than the rest.

that it provides the same accuracy as dense voxel grids in
low resolution. At the same time, it scales much better to
higher resolutions, both in terms of memory and runtime.

This architecture enables end-to-end deep learning to be
applied to tasks that appeared unfeasible before. In particu-
lar, learning tasks that involve 3D shapes, such as 3D object
and scene reconstruction, are likely to beneﬁt from it.

While in this paper we have focused on shapes and bi-
nary occupancy maps, it is straightforward to extend the
framework to multi-dimensional outputs attached to the oc-
tree structure; for example, the output of the network could
be a textured shape or a signed distance function. This will
allow for an even wider range of applications.

Acknowledgements

This work was supported by the Excellence Initiative
of the German Federal and State Governments: BIOSS
Centre for Biological Signalling Studies (EXC 294). We
would like to thank Benjamin Ummenhofer for valuable
discussions and technical comments. We also thank Niko-
laus Mayer for his help with 3D model visualization and
manuscript preparation.

References

[1] F. Bogo, J. Romero, M. Loper, and M. J. Black. FAUST:
Dataset and evaluation for 3D mesh registration. In CVPR,
2014. 11

[2] F. Calakli and G. Taubin. SSD: Smooth Signed Distance
Surface Reconstruction. Computer Graphics Forum, 2011.
2
¨O. C¸ ic¸ek, A. Abdulkadir, S. Lienkamp, T. Brox, and O. Ron-
neberger. 3d u-net: Learning dense volumetric segmentation
from sparse annotation. In MICCAI, 2016. 2

[3]

[4] A. X. Chang, T. Funkhouser, L. Guibas, P. Hanrahan,
Q. Huang, Z. Li, S. Savarese, M. Savva, S. Song, H. Su,
J. Xiao, L. Yi, and F. Yu. ShapeNet: An Information-Rich
3D Model Repository. CoRR, abs/1512.03012, 2015. 5
[5] H. Chen, Q. Dou, L. Yu, and P. Heng. Voxresnet: Deep vox-
elwise residual networks for volumetric brain segmentation.
CoRR, abs/1608.05895, 2016. 2

[6] C. B. Choy, D. Xu, J. Gwak, K. Chen, and S. Savarese. 3d-
r2n2: A uniﬁed approach for single and multi-view 3d object
reconstruction. In ECCV, 2016. 2, 5, 7, 8

[7] C. Connolly. Cumulative generation of octree models from

range data. In ICRA, 1984. 2

[8] X. Di, R. Dahyot, and M. Prasad. Deep shape from a low

number of silhouettes. In ECCV Workshops, 2016. 2

[9] A. Dosovitskiy, P. Fischer, E. Ilg, P. H¨ausser, C. Hazırbas¸,
V. Golkov, P. v.d. Smagt, D. Cremers, and T. Brox. Flownet:
Learning optical ﬂow with convolutional networks. In ICCV,
2015. 1

[10] A. Dosovitskiy, J. T. Springenberg, M. Tatarchenko, and
T. Brox. Learning to generate chairs, tables and cars with
convolutional networks. IEEE Transactions on Pattern Anal-
ysis and Machine Intelligence, 2016. 1, 6, 7

[11] H. Fan, H. Su, and L. J. Guibas. A point set generation
network for 3d object reconstruction from a single image.
CoRR, abs/1612.00603, 2016. 2

[12] S. Fuhrmann and M. Goesele. Fusion of depth maps with

multiple scales. In SIGGRAPH Asia, 2011. 2

[13] M. Gadelha, S. Maji, and R. Wang. 3d shape induction from
2d views of multiple objects. CoRR, abs/1612.05872, 2016.
2

[14] I. Gargantini. Linear octtrees for fast processing of three-
dimensional objects. Computer Graphics and Image Pro-
cessing, 20(4):365 – 374, 1982. 2

[15] R. Girdhar, D. Fouhey, M. Rodriguez, and A. Gupta. Learn-
ing a predictable and generative vector representation for ob-
jects. In ECCV, 2016. 2, 6

[16] B. Graham. Spatially-sparse convolutional neural networks.

CoRR, abs/1409.6070, 2014. 2

[17] B. Graham. Sparse 3d convolutional neural networks.

In

BMVC, 2015. 2

[18] E. Grant, P. Kohli, and M. van Gerven. Deep disentan-
gled representations for volumetric reconstruction. In ECCV
Workshops, 2016. 2

[19] Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long,
R. Girshick, S. Guadarrama, and T. Darrell. Caffe: Con-
volutional architecture for fast feature embedding. CoRR,
abs/1408.5093, 2014. 4

[20] D. Jimenez Rezende, S. M. A. Eslami, S. Mohamed,
P. Battaglia, M. Jaderberg, and N. Heess. Unsupervised
learning of 3d structure from images. In NIPS. 2016. 2
[21] J. Johnson, A. Alahi, and L. Fei-Fei. Perceptual losses for
real-time style transfer and super-resolution. In ECCV, 2016.
1

[22] M. Kazhdan, M. Bolitho, and H. Hoppe. Poisson surface

reconstruction. In SGP, 2006. 2

[23] D. P. Kingma and J. Ba. Adam: A method for stochastic

optimization. In ICLR, 2014. 5

[24] J. Masci, D. Boscaini, M. M. Bronstein, and P. Van-
dergheynst. Geodesic convolutional neural networks on rie-
mannian manifolds. In ICCV Workshops, 2015. 2

[25] D. Meagher. Octree encoding: A new technique for the rep-
resentation, manipulation and display of arbitrary 3-d objects
by computer. Technical Report IPL-TR-80-111, 1980. 2
[26] H. Noh, S. Hong, and B. Han. Learning deconvolution net-

work for semantic segmentation. In ICCV, 2015. 1

[27] C. R. Qi, H. Su, K. Mo, and L. J. Guibas. Pointnet: Deep
learning on point sets for 3d classiﬁcation and segmentation.
CoRR, abs/1612.00593, 2016. 2

[28] A. Radford, L. Metz, and S. Chintala. Unsupervised repre-
sentation learning with deep convolutional generative adver-
sarial networks. CoRR, abs/1511.06434, 2015. 1

[29] G. Riegler, A. O. Ulusoy, and A. Geiger. Octnet: Learn-
ing deep 3d representations at high resolutions. CoRR,
abs/1611.05009, 2016. 2, 6

[30] A. Sharma, O. Grau, and M. Fritz. Vconv-dae: Deep volu-
metric shape learning without object labels. In ECCV Work-
shops, 2016. 2, 6

[31] A. Sinha, J. Bai, and K. Ramani. Deep learning 3d shape

surfaces using geometry images. In ECCV, 2016. 2

[32] F. Steinbr¨ucker, J. Sturm, and D. Cremers. Volumetric 3d

mapping in real-time on a cpu. In ICRA, 2014. 2

[33] M. Tatarchenko, A. Dosovitskiy, and T. Brox. Multi-view 3d
models from single images with a convolutional network. In
ECCV, 2016. 2

[34] S. Tulsiani, H. Su, L. J. Guibas, A. A. Efros, and J. Malik.
Learning shape abstractions by assembling volumetric prim-
itives. CoRR, abs/1612.00404, 2016. 2

[35] B. Ummenhofer and T. Brox. Global, dense multiscale re-

construction for a billion points. In ICCV, 2015. 2

[36] J. Wu, C. Zhang, T. Xue, W. T. Freeman, and J. B. Tenen-
baum. Learning a probabilistic latent space of object shapes
via 3d generative-adversarial modeling. In NIPS, 2016. 2

[37] Z. Wu, S. Song, A. Khosla, F. Yu, L. Zhang, X. Tang, and
J. Xiao. 3d shapenets: A deep representation for volumetric
shapes. In CVPR, 2015. 2

[38] X. Yan, J. Yang, E. Yumer, Y. Guo, and H. Lee. Perspective
transformer nets: Learning single-view 3d object reconstruc-
tion without 3d supervision. In NIPS, 2016. 2

[39] L. Yi, H. Su, X. Guo, and L. J. Guibas. Syncspeccnn: Syn-
chronized spectral CNN for 3d shape segmentation. CoRR,
abs/1612.00606, 2016. 2

[40] M. E. Yumer and N. J. Mitra. Learning semantic deformation
ﬂows with 3d convolutional networks. In ECCV, 2016. 2

Appendix

A. Computational efﬁciency

In the main paper we have shown that with a practi-
cal architecture our networks scale much better than their
dense counterparts both in terms of memory consumption
and computation time. The numbers were obtained for the
”houses” scene from the BlendSwap dataset.

OGN
Quadratic
Dense
Cubic

OGN
Quadratic
Dense
Cubic

B
G

,
e
g
a
s
u
y
r
o
m
e
m
k
a
e
P

10

1

0.1

0.01

s

,
e
m

i
t

n
o
i
t
a
r
e
t
I

10

1

0.1

0.01

representation. The architectures of those networks are sim-
ilar to those from Table 13, but with only 1 channel in ev-
ery convolutional layer, and a single fully-connected layer
with 64 units in the encoder. The resulting measurements
are shown in Figure 9 for memory consumption and Fig-
ure 10 for runtime. To precisely quantify the scaling, we
subtracted the constant amount of memory reserved on a
GPU by caffe (190 MB) from all numbers.

Both plots are displayed in the log-log scale, i.e., func-
tions from the family y = axk are straight lines. The
slope of this line is determined by the exponent k, and the
vertical shift by the coefﬁcient a.
In this experiment we
are mainly interested in the slope, that is, how do the ap-
proaches scale with increasing output resolution. As a refer-
ence, we show dashed lines corresponding to perfect cubic
and perfect quadratic scaling.

Starting from 643 voxel resolution both the runtime and
the memory consumption scale almost cubically in case of
dense networks. For this particular example, OGN scales
even better than quadratically, but in general scaling of the
octree-based representation depends on the speciﬁc data it
is applied to.

In Section 4.4 of the main paper, we described how
we use the two propagation modes (Prop-known and Prop-
pred) during training and testing. Here we motivate the pro-
posed regimes, and show additional results with other com-
binations of propagation modes.

When the structure of the output tree is not known at test
time, we train the networks until convergence with Prop-
known, and then additionally ﬁne-tune with Prop-pred - line
4 in Table 7. Without this ﬁne-tuning step (line 2), there is
a decrease in performance, which is more signiﬁcant when
using larger convolutional ﬁlters. Intuitively, this happens
because the network has never seen erroneous propagations
during training, and does not now how to deal with them at
test time.

When the structure of the output is known at test time,
the best strategy is to simply train in Prop-known, and test
the same way (line 1). Additional ﬁne-tuning in the Prop-
pred mode slightly hurts performance in this case (line 3).
The overall conclusion is not surprising: the best results are
obtained when training networks in the same propagation
modes, in which they are later tested.

32

64

256

512

128
Resolution

B. Train/test modes

Figure 9. Memory consumption for very slim networks, forward
and backward pass, batch size 1. Shown in log-log scale - lines
with smaller slope correspond to better scaling.

32

64

256

512

128
Resolution

Figure 10. Iteration time for very slim networks, forward and back-
ward pass, batch size 1. Shown in log-log scale - lines with smaller
slope correspond to better scaling.

In order to further study this matter, we have designed
a set of slim decoder networks that ﬁt on a GPU in every
resolution, including 5123, both with an OGN and a dense

C. Feature propagation

In the main paper we mentioned that the number of fea-
tures propagated by an OGNProp layer depends on the sizes
of the convolutional ﬁlters in all subsequent blocks. In case
of 23 up-convolutions with stride 2, which were used in
most of our experiments, no neighboring features need to

(A)

up-conv
ﬁlter: 2
stride: 2

(B)

up-conv
ﬁlter: 4
stride: 2

Training Testing
Known
Known
Pred
Known
Known
Pred
Pred
Pred

23 ﬁlters
0.904
0.862
0.898
0.884

43 ﬁlters
0.907
0.804
0.896
0.885

IntConv
0.907
0.823
0.897
0.885

Table 7. Reconstruction quality for autoencoders with different de-
coder architectures: 23 up-convolutions, 43 up-convolutions, and
23 up-convolutions interleaved with 33 convolutions, using dif-
ferent conﬁgurations of Prop-known and Prop-pred propagation
modes.

be propagated. This situation is illustrated in Figure 11-A
in a one-dimensional case. Circles correspond to cells of
an octree. The green cell in the input is the only one for
which the value was predicted to be ”mixed”. Links be-
tween the circles indicate which features of the input are
required to compute the result of the operation (convolution
or up-convolution) for the corresponding output cell. In this
case, we can see that the output cells in the next level are
only affected by their parent cell from the previous level.

A more general situation is shown in Figure 11-B. The
input is processed with an up-convolutional layer with 43
ﬁlters and stride 2, which is followed by a convolutional
layer with 33 ﬁlters and stride 1. Again, only one cell was
predicted to be ”mixed”, but in order to perform convolu-
tions and up-convolutions in subsequent layers, we addi-
tionally must propagate some of its neighbors (marked red).
Therefore, with this particular ﬁlter conﬁguration, two cells
in the output are affected by four cells in the input.

Generally, the number of features that should be prop-
agated by each OGNProp layer is automatically calculated
based on the network architecture before starting the train-
ing.

D. 3D shape from high-level information: ad-

ditional experiments

D.1. MPI-FAUST

To additionally showcase the beneﬁt of using higher res-
olutions, we trained OGNs to ﬁt the MPI-FAUST dataset
[1]. It contains 300 high-resolution scans of human bodies
of 10 different people in 30 different poses. Same as with
the BlendSwap, the trained networks cannot generalize to
new samples due to the low amount of training data.

Figure 12 and Table 8 demonstrate qualitative and quan-
titative results respectively. Human models from MPI-
FAUST include ﬁner details than cars from ShapeNet, and
therefore beneﬁt from the higher resolution.

D.2. Fitting reduced ShapeNet-cars

To better understand the performance drop at 2563 res-
olution observed in section 5.4.1 of the main paper, we

conv
ﬁlter: 3
stride: 1

mixed

propagated
neighbors

ﬁlled/empty

zero-padding

Figure 11. The OGNProp layer propagates the features of ”mixed”
cells together with the features of the neighboring cells required
for computations in subsequent layers. We show the number
of neighbors that need to be propagated in two cases: 23 up-
convolutions (A), and 43 up-convolutions followed by 33 convo-
lutions (B). Visualized in 1D for simplicity.

643

1283

2563

GT 2563

Figure 12. Training samples from the FAUST dataset recon-
structed by OGN.

performed an additional experiment on the ShapeNet-Cars
dataset. We trained an OGN for generating car shapes from
their IDs on a reduced version of ShapeNet-Cars, including

64
0.890

128
0.933

256
0.969

Table 8. 3D shape from high-level information on the FAUST
dataset. Lower-resolution predictions were upsampled to 2563
ground truth.

Dataset
Shapenet-cars (full)
Shapenet-cars (subset)

1283
0.901
0.922

2563
0.865
0.931

Table 9. There is no drop in performance in higher resolution,
when training on a subset of the Shapenet-cars dataset.

Full

Subset

GT 2563

1283

2563

1283

2563

Figure 13. When training on a subset of the Shapenet-cars datset,
higher resolution models contain more details.

just 500 ﬁrst models from the dataset. Quantitative results
for different resolutions, along with the results for the full
dataset, are shown in Table 9. Interestingly, when training
on the reduced dataset, high resolution is beneﬁcial. This is
further supported by examples shown in Figure 13 – when
training on the reduced dataset, the higher-resolution model
contain more ﬁne details. Overall, these results support our
hypothesis that the performance drop at higher resolution is
not due to the OGN architecture, but due to the difﬁculty of
ﬁtting a large dataset at high resolution.

E. Shift invariance

The convolution operation on a voxel grid is perfectly
shift invariant by design. This is no longer true for convo-
lutions on octrees: a shift by a single pixel in the original
voxel grid can change the structure of the octree signiﬁ-
cantly. To study the effect of shifts, we trained two fully
convolutional autoencoders - one with an OGN decoder,
and one with a dense decoder - on 643 models, with low-
est feature map resolution 43 (so the networks should be

perfectly invariant to shifts of 16 voxels). Both were trained
on non-shifted Shapenet-Cars, and tested in the Prop-pred
mode on models shifted by a different number of voxels
along the z-axis. The results are summarized in Table 10.

Shift (voxels) OGN Dense
0.932
0.93
0.925
0.915
0.904

0.935
0.933
0.929
0.917
0.906

0
1
2
4
8

Table 10. Fully-convolutional networks tested on shifted data.
Even though not shift invariant by design, OGN shows robust per-
formance.

There is no signiﬁcant difference between OGN and the
dense network. A likely reason is that different training
models have different octree structures, which acts as an
implicit regularizer. The network learns the shape, but re-
mains robust to the exact octree structure.

F. Network architectures

In this section, we provide the exact network architec-

tures used in the experimental evaluations.

F.1. Autoencoders

The architectures of OGN autoencoders are summarized
in Table 12. For the dense baselines, we used the same layer
conﬁgurations with usual convolutions instead of OGN-
Conv, and predictions being made only after the last layer
of the network. All networks were trained with batch size
16.

F.2. 3D shape from high-level information

OGN decoders used on the Shapenet-cars dataset are
shown in Table 13. Encoders consisted of three fully-
connected layers, with output size of the last encoder layer
being identical to the input size of the corresponding de-
coder.

For FAUST and BlendSwap the 2563 output octrees had
four levels, not ﬁve like those in Table 13. Thus, the
dense block had an additional deconvolution-convolution
layer pair instead of one octree block. The 5123 decoder
on BlendSwap had one extra octree block with 32 output
channels.

All 643 and 1283 networks were trained with batch size

16, 2563 — with batch size 4, 5123 — with batch size 1.

F.3. Single-image 3D reconstruction

In this experiment we again used decoder architectures
shown in Table 13. The architecture of the convolutional
encoder is shown in Table 11. The number of channels in

the last encoder layer was set identical to the number of
input channels of the corresponding decoder.

[137 × 137 × 3]
Conv (7 × 7)
[69 × 69 × 32]
Conv (3 × 3)
[35 × 35 × 32]
Conv (3 × 3)
[18 × 18 × 64]
Conv (3 × 3)
[9 × 9 × 64]
Conv (3 × 3)
[5 × 5 × 128]
FC
[1024]
FC
[1024]
FC
[43 × c]

Table 11. Convolutional encoder used in the single-image 3D re-
construction experiment.

323

643 (23 ﬁlters)

643 (InvConv)

[323 × 1]
Conv (33)
[163 × 32]
Conv (33)
[83 × 48]
Conv (33)
[43 × 64]
FC
[1024]
FC
[1024]
FC
[43 × 80]
Deconv (23)
[83 × 64]
Conv (33)→ l1
[83 × 64]
OGNProp
OGNConv(23) → l2
[163 × 48]
OGNProp
OGNConv(23) → l3
[323 × 32]

643 (43 ﬁlters)
[643 × 1]
Conv (33)
[323 × 32]
Conv (33)
[163 × 48]
Conv (33)
[83 × 64]
Conv (33)
[43 × 80]
FC
[1024]
FC
[1024]
FC
[43 × 96]
Deconv (23)
[83 × 80]
Conv (33)
[83 × 80]

Deconv (23)
[163 × 64]

Conv (33)→ l1
[163 × 64]
OGNProp

[323 × 48]

OGNConv(23) → l2 OGNConv(43) → l2

OGNProp

[323 × 48]

OGNProp

OGNProp

OGNConv(23) → l3 OGNConv(43) → l3

[643 × 32]

[643 × 32]

OGNProp
OGNConv(23)
[323 × 48]
OGNConv*(33) → l2
[323 × 48]
OGNProp
OGNConv(23)
[643 × 32]
OGNConv*(33) → l3
[643 × 32]

Table 12. OGN architectures used in our experiments with autoencoders. OGNConv denotes up-convolution, OGNConv* — convolution.
Layer name followed by ’→ lk’ indicates that level k of an octree is predicted by a classiﬁer attached to this layer.

323
[43 × 80]
Deconv (23)
[83 × 64]
Conv (33) → l1
[83 × 64]
OGNProp
OGNConv (23) → l2
[163 × 48]
OGNProp
OGNConv (23) → l3
[323 × 32]

643
[43 × 96]
Deconv (23)
[83 × 80]
Conv (33)
[83 × 80]

Deconv (23)
[163 × 64]

1283
[43 × 112]
Deconv (23)
[83 × 96]
Conv (33)
[83 × 96]

Deconv (23)
[163 × 80]

2563
[43 × 112]
Deconv (23)
[83 × 96]
Conv (33)
[83 × 96]

Deconv (23)
[163 × 80]

Conv (33) → l1
[163 × 80]
OGNProp

Conv (33) → l1
[163 × 64]
OGNProp

Conv (33) → l1
[163 × 80]
OGNProp
OGNConv (23) → l2 OGNConv (23) → l2 OGNConv (23) → l2
[323 × 64]
OGNProp
OGNConv (23) → l3 OGNConv (23) → l3 OGNConv (23) → l3
[643 × 48]
OGNProp

[323 × 64]
OGNProp

[643 × 48]
OGNProp

[323 × 48]
OGNProp

[643 × 32]

OGNConv (23) → l4 OGNConv (23) → l4

[1283 × 32]

[1283 × 32]
OGNProp
OGNConv (23) → l5
[2563 × 32]

Table 13. OGN decoder architectures used in shape from ID, and single-image 3D reconstruction experiments.

Octree Generating Networks:
Efﬁcient Convolutional Architectures for High-resolution 3D Outputs

Maxim Tatarchenko1
tatarchm@cs.uni-freiburg.de

Alexey Dosovitskiy1,2
adosovitskiy@gmail.com

Thomas Brox1
brox@cs.uni-freiburg.de

1University of Freiburg

2Intel Labs

7
1
0
2
 
g
u
A
 
7
 
 
]

V
C
.
s
c
[
 
 
3
v
8
3
4
9
0
.
3
0
7
1
:
v
i
X
r
a

Abstract

We present a deep convolutional decoder architecture
that can generate volumetric 3D outputs in a compute- and
memory-efﬁcient manner by using an octree representation.
The network learns to predict both the structure of the oc-
tree, and the occupancy values of individual cells. This
makes it a particularly valuable technique for generating
3D shapes. In contrast to standard decoders acting on reg-
ular voxel grids, the architecture does not have cubic com-
plexity. This allows representing much higher resolution
outputs with a limited memory budget. We demonstrate this
in several application domains, including 3D convolutional
autoencoders, generation of objects and whole scenes from
high-level representations, and shape from a single image.

1. Introduction

Up-convolutional1 decoder architectures have become
a standard tool for tasks requiring image generation [10,
28, 21] or per-pixel prediction [26, 9]. They consist of
a series of convolutional and up-convolutional (upsam-
pling+convolution) layers operating on regular grids, with
resolution gradually increasing towards the output of the
network. The architecture is trivially generalized to volu-
metric data. However, because of cubic scaling of computa-
tional and memory requirements, training up-convolutional
decoders becomes infeasible for high-resolution three-
dimensional outputs.

Poor scaling can be resolved by exploiting structure in
the data. In many learning tasks, neighboring voxels on a
voxel grid share the same state — for instance, if the voxel
grid represents a binary occupancy map or a multi-class
labeling of a three-dimensional object or a scene. In this
case, data can be efﬁciently represented with octrees — data
structures with adaptive cell size. Large regions of space
sharing the same value can be represented with a single

1Also known as deconvolutional

dense

Octree
level 1

Octree
level 2

Octree
level 3

323

643

1283

Figure 1. The proposed OGN represents its volumetric output as an
octree. Initially estimated rough low-resolution structure is gradu-
ally reﬁned to a desired high resolution. At each level only a sparse
set of spatial locations is predicted. This representation is signiﬁ-
cantly more efﬁcient than a dense voxel grid and allows generating
volumes as large as 5123 voxels on a modern GPU in a single for-
ward pass.

large cell of an octree, resulting in savings in computation
and memory compared to a ﬁne regular grid. At the same
time, ﬁne details are not lost and can still be represented by
small cells of the octree.

We present an octree generating network (OGN) - a con-
volutional decoder operating on octrees. The coarse struc-
ture of the network is illustrated in Figure 1. Similar to a
usual up-convolutional decoder, the representation is grad-
ually convolved with learned ﬁlters and up-sampled. The
difference is that, starting from a certain layer in the net-
work, dense regular grids are replaced by octrees. There-
fore, the OGN predicts large uniform regions of the output
space already at early decoding stages, saving the computa-
tion for the subsequent high-resolution layers. Only regions
containing ﬁne details are processed by these more compu-
tationally demanding layers.

In this paper, we focus on generating shapes represented
as binary occupancy maps. We thoroughly compare OGNs
to standard dense nets on three tasks: auto-encoding shapes,
generating shapes from a high-level description, and recon-
structing 3D objects from single images. OGNs yield the
same accuracy as conventional dense decoders while con-
suming signiﬁcantly less memory and being much faster at

high resolutions. For the ﬁrst time, we can generate shapes
of resolution as large as 5123 voxels in a single forward
pass. Our OGN implementation is publicly available2.

2. Related work

The majority of deep learning approaches generate vol-
umetric data based on convolutional networks with fea-
ture maps and outputs represented as voxel grids. Appli-
cations include single- and multi-view 3D object recon-
struction trained in supervised [15, 6, 8, 18] and unsuper-
vised [38, 13, 20] ways, probabilistic generative modeling
of 3D shapes [37, 36, 30], semantic segmentation [3, 5]
and shape deformation [40]. A fundamental limitation of
these approaches is the low resolution of the output. Mem-
ory and computational requirements of approaches based on
the voxel grid representation scale cubically with the out-
put size. Thus, training networks with resolutions higher
than 643 comes with memory issues on the GPU or re-
quires other measures to save memory, such as reducing
the batch size or generating the volume part-by-part. More-
over, with growing resolution, training times become pro-
hibitively slow.

Computational limitations of the voxel grid representa-
tion led to research on alternative representations of volu-
metric data in deep learning. Tatarchenko et al. [33] pre-
dict RGB images and depth maps for multiple views of
an object, and fuse those into a single 3D model. This
approach is not trainable end to end because of the post-
processing fusion step, and is not applicable to objects with
strong self-occlusion. Sinha et al. [31] convert shapes into
two-dimensional geometry images and process those with
conventional CNNs – an approach only applicable to cer-
tain classes of topologies. Networks producing point clouds
have been applied to object generation [11] and semantic
segmentation [27]. By now, these architectures have been
demonstrated to generate relatively low-resolution outputs.
Scaling these networks to higher resolution is yet to be ex-
plored. Tulsiani et al. [34] assemble objects from volumet-
ric primitives. Yi et al. [39] adapt the idea of graph convolu-
tions in the spectral domain to semantic segmentation of 3D
shapes. Their approach requires all samples to have aligned
eigenbasis functions, thus limiting possible application do-
mains.

Promising alternative representations that are not di-
rectly applicable to generating 3D outputs have been ex-
plored on analysis tasks. Masci et al. [24] proposed
geodesic CNNs for extracting local
features in non-
Euclidean domains. Our approach is largely inspired by
Graham’s sparse convolutional networks [16, 17], which
enable efﬁcient shape analysis by storing a sparse set of
non-trivial features instead of dense feature maps. The

OGN essentially solves the inverse problem by predict-
ing which regions of the output contain high-resolution in-
formation and by restricting extensive calculations only to
those regions.

The recent pre-print by Riegler et al. [29] builds on the
same general idea as our work: designing convolutional net-
works that operate on octrees instead of voxel grids. How-
ever, the implementation and the application range of the
method is very different from our work. When generating
an octree, Riegler et al. assume the octree structure to be
known at test time. This is the case, for example, in seman-
tic segmentation, where the structure of the output octree
can be set to be identical to that of the input. However, in
many important scenarios — any kind of 3D reconstruc-
tion, shape modeling, RGB-D fusion, superresolution —
the structure of the octree is not known in advance and must
be predicted. The method of Riegler et al. is not applicable
in these cases. Moreover, the OGN is more ﬂexible in that
it allows for octrees with an arbitrary number of levels.

3. Octrees

An octree [25] is a 3D grid structure with adaptive cell
size, which allows for lossless reduction of memory con-
sumption compared to a regular voxel grid. Octrees have a
long history in classical 3D reconstruction and depth map
fusion [22, 2, 12, 35, 7, 32]. A function deﬁned on a voxel
grid can be converted into a function deﬁned on an octree.
This can be done by starting from a single cell representing
the entire space and recursively partitioning cells into eight
octants. If every voxel within a cell has the same function
value, this cell is not subdivided and becomes a leaf of the
tree. The set of cells at a certain resolution is referred to as
an octree level. The recursive subdivision process can also
be started not from the whole volume, but from some initial
coarse resolution. Then the maximal octree cell size is given
by this initial resolution. The most straightforward way of
implementing an octree is to store in each cell pointers to its
children. In this case, the time to access an element scales
linearly with the tree’s depth, which can become costly at
high resolutions. We use a more efﬁcient implementation
that exploits hash tables. An octree cell with spatial coordi-
nates x = (x, y, z) at level l is represented as an index-value
pair (m, v), where v can be any kind of discrete or continu-
ous signal. m is calculated from (x, l) using Z-order curves
[14]

m = Z(x, l),

which is a computationally cheap transformation imple-
mented using bit shifts. An octree O is, hence, a set of all
pairs

(1)

(2)

2https://github.com/lmb-freiburg/ogn

O = {(m, v)}.

Fl−1

¯Fl

Fl

...

d1

OGNConv
...
(one or more)

OGNProp

...

c

d2

13
conv

OGNLoss

propagated features

empty

ﬁlled

mixed

Ground truth

Prediction

Figure 2. Single block of an OGN illustrated as 2D quadtree for simplicity. After convolving features Fl−1 of the previous block with
weight ﬁlters, we directly predict the occupancy values of cells at level l using 13 convolutions. Features corresponding to ”ﬁlled” and
”empty” cells are no longer needed and thus not propagated, which yields Fl as the ﬁnal output of this block.

Storing this set as a hash table allows for constant-time ele-
ment access.

When training networks, we will need to compare two
different octrees O1 and O2, i.e. for each cell (x, l) from
O1, query the corresponding signal value v in O2. Since
different octrees have different structure, two situations are
possible. If Z(x, k) is stored at a level k in O2, which is
the same or lower than l, the signal value of this cell can
be uniquely determined. If Z(x, k) is stored at one of the
later levels, the cell is subdivided in O2, and the value of the
whole cell is not deﬁned. To formalize this, we introduce a
function f for querying the signal value of an arbitrary cell
with index m = Z(x, l) from octree O:

(cid:26) v, if ∃k ≤ l : (Z(x, k), v) ∈ O

f (m, O) =

∅, otherwise

,

(3)

where ∅ denotes an unavailable value.

4. Octree Generating Networks

An Octree Generating Network (OGN) is a convolu-
tional decoder that yields an octree as output: both the
structure, i.e. which cells should be subdivided, and the
signal value of each cell. In this work we concentrate on bi-
nary occupancy values v ∈ {0, 1}, but the proposed frame-
work can be easily extended to support arbitrary signals. As
shown in Figure 1, an OGN consists of a block operating
on dense regular grids, followed by an arbitrary number of
hash-table-based octree blocks.

The dense block is a set of conventional 3D convolu-
tional and up-convolutional layers producing a feature map
of size d1 × d2 × d3 × c as output, where {di} are the spatial
dimension and c is the number of channels.

From here on, the representation is processed by our cus-
tom layers operating on octrees. The regular-grid-based fea-
ture map produced by the dense block is converted to a set
of index-value pairs stored as a hash table (with values be-
ing feature vectors), and is further processed in this format.
We organize octree-based layers in blocks, each responsible
for predicting the structure and the content of a single level
of the generated octree.

Figure 2 illustrates the functioning of a single such block
that predicts level l of an octree. For the sake of illustration,
we replaced three-dimensional octrees by two-dimensional
quadtrees. Feature maps in Figure 2 are shown as dense ar-
rays only for simplicity; in fact the green cells are stored in
hash maps, and the white cells are not stored at all. We now
give a high-level overview of the block and then describe its
components in more detail.

Input to the block is a sparse hash-table-based convolu-
tional feature map Fl−1 of resolution (d1·2l−1, d2·2l−1, d3·
2l−1) produced by the previous block. First this feature map
is processed with a series of custom convolutional layers
and one up-convolutional layer with stride 2, all followed
by non-linearities.

This yields a new feature map ¯Fl of resolution (d1·2l, d2·
2l, d3 · 2l). Based on this feature map, we directly predict
the content of level l. For each cell, there is a two-fold
decision to be made: should it be kept at level l, and if yes,

what should be the signal value in this cell? In our case
making this decision can be formulated as classifying the
cell as being in one of three states: ”empty”, ”ﬁlled” or
”mixed”. These states correspond to the outputs of state-
querying function f from eq. (3), with ”empty” and ”ﬁlled”
being the signal values v, and ”mixed” being the state where
the value is not determined. We make this prediction using a
convolutional layer with 13 ﬁlters followed by a three-way
softmax. This classiﬁer is trained in a supervised manner
with targets provided by the ground truth octree.

Finally,

in case the output resolution has not been
reached, features from ¯Fl that correspond to ”mixed” cells
are propagated to the next layer3 and serve as an input fea-
ture map Fl to the next block.

In the following subsections, we describe the compo-
nents of a single octree block in more detail:
the octree-
based convolution, the loss function, and the feature propa-
gation mechanism.

4.1. Convolution

We implemented a custom convolutional layer OGN-
Conv, which operates on feature maps represented as hash
tables instead of usual dense arrays. Our implementation
supports strided convolutions and up-convolutions with ar-
bitrary ﬁlter sizes. It is based on representing convolution as
a single matrix multiplication, similar to standard caffe [19]
code for dense convolutions.

In the dense case, the feature tensor is converted to a
matrix with the im2col operation, then multiplied with the
weight matrix of the layer, and the result is converted back
into a dense feature tensor using the col2im operation. In
OGN, instead of storing full dense feature tensors, only a
sparse set of relevant features is stored at each layer. These
features are stored in a hash table, and we implemented
custom operations to convert a hash table to a feature ma-
trix and back. The resulting matrices are much smaller
than those in the dense case. Convolution then amounts to
multiplying the feature matrix by the weight matrix. Ma-
trix multiplication is executed on GPU with standard opti-
mized functions, and our conversion routines currently run
on CPU. Even with this suboptimal CPU implementation,
computation times are comparable to those of usual dense
convolutions at 323 voxel resolution. At higher resolutions,
OGNConv is much faster than dense convolutions (see sec-
tion 5.2).

Unlike convolutions on regular grids, OGN convolutions
are not shift invariant by design. This is studied in Section
E of the Appendix.

3Additional neighboring cells may have to be propagated if needed by

subsequent convolutional layers. This is described in section 4.3.

4.2. Loss

The classiﬁer at level l of the octree outputs the proba-
bilities of each cell from this level being ”empty”, ”ﬁlled”
or ”mixed”, that is, a three-component prediction vector
pm = (p0
m) for cell with index m. We minimize
the cross-entropy between the network predictions and the
cell states of the ground truth octree OGT , averaged over
the set Ml of cells predicted at layer l:

m, p1

m, p2

Ll =

1
|Ml|

(cid:34) 2

(cid:88)

(cid:88)

m∈Ml

i=0

hi(f (m, OGT )) log pi
m

,

(4)

(cid:35)

where function h yields a one-hot encoding (h0, h1, h2) of
the cell state value returned by f from eq. (3). Loss compu-
tations are encapsulated in our custom OGNLoss layer.

The ﬁnal OGN objective is calculated as a sum of loss

values from all octree levels

L =

Ll.

L
(cid:88)

l=1

(5)

4.3. Feature propagation

At the end of each octree block there is an OGNProp
layer that propagates to the next octree block features from
cells in the ”mixed” state, as well as from neighboring cells
if needed to compute subsequent convolutions. Information
about the cell state can either be taken from the ground truth
octree, or from the network prediction. This spawns two
possible propagation modes: using the known tree structure
(Prop-known) and using the predicted tree structure (Prop-
pred). Section 4.4 describes use cases for these two modes.
The set of features to be propagated depends on the
kernel size in subsequent OGNConv layers. The example
illustrated in Figure 2 only holds for 23 up-convolutions
which do not require any neighboring elements to be com-
puted. To use larger convolutional ﬁlters or multiple convo-
lutional layers, we must propagate not only the features of
the ”mixed” cells, but also the features of the neighboring
cells required for computing the convolution at the locations
of the ”mixed” cells. The size of the required neighborhood
is computed based on the network architecture, before the
training starts. Details are provided in Section C of the Ap-
pendix.

4.4. Training and testing

The OGN decoder is end-to-end trainable using stan-
dard backpropagation. The only subtlety is in selecting the
feature propagation modes during training and testing. At
training time the octree structure of the training samples is
always available, and therefore the Prop-known mode can
be used. At test time, the octree structure may or may not

be available. We have developed two training regimes for
these two cases.

If the tree structure is available at test time, we simply
train the network with Prop-known and test it the same way.
This regime is applicable for tasks like semantic segmenta-
tion, or, more generally, per-voxel prediction tasks, where
the structure of the output is exactly the same as the struc-
ture of the input.

If the tree structure is not available at test time, we start
by training the network with Prop-known, and then ﬁne-
tune it with Prop-pred. This regime is applicable to any
task with volumetric output.

We have also tested other regimes of combining Prop-
pred and Prop-known and found those to perform worse
than the two described variants. This is discussed in more
detail in Section B of the Appendix.

5. Experiments

In our experiments we veriﬁed that the OGN architec-
ture performs on par with the standard dense voxel grid rep-
resentation, while requiring signiﬁcantly less memory and
computation, particularly at high resolutions. The focus of
the experiments is on showcasing the capabilities of the pro-
posed architecture. How to fully exploit the new architec-
ture in practical applications is a separate problem that is
left to future work.

5.1. Experimental setup

For all OGN decoders used in our evaluations, we fol-
lowed the same design pattern: 1 or 2 up-convolutional lay-
ers interleaved with a convolutional layer in the dense block,
followed by multiple octree blocks depending on the output
resolution. In the octree blocks we used 23 up-convolutions.
We also evaluated two other architecture variants, presented
in section 5.3.1. ReLU non-linearities were applied after
each (up-)convolutional layer. The number of channels in
the up-convolutional layers of the octree blocks was set to
32 in the outermost layer, and was increased by 16 in each
preceding octree block. The exact network architectures
used in individual experiments are shown in Section F of
the Appendix.

The networks were trained using ADAM [23] with ini-
tial learning rate 0.001, β1 = 0.9, β2 = 0.999. The learning
rate was decreased by a factor of 10 after 30K and 70K it-
erations. We did not apply any additional regularization.

For quantitative evaluations, we converted the resulting
octrees back to regular voxel grids, and computed the In-
tersection over Union (IoU) measure between the ground
truth model and the predicted model. To quantify the im-
portance of high-resolution representations, in some exper-
iments we upsampled low-resolution network predictions
to high-resolution ground truth using trilinear interpolation,
and later binarization with a threshold of 0.5. We explicitly

specify the ground truth resolution in all experiments where
this was done.

If not indicated otherwise, the results were obtained in

the Prop-pred mode.

5.1.1 Datasets

In our evaluations we used three datasets:

ShapeNet-all Approximately 50.000 CAD models from
13 main categories of the ShapeNet dataset [4], used by
Choy et al. [6]. We also used the renderings provided by
Choy et al. [6].

ShapeNet-cars A subset of ShapeNet-all consisting of

7497 car models.

BlendSwap A dataset of 4 scenes we manually collected
from blendswap.com, a website containing a large col-
lection of Blender models.

All datasets were voxelized in multiple resolutions from
323 to 5123 using the binvox4 tool, and were converted into
octrees. We set the interior parts of individual objects to be
ﬁlled, and the exterior to be empty.

5.2. Computational efﬁciency

We start by empirically demonstrating that OGNs can be
used at high resolutions when the voxel grid representation
becomes impractical both because of the memory require-
ments and the runtime.

The number of elements in a voxel grid is uniquely de-
termined by its resolution, and scales cubically as the latter
increases. The number of elements in an octree depends
on the data, leading to variable scaling rates: from con-
stant for cubic objects aligned with the grid, to cubic for
pathological shapes such as a three-dimensional checker-
board. In practice, octrees corresponding to real-world ob-
jects and scenes scale approximately quadratically, since
they represent smooth two-dimensional surfaces in a three-
dimensional space.

Memory, GB

Iteration time, s

OGN
Dense

OGN
Dense

80

60

40

20

0

40

20

0

32 128

256

512

32 128

256

512

Figure 3. Memory consumption (left) and iteration time (right) of
OGN and a dense network at different output resolutions. Forward
and backward pass, batch size 1.

4http://www.patrickmin.com/binvox

Memory, GB

Iteration time, s
Resolution Dense OGN Dense OGN
0.016
0.06
0.18
0.64
2.06

0.33
0.50
1.62
9.98
(74.28)

0.015
0.19
0.56
3.89
(41.3)

323
643
1283
2563
5123

0.29
0.36
0.43
0.54
0.88

Table 1. Memory consumption and iteration time of OGN and a
dense network at different output resolutions. Batch size 1.

We empirically compare the runtime and memory con-
sumption values for a dense network and OGN, for vary-
ing output resolution. Architectures of the networks are
the same as used in Section 5.4 – three fully connected
layers followed by an up-convolutional decoder. We per-
formed the measurements on an NVidia TitanX Maxwell
GPU, with 12Gb of memory. To provide actual measure-
ments for dense networks at the largest possible resolution,
we performed the comparison with batch size 1. The 5123
dense network does not ﬁt into memory even with batch size
1, so we extrapolated the numbers by ﬁtting cubic curves.

Figure 3 and Table 1 show the results of the comparison.
The OGN is roughly as efﬁcient as its dense counterpart for
low resolutions, but as the resolution grows, it gets drasti-
cally faster and consumes far less memory. At 5123 voxel
resolution, the OGN consumes almost two orders of mag-
nitude less memory and runs 20 times faster. In Section A
of the Appendix we provide a more detailed analysis and
explicitly demonstrate the near-cubic scaling of dense net-
works against the near-quadratic scaling of OGNs.

To put these numbers into perspective, training OGN at
2563 voxel output resolution takes approximately 5 days.
Estimated training time of its dense counterpart would be al-
most a month. Even if the 5123 voxel dense network would
ﬁt into memory, it would take many months to train.

5.3. Autoencoders

Autoencoders and their variants are commonly used for
representation learning from volumetric data
[15, 30].
Therefore, we start by comparing the representational
power of the OGN to that of dense voxel grid networks on
the task of auto-encoding volumetric shapes.

We used the decoder architecture described in section 5.1
both for the OGN and the dense baseline. The architecture
of the encoder is symmetric to the decoder. Both encoders
operate on a dense voxel grid representation5.

We trained the autoencoders on the ShapeNet-cars
dataset in two resolutions: 323 and 643. We used 80% of the
data for training, and 20% for testing. Quantitative results

5In this paper, we focus on generating 3D shapes. Thus, we have not
implemented an octree-based convolutional encoder. This could be done
along the lines of Riegler et al. [29]

are summarized in Table 2. With predicted octree structure,
there is no signiﬁcant difference in performance between
the OGN and the dense baseline.

Network
Dense
OGN+Prop-known
OGN+Prop-pred

323
0.924
0.939
0.924

643
0.890
0.904
0.884

Table 2. Quantitative results for OGN and dense autoencoders.
Predictions were compared with the ground truth at the corre-
sponding resolution, without upsampling.

5.3.1 Flexibility of architecture choice

To show that OGNs are not limited to up-convolutional lay-
ers with 23 ﬁlters, we evaluated two alternative 643 OGN
auto-encoders: one with 43 up-convolutions and one with
23 up-convolutions interleaved with 33 convolutions. The
results are summarized in Table 7. There is no signiﬁ-
cant difference between the architectures for this task. With
larger ﬁlters, the network is roughly twice slower in our cur-
rent implementation, so we used 23 ﬁlters in all further ex-
periments.

5.3.2 Using known structure

Interestingly, OGN with known tree structure outperforms
the network based on a dense voxel grid, both qualitatively
and quantitatively. An example of this effect can be seen in
Figure 4: the dense autoencoder and our autoencoder with
predicted propagation struggle with properly reconstructing
the spoiler of the car. Intuitively, the known tree structure
provides additional shape information to the decoder, thus
simplifying the learning problem. In the autoencoder sce-
nario, however, this may be undesirable if one aims to en-
code all information about a shape in a latent vector. In tasks
like semantic segmentation, the input octree structure could
help introduce shape features implicitly in the learning task.

5.4. 3D shape from high-level information

We trained multiple OGNs for generating shapes from
high-level parameters similar to Dosovitskiy et al. [10]. In
all cases the input of the network is a one-hot encoded ob-
ject ID, and the output is an octree with the object shape.

Mode
OGN+Prop-known
OGN+Prop-pred

2x2 ﬁlters
0.904
0.884

4x4 ﬁlters
0.907
0.885

IntConv
0.907
0.885

Table 3. Using more complex architectures in 643 OGN autoen-
coders does not lead to signiﬁcant performance improvements.

Dense

OGN+Prop-pred OGN+Prop-known

GT

tween pairs of one-hot input ID vectors. Figure 6 shows that
for all intermediate input values the network produces con-
sistent output cars, with the style being smoothly changed
between the two training points.

Figure 4. Using the known tree structure at test time leads to im-
proved performance.

ShapeNet-cars
BlendSwap

64
0.856
0.535

128
0.901
0.649

256
0.865
0.880

512
-
0.969

Table 4. Quantitative evaluation of 3D shapes generated from high-
level information. Lower-resolution predictions from ShapeNet-
cars were upsampled to 2563 ground truth,
scenes from
BlendSwap — to 5123.

643

1283

2563

GT 2563

643

1283

2563

Figure 6. Our networks can generate previously unseen cars by
interpolating between the dataset points, which demonstrates their
generalization capabilities.

5.4.2 BlendSwap

To additionally showcase the beneﬁt of using higher reso-
lutions, we trained OGNs to ﬁt the BlendSwap dataset con-
taining 4 whole scenes.
In contrast to the ShapeNet-cars
dataset, such amount of training data does not allow for any
generalization. The experiment aims to show that OGNs
provide sufﬁcient resolution to represent such high-ﬁdelity
shape data.

Figure 7 shows the generated scenes. In both examples,
643 and 1283 resolutions are inadequate for representing the
details. For the bottom scene, even the 2563 resolution still
struggles with ﬁne-grained details. This example demon-
strates that tasks like end-to-end learning of scene recon-
struction requires high-resolution representations, and the
OGN is an architecture that can provide such resolutions.

These qualitative observations are conﬁrmed quantita-
tively in Table 4. Higher output resolutions allow for more
accurate reconstruction of the samples in the dataset. More
results for this experiment are shown in Section D of the
Appendix, and the accompanying video6.

5.5. Single-image 3D reconstruction

In this experiment we trained networks with our OGN
decoder on the task of single-view 3D reconstruction. To
demonstrate that our dense voxel grid baseline, as already
used in the autoencoder experiment, is a strong baseline, we
compare to the approach by Choy et al. [6]. This approach
operates on 323 voxel grids, and we adopt this resolution
for our ﬁrst experiment. To ensure a fair comparison, we
trained networks on ShapeNet-all, the exact dataset used by
Choy et al. [6]. Following the same dataset splitting strat-
egy, we used 80% of the data for training, and 20% for
testing. As a baseline, we trained a network with a dense

6https://youtu.be/kmMvKNNyYF4

Figure 5. Training samples from the ShapeNet-cars dataset gener-
ated by our networks. Cells at different octree levels vary in size
and are displayed in different shades of gray.

5.4.1 ShapeNet-cars

First, we trained on the whole ShapeNet-cars dataset in
three resolutions: 643, 1283 and 2563. Example outputs
are shown in Figure 5 and quantitative results are presented
in Table 4. Similar to the two-dimensional case [10], the
outputs are accurate in the overall shape, but lack some ﬁne
details. This is not due to the missing resolution, but due to
general limitations of the training data and the learning task.
Table 4 reveals that a resolution of 1283 allows the recon-
struction of a more accurate shape with more details than
a resolution of 643. At an even higher resolution of 2563,
the overall performance decreased again. Even though the
higher-resolution network is architecturally capable of per-
forming better, it is not guaranteed to train better. Noisy gra-
dients from outer high-resolution layers may hamper learn-
ing of deeper layers, resulting in an overall decline in per-
formance. This problem is orthogonal to the issue of de-
signing computationally efﬁcient architectures, which we
aim to solve in this paper. We further discuss this in the
Appendix.

Notably, the network does not only learn to generate ob-
jects from the training dataset, but it can also generalize to
unseen models. We demonstrate this by interpolating be-

643

1283

2563

5123

GT 5123

Figure 7. OGN is used to reproduce large-scale scenes from the dataset, where high resolution is crucial to generate ﬁne-grained structures.

Input

323

643

1283

2563

GT 2563

Category
Plane
Bench
Cabinet
Car
Chair
Monitor
Lamp
Speaker
Firearm
Couch
Table
Cellphone
Watercraft
Mean

R2N2 [6] OGN Dense
0.570
0.481
0.747
0.828
0.481
0.509
0.371
0.650
0.576
0.668
0.545
0.698
0.550
0.590

0.513
0.421
0.716
0.798
0.466
0.468
0.381
0.662
0.544
0.628
0.513
0.661
0.513
0.560

0.587
0.481
0.729
0.816
0.483
0.502
0.398
0.637
0.593
0.646
0.536
0.702
0.632
0.596

Table 5. Single-view 3D reconstruction results on the 323 version
of ShapeNet-all from Choy et al. [6] compared to OGN and a dense
baseline. OGN is competitive with voxel-grid-based networks.

decoder which had the same conﬁguration as our OGN de-
coder. Table 5 shows that compared to single-view recon-
structions from [6], both the OGN and the baseline dense
network compare favorably for most of the classes. In con-
clusion, the OGN is competitive with voxel-grid-based net-
works on the complex task of single-image class-speciﬁc
3D reconstruction.

We also evaluated the effect of resolution on the
ShapeNet-cars dataset. Figure 8 shows that OGNs learned
to infer the 3D shapes of cars in all cases, and that high-
resolution predictions are clearly better than the 323 models
commonly used so far. This is backed up by quantitative
results shown in Table 6: 323 results are signiﬁcantly worse
than the rest. At 2563 performance drops again for the same
reasons as in the decoder experiment in section 5.4.1.

6. Conclusions

We have presented a novel convolutional decoder ar-
chitecture for generating high-resolution 3D outputs repre-
sented as octrees. We have demonstrated that this architec-
ture is ﬂexible in terms of the exact layer conﬁguration, and

Figure 8. Single-image 3D reconstruction on the ShapeNet-cars
dataset using OGN in different resolutions.

Resolution
Single-view 3D 0.641

32

64
0.771

128
0.782

256
0.766

Table 6. Single-image 3D reconstruction results on ShapeNet-cars.
Low-resolution predictions are upsampled to 2563. Commonly
used 323 models are signiﬁcantly worse than the rest.

that it provides the same accuracy as dense voxel grids in
low resolution. At the same time, it scales much better to
higher resolutions, both in terms of memory and runtime.

This architecture enables end-to-end deep learning to be
applied to tasks that appeared unfeasible before. In particu-
lar, learning tasks that involve 3D shapes, such as 3D object
and scene reconstruction, are likely to beneﬁt from it.

While in this paper we have focused on shapes and bi-
nary occupancy maps, it is straightforward to extend the
framework to multi-dimensional outputs attached to the oc-
tree structure; for example, the output of the network could
be a textured shape or a signed distance function. This will
allow for an even wider range of applications.

Acknowledgements

This work was supported by the Excellence Initiative
of the German Federal and State Governments: BIOSS
Centre for Biological Signalling Studies (EXC 294). We
would like to thank Benjamin Ummenhofer for valuable
discussions and technical comments. We also thank Niko-
laus Mayer for his help with 3D model visualization and
manuscript preparation.

References

[1] F. Bogo, J. Romero, M. Loper, and M. J. Black. FAUST:
Dataset and evaluation for 3D mesh registration. In CVPR,
2014. 11

[2] F. Calakli and G. Taubin. SSD: Smooth Signed Distance
Surface Reconstruction. Computer Graphics Forum, 2011.
2
¨O. C¸ ic¸ek, A. Abdulkadir, S. Lienkamp, T. Brox, and O. Ron-
neberger. 3d u-net: Learning dense volumetric segmentation
from sparse annotation. In MICCAI, 2016. 2

[3]

[4] A. X. Chang, T. Funkhouser, L. Guibas, P. Hanrahan,
Q. Huang, Z. Li, S. Savarese, M. Savva, S. Song, H. Su,
J. Xiao, L. Yi, and F. Yu. ShapeNet: An Information-Rich
3D Model Repository. CoRR, abs/1512.03012, 2015. 5
[5] H. Chen, Q. Dou, L. Yu, and P. Heng. Voxresnet: Deep vox-
elwise residual networks for volumetric brain segmentation.
CoRR, abs/1608.05895, 2016. 2

[6] C. B. Choy, D. Xu, J. Gwak, K. Chen, and S. Savarese. 3d-
r2n2: A uniﬁed approach for single and multi-view 3d object
reconstruction. In ECCV, 2016. 2, 5, 7, 8

[7] C. Connolly. Cumulative generation of octree models from

range data. In ICRA, 1984. 2

[8] X. Di, R. Dahyot, and M. Prasad. Deep shape from a low

number of silhouettes. In ECCV Workshops, 2016. 2

[9] A. Dosovitskiy, P. Fischer, E. Ilg, P. H¨ausser, C. Hazırbas¸,
V. Golkov, P. v.d. Smagt, D. Cremers, and T. Brox. Flownet:
Learning optical ﬂow with convolutional networks. In ICCV,
2015. 1

[10] A. Dosovitskiy, J. T. Springenberg, M. Tatarchenko, and
T. Brox. Learning to generate chairs, tables and cars with
convolutional networks. IEEE Transactions on Pattern Anal-
ysis and Machine Intelligence, 2016. 1, 6, 7

[11] H. Fan, H. Su, and L. J. Guibas. A point set generation
network for 3d object reconstruction from a single image.
CoRR, abs/1612.00603, 2016. 2

[12] S. Fuhrmann and M. Goesele. Fusion of depth maps with

multiple scales. In SIGGRAPH Asia, 2011. 2

[13] M. Gadelha, S. Maji, and R. Wang. 3d shape induction from
2d views of multiple objects. CoRR, abs/1612.05872, 2016.
2

[14] I. Gargantini. Linear octtrees for fast processing of three-
dimensional objects. Computer Graphics and Image Pro-
cessing, 20(4):365 – 374, 1982. 2

[15] R. Girdhar, D. Fouhey, M. Rodriguez, and A. Gupta. Learn-
ing a predictable and generative vector representation for ob-
jects. In ECCV, 2016. 2, 6

[16] B. Graham. Spatially-sparse convolutional neural networks.

CoRR, abs/1409.6070, 2014. 2

[17] B. Graham. Sparse 3d convolutional neural networks.

In

BMVC, 2015. 2

[18] E. Grant, P. Kohli, and M. van Gerven. Deep disentan-
gled representations for volumetric reconstruction. In ECCV
Workshops, 2016. 2

[19] Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long,
R. Girshick, S. Guadarrama, and T. Darrell. Caffe: Con-
volutional architecture for fast feature embedding. CoRR,
abs/1408.5093, 2014. 4

[20] D. Jimenez Rezende, S. M. A. Eslami, S. Mohamed,
P. Battaglia, M. Jaderberg, and N. Heess. Unsupervised
learning of 3d structure from images. In NIPS. 2016. 2
[21] J. Johnson, A. Alahi, and L. Fei-Fei. Perceptual losses for
real-time style transfer and super-resolution. In ECCV, 2016.
1

[22] M. Kazhdan, M. Bolitho, and H. Hoppe. Poisson surface

reconstruction. In SGP, 2006. 2

[23] D. P. Kingma and J. Ba. Adam: A method for stochastic

optimization. In ICLR, 2014. 5

[24] J. Masci, D. Boscaini, M. M. Bronstein, and P. Van-
dergheynst. Geodesic convolutional neural networks on rie-
mannian manifolds. In ICCV Workshops, 2015. 2

[25] D. Meagher. Octree encoding: A new technique for the rep-
resentation, manipulation and display of arbitrary 3-d objects
by computer. Technical Report IPL-TR-80-111, 1980. 2
[26] H. Noh, S. Hong, and B. Han. Learning deconvolution net-

work for semantic segmentation. In ICCV, 2015. 1

[27] C. R. Qi, H. Su, K. Mo, and L. J. Guibas. Pointnet: Deep
learning on point sets for 3d classiﬁcation and segmentation.
CoRR, abs/1612.00593, 2016. 2

[28] A. Radford, L. Metz, and S. Chintala. Unsupervised repre-
sentation learning with deep convolutional generative adver-
sarial networks. CoRR, abs/1511.06434, 2015. 1

[29] G. Riegler, A. O. Ulusoy, and A. Geiger. Octnet: Learn-
ing deep 3d representations at high resolutions. CoRR,
abs/1611.05009, 2016. 2, 6

[30] A. Sharma, O. Grau, and M. Fritz. Vconv-dae: Deep volu-
metric shape learning without object labels. In ECCV Work-
shops, 2016. 2, 6

[31] A. Sinha, J. Bai, and K. Ramani. Deep learning 3d shape

surfaces using geometry images. In ECCV, 2016. 2

[32] F. Steinbr¨ucker, J. Sturm, and D. Cremers. Volumetric 3d

mapping in real-time on a cpu. In ICRA, 2014. 2

[33] M. Tatarchenko, A. Dosovitskiy, and T. Brox. Multi-view 3d
models from single images with a convolutional network. In
ECCV, 2016. 2

[34] S. Tulsiani, H. Su, L. J. Guibas, A. A. Efros, and J. Malik.
Learning shape abstractions by assembling volumetric prim-
itives. CoRR, abs/1612.00404, 2016. 2

[35] B. Ummenhofer and T. Brox. Global, dense multiscale re-

construction for a billion points. In ICCV, 2015. 2

[36] J. Wu, C. Zhang, T. Xue, W. T. Freeman, and J. B. Tenen-
baum. Learning a probabilistic latent space of object shapes
via 3d generative-adversarial modeling. In NIPS, 2016. 2

[37] Z. Wu, S. Song, A. Khosla, F. Yu, L. Zhang, X. Tang, and
J. Xiao. 3d shapenets: A deep representation for volumetric
shapes. In CVPR, 2015. 2

[38] X. Yan, J. Yang, E. Yumer, Y. Guo, and H. Lee. Perspective
transformer nets: Learning single-view 3d object reconstruc-
tion without 3d supervision. In NIPS, 2016. 2

[39] L. Yi, H. Su, X. Guo, and L. J. Guibas. Syncspeccnn: Syn-
chronized spectral CNN for 3d shape segmentation. CoRR,
abs/1612.00606, 2016. 2

[40] M. E. Yumer and N. J. Mitra. Learning semantic deformation
ﬂows with 3d convolutional networks. In ECCV, 2016. 2

Appendix

A. Computational efﬁciency

In the main paper we have shown that with a practi-
cal architecture our networks scale much better than their
dense counterparts both in terms of memory consumption
and computation time. The numbers were obtained for the
”houses” scene from the BlendSwap dataset.

OGN
Quadratic
Dense
Cubic

OGN
Quadratic
Dense
Cubic

B
G

,
e
g
a
s
u
y
r
o
m
e
m
k
a
e
P

10

1

0.1

0.01

s

,
e
m

i
t

n
o
i
t
a
r
e
t
I

10

1

0.1

0.01

representation. The architectures of those networks are sim-
ilar to those from Table 13, but with only 1 channel in ev-
ery convolutional layer, and a single fully-connected layer
with 64 units in the encoder. The resulting measurements
are shown in Figure 9 for memory consumption and Fig-
ure 10 for runtime. To precisely quantify the scaling, we
subtracted the constant amount of memory reserved on a
GPU by caffe (190 MB) from all numbers.

Both plots are displayed in the log-log scale, i.e., func-
tions from the family y = axk are straight lines. The
slope of this line is determined by the exponent k, and the
vertical shift by the coefﬁcient a.
In this experiment we
are mainly interested in the slope, that is, how do the ap-
proaches scale with increasing output resolution. As a refer-
ence, we show dashed lines corresponding to perfect cubic
and perfect quadratic scaling.

Starting from 643 voxel resolution both the runtime and
the memory consumption scale almost cubically in case of
dense networks. For this particular example, OGN scales
even better than quadratically, but in general scaling of the
octree-based representation depends on the speciﬁc data it
is applied to.

In Section 4.4 of the main paper, we described how
we use the two propagation modes (Prop-known and Prop-
pred) during training and testing. Here we motivate the pro-
posed regimes, and show additional results with other com-
binations of propagation modes.

When the structure of the output tree is not known at test
time, we train the networks until convergence with Prop-
known, and then additionally ﬁne-tune with Prop-pred - line
4 in Table 7. Without this ﬁne-tuning step (line 2), there is
a decrease in performance, which is more signiﬁcant when
using larger convolutional ﬁlters. Intuitively, this happens
because the network has never seen erroneous propagations
during training, and does not now how to deal with them at
test time.

When the structure of the output is known at test time,
the best strategy is to simply train in Prop-known, and test
the same way (line 1). Additional ﬁne-tuning in the Prop-
pred mode slightly hurts performance in this case (line 3).
The overall conclusion is not surprising: the best results are
obtained when training networks in the same propagation
modes, in which they are later tested.

32

64

256

512

128
Resolution

B. Train/test modes

Figure 9. Memory consumption for very slim networks, forward
and backward pass, batch size 1. Shown in log-log scale - lines
with smaller slope correspond to better scaling.

32

64

256

512

128
Resolution

Figure 10. Iteration time for very slim networks, forward and back-
ward pass, batch size 1. Shown in log-log scale - lines with smaller
slope correspond to better scaling.

In order to further study this matter, we have designed
a set of slim decoder networks that ﬁt on a GPU in every
resolution, including 5123, both with an OGN and a dense

C. Feature propagation

In the main paper we mentioned that the number of fea-
tures propagated by an OGNProp layer depends on the sizes
of the convolutional ﬁlters in all subsequent blocks. In case
of 23 up-convolutions with stride 2, which were used in
most of our experiments, no neighboring features need to

(A)

up-conv
ﬁlter: 2
stride: 2

(B)

up-conv
ﬁlter: 4
stride: 2

Training Testing
Known
Known
Pred
Known
Known
Pred
Pred
Pred

23 ﬁlters
0.904
0.862
0.898
0.884

43 ﬁlters
0.907
0.804
0.896
0.885

IntConv
0.907
0.823
0.897
0.885

Table 7. Reconstruction quality for autoencoders with different de-
coder architectures: 23 up-convolutions, 43 up-convolutions, and
23 up-convolutions interleaved with 33 convolutions, using dif-
ferent conﬁgurations of Prop-known and Prop-pred propagation
modes.

be propagated. This situation is illustrated in Figure 11-A
in a one-dimensional case. Circles correspond to cells of
an octree. The green cell in the input is the only one for
which the value was predicted to be ”mixed”. Links be-
tween the circles indicate which features of the input are
required to compute the result of the operation (convolution
or up-convolution) for the corresponding output cell. In this
case, we can see that the output cells in the next level are
only affected by their parent cell from the previous level.

A more general situation is shown in Figure 11-B. The
input is processed with an up-convolutional layer with 43
ﬁlters and stride 2, which is followed by a convolutional
layer with 33 ﬁlters and stride 1. Again, only one cell was
predicted to be ”mixed”, but in order to perform convolu-
tions and up-convolutions in subsequent layers, we addi-
tionally must propagate some of its neighbors (marked red).
Therefore, with this particular ﬁlter conﬁguration, two cells
in the output are affected by four cells in the input.

Generally, the number of features that should be prop-
agated by each OGNProp layer is automatically calculated
based on the network architecture before starting the train-
ing.

D. 3D shape from high-level information: ad-

ditional experiments

D.1. MPI-FAUST

To additionally showcase the beneﬁt of using higher res-
olutions, we trained OGNs to ﬁt the MPI-FAUST dataset
[1]. It contains 300 high-resolution scans of human bodies
of 10 different people in 30 different poses. Same as with
the BlendSwap, the trained networks cannot generalize to
new samples due to the low amount of training data.

Figure 12 and Table 8 demonstrate qualitative and quan-
titative results respectively. Human models from MPI-
FAUST include ﬁner details than cars from ShapeNet, and
therefore beneﬁt from the higher resolution.

D.2. Fitting reduced ShapeNet-cars

To better understand the performance drop at 2563 res-
olution observed in section 5.4.1 of the main paper, we

conv
ﬁlter: 3
stride: 1

mixed

propagated
neighbors

ﬁlled/empty

zero-padding

Figure 11. The OGNProp layer propagates the features of ”mixed”
cells together with the features of the neighboring cells required
for computations in subsequent layers. We show the number
of neighbors that need to be propagated in two cases: 23 up-
convolutions (A), and 43 up-convolutions followed by 33 convo-
lutions (B). Visualized in 1D for simplicity.

643

1283

2563

GT 2563

Figure 12. Training samples from the FAUST dataset recon-
structed by OGN.

performed an additional experiment on the ShapeNet-Cars
dataset. We trained an OGN for generating car shapes from
their IDs on a reduced version of ShapeNet-Cars, including

64
0.890

128
0.933

256
0.969

Table 8. 3D shape from high-level information on the FAUST
dataset. Lower-resolution predictions were upsampled to 2563
ground truth.

Dataset
Shapenet-cars (full)
Shapenet-cars (subset)

1283
0.901
0.922

2563
0.865
0.931

Table 9. There is no drop in performance in higher resolution,
when training on a subset of the Shapenet-cars dataset.

Full

Subset

GT 2563

1283

2563

1283

2563

Figure 13. When training on a subset of the Shapenet-cars datset,
higher resolution models contain more details.

just 500 ﬁrst models from the dataset. Quantitative results
for different resolutions, along with the results for the full
dataset, are shown in Table 9. Interestingly, when training
on the reduced dataset, high resolution is beneﬁcial. This is
further supported by examples shown in Figure 13 – when
training on the reduced dataset, the higher-resolution model
contain more ﬁne details. Overall, these results support our
hypothesis that the performance drop at higher resolution is
not due to the OGN architecture, but due to the difﬁculty of
ﬁtting a large dataset at high resolution.

E. Shift invariance

The convolution operation on a voxel grid is perfectly
shift invariant by design. This is no longer true for convo-
lutions on octrees: a shift by a single pixel in the original
voxel grid can change the structure of the octree signiﬁ-
cantly. To study the effect of shifts, we trained two fully
convolutional autoencoders - one with an OGN decoder,
and one with a dense decoder - on 643 models, with low-
est feature map resolution 43 (so the networks should be

perfectly invariant to shifts of 16 voxels). Both were trained
on non-shifted Shapenet-Cars, and tested in the Prop-pred
mode on models shifted by a different number of voxels
along the z-axis. The results are summarized in Table 10.

Shift (voxels) OGN Dense
0.932
0.93
0.925
0.915
0.904

0.935
0.933
0.929
0.917
0.906

0
1
2
4
8

Table 10. Fully-convolutional networks tested on shifted data.
Even though not shift invariant by design, OGN shows robust per-
formance.

There is no signiﬁcant difference between OGN and the
dense network. A likely reason is that different training
models have different octree structures, which acts as an
implicit regularizer. The network learns the shape, but re-
mains robust to the exact octree structure.

F. Network architectures

In this section, we provide the exact network architec-

tures used in the experimental evaluations.

F.1. Autoencoders

The architectures of OGN autoencoders are summarized
in Table 12. For the dense baselines, we used the same layer
conﬁgurations with usual convolutions instead of OGN-
Conv, and predictions being made only after the last layer
of the network. All networks were trained with batch size
16.

F.2. 3D shape from high-level information

OGN decoders used on the Shapenet-cars dataset are
shown in Table 13. Encoders consisted of three fully-
connected layers, with output size of the last encoder layer
being identical to the input size of the corresponding de-
coder.

For FAUST and BlendSwap the 2563 output octrees had
four levels, not ﬁve like those in Table 13. Thus, the
dense block had an additional deconvolution-convolution
layer pair instead of one octree block. The 5123 decoder
on BlendSwap had one extra octree block with 32 output
channels.

All 643 and 1283 networks were trained with batch size

16, 2563 — with batch size 4, 5123 — with batch size 1.

F.3. Single-image 3D reconstruction

In this experiment we again used decoder architectures
shown in Table 13. The architecture of the convolutional
encoder is shown in Table 11. The number of channels in

the last encoder layer was set identical to the number of
input channels of the corresponding decoder.

[137 × 137 × 3]
Conv (7 × 7)
[69 × 69 × 32]
Conv (3 × 3)
[35 × 35 × 32]
Conv (3 × 3)
[18 × 18 × 64]
Conv (3 × 3)
[9 × 9 × 64]
Conv (3 × 3)
[5 × 5 × 128]
FC
[1024]
FC
[1024]
FC
[43 × c]

Table 11. Convolutional encoder used in the single-image 3D re-
construction experiment.

323

643 (23 ﬁlters)

643 (InvConv)

[323 × 1]
Conv (33)
[163 × 32]
Conv (33)
[83 × 48]
Conv (33)
[43 × 64]
FC
[1024]
FC
[1024]
FC
[43 × 80]
Deconv (23)
[83 × 64]
Conv (33)→ l1
[83 × 64]
OGNProp
OGNConv(23) → l2
[163 × 48]
OGNProp
OGNConv(23) → l3
[323 × 32]

643 (43 ﬁlters)
[643 × 1]
Conv (33)
[323 × 32]
Conv (33)
[163 × 48]
Conv (33)
[83 × 64]
Conv (33)
[43 × 80]
FC
[1024]
FC
[1024]
FC
[43 × 96]
Deconv (23)
[83 × 80]
Conv (33)
[83 × 80]

Deconv (23)
[163 × 64]

Conv (33)→ l1
[163 × 64]
OGNProp

[323 × 48]

OGNConv(23) → l2 OGNConv(43) → l2

OGNProp

[323 × 48]

OGNProp

OGNProp

OGNConv(23) → l3 OGNConv(43) → l3

[643 × 32]

[643 × 32]

OGNProp
OGNConv(23)
[323 × 48]
OGNConv*(33) → l2
[323 × 48]
OGNProp
OGNConv(23)
[643 × 32]
OGNConv*(33) → l3
[643 × 32]

Table 12. OGN architectures used in our experiments with autoencoders. OGNConv denotes up-convolution, OGNConv* — convolution.
Layer name followed by ’→ lk’ indicates that level k of an octree is predicted by a classiﬁer attached to this layer.

323
[43 × 80]
Deconv (23)
[83 × 64]
Conv (33) → l1
[83 × 64]
OGNProp
OGNConv (23) → l2
[163 × 48]
OGNProp
OGNConv (23) → l3
[323 × 32]

643
[43 × 96]
Deconv (23)
[83 × 80]
Conv (33)
[83 × 80]

Deconv (23)
[163 × 64]

1283
[43 × 112]
Deconv (23)
[83 × 96]
Conv (33)
[83 × 96]

Deconv (23)
[163 × 80]

2563
[43 × 112]
Deconv (23)
[83 × 96]
Conv (33)
[83 × 96]

Deconv (23)
[163 × 80]

Conv (33) → l1
[163 × 80]
OGNProp

Conv (33) → l1
[163 × 64]
OGNProp

Conv (33) → l1
[163 × 80]
OGNProp
OGNConv (23) → l2 OGNConv (23) → l2 OGNConv (23) → l2
[323 × 64]
OGNProp
OGNConv (23) → l3 OGNConv (23) → l3 OGNConv (23) → l3
[643 × 48]
OGNProp

[323 × 64]
OGNProp

[643 × 48]
OGNProp

[323 × 48]
OGNProp

[643 × 32]

OGNConv (23) → l4 OGNConv (23) → l4

[1283 × 32]

[1283 × 32]
OGNProp
OGNConv (23) → l5
[2563 × 32]

Table 13. OGN decoder architectures used in shape from ID, and single-image 3D reconstruction experiments.

Octree Generating Networks:
Efﬁcient Convolutional Architectures for High-resolution 3D Outputs

Maxim Tatarchenko1
tatarchm@cs.uni-freiburg.de

Alexey Dosovitskiy1,2
adosovitskiy@gmail.com

Thomas Brox1
brox@cs.uni-freiburg.de

1University of Freiburg

2Intel Labs

7
1
0
2
 
g
u
A
 
7
 
 
]

V
C
.
s
c
[
 
 
3
v
8
3
4
9
0
.
3
0
7
1
:
v
i
X
r
a

Abstract

We present a deep convolutional decoder architecture
that can generate volumetric 3D outputs in a compute- and
memory-efﬁcient manner by using an octree representation.
The network learns to predict both the structure of the oc-
tree, and the occupancy values of individual cells. This
makes it a particularly valuable technique for generating
3D shapes. In contrast to standard decoders acting on reg-
ular voxel grids, the architecture does not have cubic com-
plexity. This allows representing much higher resolution
outputs with a limited memory budget. We demonstrate this
in several application domains, including 3D convolutional
autoencoders, generation of objects and whole scenes from
high-level representations, and shape from a single image.

1. Introduction

Up-convolutional1 decoder architectures have become
a standard tool for tasks requiring image generation [10,
28, 21] or per-pixel prediction [26, 9]. They consist of
a series of convolutional and up-convolutional (upsam-
pling+convolution) layers operating on regular grids, with
resolution gradually increasing towards the output of the
network. The architecture is trivially generalized to volu-
metric data. However, because of cubic scaling of computa-
tional and memory requirements, training up-convolutional
decoders becomes infeasible for high-resolution three-
dimensional outputs.

Poor scaling can be resolved by exploiting structure in
the data. In many learning tasks, neighboring voxels on a
voxel grid share the same state — for instance, if the voxel
grid represents a binary occupancy map or a multi-class
labeling of a three-dimensional object or a scene. In this
case, data can be efﬁciently represented with octrees — data
structures with adaptive cell size. Large regions of space
sharing the same value can be represented with a single

1Also known as deconvolutional

dense

Octree
level 1

Octree
level 2

Octree
level 3

323

643

1283

Figure 1. The proposed OGN represents its volumetric output as an
octree. Initially estimated rough low-resolution structure is gradu-
ally reﬁned to a desired high resolution. At each level only a sparse
set of spatial locations is predicted. This representation is signiﬁ-
cantly more efﬁcient than a dense voxel grid and allows generating
volumes as large as 5123 voxels on a modern GPU in a single for-
ward pass.

large cell of an octree, resulting in savings in computation
and memory compared to a ﬁne regular grid. At the same
time, ﬁne details are not lost and can still be represented by
small cells of the octree.

We present an octree generating network (OGN) - a con-
volutional decoder operating on octrees. The coarse struc-
ture of the network is illustrated in Figure 1. Similar to a
usual up-convolutional decoder, the representation is grad-
ually convolved with learned ﬁlters and up-sampled. The
difference is that, starting from a certain layer in the net-
work, dense regular grids are replaced by octrees. There-
fore, the OGN predicts large uniform regions of the output
space already at early decoding stages, saving the computa-
tion for the subsequent high-resolution layers. Only regions
containing ﬁne details are processed by these more compu-
tationally demanding layers.

In this paper, we focus on generating shapes represented
as binary occupancy maps. We thoroughly compare OGNs
to standard dense nets on three tasks: auto-encoding shapes,
generating shapes from a high-level description, and recon-
structing 3D objects from single images. OGNs yield the
same accuracy as conventional dense decoders while con-
suming signiﬁcantly less memory and being much faster at

high resolutions. For the ﬁrst time, we can generate shapes
of resolution as large as 5123 voxels in a single forward
pass. Our OGN implementation is publicly available2.

2. Related work

The majority of deep learning approaches generate vol-
umetric data based on convolutional networks with fea-
ture maps and outputs represented as voxel grids. Appli-
cations include single- and multi-view 3D object recon-
struction trained in supervised [15, 6, 8, 18] and unsuper-
vised [38, 13, 20] ways, probabilistic generative modeling
of 3D shapes [37, 36, 30], semantic segmentation [3, 5]
and shape deformation [40]. A fundamental limitation of
these approaches is the low resolution of the output. Mem-
ory and computational requirements of approaches based on
the voxel grid representation scale cubically with the out-
put size. Thus, training networks with resolutions higher
than 643 comes with memory issues on the GPU or re-
quires other measures to save memory, such as reducing
the batch size or generating the volume part-by-part. More-
over, with growing resolution, training times become pro-
hibitively slow.

Computational limitations of the voxel grid representa-
tion led to research on alternative representations of volu-
metric data in deep learning. Tatarchenko et al. [33] pre-
dict RGB images and depth maps for multiple views of
an object, and fuse those into a single 3D model. This
approach is not trainable end to end because of the post-
processing fusion step, and is not applicable to objects with
strong self-occlusion. Sinha et al. [31] convert shapes into
two-dimensional geometry images and process those with
conventional CNNs – an approach only applicable to cer-
tain classes of topologies. Networks producing point clouds
have been applied to object generation [11] and semantic
segmentation [27]. By now, these architectures have been
demonstrated to generate relatively low-resolution outputs.
Scaling these networks to higher resolution is yet to be ex-
plored. Tulsiani et al. [34] assemble objects from volumet-
ric primitives. Yi et al. [39] adapt the idea of graph convolu-
tions in the spectral domain to semantic segmentation of 3D
shapes. Their approach requires all samples to have aligned
eigenbasis functions, thus limiting possible application do-
mains.

Promising alternative representations that are not di-
rectly applicable to generating 3D outputs have been ex-
plored on analysis tasks. Masci et al. [24] proposed
geodesic CNNs for extracting local
features in non-
Euclidean domains. Our approach is largely inspired by
Graham’s sparse convolutional networks [16, 17], which
enable efﬁcient shape analysis by storing a sparse set of
non-trivial features instead of dense feature maps. The

OGN essentially solves the inverse problem by predict-
ing which regions of the output contain high-resolution in-
formation and by restricting extensive calculations only to
those regions.

The recent pre-print by Riegler et al. [29] builds on the
same general idea as our work: designing convolutional net-
works that operate on octrees instead of voxel grids. How-
ever, the implementation and the application range of the
method is very different from our work. When generating
an octree, Riegler et al. assume the octree structure to be
known at test time. This is the case, for example, in seman-
tic segmentation, where the structure of the output octree
can be set to be identical to that of the input. However, in
many important scenarios — any kind of 3D reconstruc-
tion, shape modeling, RGB-D fusion, superresolution —
the structure of the octree is not known in advance and must
be predicted. The method of Riegler et al. is not applicable
in these cases. Moreover, the OGN is more ﬂexible in that
it allows for octrees with an arbitrary number of levels.

3. Octrees

An octree [25] is a 3D grid structure with adaptive cell
size, which allows for lossless reduction of memory con-
sumption compared to a regular voxel grid. Octrees have a
long history in classical 3D reconstruction and depth map
fusion [22, 2, 12, 35, 7, 32]. A function deﬁned on a voxel
grid can be converted into a function deﬁned on an octree.
This can be done by starting from a single cell representing
the entire space and recursively partitioning cells into eight
octants. If every voxel within a cell has the same function
value, this cell is not subdivided and becomes a leaf of the
tree. The set of cells at a certain resolution is referred to as
an octree level. The recursive subdivision process can also
be started not from the whole volume, but from some initial
coarse resolution. Then the maximal octree cell size is given
by this initial resolution. The most straightforward way of
implementing an octree is to store in each cell pointers to its
children. In this case, the time to access an element scales
linearly with the tree’s depth, which can become costly at
high resolutions. We use a more efﬁcient implementation
that exploits hash tables. An octree cell with spatial coordi-
nates x = (x, y, z) at level l is represented as an index-value
pair (m, v), where v can be any kind of discrete or continu-
ous signal. m is calculated from (x, l) using Z-order curves
[14]

m = Z(x, l),

which is a computationally cheap transformation imple-
mented using bit shifts. An octree O is, hence, a set of all
pairs

(1)

(2)

2https://github.com/lmb-freiburg/ogn

O = {(m, v)}.

Fl−1

¯Fl

Fl

...

d1

OGNConv
...
(one or more)

OGNProp

...

c

d2

13
conv

OGNLoss

propagated features

empty

ﬁlled

mixed

Ground truth

Prediction

Figure 2. Single block of an OGN illustrated as 2D quadtree for simplicity. After convolving features Fl−1 of the previous block with
weight ﬁlters, we directly predict the occupancy values of cells at level l using 13 convolutions. Features corresponding to ”ﬁlled” and
”empty” cells are no longer needed and thus not propagated, which yields Fl as the ﬁnal output of this block.

Storing this set as a hash table allows for constant-time ele-
ment access.

When training networks, we will need to compare two
different octrees O1 and O2, i.e. for each cell (x, l) from
O1, query the corresponding signal value v in O2. Since
different octrees have different structure, two situations are
possible. If Z(x, k) is stored at a level k in O2, which is
the same or lower than l, the signal value of this cell can
be uniquely determined. If Z(x, k) is stored at one of the
later levels, the cell is subdivided in O2, and the value of the
whole cell is not deﬁned. To formalize this, we introduce a
function f for querying the signal value of an arbitrary cell
with index m = Z(x, l) from octree O:

(cid:26) v, if ∃k ≤ l : (Z(x, k), v) ∈ O

f (m, O) =

∅, otherwise

,

(3)

where ∅ denotes an unavailable value.

4. Octree Generating Networks

An Octree Generating Network (OGN) is a convolu-
tional decoder that yields an octree as output: both the
structure, i.e. which cells should be subdivided, and the
signal value of each cell. In this work we concentrate on bi-
nary occupancy values v ∈ {0, 1}, but the proposed frame-
work can be easily extended to support arbitrary signals. As
shown in Figure 1, an OGN consists of a block operating
on dense regular grids, followed by an arbitrary number of
hash-table-based octree blocks.

The dense block is a set of conventional 3D convolu-
tional and up-convolutional layers producing a feature map
of size d1 × d2 × d3 × c as output, where {di} are the spatial
dimension and c is the number of channels.

From here on, the representation is processed by our cus-
tom layers operating on octrees. The regular-grid-based fea-
ture map produced by the dense block is converted to a set
of index-value pairs stored as a hash table (with values be-
ing feature vectors), and is further processed in this format.
We organize octree-based layers in blocks, each responsible
for predicting the structure and the content of a single level
of the generated octree.

Figure 2 illustrates the functioning of a single such block
that predicts level l of an octree. For the sake of illustration,
we replaced three-dimensional octrees by two-dimensional
quadtrees. Feature maps in Figure 2 are shown as dense ar-
rays only for simplicity; in fact the green cells are stored in
hash maps, and the white cells are not stored at all. We now
give a high-level overview of the block and then describe its
components in more detail.

Input to the block is a sparse hash-table-based convolu-
tional feature map Fl−1 of resolution (d1·2l−1, d2·2l−1, d3·
2l−1) produced by the previous block. First this feature map
is processed with a series of custom convolutional layers
and one up-convolutional layer with stride 2, all followed
by non-linearities.

This yields a new feature map ¯Fl of resolution (d1·2l, d2·
2l, d3 · 2l). Based on this feature map, we directly predict
the content of level l. For each cell, there is a two-fold
decision to be made: should it be kept at level l, and if yes,

what should be the signal value in this cell? In our case
making this decision can be formulated as classifying the
cell as being in one of three states: ”empty”, ”ﬁlled” or
”mixed”. These states correspond to the outputs of state-
querying function f from eq. (3), with ”empty” and ”ﬁlled”
being the signal values v, and ”mixed” being the state where
the value is not determined. We make this prediction using a
convolutional layer with 13 ﬁlters followed by a three-way
softmax. This classiﬁer is trained in a supervised manner
with targets provided by the ground truth octree.

Finally,

in case the output resolution has not been
reached, features from ¯Fl that correspond to ”mixed” cells
are propagated to the next layer3 and serve as an input fea-
ture map Fl to the next block.

In the following subsections, we describe the compo-
nents of a single octree block in more detail:
the octree-
based convolution, the loss function, and the feature propa-
gation mechanism.

4.1. Convolution

We implemented a custom convolutional layer OGN-
Conv, which operates on feature maps represented as hash
tables instead of usual dense arrays. Our implementation
supports strided convolutions and up-convolutions with ar-
bitrary ﬁlter sizes. It is based on representing convolution as
a single matrix multiplication, similar to standard caffe [19]
code for dense convolutions.

In the dense case, the feature tensor is converted to a
matrix with the im2col operation, then multiplied with the
weight matrix of the layer, and the result is converted back
into a dense feature tensor using the col2im operation. In
OGN, instead of storing full dense feature tensors, only a
sparse set of relevant features is stored at each layer. These
features are stored in a hash table, and we implemented
custom operations to convert a hash table to a feature ma-
trix and back. The resulting matrices are much smaller
than those in the dense case. Convolution then amounts to
multiplying the feature matrix by the weight matrix. Ma-
trix multiplication is executed on GPU with standard opti-
mized functions, and our conversion routines currently run
on CPU. Even with this suboptimal CPU implementation,
computation times are comparable to those of usual dense
convolutions at 323 voxel resolution. At higher resolutions,
OGNConv is much faster than dense convolutions (see sec-
tion 5.2).

Unlike convolutions on regular grids, OGN convolutions
are not shift invariant by design. This is studied in Section
E of the Appendix.

3Additional neighboring cells may have to be propagated if needed by

subsequent convolutional layers. This is described in section 4.3.

4.2. Loss

The classiﬁer at level l of the octree outputs the proba-
bilities of each cell from this level being ”empty”, ”ﬁlled”
or ”mixed”, that is, a three-component prediction vector
pm = (p0
m) for cell with index m. We minimize
the cross-entropy between the network predictions and the
cell states of the ground truth octree OGT , averaged over
the set Ml of cells predicted at layer l:

m, p1

m, p2

Ll =

1
|Ml|

(cid:34) 2

(cid:88)

(cid:88)

m∈Ml

i=0

hi(f (m, OGT )) log pi
m

,

(4)

(cid:35)

where function h yields a one-hot encoding (h0, h1, h2) of
the cell state value returned by f from eq. (3). Loss compu-
tations are encapsulated in our custom OGNLoss layer.

The ﬁnal OGN objective is calculated as a sum of loss

values from all octree levels

L =

Ll.

L
(cid:88)

l=1

(5)

4.3. Feature propagation

At the end of each octree block there is an OGNProp
layer that propagates to the next octree block features from
cells in the ”mixed” state, as well as from neighboring cells
if needed to compute subsequent convolutions. Information
about the cell state can either be taken from the ground truth
octree, or from the network prediction. This spawns two
possible propagation modes: using the known tree structure
(Prop-known) and using the predicted tree structure (Prop-
pred). Section 4.4 describes use cases for these two modes.
The set of features to be propagated depends on the
kernel size in subsequent OGNConv layers. The example
illustrated in Figure 2 only holds for 23 up-convolutions
which do not require any neighboring elements to be com-
puted. To use larger convolutional ﬁlters or multiple convo-
lutional layers, we must propagate not only the features of
the ”mixed” cells, but also the features of the neighboring
cells required for computing the convolution at the locations
of the ”mixed” cells. The size of the required neighborhood
is computed based on the network architecture, before the
training starts. Details are provided in Section C of the Ap-
pendix.

4.4. Training and testing

The OGN decoder is end-to-end trainable using stan-
dard backpropagation. The only subtlety is in selecting the
feature propagation modes during training and testing. At
training time the octree structure of the training samples is
always available, and therefore the Prop-known mode can
be used. At test time, the octree structure may or may not

be available. We have developed two training regimes for
these two cases.

If the tree structure is available at test time, we simply
train the network with Prop-known and test it the same way.
This regime is applicable for tasks like semantic segmenta-
tion, or, more generally, per-voxel prediction tasks, where
the structure of the output is exactly the same as the struc-
ture of the input.

If the tree structure is not available at test time, we start
by training the network with Prop-known, and then ﬁne-
tune it with Prop-pred. This regime is applicable to any
task with volumetric output.

We have also tested other regimes of combining Prop-
pred and Prop-known and found those to perform worse
than the two described variants. This is discussed in more
detail in Section B of the Appendix.

5. Experiments

In our experiments we veriﬁed that the OGN architec-
ture performs on par with the standard dense voxel grid rep-
resentation, while requiring signiﬁcantly less memory and
computation, particularly at high resolutions. The focus of
the experiments is on showcasing the capabilities of the pro-
posed architecture. How to fully exploit the new architec-
ture in practical applications is a separate problem that is
left to future work.

5.1. Experimental setup

For all OGN decoders used in our evaluations, we fol-
lowed the same design pattern: 1 or 2 up-convolutional lay-
ers interleaved with a convolutional layer in the dense block,
followed by multiple octree blocks depending on the output
resolution. In the octree blocks we used 23 up-convolutions.
We also evaluated two other architecture variants, presented
in section 5.3.1. ReLU non-linearities were applied after
each (up-)convolutional layer. The number of channels in
the up-convolutional layers of the octree blocks was set to
32 in the outermost layer, and was increased by 16 in each
preceding octree block. The exact network architectures
used in individual experiments are shown in Section F of
the Appendix.

The networks were trained using ADAM [23] with ini-
tial learning rate 0.001, β1 = 0.9, β2 = 0.999. The learning
rate was decreased by a factor of 10 after 30K and 70K it-
erations. We did not apply any additional regularization.

For quantitative evaluations, we converted the resulting
octrees back to regular voxel grids, and computed the In-
tersection over Union (IoU) measure between the ground
truth model and the predicted model. To quantify the im-
portance of high-resolution representations, in some exper-
iments we upsampled low-resolution network predictions
to high-resolution ground truth using trilinear interpolation,
and later binarization with a threshold of 0.5. We explicitly

specify the ground truth resolution in all experiments where
this was done.

If not indicated otherwise, the results were obtained in

the Prop-pred mode.

5.1.1 Datasets

In our evaluations we used three datasets:

ShapeNet-all Approximately 50.000 CAD models from
13 main categories of the ShapeNet dataset [4], used by
Choy et al. [6]. We also used the renderings provided by
Choy et al. [6].

ShapeNet-cars A subset of ShapeNet-all consisting of

7497 car models.

BlendSwap A dataset of 4 scenes we manually collected
from blendswap.com, a website containing a large col-
lection of Blender models.

All datasets were voxelized in multiple resolutions from
323 to 5123 using the binvox4 tool, and were converted into
octrees. We set the interior parts of individual objects to be
ﬁlled, and the exterior to be empty.

5.2. Computational efﬁciency

We start by empirically demonstrating that OGNs can be
used at high resolutions when the voxel grid representation
becomes impractical both because of the memory require-
ments and the runtime.

The number of elements in a voxel grid is uniquely de-
termined by its resolution, and scales cubically as the latter
increases. The number of elements in an octree depends
on the data, leading to variable scaling rates: from con-
stant for cubic objects aligned with the grid, to cubic for
pathological shapes such as a three-dimensional checker-
board. In practice, octrees corresponding to real-world ob-
jects and scenes scale approximately quadratically, since
they represent smooth two-dimensional surfaces in a three-
dimensional space.

Memory, GB

Iteration time, s

OGN
Dense

OGN
Dense

80

60

40

20

0

40

20

0

32 128

256

512

32 128

256

512

Figure 3. Memory consumption (left) and iteration time (right) of
OGN and a dense network at different output resolutions. Forward
and backward pass, batch size 1.

4http://www.patrickmin.com/binvox

Memory, GB

Iteration time, s
Resolution Dense OGN Dense OGN
0.016
0.06
0.18
0.64
2.06

0.33
0.50
1.62
9.98
(74.28)

0.015
0.19
0.56
3.89
(41.3)

323
643
1283
2563
5123

0.29
0.36
0.43
0.54
0.88

Table 1. Memory consumption and iteration time of OGN and a
dense network at different output resolutions. Batch size 1.

We empirically compare the runtime and memory con-
sumption values for a dense network and OGN, for vary-
ing output resolution. Architectures of the networks are
the same as used in Section 5.4 – three fully connected
layers followed by an up-convolutional decoder. We per-
formed the measurements on an NVidia TitanX Maxwell
GPU, with 12Gb of memory. To provide actual measure-
ments for dense networks at the largest possible resolution,
we performed the comparison with batch size 1. The 5123
dense network does not ﬁt into memory even with batch size
1, so we extrapolated the numbers by ﬁtting cubic curves.

Figure 3 and Table 1 show the results of the comparison.
The OGN is roughly as efﬁcient as its dense counterpart for
low resolutions, but as the resolution grows, it gets drasti-
cally faster and consumes far less memory. At 5123 voxel
resolution, the OGN consumes almost two orders of mag-
nitude less memory and runs 20 times faster. In Section A
of the Appendix we provide a more detailed analysis and
explicitly demonstrate the near-cubic scaling of dense net-
works against the near-quadratic scaling of OGNs.

To put these numbers into perspective, training OGN at
2563 voxel output resolution takes approximately 5 days.
Estimated training time of its dense counterpart would be al-
most a month. Even if the 5123 voxel dense network would
ﬁt into memory, it would take many months to train.

5.3. Autoencoders

Autoencoders and their variants are commonly used for
representation learning from volumetric data
[15, 30].
Therefore, we start by comparing the representational
power of the OGN to that of dense voxel grid networks on
the task of auto-encoding volumetric shapes.

We used the decoder architecture described in section 5.1
both for the OGN and the dense baseline. The architecture
of the encoder is symmetric to the decoder. Both encoders
operate on a dense voxel grid representation5.

We trained the autoencoders on the ShapeNet-cars
dataset in two resolutions: 323 and 643. We used 80% of the
data for training, and 20% for testing. Quantitative results

5In this paper, we focus on generating 3D shapes. Thus, we have not
implemented an octree-based convolutional encoder. This could be done
along the lines of Riegler et al. [29]

are summarized in Table 2. With predicted octree structure,
there is no signiﬁcant difference in performance between
the OGN and the dense baseline.

Network
Dense
OGN+Prop-known
OGN+Prop-pred

323
0.924
0.939
0.924

643
0.890
0.904
0.884

Table 2. Quantitative results for OGN and dense autoencoders.
Predictions were compared with the ground truth at the corre-
sponding resolution, without upsampling.

5.3.1 Flexibility of architecture choice

To show that OGNs are not limited to up-convolutional lay-
ers with 23 ﬁlters, we evaluated two alternative 643 OGN
auto-encoders: one with 43 up-convolutions and one with
23 up-convolutions interleaved with 33 convolutions. The
results are summarized in Table 7. There is no signiﬁ-
cant difference between the architectures for this task. With
larger ﬁlters, the network is roughly twice slower in our cur-
rent implementation, so we used 23 ﬁlters in all further ex-
periments.

5.3.2 Using known structure

Interestingly, OGN with known tree structure outperforms
the network based on a dense voxel grid, both qualitatively
and quantitatively. An example of this effect can be seen in
Figure 4: the dense autoencoder and our autoencoder with
predicted propagation struggle with properly reconstructing
the spoiler of the car. Intuitively, the known tree structure
provides additional shape information to the decoder, thus
simplifying the learning problem. In the autoencoder sce-
nario, however, this may be undesirable if one aims to en-
code all information about a shape in a latent vector. In tasks
like semantic segmentation, the input octree structure could
help introduce shape features implicitly in the learning task.

5.4. 3D shape from high-level information

We trained multiple OGNs for generating shapes from
high-level parameters similar to Dosovitskiy et al. [10]. In
all cases the input of the network is a one-hot encoded ob-
ject ID, and the output is an octree with the object shape.

Mode
OGN+Prop-known
OGN+Prop-pred

2x2 ﬁlters
0.904
0.884

4x4 ﬁlters
0.907
0.885

IntConv
0.907
0.885

Table 3. Using more complex architectures in 643 OGN autoen-
coders does not lead to signiﬁcant performance improvements.

Dense

OGN+Prop-pred OGN+Prop-known

GT

tween pairs of one-hot input ID vectors. Figure 6 shows that
for all intermediate input values the network produces con-
sistent output cars, with the style being smoothly changed
between the two training points.

Figure 4. Using the known tree structure at test time leads to im-
proved performance.

ShapeNet-cars
BlendSwap

64
0.856
0.535

128
0.901
0.649

256
0.865
0.880

512
-
0.969

Table 4. Quantitative evaluation of 3D shapes generated from high-
level information. Lower-resolution predictions from ShapeNet-
cars were upsampled to 2563 ground truth,
scenes from
BlendSwap — to 5123.

643

1283

2563

GT 2563

643

1283

2563

Figure 6. Our networks can generate previously unseen cars by
interpolating between the dataset points, which demonstrates their
generalization capabilities.

5.4.2 BlendSwap

To additionally showcase the beneﬁt of using higher reso-
lutions, we trained OGNs to ﬁt the BlendSwap dataset con-
taining 4 whole scenes.
In contrast to the ShapeNet-cars
dataset, such amount of training data does not allow for any
generalization. The experiment aims to show that OGNs
provide sufﬁcient resolution to represent such high-ﬁdelity
shape data.

Figure 7 shows the generated scenes. In both examples,
643 and 1283 resolutions are inadequate for representing the
details. For the bottom scene, even the 2563 resolution still
struggles with ﬁne-grained details. This example demon-
strates that tasks like end-to-end learning of scene recon-
struction requires high-resolution representations, and the
OGN is an architecture that can provide such resolutions.

These qualitative observations are conﬁrmed quantita-
tively in Table 4. Higher output resolutions allow for more
accurate reconstruction of the samples in the dataset. More
results for this experiment are shown in Section D of the
Appendix, and the accompanying video6.

5.5. Single-image 3D reconstruction

In this experiment we trained networks with our OGN
decoder on the task of single-view 3D reconstruction. To
demonstrate that our dense voxel grid baseline, as already
used in the autoencoder experiment, is a strong baseline, we
compare to the approach by Choy et al. [6]. This approach
operates on 323 voxel grids, and we adopt this resolution
for our ﬁrst experiment. To ensure a fair comparison, we
trained networks on ShapeNet-all, the exact dataset used by
Choy et al. [6]. Following the same dataset splitting strat-
egy, we used 80% of the data for training, and 20% for
testing. As a baseline, we trained a network with a dense

6https://youtu.be/kmMvKNNyYF4

Figure 5. Training samples from the ShapeNet-cars dataset gener-
ated by our networks. Cells at different octree levels vary in size
and are displayed in different shades of gray.

5.4.1 ShapeNet-cars

First, we trained on the whole ShapeNet-cars dataset in
three resolutions: 643, 1283 and 2563. Example outputs
are shown in Figure 5 and quantitative results are presented
in Table 4. Similar to the two-dimensional case [10], the
outputs are accurate in the overall shape, but lack some ﬁne
details. This is not due to the missing resolution, but due to
general limitations of the training data and the learning task.
Table 4 reveals that a resolution of 1283 allows the recon-
struction of a more accurate shape with more details than
a resolution of 643. At an even higher resolution of 2563,
the overall performance decreased again. Even though the
higher-resolution network is architecturally capable of per-
forming better, it is not guaranteed to train better. Noisy gra-
dients from outer high-resolution layers may hamper learn-
ing of deeper layers, resulting in an overall decline in per-
formance. This problem is orthogonal to the issue of de-
signing computationally efﬁcient architectures, which we
aim to solve in this paper. We further discuss this in the
Appendix.

Notably, the network does not only learn to generate ob-
jects from the training dataset, but it can also generalize to
unseen models. We demonstrate this by interpolating be-

643

1283

2563

5123

GT 5123

Figure 7. OGN is used to reproduce large-scale scenes from the dataset, where high resolution is crucial to generate ﬁne-grained structures.

Input

323

643

1283

2563

GT 2563

Category
Plane
Bench
Cabinet
Car
Chair
Monitor
Lamp
Speaker
Firearm
Couch
Table
Cellphone
Watercraft
Mean

R2N2 [6] OGN Dense
0.570
0.481
0.747
0.828
0.481
0.509
0.371
0.650
0.576
0.668
0.545
0.698
0.550
0.590

0.587
0.481
0.729
0.816
0.483
0.502
0.398
0.637
0.593
0.646
0.536
0.702
0.632
0.596

0.513
0.421
0.716
0.798
0.466
0.468
0.381
0.662
0.544
0.628
0.513
0.661
0.513
0.560

Table 5. Single-view 3D reconstruction results on the 323 version
of ShapeNet-all from Choy et al. [6] compared to OGN and a dense
baseline. OGN is competitive with voxel-grid-based networks.

decoder which had the same conﬁguration as our OGN de-
coder. Table 5 shows that compared to single-view recon-
structions from [6], both the OGN and the baseline dense
network compare favorably for most of the classes. In con-
clusion, the OGN is competitive with voxel-grid-based net-
works on the complex task of single-image class-speciﬁc
3D reconstruction.

We also evaluated the effect of resolution on the
ShapeNet-cars dataset. Figure 8 shows that OGNs learned
to infer the 3D shapes of cars in all cases, and that high-
resolution predictions are clearly better than the 323 models
commonly used so far. This is backed up by quantitative
results shown in Table 6: 323 results are signiﬁcantly worse
than the rest. At 2563 performance drops again for the same
reasons as in the decoder experiment in section 5.4.1.

6. Conclusions

We have presented a novel convolutional decoder ar-
chitecture for generating high-resolution 3D outputs repre-
sented as octrees. We have demonstrated that this architec-
ture is ﬂexible in terms of the exact layer conﬁguration, and

Figure 8. Single-image 3D reconstruction on the ShapeNet-cars
dataset using OGN in different resolutions.

Resolution
Single-view 3D 0.641

32

64
0.771

128
0.782

256
0.766

Table 6. Single-image 3D reconstruction results on ShapeNet-cars.
Low-resolution predictions are upsampled to 2563. Commonly
used 323 models are signiﬁcantly worse than the rest.

that it provides the same accuracy as dense voxel grids in
low resolution. At the same time, it scales much better to
higher resolutions, both in terms of memory and runtime.

This architecture enables end-to-end deep learning to be
applied to tasks that appeared unfeasible before. In particu-
lar, learning tasks that involve 3D shapes, such as 3D object
and scene reconstruction, are likely to beneﬁt from it.

While in this paper we have focused on shapes and bi-
nary occupancy maps, it is straightforward to extend the
framework to multi-dimensional outputs attached to the oc-
tree structure; for example, the output of the network could
be a textured shape or a signed distance function. This will
allow for an even wider range of applications.

Acknowledgements

This work was supported by the Excellence Initiative
of the German Federal and State Governments: BIOSS
Centre for Biological Signalling Studies (EXC 294). We
would like to thank Benjamin Ummenhofer for valuable
discussions and technical comments. We also thank Niko-
laus Mayer for his help with 3D model visualization and
manuscript preparation.

References

[1] F. Bogo, J. Romero, M. Loper, and M. J. Black. FAUST:
Dataset and evaluation for 3D mesh registration. In CVPR,
2014. 11

[2] F. Calakli and G. Taubin. SSD: Smooth Signed Distance
Surface Reconstruction. Computer Graphics Forum, 2011.
2
¨O. C¸ ic¸ek, A. Abdulkadir, S. Lienkamp, T. Brox, and O. Ron-
neberger. 3d u-net: Learning dense volumetric segmentation
from sparse annotation. In MICCAI, 2016. 2

[3]

[4] A. X. Chang, T. Funkhouser, L. Guibas, P. Hanrahan,
Q. Huang, Z. Li, S. Savarese, M. Savva, S. Song, H. Su,
J. Xiao, L. Yi, and F. Yu. ShapeNet: An Information-Rich
3D Model Repository. CoRR, abs/1512.03012, 2015. 5
[5] H. Chen, Q. Dou, L. Yu, and P. Heng. Voxresnet: Deep vox-
elwise residual networks for volumetric brain segmentation.
CoRR, abs/1608.05895, 2016. 2

[6] C. B. Choy, D. Xu, J. Gwak, K. Chen, and S. Savarese. 3d-
r2n2: A uniﬁed approach for single and multi-view 3d object
reconstruction. In ECCV, 2016. 2, 5, 7, 8

[7] C. Connolly. Cumulative generation of octree models from

range data. In ICRA, 1984. 2

[8] X. Di, R. Dahyot, and M. Prasad. Deep shape from a low

number of silhouettes. In ECCV Workshops, 2016. 2

[9] A. Dosovitskiy, P. Fischer, E. Ilg, P. H¨ausser, C. Hazırbas¸,
V. Golkov, P. v.d. Smagt, D. Cremers, and T. Brox. Flownet:
Learning optical ﬂow with convolutional networks. In ICCV,
2015. 1

[10] A. Dosovitskiy, J. T. Springenberg, M. Tatarchenko, and
T. Brox. Learning to generate chairs, tables and cars with
convolutional networks. IEEE Transactions on Pattern Anal-
ysis and Machine Intelligence, 2016. 1, 6, 7

[11] H. Fan, H. Su, and L. J. Guibas. A point set generation
network for 3d object reconstruction from a single image.
CoRR, abs/1612.00603, 2016. 2

[12] S. Fuhrmann and M. Goesele. Fusion of depth maps with

multiple scales. In SIGGRAPH Asia, 2011. 2

[13] M. Gadelha, S. Maji, and R. Wang. 3d shape induction from
2d views of multiple objects. CoRR, abs/1612.05872, 2016.
2

[14] I. Gargantini. Linear octtrees for fast processing of three-
dimensional objects. Computer Graphics and Image Pro-
cessing, 20(4):365 – 374, 1982. 2

[15] R. Girdhar, D. Fouhey, M. Rodriguez, and A. Gupta. Learn-
ing a predictable and generative vector representation for ob-
jects. In ECCV, 2016. 2, 6

[16] B. Graham. Spatially-sparse convolutional neural networks.

CoRR, abs/1409.6070, 2014. 2

[17] B. Graham. Sparse 3d convolutional neural networks.

In

BMVC, 2015. 2

[18] E. Grant, P. Kohli, and M. van Gerven. Deep disentan-
gled representations for volumetric reconstruction. In ECCV
Workshops, 2016. 2

[19] Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long,
R. Girshick, S. Guadarrama, and T. Darrell. Caffe: Con-
volutional architecture for fast feature embedding. CoRR,
abs/1408.5093, 2014. 4

[20] D. Jimenez Rezende, S. M. A. Eslami, S. Mohamed,
P. Battaglia, M. Jaderberg, and N. Heess. Unsupervised
learning of 3d structure from images. In NIPS. 2016. 2
[21] J. Johnson, A. Alahi, and L. Fei-Fei. Perceptual losses for
real-time style transfer and super-resolution. In ECCV, 2016.
1

[22] M. Kazhdan, M. Bolitho, and H. Hoppe. Poisson surface

reconstruction. In SGP, 2006. 2

[23] D. P. Kingma and J. Ba. Adam: A method for stochastic

optimization. In ICLR, 2014. 5

[24] J. Masci, D. Boscaini, M. M. Bronstein, and P. Van-
dergheynst. Geodesic convolutional neural networks on rie-
mannian manifolds. In ICCV Workshops, 2015. 2

[25] D. Meagher. Octree encoding: A new technique for the rep-
resentation, manipulation and display of arbitrary 3-d objects
by computer. Technical Report IPL-TR-80-111, 1980. 2
[26] H. Noh, S. Hong, and B. Han. Learning deconvolution net-

work for semantic segmentation. In ICCV, 2015. 1

[27] C. R. Qi, H. Su, K. Mo, and L. J. Guibas. Pointnet: Deep
learning on point sets for 3d classiﬁcation and segmentation.
CoRR, abs/1612.00593, 2016. 2

[28] A. Radford, L. Metz, and S. Chintala. Unsupervised repre-
sentation learning with deep convolutional generative adver-
sarial networks. CoRR, abs/1511.06434, 2015. 1

[29] G. Riegler, A. O. Ulusoy, and A. Geiger. Octnet: Learn-
ing deep 3d representations at high resolutions. CoRR,
abs/1611.05009, 2016. 2, 6

[30] A. Sharma, O. Grau, and M. Fritz. Vconv-dae: Deep volu-
metric shape learning without object labels. In ECCV Work-
shops, 2016. 2, 6

[31] A. Sinha, J. Bai, and K. Ramani. Deep learning 3d shape

surfaces using geometry images. In ECCV, 2016. 2

[32] F. Steinbr¨ucker, J. Sturm, and D. Cremers. Volumetric 3d

mapping in real-time on a cpu. In ICRA, 2014. 2

[33] M. Tatarchenko, A. Dosovitskiy, and T. Brox. Multi-view 3d
models from single images with a convolutional network. In
ECCV, 2016. 2

[34] S. Tulsiani, H. Su, L. J. Guibas, A. A. Efros, and J. Malik.
Learning shape abstractions by assembling volumetric prim-
itives. CoRR, abs/1612.00404, 2016. 2

[35] B. Ummenhofer and T. Brox. Global, dense multiscale re-

construction for a billion points. In ICCV, 2015. 2

[36] J. Wu, C. Zhang, T. Xue, W. T. Freeman, and J. B. Tenen-
baum. Learning a probabilistic latent space of object shapes
via 3d generative-adversarial modeling. In NIPS, 2016. 2

[37] Z. Wu, S. Song, A. Khosla, F. Yu, L. Zhang, X. Tang, and
J. Xiao. 3d shapenets: A deep representation for volumetric
shapes. In CVPR, 2015. 2

[38] X. Yan, J. Yang, E. Yumer, Y. Guo, and H. Lee. Perspective
transformer nets: Learning single-view 3d object reconstruc-
tion without 3d supervision. In NIPS, 2016. 2

[39] L. Yi, H. Su, X. Guo, and L. J. Guibas. Syncspeccnn: Syn-
chronized spectral CNN for 3d shape segmentation. CoRR,
abs/1612.00606, 2016. 2

[40] M. E. Yumer and N. J. Mitra. Learning semantic deformation
ﬂows with 3d convolutional networks. In ECCV, 2016. 2

Appendix

A. Computational efﬁciency

In the main paper we have shown that with a practi-
cal architecture our networks scale much better than their
dense counterparts both in terms of memory consumption
and computation time. The numbers were obtained for the
”houses” scene from the BlendSwap dataset.

OGN
Quadratic
Dense
Cubic

OGN
Quadratic
Dense
Cubic

B
G

,
e
g
a
s
u
y
r
o
m
e
m
k
a
e
P

10

1

0.1

0.01

s

,
e
m

i
t

n
o
i
t
a
r
e
t
I

10

1

0.1

0.01

representation. The architectures of those networks are sim-
ilar to those from Table 13, but with only 1 channel in ev-
ery convolutional layer, and a single fully-connected layer
with 64 units in the encoder. The resulting measurements
are shown in Figure 9 for memory consumption and Fig-
ure 10 for runtime. To precisely quantify the scaling, we
subtracted the constant amount of memory reserved on a
GPU by caffe (190 MB) from all numbers.

Both plots are displayed in the log-log scale, i.e., func-
tions from the family y = axk are straight lines. The
slope of this line is determined by the exponent k, and the
vertical shift by the coefﬁcient a.
In this experiment we
are mainly interested in the slope, that is, how do the ap-
proaches scale with increasing output resolution. As a refer-
ence, we show dashed lines corresponding to perfect cubic
and perfect quadratic scaling.

Starting from 643 voxel resolution both the runtime and
the memory consumption scale almost cubically in case of
dense networks. For this particular example, OGN scales
even better than quadratically, but in general scaling of the
octree-based representation depends on the speciﬁc data it
is applied to.

In Section 4.4 of the main paper, we described how
we use the two propagation modes (Prop-known and Prop-
pred) during training and testing. Here we motivate the pro-
posed regimes, and show additional results with other com-
binations of propagation modes.

When the structure of the output tree is not known at test
time, we train the networks until convergence with Prop-
known, and then additionally ﬁne-tune with Prop-pred - line
4 in Table 7. Without this ﬁne-tuning step (line 2), there is
a decrease in performance, which is more signiﬁcant when
using larger convolutional ﬁlters. Intuitively, this happens
because the network has never seen erroneous propagations
during training, and does not now how to deal with them at
test time.

When the structure of the output is known at test time,
the best strategy is to simply train in Prop-known, and test
the same way (line 1). Additional ﬁne-tuning in the Prop-
pred mode slightly hurts performance in this case (line 3).
The overall conclusion is not surprising: the best results are
obtained when training networks in the same propagation
modes, in which they are later tested.

32

64

256

512

128
Resolution

B. Train/test modes

Figure 9. Memory consumption for very slim networks, forward
and backward pass, batch size 1. Shown in log-log scale - lines
with smaller slope correspond to better scaling.

32

64

256

512

128
Resolution

Figure 10. Iteration time for very slim networks, forward and back-
ward pass, batch size 1. Shown in log-log scale - lines with smaller
slope correspond to better scaling.

In order to further study this matter, we have designed
a set of slim decoder networks that ﬁt on a GPU in every
resolution, including 5123, both with an OGN and a dense

C. Feature propagation

In the main paper we mentioned that the number of fea-
tures propagated by an OGNProp layer depends on the sizes
of the convolutional ﬁlters in all subsequent blocks. In case
of 23 up-convolutions with stride 2, which were used in
most of our experiments, no neighboring features need to

(A)

up-conv
ﬁlter: 2
stride: 2

(B)

up-conv
ﬁlter: 4
stride: 2

Training Testing
Known
Known
Pred
Known
Known
Pred
Pred
Pred

23 ﬁlters
0.904
0.862
0.898
0.884

43 ﬁlters
0.907
0.804
0.896
0.885

IntConv
0.907
0.823
0.897
0.885

Table 7. Reconstruction quality for autoencoders with different de-
coder architectures: 23 up-convolutions, 43 up-convolutions, and
23 up-convolutions interleaved with 33 convolutions, using dif-
ferent conﬁgurations of Prop-known and Prop-pred propagation
modes.

be propagated. This situation is illustrated in Figure 11-A
in a one-dimensional case. Circles correspond to cells of
an octree. The green cell in the input is the only one for
which the value was predicted to be ”mixed”. Links be-
tween the circles indicate which features of the input are
required to compute the result of the operation (convolution
or up-convolution) for the corresponding output cell. In this
case, we can see that the output cells in the next level are
only affected by their parent cell from the previous level.

A more general situation is shown in Figure 11-B. The
input is processed with an up-convolutional layer with 43
ﬁlters and stride 2, which is followed by a convolutional
layer with 33 ﬁlters and stride 1. Again, only one cell was
predicted to be ”mixed”, but in order to perform convolu-
tions and up-convolutions in subsequent layers, we addi-
tionally must propagate some of its neighbors (marked red).
Therefore, with this particular ﬁlter conﬁguration, two cells
in the output are affected by four cells in the input.

Generally, the number of features that should be prop-
agated by each OGNProp layer is automatically calculated
based on the network architecture before starting the train-
ing.

D. 3D shape from high-level information: ad-

ditional experiments

D.1. MPI-FAUST

To additionally showcase the beneﬁt of using higher res-
olutions, we trained OGNs to ﬁt the MPI-FAUST dataset
[1]. It contains 300 high-resolution scans of human bodies
of 10 different people in 30 different poses. Same as with
the BlendSwap, the trained networks cannot generalize to
new samples due to the low amount of training data.

Figure 12 and Table 8 demonstrate qualitative and quan-
titative results respectively. Human models from MPI-
FAUST include ﬁner details than cars from ShapeNet, and
therefore beneﬁt from the higher resolution.

D.2. Fitting reduced ShapeNet-cars

To better understand the performance drop at 2563 res-
olution observed in section 5.4.1 of the main paper, we

conv
ﬁlter: 3
stride: 1

mixed

propagated
neighbors

ﬁlled/empty

zero-padding

Figure 11. The OGNProp layer propagates the features of ”mixed”
cells together with the features of the neighboring cells required
for computations in subsequent layers. We show the number
of neighbors that need to be propagated in two cases: 23 up-
convolutions (A), and 43 up-convolutions followed by 33 convo-
lutions (B). Visualized in 1D for simplicity.

643

1283

2563

GT 2563

Figure 12. Training samples from the FAUST dataset recon-
structed by OGN.

performed an additional experiment on the ShapeNet-Cars
dataset. We trained an OGN for generating car shapes from
their IDs on a reduced version of ShapeNet-Cars, including

64
0.890

128
0.933

256
0.969

Table 8. 3D shape from high-level information on the FAUST
dataset. Lower-resolution predictions were upsampled to 2563
ground truth.

Dataset
Shapenet-cars (full)
Shapenet-cars (subset)

1283
0.901
0.922

2563
0.865
0.931

Table 9. There is no drop in performance in higher resolution,
when training on a subset of the Shapenet-cars dataset.

Full

Subset

GT 2563

1283

2563

1283

2563

Figure 13. When training on a subset of the Shapenet-cars datset,
higher resolution models contain more details.

just 500 ﬁrst models from the dataset. Quantitative results
for different resolutions, along with the results for the full
dataset, are shown in Table 9. Interestingly, when training
on the reduced dataset, high resolution is beneﬁcial. This is
further supported by examples shown in Figure 13 – when
training on the reduced dataset, the higher-resolution model
contain more ﬁne details. Overall, these results support our
hypothesis that the performance drop at higher resolution is
not due to the OGN architecture, but due to the difﬁculty of
ﬁtting a large dataset at high resolution.

E. Shift invariance

The convolution operation on a voxel grid is perfectly
shift invariant by design. This is no longer true for convo-
lutions on octrees: a shift by a single pixel in the original
voxel grid can change the structure of the octree signiﬁ-
cantly. To study the effect of shifts, we trained two fully
convolutional autoencoders - one with an OGN decoder,
and one with a dense decoder - on 643 models, with low-
est feature map resolution 43 (so the networks should be

perfectly invariant to shifts of 16 voxels). Both were trained
on non-shifted Shapenet-Cars, and tested in the Prop-pred
mode on models shifted by a different number of voxels
along the z-axis. The results are summarized in Table 10.

Shift (voxels) OGN Dense
0.932
0.93
0.925
0.915
0.904

0.935
0.933
0.929
0.917
0.906

0
1
2
4
8

Table 10. Fully-convolutional networks tested on shifted data.
Even though not shift invariant by design, OGN shows robust per-
formance.

There is no signiﬁcant difference between OGN and the
dense network. A likely reason is that different training
models have different octree structures, which acts as an
implicit regularizer. The network learns the shape, but re-
mains robust to the exact octree structure.

F. Network architectures

In this section, we provide the exact network architec-

tures used in the experimental evaluations.

F.1. Autoencoders

The architectures of OGN autoencoders are summarized
in Table 12. For the dense baselines, we used the same layer
conﬁgurations with usual convolutions instead of OGN-
Conv, and predictions being made only after the last layer
of the network. All networks were trained with batch size
16.

F.2. 3D shape from high-level information

OGN decoders used on the Shapenet-cars dataset are
shown in Table 13. Encoders consisted of three fully-
connected layers, with output size of the last encoder layer
being identical to the input size of the corresponding de-
coder.

For FAUST and BlendSwap the 2563 output octrees had
four levels, not ﬁve like those in Table 13. Thus, the
dense block had an additional deconvolution-convolution
layer pair instead of one octree block. The 5123 decoder
on BlendSwap had one extra octree block with 32 output
channels.

All 643 and 1283 networks were trained with batch size

16, 2563 — with batch size 4, 5123 — with batch size 1.

F.3. Single-image 3D reconstruction

In this experiment we again used decoder architectures
shown in Table 13. The architecture of the convolutional
encoder is shown in Table 11. The number of channels in

the last encoder layer was set identical to the number of
input channels of the corresponding decoder.

[137 × 137 × 3]
Conv (7 × 7)
[69 × 69 × 32]
Conv (3 × 3)
[35 × 35 × 32]
Conv (3 × 3)
[18 × 18 × 64]
Conv (3 × 3)
[9 × 9 × 64]
Conv (3 × 3)
[5 × 5 × 128]
FC
[1024]
FC
[1024]
FC
[43 × c]

Table 11. Convolutional encoder used in the single-image 3D re-
construction experiment.

323

643 (23 ﬁlters)

643 (InvConv)

[323 × 1]
Conv (33)
[163 × 32]
Conv (33)
[83 × 48]
Conv (33)
[43 × 64]
FC
[1024]
FC
[1024]
FC
[43 × 80]
Deconv (23)
[83 × 64]
Conv (33)→ l1
[83 × 64]
OGNProp
OGNConv(23) → l2
[163 × 48]
OGNProp
OGNConv(23) → l3
[323 × 32]

643 (43 ﬁlters)
[643 × 1]
Conv (33)
[323 × 32]
Conv (33)
[163 × 48]
Conv (33)
[83 × 64]
Conv (33)
[43 × 80]
FC
[1024]
FC
[1024]
FC
[43 × 96]
Deconv (23)
[83 × 80]
Conv (33)
[83 × 80]

Deconv (23)
[163 × 64]

Conv (33)→ l1
[163 × 64]
OGNProp

[323 × 48]

OGNConv(23) → l2 OGNConv(43) → l2

OGNProp

[323 × 48]

OGNProp

OGNProp

OGNConv(23) → l3 OGNConv(43) → l3

[643 × 32]

[643 × 32]

OGNProp
OGNConv(23)
[323 × 48]
OGNConv*(33) → l2
[323 × 48]
OGNProp
OGNConv(23)
[643 × 32]
OGNConv*(33) → l3
[643 × 32]

Table 12. OGN architectures used in our experiments with autoencoders. OGNConv denotes up-convolution, OGNConv* — convolution.
Layer name followed by ’→ lk’ indicates that level k of an octree is predicted by a classiﬁer attached to this layer.

323
[43 × 80]
Deconv (23)
[83 × 64]
Conv (33) → l1
[83 × 64]
OGNProp
OGNConv (23) → l2
[163 × 48]
OGNProp
OGNConv (23) → l3
[323 × 32]

643
[43 × 96]
Deconv (23)
[83 × 80]
Conv (33)
[83 × 80]

Deconv (23)
[163 × 64]

1283
[43 × 112]
Deconv (23)
[83 × 96]
Conv (33)
[83 × 96]

Deconv (23)
[163 × 80]

2563
[43 × 112]
Deconv (23)
[83 × 96]
Conv (33)
[83 × 96]

Deconv (23)
[163 × 80]

Conv (33) → l1
[163 × 80]
OGNProp

Conv (33) → l1
[163 × 64]
OGNProp

Conv (33) → l1
[163 × 80]
OGNProp
OGNConv (23) → l2 OGNConv (23) → l2 OGNConv (23) → l2
[323 × 64]
OGNProp
OGNConv (23) → l3 OGNConv (23) → l3 OGNConv (23) → l3
[643 × 48]
OGNProp

[323 × 64]
OGNProp

[643 × 48]
OGNProp

[323 × 48]
OGNProp

[643 × 32]

OGNConv (23) → l4 OGNConv (23) → l4

[1283 × 32]

[1283 × 32]
OGNProp
OGNConv (23) → l5
[2563 × 32]

Table 13. OGN decoder architectures used in shape from ID, and single-image 3D reconstruction experiments.

Octree Generating Networks:
Efﬁcient Convolutional Architectures for High-resolution 3D Outputs

Maxim Tatarchenko1
tatarchm@cs.uni-freiburg.de

Alexey Dosovitskiy1,2
adosovitskiy@gmail.com

Thomas Brox1
brox@cs.uni-freiburg.de

1University of Freiburg

2Intel Labs

7
1
0
2
 
g
u
A
 
7
 
 
]

V
C
.
s
c
[
 
 
3
v
8
3
4
9
0
.
3
0
7
1
:
v
i
X
r
a

Abstract

We present a deep convolutional decoder architecture
that can generate volumetric 3D outputs in a compute- and
memory-efﬁcient manner by using an octree representation.
The network learns to predict both the structure of the oc-
tree, and the occupancy values of individual cells. This
makes it a particularly valuable technique for generating
3D shapes. In contrast to standard decoders acting on reg-
ular voxel grids, the architecture does not have cubic com-
plexity. This allows representing much higher resolution
outputs with a limited memory budget. We demonstrate this
in several application domains, including 3D convolutional
autoencoders, generation of objects and whole scenes from
high-level representations, and shape from a single image.

1. Introduction

Up-convolutional1 decoder architectures have become
a standard tool for tasks requiring image generation [10,
28, 21] or per-pixel prediction [26, 9]. They consist of
a series of convolutional and up-convolutional (upsam-
pling+convolution) layers operating on regular grids, with
resolution gradually increasing towards the output of the
network. The architecture is trivially generalized to volu-
metric data. However, because of cubic scaling of computa-
tional and memory requirements, training up-convolutional
decoders becomes infeasible for high-resolution three-
dimensional outputs.

Poor scaling can be resolved by exploiting structure in
the data. In many learning tasks, neighboring voxels on a
voxel grid share the same state — for instance, if the voxel
grid represents a binary occupancy map or a multi-class
labeling of a three-dimensional object or a scene. In this
case, data can be efﬁciently represented with octrees — data
structures with adaptive cell size. Large regions of space
sharing the same value can be represented with a single

1Also known as deconvolutional

dense

Octree
level 1

Octree
level 2

Octree
level 3

323

643

1283

Figure 1. The proposed OGN represents its volumetric output as an
octree. Initially estimated rough low-resolution structure is gradu-
ally reﬁned to a desired high resolution. At each level only a sparse
set of spatial locations is predicted. This representation is signiﬁ-
cantly more efﬁcient than a dense voxel grid and allows generating
volumes as large as 5123 voxels on a modern GPU in a single for-
ward pass.

large cell of an octree, resulting in savings in computation
and memory compared to a ﬁne regular grid. At the same
time, ﬁne details are not lost and can still be represented by
small cells of the octree.

We present an octree generating network (OGN) - a con-
volutional decoder operating on octrees. The coarse struc-
ture of the network is illustrated in Figure 1. Similar to a
usual up-convolutional decoder, the representation is grad-
ually convolved with learned ﬁlters and up-sampled. The
difference is that, starting from a certain layer in the net-
work, dense regular grids are replaced by octrees. There-
fore, the OGN predicts large uniform regions of the output
space already at early decoding stages, saving the computa-
tion for the subsequent high-resolution layers. Only regions
containing ﬁne details are processed by these more compu-
tationally demanding layers.

In this paper, we focus on generating shapes represented
as binary occupancy maps. We thoroughly compare OGNs
to standard dense nets on three tasks: auto-encoding shapes,
generating shapes from a high-level description, and recon-
structing 3D objects from single images. OGNs yield the
same accuracy as conventional dense decoders while con-
suming signiﬁcantly less memory and being much faster at

high resolutions. For the ﬁrst time, we can generate shapes
of resolution as large as 5123 voxels in a single forward
pass. Our OGN implementation is publicly available2.

2. Related work

The majority of deep learning approaches generate vol-
umetric data based on convolutional networks with fea-
ture maps and outputs represented as voxel grids. Appli-
cations include single- and multi-view 3D object recon-
struction trained in supervised [15, 6, 8, 18] and unsuper-
vised [38, 13, 20] ways, probabilistic generative modeling
of 3D shapes [37, 36, 30], semantic segmentation [3, 5]
and shape deformation [40]. A fundamental limitation of
these approaches is the low resolution of the output. Mem-
ory and computational requirements of approaches based on
the voxel grid representation scale cubically with the out-
put size. Thus, training networks with resolutions higher
than 643 comes with memory issues on the GPU or re-
quires other measures to save memory, such as reducing
the batch size or generating the volume part-by-part. More-
over, with growing resolution, training times become pro-
hibitively slow.

Computational limitations of the voxel grid representa-
tion led to research on alternative representations of volu-
metric data in deep learning. Tatarchenko et al. [33] pre-
dict RGB images and depth maps for multiple views of
an object, and fuse those into a single 3D model. This
approach is not trainable end to end because of the post-
processing fusion step, and is not applicable to objects with
strong self-occlusion. Sinha et al. [31] convert shapes into
two-dimensional geometry images and process those with
conventional CNNs – an approach only applicable to cer-
tain classes of topologies. Networks producing point clouds
have been applied to object generation [11] and semantic
segmentation [27]. By now, these architectures have been
demonstrated to generate relatively low-resolution outputs.
Scaling these networks to higher resolution is yet to be ex-
plored. Tulsiani et al. [34] assemble objects from volumet-
ric primitives. Yi et al. [39] adapt the idea of graph convolu-
tions in the spectral domain to semantic segmentation of 3D
shapes. Their approach requires all samples to have aligned
eigenbasis functions, thus limiting possible application do-
mains.

Promising alternative representations that are not di-
rectly applicable to generating 3D outputs have been ex-
plored on analysis tasks. Masci et al. [24] proposed
geodesic CNNs for extracting local
features in non-
Euclidean domains. Our approach is largely inspired by
Graham’s sparse convolutional networks [16, 17], which
enable efﬁcient shape analysis by storing a sparse set of
non-trivial features instead of dense feature maps. The

OGN essentially solves the inverse problem by predict-
ing which regions of the output contain high-resolution in-
formation and by restricting extensive calculations only to
those regions.

The recent pre-print by Riegler et al. [29] builds on the
same general idea as our work: designing convolutional net-
works that operate on octrees instead of voxel grids. How-
ever, the implementation and the application range of the
method is very different from our work. When generating
an octree, Riegler et al. assume the octree structure to be
known at test time. This is the case, for example, in seman-
tic segmentation, where the structure of the output octree
can be set to be identical to that of the input. However, in
many important scenarios — any kind of 3D reconstruc-
tion, shape modeling, RGB-D fusion, superresolution —
the structure of the octree is not known in advance and must
be predicted. The method of Riegler et al. is not applicable
in these cases. Moreover, the OGN is more ﬂexible in that
it allows for octrees with an arbitrary number of levels.

3. Octrees

An octree [25] is a 3D grid structure with adaptive cell
size, which allows for lossless reduction of memory con-
sumption compared to a regular voxel grid. Octrees have a
long history in classical 3D reconstruction and depth map
fusion [22, 2, 12, 35, 7, 32]. A function deﬁned on a voxel
grid can be converted into a function deﬁned on an octree.
This can be done by starting from a single cell representing
the entire space and recursively partitioning cells into eight
octants. If every voxel within a cell has the same function
value, this cell is not subdivided and becomes a leaf of the
tree. The set of cells at a certain resolution is referred to as
an octree level. The recursive subdivision process can also
be started not from the whole volume, but from some initial
coarse resolution. Then the maximal octree cell size is given
by this initial resolution. The most straightforward way of
implementing an octree is to store in each cell pointers to its
children. In this case, the time to access an element scales
linearly with the tree’s depth, which can become costly at
high resolutions. We use a more efﬁcient implementation
that exploits hash tables. An octree cell with spatial coordi-
nates x = (x, y, z) at level l is represented as an index-value
pair (m, v), where v can be any kind of discrete or continu-
ous signal. m is calculated from (x, l) using Z-order curves
[14]

m = Z(x, l),

which is a computationally cheap transformation imple-
mented using bit shifts. An octree O is, hence, a set of all
pairs

(1)

(2)

2https://github.com/lmb-freiburg/ogn

O = {(m, v)}.

Fl−1

¯Fl

Fl

...

d1

OGNConv
...
(one or more)

OGNProp

...

c

d2

13
conv

OGNLoss

propagated features

empty

ﬁlled

mixed

Ground truth

Prediction

Figure 2. Single block of an OGN illustrated as 2D quadtree for simplicity. After convolving features Fl−1 of the previous block with
weight ﬁlters, we directly predict the occupancy values of cells at level l using 13 convolutions. Features corresponding to ”ﬁlled” and
”empty” cells are no longer needed and thus not propagated, which yields Fl as the ﬁnal output of this block.

Storing this set as a hash table allows for constant-time ele-
ment access.

When training networks, we will need to compare two
different octrees O1 and O2, i.e. for each cell (x, l) from
O1, query the corresponding signal value v in O2. Since
different octrees have different structure, two situations are
possible. If Z(x, k) is stored at a level k in O2, which is
the same or lower than l, the signal value of this cell can
be uniquely determined. If Z(x, k) is stored at one of the
later levels, the cell is subdivided in O2, and the value of the
whole cell is not deﬁned. To formalize this, we introduce a
function f for querying the signal value of an arbitrary cell
with index m = Z(x, l) from octree O:

(cid:26) v, if ∃k ≤ l : (Z(x, k), v) ∈ O

f (m, O) =

∅, otherwise

,

(3)

where ∅ denotes an unavailable value.

4. Octree Generating Networks

An Octree Generating Network (OGN) is a convolu-
tional decoder that yields an octree as output: both the
structure, i.e. which cells should be subdivided, and the
signal value of each cell. In this work we concentrate on bi-
nary occupancy values v ∈ {0, 1}, but the proposed frame-
work can be easily extended to support arbitrary signals. As
shown in Figure 1, an OGN consists of a block operating
on dense regular grids, followed by an arbitrary number of
hash-table-based octree blocks.

The dense block is a set of conventional 3D convolu-
tional and up-convolutional layers producing a feature map
of size d1 × d2 × d3 × c as output, where {di} are the spatial
dimension and c is the number of channels.

From here on, the representation is processed by our cus-
tom layers operating on octrees. The regular-grid-based fea-
ture map produced by the dense block is converted to a set
of index-value pairs stored as a hash table (with values be-
ing feature vectors), and is further processed in this format.
We organize octree-based layers in blocks, each responsible
for predicting the structure and the content of a single level
of the generated octree.

Figure 2 illustrates the functioning of a single such block
that predicts level l of an octree. For the sake of illustration,
we replaced three-dimensional octrees by two-dimensional
quadtrees. Feature maps in Figure 2 are shown as dense ar-
rays only for simplicity; in fact the green cells are stored in
hash maps, and the white cells are not stored at all. We now
give a high-level overview of the block and then describe its
components in more detail.

Input to the block is a sparse hash-table-based convolu-
tional feature map Fl−1 of resolution (d1·2l−1, d2·2l−1, d3·
2l−1) produced by the previous block. First this feature map
is processed with a series of custom convolutional layers
and one up-convolutional layer with stride 2, all followed
by non-linearities.

This yields a new feature map ¯Fl of resolution (d1·2l, d2·
2l, d3 · 2l). Based on this feature map, we directly predict
the content of level l. For each cell, there is a two-fold
decision to be made: should it be kept at level l, and if yes,

what should be the signal value in this cell? In our case
making this decision can be formulated as classifying the
cell as being in one of three states: ”empty”, ”ﬁlled” or
”mixed”. These states correspond to the outputs of state-
querying function f from eq. (3), with ”empty” and ”ﬁlled”
being the signal values v, and ”mixed” being the state where
the value is not determined. We make this prediction using a
convolutional layer with 13 ﬁlters followed by a three-way
softmax. This classiﬁer is trained in a supervised manner
with targets provided by the ground truth octree.

Finally,

in case the output resolution has not been
reached, features from ¯Fl that correspond to ”mixed” cells
are propagated to the next layer3 and serve as an input fea-
ture map Fl to the next block.

In the following subsections, we describe the compo-
nents of a single octree block in more detail:
the octree-
based convolution, the loss function, and the feature propa-
gation mechanism.

4.1. Convolution

We implemented a custom convolutional layer OGN-
Conv, which operates on feature maps represented as hash
tables instead of usual dense arrays. Our implementation
supports strided convolutions and up-convolutions with ar-
bitrary ﬁlter sizes. It is based on representing convolution as
a single matrix multiplication, similar to standard caffe [19]
code for dense convolutions.

In the dense case, the feature tensor is converted to a
matrix with the im2col operation, then multiplied with the
weight matrix of the layer, and the result is converted back
into a dense feature tensor using the col2im operation. In
OGN, instead of storing full dense feature tensors, only a
sparse set of relevant features is stored at each layer. These
features are stored in a hash table, and we implemented
custom operations to convert a hash table to a feature ma-
trix and back. The resulting matrices are much smaller
than those in the dense case. Convolution then amounts to
multiplying the feature matrix by the weight matrix. Ma-
trix multiplication is executed on GPU with standard opti-
mized functions, and our conversion routines currently run
on CPU. Even with this suboptimal CPU implementation,
computation times are comparable to those of usual dense
convolutions at 323 voxel resolution. At higher resolutions,
OGNConv is much faster than dense convolutions (see sec-
tion 5.2).

Unlike convolutions on regular grids, OGN convolutions
are not shift invariant by design. This is studied in Section
E of the Appendix.

3Additional neighboring cells may have to be propagated if needed by

subsequent convolutional layers. This is described in section 4.3.

4.2. Loss

The classiﬁer at level l of the octree outputs the proba-
bilities of each cell from this level being ”empty”, ”ﬁlled”
or ”mixed”, that is, a three-component prediction vector
pm = (p0
m) for cell with index m. We minimize
the cross-entropy between the network predictions and the
cell states of the ground truth octree OGT , averaged over
the set Ml of cells predicted at layer l:

m, p1

m, p2

Ll =

1
|Ml|

(cid:34) 2

(cid:88)

(cid:88)

m∈Ml

i=0

hi(f (m, OGT )) log pi
m

,

(4)

(cid:35)

where function h yields a one-hot encoding (h0, h1, h2) of
the cell state value returned by f from eq. (3). Loss compu-
tations are encapsulated in our custom OGNLoss layer.

The ﬁnal OGN objective is calculated as a sum of loss

values from all octree levels

L =

Ll.

L
(cid:88)

l=1

(5)

4.3. Feature propagation

At the end of each octree block there is an OGNProp
layer that propagates to the next octree block features from
cells in the ”mixed” state, as well as from neighboring cells
if needed to compute subsequent convolutions. Information
about the cell state can either be taken from the ground truth
octree, or from the network prediction. This spawns two
possible propagation modes: using the known tree structure
(Prop-known) and using the predicted tree structure (Prop-
pred). Section 4.4 describes use cases for these two modes.
The set of features to be propagated depends on the
kernel size in subsequent OGNConv layers. The example
illustrated in Figure 2 only holds for 23 up-convolutions
which do not require any neighboring elements to be com-
puted. To use larger convolutional ﬁlters or multiple convo-
lutional layers, we must propagate not only the features of
the ”mixed” cells, but also the features of the neighboring
cells required for computing the convolution at the locations
of the ”mixed” cells. The size of the required neighborhood
is computed based on the network architecture, before the
training starts. Details are provided in Section C of the Ap-
pendix.

4.4. Training and testing

The OGN decoder is end-to-end trainable using stan-
dard backpropagation. The only subtlety is in selecting the
feature propagation modes during training and testing. At
training time the octree structure of the training samples is
always available, and therefore the Prop-known mode can
be used. At test time, the octree structure may or may not

be available. We have developed two training regimes for
these two cases.

If the tree structure is available at test time, we simply
train the network with Prop-known and test it the same way.
This regime is applicable for tasks like semantic segmenta-
tion, or, more generally, per-voxel prediction tasks, where
the structure of the output is exactly the same as the struc-
ture of the input.

If the tree structure is not available at test time, we start
by training the network with Prop-known, and then ﬁne-
tune it with Prop-pred. This regime is applicable to any
task with volumetric output.

We have also tested other regimes of combining Prop-
pred and Prop-known and found those to perform worse
than the two described variants. This is discussed in more
detail in Section B of the Appendix.

5. Experiments

In our experiments we veriﬁed that the OGN architec-
ture performs on par with the standard dense voxel grid rep-
resentation, while requiring signiﬁcantly less memory and
computation, particularly at high resolutions. The focus of
the experiments is on showcasing the capabilities of the pro-
posed architecture. How to fully exploit the new architec-
ture in practical applications is a separate problem that is
left to future work.

5.1. Experimental setup

For all OGN decoders used in our evaluations, we fol-
lowed the same design pattern: 1 or 2 up-convolutional lay-
ers interleaved with a convolutional layer in the dense block,
followed by multiple octree blocks depending on the output
resolution. In the octree blocks we used 23 up-convolutions.
We also evaluated two other architecture variants, presented
in section 5.3.1. ReLU non-linearities were applied after
each (up-)convolutional layer. The number of channels in
the up-convolutional layers of the octree blocks was set to
32 in the outermost layer, and was increased by 16 in each
preceding octree block. The exact network architectures
used in individual experiments are shown in Section F of
the Appendix.

The networks were trained using ADAM [23] with ini-
tial learning rate 0.001, β1 = 0.9, β2 = 0.999. The learning
rate was decreased by a factor of 10 after 30K and 70K it-
erations. We did not apply any additional regularization.

For quantitative evaluations, we converted the resulting
octrees back to regular voxel grids, and computed the In-
tersection over Union (IoU) measure between the ground
truth model and the predicted model. To quantify the im-
portance of high-resolution representations, in some exper-
iments we upsampled low-resolution network predictions
to high-resolution ground truth using trilinear interpolation,
and later binarization with a threshold of 0.5. We explicitly

specify the ground truth resolution in all experiments where
this was done.

If not indicated otherwise, the results were obtained in

the Prop-pred mode.

5.1.1 Datasets

In our evaluations we used three datasets:

ShapeNet-all Approximately 50.000 CAD models from
13 main categories of the ShapeNet dataset [4], used by
Choy et al. [6]. We also used the renderings provided by
Choy et al. [6].

ShapeNet-cars A subset of ShapeNet-all consisting of

7497 car models.

BlendSwap A dataset of 4 scenes we manually collected
from blendswap.com, a website containing a large col-
lection of Blender models.

All datasets were voxelized in multiple resolutions from
323 to 5123 using the binvox4 tool, and were converted into
octrees. We set the interior parts of individual objects to be
ﬁlled, and the exterior to be empty.

5.2. Computational efﬁciency

We start by empirically demonstrating that OGNs can be
used at high resolutions when the voxel grid representation
becomes impractical both because of the memory require-
ments and the runtime.

The number of elements in a voxel grid is uniquely de-
termined by its resolution, and scales cubically as the latter
increases. The number of elements in an octree depends
on the data, leading to variable scaling rates: from con-
stant for cubic objects aligned with the grid, to cubic for
pathological shapes such as a three-dimensional checker-
board. In practice, octrees corresponding to real-world ob-
jects and scenes scale approximately quadratically, since
they represent smooth two-dimensional surfaces in a three-
dimensional space.

Memory, GB

Iteration time, s

OGN
Dense

OGN
Dense

80

60

40

20

0

40

20

0

32 128

256

512

32 128

256

512

Figure 3. Memory consumption (left) and iteration time (right) of
OGN and a dense network at different output resolutions. Forward
and backward pass, batch size 1.

4http://www.patrickmin.com/binvox

Memory, GB

Iteration time, s
Resolution Dense OGN Dense OGN
0.016
0.06
0.18
0.64
2.06

0.33
0.50
1.62
9.98
(74.28)

0.015
0.19
0.56
3.89
(41.3)

323
643
1283
2563
5123

0.29
0.36
0.43
0.54
0.88

Table 1. Memory consumption and iteration time of OGN and a
dense network at different output resolutions. Batch size 1.

We empirically compare the runtime and memory con-
sumption values for a dense network and OGN, for vary-
ing output resolution. Architectures of the networks are
the same as used in Section 5.4 – three fully connected
layers followed by an up-convolutional decoder. We per-
formed the measurements on an NVidia TitanX Maxwell
GPU, with 12Gb of memory. To provide actual measure-
ments for dense networks at the largest possible resolution,
we performed the comparison with batch size 1. The 5123
dense network does not ﬁt into memory even with batch size
1, so we extrapolated the numbers by ﬁtting cubic curves.

Figure 3 and Table 1 show the results of the comparison.
The OGN is roughly as efﬁcient as its dense counterpart for
low resolutions, but as the resolution grows, it gets drasti-
cally faster and consumes far less memory. At 5123 voxel
resolution, the OGN consumes almost two orders of mag-
nitude less memory and runs 20 times faster. In Section A
of the Appendix we provide a more detailed analysis and
explicitly demonstrate the near-cubic scaling of dense net-
works against the near-quadratic scaling of OGNs.

To put these numbers into perspective, training OGN at
2563 voxel output resolution takes approximately 5 days.
Estimated training time of its dense counterpart would be al-
most a month. Even if the 5123 voxel dense network would
ﬁt into memory, it would take many months to train.

5.3. Autoencoders

Autoencoders and their variants are commonly used for
representation learning from volumetric data
[15, 30].
Therefore, we start by comparing the representational
power of the OGN to that of dense voxel grid networks on
the task of auto-encoding volumetric shapes.

We used the decoder architecture described in section 5.1
both for the OGN and the dense baseline. The architecture
of the encoder is symmetric to the decoder. Both encoders
operate on a dense voxel grid representation5.

We trained the autoencoders on the ShapeNet-cars
dataset in two resolutions: 323 and 643. We used 80% of the
data for training, and 20% for testing. Quantitative results

5In this paper, we focus on generating 3D shapes. Thus, we have not
implemented an octree-based convolutional encoder. This could be done
along the lines of Riegler et al. [29]

are summarized in Table 2. With predicted octree structure,
there is no signiﬁcant difference in performance between
the OGN and the dense baseline.

Network
Dense
OGN+Prop-known
OGN+Prop-pred

323
0.924
0.939
0.924

643
0.890
0.904
0.884

Table 2. Quantitative results for OGN and dense autoencoders.
Predictions were compared with the ground truth at the corre-
sponding resolution, without upsampling.

5.3.1 Flexibility of architecture choice

To show that OGNs are not limited to up-convolutional lay-
ers with 23 ﬁlters, we evaluated two alternative 643 OGN
auto-encoders: one with 43 up-convolutions and one with
23 up-convolutions interleaved with 33 convolutions. The
results are summarized in Table 7. There is no signiﬁ-
cant difference between the architectures for this task. With
larger ﬁlters, the network is roughly twice slower in our cur-
rent implementation, so we used 23 ﬁlters in all further ex-
periments.

5.3.2 Using known structure

Interestingly, OGN with known tree structure outperforms
the network based on a dense voxel grid, both qualitatively
and quantitatively. An example of this effect can be seen in
Figure 4: the dense autoencoder and our autoencoder with
predicted propagation struggle with properly reconstructing
the spoiler of the car. Intuitively, the known tree structure
provides additional shape information to the decoder, thus
simplifying the learning problem. In the autoencoder sce-
nario, however, this may be undesirable if one aims to en-
code all information about a shape in a latent vector. In tasks
like semantic segmentation, the input octree structure could
help introduce shape features implicitly in the learning task.

5.4. 3D shape from high-level information

We trained multiple OGNs for generating shapes from
high-level parameters similar to Dosovitskiy et al. [10]. In
all cases the input of the network is a one-hot encoded ob-
ject ID, and the output is an octree with the object shape.

Mode
OGN+Prop-known
OGN+Prop-pred

2x2 ﬁlters
0.904
0.884

4x4 ﬁlters
0.907
0.885

IntConv
0.907
0.885

Table 3. Using more complex architectures in 643 OGN autoen-
coders does not lead to signiﬁcant performance improvements.

Dense

OGN+Prop-pred OGN+Prop-known

GT

tween pairs of one-hot input ID vectors. Figure 6 shows that
for all intermediate input values the network produces con-
sistent output cars, with the style being smoothly changed
between the two training points.

Figure 4. Using the known tree structure at test time leads to im-
proved performance.

ShapeNet-cars
BlendSwap

64
0.856
0.535

128
0.901
0.649

256
0.865
0.880

512
-
0.969

Table 4. Quantitative evaluation of 3D shapes generated from high-
level information. Lower-resolution predictions from ShapeNet-
cars were upsampled to 2563 ground truth,
scenes from
BlendSwap — to 5123.

643

1283

2563

GT 2563

643

1283

2563

Figure 6. Our networks can generate previously unseen cars by
interpolating between the dataset points, which demonstrates their
generalization capabilities.

5.4.2 BlendSwap

To additionally showcase the beneﬁt of using higher reso-
lutions, we trained OGNs to ﬁt the BlendSwap dataset con-
taining 4 whole scenes.
In contrast to the ShapeNet-cars
dataset, such amount of training data does not allow for any
generalization. The experiment aims to show that OGNs
provide sufﬁcient resolution to represent such high-ﬁdelity
shape data.

Figure 7 shows the generated scenes. In both examples,
643 and 1283 resolutions are inadequate for representing the
details. For the bottom scene, even the 2563 resolution still
struggles with ﬁne-grained details. This example demon-
strates that tasks like end-to-end learning of scene recon-
struction requires high-resolution representations, and the
OGN is an architecture that can provide such resolutions.

These qualitative observations are conﬁrmed quantita-
tively in Table 4. Higher output resolutions allow for more
accurate reconstruction of the samples in the dataset. More
results for this experiment are shown in Section D of the
Appendix, and the accompanying video6.

5.5. Single-image 3D reconstruction

In this experiment we trained networks with our OGN
decoder on the task of single-view 3D reconstruction. To
demonstrate that our dense voxel grid baseline, as already
used in the autoencoder experiment, is a strong baseline, we
compare to the approach by Choy et al. [6]. This approach
operates on 323 voxel grids, and we adopt this resolution
for our ﬁrst experiment. To ensure a fair comparison, we
trained networks on ShapeNet-all, the exact dataset used by
Choy et al. [6]. Following the same dataset splitting strat-
egy, we used 80% of the data for training, and 20% for
testing. As a baseline, we trained a network with a dense

6https://youtu.be/kmMvKNNyYF4

Figure 5. Training samples from the ShapeNet-cars dataset gener-
ated by our networks. Cells at different octree levels vary in size
and are displayed in different shades of gray.

5.4.1 ShapeNet-cars

First, we trained on the whole ShapeNet-cars dataset in
three resolutions: 643, 1283 and 2563. Example outputs
are shown in Figure 5 and quantitative results are presented
in Table 4. Similar to the two-dimensional case [10], the
outputs are accurate in the overall shape, but lack some ﬁne
details. This is not due to the missing resolution, but due to
general limitations of the training data and the learning task.
Table 4 reveals that a resolution of 1283 allows the recon-
struction of a more accurate shape with more details than
a resolution of 643. At an even higher resolution of 2563,
the overall performance decreased again. Even though the
higher-resolution network is architecturally capable of per-
forming better, it is not guaranteed to train better. Noisy gra-
dients from outer high-resolution layers may hamper learn-
ing of deeper layers, resulting in an overall decline in per-
formance. This problem is orthogonal to the issue of de-
signing computationally efﬁcient architectures, which we
aim to solve in this paper. We further discuss this in the
Appendix.

Notably, the network does not only learn to generate ob-
jects from the training dataset, but it can also generalize to
unseen models. We demonstrate this by interpolating be-

643

1283

2563

5123

GT 5123

Figure 7. OGN is used to reproduce large-scale scenes from the dataset, where high resolution is crucial to generate ﬁne-grained structures.

Input

323

643

1283

2563

GT 2563

Category
Plane
Bench
Cabinet
Car
Chair
Monitor
Lamp
Speaker
Firearm
Couch
Table
Cellphone
Watercraft
Mean

R2N2 [6] OGN Dense
0.570
0.481
0.747
0.828
0.481
0.509
0.371
0.650
0.576
0.668
0.545
0.698
0.550
0.590

0.587
0.481
0.729
0.816
0.483
0.502
0.398
0.637
0.593
0.646
0.536
0.702
0.632
0.596

0.513
0.421
0.716
0.798
0.466
0.468
0.381
0.662
0.544
0.628
0.513
0.661
0.513
0.560

Table 5. Single-view 3D reconstruction results on the 323 version
of ShapeNet-all from Choy et al. [6] compared to OGN and a dense
baseline. OGN is competitive with voxel-grid-based networks.

decoder which had the same conﬁguration as our OGN de-
coder. Table 5 shows that compared to single-view recon-
structions from [6], both the OGN and the baseline dense
network compare favorably for most of the classes. In con-
clusion, the OGN is competitive with voxel-grid-based net-
works on the complex task of single-image class-speciﬁc
3D reconstruction.

We also evaluated the effect of resolution on the
ShapeNet-cars dataset. Figure 8 shows that OGNs learned
to infer the 3D shapes of cars in all cases, and that high-
resolution predictions are clearly better than the 323 models
commonly used so far. This is backed up by quantitative
results shown in Table 6: 323 results are signiﬁcantly worse
than the rest. At 2563 performance drops again for the same
reasons as in the decoder experiment in section 5.4.1.

6. Conclusions

We have presented a novel convolutional decoder ar-
chitecture for generating high-resolution 3D outputs repre-
sented as octrees. We have demonstrated that this architec-
ture is ﬂexible in terms of the exact layer conﬁguration, and

Figure 8. Single-image 3D reconstruction on the ShapeNet-cars
dataset using OGN in different resolutions.

Resolution
Single-view 3D 0.641

32

64
0.771

128
0.782

256
0.766

Table 6. Single-image 3D reconstruction results on ShapeNet-cars.
Low-resolution predictions are upsampled to 2563. Commonly
used 323 models are signiﬁcantly worse than the rest.

that it provides the same accuracy as dense voxel grids in
low resolution. At the same time, it scales much better to
higher resolutions, both in terms of memory and runtime.

This architecture enables end-to-end deep learning to be
applied to tasks that appeared unfeasible before. In particu-
lar, learning tasks that involve 3D shapes, such as 3D object
and scene reconstruction, are likely to beneﬁt from it.

While in this paper we have focused on shapes and bi-
nary occupancy maps, it is straightforward to extend the
framework to multi-dimensional outputs attached to the oc-
tree structure; for example, the output of the network could
be a textured shape or a signed distance function. This will
allow for an even wider range of applications.

Acknowledgements

This work was supported by the Excellence Initiative
of the German Federal and State Governments: BIOSS
Centre for Biological Signalling Studies (EXC 294). We
would like to thank Benjamin Ummenhofer for valuable
discussions and technical comments. We also thank Niko-
laus Mayer for his help with 3D model visualization and
manuscript preparation.

References

[1] F. Bogo, J. Romero, M. Loper, and M. J. Black. FAUST:
Dataset and evaluation for 3D mesh registration. In CVPR,
2014. 11

[2] F. Calakli and G. Taubin. SSD: Smooth Signed Distance
Surface Reconstruction. Computer Graphics Forum, 2011.
2
¨O. C¸ ic¸ek, A. Abdulkadir, S. Lienkamp, T. Brox, and O. Ron-
neberger. 3d u-net: Learning dense volumetric segmentation
from sparse annotation. In MICCAI, 2016. 2

[3]

[4] A. X. Chang, T. Funkhouser, L. Guibas, P. Hanrahan,
Q. Huang, Z. Li, S. Savarese, M. Savva, S. Song, H. Su,
J. Xiao, L. Yi, and F. Yu. ShapeNet: An Information-Rich
3D Model Repository. CoRR, abs/1512.03012, 2015. 5
[5] H. Chen, Q. Dou, L. Yu, and P. Heng. Voxresnet: Deep vox-
elwise residual networks for volumetric brain segmentation.
CoRR, abs/1608.05895, 2016. 2

[6] C. B. Choy, D. Xu, J. Gwak, K. Chen, and S. Savarese. 3d-
r2n2: A uniﬁed approach for single and multi-view 3d object
reconstruction. In ECCV, 2016. 2, 5, 7, 8

[7] C. Connolly. Cumulative generation of octree models from

range data. In ICRA, 1984. 2

[8] X. Di, R. Dahyot, and M. Prasad. Deep shape from a low

number of silhouettes. In ECCV Workshops, 2016. 2

[9] A. Dosovitskiy, P. Fischer, E. Ilg, P. H¨ausser, C. Hazırbas¸,
V. Golkov, P. v.d. Smagt, D. Cremers, and T. Brox. Flownet:
Learning optical ﬂow with convolutional networks. In ICCV,
2015. 1

[10] A. Dosovitskiy, J. T. Springenberg, M. Tatarchenko, and
T. Brox. Learning to generate chairs, tables and cars with
convolutional networks. IEEE Transactions on Pattern Anal-
ysis and Machine Intelligence, 2016. 1, 6, 7

[11] H. Fan, H. Su, and L. J. Guibas. A point set generation
network for 3d object reconstruction from a single image.
CoRR, abs/1612.00603, 2016. 2

[12] S. Fuhrmann and M. Goesele. Fusion of depth maps with

multiple scales. In SIGGRAPH Asia, 2011. 2

[13] M. Gadelha, S. Maji, and R. Wang. 3d shape induction from
2d views of multiple objects. CoRR, abs/1612.05872, 2016.
2

[14] I. Gargantini. Linear octtrees for fast processing of three-
dimensional objects. Computer Graphics and Image Pro-
cessing, 20(4):365 – 374, 1982. 2

[15] R. Girdhar, D. Fouhey, M. Rodriguez, and A. Gupta. Learn-
ing a predictable and generative vector representation for ob-
jects. In ECCV, 2016. 2, 6

[16] B. Graham. Spatially-sparse convolutional neural networks.

CoRR, abs/1409.6070, 2014. 2

[17] B. Graham. Sparse 3d convolutional neural networks.

In

BMVC, 2015. 2

[18] E. Grant, P. Kohli, and M. van Gerven. Deep disentan-
gled representations for volumetric reconstruction. In ECCV
Workshops, 2016. 2

[19] Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long,
R. Girshick, S. Guadarrama, and T. Darrell. Caffe: Con-
volutional architecture for fast feature embedding. CoRR,
abs/1408.5093, 2014. 4

[20] D. Jimenez Rezende, S. M. A. Eslami, S. Mohamed,
P. Battaglia, M. Jaderberg, and N. Heess. Unsupervised
learning of 3d structure from images. In NIPS. 2016. 2
[21] J. Johnson, A. Alahi, and L. Fei-Fei. Perceptual losses for
real-time style transfer and super-resolution. In ECCV, 2016.
1

[22] M. Kazhdan, M. Bolitho, and H. Hoppe. Poisson surface

reconstruction. In SGP, 2006. 2

[23] D. P. Kingma and J. Ba. Adam: A method for stochastic

optimization. In ICLR, 2014. 5

[24] J. Masci, D. Boscaini, M. M. Bronstein, and P. Van-
dergheynst. Geodesic convolutional neural networks on rie-
mannian manifolds. In ICCV Workshops, 2015. 2

[25] D. Meagher. Octree encoding: A new technique for the rep-
resentation, manipulation and display of arbitrary 3-d objects
by computer. Technical Report IPL-TR-80-111, 1980. 2
[26] H. Noh, S. Hong, and B. Han. Learning deconvolution net-

work for semantic segmentation. In ICCV, 2015. 1

[27] C. R. Qi, H. Su, K. Mo, and L. J. Guibas. Pointnet: Deep
learning on point sets for 3d classiﬁcation and segmentation.
CoRR, abs/1612.00593, 2016. 2

[28] A. Radford, L. Metz, and S. Chintala. Unsupervised repre-
sentation learning with deep convolutional generative adver-
sarial networks. CoRR, abs/1511.06434, 2015. 1

[29] G. Riegler, A. O. Ulusoy, and A. Geiger. Octnet: Learn-
ing deep 3d representations at high resolutions. CoRR,
abs/1611.05009, 2016. 2, 6

[30] A. Sharma, O. Grau, and M. Fritz. Vconv-dae: Deep volu-
metric shape learning without object labels. In ECCV Work-
shops, 2016. 2, 6

[31] A. Sinha, J. Bai, and K. Ramani. Deep learning 3d shape

surfaces using geometry images. In ECCV, 2016. 2

[32] F. Steinbr¨ucker, J. Sturm, and D. Cremers. Volumetric 3d

mapping in real-time on a cpu. In ICRA, 2014. 2

[33] M. Tatarchenko, A. Dosovitskiy, and T. Brox. Multi-view 3d
models from single images with a convolutional network. In
ECCV, 2016. 2

[34] S. Tulsiani, H. Su, L. J. Guibas, A. A. Efros, and J. Malik.
Learning shape abstractions by assembling volumetric prim-
itives. CoRR, abs/1612.00404, 2016. 2

[35] B. Ummenhofer and T. Brox. Global, dense multiscale re-

construction for a billion points. In ICCV, 2015. 2

[36] J. Wu, C. Zhang, T. Xue, W. T. Freeman, and J. B. Tenen-
baum. Learning a probabilistic latent space of object shapes
via 3d generative-adversarial modeling. In NIPS, 2016. 2

[37] Z. Wu, S. Song, A. Khosla, F. Yu, L. Zhang, X. Tang, and
J. Xiao. 3d shapenets: A deep representation for volumetric
shapes. In CVPR, 2015. 2

[38] X. Yan, J. Yang, E. Yumer, Y. Guo, and H. Lee. Perspective
transformer nets: Learning single-view 3d object reconstruc-
tion without 3d supervision. In NIPS, 2016. 2

[39] L. Yi, H. Su, X. Guo, and L. J. Guibas. Syncspeccnn: Syn-
chronized spectral CNN for 3d shape segmentation. CoRR,
abs/1612.00606, 2016. 2

[40] M. E. Yumer and N. J. Mitra. Learning semantic deformation
ﬂows with 3d convolutional networks. In ECCV, 2016. 2

Appendix

A. Computational efﬁciency

In the main paper we have shown that with a practi-
cal architecture our networks scale much better than their
dense counterparts both in terms of memory consumption
and computation time. The numbers were obtained for the
”houses” scene from the BlendSwap dataset.

OGN
Quadratic
Dense
Cubic

OGN
Quadratic
Dense
Cubic

B
G

,
e
g
a
s
u
y
r
o
m
e
m
k
a
e
P

10

1

0.1

0.01

s

,
e
m

i
t

n
o
i
t
a
r
e
t
I

10

1

0.1

0.01

representation. The architectures of those networks are sim-
ilar to those from Table 13, but with only 1 channel in ev-
ery convolutional layer, and a single fully-connected layer
with 64 units in the encoder. The resulting measurements
are shown in Figure 9 for memory consumption and Fig-
ure 10 for runtime. To precisely quantify the scaling, we
subtracted the constant amount of memory reserved on a
GPU by caffe (190 MB) from all numbers.

Both plots are displayed in the log-log scale, i.e., func-
tions from the family y = axk are straight lines. The
slope of this line is determined by the exponent k, and the
vertical shift by the coefﬁcient a.
In this experiment we
are mainly interested in the slope, that is, how do the ap-
proaches scale with increasing output resolution. As a refer-
ence, we show dashed lines corresponding to perfect cubic
and perfect quadratic scaling.

Starting from 643 voxel resolution both the runtime and
the memory consumption scale almost cubically in case of
dense networks. For this particular example, OGN scales
even better than quadratically, but in general scaling of the
octree-based representation depends on the speciﬁc data it
is applied to.

In Section 4.4 of the main paper, we described how
we use the two propagation modes (Prop-known and Prop-
pred) during training and testing. Here we motivate the pro-
posed regimes, and show additional results with other com-
binations of propagation modes.

When the structure of the output tree is not known at test
time, we train the networks until convergence with Prop-
known, and then additionally ﬁne-tune with Prop-pred - line
4 in Table 7. Without this ﬁne-tuning step (line 2), there is
a decrease in performance, which is more signiﬁcant when
using larger convolutional ﬁlters. Intuitively, this happens
because the network has never seen erroneous propagations
during training, and does not now how to deal with them at
test time.

When the structure of the output is known at test time,
the best strategy is to simply train in Prop-known, and test
the same way (line 1). Additional ﬁne-tuning in the Prop-
pred mode slightly hurts performance in this case (line 3).
The overall conclusion is not surprising: the best results are
obtained when training networks in the same propagation
modes, in which they are later tested.

32

64

256

512

128
Resolution

B. Train/test modes

Figure 9. Memory consumption for very slim networks, forward
and backward pass, batch size 1. Shown in log-log scale - lines
with smaller slope correspond to better scaling.

32

64

256

512

128
Resolution

Figure 10. Iteration time for very slim networks, forward and back-
ward pass, batch size 1. Shown in log-log scale - lines with smaller
slope correspond to better scaling.

In order to further study this matter, we have designed
a set of slim decoder networks that ﬁt on a GPU in every
resolution, including 5123, both with an OGN and a dense

C. Feature propagation

In the main paper we mentioned that the number of fea-
tures propagated by an OGNProp layer depends on the sizes
of the convolutional ﬁlters in all subsequent blocks. In case
of 23 up-convolutions with stride 2, which were used in
most of our experiments, no neighboring features need to

(A)

up-conv
ﬁlter: 2
stride: 2

(B)

up-conv
ﬁlter: 4
stride: 2

Training Testing
Known
Known
Pred
Known
Known
Pred
Pred
Pred

23 ﬁlters
0.904
0.862
0.898
0.884

43 ﬁlters
0.907
0.804
0.896
0.885

IntConv
0.907
0.823
0.897
0.885

Table 7. Reconstruction quality for autoencoders with different de-
coder architectures: 23 up-convolutions, 43 up-convolutions, and
23 up-convolutions interleaved with 33 convolutions, using dif-
ferent conﬁgurations of Prop-known and Prop-pred propagation
modes.

be propagated. This situation is illustrated in Figure 11-A
in a one-dimensional case. Circles correspond to cells of
an octree. The green cell in the input is the only one for
which the value was predicted to be ”mixed”. Links be-
tween the circles indicate which features of the input are
required to compute the result of the operation (convolution
or up-convolution) for the corresponding output cell. In this
case, we can see that the output cells in the next level are
only affected by their parent cell from the previous level.

A more general situation is shown in Figure 11-B. The
input is processed with an up-convolutional layer with 43
ﬁlters and stride 2, which is followed by a convolutional
layer with 33 ﬁlters and stride 1. Again, only one cell was
predicted to be ”mixed”, but in order to perform convolu-
tions and up-convolutions in subsequent layers, we addi-
tionally must propagate some of its neighbors (marked red).
Therefore, with this particular ﬁlter conﬁguration, two cells
in the output are affected by four cells in the input.

Generally, the number of features that should be prop-
agated by each OGNProp layer is automatically calculated
based on the network architecture before starting the train-
ing.

D. 3D shape from high-level information: ad-

ditional experiments

D.1. MPI-FAUST

To additionally showcase the beneﬁt of using higher res-
olutions, we trained OGNs to ﬁt the MPI-FAUST dataset
[1]. It contains 300 high-resolution scans of human bodies
of 10 different people in 30 different poses. Same as with
the BlendSwap, the trained networks cannot generalize to
new samples due to the low amount of training data.

Figure 12 and Table 8 demonstrate qualitative and quan-
titative results respectively. Human models from MPI-
FAUST include ﬁner details than cars from ShapeNet, and
therefore beneﬁt from the higher resolution.

D.2. Fitting reduced ShapeNet-cars

To better understand the performance drop at 2563 res-
olution observed in section 5.4.1 of the main paper, we

conv
ﬁlter: 3
stride: 1

mixed

propagated
neighbors

ﬁlled/empty

zero-padding

Figure 11. The OGNProp layer propagates the features of ”mixed”
cells together with the features of the neighboring cells required
for computations in subsequent layers. We show the number
of neighbors that need to be propagated in two cases: 23 up-
convolutions (A), and 43 up-convolutions followed by 33 convo-
lutions (B). Visualized in 1D for simplicity.

643

1283

2563

GT 2563

Figure 12. Training samples from the FAUST dataset recon-
structed by OGN.

performed an additional experiment on the ShapeNet-Cars
dataset. We trained an OGN for generating car shapes from
their IDs on a reduced version of ShapeNet-Cars, including

64
0.890

128
0.933

256
0.969

Table 8. 3D shape from high-level information on the FAUST
dataset. Lower-resolution predictions were upsampled to 2563
ground truth.

Dataset
Shapenet-cars (full)
Shapenet-cars (subset)

1283
0.901
0.922

2563
0.865
0.931

Table 9. There is no drop in performance in higher resolution,
when training on a subset of the Shapenet-cars dataset.

Full

Subset

GT 2563

1283

2563

1283

2563

Figure 13. When training on a subset of the Shapenet-cars datset,
higher resolution models contain more details.

just 500 ﬁrst models from the dataset. Quantitative results
for different resolutions, along with the results for the full
dataset, are shown in Table 9. Interestingly, when training
on the reduced dataset, high resolution is beneﬁcial. This is
further supported by examples shown in Figure 13 – when
training on the reduced dataset, the higher-resolution model
contain more ﬁne details. Overall, these results support our
hypothesis that the performance drop at higher resolution is
not due to the OGN architecture, but due to the difﬁculty of
ﬁtting a large dataset at high resolution.

E. Shift invariance

The convolution operation on a voxel grid is perfectly
shift invariant by design. This is no longer true for convo-
lutions on octrees: a shift by a single pixel in the original
voxel grid can change the structure of the octree signiﬁ-
cantly. To study the effect of shifts, we trained two fully
convolutional autoencoders - one with an OGN decoder,
and one with a dense decoder - on 643 models, with low-
est feature map resolution 43 (so the networks should be

perfectly invariant to shifts of 16 voxels). Both were trained
on non-shifted Shapenet-Cars, and tested in the Prop-pred
mode on models shifted by a different number of voxels
along the z-axis. The results are summarized in Table 10.

Shift (voxels) OGN Dense
0.932
0.93
0.925
0.915
0.904

0.935
0.933
0.929
0.917
0.906

0
1
2
4
8

Table 10. Fully-convolutional networks tested on shifted data.
Even though not shift invariant by design, OGN shows robust per-
formance.

There is no signiﬁcant difference between OGN and the
dense network. A likely reason is that different training
models have different octree structures, which acts as an
implicit regularizer. The network learns the shape, but re-
mains robust to the exact octree structure.

F. Network architectures

In this section, we provide the exact network architec-

tures used in the experimental evaluations.

F.1. Autoencoders

The architectures of OGN autoencoders are summarized
in Table 12. For the dense baselines, we used the same layer
conﬁgurations with usual convolutions instead of OGN-
Conv, and predictions being made only after the last layer
of the network. All networks were trained with batch size
16.

F.2. 3D shape from high-level information

OGN decoders used on the Shapenet-cars dataset are
shown in Table 13. Encoders consisted of three fully-
connected layers, with output size of the last encoder layer
being identical to the input size of the corresponding de-
coder.

For FAUST and BlendSwap the 2563 output octrees had
four levels, not ﬁve like those in Table 13. Thus, the
dense block had an additional deconvolution-convolution
layer pair instead of one octree block. The 5123 decoder
on BlendSwap had one extra octree block with 32 output
channels.

All 643 and 1283 networks were trained with batch size

16, 2563 — with batch size 4, 5123 — with batch size 1.

F.3. Single-image 3D reconstruction

In this experiment we again used decoder architectures
shown in Table 13. The architecture of the convolutional
encoder is shown in Table 11. The number of channels in

the last encoder layer was set identical to the number of
input channels of the corresponding decoder.

[137 × 137 × 3]
Conv (7 × 7)
[69 × 69 × 32]
Conv (3 × 3)
[35 × 35 × 32]
Conv (3 × 3)
[18 × 18 × 64]
Conv (3 × 3)
[9 × 9 × 64]
Conv (3 × 3)
[5 × 5 × 128]
FC
[1024]
FC
[1024]
FC
[43 × c]

Table 11. Convolutional encoder used in the single-image 3D re-
construction experiment.

323

643 (23 ﬁlters)

643 (InvConv)

[323 × 1]
Conv (33)
[163 × 32]
Conv (33)
[83 × 48]
Conv (33)
[43 × 64]
FC
[1024]
FC
[1024]
FC
[43 × 80]
Deconv (23)
[83 × 64]
Conv (33)→ l1
[83 × 64]
OGNProp
OGNConv(23) → l2
[163 × 48]
OGNProp
OGNConv(23) → l3
[323 × 32]

643 (43 ﬁlters)
[643 × 1]
Conv (33)
[323 × 32]
Conv (33)
[163 × 48]
Conv (33)
[83 × 64]
Conv (33)
[43 × 80]
FC
[1024]
FC
[1024]
FC
[43 × 96]
Deconv (23)
[83 × 80]
Conv (33)
[83 × 80]

Deconv (23)
[163 × 64]

Conv (33)→ l1
[163 × 64]
OGNProp

[323 × 48]

OGNConv(23) → l2 OGNConv(43) → l2

OGNProp

[323 × 48]

OGNProp

OGNProp

OGNConv(23) → l3 OGNConv(43) → l3

[643 × 32]

[643 × 32]

OGNProp
OGNConv(23)
[323 × 48]
OGNConv*(33) → l2
[323 × 48]
OGNProp
OGNConv(23)
[643 × 32]
OGNConv*(33) → l3
[643 × 32]

Table 12. OGN architectures used in our experiments with autoencoders. OGNConv denotes up-convolution, OGNConv* — convolution.
Layer name followed by ’→ lk’ indicates that level k of an octree is predicted by a classiﬁer attached to this layer.

323
[43 × 80]
Deconv (23)
[83 × 64]
Conv (33) → l1
[83 × 64]
OGNProp
OGNConv (23) → l2
[163 × 48]
OGNProp
OGNConv (23) → l3
[323 × 32]

643
[43 × 96]
Deconv (23)
[83 × 80]
Conv (33)
[83 × 80]

Deconv (23)
[163 × 64]

1283
[43 × 112]
Deconv (23)
[83 × 96]
Conv (33)
[83 × 96]

Deconv (23)
[163 × 80]

2563
[43 × 112]
Deconv (23)
[83 × 96]
Conv (33)
[83 × 96]

Deconv (23)
[163 × 80]

Conv (33) → l1
[163 × 80]
OGNProp

Conv (33) → l1
[163 × 64]
OGNProp

Conv (33) → l1
[163 × 80]
OGNProp
OGNConv (23) → l2 OGNConv (23) → l2 OGNConv (23) → l2
[323 × 64]
OGNProp
OGNConv (23) → l3 OGNConv (23) → l3 OGNConv (23) → l3
[643 × 48]
OGNProp

[323 × 64]
OGNProp

[643 × 48]
OGNProp

[323 × 48]
OGNProp

[643 × 32]

OGNConv (23) → l4 OGNConv (23) → l4

[1283 × 32]

[1283 × 32]
OGNProp
OGNConv (23) → l5
[2563 × 32]

Table 13. OGN decoder architectures used in shape from ID, and single-image 3D reconstruction experiments.

