8
1
0
2
 
l
u
J
 
1
3
 
 
]

G
L
.
s
c
[
 
 
2
v
1
9
5
5
0
.
3
0
8
1
:
v
i
X
r
a

On the insufﬁciency of existing momentum schemes for Stochastic
Optimization∗

Rahul Kidambi1, Praneeth Netrapalli2, Prateek Jain2, and Sham M. Kakade1

1University of Washington, Seattle, WA, USA, rkidambi@uw.edu, sham@cs.washington.edu
2Microsoft Research, Bangalore, India, {praneeth,prajain}@microsoft.com

Abstract

Momentum based stochastic gradient methods such as heavy ball (HB) and Nesterov’s accelerated
gradient descent (NAG) method are widely used in practice for training deep networks and other super-
vised learning models, as they often provide signiﬁcant improvements over stochastic gradient descent
(SGD). Rigorously speaking, “fast gradient” methods have provable improvements over gradient descent
only for the deterministic case, where the gradients are exact. In the stochastic case, the popular expla-
nations for their wide applicability is that when these fast gradient methods are applied in the stochastic
case, they partially mimic their exact gradient counterparts, resulting in some practical gain. This work
provides a counterpoint to this belief by proving that there exist simple problem instances where these
methods cannot outperform SGD despite the best setting of its parameters. These negative problem
instances are, in an informal sense, generic; they do not look like carefully constructed pathological in-
stances. These results suggest (along with empirical evidence) that HB or NAG’s practical performance
gains are a by-product of mini-batching.

Furthermore, this work provides a viable (and provable) alternative, which, on the same set of prob-
lem instances, signiﬁcantly improves over HB, NAG, and SGD’s performance. This algorithm, referred
to as Accelerated Stochastic Gradient Descent (ASGD), is a simple to implement stochastic algorithm,
based on a relatively less popular variant of Nesterov’s Acceleration. Extensive empirical results in this
paper show that ASGD has performance gains over HB, NAG, and SGD. The code implementing the
ASGD Algorithm can be found here1.

1 Introduction

First order optimization methods, which access a function to be optimized through its gradient or an un-
biased approximation of its gradient, are the workhorses for modern large scale optimization problems,
which include training the current state-of-the-art deep neural networks. Gradient descent (Cauchy, 1847)
is the simplest ﬁrst order method that is used heavily in practice. However, it is known that for the class of
smooth convex functions as well as some simple non-smooth problems (Nesterov, 2012a)), gradient descent
is suboptimal (Nesterov, 2004) and there exists a class of algorithms called fast gradient/momentum based
methods which achieve optimal convergence guarantees. The heavy ball method (Polyak, 1964) and Nes-
terov’s accelerated gradient descent (Nesterov, 1983) are two of the most popular methods in this category.

∗Appeared as an oral presentation at International Conference on Learning Representations (ICLR), 2018, Vancouver, Canada.
1link to the ASGD code: https://github.com/rahulkidambi/AccSGD

1

On the other hand, training deep neural networks on large scale datasets have been possible through
the use of Stochastic Gradient Descent (SGD) (Robbins and Monro, 1951), which samples a random subset
of training data to compute gradient estimates that are then used to optimize the objective function. The
advantages of SGD for large scale optimization and the related issues of tradeoffs between computational
and statistical efﬁciency was highlighted in Bottou and Bousquet (2007).

The above mentioned theoretical advantages of fast gradient methods (Polyak, 1964; Nesterov, 1983)
(albeit for smooth convex problems) coupled with cheap to compute stochastic gradient estimates led to the
inﬂuential work of Sutskever et al. (2013), which demonstrated the empirical advantages possessed by SGD
when augmented with the momentum machinery. This work has led to widespread adoption of momentum
methods for training deep neural nets; so much so that, in the context of neural network training, gradient
descent often refers to momentum methods.

But, there is a subtle difference between classical momentum methods and their implementation in
practice – classical momentum methods work in the exact ﬁrst order oracle model (Nesterov, 2004), i.e.,
they employ exact gradients (computed on the full training dataset), while in practice (Sutskever et al.,
2013), they are implemented with stochastic gradients (estimated from a randomly sampled mini-batch of
training data). This leads to a natural question:

“Are momentum methods optimal even in the stochastic ﬁrst order oracle (SFO) model, where we

access stochastic gradients computed on a small constant sized minibatches (or a batchsize of 1?)”

Even disregarding the question of optimality of momentum methods in the SFO model, it is not even
known if momentum methods (say, Polyak (1964); Nesterov (1983)) provide any provable improvement
over SGD in this model. While these are open questions, a recent effort of Jain et al. (2017) showed that
improving upon SGD (in the stochastic ﬁrst order oracle) is rather subtle as there exists problem instances
in SFO model where it is not possible to improve upon SGD, even information theoretically. Jain et al.
(2017) studied a variant of Nesterov’s accelerated gradient updates (Nesterov, 2012b) for stochastic linear
regression and show that their method improves upon SGD wherever it is information theoretically admis-
sible. Through out this paper, we refer to the algorithm of Jain et al. (2017) as Accelerated Stochastic
Gradient Method (ASGD) while we refer to a stochastic version of the most widespread form of Nesterov’s
method (Nesterov, 1983) as NAG; HB denotes a stochastic version of the heavy ball method (Polyak, 1964).
Critically, while Jain et al. (2017) shows that ASGD improves on SGD in any information-theoretically
admissible regime, it is still not known whether HB and NAG can achieve a similar performance gain.

A key contribution of this work is to show that HB does not provide similar performance gains over SGD
even when it is informationally-theoretically admissible. That is, we provide a problem instance where it is
indeed possible to improve upon SGD (and ASGD achieves this improvement), but HB cannot achieve any
improvement over SGD. We validate this claim empirically as well. In fact, we provide empirical evidence
to the claim that NAG also do not achieve any improvement over SGD for several problems where ASGD
can still achieve better rates of convergence.

This raises a question about why HB and NAG provide better performance than SGD in practice
(Sutskever et al., 2013), especially for training deep networks. Our conclusion (that is well supported by our
theoretical result) is that HB and NAG’s improved performance is attributed to mini-batching and hence,
these methods will often struggle to improve over SGD with small constant batch sizes. This is in stark con-
trast to methods like ASGD, which is designed to improve over SGD across both small or large mini-batch
sizes. In fact, based on our experiments, we observe that on the task of training deep residual networks (He
et al., 2016a) on the cifar-10 dataset, we note that ASGD offers noticeable improvements by achieving
5 − 7% better test error over HB and NAG even with commonly used batch sizes like 128 during the initial
stages of the optimization.

2

1.1 Contributions

The contributions of this paper are as follows.

1. In Section 3, we prove that HB is not optimal in the SFO model. In particular, there exist linear
regression problems for which the performance of HB (with any step size and momentum) is either
the same or worse than that of SGD while ASGD improves upon both of them.

2. Experiments on several linear regression problems suggest that the suboptimality of HB in the SFO
model is not restricted to special cases – it is rather widespread. Empirically, the same holds true
for NAG as well (Section 5).

3. The above observations suggest that the only reason for the superiority of momentum methods in
practice is mini-batching, which reduces the variance in stochastic gradients and moves the SFO
closer to the exact ﬁrst order oracle. This conclusion is supported by empirical evidence through
training deep residual networks on cifar-10, with a batch size of 8 (see Section 5.3).

4. We present an intuitive and easier to tune version of ASGD (see Section 4) and show that ASGD can
provide signiﬁcantly faster convergence to a reasonable accuracy than SGD, HB, NAG, while still
providing favorable or comparable asymptotic accuracy as these methods, particularly on several deep
learning problems.

Hence, the take-home message of this paper is: HB and NAG are not optimal in the SFO model. The only
reason for the superiority of momentum methods in practice is mini-batching. ASGD provides a distinct
advantage in training deep networks over SGD, HB and NAG.

2 Notation

We denote matrices by bold-face capital letters and vectors by lower-case letters. f (w) = 1/n (cid:80)
i fi(w)
denotes the function to optimize w.r.t. model parameters w. ∇f (w) denotes exact gradient of f at w while
(cid:98)∇ft(w) denotes a stochastic gradient of f . That is, (cid:98)∇ft(wt) = ∇fit(w) where it is sampled uniformly at
random from [1, . . . , n]. For linear regression, fi(w) = 0.5 · (bi − (cid:104)w, ai(cid:105))2 where bi ∈ (cid:60) is the target and
ai ∈ (cid:60)d is the covariate, and (cid:98)∇ft(wt) = −(bt − (cid:104)wt, at(cid:105))at. In this case, H = E (cid:2)aa(cid:62)(cid:3) denotes the Hessian
of f and κ = λ1(H)

λd(H) denotes it’s condition number.

Algorithm 1 provides a pseudo-code of HB method (Polyak, 1964). wt − wt−1 is the momentum term
and α denotes the momentum parameter. Next iterate wt+1 is obtained by a linear combination of the SGD
update and the momentum term. Algorithm 2 provides pseudo-code of a stochastic version of the most
commonly used form of Nesterov’s accelerated gradient descent (Nesterov, 1983).

3 Suboptimality of Heavy Ball Method

In this section, we show that there exists linear regression problems where the performance of HB (Algo-
rithm 1) is no better than that of SGD, while ASGD signiﬁcantly improves upon SGD’s performance. Let
us now describe the problem instance.

Fix w∗ ∈ R2 and let (a, b) ∼ D be a sample from the distribution such that:

(cid:40)

a =

σ1 · z · e1 w.p. 0.5
σ2 · z · e2 w.p. 0.5,

and

b = (cid:104)w∗, a(cid:105) ,

3

Algorithm 1 HB: Heavy ball with a SFO
Require: Initial w0, stepsize δ, momentum α

Algorithm 2 NAG: Nesterov’s AGD with a SFO
Require: Initial w0, stepsize δ, momentum α

/*Set w−1 to w0*/

/*Set v0 to w0*/

1: w−1 ← w0; t ← 0
2: while wt not converged do
3:

1: v0 ← w0; t ← 0
2: while wt not converged do
3:

wt+1 ← wt − δ · (cid:98)∇ft(wt) + α · (wt − wt−1)
/*Sum of stochastic gradient step and momen-
tum*/
t ← t + 1

4:

vt+1 ← wt − δ · (cid:98)∇ft(wt) /*SGD step*/
wt+1 = (1 + α)vt+1 − αvt/*Sum of SGD step
and previous iterate*/
t ← t + 1

5:
6: end while

/*Return the last iterate*/

Ensure: wt

/*Return the last iterate*/

4:
5: end while

Ensure: wt

where e1, e2 ∈ R2 are canonical basis vectors, σ1 > σ2 > 0. Let z be a random variable such that
E (cid:2)z2(cid:3) = 2 and E (cid:2)z4(cid:3) = 2c ≥ 4. Hence, we have: E (cid:2)(a(i))2(cid:3) = σ2
i , for i = 1, 2. Now,
our goal is to minimize:

i , E (cid:2)(a(i))4(cid:3) = cσ4

f (w) def= 0.5 · E

((cid:104)w∗, a(cid:105) − b)2(cid:105)
(cid:104)

, Hessian H def= E

aa(cid:62)(cid:105)
(cid:104)

=

(cid:20)σ2
1
0

(cid:21)

.

0
σ2
2

Let κ and ˜κ denote the computational and statistical condition numbers – see Jain et al. (2017) for deﬁni-
tions. For the problem above, we have κ = cσ2
and ˜κ = c. Then we obtain following convergence rates for
1
σ2
2
SGD and ASGD when applied to the above given problem instance:

Corollary 1 (of Theorem 1 of Jain et al. (2016)). Let wSGD
with starting point w0 and stepsize 1
. The error of wSGD
cσ2
1

t

t

be the tth iterate of SGD on the above problem
can be bounded as,

E (cid:2)f (cid:0)wSGD

(cid:1)(cid:3) − f (w∗) ≤ exp

t

(cid:0)f (w0) − f (w∗) (cid:1).

(cid:19)

(cid:18) −t
κ

On the other hand, ASGD achieves the following superior rate.

Corollary 2 (of Theorem 1 of Jain et al. (2017)). Let wASGD
problem with starting point w0 and appropriate parameters. The error of wASGD

t

t

be the tth iterate of ASGD on the above

can be bounded as,

E (cid:2)f (cid:0)wASGD
t

(cid:1)(cid:3) − f (w∗) ≤ poly(κ) exp

(cid:0)f (w0) − f (w∗) (cid:1).

(cid:19)

(cid:18) −t
√
κ˜κ

Note that for a given problem/input distribution ˜κ = c is a constant while κ = cσ2
1
σ2
√
2
large. Note that κ > ˜κ = c. Hence, ASGD improves upon rate of SGD by a factor of
κ. The following
proposition, which is the main result of this section, establishes that HB (Algorithm 1) cannot provide a
similar improvement over SGD as what ASGD offers. In fact, we show no matter the choice of parameters
of HB, its performance does not improve over SGD by more than a constant.

can be arbitrarily

Proposition 3. Let wHB
For any choice of stepsize δ and momentum α ∈ [0, 1], ∃T large enough such that ∀t ≥ T , we have,

be the tth iterate of HB (Algorithm 1) on the above problem with starting point w0.

t

E (cid:2)f (cid:0)wHB

(cid:1)(cid:3) − f (w∗) ≥ C(κ, δ, α) · exp

t

(cid:0)f (w0) − f (w∗) (cid:1),

(cid:19)

(cid:18) −500t
κ

where C(κ, δ, α) depends on κ, δ and α (but not on t).

4

Algorithm 3 Accelerated stochastic gradient descent – ASGD
Input:

Initial w0, short step δ, long step parameter κ ≥ 1, statistical advantage parameter ξ ≤

√

κ

1: ¯w0 ← w0; t ← 0
2: α ← 1 − 0.72·ξ
κ
3: while wt not converged do
4:

(cid:16)

(cid:17)
0.7 · (cid:98)∇ft(wt)

wt − κ·δ

¯wt+1 ← α · ¯wt + (1 − α) ·
average of previous running average and a long step gradient */
+ 1−α
wt+1 ← 0.7
wt − δ · (cid:98)∇ft(wt)
of current running average and short step gradient*/
t ← t + 1

0.7+(1−α) ·

(cid:17)

(cid:16)

5:

6:
7: end while
Output: wt

/*Set running average to w0*/
/*Set momentum value*/

/*Update the running average as a weighted

0.7+(1−α) · ¯wt+1/*Update the iterate as weighted average

/*Return the last iterate*/

√

Thus, to obtain (cid:98)w s.t. (cid:107) (cid:98)w − w∗(cid:107) ≤ (cid:15), HB requires Ω(κ log 1
κ log κ log 1

(cid:15) ) samples and iterations. On the other hand,
ASGD can obtain (cid:15)-approximation to w∗ in O(
(cid:15) ) iterations. We note that the gains offered
by ASGD are meaningful when κ > O(c) (Jain et al., 2017); otherwise, all the algorithms including SGD
achieve nearly the same rates (upto constant factors). While we do not prove it theoretically, we observe
empirically that for the same problem instance, NAG also obtains nearly same rate as HB and SGD. We
conjecture that a lower bound for NAG can be established using a similar proof technique as that of HB
(i.e. Proposition 3). We also believe that the constant in the lower bound described in proposition 3 can be
improved to some small number (≤ 5).

4 Algorithm

We will now present and explain an intuitive version of ASGD (pseudo code in Algorithm 3). The
algorithm takes three inputs: short step δ, long step parameter κ and statistical advantage parameter ξ. The
short step δ is precisely the same as the step size in SGD, HB or NAG. For convex problems, this scales
inversely with the smoothness of the function. The long step parameter κ is intended to give an estimate of
the ratio of the largest and smallest curvatures of the function; for convex functions, this is just the condition
number. The statistical advantage parameter ξ captures trade off between statistical and computational
√
condition numbers – in the deterministic case, ξ =
κ and ASGD is equivalent to NAG, while in the high
stochasticity regime, ξ is much smaller. The algorithm maintains two iterates: descent iterate wt and a
running average ¯wt. The running average is a weighted average of the previous average and a long gradient
step from the descent iterate, while the descent iterate is updated as a convex combination of short gradient
step from the descent iterate and the running average. The idea is that since the algorithm takes a long step
as well as short step and an appropriate average of both of them, it can make progress on different directions
at a similar pace. Appendix B shows the equivalence between Algorithm 3 and ASGD as proposed in Jain
et al. (2017). Note that the constant 0.7 appearing in Algorithm 3 has no special signiﬁcance. Jain et al.
(2017) require it to be smaller than (cid:112)1/6 but any constant smaller than 1 seems to work in practice.

5 Experiments

We now present our experimental results exploring performance of SGD, HB, NAG and ASGD. Our exper-
iments are geared towards answering the following questions:

5

Algorithm Slope – discrete

SGD
HB
NAG
ASGD

0.9302
0.8522
0.98
0.5480

Slope – Gaussian
0.8745
0.8769
0.9494
0.5127

Table 1: Slopes (i.e. γ) obtained by ﬁtting a line to the curves in Figure 1. A value of γ indicates that the
error decays at a rate of exp (cid:0) −t
κγ

(cid:1). A smaller value of γ indicates a faster rate of error decay.

• Even for linear regression, is the suboptimality of HB restricted to speciﬁc distributions in Section 3

or does it hold for more general distributions as well? Is the same true of NAG?

• What is the reason for the superiority of HB and NAG in practice? Is it because momentum meth-
ods have better performance that SGD for stochastic gradients or due to mini-batching? Does this
superiority hold even for small minibatches?

• How does the performance of ASGD compare to that of SGD, HB and NAG, when training deep

networks?

Section 5.1 and parts of Section 5.2 address the ﬁrst two questions. Section 5.2 and 5.3 address Question
2 partially and the last question. We use Matlab to conduct experiments presented in Section 5.1 and use
PyTorch (pytorch, 2017) for our deep networks related experiments. Pytorch code implementing the ASGD
algorithm can be found at https://github.com/rahulkidambi/AccSGD.

5.1 Linear Regression

In this section, we will present results on performance of the four optimization methods (SGD, HB, NAG,
and ASGD) for linear regression problems. We consider two different class of linear regression problems,
both in two dimensions. For a given condition number κ, we consider the following two distributions:

Discrete: a = e1 w.p. 0.5 and a = 2
κ · e2 with 0.5; ei is the ith standard basis vector.
Gaussian : a ∈ R2 is distributed as a Gaussian random vector with covariance matrix

(cid:21)

.

(cid:20)1 0
1
0
κ

We ﬁx a randomly generated w∗ ∈ R2 and for both the distributions above, we let b = (cid:104)w∗, a(cid:105). We vary
κ from {24, 25, ..., 212} and for each κ in this set, we run 100 independent runs of all four methods, each for
a total of t = 5κ iterations. We deﬁne that the algorithm converges if there is no error in the second half (i.e.
after 2.5κ updates) that exceeds the starting error - this is reasonable since we expect geometric convergence
of the initial error.

Unlike ASGD and SGD, we do not know optimal learning rate and momentum parameters for NAG and
HB in the stochastic gradient model. So, we perform a grid search over the values of the learning rate and
momentum parameters. In particular, we lay a 10 × 10 grid in [0, 1] × [0, 1] for learning rate and momentum
and run NAG and HB. Then, for each grid point, we consider the subset of 100 trials that converged and
computed the ﬁnal error using these. Finally, the parameters that yield the minimal error are chosen for
NAG and HB, and these numbers are reported. We measure convergence performance of a method using:

rate =

log(f (w0)) − log(f (wt))
t

,

(1)

6

Figure 1: Plot of 1/rate (refer equation (1)) vs condition number (κ) for various methods for the linear
regression problem. Discrete distribution in the left, Gaussian to the right.

We compute the rate (1) for all the algorithms with varying condition number κ. Given a rate vs κ plot
for a method, we compute it’s slope (denoted as γ) using linear regression. Table 1 presents the estimated
slopes (i.e. γ) for various methods for both the discrete and the Gaussian case. The slope values clearly
show that the rate of SGD, HB and NAG have a nearly linear dependence on κ while that of ASGD seems
to scale linearly with

κ.

√

5.2 Deep Autoencoders for MNIST

In this section, we present experimental results on training deep autoencoders for the mnist dataset, and we
follow the setup of Hinton and Salakhutdinov (2006). This problem is a standard benchmark for evaluating
optimization algorithms e.g., Martens (2010); Sutskever et al. (2013); Martens and Grosse (2015); Reddi
et al. (2017). The network architecture follows previous work (Hinton and Salakhutdinov, 2006) and is
represented as 784 − 1000 − 500 − 250 − 30 − 250 − 500 − 1000 − 784 with the ﬁrst and last 784 nodes
representing the input and output respectively. All hidden/output nodes employ sigmoid activations except
for the layer with 30 nodes which employs linear activations and we use MSE loss. We use the initialization
scheme of Martens (2010), also employed in Sutskever et al. (2013); Martens and Grosse (2015). We per-
form training with two minibatch sizes −1 and 8. The runs with minibatch size of 1 were run for 30 epochs
while the runs with minibatch size of 8 were run for 50 epochs. For each of SGD, HB, NAG and ASGD, a
grid search over learning rate, momentum and long step parameter (whichever is applicable) was done and
best parameters were chosen based on achieving the smallest training error in the same protocol followed
by Sutskever et al. (2013). The grid was extended whenever the best parameter fell at the edge of a grid. For
the parameters chosen by grid search, we perform 10 runs with different seeds and averaged the results. The
results are presented in Figures 2 and 3. Note that the ﬁnal loss values reported are suboptimal compared to
the published literature e.g., Sutskever et al. (2013); while Sutskever et al. (2013) report results after 750000
updates with a large batch size of 200 (which implies a total of 750000×200 = 150M gradient evaluations),
whereas, ours are after 1.8M updates of SGD with a batch size 1 (which is just 1.8M gradient evaluations).
Effect of minibatch sizes: While HB and NAG decay the loss faster compared to SGD for a minibatch
size of 8 (Figure 2), this superior decay rate does not hold for a minibatch size of 1 (Figure 3). This supports
our intuitions from the stochastic linear regression setting, where we demonstrate that HB and NAG are
suboptimal in the stochastic ﬁrst order oracle model.

7

Figure 2: Training loss (left) and test loss (right) while training deep autoencoder for mnist with minibatch
size 8. Clearly, ASGD matches performance of NAG and outperforms SGD on the test data. HB also
outperforms SGD.

Figure 3: Training loss (left) and test loss (right) while training deep autoencoder for mnist with minibatch
size 1. Interestingly, SGD, HB and NAG, all decrease the loss at a similar rate, while ASGD decays at a
faster rate.

Comparison of ASGD with momentum methods: While ASGD performs slightly better than NAG
for batch size 8 in the training error (Figure 2), ASGD decays the error at a faster rate compared to all the
three other methods for a batch size of 1 (Figure 3).

5.3 Deep Residual Networks for CIFAR-10

We will now present experimental results on training deep residual networks (He et al., 2016b) with pre-
activation blocks He et al. (2016a) for classifying images in cifar-10 (Krizhevsky and Hinton, 2009); the net-
work we use has 44 layers (dubbed preresnet-44). The code for this section was downloaded from preresnet
(2017). One of the most distinct characteristics of this experiment compared to our previous experiments is
learning rate decay. We use a validation set based decay scheme, wherein, after every 3 epochs, we decay the
learning rate by a certain factor (which we grid search on) if the validation zero one error does not decrease

8

Figure 4: Test zero one loss for batch size 128 (left), batch size 8 (center) and training function value for
batch size 8 (right) for SGD, HB and NAG.

by at least a certain amount (precise numbers are provided in the appendix since they vary across batch
sizes). Due to space constraints, we present only a subset of training error plots. Please see Appendix C.3
for some more plots on training errors.

Effect of minibatch sizes: Our ﬁrst experiment tries to understand how the performance of HB and NAG
compare with that of SGD and how it varies with minibatch sizes. Figure 4 presents the test zero one
error for minibatch sizes of 8 and 128. While training with batch size 8 was done for 40 epochs, with
batch size 128, it was done for 120 epochs. We perform a grid search over all parameters for each of
these algorithms. See Appendix C.3 for details on the grid search parameters. We observe that ﬁnal error
achieved by SGD, HB and NAG are all very close for both batch sizes. While NAG exhibits a superior rate
of convergence compared to SGD and HB for batch size 128, this superior rate of convergence disappears
for a batch size of 8.

Comparison of ASGD with momentum methods: The next experiment tries to understand how ASGD
compares with HB and NAG. The errors achieved by various methods when we do grid search over all
parameters are presented in Table 2. Note that the ﬁnal test errors for batch size 128 are better than those
for batch size 8 since the former was run for 120 epochs while the latter was run only for 40 epochs (due to
time constraints).

Algorithm Final test error – batch size 128

SGD
HB
NAG
ASGD

8.32 ± 0.21
7.98 ± 0.19
7.63 ± 0.18
7.23 ± 0.22

Final test error – batch size 8
9.57 ± 0.18
9.28 ± 0.25
9.07 ± 0.18
8.52 ± 0.16

Table 2: Final test errors achieved by various methods for batch sizes of 128 and 8. The hyperparameters
have been chosen by grid search.

While the ﬁnal error achieved by ASGD is similar/favorable compared to all other methods, we are also
interested in understanding whether ASGD has a superior convergence speed. For this experiment, we need
to address the issue of differing learning rates used by various algorithms and different iterations where they
decay learning rates. So, for each of HB and NAG, we choose the learning rate and decay factors by grid
search, use these values for ASGD and do grid search only over long step parameter κ and momentum α for
ASGD. The results are presented in Figures 5 and 6. For batch size 128, ASGD decays error at a faster rate
compared to both HB and NAG. For batch size 8, while we see a superior convergence of ASGD compared

9

Figure 5: Test zero one loss for batch size 128 (left), batch size 8 (center) and training function value
for batch size 8 (right) for ASGD compared to HB. In the above plots, both ASGD and ASGD-Hb-
Params refer to ASGD run with the learning rate and decay schedule of HB. ASGD-Fully-Optimized refers
to ASGD where learning rate and decay schedule were also selected by grid search.

Figure 6: Test zero one loss for batch size 128 (left), batch size 8 (center) and training function value for
batch size 8 (right) for ASGD compared to NAG. In the above plots, ASGD was run with the learning rate
and decay schedule of NAG. Other parameters were selected by grid search.

to NAG, we do not see this superiority over HB. The reason for this turns out to be that the learning rate
for HB, which we also use for ASGD, turns out to be quite suboptimal for ASGD. So, for batch size 8, we
also compare fully optimized (i.e., grid search over learning rate as well) ASGD with HB. The superiority
of ASGD over HB is clear from this comparison. These results suggest that ASGD decays error at a faster
rate compared to HB and NAG across different batch sizes.

6 Related Work

First order oracle methods: The primary method in this family is Gradient Descent (GD) (Cauchy, 1847).
As mentioned previously, GD is suboptimal for smooth convex optimization (Nesterov, 2004), and this is
addressed using momentum methods such as the Heavy Ball method (Polyak, 1964) (for quadratics), and
Nesterov’s Accelerated gradient descent (Nesterov, 1983).

Stochastic ﬁrst order methods and noise stability: The simplest method employing the SFO is
SGD (Robbins and Monro, 1951); the effectiveness of SGD has been immense, and its applicability goes
well beyond optimizing convex objectives. Accelerating SGD is a tricky proposition given the instability of
fast gradient methods in dealing with noise, as evidenced by several negative results which consider statis-

10

tical (Proakis, 1974; Polyak, 1987; Roy and Shynk, 1990), numerical (Paige, 1971; Greenbaum, 1989) and
adversarial errors (d’Aspremont, 2008; Devolder et al., 2014). A result of Jain et al. (2017) developed the
ﬁrst provably accelerated SGD method for linear regression which achieved minimax rates, inspired by a
method of Nesterov (2012b). Schemes of Ghadimi and Lan (2012, 2013); Dieuleveut et al. (2016), which
indicate acceleration is possible with noisy gradients do not hold in the SFO model satisﬁed by algorithms
that are run in practice (see Jain et al. (2017) for more details).

While HB (Polyak, 1964) and NAG (Nesterov, 1983) are known to be effective in case of exact ﬁrst

order oracle, for the SFO, the theoretical performance of HB and NAG is not well understood.

Understanding Stochastic Heavy Ball: Understanding HB’s performance with inexact gradients has
been considered in efforts spanning several decades, in many communities like controls, optimization and
signal processing. Polyak (1987) considered HB with noisy gradients and concluded that the improvements
offered by HB with inexact gradients vanish unless strong assumptions on the inexactness was considered;
an instance of this is when the variance of inexactness decreased as the iterates approach the minimizer.
Proakis (1974); Roy and Shynk (1990); Sharma et al. (1998) suggest that the improved non-asymptotic rates
offered by stochastic HB arose at the cost of worse asymptotic behavior. We resolve these unquantiﬁed
improvements on rates as being just constant factors over SGD, in stark contrast to the gains offered by
ASGD. Loizou and Richt´arik (2017) state their method as Stochastic HB but require stochastic gradients
that nearly behave as exact gradients; indeed, their rates match that of the standard HB method (Polyak,
1964). Such rates are not information theoretically possible (see Jain et al. (2017)), especially with a batch
size of 1 or even with constant sized minibatches.

Accelerated and Fast Methods for ﬁnite-sums: There have been developments pertaining to faster
methods for ﬁnite-sums (also known as ofﬂine stochastic optimization): amongst these are methods such
as SDCA (Shalev-Shwartz and Zhang, 2012), SAG (Roux et al., 2012), SVRG (Johnson and Zhang, 2013),
SAGA (Defazio et al., 2014), which offer linear convergence rates for strongly convex ﬁnite-sums, improv-
ing over SGD’s sub-linear rates (Rakhlin et al., 2012). These methods have been improved using accelerated
variants (Shalev-Shwartz and Zhang, 2014; Frostig et al., 2015a; Lin et al., 2015; Defazio, 2016; Allen-Zhu,
2016). Note that these methods require storing the entire training set in memory and taking multiple passes
over the same for guaranteed progress. Furthermore, these methods require computing a batch gradient or
require memory requirements (typically Ω(| training data points|)). For deep learning problems, data aug-
mentation is often deemed necessary for achieving good performance; this implies computing quantities
such as batch gradient (or storage necessities) over this augmented dataset is often infeasible. Such require-
ments are mitigated by the use of simple streaming methods such as SGD, ASGD, HB, NAG. For other
technical distinctions between the ofﬂine and online stochastic methods refer to Frostig et al. (2015b).

Practical methods for training deep networks: Momentum based methods employed with stochastic
gradients (Sutskever et al., 2013) have become standard and popular in practice. These schemes tend to out-
perform standard SGD on several important practical problems. As previously mentioned, we attribute this
improvement to effect of mini-batching rather than improvement offered by HB or NAG in the SFO model.
Schemes such as Adagrad (Duchi et al., 2011), RMSProp (Tieleman and Hinton, 2012), Adam (Kingma and
Ba, 2014) represent an important and useful class of algorithms. The advantages offered by these methods
are orthogonal to the advantages offered by fast gradient methods; it is an important direction to explore
augmenting these methods with ASGD as opposed to standard HB or NAG based acceleration schemes.

Chaudhari et al. (2017) proposed Entropy-SGD, which is an altered objective that adds a local strong
convexity term to the actual empirical risk objective, with an aim to improve generalization. However, we
do not understand convergence rates for convex problems or the generalization ability of this technique in
a rigorous manner. Chaudhari et al. (2017) propose to use SGD in their procedure but mention that they

11

employ the HB/NAG method in their implementation for achieving better performance. Naturally, we can
use ASGD in this context. Path normalized SGD (Neyshabur et al., 2015) is a variant of SGD that alters
the metric on which the weights are optimized. As noted in their paper, path normalized SGD could be
improved using HB/NAG (or even the ASGD method).

7 Conclusions and Future Directions

In this paper, we show that the performance gain of HB over SGD in stochastic setting is attributed to mini-
batching rather than the algorithm’s ability to accelerate with stochastic gradients. Concretely, we provide a
formal proof that for several easy problem instances, HB does not outperform SGD despite large condition
number of the problem; we observe this trend for NAG in our experiments. In contrast, ASGD (Jain et al.,
2017) provides signiﬁcant improvement over SGD for these problem instances. We observe similar trends
when training a resnet on cifar-10 and an autoencoder on mnist. This work motivates several directions such
as understanding the behavior of ASGD on domains such as NLP, and developing automatic momentum
tuning schemes (Zhang et al., 2017).

Acknowledgments

Sham Kakade acknowledges funding from Washington Research Foundation Fund for Innovation in Data-
Intensive Discovery and the NSF through awards CCF-1637360, CCF-1703574 and CCF-1740551.

12

References

abs/1603.05953, 2016.

Paris, 1847.

1171–1183, 2008.

Z. Allen-Zhu.

Katyusha: The ﬁrst direct acceleration of stochastic gradient methods.

CoRR,

L. Bottou and O. Bousquet. The tradeoffs of large scale learning. In NIPS 20, 2007.

L. A. Cauchy. M´ethode g´en´erale pour la r´esolution des syst´emes d’´equations simultanees. C. R. Acad. Sci.

P. Chaudhari, A. Choromanska, S. Soatto, Y. LeCun, C. Baldassi, C. Borgs, J. Chayes, L. Sagun, and
R. Zecchina. Entropy-sgd: Biasing gradient descent into wide valleys. CoRR, abs/1611.01838, 2017.

A. d’Aspremont. Smooth optimization with approximate gradient. SIAM Journal on Optimization, 19(3):

A. Defazio. A simple practical accelerated method for ﬁnite sums. Advances in Neural Information Pro-

cessing Systems 29 (NIPS 2016), 2016.

A. Defazio, F. R. Bach, and S. Lacoste-Julien. SAGA: A fast incremental gradient method with support for

non-strongly convex composite objectives. In NIPS 27, 2014.

O. Devolder, F. Glineur, and Y. E. Nesterov. First-order methods of smooth convex optimization with inexact

oracle. Mathematical Programming, 146:37–75, 2014.

A. Dieuleveut, N. Flammarion, and F. R. Bach. Harder, better, faster, stronger convergence rates for least-

squares regression. CoRR, abs/1602.05419, 2016.

J. C. Duchi, E. Hazan, and Y. Singer. Adaptive subgradient methods for online learning and stochastic

optimization. Journal of Machine Learning Research, 12:2121–2159, 2011.

R. Frostig, R. Ge, S. Kakade, and A. Sidford. Un-regularizing: approximate proximal point and faster

stochastic algorithms for empirical risk minimization. In ICML, 2015a.

R. Frostig, R. Ge, S. M. Kakade, and A. Sidford. Competing with the empirical risk minimizer in a single

pass. In COLT, 2015b.

S. Ghadimi and G. Lan. Optimal stochastic approximation algorithms for strongly convex stochastic com-

posite optimization i: A generic algorithmic framework. SIAM Journal on Optimization, 2012.

S. Ghadimi and G. Lan. Optimal stochastic approximation algorithms for strongly convex stochastic com-
posite optimization, ii: shrinking procedures and optimal algorithms. SIAM Journal on Optimization,
2013.

A. Greenbaum. Behavior of slightly perturbed lanczos and conjugate-gradient recurrences. Linear Algebra

and its Applications, 1989.

K. He, X. Zhang, S. Ren, and J. Sun. Identity mappings in deep residual networks. In ECCV (4), Lecture

Notes in Computer Science, pages 630–645. Springer, 2016a.

K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learning for image recognition.

In CVPR, pages

770–778, 2016b.

13

error. 2017.

2010.

2012a.

G. E. Hinton and R. R. Salakhutdinov. Reducing the dimensionality of data with neural networks. science,

313(5786):504–507, 2006.

P. Jain, S. M. Kakade, R. Kidambi, P. Netrapalli, and A. Sidford. Parallelizing stochastic approximation

through mini-batching and tail-averaging. arXiv preprint arXiv:1610.03774, 2016.

P. Jain, S. M. Kakade, R. Kidambi, P. Netrapalli, and A. Sidford. Accelerating stochastic gradient descent.

arXiv preprint arXiv:1704.08227, 2017.

R. Johnson and T. Zhang. Accelerating stochastic gradient descent using predictive variance reduction. In

NIPS 26, 2013.

D. P. Kingma and J. Ba. Adam: A method for stochastic optimization. CoRR, abs/1412.6980, 2014.

A. Krizhevsky and G. Hinton. Learning multiple layers of features from tiny images. 2009.

H. Lin, J. Mairal, and Z. Harchaoui. A universal catalyst for ﬁrst-order optimization. In NIPS, 2015.

N. Loizou and P. Richt´arik. Linearly convergent stochastic heavy ball method for minimizing generalization

J. Martens. Deep learning via hessian-free optimization. In International conference on machine learning,

J. Martens and R. Grosse. Optimizing neural networks with kronecker-factored approximate curvature. In

International conference on machine learning, 2015.

Y. Nesterov. A method of solving a convex programming problem with convergence rate o (1/k2). In Soviet

Mathematics Doklady, volume 27, pages 372–376, 1983.

Y. Nesterov. Gradient methods for minimizing composite functions. Mathematical Programming Series B,

Y. E. Nesterov. Introductory lectures on convex optimization: A basic course, volume 87 of Applied Opti-

mization. Kluwer Academic Publishers, 2004.

Y. E. Nesterov. Efﬁciency of coordinate descent methods on huge-scale optimization problems. SIAM

Journal on Optimization, 22(2):341–362, 2012b.

B. Neyshabur, R. Salakhutdinov, and N. Srebro. Path-sgd: Path-normalized optimization in deep neural

networks. CoRR, abs/1506.02617, 2015.

C. C. Paige. The computation of eigenvalues and eigenvectors of very large sparse matrices. PhD Thesis,

University of London, 1971.

B. T. Polyak. Some methods of speeding up the convergence of iteration methods. USSR Computational

Mathematics and Mathematical Physics, 4(5):1–17, 1964.

B. T. Polyak. Introduction to Optimization. Optimization Software, 1987.

preresnet. Preresnet-44 for cifar-10. https://github.com/D-X-Y/ResNeXt-DenseNet, 2017.

Accessed: 2017-10-25.

14

J. G. Proakis. Channel identiﬁcation for high speed digital communications. IEEE Transactions on Auto-

matic Control, 1974.

pytorch. Pytorch. https://github.com/pytorch, 2017. Accessed: 2017-10-25.

A. Rakhlin, O. Shamir, and K. Sridharan. Making gradient descent optimal for strongly convex stochastic

optimization. In ICML, 2012.

S. Reddi, M. Zaheer, S. Sra, B. Poczos, F. Bach, R. Salakhutdinov, and A. Smola. A generic approach for

escaping saddle points. arXiv preprint arXiv:1709.01434, 2017.

H. Robbins and S. Monro. A stochastic approximation method. The Annals of Mathematical Statistics, vol.

22, 1951.

N. L. Roux, M. Schmidt, and F. R. Bach. A stochastic gradient method with an exponential convergence

rate for strongly-convex optimization with ﬁnite training sets. In NIPS 25, 2012.

S. Roy and J. J. Shynk. Analysis of the momentum lms algorithm. IEEE Transactions on Acoustics, Speech

and Signal Processing, 1990.

tion. CoRR, abs/1209.1873, 2012.

loss minimization. In ICML, 2014.

S. Shalev-Shwartz and T. Zhang. Stochastic dual coordinate ascent methods for regularized loss minimiza-

S. Shalev-Shwartz and T. Zhang. Accelerated proximal stochastic dual coordinate ascent for regularized

R. Sharma, W. A. Sethares, and J. A. Bucklew. Analysis of momentum adaptive ﬁltering algorithms. IEEE

Transactions on Signal Processing, 1998.

I. Sutskever, J. Martens, G. Dahl, and G. Hinton. On the importance of initialization and momentum in deep

learning. In International conference on machine learning, pages 1139–1147, 2013.

T. Tieleman and G. Hinton. Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent

magnitude. COURSERA: Neural networks for machine learning, 2012.

J. Zhang, I. Mitliagkas, and C. R. Yellowﬁn and the art of momentum tuning. CoRR, abs/1706.03471, 2017.

15

A Suboptimality of HB: Proof of Proposition 3

Before proceeding to the proof, we introduce some additional notation. Let θ(j)
and centered estimates in the jth direction for j = 1, 2.

t+1 denote the concatenated

θ(j)
t+1

def=

(cid:35)

(cid:34)
w(j)
t+1 − (w∗)(j)
w(j)
t − (w∗)(j)

,

j = 1, 2.

Since the distribution over x is such that the coordinates are decoupled, we see that θ(j)
terms of θ(j)

as:

t

t+1 can be written in

t+1 = (cid:98)A(j)
θ(j)

t+1θ(j)

t

, with (cid:98)A(j)

t+1 =

(cid:34)

1 + α − δ(a(j)
1

t+1)2 −α
0

(cid:35)

.

def= E

(cid:104)
t+1 ⊗ θ(j)
θ(j)

t+1

(cid:105)

Let Φ(j)
t+1
deﬁned as

denote the covariance matrix of θ(j)

t+1. We have Φ(j)

t+1 = B(j)Φ(j)

t with, B(j)

B(j) def=

E (cid:2)(1 + α − δ(a(j))2)2(cid:3) E (cid:2)−α(1 + α − δ(a(j))2)(cid:3) E (cid:2)−α(1 + α − δ(a(j))2(cid:3) α2

E (cid:2)(1 + α − δ(a(j))2)(cid:3)
0


E (cid:2)(1 + α − δ(a(j))2)(cid:3)
0

1
0
j )2 + (c − 1)(δσ2
(1 + α − δσ2
(1 + α − δσ2
j )
(1 + α − δσ2
j )
1

0
−α
0
j )2 −α(1 + α − δσ2

j ) α2
0
0
0

j ) −α(1 + α − δσ2

0
−α
0

−α
0
0

−α
0
0







.













=

We prove Proposition 3 by showing that for any choice of stepsize and momentum, either of the two holds:

• B(1) has an eigenvalue larger than 1, or,

• the largest eigenvalue of B(2) is greater than 1 − 500
κ .

This is formalized in the following two lemmas.

Lemma 4. If the stepsize δ is such that δσ2

1 ≥

2(1−α2)
c+(c−2)α , then B(1) has an eigenvalue ≥ 1.

Lemma 5. If the stepsize δ is such that δσ2

1 <

2(1−α2)
c+(c−2)α , then B(2) has an eigenvalue of magnitude ≥ 1− 500
κ .

Given this notation, we can now consider the jth dimension without the superscripts; when needed, they

will be made clear in the exposition. Denoting x def= δσ2 and t def= 1 + α − x, we have:

B =







t2 + (c − 1)x2 −αt −αt α2
0
0
0

−α
0
0

0
−α
0

t
t
1







16

A.1 Proof

The analysis goes via computation of the characteristic polynomial of B and evaluating it at different values
to obtain bounds on its roots.

Lemma 6. The characteristic polynomial of B is:

D(z) = z4 − (t2 + (c − 1)x2)z3 + (2αt2 − 2α2)z2 + (−t2 + (c − 1)x2)α2z + α4.

Proof. We ﬁrst begin by writing out the expression for the determinant:

Det(B − zI) =

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

t2 + (c − 1)x2 − z −αt −αt α2
0
0
0 −z

−z −α
−α −z
0

t
t
1

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

.

expanding along the ﬁrst column, we have:

Det(B − zI) = (t2 + (c − 1)x2 − z)(α2z − z3) − t(−αtz2 + α2tz) + t(−αt(αz) + z · αtz) − (z · α2z − α4)

= (t2 + (c − 1)x2 − z)(α2z − z3) − 2t(α2tz − αtz2) − (α2z2 − α4).

Expanding the terms yields the expression in the lemma.

The next corollary follows by some simple arithmetic manipulations.

Corollary 7. Substituting z = 1 − τ in the characteristic equation of Lemma 6, we have:

D(1 − τ ) = τ 4 + τ 3(−4 + t2 + (c − 1)x2) + τ 2(6 − 3t2 − 3(c − 1)x2 − 2α2 + 2αt2)
+ τ (−4 + 3t2 + 3(c − 1)x2 + 4α2 − 4αt2 − (c − 1)x2α2 + t2α2)
+ (1 − t2 − (c − 1)x2 − 2α2 + 2αt2 + (c − 1)x2α2 − t2α2 + α4)
= τ 4 + τ 3[−(3 + α)(1 − α) − 2x(1 + α) + cx2]
+ τ 2[(3 − 4α − α2 + 2α3) − 2x(1 + α)(2α − 3) + x2(2α − 3c)]
+ τ [−(1 − α)2(1 − α2) − 2x(3 − α)(1 − α2) + x2(3c − 4α + (2 − c)α2)]
+ x(1 − α)[2(1 − α2) − x(c + (c − 2)α)].

(2)

Proof of Lemma 4. The ﬁrst observation necessary to prove the lemma is that the characteristic polynomial
D(z) approaches ∞ as z → ∞, i.e., limz→∞ D(z) = +∞.

Next, we evaluate the characteristic polynomial at 1, i.e. compute D(1). This follows in a straightfor-

ward manner from corollary (7) by substituting τ = 0 in equation (2), and this yields,

D(1) = (1 − α)x ·

2(1 − α2) − x(1 − α) − (c − 1)x(1 + α)

(cid:18)

(cid:19)
.

As α < 1, x = δσ2 > 0, we have the following by setting D(1) ≤ 0 and solving for x:

Since D(1) ≤ 0 and D(z) ≥ 0 as z → ∞, there exists a root of D(·) which is ≥ 1.

x ≥

2(1 − α2)
c + (c − 2)α

.

17

Remark 8. The above characterization is striking in the sense that for any c > 1, increasing the momentum
parameter α naturally requires the reduction in the step size δ to permit the convergence of the algorithm,
which is not observed when fast gradient methods are employed in deterministic optimization. For instance,
in the case of deterministic optimization, setting c = 1 yields δσ2
1 < 2(1 + α). On the other hand, when
employing the stochastic heavy ball method with x(j) = 2σ2
j , we have the condition that c = 2, and this
implies, δσ2

= 1 − α2.

1 < 2(1−α2)

2

We now prove Lemma 5. We ﬁrst consider the large momentum setting.

Lemma 9. When the momentum parameter α is set such that 1 − 450/κ ≤ α ≤ 1, B has an eigenvalue of
magnitude ≥ 1 − 450
κ .

Proof. This follows easily from the fact that det(B) = α4 = (cid:81)4
1 − 450/κ ≤ α ≤ |λmax(B)|.

j=1 λj(B) ≤ (λmax(B))4, thus implying

Remark 10. Note that the above lemma holds for any value of the learning rate δ, and holds for every
eigen direction of H. Thus, for “large” values of momentum, the behavior of stochastic heavy ball does
degenerate to the behavior of stochastic gradient descent.

We now consider the setting where momentum is bounded away from 1.

Corollary 11. Consider B(2), by substituting τ = l/κ, x = δλmin = c(δσ2
mulating terms in varying powers of 1/κ, we obtain:

1)/κ in equation (2) and accu-

G(l)

def
=

1)2l3
c3(δσ2
κ5

+

l4 − 2c(δσ2

1)l3(1 + α) + (2α − 3c)c2(δσ2

1)2l2

−(3 + α)(1 − α)l3 − 2(1 + α)(2α − 3)c(δσ2

1)l2 + (3c − 4α + (2 − c)α2)c2(δσ2

1)2l

(3 − 4α − α2 + 2α3)l2 − 2c(δσ2

1)l(3 − α)(1 − α2) − c2(δσ2

1)2(1 − α)(c + (c − 2)α)

−(1 − α)2(1 − α2)l + 2c(δσ2

1)(1 − α)(1 − α2)

κ

(3)

Lemma 12. Let 2 < c < 3000, 0 ≤ α ≤ 1 − 450

κ , l = 1 + 2c(δσ2
1)
c+(c−2)α , this implies (δσ2
1)

1−α ≤ 2(1+α)

c+(c−2)α ≤ 4

1) ≤ 2(1−α2)

Proof. Since (δσ2

c , thus implying, 1 ≤ l ≤ 9.
Substituting the value of l in equation (3), the coefﬁcient of O(1/κ) is −(1 − α)3(1 + α).
We will bound this term along with (3 − 4α − α2 + 2α3)l2/κ2 = (1 − α)2(3 + 2α)l2/κ2 to obtain:

1−α . Then, G(l) ≤ 0.

κ4

κ3

κ2

+

+

+

−(1 − α)3(1 + α)
κ

+

(1 − α)2(3 + 2α)l2
κ2

+

405(1 − α)2
κ2
(cid:19)

− (1 − α2)

≤

≤

≤

−(1 − α)3(1 + α)
κ
(cid:18) 405
(1 − α)2
κ
κ
(cid:18) 405
(1 − α)2
κ
κ

(cid:19)

− (1 − α)

≤ −

45 · 4502
κ4

,

where, we use the fact that α < 1, l ≤ 9. The natural implication of this bound is that the terms that
are lower order, such as O(1/κ4) and O(1/κ5) will be negative owing to the large constant above. Let us

18

verify that this is indeed the case by considering the terms having powers of O(1/κ4) and O(1/κ5) from
equation (3):

l4 − 2c(δσ2

1)l3(1 + α) + (2α − 3c)c2(δσ2

1)2l2

−

45 · 4502
κ4

+

c3(δσ2
1)2l3
κ5
c3(δσ2
1)2l3
κ5

≤

≤

cl3
κ5 +

+

l4
45 · 4502
κ4 −
κ4
(94 − (45 · 4502))
κ4

≤

κ4

93c + 94 − (45 · 4502)
κ4

The expression above evaluates to ≤ 0 given an upperbound on the value of c. The expression above follows
from the fact that l ≤ 9, κ ≥ 1.

Next, consider the terms involving O(1/κ3) and O(1/κ2), in particular,

Next,

1)2(1 − α)(c + (c − 2)α)

1)2l

c2(δσ2

(3c − 4α + (2 − c)α2)c2(δσ2
κ3
(cid:0) l(3c + 2)
κ
− (1 − α)(c + (c − 2)α)(cid:1)

1)2

1)2

≤

≤

−

− (1 − α)(c + (c − 2)α)(cid:1)

κ2

c2(δσ2
κ2
c2(δσ2
κ2
c2(δσ2
κ2
c3(δσ2
κ2
c3(δσ2
κ2

1)2

1)2

1)2

≤

≤

≤

(cid:0) 5cl
κ
(cid:0) 5cl
κ
(cid:0) 5l
κ
−405
κ

−

·

− (1 − α)c(cid:1)

(cid:1)

450
κ

≤ 0.

2c(δσ2

1)l(3 − α)(1 − α2)

κ2

(cid:19)

− (3 − α)(1 − α)

−2(1 + α)(2α − 3)c(δσ2
κ3

1)l2

−

(cid:18) −(2α − 3)l
κ

(cid:19)

− 2(1 − α)

≤

≤

≤

≤

1)l

1)l

1)l

2(1 + α)c(δσ2
κ2
2(1 + α)c(δσ2
κ2
2(1 + α)c(δσ2
κ2
2(1 + α)c(δσ2
κ2

1)l

(cid:18) 3l
κ
(cid:18) 3l
κ
(cid:18) 3 · 27
κ

−

(cid:19)

2 · 450
κ
2 · 450
κ

−

(cid:19)

≤ 0.

In both these cases, we used the fact that α ≤ 1 − 450
terms are negative.

κ implying −(1 − α) ≤ −450

κ . Finally, other remaining

Before rounding up the proof of the proposition, we need the following lemma to ensure that our lower
bounds on the largest eigenvalue of B indeed affect the algorithm’s rates and are true irrespective of where
the algorithm is begun. Note that this allows our result to be much stronger than typical optimization
lowerbounds that rely on speciﬁc initializations to ensure a component along the largest eigendirection of
the update operator, for which bounds are proven.

19

Lemma 13. For any starting iterate w0 (cid:54)= w∗, the HB method produces a non-zero component along the
largest eigen direction of B.

(cid:105)

(cid:104)
θ(j)
· ⊗ θ(j)

Proof. We note that in a similar manner as other proofs, it sufﬁces to argue for each dimension of the prob-
lem separately. But before we start looking at each dimension separately, let us consider the jth dimension,
and detail the approach we use to prove the claim: the idea is to examine the subspace spanned by covariance
E
and prove that the
largest eigenvector of the expected operator B(j) is not orthogonal to this subspace. This implies that there
exists a non-zero component of E
in the largest eigen direction of B(j), and this decays at a
rate that is at best λmax(B(j)).

2 , ..., for every starting iterate θ(j)

of the iterates θ(j)

(cid:104)
· ⊗ θ(j)
θ(j)

(cid:54)= (cid:2)0, 0(cid:3)(cid:62)

1 , θ(j)

0 , θ(j)

(cid:105)

0

·

·

Since B(j) ∈ R4×4, we begin by examining the expected covariance spanned by the iterates θ(j)

0 , θ(j)

1 , θ(j)

2 , θ(j)
3 .

Let w(j)

0 − (w∗)(j) = w(j)

−1 − (w∗)(j) = k(j). Now, this implies θ(j)
(cid:34)

(cid:35)

1 = k(j) (cid:98)A(j)
θ(j)

1

, with (cid:98)A(j)

1 =

(cid:21)

(cid:20)1
1

1 + α − δ (cid:98)H(j)
1

1 −α
0

0 = k(j) · (cid:2)1, 1(cid:3)(cid:62)

. Then,

, where (cid:98)H(j)

1 = (a(j)

1 )2.

This implies that k just appears as a scale factor. This in turn implies that in order to analyze the subspace
spanned by the covariance of iterates θ(j)
1 , ..., we can assume k(j) = 1 without any loss in generality.
0 = (cid:2)1, 1(cid:3)(cid:62)
This implies, θ(j)
. Note that with this in place, we see that we can now drop the superscript j
that represents the dimension, since the analysis decouples across the dimensions j ∈ {1, 2}. Furthermore,
Next, denote 1 + α − δ (cid:98)Hk = ˆtk. This
let the entries of the vector θk be represented as θk
implies,

0 , θ(j)

def= (cid:2)θk1

θk2

(cid:3)(cid:62)

(cid:98)Ak =

(cid:21)

(cid:20)ˆtk −α
0
1

.

Furthermore,

θ1 = (cid:98)A1θ0 =

(cid:21)

(cid:20)ˆt1 − α
1

θ3 = (cid:98)A3θ2 =

(cid:21)

(cid:20)ˆt2(ˆt1 − α) − α
ˆt1 − α

, θ2 = (cid:98)A2θ1 =
(cid:21)
(cid:20)ˆt3(ˆt2(ˆt1 − α) − α) − α(ˆt1 − α)
ˆt2(ˆt1 − α) − α

,

.

(4)

Let us consider the vectorized form of Φj = E [θj ⊗ θj], and we denote this as vec(Φj). Note that vec(Φj)
makes Φj become a column vector of size 4 × 1. Now, consider vec(Φj) for j = 0, 1, 2, 3 and concatenate
these to form a matrix that we denote as D, i.e.

D = (cid:2)vec(Φ0) vec(Φ1) vec(Φ2) vec(Φ3)(cid:3) .

Now, since we note that Φj is a symmetric 2×2 matrix, D should contain two identical rows implying that it
has an eigenvalue that is zero and a corresponding eigenvector that is (cid:2)0 −1/
. It turns
out that this is also an eigenvector of B with an eigenvalue α. Note that det(B) = α4. This implies there are
two cases that we need to consider: (i) when all eigenvalues of B have the same magnitude (= α). In this
case, we are already done, because there exists at least one non zero eigenvalue of D and this should have
some component along one of the eigenvectors of B and we know that all eigenvectors have eigenvalues

2 1/(cid:112)(2) 0(cid:3)(cid:62)

√

20

with a magnitude equal to λmax(B). Thus, there exists an iterate which has a non-zero component along
the largest eigendirection of B. (ii) the second case is the situation when we have eigenvalues with different
magnitudes. In this case, note that det(B) = α4 < (λmax(B))4 implying λmax(B) > α. In this case, we
need to prove that D spans a three-dimensional subspace; if it does, it contains a component along the largest
eigendirection of B which will round up the proof. Since we need to understand whether D spans a three
dimensional subspace, we can consider a different (yet related) matrix, which we call R and this is deﬁned
as:

R def= E

(cid:18)





θ2
01
θ01θ02
θ2
02

θ2
11
θ11θ12
θ2
12

(cid:19)





θ2
21
θ21θ22
θ2
22

Given the expressions for {θj}3
R has the following expression:

j=0 (by deﬁnition of θ0 and using equation 4), we can substitute to see that

R =

1 E (cid:2)(ˆt1 − α)2(cid:3)

E (cid:2)ˆt1 − α(cid:3)
1

1
1

E (cid:2)(ˆt2(ˆt1 − α) − α)2(cid:3)

E (cid:2)((ˆt2(ˆt1 − α) − α))(ˆt1 − α)(cid:3)
E (cid:2)(ˆt1 − α)2(cid:3)

 .

If we compute and prove that det(R) (cid:54)= 0, we are done since that implies that R has three non-zero eigen-
values.

This implies, we ﬁrst deﬁne the following: let qγ = (t − γ)2 + (c − 1)x2. Then, R can be expressed as:

det(R) = det

(cid:18)

(cid:18)

(cid:18)

(cid:18)

1

1

qα

qα


1
1 t − α

1

1
1 t − α

1

1
1 t − α − 1

1

0
0 t − α − 1

1

qα − 1

qα − 1

0

0

= det

= det

= det

q0qα − 2αt(t − α) + α2
tqα − α(t − α)
qα

(cid:19)





qα(q0 − qα) − 2αt(t − α) + α2
tqα − α(t − α) − (t − α)qα
0

(cid:19)





qα(q0 − qα) − 2αt(t − α) + α2
tqα − α(t − α) − (t − α)qα
0
qα(q0 − qα) − 2αt(t − α) + α2
tqα − α(t − α) − (t − α)qα
0

(cid:19)

(cid:19)









Note: (i) qα −1 = (t−α)2 −1+(c−1)x2 = (1−x)2 −1+(c−1)x2 = −2x+x2 +(c−1)x2 = −2x+cx2.
(ii) t − α − 1 = −x
(iii) α(qα − (t − α)) = α((t − α)2 − (t − α) + (c − 1)x2) = α((1 − x)(−x) + (c − 1)x2) = αx(−1 + cx)
(iv) q0 − qα = t2 − (t − α)2 = α(2t − α) = 2tα − α2.
Then,

(2αt − α2)qα − 2αt(t − α) + α2 = 2tα(qα − (t − α)) + α2(1 − qα)
= 2tα(−x + cx2) − α2(−2x + cx2)
= −2tαx + 2xα2 + 2tαcx2 − cα2x2
= 2αx(−t + α) + cαx2(2t − α)

21

Then,

Then,

= −2αx(1 − x) + 2cαx2(1 − x) + cα2x2
= 2αx(1 − x)(−1 + cx) + cα2x2.

det(R) = det



(cid:18)

0 x(cx − 2) 2αx(1 − x)(−1 + cx) + cα2x2
0

1

αx(cx − 1)
0

−x
0

(cid:19)





= x2αdet

(cid:18)

= x3αdet



(cid:18)

−1
0

0 (cx − 2)
0

1

c
0
0 −1

0
1

cαx + 2(1 − x)(cx − 1)
cx − 1
0


(cid:19)





cα − 2(cx − 1)
cx − 1
0



(cid:19)

det(R) = x3α

c(−1 + cx) − 2(−1 + cx) + cα

(cid:19)

= αx3

(c − 2)(−1 + cx) + cα

(cid:19)

(cid:18)

(cid:18)

Note that this determinant can be zero when

α =

(c − 2)(1 − cx)
c

.

(5)

We show this is not possible by splitting our argument into two parts, one about the convergent regime of
the algorithm (where, δσ2
c+(c−2)α ) and the other about the divergent regime.
Let us ﬁrst provide a proof for the convergent regime of the algorithm. For this regime, let the chosen
1/κ. Suppose α was

δ be represented as δ+. Now, for the smaller eigen direction, x = δ+λmin = cδ+σ2
chosen as per equation 5,

1 < 2(1−α2)

We will now prove that δ+σ2
HB updates, i.e., δσ2
admissible value of α, we are done.

c − α
c ( 1
c+(c−2)α ≤ 2(1−α2)

1 < 2(1−α2)

1 = κ

c

c−2 ) is much larger than one allowed by the convergence of the
for any

. In particular, if we prove that κ

c−2 ) > 2(1−α2)

c − α

c ( 1

c

cα
c − 2
=⇒ δ+σ2

= 1 −

1 =

κ
c2 −

c2δ+σ2
1
κ
κα
c(c − 2)

.

κ
c

(

⇔

1
c
κ
c

>

−

α
c − 2
κα
c − 2
κα
c

−

−

κ
c

) >

2(1 − α2)
c

> 2 − 2α2

> 2 − 2α2

⇔

−

κ
c

κα
c − 2

22

⇔ κ − κα > 2c − 2cα2
⇔ 2cα2 − κα + (κ − 2c) > 0.

The two roots of this quadratic equation are α+ = κ
2c − 1 and α− = 1. Note that κ ≥ (cid:101)κ = c; note that there
is not much any method gains over SGD if κ = O(c). And, for any κ ≥ 4c, note, α+ > α−, indicating that
the above equation holds true if α > α+ = κ
2c − 1 or if α < α− = 1. The latter condition is true and hence
the proposition that δ+σ2
c+(c−2)α is true.

1 > 2(1−α2)

We need to prove that the determinant does not vanish in the divergent regime for rounding up the proof

to the lemma.

Now, let us consider the divergent regime of the algorithm, i.e., when, δσ2

1 > 2(1−α2)

1− cα
c−2

c+(c−2)α . Furthermore, for
1 =
c−2 (obtained by substituting
c − α
c−2 for all admissible values of c, we are done.

c = 1

c − α

the larger eigendirection, the determinant is zero when δσ2
1 in equation 5). If we show that 2(1−α2)
x = δσ2
We will explore this in greater detail:

c+(c−2)α > 1

2(1 − α2)
c + (c − 2)α

>

−

1
c

⇔ 2(1 − α2) ≥ 1 +

α
c − 2
c − 2
c

⇔ 1 − α2 ≥

−4(c − 1)
c(c − 2)

α

α −

c
c − 2

α − α2

⇔ c2 − 2c − α2c2 + 2cα2 ≥ −4cα + 4α

⇔ c2(1 − α2) − 2c(1 − α2 − 2α) − 4α ≥ 0.

considering the quadratic in the left hand size and solving it for c, we have:

c± =

2(1 − α2 − 2α) ± (cid:112)4(1 − α2 − 2α)2 + 16α(1 − α2)
2(1 − α2)

(1 − α2 − 2α) ± (cid:112)(1 − α2 − 2α)2 + 4α(1 − α2)
(1 − α2)

(1 − α2 − 2α) ± (cid:112)1 + α4 + 4α2 − 2α2 − 4α + 4α3 + 4α(1 − α2)
(1 − α2)

=

=

=

(1 − α2 − 2α) ± (1 + α2)
(1 − α2)

This holds true iff

or iff,

c ≤ c− =

−2α(1 + α)
1 − α2

=

−2α
1 − α

,

c ≥ c+ =

2(1 − α)
1 − α2 =

2
1 + α

.

Which is true automatically since c > 2. This completes the proof of the lemma.

We are now ready to prove Lemma 5.

Proof of Lemma 5. Combining Lemmas 9 and 12, we see that no matter what stepsize and momentum we
choose, B(j) has an eigenvalue of magnitude at least 1− 500

κ for some j ∈ {1, 2}. This proves the lemma.

23

B Equivalence of Algorithm 3 and ASGD

We begin by writing out the updates of ASGD as written out in Jain et al. (2017), which starts with two
iterates (cid:98)a0 and (cid:98)d0, and from time t = 0, 1, ...T − 1 implements the following updates:

(cid:98)bt = α1(cid:98)at + (1 − α1) (cid:98)dt
(cid:98)at+1 = (cid:98)bt − δ1 ˆ∇ft+1((cid:98)bt)
(cid:98)ct = β1(cid:98)bt + (1 − β1) (cid:98)dt
(cid:98)dt+1 = (cid:98)ct − γ1 ˆ∇ft+1((cid:98)bt).
√

(6)

(7)

(8)

(9)

Next, we specify the step sizes β1 = c2
κ(cid:101)κ, α1 = c3/(c3 + β), γ1 = β/(c3λmin) and δ1 = 1/R2, where
3/
κ = R2/λmin. Note that the step sizes in the paper of Jain et al. (2017) with c1 in their paper set to 1 yields
the step sizes above. Now, substituting equation 8 in equation 9 and substituting the value of γ1, we have:

(cid:98)dt+1 = β1

(cid:98)bt −

ˆ∇ft+1((cid:98)bt)

+ (1 − β1) (cid:98)dt

(cid:18)

(cid:18)

1
c3λmin
δκ
c3

(cid:19)

(cid:19)

= β1

(cid:98)bt −

ˆ∇ft+1((cid:98)bt)

+ (1 − β1) (cid:98)dt.

(10)

We see that (cid:98)dt+1 is precisely the update of the running average ¯wt+1 in the ASGD method employed in this
paper.

We now update (cid:98)bt to become (cid:98)bt+1 and this can be done by writing out equation 6 at t + 1, i.e:

(cid:98)bt+1 = α1(cid:98)at+1 + (1 − α1) (cid:98)dt+1
(cid:17)
(cid:16)
(cid:98)bt − δ1 ˆ∇ft+1((cid:98)bt)

= α1

+ (1 − α1) (cid:98)dt+1.

(11)

By substituting the value of α1 we note that this is indeed the update of the iterate as a convex combination
of the current running average and a short gradient step as written in this paper. In this paper, we set c3 to
be equal to 0.7, and any constant less than 1 works. In terms of variables, we note that α in this paper’s
algorithm description maps to 1 − β1.

C More details on experiments

In this section, we will present more details on our experimental setup.

C.1 Linear Regression

In this section, we will present some more results on our experiments on the linear regression problem. Just
as in Appendix A, it is indeed possible to compute the expected error of all the algorithms among SGD,
HB, NAG and ASGD, by tracking certain covariance matrices which evolve as linear systems. For SGD, for
instance, denoting ΦSGD
, where
t
B is a linear operator acting on d×d matrices such that B ◦M def= M −δHM −δM H +δ2E (cid:2)(cid:104)x, M x(cid:105) xx(cid:62)(cid:3).
Similarly, HB, NAG and ASGD also have corresponding operators (see Appendix A for more details on the
operator corresponding to HB). The largest magnitude of the eigenvalues of these matrices indicate the rate
of decay achieved by the particular algorithm – smaller it is compared to 1, faster the decay.

− w∗(cid:1)(cid:3), we see that ΦSGD

t+1 = B ◦ ΦSGD

− w∗(cid:1) ⊗ (cid:0)wSGD

def= E (cid:2)(cid:0)wSGD

t

t

t

24

We now detail the range of parameters explored for these results: the condition number κ was varied
from {24, 25, .., 228} for all the optimization methods and for both the discrete and gaussian problem. For
each of these experiments, we draw 1000 samples and compute the empirical estimate of the fourth moment
tensor. For NAG and HB, we did a very ﬁne grid search by sampling 50 values in the interval (0, 1] for both
the learning rate and the momentum parameter and chose the parameter setting that yielded the smallest
λmax(B) that is less than 1 (so that it falls in the range of convergence of the algorithm). As for SGD and
ASGD, we employed a learning rate of 1/3 for the Gaussian case and a step size of 0.9 for the discrete case.
The statistical advantage parameter of ASGD was chosen to be (cid:112)3κ/2 for the Gaussian case and (cid:112)2κ/3
for the Discrete case, and the a long step parameters of 3κ and 2κ were chosen for the Gaussian and Discrete
case respectively. The reason it appears as if we choose a parameter above the theoretically maximal allowed
value of the advantage parameter is because the deﬁnition of κ is different in this case. The κ we speak about
for this experiment is λmax/λmin unlike the condition number for the stochastic optimization problem. In a
manner similar to actually running the algorithms (the results of whose are presented in the main paper), we
also note that we can compute the rate as in equation 1 and join all these rates using a curve and estimate its
slope (in the log scale). This result is indicated in table 3.

Figure 7 presents these results, where for each method, we did grid search over all parameters and
chose parameters that give smallest λmax. We see the same pattern as in Figure 1 from actual runs –
SGD,HB and NAG all have linear dependence on condition number κ, while ASGD has a dependence
of

κ.

√

Figure 7: Expected rate of error decay (equation 1) vs condition number for various methods for the linear
regression problem. Left is for discrete distribution and right is for Gaussian distribution.

C.2 Autoencoders for MNIST

We begin by noting that the learning rates tend to vary as we vary batch sizes, which is something that is
known in theory (Jain et al., 2016). Furthermore, we extend the grid especially whenever our best parameters
of a baseline method tends to land at the edge of a grid. The parameter ranges explored by our grid search
are:

Batch Size 1: (parameters chosen by running for 20 epochs)

• SGD: learning rate: {0.01, 0.01

10, 0.1, 0.1

10, 1,

10, 5, 10, 20, 10

10, 40, 60, 80, 100.

√

√

√

√

25

Algorithm Slope – discrete

Slope – Gaussian

SGD
HB
NAG
ASGD

0.9990
1.0340
1.0627
0.4923

0.9995
0.9989
1.0416
0.4906

Table 3: Slopes (i.e. γ) obtained by ﬁtting a line to the curves in Figure 7. A value of γ indicates that the
error decays at a rate of exp (cid:0) −t
κγ

(cid:1). A smaller value of γ indicates a faster rate of error decay.

• NAG/HB: learning rate: {0.01

10, 0.1, 0.1

10, 1,

10, 10}, momentum {0, 0.5, 0.75, 0.9, 0.95, 0.97}.

√

√

√

• ASGD: learning rate: {2.5, 5}, long step {100.0, 1000.0}, advantage parameter {2.5, 5.0, 10.0, 20.0}.

Batch Size 8: (parameters chosen by running for 50 epochs)

• SGD: learning rate: {0.001, 0.001

10.0, 0.01, 0.01

10, 0.1, 0.1

10, 1,

10, 5, 10

√

√

√

√

√

, 10

10, 40, 60, 80, 100, 120, 140}.

• NAG/HB: learning rate: {5.0, 10.0, 20.0, 10

10, 40, 60}, momentum {0, 0.25, 0.5, 0.75, 0.9, 0.95}.

√

• ASGD: learning rate {40, 60}. For a long step of 100, advantage parameters of {1.5, 2, 2.5, 5, 10, 20}.

For a long step of 1000, we swept over advantage parameters of {2.5, 5, 10}.

C.3 Deep Residual Networks for CIFAR-10

In this section, we will provide more details on our experiments on cifar-10, as well as present some ad-
ditional results. We used a weight decay of 0.0005 in all our experiments. The grid search parameters we
used for various algorithms are as follows. Note that the ranges in which parameters such as learning rate
need to be searched differ based on batch size (Jain et al., 2016). Furthermore, we tend to extrapolate the
grid search whenever a parameter (except for the learning rate decay factor) at the edge of the grid has been
chosen; this is done so that we always tend to lie in the interior of the grid that we have searched on. Note
that for the purposes of the grid search, we choose a hold out set from the training data and add it in to the
training data after the parameters are chosen, for the ﬁnal run.

Batch Size 8: Note: (i) parameters chosen by running for 40 epochs and picking the grid search param-
eter that yields the smallest validation 0/1 error. (ii) The validation set decay scheme that we use is that if
the validation error does not decay by at least 1% every three passes over the data, we cut the learning rate
by a constant factor (which is grid searched as described below). The minimal learning rate to use is ﬁxed
to be 6.25 × 10−5, so that we do not decay far too many times and curtail progress prematurely.

• SGD: learning rate: {0.0033, 0.01, 0.033, 0.1, 0.33}, learning rate decay factor {5, 10}.

• NAG/HB: learning rate: {0.001, 0.0033, 0.01, 0.033}, momentum {0.8, 0.9, 0.95, 0.97}, learning rate

decay factor {5, 10}.

learning rate decay factor {5, 10}.

• ASGD: learning rate {0.01, 0.0330, 0.1}, long step {1000, 10000, 50000}, advantage parameter {5, 10},

26

Batch Size 128: Note: (i) parameters chosen by running for 120 epochs and picking the grid search
parameter that yields the smallest validation 0/1 error. (ii) The validation set decay scheme that we use
is that if the validation error does not decay by at least 0.2% every four passes over the data, we cut the
learning rate by a constant factor (which is grid searched as described below). The minimal learning rate to
use is ﬁxed to be 1 × 10−3, so that we do not decay far too many times and curtail progress prematurely.

• SGD: learning rate: {0.01, 0.03, 0.09, 0.27, 0.81}, learning rate decay factor {2,

10, 5}.

√

• NAG/HB: learning rate: {0.01, 0.03, 0.09, 0.27}, momentum {0.5, 0.8, 0.9, 0.95, 0.97}, learning rate

decay factor {2,

10, 5}.

√

• ASGD: learning rate {0.01, 0.03, 0.09, 0.27}, long step {100, 1000, 10000}, advantage parameter

√

{5, 10, 20}, learning rate decay factor {2,

10, 5}.

As a ﬁnal remark, for any comparison across algorithms, such as, (i) ASGD vs. NAG, (ii) ASGD vs
HB, we ﬁx the starting learning rate, learning rate decay factor and decay schedule chosen by the best grid
search run of NAG/HB respectively and perform a grid search over the long step and advantage parameter
of ASGD. In a similar manner, when we compare (iii) SGD vs NAG or, (iv) SGD vs. HB, we choose the
learning rate, learning rate decay factor and decay schedule of SGD and simply sweep over the momentum
parameter of NAG or HB and choose the momentum that offers the best validation error.

We now present plots of training function value for different algorithms and batch sizes.
Effect of minibatch sizes: Figure 8 plots training function value for batch sizes of 128 and 8 for SGD,
HB and NAG. We notice that in the initial stages of training, NAG obtains substantial improvements com-
pared to SGD and HB for batch size 128 but not for batch size 8. Towards the end of training however, NAG
starts decreasing the training function value rapidly for both the batch sizes. The reason for this phenomenon
is not clear. Note however, that at this point, the test error has already stabilized and the algorithms are just
overﬁtting to the data.

Figure 8: Training loss for batch sizes 128 and 8 respectively for SGD, HB and NAG.

Comparison of ASGD with momentum methods: We now present the training error plots for ASGD com-

pared to HB and NAG in Figures 9 and 10 respectively. As mentioned earlier, in order to see a clear trend,
we constrain the learning rate and decay schedule of ASGD to be the same as that of HB and NAG respec-
tively, which themselves were learned using grid search. We see similar trends as in the validation error
plots from Figures 5 and 6. Please see the ﬁgures and their captions for more details.

27

Figure 9: Training function value for ASGD compared to HB for batch sizes 128 and 8 respectively.

Figure 10: Training function value for ASGD compared to NAG for batch size 128 and 8 respectively.

28

