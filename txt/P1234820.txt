Benchmarks for Graph Embedding Evaluation

Palash Goyal∗, Di Huang∗, Ankita Goswami, Sujit Rokka Chhetri, Arquimedes Canedo, Emilio Ferrara

University of Southern California, Information Sciences Institute
4676 Admiralty Way, Suite 1001. Marina del Rey, CA. 90292, USA

9
1
0
2
 
g
u
A
 
6
2
 
 
]
I
S
.
s
c
[
 
 
3
v
3
4
5
6
0
.
8
0
9
1
:
v
i
X
r
a

Abstract

Graph embedding is the task of representing nodes of a graph in a low-dimensional space and its applications for graph tasks
have gained signiﬁcant traction in academia and industry. Variability in the embedding methods is often due to the diﬀerent
properties preserved by them. Majority of methods report performance boosts on few selected real graphs and the results are
thus not generalizable. In this work, we introduce a principled framework to compare them. Our goal is threefold: (i) provide a
framework to compare the performance of various graph embedding methods, (ii) establish a benchmark with real-world graphs that
exhibit diﬀerent structural properties, and (iii) provide users with a tool to identify the best embedding method for their data. We
evaluate the most inﬂuential graph embedding methods and traditional link prediction methods against a corpus of 100 real-world
networks with varying properties. We organize the networks based on their properties to draw insights into embedding performance.
We deﬁne GFS-score to quantify the performance of an approach and use it to rank the state-of-the-art embedding approaches.
We envision that the proposed framework (https://www.github.com/palash1992/GEM-Benchmark) will serve the community as a
benchmarking platform to test and compare the performance of future graph embedding techniques.

Keywords: Graph Embedding Benchmarks, Graph embedding techniques, Graph embedding applications, Python Graph
Embedding Methods GEM Library

1. Introduction

Graphs are a natural way to represent relationships and in-
teractions between entities in real systems. For example, peo-
ple on social networks, proteins in biological networks, and
authors in publication networks can be represented by nodes
in a graph, and their relationships such as friendships, protein-
protein interactions, and co-authorship are represented by edges
in a graph. These graphical models enable us to understand
the behavior of systems and to gain insight into their structure.
These insights can further be used to predict future interactions
and missing information in the system. These tasks are for-
mally deﬁned as link prediction and node classiﬁcation. Link
prediction estimates the likelihood of a relationship among two
entities. This is used, for example, to recommend friends on so-
cial networks and to sort probable protein-protein interactions
on biological networks. Similarly, node classiﬁcation estimates
the likelihood of a node’s label. This is used, for example, to
infer missing meta-data on social media proﬁles, and genes in
proteins.

Numerous graph analysis methods have been developed.
Broadly, these methods can be categorized as non-parametric
and parametric. Non-parametric methods operate directly on
the graph whereas parametric methods represent the properties
of nodes and edges in the graph in a low-dimensional space.
Non-parametric methods such as Common Neighbors [1], Adamic-
Adar [2] and Jaccard’s coeﬃcient [3] require access and knowl-

∗These authors contributed equally to this work.

Preprint submitted to Information Sciences

edge of the entire graph for the prediction. On the other hand,
parametric models such as Thor et. al. [4] employ graph sum-
marization and deﬁne super nodes and super edges to perform
link prediction. Kim et. al. [5] use Expectation Maximiza-
tion to ﬁt the real network as a Kronecker graph and estimate
the parameters. Another class of parametric models that have
gained much attention recently are graph embeddings [6, 7,
8]. Graph embedding methods deﬁne a low-dimensional vec-
tor for each node and a distance metric on the vectors. These
methods learn the representation by preserving certain prop-
erties of the graph. Graph Factorization [9] preserves visible
links, HOPE [10] aims to preserve higher order proximity, and
node2vec [11] preserves both structural equivalence and higher
order proximity. In this paper, we focus our attention on graph
embedding methods. While this is a very active area of research
that continues to gain popularity among researchers, there are
several challenges that must be addressed before graph embed-
ding algorithms become mainstream.

1.1. Challenges

Most research on graph embedding has focused on the de-
velopment of mechanisms to preserve various characteristics of
the graph in the low-dimensional space. However, very little at-
tention has been dedicated to the development of mechanisms
to rigorously compare and evaluate diﬀerent graph embedding
methods. To make matters worse, most of the existing work
use simple synthetic data sets for visualization and a few real
networks for quantitative comparison. Goyal et. al. [6] use

August 28, 2019

Stochastic Block Models to visualize the results of graph em-
bedding methods. Salehi at. al. [12] use the Barabasi-Albert
graph to understand the properties of embeddings. Such evalu-
ation strategy suﬀers from the following challenges:

1. Properties of real networks vary according to the domain.
Therefore it is often diﬃcult to ascertain the reason be-
hind the performance improvement of a given method on
a particular real dataset (as shown in [6]).

2. As demonstrated in this paper, the performance of em-
bedding approaches vary greatly, and according to the
properties of diﬀerent graphs. Therefore, the utility of
any speciﬁc method is diﬃcult to establish and to char-
acterize. In practice, the performance improvement of a
method can be attributed to stochasticity.

3. Diﬀerent methods use diﬀerent metrics for evaluation.
This makes it very diﬃcult to compare the performance
of diﬀerent graph embedding methods on a given prob-
lem.

4. Typically, each graph embedding method has a reference
implementation. This implementation makes speciﬁc as-
sumptions about the data, representation, etc. This fur-
ther complicates the comparison between methods.

1.2. Contributions

In this work, we aim to: (i) provide a unifying framework
for comparing the performance of state-of-the-art and future
graph embedding methods; (ii) establish a benchmark com-
prised of 100 real-world graphs that exhibit diﬀerent structural
properties; and (iii) provide users with a fully automated Python
library that selects the best graph embedding method for their
graph data. We address the above challenges (Section 1.1) with
the following contributions:

1. We propose an evaluation benchmark to compare and
evaluate embedding methods. This benchmark consists
of 100 real-world graphs, largely a subset of the Com-
munityFitNet corpus [13] with a few additional net-
works drawn from the Stanford Network Analysis Project
(SNAP) [14]. The benchmark categorizes networks in
four domains: social, biology, technological and eco-
nomic, based on the taxonomy provided by the Index of
Complex Networks (ICON) [15].

2. Using our evaluation benchmark, we evaluate and com-
pare 8 state-of-the-art methods and provide, for the ﬁrst
time, a characterization of their performance against
graphs with diﬀerent properties. We also compare their
scores with traditional link prediction methods and ascer-
tain the general utility of embedding methods.

3. A new score, GFS-score, is introduced to compare var-
ious graph embedding methods for link prediction. The
GFS-score provides a robust metric to evaluate a graph
embedding approach by averaging over 100 graphs.
It
further has many components based on the type and prop-
erty of graph yielding insights into the methods.

4. A Python library comprised of 4 state-of-the-art embed-
ding methods, and 4 traditional link prediction meth-
ods. This library automates the evaluation, comparison
against all the other methods, and performance plotting
of any new graph embedding method.

1.3. Organization

The rest of the work is organized as follows. Section 2
presents the notations used in the paper and and overview of
graph embeddings. Section 3 introduces the benchmark frame-
work, describes the real benchmark graphs, deﬁnes the GFS-
score. Section 4 presents the results and analysis. Section 5
introduces the Python library. Section 6 concludes.

2. Notations and Background

This section introduces the notation used in this paper, and
provides a brief overview of graph embedding methods. For
an in-depth analysis of graph embedding theory we refer the
reader to [6].

2.1. Notations

Table 1: Summary of notation

G

V

E

W

f

S

RD
D

M

em
A

d

Y

Graphical representation of the data

Set of vertices in the graph

Set of edges in the graph
Adjacency matrix of the graph, |V| × |V|

Embedding function

Set of synthetic graphs

Set of real graphs in domain D

Set of domains

Set of evaluation metrics

Evaluation function for metric m

Set of graph and embedding attributes

Number of embedding dimensions
Embedding of the graph, |V| × d

G(V, E) denotes a weighted graph where V is the set of ver-
tices and E is the set of edges. We represent W as the adjacency
matrix of G, where Wi j = 1 represents the presence of an edge
between i and j. A graph embedding is a mapping f : V− > Rd,
where d << |V| and the function f preserves some proximity
measure deﬁned on graph G. It aims to map similar nodes close
to each other. Function f when applied on the graph G yields
an embedding Y.

In this work, we evaluate four state-of-the-art graph embed-
ding methods on a set of real graphs denoted by R and synthetic
graphs denoted by S (the results for synthetic graphs are pre-
sented in the Appendix). To analyze the performance of meth-
ods, we categorize the graphs into a set of domains D = { So-
cial, Economic, Biology, Technological}. The set of graphs in
a domain D ∈ D is represented as RD. We use multiple eval-
uation metrics on graph embedding methods to draw insights
into each approach. We denote this set of metrics as M. The
notations are summarized in Table 1.

2

2.2. Graph Embedding Methods

Graph embedding methods embed graph vertices into a low-
dimensional space. The goal of graph embedding is to preserve
certain properties of the original graph such as distance between
nodes and neighborhood structure. Based upon the function f
used for embedding the graph, existing methods can be classi-
ﬁed into three categories [6]: factorization based, random walk
based and deep learning based.

2.2.1. Factorization based approaches

Factorization based approaches apply factorization on graph
related matrices to obtain the node representation. Graph ma-
trices such as the adjacency matrix, Laplacian matrix, and Katz
similarity matrix contain information about node connectivity
and the graph’s structure. Other matrix factorization approaches
use the eigenvectors from spectral decomposition of a graph
matrix as node embeddings. For example, to preserve local-
ity, LLE [16] uses d eigenvectors corresponding to eigenvalues
from second smallest to (d + 1)th smallest from the sparse ma-
trix (I − W)(cid:124)(I − W). It assumes that the embedding of each
node is a linear weighted combination of the neighbor’s em-
beddings. Laplacian Eigenmaps [17] take the ﬁrst d eigenvec-
tors with the smallest eigenvalues of the normalized Laplacian
D−1/2LD−1/2. Both LLE and Laplacian Eigenmaps were de-
signed to preserve the local geometric relationships of the data.
Another type of matrix factorization methods learn node em-
beddings under diﬀerent optimization functions in order to pre-
serve certain properties. Structural Preserving Embedding [18]
builds upon Laplacian Eigenmaps to recover the original graph.
Cauchy Graph Embedding [19] uses a quadratic distance for-
mula in the objective function to emphasize similar nodes in-
stead of dissimilar nodes. Graph Factorization [9] uses an ap-
proximation function to factorize the adjacency matrix in a more
scalable manner. GraRep [20] and HOPE [21] were invented to
keep the high order proximity in the graph. Factorization based
approaches have been widely used in practical applications due
to their scalability. The methods are also easy to implement and
can yield quick insights into the data set.

2.2.2. Random walk approaches

Random walk based algorithms are more ﬂexible than fac-
torization methods to explore the local neighborhood of a node
for high-order proximity preservation. DeepWalk [22] and
Node2vec [11] aim to learn a low-dimensional feature repre-
sentation for nodes through a stream of random walks. These
random walks explore the nodes’ variant neighborhoods. Thus,
random walk based methods are much more scalable for large
graphs and they generate informative embeddings. Although
very similar in nature, DeepWalk simulates uniform random
walks and Node2vec employs search-biased random walks,
which enables embedding to capture the community or struc-
tural equivalence via diﬀerent bias settings. LINE [23] com-
bines two phases for embedding feature learning: one phase
uses a breadth-ﬁrst search (BFS) traversal across ﬁrst-order
neighbors, and the second phase focuses on sampling nodes
from second-order neighbors. HARP [24] improves DeepWalk

and Node2vec by creating a hierarchy for nodes and using the
embedding of the coarsened graph as a better initialization in
the original graph. Walklets [25] extended Deepwalk by us-
ing multiple skip lengths in random walking. Random walk
based approaches tend to be more computationally expensive
than factorization based approaches but can capture complex
properties and longer dependencies between nodes.

2.2.3. Neural network approaches

The third category of graph embedding approaches is based
on neural networks. Deep neural networks based approaches
capture highly non-linear network structure in graphs, which
is neglected by factorization based and random walk based
methods. One type of deep learning based methods such as
SDNE [10] uses a deep autoencoder to provide non-linear func-
tions to preserve the ﬁrst and second order proximities jointly.
Similarly, DNGR [26] applies random surﬁng on input graph
before a stacked denoising autoencoder and makes the em-
bedding robust to noise in graphs. Another genre of methods
use Graph Neural Networks(GNNs) and Graph Convolutional
Networks (GCNs) [27, 28, 29, 30] to aggregate the neighbors
embeddings and features via convolutional operators, includ-
ing spatial or spectral ﬁlters. GCNs learn embeddings in a
semi-supervised manner and have shown great improvement
and scalability on large graphs compared to other methods.
SEAL [31] learns a wide range of link prediction heuristics
from extracted local enclosing subgraphs with GNN. DIFF-
POOL [32] employs a diﬀerentiable graph pooling module on
GNNs to learn hierarchical embeddings of graphs. Variational
Graph Auto-Encoders(VGAE) [33] utilizes a GCN as encoder
and inner product as decoder, which provides embedding with
higher quality than autoencoders. Deep neural network based
algorithms like SDNE and DNGR can be computational costly
since they require the global information such as adjacency ma-
trix for each node as input. GCNs based methods are more
scalable and ﬂexible to characterize global and local neighbours
through variant convolutional and pooling layers.

3. GEM-BEN: Graph Embedding Methods Benchmark

Unlike other ﬁelds with well established benchmark
datasets (e.g. community detection [34]), the graph embed-
ding community has adopted an ad-hoc approach to evaluate
new methods. Typically, graph embedding methods are evalu-
ated on only a few real networks, and these are biased towards
speciﬁc properties. This ad-hoc evaluation approach restricts
us from understanding how the algorithm would behave if we
vary a certain property of the graph, or how the algorithm per-
forms on other types of graphs.
In order to propose a more
rigorous evaluation approach, we must ﬁrst to understand the
key attributes that govern the performance of graph embedding
methods. First, the size of the graph (A1) is a challenge for any
method. Real graphs vary in the number of nodes, from a few
hundred to millions of nodes. Diﬀerent methods make diﬀerent
assumptions on how to capture the higher order proximities and
structural dependencies between nodes, and this greatly aﬀects

3

Figure 1: Real graphs properties.

their scalability. Second, the density of the graph (A2) plays an
important role in deﬁning its structure. Lower density results
in lesser information about the nodes which may hamper the
performance of some methods. Third, the dimension of the em-
bedding (A3) determines how concisely the method can store
the information about a given graph. Higher dimension of the
embedding may lead to overﬁtting of the graph whereas lower
dimension of the embedding may not be enough to capture the
information the graph provides resulting in underﬁtting. Fourth,
the evaluation metric (A4) used to evaluate the method captures
diﬀerent aspects of the prediction. Global metrics are often bi-
ased towards high degree nodes whereas local metrics can be
biased towards lower degree nodes.

In this paper, we take the ﬁrst step towards establishing a
graph embedding benchmark. We propose a benchmark evalu-
ation framework to answer the following questions:

• Q1: How does the performance of embedding methods

vary with the increasing size of the graph?

• Q2: How does increasing the density of graph aﬀect the

model?

• Q3: How does the optimal embedding dimension vary

with an increasing number of nodes in the graph?

• Q4: How does the performance vary with respect to the

evaluation metric?

To address the above questions, we construct and utilize a
benchmark of 100 real-world graphs, drawn from two large ex-
isting network corpora [13, 14], and vary the above attributes
(A1, ..., A4) in the graphs and the embedding methods. Varying

4

the size of the graph (A1) in terms of number of nodes answers
the ﬁrst question (Q1) and helps us understand which methods
are best when used in small, medium, and large graphs. Simi-
larly, varying the density of the graph (A2) in terms of the aver-
age degree of nodes helps us understand its eﬀect in the embed-
ding performance. This answers the second question (Q2). Fur-
thermore, varying the dimension of the embedding (A3) helps
us draw insights into the information compression power of the
embedding approach. This answers the third question (Q3). Fi-
nally, by varying the evaluation metrics (A4) we can analyze
the performance sensitivity of the method and can help us infer
the bias of the embedding method towards speciﬁc nodes int he
graph. This answers the fourth question (Q4).

3.1. Real Graphs

We use a benchmark corpus that contains 100 real-world
graphs, 86 of which are from the CommunityFitNet cor-
pus [13] and 14 are from the Stanford Network Analysis Project
(SNAP) [14]. These graphs are labeled by their domain of ori-
gin as social, biological, economic, and technological, follow-
ing the taxonomy given by the Index of Complex Networks
(ICON) [15]. We use Induced Subgraph Random Walk Sam-
pling (ISRW) [35] to sample some huge social graphs while
keeping the same graph density to ensure. To demonstrate the
usefulness of this benchmark, we evaluate eight graph embed-
ding methods and measure their performance. This provides
valuable insights about every method and their sensitivity to
diﬀerent graph properties. This paves the way towards a frame-
work that can be used to recommend the best embedding ap-
proaches for a given graph with a unique set of properties.

Figure 1 summarizes the main properties of the graphs from
diﬀerent domains in the data set. We observe that economic
graphs have a lower average density varying between 0.00160
and 0.00280 with a higher number of nodes concentrated in
lower density spectrum. Technological and social graphs are
denser with an average density between 0.0030 to 0.0160. It is
interesting to note that despite the wide average density range
densities are concentrated primarily in the lower and higher val-
ues with a gap in between. Biological graphs have an almost
uniform distribution of densities ranging from 0.005 to 0.0155.
Next, we observe the domain-wise pattern of diameters.
Economic graphs have the widest range(20 - 40) and the high-
est values of diameters which justiﬁes the lowest average den-
sities observed. Technological graphs with diameter ranges be-
tween 11 and 17.5 are less sparse when compared with eco-
nomic graphs. Biological graphs have a good combination of
both dense and sparse graphs with a majority of graphs lying
in small diameter range. Biological graphs typically have short
long diameter ranges as (8 to 12) and (16 to 18) respectively.
Social graphs have in general a lower diameter around 10 al-
though some of them have higher diameters.

On further investigation, we observe that biological net-
works have the highest clustering tendencies with an average
clustering coeﬃcient as 0.10. However, economic graphs stand
in absolute contrast to them with very low clustering coeﬃ-
cient of 0.00016 as the highest recorded average clustering co-
eﬃcient. Technological networks are somewhere in between
the aforementioned extremes with 0.03 as the highest recorded
average clustering coeﬃcients. Clustering tendencies can be
sought to have a high correlation with average density and di-
ameter observations.

Note that these 100 graphs include a very diverse set of
graphs in terms of the size of the graph (A1) ranging from 200
to 1500 nodes, and in terms of the density of the graph (A2)
ranging from an average density between 0.0015 to 0.020. As
it will be shown in Section 4, this graph diversity is helpful in
characterizing the performance of diﬀerent embedding meth-
ods.

3.2. Evaluation Metrics

In the graph embedding literature, there are two primary
metrics that are used to evaluate the performance of the meth-
ods on link prediction: (i) Precision at k (P@k) and (ii) Mean
Average Precision (MAP). These metrics are deﬁned as fol-
lows:

P@k is the fraction of correct predictions in the top k predic-
tions. It is deﬁned as P@k = |E pred(1:k)∩Eobs|
, where E pred(1 : k)
are the top k predictions and Eobs are the observed edges/hidden
edges.

k

MAP estimates the prediction precision for every node and

computes the prediction average over all nodes, as follows:

(cid:80)

MAP =

i AP(i)
|V|
k P@k(i)·I{E predi (k)∈Eobsi
}
|{k:E predi (k)∈Eobsi

,

(cid:80)

, P@k(i) = |E predi (1:k)∩Eobsi
where AP(i) =
,
}|
and E predi and Eobsi are the predicted and observed edges for
node i respectively.

k

|

5

Intuitively, P@k is a global metric that measures the accu-
racy of the most likely links predicted. On the other hand, MAP
measures the accuracy of prediction for each node and com-
putes their average. These metrics are often uncorrelated and
reﬂect the properties captured by the prediction method at dif-
ferent levels (MAP on local level and P@k on global level). In
this work, we present results using both these metrics to analyze
each approach.

3.3. GFS-score

We now deﬁne a set of scores to evaluate a graph embed-
ding model on our data set. The scores are divided into compo-
nents to draw insights into a method’s approach across domains
and metrics. We further plot the metrics varying various graph
properties to understand the sensitivity of the models to these
properties.

Given a set of graph domains D, a set of evaluation metrics
M and evaluation function em(graph, approach) for m ∈ M,
we deﬁne GFS-score for an approach a as follows:

micro − GFS − m(a) =

(cid:80)

g∈G(em(g, a)/em(g, random))
|G|

,

macro − GFS − m(a) =

(cid:80)

d∈D GFS − m(d, a)
|D|

,

(cid:80)

GFS − m(d, a) =

g∈Gd (em(g, a)/em(g, random))
|Gd|
where Gd is the set of graphs in domain d.

,

The GFS-score is a robust score which averages over a set
of real graphs with varying properties. It is normalized in order
to ascertain the gain in performance with respect to a random
prediction. The domain scores provide insights into the appli-
cability of each approach to the diﬀerent graph categories.

(1)

(2)

(3)

3.4. Link Prediction Baselines

Our link prediction baselines were selected to showcase the
utility of embedding approaches on real graphs and establish
the ground truth for comparison between the state-of-the-art
methods. The link prediction baselines are:

Preferential Attachment: [36] is based on the assumption
that the connection to a node is proportional to its degree. It
deﬁnes the similarity between the nodes as the product of their
degrees.

Common Neighbors: [1] deﬁnes the similarity between

nodes as the number of common neighbors between them.

Adamic-Adar: [2] is based on the intuition that common
neighbors with very large neighbourhoods are less signiﬁcant
than common neighbors with small neighborhoods when pre-
dicting a connection between two nodes. Formally, it is deﬁned
as the sum of the inverse logarithmic degree centrality of the
neighbours shared by the two nodes.

Jaccard’s Coeﬃcient: [37] measures the probability that
two nodes i and j have a connection to node k, for a randomly
selected node k from the neighbors of i and j .

3.5. Embedding Approaches

We illustrate the benchmark data set on four popular graph
embedding techniques to illustrate the utility of the benchmark
and rank the state-of-the-art embedding approaches. The tech-
niques preserve various properties including local neighbor-
hood, higher order proximity and structure.

Laplacian Eigenmaps [17]:

It penalizes the weighted
square of distance between neighbors. This is equivalent to fac-
torizing the normalized Laplacian matrix.

Graph Factorization (GF) [9]: It factorizes the adjacency

matrix with regularization.

Higher Order Proximity Preserving [21] (HOPE): It fac-
torizes the higher order similarity matrix between nodes using
generalized singular value decomposition.

Structural Deep Network Embedding (SDNE) [10]: It
uses deep autoencoder along with Laplacian Eigenmaps objec-
tive to preserve ﬁrst and second order proximities.

4. Experiments and Analysis

This section evaluates the performance of the baseline and
state-of-the-art methods on link prediction on the benchmark
graphs according to the methodology presented in Section 3.
First, we present the general results, and use subsections for an
in-depth analysis.

Figure 2 shows the MAP scores achieved by the eight meth-
ods when varying the size of the graph (A1) (256, 512, and 1024
nodes), the density of the graph (A2) (degree 3, 4, and 5), and
the dimension of the embedding (A3) (dimensions of 24, ..., 27).
We present the results for four graph categories: economic, bi-
ological, social and technological. To ensure the experiments
on an attribute are independent of other attributes, while vary-
ing the number of nodes, we keep the density within a small
range. For density, we consider all the graphs as it is indepen-
dent of number of nodes. The MAP scores shown are precision
scores averaged over all nodes, thus making the score unbiased
towards high degree nodes. However, as most real world graphs
have a long tail degree distribution it may be unfair to methods
which predict the top links in the graphs but fail for nodes with
less information. Overall, we observe that methods show con-
sistent performance across data sets from the same domain as
shown by the low variance. Further, the best embedding ap-
proaches obtain a MAP value of around 0.1 which is about 5
times improvement over the traditional link prediction methods.
Similarly, Figure 3 shows the P@100 values for the eight
link prediction methods using the same experimental setup.
P@k is a global metric which computes the accuracy of top
k predictions. As for MAP, the value of P@100 is consistent
across data sets. The best embedding approaches obtain 0.15-
0.2 P@100 which is an improvement of 5-10 times over tradi-
tional link prediction methods.

We address the evaluation metrics (A4) in Table 2 where
the GFS-score for each method is presented. In general, SDNE
obtains top performance across domains and metrics with the
exception of P@100 in biology and social for which HOPE

performs better. Also, we can see that in general embedding
approaches outperform traditional methods. We now study the
performance variations between methods in detail.

4.1. Domain Performance

For economic graphs, we ﬁnd that traditional link predic-
tion models perform poorly because these graphs do not have
the notion of a community structure and therefore violate the
assumptions of traditional methods. However, state-of-the-art
methods perform better and capture the structure of these net-
works achieving good scores on both MAP and P@100. We ob-
serve that Structural Deep Network Embedding (SDNE) gives
the best performance for economic graphs with a GFS-score of
11.2 for MAP and 143.3 for P@100. The score for P@100
is signiﬁcantly higher than MAP. The reason is that predict-
ing correct links for low degree nodes is more challenging than
high degree nodes and thus averaging over all nodes gives a
low overall performance. We also ﬁnd that Graph Factorization
(GF), despite capturing ﬁrst order proximity, performs better
than Higher Order Proximity Embedding (HOPE). This sug-
gests that economic graphs do not beneﬁt from capturing longer
dependency. The overall good performance of SDNE indicates
that economic graphs have complex structures that beneﬁt from
deep neural networks.

Biological graphs show a more consistent performance
across traditional methods. Preferential Attachment, Common
Neighbors and Adamic Adar give a GFS-map score of about
3.3 and a GFS-P@100 score of around 30. Among the graph
embedding methods, Graph Factorization and Laplacian Eigen-
maps do not improve over the traditional methods and give sim-
ilar scores. However, HOPE and SDNE show signiﬁcant gains
in performance. SDNE and HOPE give the highest MAP and
P@100 performance, respectively. As HOPE captures higher
order proximity, these results suggest that longer dependencies
are critical to predicting top links in the biology domain. For
the MAP score, SDNE performs better than HOPE. This may
be because the low degree nodes may require the understand-
ing of structure to make accurate predictions. Furthermore, we
see that the GFS scores for the biology domain are lower than
economy graphs. This is an indication that these networks are
more diﬃcult to predict.

Technological graphs show patterns similar to economic
graphs. Non-parametric link prediction methods perform
poorly and are unable to outperform the random baseline.
Laplacian Eigenmaps gives a score of around 3.5 for both MAP
and P@100. HOPE and SDNE perform the best among the
state-of-the-art methods showing that both higher order and
structure are helpful in the prediction. We also observe that for
technological graphs, the gain in performance is much higher
for P@100 by SDNE. This suggests that several top links are
not based on neighborhood but based on distant nodes with sim-
ilar structure.

For social graphs, we observe that traditional methods per-
form very well mostly because these methods were designed
for such graphs. On average, we see that both SDNE and HOPE
outperform baselines for MAP and HOPE achieves the highest
performance on P@100. Social graphs often have community

6

Figure 2: Performance evaluation of diﬀerent methods varying the attributes of graphs. The x axis denotes the dimension of embedding, whereas the y axis denotes
the MAP scores.

7

Figure 3: Performance evaluation of diﬀerent methods varying the attributes of graphs. The x axis denotes the dimension of embedding, whereas the y axis denotes
the P@100 scores.

8

Table 2: Average and standard deviation of GFS-score

Pref. Attach.
Common Neigh.
Jaccard Coeﬀ.
Adamic-Adar
Lap. Eigen.
GF
HOPE
SDNE

micro-GFS

macro-GFS

GFS-bio

GFS-eco

GFS-soc

GFS-tech

MAP
3.1
2.8
2.3
2.9
6.6
5.7
6.1
11.0

P@100 MAP
3.4
4.6
3.8
4.8
6.4
5.2
7.3
10.1

37.7
77
28.3
74.6
18.9
41.2
98.0
90.6

P@100 MAP
3.3
3.2
2.2
3.3
3.5
3.3
4.7
6.8

31.3
67.2
26.3
66.0
17.4
40.9
89.1
91.3

P@100 MAP
2.6
0.1
0.01
0.02
6.2
5.7
4.2
11.2

35.9
36.1
0.5
28.3
0.75
19.2
43.8
33.1

P@100 MAP
6.4
14.8
12.6
15.5
12.3
10.5
16.7
18.6

2.7
0.0
0.0
0.0
0.0
80.5
45.2
143.3

P@100 MAP
1.3
0.5
0.5
0.5
3.8
1.35
3.4
4.0

83.6
232.8
102.8
234.6
65.3
62.2
263.3
170.4

P@100
3.0
0.0
1.8
1.0
3.5
3.4
4.25
18.5

structure and capturing local and global neighborhood can be
useful in capturing the graph. Higher performance by HOPE
may be because of its ability to capture such properties well.

In general, we observe that the state-of-the-art graph em-
bedding methods have higher micro and macro GFS scores than
traditional methods showcasing the utility of these approaches.
It is worth noting that Laplacian Eigenmaps is good for predict-
ing links for nodes with lower degrees, but it does not perform
well for top link predictions. On average, SDNE outperforms
the other methods by a big margin. In conclusion, exploring
deep learning based graph embedding methods is a valuable di-
rection for future work.

4.2. Sensitivity to Graph Size

Real graphs vary in the number of nodes and edges. On
the one hand, representing larger graphs in low dimensions re-
quires more compression. On the other hand, many data driven
approaches require data to learn the parameters and thus may
not perform well for smaller graphs as the data may not be suﬃ-
cient to learn their parameters. To study the eﬀects of graph size
on the embedding performance, we evaluate the performance of
methods on graphs of diﬀerent sizes ranging from 256, 512, and
1024 (as shown in Figures 2 and 3).

We observe that for most methods, the absolute MAP and
P@100 scores decrease as the size of the graph increases. For
example, the average MAP score of HOPE across all dimen-
sions is 0.08, 0.06 and 0.04 for graphs of sizes 256, 512 and
1024, respectively. Similar trends are observed for Graph Fac-
torization and Laplacian Eigenmaps. However, for SDNE, the
performance decreases for 512 nodes and increases for 1024
nodes. The reason may be that the deep neural network has
more parameters to store information about larger graphs and
beneﬁts from more data. Another key observation is that al-
though the absolute MAP values decrease, the performance rel-
ative to the random baseline improves. As the number of nodes
increases, the link prediction task becomes inherently more
diﬃcult. With more nodes there are more candidate links to
choose from, thus leading to a lower absolute performance. In
general, the increase of performance relative to the random ran-
dom baseline suggests that the state-of-the-art embedding ap-
proaches better capture the graph structure when there is more
information about the links.

4.3. Sensitivity to Graph Density

A wide variety of network graphs in real world are sparse.
However, the factor of sparsity varies depending on the domain
of graphs and other connectivity patterns in the graphs. We now
study the eﬀect of graph density on the performance of graph
embedding methods (Figures 2 and 3).

In Figure 2 we observe that overall the performance of em-
bedding methods in terms of MAP is not sensitive to graph
density. MAP values of Graph Factorization increases with in-
creasing graph density but for other methods the trend is not sig-
niﬁcant. Further, with higher density the likelihood of correct
prediction increases so the trend in Graph Factorization may
not signify an increase in performance with increase in den-
sity. From Figure 3 we observe that the models perform poorly
on P@100 score for lower density. Thus, the methods make top
link predictions with more accuracy when the graph is relatively
denser.

4.4. Sensitivity to Embedding Dimension

An inherent parameter of every embedding approach is the
number of dimensions in the embedded space. The embedding
dimension controls the amount of overﬁtting incurred by the
method. A low number of dimensions may not be suﬃcient to
capture the information contained in the graph. A high number
of dimensions may overﬁt the observed links and thus perform
poorly on predicting the missing links.

The optimal embedding dimension depends on three fac-
tors: (i) the input graph, (ii) the embedding method, and (iii)
the evaluation metric. Theoretically, graphs with less structure
and higher entropy require higher dimensions. Furthermore,
embedding methods which are capable of capturing more com-
plex information may require higher dimensions to store the
information. Also, predicting top links requires a higher level
understanding of the graph and thus requires lower dimensions.
Finding the optimal embedding dimension for a given graph re-
quires extensive experimentation.

Figure 2 shows the MAP performance of the graph embed-
ding methods when varying the embedding dimension from 24
to 27. These results provide us with interesting insights. The
performance of SDNE improves proportionally when increas-
ing the embedding dimension. Laplacian Eigenmaps performs
best for lower dimensions and quickly overﬁts for higher di-
mensions. This is surprising as deep neural networks models

9

are prone to overﬁtting. But as deep neural networks are capa-
ble of capturing more complex information, they beneﬁt from
higher dimensional representation. Laplacian Eigenmaps only
captures the ﬁrst order proximity and hence overﬁts for larger
dimensions. This is not surprising as the embedding vector
stores ﬁrst order proximity with higher precision. HOPE and
GF also improve their performance with increasing dimensions,
but HOPE has higher gains comparatively.

Figure 3 shows the P@100 performance. The SDNE up-
ward MAP trend is consistent across the metrics and we ob-
serve similar increase for P@100. However, we observe that
the performance of HOPE deteriorates with increasing dimen-
sions. Graph Factorization’s performance is almost constant
across all embedding dimensions. This follows the intuition
that predicting top links does not require higher dimensions.

(iii) generating realistic synthetic data. During the experimenta-
tion, we observed that a considerable eﬀort is spent in identify-
ing optimal hyperparameters for graph embedding approaches.
Automating this process can help in their evaluation. Secondly,
we showed in this work that optimal approach for a graph de-
pends on the domain and other properties. We can extend this
concept to infer that diﬀerent subgraphs of a graph may ben-
eﬁt from using diﬀerent embedding approaches. Combining
multiple approaches on a graph is non-trivial but can help im-
prove link prediction performance. Finally, in the Appendix we
show that graph embedding approaches do not perform well on
synthetic graphs as the state-of-the-art synthetic graphs are too
simple with few parameters. We believe generating more real-
istic synthetic graphs is an important problem which can beneﬁt
testing a new approach.

5. Python Library for GEM-BEN

Acknowledgements

We have created a pip installable Python library
for graph embedding method benchmark called gemben
(https://pypi.org/project/gemben). The documentation of the
gemben library can be found at https://gemben.readthedocs.io.
A simple usage example for linux is as follows:

$ virtualenv −p python3 ./venv # create a virtual environment
$ source ./venv/bin/ activate # activate the environment
(venv) $ pip install −−upgrade pip
(venv) $ pip install gemben # install gemben
(venv) $ python3 #launch python
#import the experiment module
>>> from gemben.experiments.experiment import exp
#experiment on social domain with all baselines algorithms
>>> test = exp(domain="social", method="all")
#run the experiment
>>> test.run()

6. Conclusion and Future Work

This work introduced a benchmark for graph embedding
techniques. This benchmark rests on a corpus of 100 real-world
graphs, which is largely a subset of the popular CommunityFit-
Net corpus [13] with additional graphs drawn from the Stanford
Network Analysis Project (SNAP) [14], and provides a broad
evaluation of state-of-the-art embedding approaches against tra-
ditional approaches. We established that graph embedding ap-
proaches outperform traditional methods on a variety of diﬀer-
ent graphs. Further, we showed that the performance of the
method depends on multiple attributes of the graph and eval-
uation: (i) size of the graph, (ii) graph density, (iii) embed-
ding dimension, and (iv) evaluation metric. Further, the perfor-
mance varies tremendously based on the domain of the graph.
Finally, we presented an open-source Python library, named
GEM-BEN, which provides the benchmarking tool to evaluate
any new embedding approach against the existing methods.

There are three promising research directions: (i) automat-
ing hyperparameter selection, (ii) graph ensemble techniques,

10

This material is based upon work supported by the Defense
Advanced Research Projects Agency (DARPA) under Agree-
ment No. HR00111990017, and Contract No. W911NF-17-C-
0094.

Appendix: Results on Synthetic Graphs

6.1. Synthetic Graphs

Synthetic graphs are often used to simulate the properties
of real networks. This approach is useful when analyzing net-
work structure properties and network evolution process, espe-
cially when the real graph is very large or cannot be fully ob-
served. Realistic synthetic graphs can provide reliable and prac-
tical statistical conﬁdence on algorithmic analysis and method
evaluation. Synthetic graphs are ubiquitous in various domains
including sociology, biology, medical domain, internet, team-
work dynamics, and human collaborations.

Many graph embedding methods for link prediction, node
classiﬁcation, graph visualization, and graph reconstruction
have been evaluated on synthetic graphs.
For example,
GEM [6] uses the Stochastic Block Model (SBM) graph for
visualization and evaluation on link prediction, node classiﬁ-
cation, and graph reconstruction. Similarly, dyngraph2vec [38]
also utilizes the SBM graph to evaluate diﬀerent dynamic graph
embedding methods on link prediction tasks. HOPE [21] uses
synthetic graphs generated by the forest ﬁre model to evaluate
the embedding’s ability to preserve graph high-order proximity.
Although synthetic graphs do not to always fully capture
inherent properties of real graphs, they are still useful for ana-
lyzing the performance of graph embedding methods regarding
diﬀerent graph characteristics. In this appendix, we analyze the
performance of traditional and state-of-the-art methods on syn-
thetic graphs. Our goal is to establish a better understanding on
how graph embedding methods perform on some of the most
popular synthetic graphs available in the literature.

6.2. Synthetic Graph Dataset

We evaluate the graph embedding methods implemented in
our benchmark on ten synthetic graphs. These synthetic graphs
can be categorized in three domains: (i) social, (ii) biology,
and (iii) internet. Social networks represent the relationships
between users on online social platforms. They characterize
friendship networks (e.g., Facebook), and follower networks
(e.g., Twitter where links are explicit and direct between users).
Social graphs follow small world properties and power-law dis-
tribution. Social networks usually contain hubs and community
structures. It is well known that Random Geometric graph [39],
Waxman graph [40] and Stochastic block model [41] can ap-
propriately reveal such community properties typically found
in social networks. Biology graphs can represent protein-
protein interaction networks, gene co-expression networks, and
metabolic networks. The Watts-Strogatz graph [42] and Du-
plication Divergence graph [43] are heavily used to simulate
biological networks. Graphs in the internet domain are usu-
ally very large in size and scale-free such as the web graph in
the World Wide Web. The Barabasi-Albert graph [36] and the
Power-law Cluster graph [44] have been used to simulate the
power-law distribution found in internet graphs. In addition to
the synthetic graphs described above which are designed to sim-
ulate certain type of real graphs, Leskovec et al. [45] used the
Stochastic Kronecker Graph to eﬀectively model any real net-
works from diﬀerent domains using four parameters through an
iterative Kronecker product process.

We use the following synthetic graphs to illustrate the inef-
ﬁcacy of existing data sets and to highlighting the performance
gaps between diﬀerent graph embedding methods:

Barabasi-Albert graph [36]: This method generates ran-
dom graphs using a preferential attachment process. A graph
of n nodes is constructed by adding new nodes with m edges
which are connected to existing nodes based on their degree.
The likelihood of connection to a node is proportional to its de-
gree. The generated random graph has power-law properties
similar to the ones found in real-world networks.

Powerlaw Cluster graph [44]: It extends the Barabasi-
Albert graph to include a triad formation step. When a new
node u is linked to an existing node v, with a probability p, u is
also connected to one of v’s neighbors . The likelihood of triad
formation controls the clustering coeﬃcient of the graph.

Watts-Strogatz graph [42]: The model creates a ring graph
of n nodes. It then links each node to its k nearest neighbors.
Each link from a node u is rewired randomly to a node w with
a probability p. The rewiring is done to create short paths be-
tween nodes.

Duplication Divergence graph [43]: This random graph
model is based on the behavior of protein-protein interaction
graphs. The model starts with an initial graph and follows two
steps for evolution: duplication and divergence. In the dupli-
cation step, a uniformly randomly chosen target is duplicated,
and then connected to each neighbor of the target node. In the
divergence step, each edge from the duplicate is removed with
a probability 1 − p. The retention probability of an edge is p.

Random Geometric Graph [39]: It is a spatial network
that starts with an arbitrary distribution of n nodes in a metric

11

domain. Then it creates an edge between any pair of nodes if
their spatial distance is under a certain threshold. This model
simulates the community structure within human social net-
works.

Waxman Graph [40]: This model extends the Random Ge-
ometric graph by adding edges in a probabilistic process. First,
it uniformly places n nodes in a rectangular space. If the dis-
tance of two nodes is within the neighborhood radius r, then
it adds an edge with a probability p. The Waxman graph also
demonstrates the community structure within the network.

Stochastic Block Model Graph [41]: This random graph
generator splits n nodes into m communities of arbitrary size.
For each pair of vertices that belong to the community Ci and
C j respectively, this model connects two nodes under proba-
bility pi j.
In order to preserve the community structure, the
in-block connection probability is higher than the cross-block
probability.

R-Mat(Recursive Matrix) Graph [46]: this model is able
to simulate any unimodal or power-law graphs with a few pa-
rameters using the recursive matrix. It recursively subdivides
the adjacency matrix into four equal-sized partitions and dis-
tributes edges within these partitions with unequal probabilities.
Random Hyperbolic Graph [47]: this generation method
builds a graph based on hyperbolic geometry. First, it randomly
places nodes in a hyperbolic disk of radius R, and then connects
each pair of vertices with an edge if their distance is less than
R.

Stochastic Kronecker Graph [45]:

similar to the R-
Mat graph’s recursive generation process, this model builds the
graph’s adjacent matrix from a 2 × 2 parameter matrix via it-
erating Kronecker product. Each component in the matrix is a
real number between 0 and 1. Stochastic Kronecker Graph can
simulate realistic graphs while preserving all common realistic
graph properties.

6.3. Results

This section analyses the performance of diﬀerent graph
embedding methods and link prediction heuristic methods on
link prediction task on eleven synthetic graph datasets described
in section 6.2. We evaluate diﬀerent link prediction approaches
from various perspectives, including graph domain, graph size,
node average degree and embedding dimension.

Figure 4 represents the link prediction performance MAP
scores of eight methods on all synthetic graphs from three dif-
ferent domains: social, biology and internet with varying graph
size from 256 to 8192 nodes, varying graph embedding dimen-
sions from 16 to 256, and varying average node degree from
4 to 12. While varying one parameter, we keep other parame-
ters the same across diﬀerent graphs. The MAP score shown
in the ﬁgure is averaged across all synthetic graphs belonging
to that domain. Figure 5 shows P@100 scores of all methods.
Diﬀerent from the apparent advantage of state-of-the-art graph
embedding methods such as SDNE and HOPE on link predic-
tion tasks on real graphs shown from Figure 2, we observe that
classic link prediction heuristics such as Jaccard’s Coeﬃcient,
Common Neighbors and Adamic-Adar can surpass some graph

Domain Domain Properties

Social

community based graphs

Biology

variant graph properties

Internet

power-law degree distribution

All

simulate any realistic graphs

Graph Generator
Stochastic Block Model
Random Geometric Graph
Waxman Graph
Watts Strogatz Graph
Duplication Divergence Graph
Hyperbolic Graph
Barabasi Albert Graph
Powerlaw Cluster Graph
R-Mat Graph
Stochastic Kronecker Graph

Generator Properties
dense areas with sparse connections
community structure
community structure
ring shape graph
simulate protein-protein interations via duplication and divergence
large networks, power-law degree distribution and high clustering
power-law degree distribution, small-world property
power-law degree distribution, small-world property
power-law degree distribution, small-world property, self-similarity
build graph via iterating Kronecker product

embedding methods on certain simple synthetic graphs dataset.
Some synthetic graphs have naive structure and link prediction
heuristics are capable of learning the network structure. Diﬀer-
ent graph embedding methods also perform diﬀerently in terms
of domain, graph size, node degree and embedding dimension.
Figure 5 shows concrete MAP scores of those methods on
three chosen synthetic graphs from three diﬀerent domains, also
with varying graph properties and embedding dimensions. The
chosen graphs include Random Geometric Graph from social
domain, Watts Strogatz Graph in biology and Powerlaw Clus-
ter Graph belonging to internet domain. Figure 6 shows their
P@100 performance. Seen from the ﬁgures, even with same
graph sizes, node average degree and embedding dimension,
those methods have diverse performance on link prediction.
Some synthetic graph generators contain certain network struc-
ture characteristics, which enable heuristic based and graph
embedding based methods to learn. However, some synthetic
graphs such as synthetic internet graphs are generated in a more
stochastic way, which are less structured and all methods fail to
predict correctly.

6.3.1. Domain Performance

We divide all sythetic graph generators into three domains:
social, biology and internet. Each domain contains three kinds
of synthetic graphs. We add Stochastic Kronecker graph to each
domain with speciﬁc parameters with respect to that domain.

For social network synthetic graphs, heuristic method Jac-
card’s Coeﬃcient and Common Neighbours perform the best on
the link prediction task. As synthetic social graphs are usually
community based graphs, including Stochastic Block Model,
Random Geometric Graph, Waxman Graph, nodes within the
same community are more densely connected than nodes out-
side. Jaccard’s Coeﬃcient and Common Neighbours are ca-
pable of capturing such inherent property that nodes with high
degree are more likely connected with nodes with high degree
within the same cluster. For graph embedding methods, Lapla-
cian Eigenmaps has the similar MAP performance with best
heuristics methods and HOPE is also good at predicting top
100 missing links. SDNE doesn’t perform well on synthetic
graphs probably due to that those graphs are simply structured
and training links easily overﬁt the model.

When it comes to biology graphs, non-parametric meth-
ods Common Neighbor, Adamic-Adar and Jaccard Coeﬃcients
have consistently good performance. Biological graphs are usu-
ally various as objects and connections are diﬀerent under dif-

12

ferent context. However, synthetic biological graphs are con-
structed in certain heuristic manner, which explains the good
performance of the heuristic link prediction methods. Graph
embedding methods are easily overﬁtted with such graphs.
Some graph embedding methods such as HOPE can still over-
pass all methods at predicting top 100 nodes.

For Internet graphs, Barabasi Albert Graph, Powerlaw Clus-
ter Graph and R-mat Graph all have power-law degree distribu-
tion and small-world property. Heuristic methods Adamic-Adar
has the best MAP score and Jaccord Coeﬃcient achieves the
best Precision@100 score. Like social and biological graphs,
internet synthetic graphs are also built using such heuristics.
Heuristic link prediction methods are suitable to explain edge
generation rules. Graph embedding methods like Graph Factor-
ization performs better on synthetic graphs in internet domain.

6.3.2. Sensitivity to Graph Size

In our experiments, we test all methods on synthetic graphs
from small size(1024 nodes), medium size(2048, 4096 nodes)
to large size(8192 nodes). From three subplots in the ﬁrst col-
umn in Figure 4 and 5, we notice that the absolute values of
MAP decrease when graph size increases accross all methods
in three domains. However, some methods including Laplacian
Eigenmaps and HOPE have higher P@100 scores when graph
size grows. On one hand, the reason that MAP score is lower
on large graphs might be that with the size of graphs increasing,
it is harder to predict the possible edges over more candidate
edges. For graph embedding methods, embedding using the
same dimension on larger-size graphs require more information
compression and it results in relatively poor performance. On
the other hand, the density of graphs increases while the graphs
nodes increase and average node degree stay the same. Higher
density provides more information for individual nodes and it
helps to increase P@100 of link prediction.

6.3.3. Sensitivity to Average Node Degree

Instead of using graph density which is less controllable in
the graph generators, we look into sensitivity of link predic-
tion methods and graph embedding methods to average node
degree of graphs. In Figure 4, we observe that most of meth-
ods get better MAP performance along with the increase of av-
erage node degree on social and biological synthetic graphs.
When graph size is the same, the higher average node degree
means each node has more edges. It is easier to predict possible

hidden links. However, those methods’ performance has op-
posite trend on internet graphs. Internet graphs might be more
stochastic and noisy when the size becomes bigger. In ﬁgure
5, Hope and Laplacian Eigenmaps shows good performance on
P@100. Graph embedding methods are good at predicting top
links on denser graphs.

6.3.4. Sensitivity to Embedding Dimension

The traditional link prediction methods make predictions
based on node similarity metrics and they are invariant to di-
mension. Graph embedding methods represent nodes in embed-
ding space and diﬀerent embedding dimension could generate
embeddings with diﬀerent quality. Seeing from Figure 4 and
Figure 5, the higher dimension the graph embedding methods
use, the better MAP and P@100 scores they can get on the same
graph. As all the graphs sizes are much larger than embedding
dimensions, it requires less compression of graph information
when embedding dimension is higher. Higher dimension pre-
serves more features of graphs nodes and it results in better link
prediction accuracy. For internet synthetic graphs, increasing
embedding dimensions is a smaller boost and the reason might
be that there are too much noise in the graphs.

References

[1] M. E. Newman, Clustering and preferential attachment in growing net-

works, Physical review E 64 (2) (2001) 025102.

[2] L. A. Adamic, E. Adar, Friends and neighbors on the web, Social net-

works 25 (3) (2003) 211–230.

[3] G. Salton, M. J. McGill, Introduction to modern information retrieval.
[4] A. Thor, P. Anderson, L. Raschid, S. Navlakha, B. Saha, S. Khuller, X.-N.
Zhang, Link prediction for annotation graphs using graph summarization,
in: International Semantic Web Conference, Springer, 2011, pp. 714–729.
[5] M. Kim, J. Leskovec, The network completion problem: Inferring miss-
ing nodes and edges in networks, in: Proceedings of the 2011 SIAM In-
ternational Conference on Data Mining, SIAM, 2011, pp. 47–58.

[6] P. Goyal, E. Ferrara, Graph embedding techniques, applications, and per-
formance: A survey, Knowledge-Based Systems 151 (2018) 78–94.
[7] W. L. Hamilton, R. Ying, J. Leskovec, Representation learning on graphs:

Methods and applications, arXiv preprint arXiv:1709.05584.

[8] H. Cai, V. W. Zheng, K. C.-C. Chang, A comprehensive survey of graph
embedding: Problems, techniques, and applications, IEEE Transactions
on Knowledge and Data Engineering 30 (9) (2018) 1616–1637.

[9] A. Ahmed, N. Shervashidze, S. Narayanamurthy, V. Josifovski, A. J.
Smola, Distributed large-scale natural graph factorization, in: Proceed-
ings of the 22nd international conference on World Wide Web, ACM,
2013, pp. 37–48.

[10] D. Wang, P. Cui, W. Zhu, Structural deep network embedding, in: Pro-
ceedings of the 22nd International Conference on Knowledge Discovery
and Data Mining, ACM, 2016, pp. 1225–1234.

[11] A. Grover, J. Leskovec, node2vec: Scalable feature learning for networks,
in: Proceedings of the 22nd International Conference on Knowledge Dis-
covery and Data Mining, ACM, 2016, pp. 855–864.

[12] F. Salehi Rizi, M. Granitzer, K. Ziegler, Properties of vector embeddings

in social networks, Algorithms 10 (4) (2017) 109.

[13] A. Ghasemian, H. Hosseinmardi, A. Clauset, Evaluating overﬁt and un-
derﬁt in models of network community structure, IEEE Trans. Knowledge
and Data Engineering (TKDE)In press.

[14] J. Leskovec, R. Sosiˇc, Snap: A general-purpose network analysis and
graph-mining library, ACM Transactions on Intelligent Systems and
Technology (TIST) 8 (1) (2016) 1.

[15] A. Clauset, E. Tucker, M. Sainz, The Colorado Index of Complex Net-

works. (2016).

[16] S. T. Roweis, L. K. Saul, Nonlinear dimensionality reduction by locally

linear embedding, Science 290 (5500) (2000) 2323–2326.

[17] M. Belkin, P. Niyogi, Laplacian eigenmaps and spectral techniques for
embedding and clustering, in: NIPS, Vol. 14, 2001, pp. 585–591.
[18] B. Shaw, T. Jebara, Structure preserving embedding, in: Proceedings of
the 26th Annual International Conference on Machine Learning, ACM,
2009, pp. 937–944.

[19] D. Luo, F. Nie, H. Huang, C. H. Ding, Cauchy graph embedding, in:
Proceedings of the 28th International Conference on Machine Learning
(ICML-11), 2011, pp. 553–560.

[20] S. Cao, W. Lu, Q. Xu, Grarep: Learning graph representations with global
structural information, in: Proceedings of the 24th ACM International on
Conference on Information and Knowledge Management, ACM, 2015,
pp. 891–900.

[21] M. Ou, P. Cui, J. Pei, Z. Zhang, W. Zhu, Asymmetric transitivity preserv-
ing graph embedding, in: Proc. of ACM SIGKDD, 2016, pp. 1105–1114.
[22] B. Perozzi, R. Al-Rfou, S. Skiena, Deepwalk: Online learning of social
representations, in: Proceedings 20th international conference on Knowl-
edge discovery and data mining, 2014, pp. 701–710.

[23] J. Tang, M. Qu, M. Wang, M. Zhang, J. Yan, Q. Mei, Line: Large-scale
information network embedding, in: Proceedings 24th International Con-
ference on World Wide Web, 2015, pp. 1067–1077.

[24] H. Chen, B. Perozzi, Y. Hu, S. Skiena, Harp: Hierarchical representation

learning for networks, arXiv preprint arXiv:1706.07845.

[25] B. Perozzi, V. Kulkarni, S. Skiena, Walklets: Multiscale graph
embeddings for interpretable network classiﬁcation, arXiv preprint
arXiv:1605.02115.

[26] S. Cao, W. Lu, Q. Xu, Deep neural networks for learning graph represen-
tations, in: Proceedings of the Thirtieth AAAI Conference on Artiﬁcial
Intelligence, AAAI Press, 2016, pp. 1145–1152.

[27] J. Bruna, W. Zaremba, A. Szlam, Y. LeCun, Spectral networks and locally

connected networks on graphs, arXiv preprint arXiv:1312.6203.

[28] M. Henaﬀ, J. Bruna, Y. LeCun, Deep convolutional networks on graph-

structured data, arXiv preprint arXiv:1506.05163.

[29] Y. Li, D. Tarlow, M. Brockschmidt, R. Zemel, Gated graph sequence neu-

ral networks, arXiv preprint arXiv:1511.05493.

[30] W. L. Hamilton, R. Ying, J. Leskovec, Inductive representation learning

on large graphs, arXiv preprint arXiv:1706.02216.

[31] M. Zhang, Y. Chen, Link prediction based on graph neural networks, in:
Advances in Neural Information Processing Systems, 2018, pp. 5165–
5175.

[32] Z. Ying, J. You, C. Morris, X. Ren, W. Hamilton, J. Leskovec, Hierar-
chical graph representation learning with diﬀerentiable pooling, in: Ad-
vances in Neural Information Processing Systems, 2018, pp. 4800–4810.
[33] T. N. Kipf, M. Welling, Variational graph auto-encoders, arXiv preprint

arXiv:1611.07308.

[34] A. Lancichinetti, S. Fortunato, F. Radicchi, Benchmark graphs for test-
ing community detection algorithms, Physical review E 78 (4) (2008)
046110.

[35] X. Lu, S. Bressan, Sampling connected induced subgraphs uniformly
International Conference on Scientiﬁc and Statistical

at random, in:
Database Management, Springer, 2012, pp. 195–212.

[36] A.-L. Barab´asi, R. Albert, Emergence of scaling in random networks, sci-

[37] P. Jaccard, Nouvelles recherches sur la distribution ﬂorale, Bull. Soc.

ence 286 (5439) (1999) 509–512.

Vaud. Sci. Nat. 44 (1908) 223–270.

[38] P. Goyal, S. R. Chhetri, A. Canedo, dyngraph2vec: Capturing network dy-
namics using dynamic graph representation learning, Knowledge-Based
Systems.

[39] M. Penrose, et al., Random geometric graphs, Vol. 5, Oxford university

press, 2003.

[40] B. M. Waxman, Routing of multipoint connections, IEEE journal on se-

lected areas in communications 6 (9) (1988) 1617–1622.

[41] Y. J. Wang, G. Y. Wong, Stochastic blockmodels for directed graphs, Jour-
nal of the American Statistical Association 82 (397) (1987) 8–19.
[42] D. J. Watts, S. H. Strogatz, Collective dynamics of small-worldnetworks,

nature 393 (6684) (1998) 440.

[43] I. Ispolatov, P. Krapivsky, A. Yuryev, Duplication-divergence model of
protein interaction network, Physical review E 71 (6) (2005) 061911.
[44] P. Holme, B. J. Kim, Growing scale-free networks with tunable clustering,

Physical review E 65 (2) (2002) 026107.

[45] J. Leskovec, D. Chakrabarti, J. Kleinberg, C. Faloutsos, Z. Ghahramani,
Kronecker graphs: An approach to modeling networks, Journal of Ma-
chine Learning Research 11 (Feb) (2010) 985–1042.

13

Figure 4: Benchmark Synthetic plot.

14

Figure 5: Benchmark Synthetic plot.

15

Figure 6: Benchmark plot for individual synthetic graphs.

16

Figure 7: Benchmark plot for individual synthetic graphs.

17

[46] D. Chakrabarti, Y. Zhan, C. Faloutsos, R-mat: A recursive model for
graph mining, in: Proceedings of the 2004 SIAM International Confer-
ence on Data Mining, SIAM, 2004, pp. 442–446.

[47] D. Krioukov, F. Papadopoulos, M. Kitsak, A. Vahdat, M. Bogun´a, Hyper-
bolic geometry of complex networks, Physical Review E 82 (3) (2010)
036106.

18

