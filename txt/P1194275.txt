7
1
0
2
 
c
e
D
 
9
1
 
 
]

V
C
.
s
c
[
 
 
1
v
9
0
9
6
0
.
2
1
7
1
:
v
i
X
r
a

ComboGAN:
Unrestrained Scalability for Image Domain Translation

Asha Anoosheh
Computer Vision Lab
ETH Z¨urich
ashaa@ethz.ch

Eirikur Agustsson
Computer Vision Lab
ETH Z¨urich
aeirikur@ethz.ch

Radu Timofte
ETH Z¨urich
Merantix GmbH
timofter@ethz.ch

Luc Van Gool
ETH Z¨urich
KU Leuven
vangool@ethz.ch

Abstract

This year alone has seen unprecedented leaps in the area
of learning-based image translation, namely CycleGAN, by
Zhu et al. But experiments so far have been tailored to merely
two domains at a time, and scaling them to more would re-
quire an quadratic number of models to be trained. And with
two-domain models taking days to train on current hardware,
the number of domains quickly becomes limited by the time
and resources required to process them. In this paper, we pro-
pose a multi-component image translation model and train-
ing scheme which scales linearly - both in resource consump-
tion and time required - with the number of domains. We
demonstrate its capabilities on a dataset of paintings by 14
different artists and on images of the four different seasons in
the Alps. Note that 14 data groups would need (14 choose
2) = 91 different CycleGAN models: a total of 182 genera-
tor/discriminator pairs; whereas our model requires only 14
generator/discriminator pairs.

1. Introduction

In such a short amount of time, we have come such a long
way in the ﬁeld of image domain adaptation and style trans-
fer, with projects such as [11], [8], [5], [6], [9], [3], and more
paving the way. The ﬁrst four are of particular interest as they
do not simply transfer style in terms of texture and color, but
in terms of semantics, and they maintain realism in their re-
sults. But they must be trained on examples from two speciﬁc
domains, whereas the other two do not. The ﬁrst three are
even more noteworthy for being able to do this without any
supervision between the two domains chosen - no pairing of
matching data. Now what if we want to go beyond two do-
mains?

Naively, we could train a model for each pair of domains
(cid:1) = Θ(n2) models
we desire. With n domains, this leads to (cid:0)n
to train. In this work, we approach this problem by dividing
each model into two parts: one that handles the conversion of
one domain into a common representation and one that con-
verts common representations into that domain. Having one

2

of these pairs per domain allows us to mix-and-match by ob-
taining a common representation for any image and translat-
ing it to any other domain. All the while, the number of mod-
els increases linearly with the number of domains, as does the
required training time.

1.1. Generative Adversarial Models

Creating a generative model of natural images is a chal-
lenging task. Such a model needs to be able to capture the
rich distributions from which natural images come from. Gen-
erative Adversarial Networks (GANs) [4] have proven to be
excellent for this task and can produce images of high visual
ﬁdelity. GANs, by default, consist of a pair of models (typi-
cally neural networks): a generator G and a discriminator D.
D is trained to estimate the probability that a sample x comes
from a true training data distribution p(x), while simultane-
ously G is trained turn vector z sampled from its own prior
distribution p(z) into x(cid:48), in order to maximize the value D
outputs when fed x(cid:48). G’s outputs receiving higher score by
D implies the distribution G learns nears the true distribution
p(x).

This training procedure is referred to as adversarial train-
ing and corresponds to a Minimax game between G and D.
Training itself is executed in two alternating steps; ﬁrst D is
trained to distinguish between one or more pairs of real and
generated samples, and then the generator is trained to fool
D with generated samples. Should the discriminator be too
powerful at identifying real photos to begin with, the gener-
ator will quickly learn low-level ”tricks” to fool the discrim-
inator that do not lie along any natural image manifold. For
example, a noisy matrix of pixels can mathematically be a so-
lution that makes D produce a high real-image probability. To
combat this, the training is often done with a small handful of
examples per turn, allowing G and D to gradually improve
alongside each other. The optimization problem at hand can
be formulated as:

min
G

max
D

Ex[logD(x)] + Ez[log(1 − D(G(z))]

(1)

GANs have found applications in many computer vision re-

1

lated domains, including image super-resolution [7] and style
transfer [3].

1.2. Related Works

Many tasks in computer vision and graphics can be thought
of as translation problems where an input image a is to be
translated from domain A to b in another domain B. Isola et
al. [6] introduced an image-to-image translation framework
that uses GANs in a conditional setting where the generator
transforms images conditioned on the existing image a. In-
stead of sampling from a vector distribution p(z) to generate
images, it simply modiﬁes the given input. Their method re-
quires image data from two domains, but it requires they be
aligned in corresponding pairs.

Introduced by Zhu et al., CycleGAN [11] extends
this framework to unsupervised image-to-image translation,
meaning no alignment of image pairs are necessary. Cycle-
GAN consists of two pairs of neural networks, (G, DA) and
(F, DB), where the translators between domains A and B are
G : A → B and F : B → A. DA is trained to discriminate
between real images a and translated images F (a), while DB
is trained to discriminate between images b and G(a). The
system is trained using both an adversarial loss, as expressed
in (1), and a cycle consistency loss expressed in (3). The Cy-
cle consistency loss is a way to regularize the highly uncon-
strained problem of translating an image one-direction alone,
by encouraging the mappings G and F to be inverses of each
other such that F (G(a)) ≈ a and G(F (b)) ≈ b. However,
here the traditional negative log-likelihood loss in (1) is re-
placed by a mean-squared loss (2) that has been shown to be
more stable during training and to produce higher quality re-
sults [10]. The full CycleGAN objective is expressed:

LGAN (G, DB, A, B) =

Eb[(DB(b) − 1)2] + Ea[DB(G(a))2]

(2)

Lcycle(G, F ) =

Ea[||F (G(a)) − a||1] + Eb[||G(F (b)) − b||1]

(3)

L(G, F, DA, DB) = λ Lcycle(G, F )

+ LGAN (G, DB, A, B) + LGAN (F, DA, B, A)

(4)

The reconstruction part of the cycle loss forces the networks
to preserve domain-agnostic detail and geometry in translated
images if they are to be reverted as closely as possible to the
original image. Zhu et al. were able to produce very convinc-
ing image translations such as ones trained to translate be-
tween horses and zebras, between paintings and photographs,
and between artistic styles.

Liu et al. [8] implemented a similar approach with UNIT,
adding further losses to the intermediate activation results

within the generator instead of purely on the ﬁnal generated
outputs. Using the CycleGAN architecture, they designate
the activations from the central layer of the generators as the
shared latent vectors. Using a variational-autoencoder loss,
these vectors from both domains are pushed into a gaussian
distribution. This is done in addition to the discriminator
loss and cycle loss from CycleGAN, seemingly improving the
image translation task over CycleGAN in cases with signiﬁ-
cantly varying geometry in the domains.

Lastly there is the concurrent work of StarGAN [1], which
aims to solve a similar problem as ours: scalability of unsu-
pervised image-translation methods. StarGAN melds the gen-
erators and discriminators from CycleGAN into one generator
and discriminator used in common by all domains. As such,
the model can take as input any number of domains, though
this requires passing in a vector along with each input to the
generator specifying the output domain desired. Meanwhile
the discriminator is trained to output the detected domain of
an image along with a real/fake label, as opposed to simply the
latter when each domain has its own discriminator. The results
suggest having a shared model for domains similar enough to
each other may be beneﬁcial to the learning process. Never-
theless, this method was only applied to the task of face at-
tribute modiﬁcation, where all the domains were slight shifts
in qualities of the same category of images: human faces.

2. The ComboGAN Model

Figure 1. Model design setup for N domains.

2

Figure 2. Generator training pass for direction X → Y , where X, Y ∈ {1, .., n} : X (cid:54)= Y are randomly chosen from our n domains at the
start of every iteration. This pass is always repeated symmetrically for direction Y → X as well.

encoders and decoders of our trained model like building
blocks, taking as input any domain and outputting any other.
For example during inference, to transform an image x from
an arbitrary domain X to y from domain Y , we simply per-
form y = GY X (x) = DecoderY (EncoderX (x)). The re-
sult of EncoderX (x) can even be cached when translating to
other domains as not to repeat computation.

With only one generator (an encoder-decoder pair) per do-
main, the number of generators scales exactly linearly with the
number of domains, instead of 2(cid:0)n
(cid:1) = n(n − 1) = Θ(n2).
The discriminators remain untouched in our experiment; the
number of discriminators already scales linearly when each
domain receives its own. Figure 1 displays our full setup.

2

2.2. Training

Fully utilizing the same losses as CycleGAN involves fo-
cusing on two domains, as the generator’s cyclic training and
discriminator’s true/false-pair training are not directly adapt-
able for more domains. ComboGAN’s training procedure in-
volves focusing on 2 of our n domains at a time. At the begin-
ning of each iteration, we select two domains X, Y ∈ {1..n}
from our n domains, uniformly at random. Then maintaining
the same notation as CycleGAN in (4), we set A := X and
B := Y and proceed as CycleGAN would for the remainder
of the iteration. Figure 2 shows one of the two forward passes
in a training iteration. The other half is simply the symmetric
mirroring of the procedure for the other domain, as if the two
were swapped.

Randomly choosing between two domains per iteration
means we should eventually cover training between all pairs
of domains uniformly. Though of course the training time
(number of iterations) required must increase as well. If train-
ing between two domains with CycleGAN requires k2 itera-
tions, then with n domains, (cid:0)n
(cid:1) CycleGAN setups would re-
(cid:1) iterations to complete. In our situation, we instead
quire k2

2

(cid:0)n
2

Figure 3. Example inference functionality of translation from one
domain to all others.

2.1. Decoupling the Generators

The scalability of setups such as CycleGAN’s is hindered
by the fact that both networks used are tied jointly to two do-
mains, one from some domain A to B and the other from B to
A. To add another domain C, we would then need to add four
new networks, A to C, C to A, B to C, and C to B. To solve
this issue of exploding model counts, we introduce a new
model, ComboGAN, which decouples the domains and net-
works from each other. ComboGAN’s generator networks are
identical to the networks used in CycleGAN (see Appendix
A for network speciﬁcations), yet we divide each one in half,
labeling the frontal halves as encoders and the latter halves as
decoders. We can now assign an encoder and decoder to each
domain.

As the name ComboGAN suggests, we can combine the

3

Figure 4. Validation results for pictures of the Alps in all four sea-
sons. Original images lie on the diagonal.

Figure 5. Same Alps images but from standard CycleGAN results
instead. Original images lie on the diagonal.

keep the training linear in the number of domains, since the
number of parameters (weights) in our model increases lin-
early with the number of domains, as well. We desire each
domain to be chosen for a training iteration the same number
of times as in CycleGAN. Note that it will not be the same
number of times that a given pair is chosen, as achieving that
would just require the same number of iterations as the naive
method; rather we only care about whether a domain is chosen
to be trained alongside any other domain or not. We observe
that since a domain X is chosen in each iteration with prob-
n , during training it is chosen in expectation n
ability 2
2 · kn
times. Requiring equality to the two-domain case k2, we ob-
2 n, or k2
tain kn = k2
2 iterations per domain, which proves
satisfactory in practice.

As for the discriminators, training is the same as Cycle-
GAN’s. After each training iteration for two given generators,
the two corresponding discriminators receive a training iter-
ation, as well. For a single discriminator, a real image from
its domain and a fake image intended for the same domain
(the output of that domain’s decoder) are fed to train the net-
work to better distinguish real and fake images. This is done
independently for both discriminators.

2.3. Relation with CycleGAN

It is easy to see our changes only distinguish our model
when more than two domains are present. For the case of
two domains, our entire procedure becomes exactly equiva-
lent to CycleGAN. Because of this, we consider ComboGAN
a proper extension of the CycleGAN model that needs not

change the underlying foundation.

In the case of more than two domains, for the end result to
work as intended, it is implied the encoders must be placing
input images into a shared representation, in which all inputs
are equally ﬁt for any domain transformation. Achieving this
latent space suggests that the encoders learn to conceal quali-
ties that make an image unique or distinguishable among the
domains, with decoders re-ﬁlling them with the necessary de-
tail that deﬁnes that domain’s characteristics. As detailed in
[2], cycle-consistent image translation schemes are known to
hide reconstruction details in often-imperceptible noise. This
could theoretically be avoided by strictly enforcing the latent
space assumption with added losses acting upon intermedi-
ate values (encoder outputs) instead of the decoder outputs.
ComboGAN’s decoupled-generator structure allows for en-
hancements such as this, but for sake of direct comparison
with CycleGAN, we omit tweaks to the objective formulation
in this current experiment.

It should be noted though, that in the case of only two do-
mains (and in CycleGAN), the concept of the images being
taken to a shared latent space need not hold at all. In this sit-
uation, the output of an encoder is always given to the same
decoder, so it will learn to optimize for that speciﬁc domain’s
decoder. In the case of more than two domains, the encoder
output has to be suitable for all other decoders, meaning en-
coders cannot specialize.

4

Figure 6. Validation results for our 14 painters. Original images lie on the diagonal.

3. Experiments and Results

3.1. Datasets

The ﬁrst of two datasets used in this experiment consists
of approximately 6,000 images of the Alps mountain range

scraped from Flickr. The photos are individually categorized
into four seasons based on the provided timestamp of when it
was taken. This way we can translate among Spring, Summer,
Autumn, and Winter.

The other dataset is a collection of approximately 10,000

5

Figure 7. Sample artworks from our 14 painters to visually describe their styles.

paintings total from 14 different artists from Wikiart.org. The
artists used are listed alphabetically: Zdzislaw Beksinski, Eu-
gene Boudin, David Burliuk, Paul Cezanne, Marc Chagall,
Jean-Baptiste-Camille Corot, Eyvind Earle, Paul Gauguin,
Childe Hassam, Isaac Levitan, Claude Monet, Pablo Picasso,
Ukiyo-e (style, not person), and Vincent Van Gogh.

3.2. Setup

All images in our trials were scaled to 256x256 size.
Batches are not used (only one image per input), random
image ﬂipping is enabled, random crops are disabled, and
dropout is not used. Learning rate begins at 0.0002 for gener-
ators and 0.0001 for discriminators, constant for the ﬁrst half
of training and decreasing linearly to zero during the second
half. The speciﬁc architectures for our networks used are de-
tailed in Table A in the appendix. We run our experiments
for 100n epochs, having n domains, as we consider a normal
CycleGAN training with two domains to require 200 epochs
for adequate results. The fourteen painters dataset, for exam-
ple, ran 1400 epochs in 220 hours on our nVidia Titan X GPU.
Note that pairwise CycleGAN instead would have taken about
2860 hours, or four months. Our code is publicly available at
https://github.com/AAnoosheh/ComboGAN

easy ways to change color back and forth, such as color inver-
sion. Meanwhile in Figure 5 we show results from CycleGAN
trained on all six combinations of the four seasons to produce
the same images, demonstrating that ComboGAN maintains
comparable quality, while only training four networks for 400
epochs instead of CyleGAN’s twelve nets for a total of 1200
epochs.

Figure 6 shows randomly-chosen validation images for our
fourteen painters dataset. The ﬁgure contains translations of a
single real image from each artist to every other one. Looking
at columns as a whole, one can see common texture behavior
and color palettes common to the pieces per artist column.
In addition, we have included further real sample artworks
from each artist in Figure 7 to help give a better impression
of what an artist’s style is supposed to be. One piece in the
translation results which stands out almost immediately is the
tenth item under Chagall’s column: this image was styled as
a completely black-and-white sketch. The datasets gathered
did happen to contain a few artworks which were unﬁnished,
preliminary sketches for paintings; this led to the translation
model coincidentally choosing to translate Corot’s painting
to a monochrome pencil/charcoal sketch. Comparison with
CycleGAN is not shown as it is computationally infeasible.

3.3. Discussion

4. Conclusion

Figure 4 shows validation image results for ComboGAN
trained on the Alps seasons photos for 400 iterations. Combo-
GAN did reasonably well converting among the four domains.
Looking closely one can notice many examples hide infor-
mation necessary for the reconstruction process (from train-
ing) within them. Many are semantically-meaningful, such
as the cloud inversion in the summer images, while some are

We have shown a novel construction of the CycleGAN
model as ComboGAN, which solves the θ(n2) scaling issue
inherent in current image translation experiments. Combo-
GAN still maintains the visual richness of CycleGAN with-
out being constrained to two domains. In theory, additional
domains can be appended to an existing ComboGAN model
by simply creating a new encoder/decoder pair to train along-

6

side a pretrained model.

Though the proposed framework is not restricted to Cycle-
GAN, its formulation can be easily extended to UNIT [8], for
example. The model allows for more modiﬁcations, such as
encoder-decoder layer sharing, or to add latent-space losses
to the representations outputted by the encoders. These were
omitted from this work to demonstrate the sole effect of scal-
ing the CycleGAN model and showing it still compares to the
original, without introducing scaling-irrelevant adjustments
that might improve results on their own.

A. Network Architectures

The network architecture used translation experiments is
detailed in Table A. We use the following abbreviations for
brevity: N=Neurons, K=Kernel size, S=Stride size. The trans-
posed convolutional layer is denoted by DCONV. The residual
basic block is denoted as RESBLK.

Table 1. Layer speciﬁcations for Generator (Encoder + Decoder) and
Discriminator

Layer # Encoders

Layer # Decoders

CONV-(N64,K7,S1), InstanceNorm, ReLU
CONV-(N128,K3,S2), InstanceNorm, ReLU
CONV-(N256,K3,S2), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU

RESBLK-(N256,K3,S1), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU
DCONV-(N128,K4,S2), InstanceNorm, ReLU
DCONV-(N64,K4,S2), InstanceNorm, ReLU
CONV-(N3,K7,S1), Tanh

Layer # Discriminators

CONV-(N64,K4,S2), LeakyReLU
CONV-(N128,K4,S2), InstanceNorm, LeakyReLU
CONV-(N256,K4,S2), InstanceNorm, LeakyReLU
CONV-(N512,K4,S1), InstanceNorm, LeakyReLU
CONV-(N1,K4,S1)

1
2
3
4
5
6
7

1
2
3
4
5
6
7
8

1
2
3
4
5

References

[1] Y. Choi, M. Choi, M. Kim, J.-W. Ha, S. Kim, and J. Choo.
StarGAN: Uniﬁed Generative Adversarial Networks for Multi-
Domain Image-to-Image Translation. ArXiv e-prints, Nov.
2017.

[2] C. Chu, A. Zhmoginov, and M. Sandler. CycleGAN: a Master

of Steganography. ArXiv e-prints, Dec. 2017.

[3] L. A. Gatys, A. S. Ecker, and M. Bethge. A Neural Algorithm

of Artistic Style. ArXiv e-prints, Aug. 2015.

[4] I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-
Farley, S. Ozair, A. Courville, and Y. Bengio. Generative ad-
versarial nets. In Advances in neural information processing
systems, pages 2672–2680, 2014.

[5] J. Hoffman, E. Tzeng, T. Park, J.-Y. Zhu, P. Isola, K. Saenko,
A. A. Efros, and T. Darrell. CyCADA: Cycle-Consistent Ad-
versarial Domain Adaptation. ArXiv e-prints, Nov. 2017.
[6] P. Isola, J.-Y. Zhu, T. Zhou, and A. A. Efros. Image-to-Image
Translation with Conditional Adversarial Networks. ArXiv e-
prints, Nov. 2016.

[7] C. Ledig, L. Theis, F. Huszar, J. Caballero, A. Cunningham,
A. Acosta, A. Aitken, A. Tejani, J. Totz, Z. Wang, and W. Shi.
Photo-Realistic Single Image Super-Resolution Using a Gen-
erative Adversarial Network. ArXiv e-prints, Sept. 2016.
[8] M. Liu, T. Breuel, and J. Kautz. Unsupervised image-to-image

translation networks. CoRR, abs/1703.00848, 2017.

[9] F. Luan, S. Paris, E. Shechtman, and K. Bala. Deep photo style

transfer. CoRR, abs/1703.07511, 2017.

[10] X. Mao, Q. Li, H. Xie, R. Y. K. Lau, Z. Wang, and S. P. Smol-
ley. Least Squares Generative Adversarial Networks. ArXiv
e-prints, Nov. 2016.

[11] J.-Y. Zhu, T. Park, P. Isola, and A. A. Efros. Unpaired Image-
to-Image Translation using Cycle-Consistent Adversarial Net-
works. ArXiv e-prints, Mar. 2017.

7

7
1
0
2
 
c
e
D
 
9
1
 
 
]

V
C
.
s
c
[
 
 
1
v
9
0
9
6
0
.
2
1
7
1
:
v
i
X
r
a

ComboGAN:
Unrestrained Scalability for Image Domain Translation

Asha Anoosheh
Computer Vision Lab
ETH Z¨urich
ashaa@ethz.ch

Eirikur Agustsson
Computer Vision Lab
ETH Z¨urich
aeirikur@ethz.ch

Radu Timofte
ETH Z¨urich
Merantix GmbH
timofter@ethz.ch

Luc Van Gool
ETH Z¨urich
KU Leuven
vangool@ethz.ch

Abstract

This year alone has seen unprecedented leaps in the area
of learning-based image translation, namely CycleGAN, by
Zhu et al. But experiments so far have been tailored to merely
two domains at a time, and scaling them to more would re-
quire an quadratic number of models to be trained. And with
two-domain models taking days to train on current hardware,
the number of domains quickly becomes limited by the time
and resources required to process them. In this paper, we pro-
pose a multi-component image translation model and train-
ing scheme which scales linearly - both in resource consump-
tion and time required - with the number of domains. We
demonstrate its capabilities on a dataset of paintings by 14
different artists and on images of the four different seasons in
the Alps. Note that 14 data groups would need (14 choose
2) = 91 different CycleGAN models: a total of 182 genera-
tor/discriminator pairs; whereas our model requires only 14
generator/discriminator pairs.

1. Introduction

In such a short amount of time, we have come such a long
way in the ﬁeld of image domain adaptation and style trans-
fer, with projects such as [11], [8], [5], [6], [9], [3], and more
paving the way. The ﬁrst four are of particular interest as they
do not simply transfer style in terms of texture and color, but
in terms of semantics, and they maintain realism in their re-
sults. But they must be trained on examples from two speciﬁc
domains, whereas the other two do not. The ﬁrst three are
even more noteworthy for being able to do this without any
supervision between the two domains chosen - no pairing of
matching data. Now what if we want to go beyond two do-
mains?

Naively, we could train a model for each pair of domains
(cid:1) = Θ(n2) models
we desire. With n domains, this leads to (cid:0)n
to train. In this work, we approach this problem by dividing
each model into two parts: one that handles the conversion of
one domain into a common representation and one that con-
verts common representations into that domain. Having one

2

of these pairs per domain allows us to mix-and-match by ob-
taining a common representation for any image and translat-
ing it to any other domain. All the while, the number of mod-
els increases linearly with the number of domains, as does the
required training time.

1.1. Generative Adversarial Models

Creating a generative model of natural images is a chal-
lenging task. Such a model needs to be able to capture the
rich distributions from which natural images come from. Gen-
erative Adversarial Networks (GANs) [4] have proven to be
excellent for this task and can produce images of high visual
ﬁdelity. GANs, by default, consist of a pair of models (typi-
cally neural networks): a generator G and a discriminator D.
D is trained to estimate the probability that a sample x comes
from a true training data distribution p(x), while simultane-
ously G is trained turn vector z sampled from its own prior
distribution p(z) into x(cid:48), in order to maximize the value D
outputs when fed x(cid:48). G’s outputs receiving higher score by
D implies the distribution G learns nears the true distribution
p(x).

This training procedure is referred to as adversarial train-
ing and corresponds to a Minimax game between G and D.
Training itself is executed in two alternating steps; ﬁrst D is
trained to distinguish between one or more pairs of real and
generated samples, and then the generator is trained to fool
D with generated samples. Should the discriminator be too
powerful at identifying real photos to begin with, the gener-
ator will quickly learn low-level ”tricks” to fool the discrim-
inator that do not lie along any natural image manifold. For
example, a noisy matrix of pixels can mathematically be a so-
lution that makes D produce a high real-image probability. To
combat this, the training is often done with a small handful of
examples per turn, allowing G and D to gradually improve
alongside each other. The optimization problem at hand can
be formulated as:

min
G

max
D

Ex[logD(x)] + Ez[log(1 − D(G(z))]

(1)

GANs have found applications in many computer vision re-

1

lated domains, including image super-resolution [7] and style
transfer [3].

1.2. Related Works

Many tasks in computer vision and graphics can be thought
of as translation problems where an input image a is to be
translated from domain A to b in another domain B. Isola et
al. [6] introduced an image-to-image translation framework
that uses GANs in a conditional setting where the generator
transforms images conditioned on the existing image a. In-
stead of sampling from a vector distribution p(z) to generate
images, it simply modiﬁes the given input. Their method re-
quires image data from two domains, but it requires they be
aligned in corresponding pairs.

Introduced by Zhu et al., CycleGAN [11] extends
this framework to unsupervised image-to-image translation,
meaning no alignment of image pairs are necessary. Cycle-
GAN consists of two pairs of neural networks, (G, DA) and
(F, DB), where the translators between domains A and B are
G : A → B and F : B → A. DA is trained to discriminate
between real images a and translated images F (a), while DB
is trained to discriminate between images b and G(a). The
system is trained using both an adversarial loss, as expressed
in (1), and a cycle consistency loss expressed in (3). The Cy-
cle consistency loss is a way to regularize the highly uncon-
strained problem of translating an image one-direction alone,
by encouraging the mappings G and F to be inverses of each
other such that F (G(a)) ≈ a and G(F (b)) ≈ b. However,
here the traditional negative log-likelihood loss in (1) is re-
placed by a mean-squared loss (2) that has been shown to be
more stable during training and to produce higher quality re-
sults [10]. The full CycleGAN objective is expressed:

LGAN (G, DB, A, B) =

Eb[(DB(b) − 1)2] + Ea[DB(G(a))2]

(2)

Lcycle(G, F ) =

Ea[||F (G(a)) − a||1] + Eb[||G(F (b)) − b||1]

(3)

L(G, F, DA, DB) = λ Lcycle(G, F )

+ LGAN (G, DB, A, B) + LGAN (F, DA, B, A)

(4)

The reconstruction part of the cycle loss forces the networks
to preserve domain-agnostic detail and geometry in translated
images if they are to be reverted as closely as possible to the
original image. Zhu et al. were able to produce very convinc-
ing image translations such as ones trained to translate be-
tween horses and zebras, between paintings and photographs,
and between artistic styles.

Liu et al. [8] implemented a similar approach with UNIT,
adding further losses to the intermediate activation results

within the generator instead of purely on the ﬁnal generated
outputs. Using the CycleGAN architecture, they designate
the activations from the central layer of the generators as the
shared latent vectors. Using a variational-autoencoder loss,
these vectors from both domains are pushed into a gaussian
distribution. This is done in addition to the discriminator
loss and cycle loss from CycleGAN, seemingly improving the
image translation task over CycleGAN in cases with signiﬁ-
cantly varying geometry in the domains.

Lastly there is the concurrent work of StarGAN [1], which
aims to solve a similar problem as ours: scalability of unsu-
pervised image-translation methods. StarGAN melds the gen-
erators and discriminators from CycleGAN into one generator
and discriminator used in common by all domains. As such,
the model can take as input any number of domains, though
this requires passing in a vector along with each input to the
generator specifying the output domain desired. Meanwhile
the discriminator is trained to output the detected domain of
an image along with a real/fake label, as opposed to simply the
latter when each domain has its own discriminator. The results
suggest having a shared model for domains similar enough to
each other may be beneﬁcial to the learning process. Never-
theless, this method was only applied to the task of face at-
tribute modiﬁcation, where all the domains were slight shifts
in qualities of the same category of images: human faces.

2. The ComboGAN Model

Figure 1. Model design setup for N domains.

2

Figure 2. Generator training pass for direction X → Y , where X, Y ∈ {1, .., n} : X (cid:54)= Y are randomly chosen from our n domains at the
start of every iteration. This pass is always repeated symmetrically for direction Y → X as well.

encoders and decoders of our trained model like building
blocks, taking as input any domain and outputting any other.
For example during inference, to transform an image x from
an arbitrary domain X to y from domain Y , we simply per-
form y = GY X (x) = DecoderY (EncoderX (x)). The re-
sult of EncoderX (x) can even be cached when translating to
other domains as not to repeat computation.

With only one generator (an encoder-decoder pair) per do-
main, the number of generators scales exactly linearly with the
number of domains, instead of 2(cid:0)n
(cid:1) = n(n − 1) = Θ(n2).
The discriminators remain untouched in our experiment; the
number of discriminators already scales linearly when each
domain receives its own. Figure 1 displays our full setup.

2

2.2. Training

Fully utilizing the same losses as CycleGAN involves fo-
cusing on two domains, as the generator’s cyclic training and
discriminator’s true/false-pair training are not directly adapt-
able for more domains. ComboGAN’s training procedure in-
volves focusing on 2 of our n domains at a time. At the begin-
ning of each iteration, we select two domains X, Y ∈ {1..n}
from our n domains, uniformly at random. Then maintaining
the same notation as CycleGAN in (4), we set A := X and
B := Y and proceed as CycleGAN would for the remainder
of the iteration. Figure 2 shows one of the two forward passes
in a training iteration. The other half is simply the symmetric
mirroring of the procedure for the other domain, as if the two
were swapped.

Randomly choosing between two domains per iteration
means we should eventually cover training between all pairs
of domains uniformly. Though of course the training time
(number of iterations) required must increase as well. If train-
ing between two domains with CycleGAN requires k2 itera-
tions, then with n domains, (cid:0)n
(cid:1) CycleGAN setups would re-
(cid:1) iterations to complete. In our situation, we instead
quire k2

2

(cid:0)n
2

Figure 3. Example inference functionality of translation from one
domain to all others.

2.1. Decoupling the Generators

The scalability of setups such as CycleGAN’s is hindered
by the fact that both networks used are tied jointly to two do-
mains, one from some domain A to B and the other from B to
A. To add another domain C, we would then need to add four
new networks, A to C, C to A, B to C, and C to B. To solve
this issue of exploding model counts, we introduce a new
model, ComboGAN, which decouples the domains and net-
works from each other. ComboGAN’s generator networks are
identical to the networks used in CycleGAN (see Appendix
A for network speciﬁcations), yet we divide each one in half,
labeling the frontal halves as encoders and the latter halves as
decoders. We can now assign an encoder and decoder to each
domain.

As the name ComboGAN suggests, we can combine the

3

Figure 4. Validation results for pictures of the Alps in all four sea-
sons. Original images lie on the diagonal.

Figure 5. Same Alps images but from standard CycleGAN results
instead. Original images lie on the diagonal.

keep the training linear in the number of domains, since the
number of parameters (weights) in our model increases lin-
early with the number of domains, as well. We desire each
domain to be chosen for a training iteration the same number
of times as in CycleGAN. Note that it will not be the same
number of times that a given pair is chosen, as achieving that
would just require the same number of iterations as the naive
method; rather we only care about whether a domain is chosen
to be trained alongside any other domain or not. We observe
that since a domain X is chosen in each iteration with prob-
n , during training it is chosen in expectation n
ability 2
2 · kn
times. Requiring equality to the two-domain case k2, we ob-
2 n, or k2
tain kn = k2
2 iterations per domain, which proves
satisfactory in practice.

As for the discriminators, training is the same as Cycle-
GAN’s. After each training iteration for two given generators,
the two corresponding discriminators receive a training iter-
ation, as well. For a single discriminator, a real image from
its domain and a fake image intended for the same domain
(the output of that domain’s decoder) are fed to train the net-
work to better distinguish real and fake images. This is done
independently for both discriminators.

2.3. Relation with CycleGAN

It is easy to see our changes only distinguish our model
when more than two domains are present. For the case of
two domains, our entire procedure becomes exactly equiva-
lent to CycleGAN. Because of this, we consider ComboGAN
a proper extension of the CycleGAN model that needs not

change the underlying foundation.

In the case of more than two domains, for the end result to
work as intended, it is implied the encoders must be placing
input images into a shared representation, in which all inputs
are equally ﬁt for any domain transformation. Achieving this
latent space suggests that the encoders learn to conceal quali-
ties that make an image unique or distinguishable among the
domains, with decoders re-ﬁlling them with the necessary de-
tail that deﬁnes that domain’s characteristics. As detailed in
[2], cycle-consistent image translation schemes are known to
hide reconstruction details in often-imperceptible noise. This
could theoretically be avoided by strictly enforcing the latent
space assumption with added losses acting upon intermedi-
ate values (encoder outputs) instead of the decoder outputs.
ComboGAN’s decoupled-generator structure allows for en-
hancements such as this, but for sake of direct comparison
with CycleGAN, we omit tweaks to the objective formulation
in this current experiment.

It should be noted though, that in the case of only two do-
mains (and in CycleGAN), the concept of the images being
taken to a shared latent space need not hold at all. In this sit-
uation, the output of an encoder is always given to the same
decoder, so it will learn to optimize for that speciﬁc domain’s
decoder. In the case of more than two domains, the encoder
output has to be suitable for all other decoders, meaning en-
coders cannot specialize.

4

Figure 6. Validation results for our 14 painters. Original images lie on the diagonal.

3. Experiments and Results

3.1. Datasets

The ﬁrst of two datasets used in this experiment consists
of approximately 6,000 images of the Alps mountain range

scraped from Flickr. The photos are individually categorized
into four seasons based on the provided timestamp of when it
was taken. This way we can translate among Spring, Summer,
Autumn, and Winter.

The other dataset is a collection of approximately 10,000

5

Figure 7. Sample artworks from our 14 painters to visually describe their styles.

paintings total from 14 different artists from Wikiart.org. The
artists used are listed alphabetically: Zdzislaw Beksinski, Eu-
gene Boudin, David Burliuk, Paul Cezanne, Marc Chagall,
Jean-Baptiste-Camille Corot, Eyvind Earle, Paul Gauguin,
Childe Hassam, Isaac Levitan, Claude Monet, Pablo Picasso,
Ukiyo-e (style, not person), and Vincent Van Gogh.

3.2. Setup

All images in our trials were scaled to 256x256 size.
Batches are not used (only one image per input), random
image ﬂipping is enabled, random crops are disabled, and
dropout is not used. Learning rate begins at 0.0002 for gener-
ators and 0.0001 for discriminators, constant for the ﬁrst half
of training and decreasing linearly to zero during the second
half. The speciﬁc architectures for our networks used are de-
tailed in Table A in the appendix. We run our experiments
for 100n epochs, having n domains, as we consider a normal
CycleGAN training with two domains to require 200 epochs
for adequate results. The fourteen painters dataset, for exam-
ple, ran 1400 epochs in 220 hours on our nVidia Titan X GPU.
Note that pairwise CycleGAN instead would have taken about
2860 hours, or four months. Our code is publicly available at
https://github.com/AAnoosheh/ComboGAN

easy ways to change color back and forth, such as color inver-
sion. Meanwhile in Figure 5 we show results from CycleGAN
trained on all six combinations of the four seasons to produce
the same images, demonstrating that ComboGAN maintains
comparable quality, while only training four networks for 400
epochs instead of CyleGAN’s twelve nets for a total of 1200
epochs.

Figure 6 shows randomly-chosen validation images for our
fourteen painters dataset. The ﬁgure contains translations of a
single real image from each artist to every other one. Looking
at columns as a whole, one can see common texture behavior
and color palettes common to the pieces per artist column.
In addition, we have included further real sample artworks
from each artist in Figure 7 to help give a better impression
of what an artist’s style is supposed to be. One piece in the
translation results which stands out almost immediately is the
tenth item under Chagall’s column: this image was styled as
a completely black-and-white sketch. The datasets gathered
did happen to contain a few artworks which were unﬁnished,
preliminary sketches for paintings; this led to the translation
model coincidentally choosing to translate Corot’s painting
to a monochrome pencil/charcoal sketch. Comparison with
CycleGAN is not shown as it is computationally infeasible.

3.3. Discussion

4. Conclusion

Figure 4 shows validation image results for ComboGAN
trained on the Alps seasons photos for 400 iterations. Combo-
GAN did reasonably well converting among the four domains.
Looking closely one can notice many examples hide infor-
mation necessary for the reconstruction process (from train-
ing) within them. Many are semantically-meaningful, such
as the cloud inversion in the summer images, while some are

We have shown a novel construction of the CycleGAN
model as ComboGAN, which solves the θ(n2) scaling issue
inherent in current image translation experiments. Combo-
GAN still maintains the visual richness of CycleGAN with-
out being constrained to two domains. In theory, additional
domains can be appended to an existing ComboGAN model
by simply creating a new encoder/decoder pair to train along-

6

side a pretrained model.

Though the proposed framework is not restricted to Cycle-
GAN, its formulation can be easily extended to UNIT [8], for
example. The model allows for more modiﬁcations, such as
encoder-decoder layer sharing, or to add latent-space losses
to the representations outputted by the encoders. These were
omitted from this work to demonstrate the sole effect of scal-
ing the CycleGAN model and showing it still compares to the
original, without introducing scaling-irrelevant adjustments
that might improve results on their own.

A. Network Architectures

The network architecture used translation experiments is
detailed in Table A. We use the following abbreviations for
brevity: N=Neurons, K=Kernel size, S=Stride size. The trans-
posed convolutional layer is denoted by DCONV. The residual
basic block is denoted as RESBLK.

Table 1. Layer speciﬁcations for Generator (Encoder + Decoder) and
Discriminator

Layer # Encoders

Layer # Decoders

CONV-(N64,K7,S1), InstanceNorm, ReLU
CONV-(N128,K3,S2), InstanceNorm, ReLU
CONV-(N256,K3,S2), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU

RESBLK-(N256,K3,S1), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU
RESBLK-(N256,K3,S1), InstanceNorm, ReLU
DCONV-(N128,K4,S2), InstanceNorm, ReLU
DCONV-(N64,K4,S2), InstanceNorm, ReLU
CONV-(N3,K7,S1), Tanh

Layer # Discriminators

CONV-(N64,K4,S2), LeakyReLU
CONV-(N128,K4,S2), InstanceNorm, LeakyReLU
CONV-(N256,K4,S2), InstanceNorm, LeakyReLU
CONV-(N512,K4,S1), InstanceNorm, LeakyReLU
CONV-(N1,K4,S1)

1
2
3
4
5
6
7

1
2
3
4
5
6
7
8

1
2
3
4
5

References

[1] Y. Choi, M. Choi, M. Kim, J.-W. Ha, S. Kim, and J. Choo.
StarGAN: Uniﬁed Generative Adversarial Networks for Multi-
Domain Image-to-Image Translation. ArXiv e-prints, Nov.
2017.

[2] C. Chu, A. Zhmoginov, and M. Sandler. CycleGAN: a Master

of Steganography. ArXiv e-prints, Dec. 2017.

[3] L. A. Gatys, A. S. Ecker, and M. Bethge. A Neural Algorithm

of Artistic Style. ArXiv e-prints, Aug. 2015.

[4] I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-
Farley, S. Ozair, A. Courville, and Y. Bengio. Generative ad-
versarial nets. In Advances in neural information processing
systems, pages 2672–2680, 2014.

[5] J. Hoffman, E. Tzeng, T. Park, J.-Y. Zhu, P. Isola, K. Saenko,
A. A. Efros, and T. Darrell. CyCADA: Cycle-Consistent Ad-
versarial Domain Adaptation. ArXiv e-prints, Nov. 2017.
[6] P. Isola, J.-Y. Zhu, T. Zhou, and A. A. Efros. Image-to-Image
Translation with Conditional Adversarial Networks. ArXiv e-
prints, Nov. 2016.

[7] C. Ledig, L. Theis, F. Huszar, J. Caballero, A. Cunningham,
A. Acosta, A. Aitken, A. Tejani, J. Totz, Z. Wang, and W. Shi.
Photo-Realistic Single Image Super-Resolution Using a Gen-
erative Adversarial Network. ArXiv e-prints, Sept. 2016.
[8] M. Liu, T. Breuel, and J. Kautz. Unsupervised image-to-image

translation networks. CoRR, abs/1703.00848, 2017.

[9] F. Luan, S. Paris, E. Shechtman, and K. Bala. Deep photo style

transfer. CoRR, abs/1703.07511, 2017.

[10] X. Mao, Q. Li, H. Xie, R. Y. K. Lau, Z. Wang, and S. P. Smol-
ley. Least Squares Generative Adversarial Networks. ArXiv
e-prints, Nov. 2016.

[11] J.-Y. Zhu, T. Park, P. Isola, and A. A. Efros. Unpaired Image-
to-Image Translation using Cycle-Consistent Adversarial Net-
works. ArXiv e-prints, Mar. 2017.

7

