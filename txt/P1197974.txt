CSGNet: Neural Shape Parser for Constructive Solid Geometry

Gopal Sharma Rishabh Goyal Difan Liu

Evangelos Kalogerakis

Subhransu Maji

University of Massachusetts, Amherst
{gopalsharma,risgoyal,dliu,kalo,smaji}@cs.umass.edu

Abstract

We present a neural architecture that takes as input a 2D or
3D shape and outputs a program that generates the shape.
The instructions in our program are based on construc-
tive solid geometry principles, i.e., a set of boolean op-
erations on shape primitives deﬁned recursively. Bottom-
up techniques for this shape parsing task rely on primitive
detection and are inherently slow since the search space
over possible primitive combinations is large. In contrast,
our model uses a recurrent neural network that parses the
input shape in a top-down manner, which is signiﬁcantly
faster and yields a compact and easy-to-interpret sequence
of modeling instructions. Our model is also more effective
as a shape detector compared to existing state-of-the-art de-
tection techniques. We ﬁnally demonstrate that our network
can be trained on novel datasets without ground-truth pro-
gram annotations through policy gradient techniques.

1. Introduction

8
1
0
2
 
r
a

M
 
1
3
 
 
]

V
C
.
s
c
[
 
 
2
v
0
9
2
8
0
.
2
1
7
1
:
v
i
X
r
a

Figure 1. Our shape parser produces a compact program that
generates an input 2D or 3D shape. On top is an input image of
2D shape, its program and the underlying parse tree where primi-
tives are combined with boolean operations. On the bottom is an
input voxelized 3D shape, the induced program, and the resulting
shape from its execution.

In recent years, there has been a growing interest in gen-
erative models of 2D or 3D shapes, especially through
the use of deep neural networks as image or shape pri-
ors [28, 9, 12, 16]. However, current methods are limited
to the generation of low-level shape representations con-
sisting of pixels, voxels, or points. Human designers, on the
other hand, rarely model shapes as a collection of these indi-
vidual elements. For example, in vector graphics modeling
packages (Inkscape, Illustrator, and so on), shapes are often
created through higher-level primitives, such as parametric
curves (e.g., Bezier curves) or basic shapes (e.g., circles,
polygons), as well as operations acting on these primitives,
such as boolean operations, deformations, extrusions, and
so on. The reason for choosing higher-level primitives is not
incidental. Describing shapes with as few as possible primi-
tives and operations is highly desirable for designers since it
is compact, makes subsequent editing easier, and is perhaps
better at capturing aspects of human shape perception such
as view invariance, compositionality, and symmetry [5].

The goal of our work is to develop an algorithm that parses
shapes into their constituent modeling primitives and oper-
ations within the framework of Constructive Solid Geome-
try (CSG) modeling [29] as seen in Figure 1. This poses a
number of challenges. First, the number of primitives and
operations is not the same for all shapes i.e., our output does
not have constant dimensionality, as in the case of pixel ar-
rays, voxel grids, or ﬁxed point sets. Second, the order of
these operations matters. Figure 1 demonstrates an example
where a complex object is created through boolean opera-
tions that combine simpler objects. If one performs a small
change e.g., swap two operations, the resulting object be-
comes entirely different. From this aspect, the shape mod-
eling process could be thought of as a visual program i.e.,
an ordered set of modeling instructions. Finally, a challenge
is that we would like to learn an efﬁcient parser that gener-
ates a compact program (e.g., with the fewest instructions)
without relying on a vast number of shapes annotated with
their programs for a target domain.

1

To tackle these challenges we designed a memory-enabled
network architecture, that given a target 2D image of a
shape, or a target 3D shape, generates a CSG program to
generate it. To train our network we created a large syn-
thetic dataset of automatically generated 2D and 3D pro-
grams. Networks trained on this dataset however lead to
poor generalization when applied to new domains. To
adapt models to new domains without program annotations
we employ policy gradient techniques from the reinforce-
ment learning literature [44]. Combining our parser with a
CSG rendering engine allows the parser to receive feedback
based on the visual difference between the target shape and
generated shape. Thus the parser network can be trained to
minimize this difference.

Our contributions are as follows. First we show that the
proposed architecture is efﬁcient and effective at inferring
CSG programs for 2D and 3D shapes across a number of do-
mains. Second we show that the parser can be learned using
reinforcement learning techniques on novel datasets with-
out program annotations. Third, we show that the parser is
a better and faster shape detector than state-of-the art detec-
tion approaches that only rely on bottom-up cues. We con-
jecture that this is because the parser jointly reasons about
presence and ordering during parsing unlike the detector.

2. Related Work

Our work is primarily related to neural program induc-
tion methods. Secondly, it is also related to “vision-as-
inverse-graphics” approaches, as well as neural network-
based methods that predict shape primitives or parameters
of procedural graphics models. Below, we brieﬂy overview
these prior methods, and explain differences from our work.

Neural program induction. Our method is inspired by
recent progress in neural network-based methods that infer
programs expressed in some high-level language to solve a
task. These methods often employ variants of recurrent neu-
ral networks whose parameters are trained to predict desired
program outputs given exemplar inputs, such as answers to
questions involving complex arithmetic, logical, or seman-
tic parsing operations [32, 35, 11, 4, 23, 49, 48, 24, 30].

In the context of visual reasoning, several authors [22, 20]
proposed architectures that produce programs composed of
functions that perform compositional reasoning on the in-
put image. They also incorporate an execution engine that
produces the result of the program through a neural mod-
ule network [3]. In contrast our method aims to produce a
generative program consisting of shape modeling functions
that match a target image.

Vision-as-inverse-graphics. A well-known approach to
visual analysis is to generate and ﬁt hypotheses of scenes

or objects to input image data i.e., perform analysis-by-
syntesis [47]. Kulkani et al. [27] proposed sampling-based
probabilistic inference to estimate parameters of stochas-
tic graphics models (e.g., human body parameters, or pa-
rameters of rotationally symmetric objects) representing
the space of hypothesized scenes given an input image.
Shape grammars (or so-called inverse procedural model-
ing techniques) have alternatively been used in analysis-by-
synthesis image parsing frameworks [42, 31], yet they have
the disadvantage of not modeling long-range dependencies
in the parsing task, and are often speciﬁc to a particular
shape class (e.g., buildings). More recent approaches em-
ploy Convolutional Neural Network (CNN) to infer param-
eters of objects [28] or whole scenes [39]. A similar trend is
observed in graphics applications where CNNs are used to
map input images or partial shapes to procedural model pa-
rameters [21, 38, 33]. Wu et al. [45] detect objects in scenes
by employing a network for producing object proposals and
a network that predicts whether there is an object in a pro-
posed segment, along with various object attributes. Eslami
et al. [15] uses a recurrent neural network to attend to one
object at a time in a scene, and learn to use an appropriate
number of inference steps to recover object counts, identi-
ties and poses.

In contrast, we do not aim at parsing images or scenes into a
collection of objects and their parameters. We instead parse
input images or 3D shapes into a sequence of modeling op-
erations on primitives (i.e, a visual program) to match a
target image. In our setting, the space of outputs is much
larger and the order of operations in our visual programs
matter. To deal with this complexity, we use a combination
of supervised pretraining, reinforcement learning, reward
design, and post-optimization of modeling parameters, de-
scribed in the next Section.

Neural primitive ﬁtting. Tulsiani et al. [43] proposed a
volumetric convolutional network architecture that predicts
a ﬁxed number of cuboidal primitives to describe an input
3D shape. To better handle a variable number of prim-
itives, Zou et al. [50] instead proposed an LSTM-based
architecture that predicts boxes given input depth images.
We also aim at deriving geometrically interpretable expla-
nations of shapes in terms of primitives. However, our net-
work is not limited to predicting a single type of primitives
(e.g., cubes), but also outputs modeling operations acting on
them, or in other words supports a signiﬁcantly richer mod-
eling paradigm. The program can be used not only to geo-
metrically describe the input shape but can also be directly
edited to manipulate it if desired. Finally, Ellis et al. [14]
proposed a neural network architecture to extract various
hand-drawn primitives (lines, circles, rectangles) in images,
which are then grouped into Latex programs. Their pro-
gram synthesis is posed as a constraint satisfaction problem

Figure 2. Architecture of our neural shape parser (CSGNet). CSGNet consists of three parts, ﬁrst an encoder takes a shape (2D or
3D) as input and outputs a feature vector through a CNN. Second, a decoder maps these features to a sequence of modeling instructions
yielding a visual program. Third, the rendering engine processes the program and outputs the ﬁnal shape. The primitives annotated as
P 1, P 2, P 3, P 4 are predicted by the network, while E1, E2 are the outputs of boolean modeling operations acting on intermediate shapes.

which is computationally expensive and can take hours to
solve. Instead, our program is created by a neural network
that takes a fraction of a second to evaluate at test time.

Bottom-up parsing. Our work is related to approaches
for shape parsing using grammars [18, 17, 46, 7, 6, 42, 31,
41, 37]. These have been applied to objects that can be rep-
resented using tree-structured grammars (e.g., human bod-
ies, buildings). However such approaches often use shallow
grammars or accurate bottom-up proposals (e.g., face and
limb detection) to guide parsing.
In the context of CSG,
primitive detection is challenging as shapes change signiﬁ-
cantly when boolean operations are applied to them. Parse
trees for CSG also tend to be deeper. As a result, bottom-up
parsing becomes computationally expensive since the com-
plexity scales exponentially with the program length.

3. Designing a Neural Shape Parser

In this section, we ﬁrst present our neural shape parser
that can induce programs for 2D/3D shapes. The goal
of the parser π is to produce a sequence of instructions
given an input shape. The parser can be implemented
as an encoder-decoder using neural network modules as
shown in Figure 2. The encoder takes as input an im-
age I and produces an encoding Φ(I) using a CNN. The
decoder Θ takes as input Φ(I) and produces a probabil-
ity distribution over programs P represented as a sequence
of instructions. Decoders can be implemented using Re-
current Neural Networks (RNNs). We employ Gated Re-
current Units (GRUs) [10] that have been widely used for

sequential prediction tasks such as generating natural lan-
guage and speech. The overall network can be written as
π(I) = Θ ◦ Φ(I). The space of programs can be efﬁ-
ciently described according to a context-free grammar [19].
For example, in constructive solid geometry the instructions
consist of drawing primitives (e.g., spheres, cubes, cylin-
ders, etc.) and performing boolean operations described as
a grammar with the following production rules:

S → E

E → E E T | P
T → OP1|OP2| . . . |OPm
P → SHAPE1|SHAPE2| . . . |SHAPEn

Each rule indicates possible derivations of a non-terminal
symbol separated by the | symbol. Here S is the start sym-
bol, OPi is chosen from a set of deﬁned modeling opera-
tions and the SHAPEi is a primitive chosen from a set of
basic shapes at different positions, scales, orientations, etc.
Instructions can be written in a standard post-ﬁx notation,
e.g. SHAPE1SHAPE2OP1SHAPE3OP2. Figure 2 also gives
an example of a program predicted by the network, that fol-
lows the grammar described above.

3.1. Learning

Given an input I the parser network π generates a program
that minimizes a reconstruction error between the shape
produced by executing the program and a target shape. Note
that not all programs are valid hence the network must also
learn to generate grammatical programs.

Supervised learning: When target programs are avail-
able the architecture can be trained with standard supervised
learning techniques. Training data in this case consists of
shape and program pairs (I i, P i), i = 1, . . . , N . In our im-
plementation, the RNN produces a categorical distribution
πθ over instructions a ∈ A at every time step. Similarly
the ground-truth program P i can be written as sequence of
instructions gi
, where Ti is the length of the pro-
gram P i. The parameters θ can be learned to maximize the
log-likelihood of the ground truth instructions:

2 .. gi
Ti

1, gi

L(θ) =

log πθ(gi

t|g1:t−1, I i).

(1)

N
(cid:88)

Ti(cid:88)

i=1

t=1

Learning with policy gradients. Without
target pro-
grams one can minimize a reconstruction error between
the shape obtained by executing the program and the tar-
get. However, directly minimizing this error using gradient-
based techniques is not possible since the output space is
discrete and execution engines are typically not differen-
tiable. Policy gradient techniques [44] from the reinforce-
ment learning (RL) literature can instead be used in this
case.

Concretely, the parser πθ, that represents a policy network,
can be used to sample a program y = (a1,a2 .. aT ) con-
ditioned on the input shape I. Then a reward R can be
estimated by measuring the similarity between the gener-
ated image ˆI obtained by executing the program and the
target shape I. With this setup, we want to learn the net-
work parameters θ that maximize the expected rewards over
programs sampled under the predicted distribution πθ(I)
across images I sampled from a distribution D:
(cid:2)Jθ(I)(cid:3) = EI∼DEy∼πθ(I)) [R] .

EI∼D

The outer expectation can be replaced by a sample estimate
on the training data. The gradient of the inner expectation
can be obtained by rearranging the equation as:

∇θJθ(I) = ∇θ

πθ(y)R =

∇θ log πθ(y) (cid:2)πθ(y)R(cid:3) .

(cid:88)

y

(cid:88)

y

t ∼ πθ(at|ˆas

ys is obtained by sampling instructions ˆas
t=1:T from the dis-
tribution ˆas
1:t−1; I) at every time step t, till the
stop symbol (EOS) is sampled. The reward Rs is calcu-
lated by executing the program ys. Sampling-based esti-
mates typically have high variance that can be reduced by
subtracting a baseline without changing the bias as:

1
S

S
(cid:88)

T
(cid:88)

s=1

t=1

∇θJθ(I) =

∇θ log πθ(ˆas

t |ˆas

1:t−1, I)(Rs − b).

(2)
A good choice of the baseline is the expected value of re-
turns starting from t [40, 44]. We compute baseline as the
running average of past rewards.

Reward. The rewards should be primarily designed to en-
courage visual similarity of the generated program with the
target. Visual similarity between two shapes is measured
using the Chamfer distance (CD) between points on the
edges of each shape. The CD is between two point sets,
x and y, is deﬁned as follows:

Ch(x, y) =

min
y∈y

(cid:107)x − y(cid:107)2+

min
x∈x

(cid:107)x − y(cid:107)2 .

1
2|x|

(cid:88)

x∈x

1
2|y|

(cid:88)

y∈y

The points are scaled by the image diagonal,
thus
Ch(x, y) ∈ [0, 1] ∀x, y. The distance can be efﬁciently
computed using distance transforms.
In our implementa-
tion, we also set a maximum length T for the induced
programs to avoid having too long or redundant programs
(e.g., repeating the same modeling instructions over and
over again). We then deﬁne the reward as:

(cid:40)

R =

f (cid:0)Ch(Edge(I), Edge(Z(y)(cid:1) ,
0,

y is valid
y is invalid.

where f is a shaping function and Z is the CSG rendering
engine. Since invalid programs get zero reward, the maxi-
mum length constraint on the programs encourages the net-
work to produce shorter programs with high rewards. We
use maximum length T = 13 in all of our RL experiments.
The function f shapes the CD as f (x) = (1 − x)γ with an
exponent γ > 0. Higher values of γ encourages CD close
to zero. We found that γ = 20 provides a good trade-off
between program length and visual similarity.

It is often intractable to compute the expectation Jθ(I) since
the space of programs is very large. Hence the expectation
must be approximated. The popular REINFORCE [44] al-
gorithm computes a Monte-Carlo estimate as:

3.2. Inference

∇θJθ(I) =

∇ log πθ(ˆas

t |ˆas

1:t−1, I)Rs,

1
S

S
(cid:88)

T
(cid:88)

s=1

t=1

by sampling S programs from the policy πθ. Each program

Greedy decoding and beam search. Estimating the most
likely program given an input is intractable using RNNs.
Instead one usually employs a greedy decoder that picks
the most likely instruction at each time step. An alternate
is to use a beam search procedure that maintains the k-best
likely sequences at each time step. In our experiments we
report results with varying beam sizes.

Visually-guided reﬁnement. Our parser produces a pro-
gram with a discrete set of primitives. However, further
reﬁnement can be done by directly optimizing the position
and size of the primitives to maximize the reward. The re-
ﬁnement step keeps the program structure of the program
and primitive type ﬁxed but uses a heuristic algorithm [34]
to optimize the parameters using feedback from the render-
ing engine. On our dataset where shapes have up to 7 prim-
itives, the search space is relatively small and the algorithm
converges to a local minima in about 10 iterations and con-
sistently improves the results.

4. Experiments

We describe our experiments on different datasets exploring
the generalization capabilities of our network (CSGNet).
We ﬁrst describe our datasets: (i) an automatically gener-
ated dataset of 2D and 3D shapes based on synthetic gen-
eration of CSG programs, (ii) 2D CAD shapes mined from
the web where ground-truth programs are not available, and
(iii) logo images mined also from the web where ground-
truth programs are also not available. We discuss our quali-
tative and quantitative results on the above datasets.

4.1. Datasets

Figure 3. Samples created from our synthetically generated
programs. 2D samples in top row and 3D samples in bottom row.

To train our network in the supervised learning setting, we
automatically created a large set of 2D and 3D CSG-based
synthetic programs according to the grammars described
below.

Synthetic 2D shapes. We sampled derivations of the fol-
lowing CSG grammar to create our synthetic dataset in the
2D case:

S → E;

E → EET | P (L, R);

T → intersect | union | subtract;

P → square | circle | triangle;
L → (cid:2)8 : 8 : 56(cid:3)2

; R → (cid:2)8 : 4 : 32(cid:3).

Program
Length
3
5
7
9
11
13

2D

3D

5k

5k

Train Val Test Train Val Test
25k
100k 10k 20k
100k 10k 50k 200k 20k 40k
150k 20k 50k 400k 40k 80k
250k 20k 50k
350k 20k 100k
350k 20k 100k

-
-
-

-
-
-

-
-
-

Table 1. Statistics of our 2D and 3D synthetic dataset.

Primitives are speciﬁed by their type: square, circle, or tri-
angle, locations L and circumscribing circle of radius R on
a canvas of size 64×64. There are three boolean operations:
intersect, union, and subtract. L is discretized to lie on
a square grid with spacing of 8 units and R is discretized
with spacing of 4 units. The triangles are assumed to be
upright and equilateral. The synthetic dataset is created by
sampling random programs containing different number of
primitives from the above grammar, constraining the distri-
bution of various primitive types and operation types to be
uniform. We also ensure that no duplicate programs exist in
our dataset. The primitives are rendered as binary images
and the programs are executed on a canvas of 64 × 64 pix-
els. Samples from our dataset are shown in Figure 3. Table
1 provides details about the size and splits of our dataset.

Synthetic 3D shapes. We sampled derivations of the fol-
lowing grammar in the case of 3D CSG:

S → E; E → EET ;

E → sp(L, R) | cu(L, R) | cy(L, R, H)
T → intersect | union | subtract;
L → (cid:2)8 : 8 : 56]3
R → (cid:2)8 : 4 : 32]; H → (cid:2)8 : 4 : 32].

The same three binary operations are used as in the 2D case.
Three basic solids are denoted by ‘sp’: Sphere, ‘cu’: Cube,
‘cy’: Cylinder. L represents the center of primitive in 3D
voxel grid. R speciﬁes radius of sphere and cylinder, and
also speciﬁes size of cube. H is the height of cylinder. The
primitives are rendered as voxel grids and the programs are
executed on a 3D volumetric grid of size 64 × 64 × 64.
We used the same random sampling method as described
for the synthetic 2D dataset, resulting in 3D CSG programs.
3D shape samples from this dataset are shown in Figure 3.

2D CAD shapes. We collected 8K CAD shapes from the
Trimble 3DWarehouse dataset [2] in three categories: chair,
desk and lamps. We rendered the CAD shapes into 64 × 64
binary masks from their front and side views. In Section 4,
we show that the rendered shapes can be parsed effectively
through our visual program induction method. We split this
dataset into 5K shapes for training, 1.5K validation and
1.5K for testing.

Web logos. We mined a collection of binary logos from
the web that can be modeled using the primitives in our out-
put shapes. We test our approach on these logos without
further training or ﬁne-tuning our net on this data.

4.2. Implementation details

The input 2D or 3D shape I is represented as pixel and
voxel occupancy grid respectively. Our encoder is based
on an image-based convnet in the case of 2D inputs, and
a volumetric convnet in the case of 3D inputs. The output
of the encoder Φ(I) is passed as input to our GRU-based
decoder at every program step. The hidden state of our
GRU units is passed through two fully-connected layers,
which are then converted into a probability distribution over
program instructions through a classiﬁcation layer. For the
2D CSG there are 400 unique instructions corresponding to
396 different primitive types, discrete locations and sizes,
the 3 boolean operations and the stop symbol. For the 3D
CSG there are 6635 unique instructions with 6631 different
types of primitives with different sizes and locations, plus
3 boolean modeling operations and a stop symbol. During
training, on synthetic dataset, we sample images rendered
from programs of variable length (up to 13 for 2D and up to
7 for 3D dataset) from training dataset. More details about
the architecture of our encoder and decoder (number and
type of layers) are provided in the supplementary material.

For supervised learning, we use the Adam optimizer [25]
with learning rate 0.001 and dropout of 0.2 in non-recurrent
network connections. For reinforcement learning, we use
stochastic gradient descent with 0.9 momentum, 0.01 learn-
ing rate, and with the same dropout as above. Our im-
plementation is based on PyTorch [1]. Our source code
and datasets are available on our project page: https:
//hippogriff.github.io/CSGNet.

4.3. Results

We evaluate our network, called CSGNet, in two different
ways: (i) as a model for inferring the entire program, and (ii)
as model for inferring primitives, i.e., as an object detector.

4.3.1 Inferring programs

Evaluation on the synthetic 2D shapes. We perform su-
pervised learning to train CSGNet on the training split of
this synthetic dataset, and evaluate performance on its test
split under different beam sizes. We compare with a base-
line that retrieves a program in the training split using a
Nearest Neighbor (NN) approach. In NN setting, the pro-
gram for a test image is retrieved by taking the program of
the train image that is most similar to the test image. Table 2
compares CSGNet to this NN baseline using the Chamfer
distance between the test target and predicted shapes. Our

Method NN

CD

1.94

CSGNet
k=5
1.46

k=10
1.39

k=1
1.69

Table 2. Comparison of the supervised network (CSGNet) with
the NN baseline on the synthetic 2D dataset. Results are shown
using Chamfer Distance (CD) metric by varying beam sizes (k)
during decoding. CD is in number of pixels.

parser is able to outperform the NN method. One would
expect that NN would perform well here because the size
of the training set is large. However, our results indicate
that our compositional parser is better at capturing shape
variability, which is still signiﬁcant in this dataset. Results
are also shown with increasing beam sizes (k) during de-
coding, which consistently improves performance. Figure 4
also shows the programs retrieved through NN and our gen-
erated program for a number of characteristic examples in
our test split of our synthetic dataset.

Figure 4. Comparison of performance on synthetic 2D dataset.
a) Input image, b) NN-retrieved image, c) top-1 prediction, and d)
best result from top-10 beam search predictions of CSGNet.

Evaluation on 2D CAD shapes. For this dataset, we re-
port results on its test split under two conditions: (i) when
training our network only on synthetic data, and (ii) when
training our network on synthetic data and also ﬁne-tuning
it on the training split of 2D CAD dataset using policy gra-
dients.

Table 3 shows quantitative results on this dataset. We
ﬁrst compare with the NN baseline. For any shape in this
dataset, where ground truth program is not available, NN re-
trieves a shape from synthetic dataset and we use the ground
truth program of the retrieved synthetic shape for compar-
ison. We then list the performance of CSGNet trained in
supervised manner only on our synthetic dataset. With
beam search, the performance of this variant improves com-
pared to NN. Most importantly, further training with Re-
inforcement Learning (RL) on the training split of the 2D
CAD dataset improves the results signiﬁcantly and outper-
forms the NN approach by a considerable margin. This also

-

-

Method Train Test

CD (@reﬁnement iterations)
i=0 i=1 i=2 i=4 i=10 i=∞
NN
1.92 1.22 1.13 1.08 1.07 1.07
CSGNet Super k=1 2.30 1.13 0.97 0.91 0.90 0.90
CSGNet Super k=10 1.60 0.71 0.60 0.56 0.55 0.55
k=1 1.26 0.61 0.54 0.52 0.51 0.51
CSGNet RL
CSGNet RL k=10 1.14 0.50 0.44 0.42 0.42 0.41
Table 3. Comparison of various approaches on the CAD shape
dataset. CSGNet trained with supervision (Super) is comparable
to the NN approach but reinforcement learning (RL) on the CAD
dataset signiﬁcantly improves the results. Results are shown with
different beam sizes (k) during decoding. Increasing the number
of iterations (i) of visually guided reﬁnement during testing im-
proves results signiﬁcantly. CD metric is in number of pixels.

shows the advantage of using RL, which trains the shape
parser without ground-truth programs. We note that directly
training the network using RL alone does not yield good
results which suggests that the two-stage learning (super-
vised learning and RL) is important. Finally, optimizing
the best beam search program with visually guided reﬁne-
ment yielded results with the smallest Chamfer Distance.
Figure 5 shows a comparison of the rendered programs for
various examples in the test split of the 2D CAD dataset
for variants of our network. Visually guided reﬁnement on
top of beam search of our two stage-learned network qual-
itatively produces results that best match the input image.

Logos. Here, we experiment with the logo dataset de-
scribed in Section 4.1 (none of these logos participate in
training). Outputs of the induced programs parsing the in-
put logos are shown in Figure 6. In general, our method
is able to parse logos into primitives well, yet performance
can degrade when long programs are required to generate
them, or when they contain shapes that are very different
from our used primitives.

Evaluation on Synthetic 3D CSG. Finally, we show that
In the 3D
our approach can be extended to 3D shapes.
CSG setting, we train a 3D-CNN + GRU (3D-CSGNet) net-
work on the 3D CSG synthetic dataset explained in Section
4.1. The input to our 3D-CSGNet are voxelized shapes in a
64×64×64 grid. Our output is a 3D CSG program, which
can be rendered as a high-resolution polygon mesh (we em-
phasize that our output is not voxels, but CSG primitives
and operations that can be computed and rendered accu-
rately). Figure 7 show pairs of input voxel grids and our
output shapes from the test split of the 3D dataset. The qual-
itative results are shown in the Table 4, where we compare
our 3D-CSGNet at different beam search decodings with
NN method. The results indicate that our method is promis-
ing in inducing correct programs, which also have the ad-
vantage of accurately reconstructing the voxelized surfaces
into high-resolution surfaces.

Figure 5. Comparison of performance on the 2D CAD dataset.
From left column to right column: a) Input image, b) NN retrieved
image, c) top-1 prediction from CSGNet in the supervised learn-
ing mode, d) top-1 prediction from CSGNet ﬁne-tuned with RL
(policy gradient), e) best result from beam search from CSGNet
ﬁne-tuned with RL, f) reﬁning our results using the visually guided
search on the best beam result (“full” version of our method).

Figure 6. Results for our logo dataset. a) Target logos, b) output
shapes from CSGNet and c) inferred primitives from output pro-
gram. Circle primitives are shown with red outlines, triangles with
green and squares with blue.

4.3.2 Primitive detection

Successful program induction for a shape requires not only
predicting correct primitives but also correct sequences of
operations to combine these primitives. Here we evaluate
the shape parser as a primitive detector (i.e., we evaluate the
output primitives of our program, not the operations them-

Method NN

3D-CSGNet
k=1 k=5 k=10
IOU (%) 73.2 80.1 85.3 89.2
Table 4. Comparison of the supervised network (3D-CSGNet)
with NN baseline on 3D dataset. Results are shown using
IOU(%) metric by varying beam sizes (k) during decoding.

Figure 7. Qualitative performance of 3D-CSGNet. a) Input vox-
elized shape, b) Summarization of the steps of the program in-
duced by CSGNet in the form of intermediate shapes, c) Final out-
put created by executing induced program.

selves). This allows us to directly compare our approach
with bottom-up object detection techniques.

In particular we compare against a state-of-the-art object
detector (Faster R-CNNs [36]). The Faster R-CNN is based
on the VGG-M network [8] and is trained using bounding-
box and primitive annotations based on our 2D synthetic
training dataset. At test time the detector produces a set of
bounding boxes with associated class scores. The models
are trained and evaluated on 640×640 pixel images. We
also experimented with bottom-up approaches for primitive
detection based on Hough transform [13] and other rule-
based approaches. However, our experiments indicated that
the Faster R-CNN was considerably better.

For a fair comparison, we obtain primitive detections from
CSGNet trained on the 2D synthetic dataset only (same as
the Faster R-CNN). To obtain detection scores, we sample k
programs with beam-search decoding. The primitive score
is the fraction of times it appears across all beam programs.
This is a Monte Carlo estimate of our detection score.

The accuracy can be measured through standard evaluation
protocols for object detection (similar to those in the PAS-
CAL VOC benchmark). We report the Mean Average Preci-
sion (MAP) for each primitive type using an overlap thresh-
old between the predicted and the true bounding box of 0.5
intersection-over-union. Table 5 compares the parser net-
work to the Faster R-CNN approach.

Our parser clearly outperforms the Faster R-CNN detector
on the squares and triangles category. With larger beam
search, we also produce slighly better results for circle de-
tection. Interestingly, our parser is considerably faster than
Faster R-CNN tested on the same GPU.

Circle Square Triangle Mean Speed (im/s)
Method
Faster R-CNN
87.4
CSGNet, k = 10 86.7
CSGNet, k = 40 88.1
Table 5. MAP of detectors on the synthetic 2D shape dataset.
We also report detection speed measured as images/second on a
NVIDIA 1070 GPU.

80.1
83.0
84.3

81.8
83.1
84.1

71.0
79.3
80.7

5
80
20

5. Conclusion

We believe that our work represents a ﬁrst step towards the
automatic generation of modeling programs given target vi-
sual content, which we believe is quite ambitious and hard
problem. We demonstrated results of generated programs
in various domains, including logos, 2D binary shapes, and
3D CAD shapes, as well as an analysis-by-synthesis appli-
cation in the context of 2D shape primitive detection.

One might argue that the 2D images and 3D shapes our
method parsed are relatively simple in structure or geom-
etry. However, we would also like to point out that even in
this ostensibly simple application scenario (i) our method
demonstrates competitive or even better results than state-
of-the-art object detectors, and most importantly (ii) the
problem of generating programs was far from trivial to
solve: based on our experiments, a combination of memory-
enabled networks, supervised and RL strategies, along with
beam and local exploration of the state space all seemed
necessary to produce good results. As future work, a chal-
lenging research direction would be to generalize our ap-
proach to longer programs with much larger spaces of pa-
rameters in the modeling operations and more sophisticated
reward functions balancing perceptual similarity to the in-
put image and program length. Other promising directions
would be to explore how to combine bottom-up proposals
and top-down approaches for parsing shapes, in addition to
exploring top-down program generation strategies.

Acknowledgments. We acknowledge support from NSF
(CHS-1422441, CHS-1617333,
IIS-1617917) and the
MassTech Collaborative grant for funding the UMass GPU
cluster.

References

com/. 5

[1] Pytorch. https://pytorch.org. 6
[2] Trimble 3D Warehouse. https://3dwarehouse.sketchup.

[3] J. Andreas, M. Rohrbach, T. Darrell, and D. Klein. Neural Module

Networks. In Proc. CVPR, 2016. 2

[4] M. Balog, A. L. Gaunt, M. Brockschmidt, S. Nowozin, and D. Tar-
low. DeepCoder: Learning to Write Programs. In Proc. ICLR, 2017.
2

[5] I. Biederman. Recognition-by-Components: A Theory of Human

Image Understanding. Psychological Review, 94(2), 1987. 1

[6] M. Bokeloh, M. Wand, and H.-P. Seidel. A Connection Between Par-
tial Symmetry and Inverse Procedural Modeling. ACM Transactions
on Graphics, 29(4), 2010. 3

[7] L. Bourdev, S. Maji, T. Brox, and J. Malik. Detecting people using
mutually consistent poselet activations. In Proc. ECCV, 2010. 3
[8] K. Chatﬁeld, K. Simonyan, A. Vedaldi, and A. Zisserman. Return
of the devil in the details: Delving deep into convolutional nets. In
Proc. BMVC, 2014. 8

[9] C. B. Choy, D. Xu, J. Gwak, K. Chen, and S. Savarese. 3d-r2n2: A
uniﬁed approach for single and multi-view 3d object reconstruction.
In Proc. ECCV, 2016. 1

[10] J. Chung, C. Gulcehre, K. Cho, and Y. Bengio. Empirical evalua-
tion of gated recurrent neural networks on sequence modeling. arXiv
preprint arXiv:1412.3555, 2014. 3

[11] M. Denil, S. G´omez Colmenarejo, S. Cabi, D. Saxton, and N. De
Freitas. Programmable Agents. arXiv preprint arXiv:1706.06383,
2017. 2

[12] A. Dosovitskiy, J. T. Springenberg, M. Tatarchenko, and T. Brox.
Learning to generate chairs, tables and cars with convolutional net-
works. IEEE PAMI, 39(4), 2017. 1

[13] R. O. Duda and P. E. Hart. Use of the hough transformation to detect
lines and curves in pictures. Commun. ACM, 15(1):11–15, Jan. 1972.
8

[14] K. Ellis, D. Ritchie, A. Solar-Lezama, and J. B. Tenenbaum. Learn-
ing to Infer Graphics Programs from Hand-Drawn Images. arXiv
preprint arXiv:1707.09627, 2017. 2

[15] S. M. A. Eslami, N. Heess, T. Weber, Y. Tassa, D. Szepesvari,
K. Kavukcuoglu, and G. Hinton. Attend, Infer, Repeat: Fast Scene
Understanding with Generative Models. In Proc. NIPS, 2016. 2
[16] H. Fan, H. Su, and L. J. Guibas. A Point Set Generation Network for

3D Object Reconstruction from a Single Image. In CVPR, 2017. 1

[17] P. F. Felzenszwalb and D. P. Huttenlocher. Pictorial structures for

object recognition. IJCV, 61(1):55–79, 2005. 3

[18] M. A. Fischler and R. A. Elschlager.

The representation and
matching of pictorial structures. IEEE Transactions on computers,
100(1):67–92, 1973. 3

[19] J. E. Hopcroft, R. Motwani, and U. J. D. Introduction to Automata

Theory, Languages, and Computation. 2001. 3

[20] R. Hu, J. Andreas, M. Rohrbach, T. Darrell, and K. Saenko. Learning
to reason: End-to-end module networks for visual question answer-
ing. In Proc. ICCV, 2017. 2

[21] H. Huang, E. Kalogerakis, E. Yumer, and R. Mech. Shape Synthesis
from Sketches via Procedural Models and Convolutional Networks.
IEEE transactions on visualization and computer graphics, 23(8),
2017. 2

[22] J. Johnson, B. Hariharan, L. Van Der Maaten, J. Hoffman, L. Fei-Fei,
C. L. Zitnick, and R. Girshick. Inferring and Executing Programs for
Visual Reasoning. In Proc. ICCV, 2017. 2

[26] D. E. Knuttt. On the translation of languages from left to right. 10
[27] T. D. Kulkarni, P. Kohli, J. B. Tenenbaum, and V. Mansinghka. Pic-
ture: A probabilistic programming language for scene perception. In
Proc. CVPR, 2015. 2

[28] T. D. Kulkarni, W. Whitney, P. Kohli, and J. B. Tenenbaum. Deep

convolutional inverse graphics network. In Proc. NIPS, 2015. 1, 2

[29] D. H. Laidlaw, W. B. Trumbore, and J. F. Hughes. Constructive solid
geometry for polyhedral objects. In Proc. SIGGRAPH, 1986. 1
[30] C. Liang, J. Berant, Q. Le, K. D. Forbus, and N. Lao. Neural Sym-
bolic Machines: Learning Semantic Parsers on Freebase with Weak
Supervision. In Proc. ACL, 2017. 2

[31] A. Martinovic and L. Van Gool. Bayesian Grammar Learning for

Inverse Procedural Modeling. In Proc. CVPR, 2013. 2, 3

[32] A. Neelakantan, Q. V. Le, and I. Sutskever. Neural Programmer:
In Proc. ICLR,

Inducing Latent Programs with Gradient Descent.
2016. 2
[33] G. Nishida,
A. Bousseau.
ACM Transactions on Graphics, 35(4), 2016. 2

I. Garcia-Dorado, D. G. Aliaga, B. Benes, and
Interactive Sketching of Urban Procedural Models.

[34] M. J. D. Powell. An efﬁcient method for ﬁnding the minimum of
a function of several variables without calculating derivatives. The
Computer Journal, 7(2):155, 1964. 5

[35] S. Reed and N. de Freitas. Neural Programmer-Interpreters. In Proc.

ICLR, 2016. 2

[36] S. Ren, K. He, R. Girshick, and J. Sun. Faster R-CNN: Towards Real-
In Proc.

Time Object Detection with Region Proposal Networks.
NIPS, 2015. 8

[37] D. Ritchie, B. Mildenhall, N. D. Goodman, and P. Hanrahan. Con-
trolling Procedural Modeling Programs with Stochastically-ordered
Sequential Monte Carlo. ACM Transactions on Graphics, 34(4),
2015. 3

[38] D. Ritchie, A. Thomas, P. Hanrahan, and N. D. Goodman. Neurally-
Guided Procedural Models: Amortized Inference for Procedural
In Proc. NIPS, 2016.
Graphics Programs using Neural Networks.
2

[39] L. Romaszko, C. K. I. Williams, P. Moreno, and P. Kohli. Vision-as-
inverse-graphics: Obtaining a rich 3d explanation of a scene from a
single image. In ICCV workshops, 2017. 2

[40] R. S. Sutton, D. McAllester, S. Singh, and Y. Mansour. Policy Gra-
dient Methods for Reinforcement Learning with Function Approxi-
mation. In Proc. NIPS, 1999. 4

[41] J. Talton, L. Yang, R. Kumar, M. Lim, N. Goodman, and R. Mˇech.
In
Learning Design Patterns with Bayesian Grammar Induction.
Proc. UIST, 2012. 3

[42] O. Teboul, I. Kokkinos, L. Simon, P. Koutsourakis, and N. Para-
gios. Shape Grammar Parsing via Reinforcement Learning. In Proc.
CVPR, 2011. 2, 3

[43] S. Tulsiani, H. Su, L. J. Guibas, A. A. Efros, and J. Malik. Learning
Shape Abstractions by Assembling Volumetric Primitives. In Proc.
CVPR, 2017. 2

[44] R. J. Williams. Simple Statistical Gradient-Following Algorithms
for Connectionist Reinforcement Learning. Machine Learning, 8(3-
4):229–256, 1992. 2, 4

[45] J. Wu and J. B. Tenenbaum. Neural Scene De-rendering. In Proc.

CVPR, 2017. 2

[46] Y. Yang and D. Ramanan. Articulated pose estimation with ﬂexible

mixtures-of-parts. In Proc. CVPR, 2011. 3

[47] A. Yuille and D. Kersten. Vision as Bayesian inference: analysis by

synthesis? Trends in Cognitive Sciences, pages 301–308, 2006. 2

[48] W. Zaremba, T. Mikolov, A. Joulin, and R. Fergus. Learning Simple

[23] A. Joulin and T. Mikolov. Inferring Algorithmic Patterns with Stack-

Algorithms from Examples. In Proc. ICML, 2016. 2

Augmented Recurrent Nets. In Proc. NIPS, 2015. 2

[49] W. Zaremba and I. Sutskever. Learning to Execute. arXiv preprint

[24] Ł. Kaiser and I. Sutskever. Neural GPUs Learn Algorithms. In Proc.

arXiv:1410.4615, 2014. 2

ICLR, 2016. 2

[25] D. P. Kingma and J. Ba. Adam: A method for stochastic optimiza-

tion. CoRR, abs/1412.6980, 2014. 6

[50] C. Zou, E. Yumer, J. Yang, D. Ceylan, and D. Hoiem. 3D-PRNN:
Generating Shape Primitives with Recurrent Neural Networks.
In
Proc. ICCV, 2017. 2

6. Supplementary

In this supplementary material, we include the following
topics in more detail: a) synthetic dataset creation in the 2D
and the 3D case, b) neural network architecture used in our
experiments, c) more qualitative results on our test dataset.

6.1. Dataset

Synthetic 2D shapes. We use the grammar described in
the Section 4.1 to create our 2D dataset. The dataset is cre-
ated by randomly generating programs of lengths 3 to 13
following the grammar. While generating these programs
we impose additional restrictions as follows: a) Primitives
must lie completely inside the canvas, b) Each operation
changes the number of ON pixels by at least a threshold set
to 10% of sum of pixels in two shapes. This avoids spu-
rious operations such as subtraction between shapes with
little overlap. c) The number of ON pixels in the ﬁnal im-
age is above a threshold. d) The previous rules promotes
programs with the union operation. To ensure a balanced
dataset we boost the probabilities of generating programs
with subtract and intersect operations. Finally we remove
duplicates. We only use upright, equilateral triangles and
upright squares. Note that locations (L) are discretized to
lie on square grid with spacing of 8 units and size (R) are
discretized with spacing of 4 units. Figure 8 shows exam-
ples from our dataset.

Synthetic 3D shapes. We use the grammar described in
the Section 4.1 to create our 3D dataset. While generat-
ing shapes we followed a strategy similar to the 2D case.
For 3D case, we only use programs of up to length 7 (up
to 4 shape primtives and upto 3 boolean operations). Note
that the cube and cylinder are upright. The dataset contains
64 × 64 × 64 voxel-grid shapes and program pairs. Also
note that locations (L) are discretized to lie on cubic grid
with spacing of 8 units, and size (R) and height (H) are dis-
cretized with spacing of 4 units.

Figure 8. Random samples from our synthetic 2D dataset.

Output
Layers
64 × 64 × 1
Input image
64 × 64 × 8
Dropout(Relu(Conv: 3 × 3, 1 → 8))
32 × 32 × 8
Max-pool(2 × 2)
Dropout(Relu(Conv: 3 × 3, 8 → 16)) 32 × 32 × 16
16 × 16 × 16
Max-pool(2 × 2)
Dropout(Relu(Conv: 3 × 3, 16 → 32)) 16 × 16 × 32
8 × 8 × 32
Max-pool(2 × 2)
2048
Flatten

Table 6. Encoder architecture for 2D shapes experiments. The
same architecture is used in all experiments in the Section 4.3.1.

Index Layers
1
2
3
4
5
6
7

Input shape encoding
Input previous instruction
Relu(FC (401 → 128))
Concatenate (1, 3)
Drop(GRU (hidden dim: 2048))
Drop(Relu(FC(2048 → 2048)))
Softmax(FC(2048 → 400))

Output
2048
401
128
2176
2048
2048
400

Table 7. Decoder architecture for 2D shapes experiments. The
same architecture is used for all experiments in the Section 4.3.1.
FC: Fully connected dense layer, Drop: dropout layer with 0.2
probability. Dropout on GRU are applied on outputs but not on
recurrent connections.

6.2. Network Architecture

CSG execution engine. We implemented a CSG engine
that reads the instructions one by one.
If it encounters a
primitive (e.g. c(32, 32, 16)) it draws it on an empty
canvas and pushes it on to a stack. If it encounters an op-
eration (e.g. union, intersect, or subtract) it pops
the top two canvases on its stack, applies the operation to
them, and pushes the output to the top of the stack. The
execution stops when no instructions remain at which point
the top canvas represents the result. The above can be seen
as a set of shift and reduce operations in a LR-parser [26].
Figure 9 describes execution procedure to induce programs
for 3D shapes.

Architecture for 2D shape experiments. Table 6 shows
the CNN architecture used as the encoder. The input I is an
image of size 64 × 64 and output Φ(I) is a vector of size
2048. Table 7 describes the architecture used in the decoder.
The RNN decoder is based on a GRU unit that at every time
step takes as input the encoded feature vector and previous
instruction encoded as a 128 dimensional vector obtained
by a linear mapping of the 401 dimensional one-hot vector
representation. At ﬁrst time step, the previous instruction
vector represents the START symbol. Embedded vector of
previous instruction is concantenated with Φ(I) and is in-
put to the GRU. The hidden state of GRU is passed through

Figure 9. Detailed execution procedure followed by an induced CSG program in a characteristic 3D case. The input is a voxel based
representation of size 64 × 64 × 64. The RNN decoder produces a program, which can be executed following the grammar described in
the Section 6.1, to give the output shown at the bottom. The user-level program is shown for illustration. On the right side is shown a parse
tree corresponding to the execution of the program.

two dense layer to give a vector of dimension 400, which
after softmax layer gives a probability distribution over
instructions. The output distribution is over 396 different
shape primitives, 3 operations (intersect, union and
subtract) and a STOP. We exclude the START symbol
from the output probability distribution. Note that the cir-
cle, triangle or square at a particular position in the image
and of a particular size represents an unique primitive. For
example, c(32, 32, 16), c(32, 28, 16), s(12, 32, 16) are dif-
ferent shape primitives.

Architecture for 3D shape experiments.
Input to 3D
shape encoder (3DCNN) is a voxel grid I of size 64 x 64
x 64 and outputs an encoded vector Φ(I) of size 2048, as
shown in the Table 8. Similar to the 2D case, at every
time step, GRU takes as input the encoded feature vector
and previous ground truth instruction. The previous ground
truth instruction is a 6636-dimensional (also includes the
start symbol) one-hot vector, which gets converted to a
ﬁxed 128-dimensional vector using a learned embedding
layer. At ﬁrst time step the last instruction vector rep-
resents the START symbol. Embedded vector of previ-
ous instruction is concatenated with Φ(I) and is input to

Output
Layers
64 × 64 × 64 × 1
Input Voxel
Relu(Conv3d: 4 × 4 × 4, 1 → 32) 64 × 64 × 64 × 32
BN(Drop(Max-pool(2 × 2 × 2))) 32 × 32 × 32 × 32
32 × 32 × 32 × 64
Relu(Conv3d: 4 × 4, 32 → 64)
BN(Drop(Max-pool(2 × 2 × 2))) 16 × 16 × 16 × 64
Relu(Conv3d: 3 × 3, 64 → 128)) 16 × 16 × 16 × 128
8 × 8 × 8 × 128
BN(Drop(Max-pool(2 × 2 × 2)))
Relu(Conv3d: 3 × 3, 128 → 256)) 8 × 8 × 8 × 256
4 × 4 × 4 × 256
BN(Drop(Max-pool(2 × 2 × 2)))
Relu(Conv3d: 3 × 3, 256 → 256)) 4 × 4 × 4 × 256
2 × 2 × 2 × 256
BN(Drop(Max-pool(2 × 2 × 2)))
2048
Flatten

Table 8. Encoder architecture for 3D shape experiments. Drop:
dropout layer, BN: batch-normalization layer and Drop: dropout
layer with 0.2 probability.

Index Layers
1
2
3
4
5
6
7

Output
2048
Input shape encoding
6636
Input previous instruction
128
Relu(FC(6636 → 128))
2176
Concatenate (1, 3)
Drop(GRU (hidden dim: 1500)) 1500
1500
Drop(Relu(FC(1500 → 1500)))
6635
Softmax(FC(1500 → 6635))

Table 9. Decoder network architecture for 3D shapes experi-
ments. FC: Fully connected dense layer, Drop: dropout layer with
0.2 probability. Dropout on GRU are applied on outputs but not
on recurrent connections.

the GRU. The hidden state of GRU is passed through two
dense layers to give a vector of dimension 6635, which af-
ter Softmax layer gives a probability distribution over in-
structions. The output distribution is over 6631 different
shape primitives, 3 operations (intersect, union and
subtract) and a STOP. We exclude the START symbol
from the output probability distribution. Similar to 2D case,
cu(32, 32, 16, 16), cu(32, 28, 16, 12), sp(12, 32, 16, 28) are
different shape primitives. Table 9 shows details of decoder.

6.3. Qualitative Evaluation

In this section, we show more qualitative results on different
dataset. We ﬁrst show peformance of our CSGNet trained
using only Supervised learning on 2D synthetic dataset, and
we compare top-10 results from nearest neighbors and and
top-10 results from beam search, refer to the Figure 10 and
11. Then we show performance of our full model (using RL
+ beam search + visually guided search) on CAD 2D shape
dataset, refer to the Figure 12 and 13.

Figure 10. Qualitative evaluation on 2D synthetic dataset. In green outline is the groundtruth, top row represent top-10 beam search
results, bottom row represents top-10 nearest neighbors.

Figure 11. Qualitative evaluation on 2D synthetic dataset. In green outline is the groundtruth, top row represent top-10 beam search
results, bottom row represents top-10 nearest neighbors.

Figure 12. Performance of our full model on 2D CAD images. a) Input image, b) output from our full model, c) Outlines of primitives
present in the generated program, triangles are in green, squares are in blue and circles are in red d) Predicted program. s, c and t are shape
primitives that represents square, circle and triangle respectively, and union, intersect and subtract are boolean operations.

Figure 13. Performance of our full model on 2D CAD images. a) Input image, b) output from our full model, c) Outlines of primitives
present in the generated program, triangles are in green, squares are in blue and circles are in red d) Predicted program. s, c and t are shape
primitives that represents square, circle and triangle respectively, and union, intersect and subtract are boolean operations.

