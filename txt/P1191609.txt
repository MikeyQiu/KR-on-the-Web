Online Unsupervised Multi-view Feature Selection

Weixiang Shao∗, Lifang He†, Chun-Ta Lu∗, Xiaokai Wei∗ and Philip S. Yu∗‡
∗University of Illinois at Chicago
Email: {wshao4, clu29, xwei2, psyu}@uic.edu
†Shenzhen University, China
Email: lifanghescut@gmail.com
‡Institute for Data Science, Tsinghua University, China

6
1
0
2
 
p
e
S
 
7
2
 
 
]

G
L
.
s
c
[
 
 
1
v
6
8
2
8
0
.
9
0
6
1
:
v
i
X
r
a

Abstract—In the era of big data, it is becoming common to have
data with multiple modalities or coming from multiple sources,
known as “multi-view data”. Since multi-view data are usually
unlabeled and come from high-dimensional spaces (such as
language vocabularies), unsupervised multi-view feature selection
is crucial to many applications such as model interpretation and
storage reduction. However, it is nontrivial due to the following
challenges. First, the data may not ﬁt in memory, because there
are too many instances or the feature dimensionality is too large.
How to select useful features with limited memory space? Second,
the data may come in as streams and concept drift may happen.
How to select features from streaming data and handles the
concept drift? Third, different views may share some consistent
and complementary information. How to leverage the consistent
and complementary information from different views to improve
the feature selection in the situation when the data are too big
or come in as streams? To the best of our knowledge, none of
the previous works can solve all the challenges simultaneously.
In this paper, we propose an Online unsupervised Multi-
View Feature Selection, OMVFS, which deals with large-
scale/streaming multi-view data in an online fashion. OMVFS
embeds unsupervised feature selection into a clustering algorithm
via nonnegative matrix factorizatio with sparse learning. It fur-
ther incorporates the graph regularization to preserve the local
structure information and help select discriminative features.
Instead of storing all the historical data, OMVFS processes
the multi-view data chunk by chunk and aggregates all the
necessary information into several small matrices. By using
the buffering technique, the proposed OMVFS can reduce the
computational and storage cost while taking advantage of the
structure information. Furthermore, OMVFS can capture the
concept drifts in the data streams. Extensive experiments on four
real-world datasets show the effectiveness and efﬁciency of the
proposed OMVFS method. More importantly, OMVFS is about
100 times faster than the off-line methods.

I. INTRODUCTION

In many real-world applications, data are often with multiple
modalities or coming from multiple sources. Such data are
called multi-view data. For example, in web image retrieval,
the visual information of images and their textual tags can
be regarded as two views; in web document clustering, one
web document may be translated into different languages, each
language can be seen as one view. Usually, multiple views
provide complementary information for the semantically same
data. Multi-view learning was proposed to combine different
views to obtain better performance than relying on just one
single view [1]. However, many of the views may come
from high-dimensional spaces (such as language vocabularies).

Thus, accurate unsupervised feature selection on these high-
dimensional multi-view data is crucial to many applications
such as model interpretation and storage reduction.

Feature selection has been studied for decades [2]. It can
be categorized into supervised feature selection and unsu-
pervised feature selection in terms of the label availability.
Supervised feature selection [3] uses the class labels to ef-
fectively select discriminative features to distinguish samples
from different classes. As the data explodes, most of the data
are unlabeled and expensive to obtain the labels. Recently,
several approaches on unsupervised feature selection has been
proposed [4], [5]. Without the label information, most of
the unsupervised feature selection methods combine generated
pseudo labels with sparse learning [6], [7]. In this paper, we
will only focus on the unsupervised feature selection.

Most recently, as complementary information can be ob-
tained from different views, unsupervised multi-view feature
selection has drawn lots of attention [8]–[10]. For example, [9]
is the ﬁrst to use spectral clustering and ℓ2,1-norm regression
to multi-view data in social media. [8] integrates all features
and learns the weights for every feature with respect to each
cluster individually via a new joint structured sparsity-inducing
norms. For image and text data, [10] uses image local learning
regularized orthogonal nonnegative matrix factorization to
learn pseudo labels and simultaneously perform robust joint
ℓ2,1-norm minimization to select discriminative features.

However, several challenges prevent us from applying exist-
ing unsupervised feature selection methods to the real-world
multi-view data:

1) As information explodes, multi-view data may contain
too many instances or the feature dimensionality may be
too large, such that the data cannot ﬁt in memory. How
to select useful features with limited memory space is
the ﬁrst challenge.

2) In many real-world applications, the data may come in
as streams and concept drift [11] may happen. How
to select features from streaming data and handles the
concept drift is the second challenge.

3) Multi-view data always exhibits the heterogeneity of
the features. Different views may share some consistent
and complementary information. The third challenge is
how to combine features from different views while
take advantages of the consistent and complementary
information to improve the feature selection in the

situation when the data are too big or come in as streams.
To the best of our knowledge, all the existing feature selec-
tion methods only focus on one or two of the challenges. For
example, [8]–[10] only solve unsupervised feature selection
problem for multi-view data. [12]–[14] solve the problem of
feature selection on large-scale/streaming data in a single view.
None of them can solve all the challenges simultaneously.

In this paper, we propose a novel method, Online
unsupervised Multi-View Feature Selection (OMVFS),
to
solve the problem of multi-view feature selection on large-
scale/streaming data. OMVFS embeds the unsupervised fea-
ture selection into the Nonnegative Matrix Factorization
(NMF) based clustering objective function. It further adopts
the graph regularization to preserve the local structure infor-
mation and help select discriminative features. By learning a
consensus clustering indicator matrix, the proposed OMVFS
integrates all the views in different feature spaces. Instead of
storing all the historical data, OMVFS processes the multi-
view data chunk by chunk and aggregates necessary informa-
tion from all the previous data into several small matrices.
These aggregated matrices will be used in the learning of
feature selection matrices and be updated as new data come
in. The contributions of this paper can be summarized as
following:

1) The proposed OMVFS method is the ﬁrst attempt to
solve the problem of online unsupervised multi-view
feature selection on large-scale/streaming data.

2) OMVFS can process the data chunks in an online
fashion and aggregate information about all the previous
data into small matrices. The aggregated information can
be used to help feature selection in the future. Thus,
the proposed method can greatly reduce the memory re-
quirement and scale up to large data without appreciable
sacriﬁce of performance.

3) By using the buffering technique, OMVFS can reduce
the computational and storage cost while taking advan-
tage of the structure information. Furthermore, it can
capture the concept drifts in the data streams.

4) Through extensive experiments on real-world datasets,
the effectiveness of proposed
we demonstrate that
OMVFS is comparative and even better than the best
off-line method. More importantly, OMVFS is about 100
times faster than the off-line methods.

The rest of this paper is organized as follows. In the next
section, problem formulation and some backgrounds are given.
The details of the proposed OMVFS method are presented
in Sections III, and IV. Extensive experimental results and
analysis are shown in Section V. Related work is discussed in
Section VI and followed by the conclusion in Section VII.

II. PRELIMINARIES

In this section, we will brieﬂy describe the problem of
unsupervised multi-view feature selection. Then some back-
ground knowledge about unsupervised feature selection will
be introduced.

TABLE I: Summary of the Notations

Notation
N
Dv
nv
m
s
X(v), W(v), V(v)
U
Mt
M
[t]
M

[s,t]

Description
Total number of instances.
Dimension of features for view v.
Total number of views.
Size of data received at each time.
Size of the buffer.
Data matrix, similarity matrix, and feature selection matrix for view v.
Cluster indicator matrix.
Matrix for time t.
Aggregated matrix from time 1 to time t.
Aggregated matrix from time t − s + 1 to time t.

A. Problem Description

Before we describe the formulation of the problem, we

summarize some notations used in this paper in Table I.

Throughout this paper, matrices are written as boldface cap-
ital letters (e.g., M ∈ Rn×m) and vectors are denoted as bold-
face lowercase letters (e.g., mi). k · kF is the matrix Frobenius
norm and T r(·) is the trace of a square matrix. The ℓ2,1-norm
n
i=1 mi =
is deﬁned as kMk2,1 =
Assume we are given a dataset with N instances in nv views
{X(v), v = 1, 2, ..., nv}, where X(v) ∈ RN ×Dv
represents the
nonnegative data in the v-th view and Dv is the feature dimen-
sion in the v-th view. Our goal is to leverage complementary
information from multi-view data to select pv features from
the v-th view, while dealing with high-dimensional and large-
scale problems in an online fashion.

m
j=1 M2

qP

n
i=1

i,j.

P

P

+

B. Unsupervised Feature Selection using NMF

Nonnegative Matrix Factorization (NMF) has been widely
used in unsupervised learning such as clustering and dimen-
sion reduction. In this paper, we embed the feature selection
into a NMF based clustering algorithm. Let X ∈ RN ×D
denote a nonnegative data matrix, where each row represents
an instance and each column represents one normalized at-
tribute (each column kX.,ik2 = 1). Assume we would like to
cluster the data into K clusters, NMF will factorize the data
matrix X into two nonnegative matrices. We denote the two
nonnegative matrices factors as U ∈ RN ×K
and V ∈ RD×K
.
The objective function for NMF can be formulated as below:

+

+

+

min
U,V

L = kX − UVT k2
F

s.t. U ≥ 0, V ≥ 0.

(1)

(2)

In practice, for clustering problem, an orthogonality constraint
is usually added to U [15]–[17]. Thus, Eq. (1) can be rewritten
as:

min
U,V

kX − UVT k2
F

s.t. UT U = I, U ≥ 0, V ≥ 0.

The orthogonality constraint on U can be seen as a relaxed
form from the original clustering indicator constraint, where
U ∈ {0, 1}N ×K, UT 1 = 1.

Another advantage of this orthogonality constraint on U
is to allow us to perform feature selection using V. It has
been proved that the ℓ2-norm of the rows in V represents the
importance of the features in X regarding to the reconstruction

(3)

(4)

error [18]. Thus, we can add a selection matrix diag(p) to X
and V to only select the important features that minimize the
reconstruction error:,

kXdiag(p) − U(diag(p)V)T k2
F

min
U,V
s.t. UT U = I, U ≥ 0, V ≥ 0
p ∈ {0, 1}D, pT 1 = r,

where r is the number of selected feature, p is the indicator
vector, where pi = 1 indicates that the i-th feature is selected.
Now, Eq. (3) becomes a mixed integer programming, which
is very difﬁcult to solve. [18] proposed to relax Eq. (3) to the
following problem and proved the equivalent between Eq. (3)
and Eq. (4):

kX − UVT k2

min
U,V
s.t. UT U = I, U ≥ 0, V ≥ 0,

F + βkVk2,1

where β is the parameter to control the sparsity of V. By
adding the ℓ2,1-norm on V, we force some of the rows
in V close to 0. Thus, we can achieve feature selection
by sorting the features according to the row norms of V
in descending order, and selecting the top ranked ones. To
facilitate discussions, we call U the cluster indicator matrix,
and V the feature selection matrix.

III. METHOD

The proposed online unsupervised multi-view feature se-
lection is based on nonnegative matrix factorization and it
processes the multi-view data chunk by chunk and aggregates
all the historical information into small matrices with low
computational and storage complexity. We will ﬁrst describe
how to derive the objective function.

A. Objective of OMVFS

Given data in nv views {X(v) ∈ RN ×Dv

, v = 1, 2, ..., nv},
we aim to ﬁnd a feature selection matrix for each view
and a consensus cluster indicator matrix, which integrates
information of all the views. Following the constrained NMF
framework in Section II-B, we can form the objective function

+

nv

min
U,{V(v)}

kX(v) − UV(v)T

F + βvkV(v)k2,1
k2

Xv=1 (cid:16)
s.t. UT U = I, U ≥ 0, V(v) ≥ 0, v = 1, 2, ..., nv,

(cid:17)

(5)

where U is the consensus cluster indicator matrix, V(v) is
the feature selection matrix for the v-th view, and βv is the
parameter that controls the sparsity of V(v).

To take advantage of local manifold information from the
structure of the original data {X(v)}, i.e., similar data instances
should have similar labels, we add the spectral clustering
objective term for every view

min T r(U(v)T
L(v)U(v))
(v) −W(v) is the Laplacian matrix for the v-
where L(v) = Dw
th view, W(v) ∈ RN ×N is the similarity matrix based on X(v)
(v) is a diagonal matrix with its diagonal elements as
and Dw

(6)

the row sums of W(v). Now, we can obtain the objective
function for OMVFS as:

nv

min
U,{V(v)}

kX(v) − UV(v)T

F + αvtr(UT L(v)U) + βvkV(v)k2,1
k2

Xv=1 (cid:16)
s.t. UT U = I, U ≥ 0, V(v) ≥ 0, v = 1, 2, ..., nv

(7)

(cid:17)

where αv is the importance of the spectral clustering term for
the v-th view.

It is worth noting that in order to solve the problem in
Eq. (7), we need to have the entire data {X(v)} in memory.
However, in real-world applications, the data may be too large
to ﬁt into the memory or may only come on stream. Hence,
it is crucial to solve the above optimization problem in an
incremental way. Let X(v)
t ∈ Rm×Dv
denote the data received
+
at time t in the v-th view, and X(v)
denote all the
data received up to time t, where m is the number of instances
(size of the data chunk) received at each time. The objective
function at time t is:

[t] ∈ Rmt×Dv

+

min
U[t],{V(v)}

kX(v)

[t] − U[t]V(v)T

F + αvT r(UT
k2

[t]L(v)

nv

Xv=1 (cid:16)
nv

+

βvkV(v)k2,1

[t] U[t])
(cid:17)

(8)

Xv=1
T U[t] = I, U[t] ≥ 0, V(v) ≥ 0, v = 1, 2, ..., nv

s.t. U[t]
where U[t] ∈ Rmt×K
for all the instances received up to time t and L(v)
is the Laplacian matrix constructed from X(v)
[t] .

is the consensus cluster indicator matrix
[t] ∈ Rmt×mt

+

B. Optimization

In the previous section, we derived the objective function of
OMVFS. To solve OMVFS, we ﬁrst rewrite the optimization
problem as follows

min
U[t],{V(v)}

nv

Xv=1 (cid:16)
nv

kX(v)

[t] − U[t]V(v)T

F + αvT r(UT
k2

[t]L(v)

[t] U[t])
(cid:17)

(9)

+

βvkV(v)k2,1 + γkUT

[t]U[t] − Ik2
F

Xv=1
s.t. U[t] ≥ 0, V(v) ≥ 0, v = 1, 2, ..., nv

where γ > 0 is a parameter to control the orthogonality
condition. In practice, γ should be large enough to ensure
the orthogonality is satisﬁed (γ is set to 107 throughout the
experiments). From Eq. (9), we can see that at each time
t, we need to optimize U[t] and {V(v)}nv
v=1. However, the
objective function is not jointly convex, so we have to update
U[t] and {V(v)}nv
v=1 in an alternating way. Thus, there are two
subproblems in OMVFS:

1) Optimize U[t] with {V(v)}nv

v=1 Fixed: To optimize U[t]
v=1 ﬁxed at time t, we only need to minimize the

with {V(v)}nv
following objective:

nv

Jt(U[t]) =

kX(v)

[t] − U[t]V(v)T

F + αvtr(UT
k2

[t]L(v)

[t] U[t])
(cid:17)

Xv=1 (cid:16)
+ γkUT
s.t. U[t] ≥ 0

[t]U[t] − Ik2
F

(10)

Taking the ﬁrst-order derivative, the gradient of Jt with

respect to U[t] is

Using the KKT complementary condition for the nonnegativity
constraint on V(v), we get the update rule for V(v):

(11)

V(v)

j,k ← V(v)

j,k

v
u
u
u
u
t

(cid:18)
V(v)(At−1 + UT
(cid:0)

B(v)

t−1 + X(v)

t

T

Ut

(cid:19)j,k
2 βvD(v)V(v)

t Ut) + 1

j,k
(cid:1)

(19)

∂Jt
∂U[t]

nv

Xv=1

=2U[t]

V(v)T

V(v) − 2

X(v)

[t] V(v)

[t]

nv

Xv=1

+ 2M[t]U[t] + 2γT[t] − 2γU[t]

where, M[t] =

nv

v=1 αvL(v)

[t] and T[t] = U[t]UT

[t]U[t].

P

Using the Karush-Kuhn-Tucker (KKT) complementary con-
dition for the nonnegativity constraint on U[t], we can get the
update rule for U[t] [16], [19]:

(U[t]

(U[t])i,k ← (U[t])i,kv
u
u
t
[t])i,j = 1
k(M[t])i,j k − (M[t])i,j
2) Optimize {V(v)}nv
(cid:0)

where (M+
1
2

2

P

(
P

nv

v=1 X(v)
[t] V(v) + λU[t] + M−
v=1 V(v)T V(v) + γT[t] + M+

nv

[t]U[t])i,k

[t]U[t])i,k
(12)

k(M[t])i,jk + (M[t])i,j
and M[t] = M+
(cid:0)

, (M−
[t])i,j =
[t] − M−
(cid:1)
[t].

(cid:1)

v=1 with U[t] Fixed: From Eq. (9), we
can observe that the optimization of V(v) is independent with
different v when U[t] is ﬁxed. We only need to minimize the
following objective function for the v-th view:

Jt(V(v)) = kX(v)

[t] − U[t]V(v)T

F + βvkV(v)k2,1
k2

We observe that the above objective Jt can be decomposed
as:

Jt(V(v)) =

kX(v)

i − UiV(v)T

F + βvkV(v)k2,1
k2

s.t. V(v) ≥ 0

t

Xi=1

s.t. V(v) ≥ 0

where X(v)
cluster indicator matrix for data received at time i.

is the data chunk received at time i and Ui is the

i

Taking the ﬁrst-order derivative, the gradient of Jt with

respect to V(v) is

∂Jt
∂V(v) = 2V(v)

t

Xi=1

UT

i Ui − 2

Ui + βvD(v)V(v)

t

Xi=1

T

X(v)
i

(15)
where D(v) is a diagonal matrix with the j-th diagonal element
given by D(v)
and v(v)
is the j-th row of V(v) and
j,j = 1
kv(v)
k · k2 is the ℓ2 norm.

j k2

j

For the sake of convenience, we introduce two terms At

and B(v)

:

t

At =

UT

i Ui = At−1 + UT

t Ut

B(v)

t =

T

X(v)
i

Ui = B(v)

t−1 + X(v)

t

T

Ut

t

Xi=1
t

Xi=1

can be computed incrementally with low

t

Both At and B(v)
storage. Thus, Eq. 15 can be rewritten as
∂Jt
∂V(v) =2V(v)(At−1 + UT
t−1 + X(v)
− 2(B(v)

t Ut)
T

t

Ut) + βvD(v)V(v)

(13)

(14)

(16)

(17)

(18)

C. Further Optimization Using Buffering

From the update rules (12), we observe that the update
process for U[t] still needs all the data and all the cluster
indicator matrices up to time t to reside in the memory.
Thus, the memory usage will continue growing as more data
come in. Also, at each time t, we need to calculate the new
similarity matrix W(v)
in order to get the Laplacian matrix
[t]
L(v)
[t] . Even if we only calculate the similarity between the m
new instances and all the mt instances, the time complexity
will still increase as the data pile up. What’s worse, the size
of L(v)
(mt × mt) will grow quadratically. To overcome
[t]
this deﬁciency, we adopt the buffering technique by keeping
a limited number of samples for each update step. Another
beneﬁt of adopting buffering is that, by only considering the
structure information in the buffer, we can capture the concept
drift in streaming data. The intuition behind buffering is based
on the assumption regarding to streaming data:

ASSUMPTION 1: The incoming data are more related with
the recent data than the far more old data, and the underline
concept distribution of incoming data are more similar to those
of recent data.

t

+

[s,t] = [X(v)

t−s+2; . . . ; X(v)

Thus, we consider the graph/structure information only
within a time window. Assume that the buffer size is s, i.e.,
we only consider the most recent s data chunks received,
t−s+1; X(v)
we deﬁne X(v)
] ∈ Rsm×Dv
+
as the most recent s data chunks received up to time t
and U[s,t] = [Ut−s+1; Ut−s+2; . . . ; Ut] ∈ Rsm×K
as the
cluster indicator matrix for them. W(v)
[s,t] ∈ Rsm×sm and
L(v)
[s,t] ∈ Rsm×sm are the similarity matrix constructed from
the data in the buffer and the Laplacian matrix from W(v)
[s,t].
Note that, for the similarity matrix W(v)
[s,t], we do not need
the sm instances
to recompute the similarities among all
(sm × sm pairwise similarities). We only need to calculate
the similarities between the m new instances with all the sm
instances (m×sm pairwise similarities). Thus, we can redeﬁne
[t] , U[t] and L(v)
the objective function (10) by substituting X(v)
[t]
with the above new deﬁnitions. The new update rule for U[s,t]
is

[s,t]U[s,t])i,k

(
P
(U[s,t]

nv

v=1 X(v)

[s,t]V(v) + λU[s,t] + M−
v=1 V(v)T V(v) + γT[s,t] + M+

nv

(U[s,t])i,k ← (U[s,t])i,kv
u
u
t

P

For the feature selection matrices {V(v)}nv

[s,t]U[s,t])i,k
(20)
v=1, we fortu-
nately observe that At and {B(v)
v=1 accumulate the infor-
mation of all the previous t chunks. Therefore, we can still use
update rule (19) without any modiﬁcation, which means that

t }nv

At−1

Update procedure at time t

At

{B(v)

t }

nv
v=1

Ut

Algorithm 1: OMVFS algorithm.
Input: Data matrices {X(v)}. The number of clusters K, the
batch size m, the buffer size s. Parameters {αv} and
{βv}.

{W(v)

[s,t−1]}nv

v=1

{W(v)

[s,t]}nv

v=1

{X(v)

[s,t−1]}nv

v=1

{X(v)

[s,t]}nv

v=1

Fig. 1: The workﬂow of OMVFS at time t. The blue boxes
represent the aggregated information about all the previously
received data, the green box represents the incoming data at
time t, the red box represents the feature weight matrices
learned from the aggregated information and the new data.

Time

t − 1

t

Data 
Matrix
sm × Dv

X(v)
t−s

X(v)

t−s+1

.

.

.

X(v)
t−1

X(v)

t−s+1

.

.

.

X(v)
t−1

X(v)
t

Indicator 
Matrix
sm × K

Feature Selection 
Matrix
Dv × K

Graph Weight 
Matrix
sm × sm

X(v)
t−s

X(v)
t−1

Ut−s
Ut−s+1

.

.

.

Ut−1

Ut−s+1

.

.

.

Ut−1

Ut

V(v)

W(v)

[s,t−1]

X(v)

t−s+1

X(v)
t

V(v)

W(v)
[s,t]

X(v)
t−s

X(v)
t−1

X(v)

t−s+1

X(v)
t

Fig. 2: The detailed update process for major matrices in
OMVFS at time t. When the buffer is full, data for the oldest
chunk (gray parts) will be discarded, and data for the incoming
chunck (red parts) will be added.

employing the buffering technique has no effect on updating
the feature selection matrices.

IV. ONLINE UNSUPERVISED MULTI-VIEW FEATURE
SELECTION

t−1}nv

In this section we will present the whole OMVFS method.
Fig. 1 shows the workﬂow of the OMVFS method at time t.
From Fig. 1 we can see that, at time t, OMVFS takes At−1,
{B(v)
[s,t−1]}nv
v=1, W[s,t−1], and {Xv
v=1 from time t − 1 and
t }nv
combines with the incoming data {Xv
v=1 to update all the
matrices. It is worth mentioning that OMVFS does not need to
store all the previous data. Instead, it only stores some small
buffered data {Xv
v=1 and W[s,t−1]. All the necessary
information from the previous data is aggregated and stored
in small matrices At−1 and {B(v)
v=1. The computation
of these aggregated matrices can be done efﬁciently and
incrementally. The complete algorithm procedure is shown in
Algorithm 1. There are several things need to be clariﬁed.

[s,t−1]}nv

t−1}nv

[s,0] as empty matrices.

Output: Feature selection matrices {Vv}.
1 Initialize V(v) randomly for each view v.
[s,0], U[s,0], W(v)
2 Initialize X(v)
0 = 0, B(v)
3 A(v)
0 = 0 for each view v.
4 for t = 1 : ⌈N/m⌉ do
Draw X(v)
5
Initialize Ut randomly.
for v = 1 : nv do
Construct X(v)
[s,t−1].
Construct U[s,t] from U[s,t−1].
Construct W(v)

[s,t] from X(v)

for all the views.

[s,t] and L(v)

8

6

7

9

t

[s,t] from W(v)

[s,t−1].

repeat

Update U[s,t] according to Eq. (20).
for v = 1 : nv do

Update V(v) according to Eq. (19).

10

11

12

13

14

15

16

until Convergence;
At = At−1 + UT
B(v)

t Ut
t−1 + X(v)

t

T Ut

t = B(v)
17
18 for v = 1 : nv do
19

Sort the features for X(v) according to the ℓ2-norm of the
rows in V(v) in descending order.

First, at the beginning of the algorithm (t = 0), OMVFS will
initialize the buffered data X(v)
[s,t], the cluster indicator matrix
for buffered data U[s,t] and similarity matrix for buffered data
W(v)
[s,t] with empty matrices. The feature selection matrices
{V(v)} will also be initialized randomly at t = 0.

Second, as the data come in, if the buffer is full, OMVFS
will remove the oldest data (e.g., X(v)
t−s), and concatenate the
new data to the buffer. The procedure for updating the matrices
in the buffer is shown in Fig. 2. The grey shadow areas are
the parts for the oldest data, and the red shadow areas are the
parts for the incoming new data.

A. Convergence Analysis

Although the objective function for the proposed OMVFS
at time t is not jointly convex with U[s,t] and {V(v)}, the al-
ternating optimization strategy used in OMVFS is guaranteed
to converge to the local minimum [20]. The proof is similar
to that of Theorem 1 in [21] and we omit it. It is important
to note that our method essentially applies stochastic gradient
descent [22] to the new coming data. Since we perform a
stochastic approximation for minimizing an objective function
that is written as a sum of differentiable functions. This method
is expected to decrease the objective function in every iteration
on the new data [23]. Therefore, the same convergence proof
can be adapted to the problem setting and algorithm design
that considered here. In the experiments, we also ﬁnd that the
proposed OMVFS method converges within 200 iterations for
all the datasets used.

B. Complexity Analysis

There are two subproblems for OMVFS algorithm: optimiz-
ing U[s,t], and optimizing {V(v)}. The computation cost for
updating U[s,t] depends on the calculation in Eq. (20). After
analyzing the equation, we can ﬁnd that the computational
cost to update U[s,t] is O(nvsmDK) + O(nvs2m2K), where
s is the buffer size, m is the size of data chunk, and D is
the average feature dimension for all the views. Since D is
usually very large, we can assume that D ≫ sm. Thus, the
computational cost for updating U[s,t] is O(nvsmDK).

The compuational cost for updating V(v) depends on
Eq. (19). The computation for D(v) is O(DvK). Since D(v)
is diagonal, it only takes O(DvK) to calculate D(v)V(v). It
is easy to verify that it take O(mDvK) to update V(v), and
O(nvmDK) to update {V(v)}. Thus, the time complexity for
OMVFS to process one data chunk is O(tnvsmDK), which
leads to the overall time complexity to O(tnvsN DK). Here,
t is the average number of iterations to converge. Considering
s is usually very small (less than 5 in the experiments),
the time complexity is approximately O(tnvN DK). We can
observe that the time complexity is linear to all the components
(number of views, number of instances, feature dimensionality
and the number of clusters).

Most of the ofﬂine methods require at least O(nvN D)
space, however
proposed OMVFS only requires
O(nvsmD) + O(nvs2m2) ≈ O(nvsmD) memory space,
which makes OMVFS suitable for large-scale/streaming data.

the

TABLE II: Summary of the datasets

Dataset
CNN
FOX
YouTube
Reuters

# Instance
2, 107
1, 523
95, 343
111, 740

# Feature
996 + 35, 719
996 + 27, 072
2, 000 + 94, 012
21, 531 + 24, 893

# Class
7
4
31
6

feature families: textual, visual, and auditory features.
There are 31 class labels, 1 through 31. The ﬁrst 30
labels correspond to popular video games. Class 31 is
not speciﬁc, and means none of the 30. In this paper, we
select one text view and one audio view for the exper-
iments. For the text view, we use the 94, 012 unigrams
extracted from the video tags. We use the Mel-Frequency
Cepstral Coefﬁcient (MFCC) features with the dimension
of 2, 000 for the audio view. We removed some instances
with label 31 and kept 95, 343 instances to create a more
balanced dataset.

• Reuters Multilingual Text Data (Reuters)3: The text
collection contains feature characteristics of documents
originally written in ﬁve different languages (English,
French, German, Spanish and Italian), and their trans-
lations, over a common set of 6 topic categories [25]. In
our experiments we use the 111, 740 documents in two
languages (English and French). The feature dimensions
are 21, 531 for English and 24, 893 for French.

V. EXPERIMENTS AND RESULTS

B. Comparison Methods

A. Dataset

In this paper, two small real-world datasets and two large
real-world datasets are used to evaluate the proposed OMVFS
method. The summary of these four datasets is shown in Table
II, and the details of the datasets are as follows:

• CNN and FOX1: These two datasets were crawled from
CNN and FOX web news [10]. The category information
contained in the RSS feeds for each news article can
be viewed as reliable class label. Each instance can be
represented in two views, the text view and image view.
Titles, abstracts, and text body contents are extracted as
the text view data, and the image associated with the
article is stored as the image view data. All text content
is stemmed by portStemmer, and l2-normalized TF-IDF is
used as text features, which results in 35, 719 features for
CNN and 27, 072 features for FOX. For image features,
seven groups of color features and ﬁve textural features
are used [10], which results in 996 features for both
datasets.

• YouTube Multiview Video Games (YouTube)2: This
dataset consists of feature values and class labels for
about 120,000 videos (instances) [24]. Each instance is
described by up to 13 feature types, from 3 high level

We compare the proposed OMVC method with several
state-of-art methods. The differences between these compari-
son methods are summarized in Table III, and the details of
comparison methods are as follows:

• OMVFS: OMVFS is the online unsupervised multi-view

feature selection method proposed in this paper 4.

• LapScore: Laplacian Score [26] is a single view unsu-
pervised feature selection method, which evaluates the
importance of a feature via its power of locality preser-
vation.

• EUFS: Embedded Unsupervised Feature Selection [18] is
one of the most recent single view unsupervised feature
selection method. It directly embeds unsupervised feature
selection algorithm into a clustering algorithm via sparse
learning.

• FSDS: Unsupervised Feature Selection on Data Stream
[14] is one of the state-of-the-art unsupervised feature
selection algorithms, which handles large volume single
view data stream efﬁciently. It adopts the idea of matrix
sketching to efﬁciently maintain a low-rank approxima-
tion of the observed data and applies regularized regres-
sion to select the important features.

• MVUFS Multi-View Unsupervised Feature Selection
[27] is the most advanced off-line unsupervised feature

1https://sites.google.com/site/qianmingjie/home/datasets/
2https://archive.ics.uci.edu/ml/datasets/YouTube+Multiview

+Video+Games+Dataset

3http://archive.ics.uci.edu/ml/machine-learning-databases/00259/
4code available at: https://github.com/software-shao

TABLE III: Summary of the comparison methods

Methods Multi-view
LapScore
EUFS
MVUFS
FSDS
OMVFS

×
×
X
×
X

Online
×
×
×
X
X

Direct Embedding
−
X
×
×
X

selection for multi-view data. It uses local learning reg-
ularized orthogonal nonnegative matrix factorization to
learn pseudo labels and simultaneously performs joint
ℓ2,1-norm minimization to select discriminative features.

LapScore
EUFS
FSDS
MVUFS
OMVFS

0.85

0.8

0.75

0.7

0.65

0.6

0.55

0.5

C
C
A

0.45

100

0.6

0.55

0.5

0.45

0.4

0.35

0.3

C
C
A

0.25

100

0.7

0.6

0.5

0.3

0.2

0.1

0.4

I

M
N

0.4

0.35

0.3

0.25

0.2

0.15

0.1

I

M
N

0.05

100

LapScore
EUFS
FSDS
MVUFS
OMVFS

LapScore
EUFS
FSDS
MVUFS
OMVFS
500

LapScore
EUFS
FSDS
MVUFS
OMVFS

200

300

400

# of Selected Feature
(a) ACC for FOX

600

100

200

300

400

500

600

# of Selected Feature
(b) NMI for FOX

C. Experiment Settings

In our experiments, two widely used evaluation metrics,
Accuracy (ACC) and Normalized Mutual Information (NMI),
are used to measure the clustering performance [28]. We
apply different methods to the four data sets, then the multi-
view spherical K-means algorithm [29] is applied to get the
clustering solution. Since LapScore, EUFS and FSDS only
work for single view data,
in the experiments, we apply
these three methods on each of the view to select features.
It is worth mentioning that MVUFS is an off-line multi-
view feature selection method, which takse all data into
consideration and can often achieve better performance than
online methods. Furthermore, LapScore, EUFS, MVUFS are
all off-line methods, which cannot handle large datasets. Thus,
only the two online methods, FSDS and OMVFS, are applied
to the two large datasets.

Most of the comparison methods use graph/similarity ma-
trices. In the experiments, we used the same kernal/similarity
matrices as stated in the original papers. For the proposed
OMVFS, we used the Gaussian kernel. If not stated, for the
online methods (FSDS and OMVFS) the size of data chunk is
set to 200 for the two small datasets and 1000 for the two large
datasets. The buffer size is set to 2 and γ is set to 107 for the
proposed OMVFS method. For the sake of convenience, the
parameters αv and βv are all set equally for different views.
For FSDS, we do grid search in {1, 2, ..., 10} for the index of
parameter α. For all the other parameters in the comparison
methods, we do grid search in {10−2, 10−1, ..., 102}. We also
vary the number of selected features as {100, 200, ..., 600} for
all the views. The performance of the best parameter setting
is reported for all the methods.

D. Results on Small Datasets

In order to compare the proposed OMVFS method with
other comparison methods, we ﬁrst apply all the methods
to two small datasets, FOX and CNN. Fig. 3 shows the
performance of all the methods on FOX and CNN data with
different numbers of selected features.

From the Fig. 3, we can observe that as the number of
selected feature increases, the performance will increase for
most of the cases. For both datasets, the two multi-view feature
selection methods, MVUFS (off-line) and OMVFS (online),
outperform the single view feature selection methods. This

200

300

400

500

600

# of Selected Feature

200

300

400

500

600

# of Selected Feature

(c) ACC for CNN

(d) NMI for CNN

Fig. 3: Performance with different # features on small datasets.

observation suggests that combining different views would
beneﬁt the feature selection for multi-view data.

For the FOX data, we can observe from Fig. 3a and Fig. 3b
that the performance of the proposed OMVFS is very close
and even better than that of the best off-line method. Among
the three single view methods, FSDS and EUFS can get
better performance than LapScore. Although FSDS may suffer
from low performance when including only 100 features, its
performance will increase dramatically when including more
than 200 features. This may indicate that the online FSDS
selects less discriminative features as the top features, however,
more discriminative features will be included if we increase
the size of the feature set.

For the CNN data, we can see that the proposed OMVFS
has similar performance as MVUFS when the feature size
is less than 300. However, OMVFS outperforms MVUFS if
more than 300 features are included. Comparing the statics
of CNN and FOX data, we can ﬁnd that CNN has higher
feature dimensions and more classes than FOX. The proposed
OMVFS may select more discriminative features in data with
higher dimensions than MVUFS.

From the results on FOX and CNN, we can conclude that
the proposed OMVFS method outperforms all the single view
feature selection methods (online and off-line). It can also get
close or even better performance than the most advanced off-
line multi-view feature selection method.

E. Result on Large Datasets

Since the proposed OMVFS is designed for large-scale
multi-view datasets, we test OMVFS on the two largest public
available multi-view datasets. We also compare OMVFS with
the most recent online single view feature selection method,
FSDS. The results on both datasets are reported in Fig. 4.
However, due to the extremely high runtime and memory
consumption, LapScore, EUFS and MVUFS cannot be applied
to the two large datasets.

0.6

0.55

0.5

C
C
A

0.45

0.4

0.35

0.3

100

C
C
A

0.9

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.1

0.4

0.35

0.3

I

M
N

0.25

0.2

0.15

0.1

100

0.8

0.7

0.6

0.4

0.3

I

M
N

0.5

0.2

100

105

104

103

102

101

)
s
(
 

e
m

i
t

n
u
R

100

103

2000

1500

1000

500

)
s
(
 

e
m

i
t

n
u
R

0

0

104

103

102

)
s
(
 

e
m

i
t

n
u
R

101

103

OMVFS
FSDS
MVUFS
105

8000

7000

6000

5000

4000

3000

2000

1000

)
s
(
 

e
m

i
t

n
u
R

0

0

FSDS
OMVFS

600

200

300

400

500

# of Selected Feature
(a) ACC for Reuters

FSDS
OMVFS

600

200

300

400

500

# of Selected Feature
(b) NMI for Reuters

OMVFS
FSDS
MVUFS

105

104
# of instances (N)
(a) Runtime on Reuters

104
# of instances (N)
(b) Runtime on YouTube

Fig. 5: Runtime v.s. the Data size on Reuters and YouTube
Data. We only report the runtime for MVUFS under size 104,
because of the high runtime and memory consumption.

100

200

300

400

500

600

# of Selected Feature

200

300

400

500

600

# of Selected Feature

OMVFS
FSDS

OMVFS
FSDS

FSDS
OMVFS

FSDS
OMVFS

(c) ACC for YouTube

(d) NMI for YouTube

Fig. 4: Performance with different # features on large datasets.

From Fig. 4, it can be easily observed that the proposed
OMVFS methods achieves better performance than FSDS in
most cases. Especially when the number of selected feature is
small (i.e., less than 300), OMVFS is much better than FSDS.
For example, on YouTube data, when we only select 100
features, the NMI for OMVFS is about 0.58, while the NMI
for FSDS is only 0.28. This observation suggests that unlike
FSDS, which tends to include less discriminative features in
the top selected feature set, the proposed OMVFS selects more
discriminative features even in a small set of selected features.

F. Scalability Comparison

In order to show the scalability of the proposed OMVFS
method under different data sizes, we run OMVFS on the
Reuters and YouTube data and report the runtime for different
data sizes (number of instances) in Fig. 5. Also, to show
the scalability of OMVFS method under different feature
dimensions, we randomly sample different numbers of features
from the two large datasets and run OMVFS on the sampled
features. The runtime for different feature dimensions is re-
ported in Fig. 6.

We select MVUFS and FSDS as comparison methods, since
MVUFS is the only one that deals with multi-view data and
FSDS is the only one that handles large-scale/streaming data.
Because FSDS is a single view method, we run FSDS on each
view and report the total runtime for all the views.

From Fig. 5, we can observe that the two online methods,
FSDS and OMVFS, are much faster than the off-line MVUFS
and the runtime of the two online methods are linear with
respect to the data size. It only takes about 3 seconds for FSDS
and OMVFS on data with size 1000 on Reuters data, while
MVUFS takes about 300 seconds. Like the FSDS method, the
proposed OMVFS only uses the current data chunks and all
the historical data is aggregated. OMVFS considers all the
views simultaneously while FSDS can only work on single
view. Although the two online methods have similar runtime

80
20
Percentage of the features (%)

40

60

100

80
20
Percentage of features (%)

60

40

100

(a) Runtime on Reuters

(b) Runtime on YouTube

Fig. 6: Runtime v.s. the feature dimension on Reuters and
YouTube Data. Due to the high runtime and memory con-
sumption of MVUFS, we only report the runtime for OMVFS
and FSDS.

with small data, the proposed OMVFS uses less time as the
data size increases. Further, it can be found that OMVFS is
about 100 times faster than MVUFS on both datasets.

Because of the high memory usage and slow runtime of
MVUFS, we only report the runtime for OMVFS and FSDS
in Fig. 6. From Fig. 6, we can observe that although FSDS is
faster when we only sample small number of features (10 % or
20%), the runtime of OMVFS grows much slower than FSDS
as the dimension of features increases. For Reuters data, the
runtime of OMVFS only increases from 240 seconds to 480
seconds when the number of features increases from 10% to
100%. Thus, the proposed OMVFS is faster when the feature
dimension becomes really large.

G. Stability under Concept Drift

It is well-known that online/streaming algorithms are gen-
erally sensitive to the order of data, or concept drift [11].
To test the performance of OMVFS in such scenarios, we
use 12,000 instances from Reuters data. We randomly create
unbalanced data with two dominant classes and randomly
change the dominant classes for every 3,000 instances in the
data stream. OMVFS is then applied to the data stream with
concept drifts. As the data came in, we report the performance
of OMVFS with different sizes of feature set in Fig. 7. We
also compare against a scheme where a static feature subset
(with 200 features) is used without adapting to concept drift.
This static feature subset is determined by OMVFS using only
the ﬁrst 3,000 instances in the data stream.

I

M
N

0.24

0.32

0.3

0.28

0.26

0.22

0.2

0.18

0.16

C
C
A

0.8

0.6

0.4

0.2

0

I

M
N

0.8

0.6

0.4

0.2

0

# of features = 200
# of features = 300
# of features = 400
fixed feature (200)

C
C
A

0.5

1

0

0.6

0.4

I

M
N

0.2

0

50

100

150

200

250

Batch size

600

500

200

100

400

300

# Features

50

100

150

200

250

Batch size

600

500

200

100

400

300

# Features

3000

4000

5000

6000

7000

8000

9000 10000 11000 12000

Samples Order

(a)

(b)

Fig. 7: Concept drift test across the data stream for OMVFS

Fig. 9: ACC and NMI of OMVFS with different batch sizes
m and feature numbers on FOX

0.8

0.6

0.4

C
C
A

0.2

0

I

M
N

0.8

0.6

0.4

0.2

0

102

10-1

1

α

10-1

10-2

600

500

400

300

200

100

# of Selected Feature

102

10-1

1

β

10-1

10-2

600

500

400

300

200

100

# of Selected Feature

(a) ACC when βv = 1, with dif-
ferent αv

(b) ACC when αv = 10, with different
βv

102

10-1

1

α

10-1

10-2

600

500

400

300

200

100

# of Selected Feature

102

10-1

1

β

10-1

10-2

600

500

400

300

200

100

# of Selected Feature

(c) NMI when βv = 1, with differ-
ent αv

(d) NMI when αv = 10, with different
βv

Fig. 8: ACC and NMI of OMVFS with different αv,βv and
feature numbers on FOX

From Fig. 7, we can observe that the approach based on
static feature subset performs quite close to OMVFS in the
beginging. However, as new data come in and concept drift
becomes more prominent, the performance of static feature
subset decreases. On the other side, the performance of the
proposed OMVFS will not decrease as more data come in.
Instead, the performance increases as OMVFS combines the
information in the new data with the aggregated information
from previous data. Also, from Fig. 7, we can see that in
general, the more features we select, the better performance
OMVFS would achieve.

H. Parameter Study

There are two sets of parameters in the proposed methods:
{αv} and {βv}. Here, we explore the effects of the two
parameter sets. For the sake of convenience, we set αv to
be equal for different views and also set βv equally. We ran
OMVFS with different values for {αv} and {βv} on FOX data.
Basically, we ﬁx one of the parameters and ran OMVFS with
different values for the other. We report the performance with

different sizes of the selected features. The results in ACC and
NMI are shown in Fig. 8.

From Fig. 8, we can see that for most of the cases, the pro-
posed OMVFS method is not very sensitive to the parameters
αv and βv. However, the performance does increase as the
number of selected features increases.

Another parameter in the proposed OMVFS method is the
batch size m, which is a common parameter for streaming
algorithms. To test the performance of OMVFS under different
batch sizes, we run OMVFS on FOX data with different batch
sizes and numbers of selected features. The results in ACC
and NMI are shown in Fig. 9. From Fig. 9, we can clearly
observe that the performance of OMVFS is very stable under
different batch sizes.

VI. RELATED WORK

There are three areas of related works upon which the
proposed model is built. Feature selection, especially unsuper-
vised feature selection [4], [5], is the ﬁrst area that is related to
this work. Most of the unsupervised feature selection methods
combine generated pseudo labels with sparse learning [6],
[7]. In terms of the number of views available, unsupervised
feature selection can be categorized into single view feature
selection and multi-view feature selection. Most of the conven-
tional unsupervised feature selection methods are designed for
single view. As more and more multi-view data are generated,
the limitation of conventional feature selection methods be-
comes more obvious. Multi-view feature selection has drawn
more attention in recent years. Several effective methods have
been proposed to solve unsupervised feature selection problem
for various multi-view scenarios [8]–[10]. However, all the
previous multi-view feature selection methods suffer from the
scalability issues. They all require that the whole data ﬁt
into the memory. The proposed OMVFS method, however,
only takes a small amount of memory space and uses less
computational time without sacriﬁcing the performance, which
makes it more suitable for large-scale/streaming data.

Multi-view unsupervised learning is the second area that is
related to our work. A few directions were explored to solve
multi-view unsupervised learning in recent years. For example,
[30], [31] propose to use canonical correlation analysis to
combine different views. [32], [33] explore the option to model

VII. CONCLUSIONS

factorization,” in NIPS, 2001.

the multi-view learning as a joint NMF problem. [34], [35] use
tensor to model the multi-view data.

Nonnegative matrix factorization [20], especially online
NMF, is the third area that is related to our work. NMF
has been successfully used in unsupervised learning [15],
[21]. However, traditional NMF cannot deal with large-scale
data. Different variations were proposed in the last few years.
For example, [36] proposed an online NMF algorithm for
document clustering. [37] proposed an efﬁcient online NMF
algorithm (OR-NMF) that takes one sample or a chunk of
samples per step and updates the bases via robust hastic
approximation. All the online NMF methods either focus on
clustering or dimension reduction. None of them are designed
for feature selection. Furthermore, none of them can handle
multi-view data. However, our proposed OMVFS directly
embeds feature selection into the online joint NMF frame-
work with graph regularization, which handles large/streaming
multi-view data.

In this paper, we present possibly the ﬁrst attempt to solve
the online unsupervised multi-view feature selection problem.
Based on NMF, the proposed method OMVFS directly embeds
the feature selection into the graph regularized clustering
algorithm. A joint NMF is used to learn a consensus clustering
indicator matrix, which makes OMVFS integrate information
from different views. OMVFS also adopts the graph regular-
ization to preserve the local structure information and help
select more discriminative features. Solving the optimization
problem in an incremental way, OMVFS can process the
data chunks one by one without storing all the historical
data, which greately reduces the memory requirement. Also,
by using the buffering technique, OMVFS can reduce the
computational and storage cost while taking advantage of the
structure information. The buffering will also help OMVFS
capture the concept drift in the data streams. Extensive ex-
periments conducted on two small datasets and two large
datasets demonstrate the effectiveness and efﬁciency of the
proposed OMVFS algorithm. Without sacriﬁcing performance,
the proposed OMVFS is about 100 times faster than the best
off-line multi-view feature selection method.

REFERENCES

[1] S. Sun, “A survey of multi-view machine learning,” Neural Computing

and Applications, vol. 23, no. 7-8, pp. 2031–2038, 2013.

[2] G. H. John, R. Kohavi, K. Pﬂeger et al., “Irrelevant features and the

subset selection problem,” in ICML, 1994.

[3] Z. Zhao and H. Liu, “Spectral feature selection for supervised and

unsupervised learning,” in ICML, 2007.

[4] D. Cai, C. Zhang, and X. He, “Unsupervised feature selection for multi-

[5] S. Wang, J. Tang, and H. Liu, “Embedded unsupervised feature selec-

cluster data,” in KDD, 2010.

tion.” in AAAI, 2015.

[6] Z. Li, Y. Yang, J. Liu, X. Zhou, and H. Lu, “Unsupervised feature

selection using nonnegative spectral analysis.” in AAAI, 2012.

[7] M. Qian and C. Zhai, “Robust unsupervised feature selection.” in IJCAI,

2013.

[8] H. Wang, F. Nie, and H. Huang, “Multi-view clustering and feature

learning via structured sparsity,” in ICML, 2013.

[9] J. Tang, X. Hu, H. Gao, and H. Liu, “Unsupervised feature selection for

multi-view data in social media.” in SDM, 2013.

[10] M. Qian and C. Zhai, “Unsupervised feature selection for multi-view

clustering on text-image web news data,” in CIKM, 2014.

[11] H. Wang, W. Fan, P. S. Yu, and J. Han, “Mining concept-drifting data

streams using ensemble classiﬁers,” in KDD, 2003.

[12] Q. Song, J. Ni, and G. Wang, “A fast clustering-based feature subset
selection algorithm for high-dimensional data,” IEEE Transactions on
Knowledge and Data Engineering, vol. 25, no. 1, pp. 1–14, 2013.
[13] C. Maung and H. Schweitzer, “Pass-efﬁcient unsupervised feature se-

lection,” in NIPS, 2013.

[14] H. Huang, S. Yoo, and S. P. Kasiviswanathan, “Unsupervised feature

selection on data streams,” in CIKM, 2015.

[15] C. Ding, T. Li, W. Peng, and H. Park, “Orthogonal nonnegative matrix

t-factorizations for clustering,” in KDD, 2006.

[16] S. Choi, “Algorithms for orthogonal nonnegative matrix factorization,”

in IJCNN, 2008.

[17] J.-H. Yoo and S.-J. Choi, “Nonnegative matrix factorization with or-
thogonality constraints,” Journal of computing science and engineering,
vol. 4, no. 2, pp. 97–109, 2010.

[18] S. Wang, J. Tang, and H. Liu, “Embedded unsupervised feature selec-

[19] S. Boyd and L. Vandenberghe, Convex optimization.

Cambridge

tion,” in AAAI, 2015.

university press, 2004.

[20] D. D. Lee and H. S. Seung, “Algorithms for non-negative matrix

[21] D. Cai, X. He, J. Han, and T. S. Huang, “Graph regularized nonnegative
matrix factorization for data representation,” IEEE Transactions on
Pattern Analysis and Machine Intelligence, vol. 33, no. 8, pp. 1548–
1560, 2011.

[22] L. Bottou, “Large-scale machine learning with stochastic gradient de-

scent,” in COMPSTAT, 2010.

[23] ——, “Online learning and stochastic approximations,” On-line learning

in neural networks, vol. 17, no. 9, p. 142.

[24] O. Madani, M. Georg, and D. A. Ross, “On using nearly-independent
feature families for high precision and conﬁdence,” Machine Learning,
vol. 92, pp. 457–477, 2013.

[25] M. Amini, N. Usunier, and C. Goutte, “Learning from multiple partially
observed views-an application to multilingual text categorization,” in
NIPS, 2009.

[26] X. He, D. Cai, and P. Niyogi, “Laplacian score for feature selection,”

in NIPS, 2005.

[27] M. Qian and C. Zhai, “Unsupervised feature selection for multi-view

clustering on text-image web news data,” in CIKM, 2014.

[28] W. Xu, X. Liu, and Y. Gong, “Document clustering based on non-

negative matrix factorization,” in SIGIR, 2003.

[29] S. Bickel and T. Scheffer, “Multi-view clustering,” in ICDM, 2004.
[30] K. Chaudhuri, S. M. Kakade, K. Livescu, and K. Sridharan, “Multi-view
Clustering via Canonical Correlation Analysis,” in ICML, 2009.
[31] W. Shao, X. Shi, and P. Yu, “Clustering on multiple incomplete datasets

via collective kernel learning,” in ICDM, 2013.

[32] J. Liu, C. Wang, J. Gao, and J. Han, “Multi-View Clustering via Joint

Nonnegative Matrix Factorization,” in SDM, 2013.

[33] W. Shao, L. He, and P. S. Yu, “Multiple Incomplete Views Clustering via
Weighted Nonnegative Matrix Factorization with L2,1 Regularization,”
in ECML PKDD, 2015.

[34] X. Liu, S. Ji, W. Gl¨anzel, and B. De Moor, “Multiview partitioning via
tensor methods,” IEEE Transactions on Knowledge and Data Engineer-
ing, vol. 25, no. 5, pp. 1056–1069, 2013.

[35] W. Shao, L. He, and S. Y. Philip, “Clustering on multi-source incomplete

data via tensor modeling and factorization,” in PAKDD, 2015.

[36] F. Wang, P. Li, and A. C. K¨onig, “Efﬁcient document clustering via

online nonnegative matrix factorizations.” in SDM, 2011.

[37] N. Guan, D. Tao, Z. Luo, and B. Yuan, “Online nonnegative matrix
factorization with robust stochastic approximation,” IEEE Transactions
on Neural Networks and Learning Systems, vol. 23, no. 7, pp. 1087–
1099, 2012.

