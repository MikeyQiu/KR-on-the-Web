6
1
0
2
 
b
e
F
 
2
2
 
 
]

G
L
.
s
c
[
 
 
5
v
9
8
2
7
0
.
1
1
5
1
:
v
i
X
r
a

Published as a conference paper at ICLR 2016

FAST AND ACCURATE DEEP NETWORK LEARNING BY
EXPONENTIAL LINEAR UNITS (ELUS)

Djork-Arn´e Clevert, Thomas Unterthiner & Sepp Hochreiter
Institute of Bioinformatics
Johannes Kepler University, Linz, Austria
{okko,unterthiner,hochreit}@bioinf.jku.at

ABSTRACT

We introduce the “exponential linear unit” (ELU) which speeds up learning in
deep neural networks and leads to higher classiﬁcation accuracies. Like recti-
ﬁed linear units (ReLUs), leaky ReLUs (LReLUs) and parametrized ReLUs (PRe-
LUs), ELUs alleviate the vanishing gradient problem via the identity for positive
values. However ELUs have improved learning characteristics compared to the
units with other activation functions. In contrast to ReLUs, ELUs have negative
values which allows them to push mean unit activations closer to zero like batch
normalization but with lower computational complexity. Mean shifts toward zero
speed up learning by bringing the normal gradient closer to the unit natural gra-
dient because of a reduced bias shift effect. While LReLUs and PReLUs have
negative values, too, they do not ensure a noise-robust deactivation state. ELUs
saturate to a negative value with smaller inputs and thereby decrease the forward
propagated variation and information. Therefore ELUs code the degree of pres-
ence of particular phenomena in the input, while they do not quantitatively model
the degree of their absence.
In experiments, ELUs lead not only to faster learning, but also to signiﬁcantly bet-
ter generalization performance than ReLUs and LReLUs on networks with more
than 5 layers. On CIFAR-100 ELUs networks signiﬁcantly outperform ReLU
networks with batch normalization while batch normalization does not improve
ELU networks. ELU networks are among the top 10 reported CIFAR-10 results
and yield the best published result on CIFAR-100, without resorting to multi-view
evaluation or model averaging. On ImageNet, ELU networks considerably speed
up learning compared to a ReLU network with the same architecture, obtaining
less than 10% classiﬁcation error for a single crop, single model network.

1

INTRODUCTION

Currently the most popular activation function for neural networks is the rectiﬁed linear unit (ReLU),
which was ﬁrst proposed for restricted Boltzmann machines (Nair & Hinton, 2010) and then suc-
cessfully used for neural networks (Glorot et al., 2011). The ReLU activation function is the identity
for positive arguments and zero otherwise. Besides producing sparse codes, the main advantage
of ReLUs is that they alleviate the vanishing gradient problem (Hochreiter, 1998; Hochreiter et al.,
2001) since the derivative of 1 for positive values is not contractive (Glorot et al., 2011). However
ReLUs are non-negative and, therefore, have a mean activation larger than zero.

Units that have a non-zero mean activation act as bias for the next layer. If such units do not cancel
each other out, learning causes a bias shift for units in next layer. The more the units are correlated,
the higher their bias shift. We will see that Fisher optimal learning, i.e., the natural gradient (Amari,
1998), would correct for the bias shift by adjusting the weight updates. Thus, less bias shift brings
the standard gradient closer to the natural gradient and speeds up learning. We aim at activation
functions that push activation means closer to zero to decrease the bias shift effect.

Centering the activations at zero has been proposed in order to keep the off-diagonal entries of the
Fisher information matrix small (Raiko et al., 2012). For neural network it is known that centering

1

Published as a conference paper at ICLR 2016

the activations speeds up learning (LeCun et al., 1991; 1998; Schraudolph, 1998). “Batch normaliza-
tion” also centers activations with the goal to counter the internal covariate shift (Ioffe & Szegedy,
2015). Also the Projected Natural Gradient Descent algorithm (PRONG) centers the activations by
implicitly whitening them (Desjardins et al., 2015).

An alternative to centering is to push the mean activation toward zero by an appropriate activation
function. Therefore tanh has been preferred over logistic functions (LeCun et al., 1991; 1998). Re-
cently “Leaky ReLUs” (LReLUs) that replace the negative part of the ReLU with a linear function
have been shown to be superior to ReLUs (Maas et al., 2013). Parametric Rectiﬁed Linear Units
(PReLUs) generalize LReLUs by learning the slope of the negative part which yielded improved
learning behavior on large image benchmark data sets (He et al., 2015). Another variant are Ran-
domized Leaky Rectiﬁed Linear Units (RReLUs) which randomly sample the slope of the negative
part which raised the performance on image benchmark datasets and convolutional networks (Xu
et al., 2015).

In contrast to ReLUs, activation functions like LReLUs, PReLUs, and RReLUs do not ensure a
noise-robust deactivation state. We propose an activation function that has negative values to allow
for mean activations close to zero, but which saturates to a negative value with smaller arguments.
The saturation decreases the variation of the units if deactivated, so the precise deactivation argument
is less relevant. Such an activation function can code the degree of presence of particular phenomena
in the input, but does not quantitatively model the degree of their absence. Therefore, such an acti-
vation function is more robust to noise. Consequently, dependencies between coding units are much
easier to model and much easier to interpret since only activated code units carry much information.
Furthermore, distinct concepts are much less likely to interfere with such activation functions since
the deactivation state is non-informative, i.e. variance decreasing.

2 BIAS SHIFT CORRECTION SPEEDS UP LEARNING

To derive and analyze the bias shift effect mentioned in the introduction, we utilize the natural gra-
dient. The natural gradient corrects the gradient direction with the inverse Fisher information matrix
and, thereby, enables Fisher optimal learning, which ensures the steepest descent in the Riemannian
parameter manifold and Fisher efﬁciency for online learning (Amari, 1998). The recently introduced
Hessian-Free Optimization technique (Martens, 2010) and the Krylov Subspace Descent methods
(Vinyals & Povey, 2012) use an extended Gauss-Newton approximation of the Hessian, therefore
they can be interpreted as versions of natural gradient descent (Pascanu & Bengio, 2014).

Since for neural networks the Fisher information matrix is typically too expensive to compute, dif-
ferent approximations of the natural gradient have been proposed. Topmoumoute Online natural
Gradient Algorithm (TONGA) (LeRoux et al., 2008) uses a low-rank approximation of natural gra-
dient descent. FActorized Natural Gradient (FANG) (Grosse & Salakhudinov, 2015) estimates the
natural gradient via an approximation of the Fisher information matrix by a Gaussian graphical
model. The Fisher information matrix can be approximated by a block-diagonal matrix, where unit
or quasi-diagonal natural gradients are used (Olivier, 2013). Unit natural gradients or “Unitwise
Fisher’s scoring” (Kurita, 1993) are based on natural gradients for perceptrons (Amari, 1998; Yang
& Amari, 1998). We will base our analysis on the unit natural gradient.

We assume a parameterized probabilistic model p(x; w) with parameter vector w and data x. The
training data are X = (x1, . . . , xN ) ∈ R(d+1)×N with xn = (zT
n , yn)T ∈ Rd+1, where zn is the
input for example n and yn is its label. L(p(.; w), x) is the loss of example x = (zT , y)T using
model p(.; w). The average loss on the training data X is the empirical risk Remp(p(.; w), X).
Gradient descent updates the weight vector w by wnew = wold − η∇wRemp where η is the learning
rate. The natural gradient is the inverse Fisher information matrix ˜F −1 multiplied by the gradient of
w Remp = ˜F −1∇wRemp. For a multi-layer perceptron a is the unit activation
the empirical risk: ∇nat
vector and a0 = 1 is the bias unit activation. We consider the ingoing weights to unit i, therefore we
drop the index i: wj = wij for the weight from unit j to unit i, a = ai for the activation, and w0 for
the bias weight of unit i. The activation function f maps the net input net = (cid:80)
j wjaj of unit i to its
activation a = f (net). For computing the Fisher information matrix, the derivative of the log-output
probability ∂
∂net ln p(z; w),
∂wj

ln p(z; w) is required. Therefore we deﬁne the δ at unit i as δ = ∂

2

Published as a conference paper at ICLR 2016

which can be computed via backpropagation, but using the log-output probability instead of the
conventional loss function. The derivative is ∂
∂wj

ln p(z; w) = δaj.

We restrict the Fisher information matrix to weights leading to unit i which is the unit Fisher in-
formation matrix F . F captures only the interactions of weights to unit i. Consequently, the unit
natural gradient only corrects the interactions of weights to unit i, i.e. considers the Riemannian
parameter manifold only in a subspace. The unit Fisher information matrix is

[F (w)]kj = Ep(z;w)

(cid:18) ∂ ln p(z; w)
∂wk

∂ ln p(z; w)
∂wj

(cid:19)

= Ep(z;w)(δ2 ak aj) .

(1)

Weighting the activations by δ2 is equivalent to adjusting the probability of drawing inputs z. In-
puts z with large δ2 are drawn with higher probability. Since 0 ≤ δ2 = δ2(z), we can deﬁne a
distribution q(z):

q(z) = δ2(z) p(z)

δ2(z) p(z) dz

(cid:18)(cid:90)

(cid:19)−1

= δ2(z) p(z) E−1

p(z)(δ2) .

(2)

Using q(z), the entries of F can be expressed as second moments:

[F (w)]kj = Ep(z)(δ2 ak aj) =

δ2 ak aj p(z) dz = Ep(z)(δ2) Eq(z)(ak aj) .

(3)

(cid:90)

If the bias unit is a0 = 1 with weight w0 then the weight vector can be divided into a bias part w0
and the rest w: (wT , w0)T . For the row b = [F (w)]0 that corresponds to the bias weight, we have:
b = Ep(z)(δ2a) = Ep(z)(δ2) Eq(z)(a) = Covp(z)(δ2, a) + Ep(z)(a) Ep(z)(δ2) .
(4)
The next Theorem 1 gives the correction of the standard gradient by the unit natural gradient where
the bias weight is treated separately (see also Yang & Amari (1998)).
Theorem 1. The unit natural gradient corrects the weight update (∆wT , ∆w0)T to a unit i by
following afﬁne transformation of the gradient ∇(wT ,w0)T Remp = (gT , g0)T :
(cid:19)

(cid:19)

(cid:18) ∆w
∆w0

=

(cid:18)A−1 (g − ∆w0 b)
s (cid:0)g0 − bT A−1g(cid:1)

,

where A = [F (w)]¬0,¬0 = Ep(z)(δ2)Eq(z)(aaT ) is the unit Fisher information matrix without
row 0 and column 0 corresponding to the bias weight. The vector b = [F (w)]0 is the zeroth column
of F corresponding to the bias weight, and the positive scalar s is

s = E−1

p(z)(δ2)

1 + ET

q(z)(a) Var−1

(cid:17)
q(z)(a) Eq(z)(a)

,

(cid:16)

where a is the vector of activations of units with weights to unit i and q(z) = δ2(z)p(z)E−1

Proof. Multiplying
separated
∇(wT ,w0)T Remp((wT , w0)T , X) = (gT , g0)T gives the weight update (∆wT , ∆w0)T :
(cid:19)

Fisher matrix F −1 with

inverse

the

the

(cid:19)

(cid:19)

(cid:18) ∆w
∆w0

=

(cid:18) A b
bT
c

(cid:19)−1 (cid:18) g
g0

=

(cid:18)A−1 g + u s−1uT g + go u
uT g + s g0

.

where

b = [F (w)]0

,

c = [F (w)]00

, u = − s A−1 b ,

s = (cid:0)c − bT A−1b(cid:1)−1

. (8)

The previous formula is derived in Lemma 1 in the appendix. Using ∆w0 in the update gives
(cid:19)

(cid:19)

(cid:19)

(cid:19)

(cid:18) ∆w
∆w0

=

(cid:18)A−1 g + s−1u ∆w0
uT g + s g0

,

(cid:18) ∆w
∆w0

=

(cid:18)A−1 (g − ∆w0 b)
s (cid:0)g0 − bT A−1g(cid:1)

.

(9)

The right hand side is obtained by inserting u = −sA−1b in the left hand side update. Since
c = F00 = Ep(z)(δ2), b = Ep(z)(δ2)Eq(z)(a), and A = Ep(z)(δ2)Eq(z)(aaT ), we obtain
(cid:16)

(cid:17)−1

= E−1

p(z)(δ2)

1 − ET

q(z)(a) E−1

q(z)(aaT ) Eq(z)(a)

.

(10)

s = (cid:0)c − bT A−1b(cid:1)−1

Applying Lemma 2 in the appendix gives the formula for s.

(5)

(6)

p(z)(δ2).

gradient

(7)

3

Published as a conference paper at ICLR 2016

(11)

(12)

The bias shift (mean shift) of unit i is the change of unit i’s mean value due to the weight update. Bias
shifts of unit i lead to oscillations and impede learning. See Section 4.4 in LeCun et al. (1998) for
demonstrating this effect at the inputs and in LeCun et al. (1991) for explaining this effect using the
input covariance matrix. Such bias shifts are mitigated or even prevented by the unit natural gradient.
The bias shift correction of the unit natural gradient is the effect on the bias shift due to b which
captures the interaction between the bias unit and the incoming units. Without bias shift correction,
i.e., b = 0 and s = c−1, the weight updates are ∆w = A−1g and ∆w0 = c−1g0. As only the
activations depend on the input, the bias shift can be computed by multiplying the weight update by
the mean of the activation vector a. Thus we obtain the bias shift (Ep(z)(a)T , 1)(∆wT , ∆w0)T =
ET
p(z)(a)A−1g + c−1g0. The bias shift strongly depends on the correlation of the incoming units
which is captured by A−1.

Next, Theorem 2 states that the bias shift correction by the unit natural gradient can be considered
to correct the incoming mean Ep(z)(a) proportional to Eq(z)(a) toward zero.
Theorem 2. The bias shift correction by the unit natural gradient is equivalent to an additive cor-
rection of the incoming mean by −k Eq(z)(a) and a multiplicative correction of the bias unit by k,
where

k = 1 + (cid:0)Eq(z)(a) − Ep(z)(a)(cid:1)T

Var−1

q(z)(a) Eq(z)(a) .

Proof. Using ∆w0 = −sbT A−1g + sg0, the bias shift is:

(cid:18)Ep(z)(a)
1

(cid:19)T (cid:18) ∆w
∆w0

(cid:19)

(cid:18)Ep(z)(a)
1

(cid:19)T (cid:18)A−1 g − A−1b ∆w0

(cid:19)

=

(cid:16)

= ET
p(z)(a) A−1 g +
(cid:32)

=

ET

p(z)(a) −

1 − ET

1 − ET

p(z)(a) A−1b

(cid:16)

(cid:124)

(cid:17)

p(z)(a) A−1b
(cid:123)(cid:122)

s bT
(cid:125)

∆w0

(cid:17)

∆w0
(cid:33)

A−1 g + s

1 − ET

p(z)(a) A−1b

g0 .

(cid:16)

(cid:17)

The mean correction term, indicated by an underbrace in previous formula, is

p(z)(a) A−1b

b = E−1

(cid:17)

1 − ET

q(z)(a) E−1

q(z)(aaT ) Eq(z)(a)

(cid:17)−1

(13)

1 − ET

p(z)(a) E−1

q(z)(aaT ) Eq(z)(a)

Ep(z)(δ2) Eq(z)(a)

=

1 − ET

q(z)(a) E−1

q(z)(aaT ) Eq(z)(a)

(cid:17)−1 (cid:16)

1 − ET

p(z)(a) E−1

(cid:17)
q(z)(aaT ) Eq(z)(a)

Eq(z)(a).

(cid:16)

s

1 − ET
(cid:16)

(cid:16)

(cid:124)

(cid:16)

p(z)(δ2)
(cid:17)

(cid:123)(cid:122)
k

(cid:125)

The expression Eq. (11) for k follows from Lemma 2 in the appendix. The bias unit correction term
is s

g0 = kc−1g0.

1 − ET

p(z)(a)A−1b

(cid:16)

(cid:17)

p(z)(δ2)CovT
In Theorem 2 we can reformulate k = 1 + E−1
q(z)(a)Eq(z)(a). Therefore
k increases with the length of Eq(z)(a) for given variances and covariances. Consequently the bias
shift correction through the unit natural gradient is governed by the length of Eq(z)(a). The bias
shift correction is zero for Eq(z)(a) = 0 since k = 1 does not correct the bias unit multiplicatively.
Using Eq. (4), Eq(z)(a) is split into an offset and an information containing term:

p(z)(δ2, a)Var−1

Eq(z)(a) = Ep(z)(a) + E−1

p(z)(δ2) Covp(z)(δ2, a) .

(14)

In general, smaller positive Ep(z)(a) lead to smaller positive Eq(z)(a), therefore to smaller correc-
tions. The reason is that in general the largest absolute components of Covp(z)(δ2, a) are positive,
since activated inputs will activate the unit i which in turn will have large impact on the output.

To summarize, the unit natural gradient corrects the bias shift of unit i via the interactions of in-
coming units with the bias unit to ensure efﬁcient learning. This correction is equivalent to shifting
the mean activations of the incoming units toward zero and scaling up the bias unit. To reduce the

4

Published as a conference paper at ICLR 2016

undesired bias shift effect without the natural gradient, either the (i) activation of incoming units can
be centered at zero or (ii) activation functions with negative values can be used. We introduce a new
activation function with negative values while keeping the identity for positive arguments where it
is not contradicting.

3 EXPONENTIAL LINEAR UNITS (ELUS)

The exponential linear unit (ELU) with 0 < α is

(cid:26)x

f (x) =

α (exp(x) − 1)

if x > 0
if x ≤ 0

,

f (cid:48)(x) =

(cid:26)1

if x > 0
f (x) + α if x ≤ 0

.

(15)

The ELU hyperparameter α controls the value to which an ELU saturates for negative net inputs
(see Fig. 1). ELUs diminish the vanishing gradient effect as rectiﬁed linear units (ReLUs) and leaky
ReLUs (LReLUs) do. The vanishing gradient problem is alleviated because the positive part of these
functions is the identity, therefore their derivative is one and not contractive. In contrast, tanh and
sigmoid activation functions are contractive almost everywhere.

In contrast to ReLUs, ELUs have negative values
which pushes the mean of the activations closer to
zero. Mean activations that are closer to zero enable
faster learning as they bring the gradient closer to the
natural gradient (see Theorem 2 and text thereafter).
ELUs saturate to a negative value when the argument
gets smaller. Saturation means a small derivative
which decreases the variation and the information
that is propagated to the next layer. Therefore the
representation is both noise-robust and low-complex
(Hochreiter & Schmidhuber, 1999). ELUs code the
degree of presence of input concepts, while they nei-
ther quantify the degree of their absence nor distin-
guish the causes of their absence. This property of
non-informative deactivation states is also present at
ReLUs and allowed to detect biclusters corresponding to biological modules in gene expression
datasets (Clevert et al., 2015) and to identify toxicophores in toxicity prediction (Unterthiner et al.,
2015; Mayr et al., 2015). The enabling features for these interpretations is that activation can be
clearly distinguished from deactivation and that only active units carry relevant information and can
crosstalk.

Figure 1: The rectiﬁed linear unit (ReLU),
the leaky ReLU (LReLU, α = 0.1), the
shifted ReLUs (SReLUs), and the exponen-
tial linear unit (ELU, α = 1.0).

4 EXPERIMENTS USING ELUS

In this section, we assess the performance of exponential linear units (ELUs) if used for unsupervised
and supervised learning of deep autoencoders and deep convolutional networks. ELUs with α = 1.0
are compared to (i) Rectiﬁed Linear Units (ReLUs) with activation f (x) = max(0, x), (ii) Leaky
ReLUs (LReLUs) with activation f (x) = max(αx, x) (0 < α < 1), and (iii) Shifted ReLUs
(SReLUs) with activation f (x) = max(−1, x). Comparisons are done with and without batch
normalization. The following benchmark datasets are used: (i) MNIST (gray images in 10 classes,
60k train and 10k test), (ii) CIFAR-10 (color images in 10 classes, 50k train and 10k test), (iii)
CIFAR-100 (color images in 100 classes, 50k train and 10k test), and (iv) ImageNet (color images in
1,000 classes, 1.3M train and 100k tests).

4.1 MNIST

4.1.1 LEARNING BEHAVIOR

We ﬁrst want to verify that ELUs keep the mean activations closer to zero than other units. Fully
connected deep neural networks with ELUs (α = 1.0), ReLUs, and LReLUs (α = 0.1) were trained
on the MNIST digit classiﬁcation dataset while each hidden unit’s activation was tracked. Each

5

Published as a conference paper at ICLR 2016

(a) Average unit activation

(b) Cross entropy loss

Figure 2: ELU networks evaluated at MNIST. Lines are the average over ﬁve runs with different
random initializations, error bars show standard deviation. Panel (a): median of the average unit
activation for different activation functions. Panel (b): Training set (straight line) and validation set
(dotted line) cross entropy loss. All lines stay ﬂat after epoch 25.

network had eight hidden layers of 128 units each, and was trained for 300 epochs by stochastic gra-
dient descent with learning rate 0.01 and mini-batches of size 64. The weights have been initialized
according to (He et al., 2015). After each epoch we calculated the units’ average activations on a
ﬁxed subset of the training data. Fig. 2 shows the median over all units along learning. ELUs stay
have smaller median throughout the training process. The training error of ELU networks decreases
much more rapidly than for the other networks.

Section C in the appendix compares the variance of median activation in ReLU and ELU networks.
The median varies much more in ReLU networks. This indicates that ReLU networks continuously
try to correct the bias shift introduced by previous weight updates while this effect is much less
prominent in ELU networks.

4.1.2 AUTOENCODER LEARNING

(a) Training set

(b) Test set

Figure 3: Autoencoder training on MNIST: Reconstruction error for the test and training data set
over epochs, using different activation functions and learning rates. The results are medians over
several runs with different random initializations.

6

Published as a conference paper at ICLR 2016

To evaluate ELU networks at unsupervised settings, we followed Martens (2010) and Desjardins
et al. (2015) and trained a deep autoencoder on the MNIST dataset. The encoder part consisted
of four fully connected hidden layers with sizes 1000, 500, 250 and 30, respectively. The decoder
part was symmetrical to the encoder. For learning we applied stochastic gradient descent with mini-
batches of 64 samples for 500 epochs using the ﬁxed learning rates (10−2, 10−3, 10−4, 10−5). Fig. 3
shows, that ELUs outperform the competing activation functions in terms of training / test set recon-
struction error for all learning rates. As already noted by Desjardins et al. (2015), higher learning
rates seem to perform better.

4.2 COMPARISON OF ACTIVATION FUNCTIONS

In this subsection we show that ELUs indeed possess a superior learning behavior compared to other
activation functions as postulated in Section 3. Furthermore we show that ELU networks perform
better than ReLU networks with batch normalization. We use as benchmark dataset CIFAR-100 and
use a relatively simple convolutional neural network (CNN) architecture to keep the computational
complexity reasonable for comparisons.

(a) Training loss

(b) Training loss (start)

(c) Training loss (end)

(d) Test error

(e) Test error (start)

(f) Test error (end)

Figure 4: Comparison of ReLUs, LReLUs, and SReLUs on CIFAR-100. Panels (a-c) show the
training loss, panels (d-f) the test classiﬁcation error. The ribbon band show the mean and standard
deviation for 10 runs along the curve. ELU networks achieved lowest test error and training loss.

The CNN for these CIFAR-100 experiments consists of 11 convolutional layers arranged in stacks
of ([1 × 192 × 5], [1 × 192 × 1, 1 × 240 × 3], [1 × 240 × 1, 1 × 260 × 2], [1 × 260 × 1, 1 × 280 ×
2], [1 × 280 × 1, 1 × 300 × 2], [1 × 300 × 1], [1 × 100 × 1]) layers × units × receptive ﬁelds.
2×2 max-pooling with a stride of 2 was applied after each stack. For network regularization we
used the following drop-out rate for the last layer of each stack (0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.0). The
L2-weight decay regularization term was set to 0.0005. The following learning rate schedule was
applied (0 − 35k[0.01], 35k − 85k[0.005], 85k − 135k[0.0005], 135k − 165k[0.00005]) (iterations
[learning rate]). For fair comparisons, we used this learning rate schedule for all networks. During
previous experiments, this schedule was optimized for ReLU networks, however as ELUs converge
faster they would beneﬁt from an adjusted schedule. The momentum term learning rate was ﬁxed
to 0.9. The dataset was preprocessed as described in Goodfellow et al. (2013) with global contrast

7

Published as a conference paper at ICLR 2016

(a) ELU - ReLU

(b) ELU - SReLU

(c) ELU - LReLU

(d) ELU - ReLU (end)

(e) ELU - SReLU (end)

(f) ELU - LReLU (end)

Figure 5: Pairwise comparisons of ELUs with ReLUs, SReLUs, and LReLUs with and without batch
normalization (BN) on CIFAR-100. Panels are described as in Fig. 4. ELU networks outperform
ReLU networks with batch normalization.

normalization and ZCA whitening. Additionally, the images were padded with four zero pixels
at all borders. The model was trained on 32 × 32 random crops with random horizontal ﬂipping.
Besides that, we no further augmented the dataset during training. Each network was run 10 times
with different weight initialization. Across networks with different activation functions the same run
number had the same initial weights.

Mean test error results of networks with different activation functions are compared in Fig. 4, which
also shows the standard deviation. ELUs yield on average a test error of 28.75(±0.24)%, while SRe-
LUs, ReLUs and LReLUs yield 29.35(±0.29)%, 31.56(±0.37)% and 30.59(±0.29)%, respectively.
ELUs achieve both lower training loss and lower test error than ReLUs, LReLUs, and SReLUs.
Both the ELU training and test performance is signiﬁcantly better than for other activation func-
tions (Wilcoxon signed-rank test with p-value<0.001). Batch normalization improved ReLU and
LReLU networks, but did not improve ELU and SReLU networks (see Fig. 5). ELU networks
signiﬁcantly outperform ReLU networks with batch normalization (Wilcoxon signed-rank test with
p-value<0.001).

4.3 CLASSIFICATION PERFORMANCE ON CIFAR-100 AND CIFAR-10

The following experiments should highlight the generalization capabilities of ELU networks. The
CNN architecture is more sophisticated than in the previous subsection and consists of 18 convolu-
tional layers arranged in stacks of ([1 × 384 × 3], [1 × 384 × 1, 1 × 384 × 2, 2 × 640 × 2], [1 × 640 ×
1, 3 × 768 × 2], [1 × 768 × 1, 2 × 896 × 2], [1 × 896 × 3, 2 × 1024 × 2], [1 × 1024 × 1, 1 × 1152 ×
2], [1 × 1152 × 1], [1 × 100 × 1]). Initial drop-out rate, Max-pooling after each stack, L2-weight
decay, momentum term, data preprocessing, padding, and cropping were as in previous section. The
initial learning rate was set to 0.01 and decreased by a factor of 10 after 35k iterations. The mini-
batch size was 100. For the ﬁnal 50k iterations ﬁne-tuning we increased the drop-out rate for all

8

Published as a conference paper at ICLR 2016

layers in a stack to (0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.0), thereafter increased the drop-out rate by a factor
of 1.5 for 40k additional iterations.

Table 1: Comparison of ELU networks and other CNNs on CIFAR-10 and CIFAR-100. Reported is
the test error in percent misclassiﬁcation for ELU networks and recent convolutional architectures
like AlexNet, DSN, NiN, Maxout, All-CNN, Highway Network, and Fractional Max-Pooling. Best
results are in bold. ELU networks are second best for CIFAR-10 and best for CIFAR-100.

Network
AlexNet
DSN
NiN
Maxout
All-CNN
Highway Network
Fract. Max-Pooling
ELU-Network

CIFAR-10 (test error %)
18.04
7.97
8.81
9.38
7.25
7.60
4.50
6.55

CIFAR-100 (test error %)
45.80
34.57
35.68
38.57
33.71
32.24
27.62
24.28

augmented

√
√
√
√
√
√

ELU networks are compared to following recent successful CNN architectures: AlexNet
(Krizhevsky et al., 2012), DSN (Lee et al., 2015), NiN (Lin et al., 2013), Maxout (Goodfellow
et al., 2013), All-CNN (Springenberg et al., 2014), Highway Network (Srivastava et al., 2015) and
Fractional Max-Pooling (Graham, 2014). The test error in percent misclassiﬁcation are given in
Tab. 1. ELU-networks are the second best on CIFAR-10 with a test error of 6.55% but still they are
among the top 10 best results reported for CIFAR-10. ELU networks performed best on CIFAR-100
with a test error of 24.28%. This is the best published result on CIFAR-100, without even resorting
to multi-view evaluation or model averaging.

4.4

IMAGENET CHALLENGE DATASET

Finally, we evaluated ELU-networks on the 1000-class ImageNet dataset. It contains about 1.3M
training color images as well as additional 50k images and 100k images for validation and testing,
respectively. For this task, we designed a 15 layer CNN, which was arranged in stacks of (1 × 96 ×
6, 3 × 512 × 3, 5 × 768 × 3, 3 × 1024 × 3, 2 × 4096 × F C, 1 × 1000 × F C) layers × units ×
receptive ﬁelds or fully-connected (FC). 2×2 max-pooling with a stride of 2 was applied after each
stack and spatial pyramid pooling (SPP) with 3 levels before the ﬁrst FC layer (He et al., 2015). For
network regularization we set the L2-weight decay term to 0.0005 and used 50% drop-out in the
two penultimate FC layers. Images were re-sized to 256×256 pixels and per-pixel mean subtracted.
Trained was on 224 × 224 random crops with random horizontal ﬂipping. Besides that, we did not
augment the dataset during training.

Fig. 6 shows the learning behavior of ELU vs. ReLU networks. Panel (b) shows that ELUs start
reducing the error earlier. The ELU-network already reaches the 20% top-5 error after 160k itera-
tions, while the ReLU network needs 200k iterations to reach the same error rate. The single-model
performance was evaluated on the single center crop with no further augmentation and yielded a
top-5 validation error below 10%.

Currently ELU nets are 5% slower on ImageNet than ReLU nets. The difference is small because
activation functions generally have only minor inﬂuence on the overall training time (Jia, 2014). In
terms of wall clock time, ELUs require 12.15h vs. ReLUs with 11.48h for 10k iterations. We ex-
pect that ELU implementations can be improved, e.g. by faster exponential functions (Schraudolph,
1999).

5 CONCLUSION

We have introduced the exponential linear units (ELUs) for faster and more precise learning in deep
neural networks. ELUs have negative values, which allows the network to push the mean activations

9

Published as a conference paper at ICLR 2016

(a) Training loss

(b) Top-5 test error

(c) Top-1 test error

Figure 6: ELU networks applied to ImageNet. The x-axis gives the number of iterations and
the y-axis the (a) training loss, (b) top-5 error, and (c) the top-1 error of 5,000 random validation
samples, evaluated on the center crop. Both activation functions ELU (blue) and ReLU (purple) lead
for convergence, but ELUs start reducing the error earlier and reach the 20% top-5 error after 160k
iterations, while ReLUs need 200k iterations to reach the same error rate.

closer to zero. Therefore ELUs decrease the gap between the normal gradient and the unit natural
gradient and, thereby speed up learning. We believe that this property is also the reason for the
success of activation functions like LReLUs and PReLUs and of batch normalization. In contrast to
LReLUs and PReLUs, ELUs have a clear saturation plateau in its negative regime, allowing them
to learn a more robust and stable representation. Experimental results show that ELUs signiﬁcantly
outperform other activation functions on different vision datasets. Further ELU networks perform
signiﬁcantly better than ReLU networks trained with batch normalization. ELU networks achieved
one of the top 10 best reported results on CIFAR-10 and set a new state of the art in CIFAR-100
without the need for multi-view test evaluation or model averaging. Furthermore, ELU networks
produced competitive results on the ImageNet in much fewer epochs than a corresponding ReLU
network. Given their outstanding performance, we expect ELU networks to become a real time saver
in convolutional networks, which are notably time-intensive to train from scratch otherwise.

Acknowledgment. We thank the NVIDIA Corporation for supporting this research with several
Titan X GPUs and Roland Vollgraf and Martin Heusel for helpful discussions and comments on this
work.

REFERENCES

Amari, S.-I. Natural gradient works efﬁciently in learning. Neural Computation, 10(2):251–276, 1998.
Clevert, D.-A., Unterthiner, T., Mayr, A., and Hochreiter, S. Rectiﬁed factor networks. In Cortes, C., Lawrence,
N. D., Lee, D. D., Sugiyama, M., and Garnett, R. (eds.), Advances in Neural Information Processing Systems
28. Curran Associates, Inc., 2015.

Desjardins, G., Simonyan, K., Pascanu, R., and Kavukcuoglu, K. Natural neural networks. CoRR,

abs/1507.00210, 2015. URL http://arxiv.org/abs/1507.00210.

Glorot, X., Bordes, A., and Bengio, Y. Deep sparse rectiﬁer neural networks. In Gordon, G., Dunson, D.,
and Dudk, M. (eds.), JMLR W&CP: Proceedings of the Fourteenth International Conference on Artiﬁcial
Intelligence and Statistics (AISTATS 2011), volume 15, pp. 315–323, 2011.

Goodfellow, I. J., Warde-Farley, D., Mirza, M., Courville, A., and Bengio, Y. Maxout networks. ArXiv e-prints,

Graham, Benjamin. Fractional max-pooling. CoRR, abs/1412.6071, 2014. URL http://arxiv.org/

2013.

abs/1412.6071.

Grosse, R. and Salakhudinov, R. Scaling up natural gradient by sparsely factorizing the inverse Fisher
Journal of Machine Learning Research, 37:2304–2313, 2015. URL http://jmlr.org/
matrix.
proceedings/papers/v37/grosse15.pdf. Proceedings of the 32nd International Conference on
Machine Learning (ICML15).

He, K., Zhang, X., Ren, S., and Sun, J. Delving deep into rectiﬁers: Surpassing human-level performance on

imagenet classiﬁcation. In IEEE International Conference on Computer Vision (ICCV), 2015.

10

Published as a conference paper at ICLR 2016

Hochreiter, S. The vanishing gradient problem during learning recurrent neural nets and problem solutions.

International Journal of Uncertainty, Fuzziness and Knowledge-Based Systems, 6(2):107–116, 1998.

Hochreiter, S. and Schmidhuber, J. Feature extraction through LOCOCODE. Neural Computation, 11(3):

679–714, 1999.

Hochreiter, S., Bengio, Y., Frasconi, P., and Schmidhuber, J. Gradient ﬂow in recurrent nets: the difﬁculty
of learning long-term dependencies. In Kremer and Kolen (eds.), A Field Guide to Dynamical Recurrent
Neural Networks. IEEE Press, 2001.

Ioffe, S. and Szegedy, C. Batch normalization: Accelerating deep network training by reducing internal co-
variate shift. Journal of Machine Learning Research, 37:448–456, 2015. URL http://jmlr.org/
proceedings/papers/v37/ioffe15.pdf. Proceedings of the 32nd International Conference on
Machine Learning (ICML15).

Jia, Yangqing. Learning Semantic Image Representations at a Large Scale. PhD thesis, EECS Department,
University of California, Berkeley, May 2014. URL http://www.eecs.berkeley.edu/Pubs/
TechRpts/2014/EECS-2014-93.html.

Krizhevsky, A., Sutskever, I., and Hinton, G. E. ImageNet classiﬁcation with deep convolutional neural net-
In Pereira, F., Burges, C. J. C., Bottou, L., and Weinberger, K. Q. (eds.), Advances in Neural

works.
Information Processing Systems 25, pp. 1097–1105. Curran Associates, Inc., 2012.

Kurita, T. Iterative weighted least squares algorithms for neural networks classiﬁers. In Proceedings of the Third
Workshop on Algorithmic Learning Theory (ALT92), volume 743 of Lecture Notes in Computer Science, pp.
77–86. Springer, 1993.

LeCun, Y., Kanter, I., and Solla, S. A. Eigenvalues of covariance matrices: Application to neural-network

learning. Physical Review Letters, 66(18):2396–2399, 1991.

LeCun, Y., Bottou, L., Orr, G. B., and M¨uller, K.-R. Efﬁcient backprop.

In Orr, G. B. and M¨uller, K.-R.
(eds.), Neural Networks: Tricks of the Trade, volume 1524 of Lecture Notes in Computer Science, pp. 9–50.
Springer, 1998.

Lee, Chen-Yu, Xie, Saining, Gallagher, Patrick W., Zhang, Zhengyou, and Tu, Zhuowen. Deeply-supervised

nets. In AISTATS, 2015.

LeRoux, N., Manzagol, P.-A., and Bengio, Y. Topmoumoute online natural gradient algorithm. In Platt, J. C.,
Koller, D., Singer, Y., and Roweis, S. T. (eds.), Advances in Neural Information Processing Systems 20
(NIPS), pp. 849–856, 2008.

Lin, Min, Chen, Qiang, and Yan, Shuicheng. Network in network. CoRR, abs/1312.4400, 2013. URL http:

//arxiv.org/abs/1312.4400.

Maas, A. L., Hannun, A. Y., and Ng, A. Y. Rectiﬁer nonlinearities improve neural network acoustic models. In

Proceedings of the 30th International Conference on Machine Learning (ICML13), 2013.

Martens, J. Deep learning via Hessian-free optimization. In F¨urnkranz, J. and Joachims, T. (eds.), Proceedings

of the 27th International Conference on Machine Learning (ICML10), pp. 735–742, 2010.

Mayr, A., Klambauer, G., Unterthiner, T., and Hochreiter, S. DeepTox: Toxicity prediction using deep
learning. Front. Environ. Sci., 3(80), 2015. doi: 10.3389/fenvs.2015.00080. URL http://journal.
frontiersin.org/article/10.3389/fenvs.2015.00080.

Nair, V. and Hinton, G. E. Rectiﬁed linear units improve restricted Boltzmann machines. In F¨urnkranz, J. and
Joachims, T. (eds.), Proceedings of the 27th International Conference on Machine Learning (ICML10), pp.
807–814, 2010.

Olivier, Y. Riemannian metrics for neural networks i: feedforward networks. CoRR, abs/1303.0818, 2013.

URL http://arxiv.org/abs/1303.0818.

Pascanu, R. and Bengio, Y.

In International Con-
ference on Learning Representations 2014, 2014. URL http://arxiv.org/abs/1301.3584.
arXiv:1301.3584.

Revisiting natural gradient for deep networks.

Raiko, T., Valpola, H., and LeCun, Y. Deep learning made easier by linear transformations in perceptrons. In
Lawrence, N. D. and Girolami, M. A. (eds.), Proceedings of the 15th International Conference on Artiﬁcial
Intelligence and Statistics (AISTATS12), volume 22, pp. 924–932, 2012.

Schraudolph, N. N. Centering neural network gradient factor. In Orr, G. B. and M¨uller, K.-R. (eds.), Neural
Networks: Tricks of the Trade, volume 1524 of Lecture Notes in Computer Science, pp. 207–226. Springer,
1998.

Schraudolph, Nicol N. A Fast, Compact Approximation of the Exponential Function. Neural Computation, 11:

853–862, 1999.

Springenberg, Jost Tobias, Dosovitskiy, Alexey, Brox, Thomas, and Riedmiller, Martin A. Striving for simplic-
ity: The all convolutional net. CoRR, abs/1412.6806, 2014. URL http://arxiv.org/abs/1412.
6806.

Srivastava, Rupesh Kumar, Greff, Klaus, and Schmidhuber, J¨urgen. Training very deep networks. CoRR,

abs/1507.06228, 2015. URL http://arxiv.org/abs/1507.06228.

11

Published as a conference paper at ICLR 2016

Unterthiner, T., Mayr, A., Klambauer, G., and Hochreiter, S. Toxicity prediction using deep learning. CoRR,

abs/1503.01445, 2015. URL http://arxiv.org/abs/1503.01445.

Vinyals, O. and Povey, D. Krylov subspace descent for deep learning.

In AISTATS, 2012. URL http:

//arxiv.org/pdf/1111.4259v1. arXiv:1111.4259.

Xu, B., Wang, N., Chen, T., and Li, M. Empirical evaluation of rectiﬁed activations in convolutional network.

CoRR, abs/1505.00853, 2015. URL http://arxiv.org/abs/1505.00853.

Yang, H. H. and Amari, S.-I. Complexity issues in natural gradient descent method for training multilayer

perceptrons. Neural Computation, 10(8), 1998.

A INVERSE OF BLOCK MATRICES

Lemma 1. The positive deﬁnite matrix M is in block format with matrix A, vector b, and scalar c. The inverse
of M is

where

M −1 =

(cid:19)−1

(cid:18) A b
bT
c

=

(cid:19)

(cid:18) K u
uT
s

,

K = A−1 + u s−1uT
u = − s A−1 b

(cid:16)

s =

c − bT A−1b

(cid:17)−1

.

(cid:19)−1

(cid:18) A B
BT C

=

(cid:19)

(cid:18) K U
U T S

,

Proof. For block matrices the inverse is

where the matrices on the right hand side are:

K = A−1 + A−1 B

C − BT A−1B

BT A−1

(cid:16)

(cid:17)−1

U = − A−1 B

C − BT A−1B

(cid:16)

(cid:17)−1

U T = −

C − BT A−1B

BT A−1

(cid:16)

(cid:17)−1

(cid:16)

S =

C − BT A−1B

(cid:17)−1

.

Further if follows that

We now use this formula for B = b being a vector and C = c a scalar. We obtain

K = A−1 + U S−1U T .

(cid:19)−1

(cid:18) A b
bT
c

=

(cid:19)

(cid:18) K u
uT
s

,

where the right hand side matrices, vectors, and the scalar s are:

K = A−1 + A−1 b

c − bT A−1b

bT A−1

(cid:16)

(cid:17)−1

Again it follows that

u = − A−1 b

c − bT A−1b

(cid:16)

(cid:17)−1

uT = −

c − bT A−1b

bT A−1

(cid:16)

(cid:17)−1

(cid:16)

s =

c − bT A−1b

(cid:17)−1

.

K = A−1 + u s−1uT .

12

(16)

(17)

(18)

(19)

(20)

(21)

(22)

(23)

(24)

(25)

(26)

(27)

(28)

(29)

(30)

(31)

Published as a conference paper at ICLR 2016

A reformulation using u gives

K = A−1 + u s−1uT
u = − s A−1 b
uT = − s bT A−1

(cid:16)

s =

c − bT A−1b

(cid:17)−1

.

(32)

(33)

(34)

(35)

(36)

(37)

(38)

(39)

(40)

(41)

(42)

(43)

(44)

B QUADRATIC FORM OF MEAN AND INVERSE SECOND MOMENT

Lemma 2. For a random variable a holds

ET (a) E−1(a aT ) E(a) ≤ 1

and

Furthermore holds

(cid:16)

(cid:16)

1 − ET (a) E−1(a aT ) E(a)

= 1 + ET (a) Var−1(a) E(a) .

(cid:17)−1

1 − ET (a) E−1(a aT ) E(a)

1 − ET

p (a) E−1(a aT ) E(a)

(cid:17)−1 (cid:16)

(cid:17)

= 1 + (E(a) − Ep(a))T Var−1(a) E(a) .

Proof. The Sherman-Morrison Theorem states

A + b cT (cid:17)−1
(cid:16)

= A−1 −

A−1 b cT A−1
1 + cT A−1b

.

Therefore we have

cT (cid:16)

b = cT A−1b −

A + b bT (cid:17)−1
cT A−1b (cid:0)1 + bT A−1b(cid:1) − (cid:0)cT A−1 b(cid:1) (cid:0)bT A−1 b(cid:1)
1 + bT A−1b

cT A−1 b bT A−1b
1 + bT A−1b

=

=

cT A−1b
1 + bT A−1b

.

Using the identity

for the second moment and Eq. (40), we get

E(a aT ) = Var(a) + E(a) ET (a)

ET (a) E−1(a aT ) E(a) = ET (a)

Var(a) + E(a) ET (a)

E(a)

(cid:17)−1

=

ET (a) Var−1(a) E(a)
1 + ET (a) Var−1(a) E(a)

≤ 1 .

The last inequality follows from the fact that Var(a) is positive deﬁnite. From last equation, we obtain further

(cid:16)

1 − ET (a)E−1(a aT ) E(a)

= 1 + ET (a)Var−1(a) E(a) .

(cid:17)−1

For the mixed quadratic form we get from Eq. (40)

ET

p (a) E−1(a aT ) E(a) = ET

p (a)

Var(a) + E(a) ET (a)

(cid:17)−1

E(a)

=

ET

p (a) Var−1(a) E(a)
1 + ET (a) Var−1(a) E(a)

.

(cid:16)

(cid:16)

13

Published as a conference paper at ICLR 2016

From this equation follows

1 − ET

p (a) E−1(a aT ) E(a) = 1 −

ET

p (a) Var−1(a) E(a)
1 + ET (a) Var−1(a) E(a)

(45)

1 + ET (a) Var−1(a) E(a) − ET

p (a) Var−1(a) E(a)

=

1 + ET (a) Var−1(a) E(a)

=

1 + (E(a) − Ep(a))T Var−1(a) E(a)
1 + ET (a) Var−1(a) E(a)

.

Therefore we get

(cid:16)

(cid:17)−1 (cid:16)

1 − ET (a) E−1(a aT ) E(a)

1 − ET

p (a) E−1(a aT ) E(a)

(46)

(cid:17)

= 1 + (E(a) − Ep(a))T Var−1(a) E(a) .

C VARIANCE OF MEAN ACTIVATIONS IN ELU AND RELU NETWORKS

To compare the variance of median activation in ReLU and ELU networks, we trained a neural network with 5
hidden layers of 256 hidden units for 200 epochs using a learning rate of 0.01, once using ReLU and once using
ELU activation functions on the MNIST dataset. After each epoch, we calculated the median activation of each
hidden unit on the whole training set. We then calculated the variance of these changes, which is depicted in
Figure 7 . The median varies much more in ReLU networks. This indicates that ReLU networks continuously
try to correct the bias shift introduced by previous weight updates while this effect is much less prominent in
ELU networks.

Figure 7: Distribution of variances of the median hidden unit activation after each epoch of MNIST
training. Each row represents the units in a different layer of the network.

14

