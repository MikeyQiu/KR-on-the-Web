7
1
0
2
 
p
e
S
 
8
1
 
 
]

V
C
.
s
c
[
 
 
1
v
3
5
0
6
0
.
9
0
7
1
:
v
i
X
r
a

To be submitted as a conference paper at ICLR 2018

COUPLED ENSEMBLES OF NEURAL NETWORKS

Anuvabh Dutt
Univ. Grenoble Alpes, CNRS, Grenoble-INP, LIG, F-38000 Grenoble France
Anuvabh.Dutt@univ-grenoble-alpes.fr

Denis Pellerin
Univ. Grenoble Alpes, CNRS, Grenoble-INP, GIPSA-Lab, F-38000 Grenoble France
Denis.Pellerin@gipsa-lab.grenoble-inp.fr

Georges Qu´enot
Univ. Grenoble Alpes, CNRS, Grenoble-INP, LIG, F-38000 Grenoble France
Georges.Quenot@imag.fr

ABSTRACT

We investigate in this paper the architecture of deep convolutional networks.
Building on existing state of the art models, we propose a reconﬁguration of the
model parameters into several parallel branches at the global network level, with
each branch being a standalone CNN. We show that this arrangement is an efﬁcient
way to signiﬁcantly reduce the number of parameters without losing performance
or to signiﬁcantly improve the performance with the same level of performance.
The use of branches brings an additional form of regularization. In addition to
the split into parallel branches, we propose a tighter coupling of these branches
by placing the “fuse (averaging) layer” before the Log-Likelihood and SoftMax
layers during training. This gives another signiﬁcant performance improvement,
the tighter coupling favouring the learning of better representations, even at the
level of the individual branches. We refer to this branched architecture as “cou-
pled ensembles”. The approach is very generic and can be applied with almost
any DCNN architecture. With coupled ensembles of DenseNet-BC and parameter
budget of 25M, we obtain error rates of 2.92%, 15.68% and 1.50% respectively
on CIFAR-10, CIFAR-100 and SVHN tasks. For the same budget, DenseNet-BC
has error rate of 3.46%, 17.18%, and 1.8% respectively. With ensembles of cou-
pled ensembles, of DenseNet-BC networks, with 50M total parameters, we obtain
error rates of 2.72%, 15.13% and 1.42% respectively on these tasks.

1

INTRODUCTION

The design of early convolutional architectures (CNN) involved choices of hyper-parameters such
as: ﬁlter size, number of ﬁlters at each layer, and padding (Lecun et al., 1998; Krizhevsky et al.,
2012). Since the introduction of the VGGNet (Simonyan and Zisserman, 2014) the design has
moved towards following a template: ﬁxed ﬁlter size of 3 × 3 and N features maps, down-sample to
half the input resolution only by the use of either maxpool or strided convolutions (Springenberg
et al., 2015), and double the number the computed feature maps following each down-sampling
operation. This philosophy is used by state of the art models such as ResNet (He et al., 2016b) and
DenseNet (Huang et al., 2017). The last two architectures extended the template to include the use
of “skip-connections” between non-contiguous layers.

Our work extends this template by adding another element, which we refer to as “coupled en-
sembling”.
In this set-up, the network is decomposed into several branches, each branch being
functionally similar to a complete CNN (and able to fully do the classiﬁcation task alone, gen-
erally with a lower performance). The proposed template achieves performance comparable to
state of the art models with a signiﬁcantly lower parameter count. The proposed modiﬁcation

1

To be submitted as a conference paper at ICLR 2018

is simple to implement and we provide a wrapper to compose different standard architectures at:
https://github.com/vabh/coupled_ensembles.

In this paper, we make the following contributions: (i) we show that given a parameter budjet,
splitting a large network into an ensemble of smaller parallel branches of the same type, and jointly
training them performs better or at par; (ii) when a ﬁnal SoftMax (SM) layer is used during the
prediction step, we show that ensemble fusion works better when averaging is done before this
layer than when it is done after; (iii) when a ﬁnal Log-Likelihood (LL) layer is used during the
training step, we show that ensemble fusion of branches works better when the fusion is done before
this layer than when it is done after; (iv) combining all these elements, we signiﬁcantly improved
the performance and/or signiﬁcantly reduce the parameter count of state-of-the-art neural network
architectures on CIFAR and SVHN data sets. (v) We show that such multi-branch networks can be
further ensembled at a higher level still producing a signiﬁcant performance gain.

This paper is organised as follows: in section 2, we discuss related work; in section 3, we introduce
the concept of coupled ensembles and the motivation behind the idea; in section 4, we present the
evaluation of the proposed approach and compare it with the state of the art; and we conclude and
discuss future work in section 5.

2 RELATED WORK

Multi-column architectures. The network architecture that we propose has strong similarities
with Cires¸an’s Neural Networks Committees (Cires¸an et al., 2011) and Multi-Column Deep Neural
Network (MCDNN) (Cires¸an et al., 2012), which are a type of ensemble of networks where the
“committee members” or “DNN columns” correspond to our basic block instances (or branches).
However, our coupled ensemble networks differ as following: (i) we train a single model which is
composed of sub-networks, while they train each member or column separately. (ii) we consider a
coupled ensemble of smaller networks for improving the performance of a network, given a budget
of parameters for the entire model. This is contrary to improving it by utilising multiple models of
ﬁxed size and therefore multiplying the overall size (though both are not exclusive); (iii) we consider
placing the averaging (AVG) layer, not only completely at the end of the network but also before
the Log-Likelihood (LL) layer during training and before the Soft-Max (SM) layer during training
and/or during prediction; (iv) we used the same preprocessing for all branches while they consid-
ered different preprocessing (data augmentation) blocks for different members or different subsets
of columns; we consider doing this also in the future.

Multi-branch architectures. Multi-branch architectures have been very successful in several vision
applications (He et al., 2016a; Szegedy et al., 2015). Recently, modiﬁcations have been proposed
(Xie et al., 2017; Chollet, 2017) for these architectures using the concept of “grouped convolutions”,
in order to factorize spatial feature extraction and channel features. These modiﬁcations additionally
advocate the use of template building blocks stacked together to form the complete model. This
modiﬁcation is at the level of the building blocks of their corresponding base architectures: ResNet
and Inception respectively. In contrast we propose a generic modiﬁcation of the structure of the
CNN at the global model level. This includes a template in which the speciﬁc architecture of a
“basic block” is speciﬁed, and then this “basic block” is replicated as parallel branches to form the
ﬁnal composite model.

To further improve the performance of such architectures, Shake-Shake regularization (Gastaldi,
2017) proposes a stochastic mixture of each of the branches and has achieved good results on the
CIFAR datasets. However, the number of epochs required for convergence is much higher compared
to the base model. Additionally, the technique seems to depend on the batch size. In contrast, we
apply our method using the exact same hyper-parameters as used in the underlying CNN.

Zhao et al. (2016) investigate the usage of parallel paths in a ResNet, connecting layers to allow
information exchange between the paths. However this requires modiﬁcation at a local level of each
of the residual blocks. In contrast, our method is a generic rearrangement of a given architecture’s
parameters, which does not introduce additional choices. Additionally, we empirically conﬁrm that
our proposed conﬁguration leads to an efﬁcient usage of parameters.

Neural network ensembles. Ensembling is a reliable technique to increase the performance of
models for a task. Due to the presence of several local minima, multiple trainings of the exact

2

To be submitted as a conference paper at ICLR 2018

same neural network architecture can reach a different distribution of errors on a per-class basis.
Hence, combining their outputs lead to improved performance on the overall task. This was observed
very early (Hansen and Salamon, 1990) and is now commonly used for obtaining top results in
classiﬁcation challenges, despite the increase in training and prediction cost. Our proposed model
architecture is not an ensemble of independent networks given that we have a single model made
up of parallel branches that is trained. This is similar in spirit to the residual block in ResNet
and ResNeXt, and to the inception module in Inception but is done at the full network level. We
would like to emphasize here that “arranging” a given budget of parameters into parallel branches
leads to an increase in performance (as shown in tables 1, 2 and 3). Additionally, the classical
ensembling approach can still be applied for the fusion of independently trained coupled ensemble
networks where it produces a signiﬁcant performance improvement (as shown in table 4)

3 COUPLED ENSEMBLES

TERMINOLOGY

For the following discussion, we deﬁne some terms:

• Branch: the proposed model comprises several branches. Each branch takes as input a data point
and produces a score vector corresponding to the target classes. Current design of CNNs are
referred to as single-branch. The number of branches is denoted by e.

• Basic block: the model architecture used to form a branch. In our experiments, we use DenseNet-

BC and ResNet with pre-activation as basic blocks.

• Fuse Layer:

the operation used to combine each of the parallel branches which make up our
model. In our experiments, each of the branches are combined by taking the average of each of
their predicted log probabilities over the target classes. Section 4.4 explores different choices of
operations for the fuse layer.

We consider a classiﬁcation task in which individual samples are always associated to exactly
one class, labelled from a ﬁnite set. This is the case for CIFAR (Krizhevsky and Hinton, 2009),
SVHN (Netzer et al., 2011) and ILSVRC (Russakovsky et al., 2015) tasks. In theory, this should
work for other tasks as well (for example, segmentation, object detection, etc.).

We consider neural network models whose last layer outputs a score vector of the same dimension
as the number of target classes. This is usually implemented as a linear layer and referred to as
a fully connected (FC) layer. This layer can be followed by a SoftMax (SM) layer to produce a
probability distribution over the target classes. During training, this is followed by a loss layer, for
example, negative log-likelihood (LL). This is the case for all recent network architectures for image
classiﬁcation1 (Krizhevsky et al., 2012; Simonyan and Zisserman, 2014; Szegedy et al., 2015; He
et al., 2016a; Xie et al., 2017; Huang et al., 2016; Zagoruyko and Komodakis, 2016; Huang et al.,
2017). The differences among them is related to what is present before the last FC layer. We are
agnostic to this internal setup (however complex it may or may not be) because the resulting “basic
block” always takes an image as input and produces a vector of N values (one for each target class)
as output, parametrized by a tensor W .

In the case of ensemble predictions, fusion is usually done by computing the individual predic-
tions separately for e model instances and then averaging them. Each of the instances are trained
seperately. This is functionally equivalent to predicting with a “super-network” including the e in-
stances as parallel branches with a ﬁnal averaging (AVG) layer on top. Such super-networks are
generally not implemented because the branch instances often already correspond to the maximum
memory capacity of GPUs. The remaining AVG layer operation can be implemented separately.
Alternatively, it is possible to place the averaging layer just after the last FC layer of the basic block
instances and before the SM layer, which is then “factorized”.

1Though all these networks actually do have a FC layer before the SM one, the last layer need not be a linear
layer, as long as it produces one value for each target label. We will refer to the output of each basic block as
“FC”. Similarly, the proposed method may be easily adapted to multi-label classiﬁcation (i.e. considering non-
exclusive classes) by simply replacing the SM (and possibly also the LL) layer(s) by any variant(s) appropriate
for multi-label classiﬁcation. Again, we will refer to their output as “SM” and “LL”.

3

To be submitted as a conference paper at ICLR 2018

In our setup, a model is composed of parallel branches and each branch produces a score vector for
the target categories. We explore three options to combine these vectors during training:

• Activation (FC) average.

• Probability (SM) average (in practice we do an arithmetic average of log-probabilities).

• Log Likelihood (LL) average (average of the loss of each branch).

We investigate these options in section 4.4. Note that for inference, averaging the FC layer activa-
tions is equivalent to averaging the LogSoftMax values (or to a geometric average of the softmax
values, see section B of supplementary material).

This transformation of having multiple branches, and combining the branch activations by averaging
the log probabilites that they predict for the target categories, leads to a performance improvement,
with a lower parameter count, in all our experiments (see section 4). The parameter vector W of this
composite branched model is the concatenation of the parameter vectors We of the e basic blocks
with 1 ≤ i ≤ e. All parameters are in the “basic blocks” as the “fuse layer” does not contain any
parameters. The e model instances do not really need to share the same architecture.

Three training versions may be considered depending upon whether the “fuse layer” is placed after
the FC, after the SM or after the LL layer. All the instances are trained simultaneously trough a
single loss function and the W parameter vector is obtained in a single training phase. In practice,
in the ﬁrst and the third versions, the SM and LL layers are replaced by a single Cross-Entropy
(CE) layer as this is numerically more stable. Similarly, in the second and intermediate case, a
LogSoftMax (LSM) layer is used instead of the regular SM layer before the arithmetic averaging
(while removing the Log operation in the LL layer). This is equivalent to replacing the arithmetic
average by a geometric one with the regular SM and LL layers. The training can be done in four
different ways: the three coupled ways correspoding to the “fuse layer” plus the the one in which
all basic blocks are trained separately in e independent trainings. Regardless of how the training of
the basic blocks has been performed, it is possible to use any of the two coupled ways for making
‘coupled prediction’ and it is also possible to use the individual basic blocks for making e ‘individual
predictions’. Not all of these combinations are expected to be consistent or equally efﬁcient but all
can be implemented and evaluated as shown in section 4.4.

4 EXPERIMENTS

4.1 DATASETS

We evaluate our proposed architecture on the CIFAR (Krizhevsky and Hinton, 2009) and SVHN
(Netzer et al., 2011) data sets. CIFAR-10 and CIFAR-100 consist each of 50,000 training images
and 10,000 test images, distributed into 10 and 100 categories respectively. SVHN consists of
73,257 training images, 531,131 “easy” training images (we use both for training) and 26,032 testing
images, distributed into 10 categories. Each image from these datasets is of size 32×32 pixels.

4.2 EXPERIMENTAL SET-UP

All hyper parameters are set according to the original descriptions of the “basic block” that is used.
This may not be the optimal setting in our case (especially the learning rate decay schedule) but we
do not alter them, so as to not introduce any bias in comparisons.

For CIFAR-10, CIFAR-100 and SVHN, the input image is normalised by subtracting by the mean
image and dividing by the standard deviation. During training on CIFAR datasets, standard data
augmentation is used, which comprises random horizontal ﬂips and random crops. For SVHN, no
data augmentation is used. However, a dropout ratio of 0.2 is applied in the case of DenseNet when
training on SVHN. Testing is done after normalising the input in the same way as during training.

All error rates are given in percentages and correspond to an average computed on the last 10 epochs
for CIFAR and on the last 4 epochs for SVHN. This measure is more conservative than the one used
by the DenseNet authors (see supplementary material, section D). For DenseNet-BC, Amos and
Kolter (2017)’s PyTorch implementation has been used. All execution times were measured using a

4

To be submitted as a conference paper at ICLR 2018

single NVIDIA 1080Ti GPU with the optimal micro-batch2. Experiments in section 4.3, 4.4 are done
on the CIFAR-100 data set with the “basic block” being DenseNet-BC, depth L = 100, growth rate
k = 12. For experiments in Section 4.5, we consider this same conﬁguration (with a single branch)
as our baseline reference point.

4.3 COMPARISON WITH SINGLE BRANCH AND INDEPENDENT ENSEMBLES

A natural point of comparison of the proposed branched architecture is with an ensemble of indepen-
dent models. Rows 2 (coupled training with SM averaging) and 4 (no averaging) in Table 1 present
the results of these two cases respectively. Row 4 shows the error rate obtained from averaging the
predictions of 4 identical models, each of which were trained separately. We see that even though
the total number of trainable parameters involved is exactly the same, a jointly trained branched
conﬁguration gives a much lower test error (17.61 vs. 18.42 with 4 predictions fused at the FC level
in both cases).

The next point of comparison is with a single branch model comprising a similar number of pa-
rameters as the multi branch conﬁguration. The choice of single branch models has been done by:
increasing k while keeping L constant, by increasing both k and L, or by increasing L while keep-
ing k constant. The last three rows of Table 1 show that the error from the multi branch model is
considerably lower, as compared to a single branch model (17.61 vs. 20.01, with 4 predictions fused
at the FC level).

These observations show that the arranging a given budget of parameters into parallel branches is
efﬁcient in terms of parameters, as compared to having a large single branch or multiple independent
trainings. In Section 4.5 we analyse the relation between the number of branches and the model
performance.

4.4 CHOICE OF FUSE LAYER OPERATION

In this section, we compare the performance of our proposed branched model for different choices
for the positioning of the “fuse layer” (see section 3). Experiments are carried out to evaluate the best
training and prediction fusion combinations. We consider two branched models with e = 2, e = 4,
trained in the following conditions: training with fusion after the LL layer, after the SM layer, or
after the FC layer.

Table 1 shows the performance of the differently trained systems for different prediction conﬁgu-
rations: individual average performance of the trained instances (without fusion) and performance
of the ensemble system with fusion after the SM layer or after the FC layer. Note that this ta-
ble includes models with parameters obtained using different training methods . We can make the
following observations:

• The Avg. FC training with separate predictions (in red) does not work well. This is expected since
a similar FC average may be reached with quite unrelated FC instances. The Avg. FC training
with Avg. SM prediction (in red) works a bit better but is still not good because the non-linearity
of the SM layer distorts the FC average. Indeed, the consistent Avg. FC training with Avg. FC
prediction works quite well though it does not yield the best performance.

• The Avg. FC prediction works at least as well and often signiﬁcantly better than the Avg. SM
prediction whatever the training choice is. This can be explained by the fact that the SM layer
compresses values for probabilities close to 0 and 1 while the values remain more spread and
transmit more information at the FC layer, even for different training conditions.

• The average error rate of each of the “basic blocks” trained jointly in coupled ensembles with SM
fusion is signiﬁcantly lower than the error rate of the individual instances trained separately. This
indicates that the coupling not only forces them to learn complementary features as a group but
also to better learn individually. Averaging the log probabilities forces the network to continuously
update all branches so as to be consistent with each other. This provides a stronger gradient
signal. Additionally, the training loss remains higher compared to single branch models, serving
as a regularizer. The error gradient that is back-propagated from the fuse layer is the same for all

2The micro-bath denotes the number of images samples that were processed in one batch on the GPU so as

to have the best throughput. In practice, minibatch (for parameter update) = n×microbatch

5

To be submitted as a conference paper at ICLR 2018

Table 1: Coupled Ensembles of DenseNet-BCs versus a single model of comparable complexity and
study of training / prediction fusion combinations. Top: e = 2, bottom: e = 4. Performance is given
as the top-1 error rate (mean±standard deviation for the individual branches) on the CIFAR-100
data set with standard data augmentation. Columns “L” and “k” indicate the DenseNet-BC hyper-
parameter values of the “basic block”. Column “e” indicates the number of branches. Column
“Avg.” indicates the type of “fuse layer” during training: “none” for separate trainings (classical
ensembling), “FC”, “SM” and “LL” for fusion (arithmetic averaging) after the FC, SM and LL lay-
ers respectively (not applicable for e = 1). Column “Individual” gives the performance for the
individual “basic blocks” evaluated separately; Columns “FC” and “SM” give the performance with
fusion (arithmetic averaging) during prediction done after the FC and SM layers respectively. The
last three columns give the total number of parameters of the model, the duration of a training itera-
tion (50,000 images) and the prediction time per test image (in batch mode). (*) See supplementary
material, section D; The average and standard deviations are computed here for the independent
trainings (comprising 2 and 4 models respectively.).

L
100
100
100
100
100
124
148

L
100
100
100
100
100
154
220

k
12
12
12
12
17
14
12

k
12
12
12
12
25
17
12

e Avg.
FC
2
SM
2
LL
2
none
2
n/a
1
n/a
1
n/a
1

e Avg.
FC
4
SM
4
LL
4
none
4
n/a
1
n/a
1
n/a
1

Individual
52.68±22.95
22.17±0.32
22.78±0.08
23.13±0.15(*)
21.22±0.12
21.75±0.10
20.80±0.06

Individual
74.36±26.28
22.29±0.11
22.83±0.18
23.13±0.09(*)
20.61±0.01
20.02±0.10
20.01±0.12

FC
22.25
19.06
19.33
20.44
n/a
n/a
n/a

FC
22.55
17.61
18.21
18.42
n/a
n/a
n/a

SM Params Epoch(s) Test(ms)
28.78
19.43
19.91
20.44
n/a
n/a
n/a

1.60M
1.60M
1.60M
1.60M
1.57M
1.55M
1.56M

0.98
0.98
0.98
0.98
0.67
0.77
0.90

174
174
174
171
121
135
159

SM Params Epoch(s) Test(ms)
31.92
17.68
18.92
18.85
n/a
n/a
n/a

3.20M
3.20M
3.20M
3.20M
3.34M
3.29M
3.15M

2.00
2.00
2.00
2.00
0.8
1.3
1.5

402
402
402
341
164
245
326

branches, and this gradient depends on the combined predictions. This means that at every step
all branches act complementary to the other branches’ weight updates.

• All ensemble combinations except those based on the Avg. FC training do signiﬁcantly better
than a single network of comparable size and same depth. For a global network size of about
1.6M (resp. 3.2M) parameters, the error rate decreases from 20.80 (resp. 20.01) for the best
single instance combination to 19.06 (−1.74) with two instances (resp. 17.61 (−2.40) with four
instances).

• The best combination seems to be Avg. SM for training with Avg. FC for prediction.
• The branched model with e = 4 and Avg. SM for the “fuse layer” has the same performance as
a DenseNet-BC (L = 250, k = 24) model (Huang et al., 2017), which has about 5 times more
parameters (15.3M versus 3.2M).

All the following experiments have Avg. SM for the training “fuse layer’ in the branched models.

4.5 CHOICE OF THE NUMBER OF BRANCHES

In this section, we investigate the optimal number of branches e for a given model parameter budget.
We evaluate on CIFAR-100, with DenseNet-BC as the “basic block”, and parameter budget equal
to 0.8M parameters (this is the number of parameters in DenseNet-BC (L = 100, k = 12)). In-
deed, the optimal number of instances e is likely to depend upon the network architecture, upon the
parameter budget and upon the data set but this gives at least one reference. This was investigated
again with larger models, and the results are in table 3 (last four rows).

6

To be submitted as a conference paper at ICLR 2018

Table 2: Different number of branches, e for a ﬁxed parameter count. The models are trained on
CIFAR-100 with standard data augmentation. See table 1 caption for the meaning of row and column
labels. When applicable (e > 1), “fuse layer” is SM Avg. (*) Average and standard deviation on 10
trials with different seeds; Huang et al. (2017) reports 22.27, see supplementary material, section D.

L
100
76
88
94
100
70
82
88
94
64
70
58
64
58
64

k
12
10
9
8
8
9
8
7
7
8
8
7
7
6
6

e
1
2
2
2
2
3
3
3
3
4
4
6
6
8
8

Individual
22.87±0.17(*)
25.58±0.20
25.15±0.31
25.72±0.20
25.42±0.20
26.67±0.40
26.47±0.17
26.92±0.41
26.50±0.12
28.58±0.59
27.65±0.48
30.11±0.53
30.65±0.62
32.15±0.00
31.52±0.38

FC
n/a
21.66
21.87
21.95
21.87
21.10
21.25
22.09
21.95
22.44
21.50
23.87
23.08
25.95
24.42

SM Params Epoch(s) Test(ms)
n/a
22.17
22.19
22.22
22.07
21.24
21.46
22.49
22.35
22.58
22.12
24.22
23.36
25.70
24.69

800k
720k
747k
666k
737k
773k
800k
698k
775k
719k
828k
718k
840k
722k
843k

0.51
0.63
0.71
0.69
0.75
0.77
0.85
0.92
0.98
0.88
0.94
1.08
1.20
1.35
1.51

86
103
119
115
126
129
141
148
160
142
156
179
198
219
250

Table 2 shows the performance for different conﬁgurations of branches e, depth L, and growth rate
k. One difﬁculty is that DenseNet-BC parameter counts are strongly quantiﬁed according to the L
and k values (L has to be a multiple of 6 modulo 4) and, additionally, to the e value in the coupled
ensemble version. This is even more critical in moderate size models like the 800K one targeted
here. We selected model conﬁgurations with parameters just below the target for making a fair
comparison. A few models have slightly more parameters so that some interpolation can be done
for possibly more accurate comparisons. We can make the following observations:

• In the considered case (DenseNet-BC, CIFAR-100 and 800K parameters), the optimal number of
branches is e = 3, L = 70, k = 9. With these parameters, the error rates decreases from 22.87
for the regular (L = 100, k = 12) DenseNet-BC model to 21.10 (−1.77).

• Using 2 to 4 branches yields a signiﬁcant performance gain over the classical (single branch,
e = 1) case, and even over the original performance of 22.27 reported for the (L = 100, k = 12)
DenseNet-BC (see supplementary material, section D).
• Using 6 or 8 branches performs signiﬁcantly less well.
• Slightly varying the L, k and e hyper-parameters around their optimal value does not lead to a
signiﬁcant performance drop, showing that the coupled ensemble approach and the DenseNet-BC
architecture are quite robust relatively to these choices.

• The gain in performance comes at the expense of an increased training and prediction times even
though the model size does not change. This is due to the use of smaller values of k that prevents
good parallelism efﬁciency. This increase is relatively smaller with bigger networks.

The same experiment was done on a validation set with a 40k/10k random split of the CIFAR-
100 training set and we could draw the same conclusions from there; they led to predict that the
(L = 82, k = 8, e = 3) combination should be the best one on the test set. The (L = 70, k = 9, e =
3) combination appears to be slightly better here but the difference is probably not statistically
signiﬁcant.

4.6 COMPARISON WITH THE STATE OF THE ART

We have evaluated the coupled ensemble network approach with networks of various sizes. We used
again Huang et al. (2017)’s DenseNet-BC architecture as the “basic block” since this was the current
state of the art or very close to it at the time we started these experiments. We used Amos and Kolter
(2017)’s PyTorch DenseNet-BC implementation both for the multi-branch (coupled ensembles) and

7

To be submitted as a conference paper at ICLR 2018

single-branch (classical) experiments. We also evaluated the approach using He et al. (2016b)’s
ResNet with pre-activation as the basic block to check if the coupled ensemble approach works well
with other architectures.

Table 3 reports in the upper part the results obtained by the current best systems (see section 2 for
references) and the results obtained with our coupled ensembles approach in the lower part. All
results presented in this table correspond to the training of a single, possibly big, network. Even
if ensembles are considered, they are always coupled as described in section 3 and trained as a
single global network. A further level of ensembling involving multiple trainings is considered in
section 4.7. Results are presented on the CIFAR 10 and 100 data set with standard data augmentation
and on SVHN using the extra training data.

Table 3: Classiﬁcation error comparison with the state of the art, for a single model.

SVHN #Params

System
ResNet L = 110 k = 64
ResNet stochastic depth L = 110 k = 64
ResNet stochastic depth L = 1202 k = 64
ResNet pre-activation L = 164 k = 64
ResNet pre-activation L = 1001 k = 64
DenseNet L = 100 k = 24
DenseNet-BC L = 100 k = 12 (Torch)
DenseNet-BC L = 250 k = 24 (Torch)
DenseNet-BC L = 190 k = 40 (Torch)
Shake-Shake C10 Model S-S-I
Shake-Shake C100 Model S-E-I
Snapshot Ensemble DenseNet-40 (α0 = 0.1)
Snapshot Ensemble DenseNet-40 (α0 = 0.2)
Snapshot Ensemble DenseNet-100 (α0 = 0.2)
SGDR WRN-28-10 Loshchilov and Hutter (2017)
SGDR WRN-28-10 3 snapshots
ResNeXt-29, 8×64d Xie et al. (2017)
ResNeXt-29, 16×64d Xie et al. (2017)
DFN-MR2 Zhao et al. (2016)
DFN-MR3 Zhao et al. (2016)
IGC-L450M2 Zhang et al. (2017)
IGC-L32M26 Zhang et al. (2017)
ResNet pre-activation L = 65 k = 64 e = 2
ResNet pre-activation L = 164 k = 64 e = 2
ResNet pre-activation L = 164 k = 64 e = 4
DenseNet-BC L = 100 k = 12 e = 1
DenseNet-BC L = 112 k = 16 e = 1
DenseNet-BC L = 130 k = 20 e = 1
DenseNet-BC L = 160 k = 24 e = 1
DenseNet-BC L = 166 k = 32 e = 1
DenseNet-BC L = 190 k = 40 e = 1
DenseNet-BC L = 82 k = 8 e = 3
DenseNet-BC L = 82 k = 10 e = 4
DenseNet-BC L = 88 k = 14 e = 4
DenseNet-BC L = 88 k = 20 e = 4
DenseNet-BC L = 94 k = 26 e = 4
DenseNet-BC L = 118 k = 35 e = 3
DenseNet-BC L = 106 k = 33 e = 4
DenseNet-BC L = 76 k = 33 e = 6
DenseNet-BC L = 64 k = 35 e = 8

C10+ C100+
6.61
5.25
4.91
5.46
4.92
3.74
4.51
3.62
3.46
2.86
-
4.99
4.84
3.44
4.03
3.51
3.65
3.58
3.94
3.57
3.25
3.31
5.26
4.24
3.96
4.77
4.47
4.06
3.98
4.03
4.04
4.30
3.78
3.57
3.18
3.01
2.99
2.99
2.92
3.13

-
24.98
-
24.33
22.71
19.25
22.27
17.60
17.18
-
15.85
23.34
21.93
17.41
19.57
17.75
17.77
17.31
19.25
19.00
19.25
18.75
23.24
19.92
18.84
22.87
20.73
19.03
18.92
20.03
18.19
21.25
19.92
17.68
16.79
16.24
16.18
15.68
15.76
15.95

-
-
-
-
-
1.59
1.76
-
-
-
-
1.64
1.73
-
-
-
-
-
1.51
1.55
-
1.56
-
-
-
1.79
1.83
1.84
1.88
1.88
1.79
1.66
1.62
1.55
1.57
1.50
1.50
1.53
1.50
1.50

1.7M
1.7M
10.2M
1.7M
10.2M
27.2M
0.80M
15.3M
25.6M
26.2M
34.4M
6.0M
6.0M
163M
36.5M
110M
34.4M
68.1M
14.9M
24.8M
19.3M
24.1M
1.4M
3.4M
6.8M
0.8M
1.7M
3.4M
6.9M
13.0M
25.8M
0.8M
1.6M
3.5M
7.0M
13.0M
25.7M
25.1M
24.6M
24.9M

8

To be submitted as a conference paper at ICLR 2018

For the ResNet pre-act architecture, the ensemble versions with 2 or 4 branches leads to a sig-
niﬁcantly better performance than single branch versions with comparable or higher number of
parameters.

Regarding the DenseNet-BC architecture, we considered 6 different network sizes, roughly follow-
ing multiples of powers of 2 and ranging from 0.8M up to 25.6M parameters, with two extremes
corresponding to those for which the error rates were available Huang et al. (2017). We chose these
values for the depth L and growth rate k for these points and interpolated between them according
to a log scale as much as possible. Our experiments showed that the trade-off between L and k is
not critical for a given overall parameter count. This was also the case for choosing between the
number of branches e, depth L and growth rate, k for a given overall parameter count budget as long
as e ≥ 3 (or even e ≥ 2 for small networks). For the 6 conﬁgurations, we experimented with both
the single-branch (classical) and multi-branch versions of the model, with e = 4. Additionally, for
the largest model, we tried e = 3, 6, 8 branches.

For the single branch version with extreme network sizes, we obtained error rates signiﬁcantly lower
than those reported by Huang et al. (2017). From what we have checked, the Lua Torch implemen-
tation they used and the PyTorch one we used are equivalent. The difference may be due to the fact
that we used a more conservative measure of the error rate (on the last iterations) and from statistical
differences due to different initializations and/or to non-deterministic computations (see section D
in supplementary material). Still, the coupled ensemble version leads to a signiﬁcantly better per-
formance for all network sizes, even when compared to DenseNet-BC’s reported performance.

Our larger models of coupled DenseNet-BCs (error rates of 2.92% on CIFAR 10, 15.68% on CIFAR
100 and 1.50% on SVHN) perform better than or are on par with all current state of the art imple-
mentations that we are aware of at the time of publication of this work. Only the Shake-Shake S-S-I
model (Gastaldi, 2017) performs slightly better on CIFAR 10.

We also compare the performance of coupled ensembles with model architectures that were ‘learnt’
in a meta learning scenario. The results are presented in the supplementary material, section C.

4.7 ENSEMBLES OF COUPLED ENSEMBLES

The coupled ensemble approach is limited by the size of the network that can ﬁt into GPU memory
during the training and the time that such training takes. With the hardware we have access to, it
was not possible to go much beyond the 25M-parameter scale. For going further, we resorted to the
classical ensembling approach based on independent trainings. An interesting question was whether
we could still signiﬁcantly improve the performance since the classical approach generally plateaus
after quite a small number of models and the coupled ensemble approach already include several.
For instance the SGDR with snapshots approach (Loshchilov and Hutter, 2017) has a signiﬁcant im-
provement from 1 to 3 models but not much improvement from 3 to 16 models (see tables 3 and 4).
As doing multiple times the same training is quite costly when models are large, we instead ensem-
bled the four large coupled ensemble models that we trained for the four values of e = 3, 4, 6, 8.
Results are shown in table 4. We obtained a signiﬁcant gain by fusing two models and a quite small
one from any further fusion of three or four of them. To the best of our knowledge, these ensem-
bles of coupled ensemble networks outperform all state of the art implementations including other
ensemble-based ones at the time of publication of this work.

Table 4: Classiﬁcation error comparison with the state of the art, multiple model trainings.
System
SVHN #Params
SGDR WRN-28-10 3 runs × 3 snapshots
SGDR WRN-28-10 16 runs × 3 snapshots
DenseNet-BC ensemble of ensembles e = 6, 4
DenseNet-BC ensemble of ensembles e = 6, 4, 3
DenseNet-BC ensemble of ensembles e = 8, 6, 4, 3

C10+ C100+
16.64
3.25
16.21
3.14
15.13
2.72
15.04
2.68
15.05
2.73

329M
1752M
50M
75M
100M

-
-
1.42
1.42
1.41

9

To be submitted as a conference paper at ICLR 2018

4.8 PARAMETER USAGE

Figure 1 shows that for a given parameter count, coupled ensemble networks or ensembles of cou-
pled ensemble networks perform signiﬁcantly better for all parameter budgets. Our approach is
shown by the blue diamonds.

Figure 1: Comparison of parameter usage between different methods. Results on CIFAR-10 (top),
CIFAR-100 (middle) and SVHN (bottom) tasks. “DenseNet-BC”: single-branch (PyTorch) conﬁg-
uration; “Ours”: proposed multiple branch conﬁguration using DenseNet-BC as the basic block,
single training up to 25M parameters and ensembles of coupled ensembles beyond; SGDR-WRN:
snapshot ensembles with SGDR on Wide ResNets up to 110M parameters and ensembles of snap-
shot ensembles beyond; ”Other”: all other architectures mentioned in tables 3 and 4.

10

To be submitted as a conference paper at ICLR 2018

5 DISCUSSION

The proposed approach consists in replacing a single deep convolutional network by a number of
“basic blocks” which resemble standalone CNN models. The intermediate score vectors produced
by each of the basics blocks are coupled via a “fuse layer”. At training time, this is done by taking
an arithmetic average of their log-probabilites for the targets. At test time the score vectors are
averaged following the output from each score vector. Both of these aspects leads to a signiﬁcant
performance improvement over a single branch conﬁguration. This improvement comes at the cost
of a small increase in the training and prediction times. The proposed approach leads to the best
performance for a given parameter budget as can be seen in tables 3 and 4, and in ﬁgure 1.

The increase in training and prediction times is mostly due to the sequential processing of branches
during the forward and backward passes. The smaller size of the branches makes the data parallelism
on GPUs less efﬁcient. This effect is not as pronounced for larger models. This could be solved in
two ways. First, as there is no data dependency between the branches (before the averaging layer)
it is possible to extend the data parallelism to the branches, restoring the initial level of parallelism.
This can be done by implementing a parallel implementation of multiples 2D convolutions at the
same time. Second or alternatively, when multiple GPUs are used, it is possible to spread the
branches over the GPUs.

We have currently evaluated the coupled ensemble approach only on relatively small data sets. We
therefore plan to conduct experiments on ImageNet (Russakovsky et al., 2015) to check whether it
will work equally well on large collections.

ACKNOWLEDGEMENTS

This work has been partially supported by the LabEx PERSYVAL-Lab (ANR-11-LABX-0025-01).
Experiments presented in this paper were partly carried out using the Grid’5000 test-bed, supported
by a scientiﬁc interest group hosted by Inria and including CNRS, RENATER and several Universi-
ties as well as other organizations (see https://www.grid5000.fr).

REFERENCES

Amos, B. and Kolter, J. Z. (2017). A PyTorch Implementation of DenseNet. https://github.

com/bamos/densenet.pytorch. Accessed: June 2017.

Chollet, F. (2017). Xception: Deep learning with depthwise separable convolutions. In Proceedings

of the IEEE Conference on Computer Vision and Pattern Recognition.

Cires¸an, D., Meier, U., and Schmidhuber, J. (2012). Multi-column deep neural networks for image
In 2012 IEEE Conference on Computer Vision and Pattern Recognition, pages

classiﬁcation.
3642–3649.

Cires¸an, D. C., Meier, U., Gambardella, L. M., and Schmidhuber, J. (2011). Convolutional neural
In Proceedings of the 2011 In-
network committees for handwritten character classiﬁcation.
ternational Conference on Document Analysis and Recognition, ICDAR ’11, pages 1135–1139,
Washington, DC, USA.

Gastaldi, X. (2017). Shake-shake regularization. In International Conference on Learning Repre-

sentations. arXiv:1705.07485.

Hansen, L. K. and Salamon, P. (1990). Neural network ensembles. IEEE Transactions on Pattern

Analysis and Machine Intelligence, 12(10):993–1001.

He, K., Zhang, X., Ren, S., and Sun, J. (2016a). Deep residual learning for image recognition. In
2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR), pages 770–778.
arXiv:1512.03385.

He, K., Zhang, X., Ren, S., and Sun, J. (2016b). Identity Mappings in Deep Residual Networks,

pages 630–645.

11

To be submitted as a conference paper at ICLR 2018

Huang, G., Liu, Z., van der Maaten, L., and Weinberger, K. Q. (2017). Densely connected con-
volutional networks. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition.

Huang, G., Sun, Y., Liu, Z., Sedra, D., and Weinberger, K. Q. (2016). Deep Networks with Stochastic

Depth, pages 646–661.

Kawaguchi, K. (2016). Deep learning without poor local minima. In Advances in Neural Information

Processing Systems, pages 586–594.

Krizhevsky, A. and Hinton, G. (2009). Learning multiple layers of features from tiny images.

Krizhevsky, A., Sutskever, I., and Hinton, G. E. (2012). Imagenet classiﬁcation with deep convolu-
tional neural networks. In Pereira, F., Burges, C. J. C., Bottou, L., and Weinberger, K. Q., editors,
Advances in Neural Information Processing Systems 25, pages 1097–1105. Curran Associates,
Inc.

Lecun, Y., Bottou, L., Bengio, Y., and Haffner, P. (1998). Gradient-based learning applied to docu-

ment recognition. Proceedings of the IEEE, 86(11):2278–2324.

Loshchilov, I. and Hutter, F. (2017). SGDR: stochastic gradient descent with restarts. In Interna-

tional Conference on Learning Representations.

Netzer, Y., Wang, T., Coates, A., Bissacco, A., Wu, B., and Ng, A. Y. (2011). Reading digits in
In NIPS Workshop on Deep Learning and

natural images with unsupervised feature learning.
Unsupervised Feature Learning 2011.

Russakovsky, O., Deng, J., Su, H., Krause, J., Satheesh, S., Ma, S., Huang, Z., Karpathy, A., Khosla,
A., Bernstein, M., Berg, A. C., and Fei-Fei, L. (2015). ImageNet Large Scale Visual Recognition
Challenge. International Journal of Computer Vision (IJCV), 115(3):211–252.

Simonyan, K. and Zisserman, A. (2014). Very deep convolutional networks for large-scale image

recognition. CoRR, abs/1409.1556. Published at ICLR 2015.

Springenberg, J. T., Dosovitskiy, A., Brox, T., and Riedmiller, M. (2015). Striving for simplicity:

The all convolutional net. In International Conference on Learning Representations.

Szegedy, C., Liu, W., Jia, Y., Sermanet, P., Reed, S. E., Anguelov, D., Erhan, D., Vanhoucke, V., and
Rabinovich, A. (2015). Going deeper with convolutions. In Proceedings of the IEEE conference
on computer vision and pattern recognition, pages 1–9.

Xie, S., Girshick, R., Dollr, P., Tu, Z., and He, K. (2017). Aggregated residual transformations for
deep neural networks. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition.

Zagoruyko, S. and Komodakis, N. (2016). Wide residual networks. In Proceedings of the British

Machine Vision Conference 2016, BMVC 2016, York, UK, September 19-22, 2016.

Zhang, T., Qi, G.-J., Xiao, B., and Wang, J. (2017). Interleaved Group Convolutions for Deep Neural

Networks. In International Conference on Computer Vision.

Zhao, L., Wang, J., Li, X., Tu, Z., and Zeng, W. (2016). On the connection of deep fusion to

ensembling. arXiv preprint arXiv:1611.07718.

Zoph, B. and Le, Q. V. (2017). Neural architecture search with reinforcement learning. In Interna-

tional Conference on Learning Representations.

Zoph, B., Vasudevan, V., Shlens, J., and Le, Q. V. (2017). Learning transferable architectures for

scalable image recognition. arXiv preprint arXiv:1707.07012.

12

To be submitted as a conference paper at ICLR 2018

Supplementary Material

A IMPLEMENTATION

Figure 2 shows the common structure of the test (top) and train (bottom) versions of networks used
as basic blocks. Figure 3 shows how it is possible to place the averaging layer just after the last FC
layer of the basic block instances and before the SM layer which is then “factorized”. The e model
instances do not need to share the same architecture. Figure 3 shows how it is possible to place the
averaging layer just after the last FC layer, just after the SM (actually LSM (LogSoftMax), which is
equivalent to do a geometric mean of the SM values) layer, or just after the LL layer.

Figure 2: Versions of the base network. Top: test, bottom: train.

Figure 3: Test versions of coupled ensemble networks. Top: SM (classical) fusion, bottom: FC
fusion. AVG: averaging layer.

We reuse “basic blocks” from other groups (with appropriate credits, please let us know if any is
missing or requires updating) in their original form as much as possible both for efﬁciency and for
ensuring more meaningful comparisons. When available, we use the PyTorch implementations.

Each of the e branches is deﬁned by a parameter vector We containing the same parameters as
the original implementation. The global network is deﬁned by a parameter vector W which is a
concatenation of all the We parameter vectors. When training is done in the coupled mode and the
prediction is done in a separate mode or vice-versa, a dedicated script is used for splitting the W
vector into the We ones or vice-versa. In all coupled networks, for all train versions and for all test
version, the same global parameter vector W is used with the same split and deﬁning the same basic
block functions. This is how we can combine in any way all of the four possible training conditions
with all the three possible prediction conditions, even though not all of them are consistent or equally
efﬁcient.

The overall network architecture is determined by:

• the global hyper-parameter specifying the train versus test mode;

• the global hyper-parameter e specifying the number of branches;

• the global hyper-parameter specifying after which layer the AVG layer should be placed (FC, SM

or LL);

13

To be submitted as a conference paper at ICLR 2018

Figure 4: Train versions of coupled ensemble networks. Top: LL fusion, middle: SM fusion, bottom:
FC fusion.

• either one basic block to be replicated e times with its own hyper-parameters or a list of e basic

blocks, each with its own hyper-parameters.

B TEST TIME EQUIVALENCE BETWEEN FC AVERAGE AND LOGSOFTMAX

AVERAGE

Given branches E = E1, E2, ..Ee, each Ei produces a score vector of dimension C, where C is the
number of categories. An element of Ei is referenced as Ec
i , were c ∈ [1, C]. FC Average denotes
averaging the raw activations from each branch. LSM Average denotes averaging across branches,
after a LogSoftMax operation in applied on each branch activation vector, separately.
i=1 Ec
Case 1: FC average: Scoresc
i

F C = (cid:80)e

Case 2:

LogSof tM ax(Ec

n) = log

(cid:80)

exp(Ec
e)
c exp(Ec
e)
e) − log

= log exp(Ec

= Ec

e − Ze

(cid:88)

c

exp(Ec
e)

LSM = (cid:80)e

LSM average: Scoresc
e). Hence we
see that the LSM average score vector is a translated version of the FC average score vector. Also,
doing an arithmetic average of LogSoftMax values is equivalent to doing a geometric average of
SoftMax values. This holds during inference where we are interested only in the maximum value.

i=1 Zi, where Ze = log (cid:80)

C exp(Ec

i − (cid:80)e

i=1 Ec

C COMPARISON WITH Learnt ARCHITECTURES

In table 5, we compare the parameter usage and performance of the branched coupled ensembles
with model architectures that were recovered using meta learning techniques.

14

To be submitted as a conference paper at ICLR 2018

Table 5: Classiﬁcation error comparison with learnt architectures.

System
Neural Architecture Search v3 (Zoph and Le, 2017)
NASNet-A (Zoph et al., 2017)
DenseNet-BC L = 82 k = 10 e = 4
DenseNet-BC L = 88 k = 14 e = 4
DenseNet-BC L = 88 k = 20 e = 4

C10+ C100+
3.65
3.41
3.78
3.57
3.18

-
-
19.92
17.68
16.79

SVHN #Params
37.4M
3.3M
1.6M
3.5M
7.0M

-
-
1.62
1.55
1.57

D PERFORMANCE MEASUREMENT AND REPRODUCIBILITY ISSUES

When attempting to compare the relative performance of different methods, we face the issue of the
reproducibility of the experiments and of the statistical signiﬁcance of the observed difference be-
tween performance measures. Even for a same experiment, we identiﬁed the ﬁve following sources
of variation in the performance measure:

• Underlying framework for the implementation: we made experiments with Torch7 (lua) and with

PyTorch.

• Random seed for the network initialization.

• CuDNN non-determinism during training: GPU associative operations are by default fast but
non-deterministic. We observed that the results varies even for a same tool and the same seed. In
practice, the observed variation is as important as when changing the seed.

• Fluctuations associated to the computed moving average and standard deviation in batch normal-
ization: these ﬂuctuations can be observed even when training with the learning rate, the SGD
momentum and the weight decay all set to 0. During the last few epochs of training, their level of
inﬂuence is the same as with the default value of these hyper-parameters.

• Choice of the model instance chosen from training epochs:

the model obtained after the last
epoch, or the best performing model. Note that choosing the best performing model involves
looking at test data.

Regardless of the implementation, the numerical determinism, the Batch Norm moving average,
and the epoch sampling questions, we should still expect a dispersion of the evaluation measure
according to the choice of the random initialization since different random seeds will likely lead
to different local minima. It is generally considered that the local minima obtained with “properly
designed and trained” neural networks should all have similar performance (Kawaguchi, 2016). We
do observe a relatively small dispersion (quantiﬁed by the standard deviation below) conﬁrming this
hypothesis. This dispersion may be small but it is not negligible and it complicates the comparisons
between methods since differences in measures lower than their dispersions is likely to be non-
signiﬁcant. Classical statistical signiﬁcance tests do not help much here since differences that are
statistically signiﬁcant in this sense can be observed between models obtained just with different
seeds (and even with the same seed), everything else being kept equal.

Experiments reported in this section gives an estimation of the dispersion in the particular case of a
moderate scale model. We generally cannot afford doing a large number of trials for larger models.

We tried to quantify the relative importance of the different effects in the particular case of DenseNet-
BC with L = 100, k = 12 on CIFAR 100. Table 6 shows the results obtained for the same exper-
iment in the four groups of three rows. We tried four combinations corresponding to the use of
Torch7 versus PyTorch and to the use of the same seed versus the use of different seeds. For each of
these conﬁguration, we used as the performance measure: (i) the error rate of the model computed
at the last epoch or (ii) the average of the error rate of the models computed at the last 10 epochs,
(iii) the error rate of the model having the lowest error rate over all epochs. For these 2 × 2 × 3
cases, we present the minimum, the median, the maximum and the mean±standard deviation over
10 measures corresponding to 10 identical runs (except for the seed when indicated). Additionally,
in the case of the average of the error rate of the models computed at the 10 last epochs, we present
the root mean square of the standard deviation of the ﬂuctuations on the last 10 epochs (which is the
same as the square root of the mean of their variance). We make the following observations:

15

To be submitted as a conference paper at ICLR 2018

• There does not seem to be a signiﬁcant difference between Torch7 and PyTorch implementations;
• There does not seem to be a signiﬁcant difference between using a same seed and using different
seeds; the dispersion observed using the same seed (with everything else being equal) implies that
there is no way to exactly reproduce results;

• There does not seem to be a signiﬁcant difference between the means over the 10 measures com-
puted on the single last epoch and the means over the 10 measures computed on the last 10 epochs;
• The standard deviation of the measures computed on the 10 runs is slightly but consistently
smaller when the measures are computed on the last 10 epochs than when they are computed
on the single last epoch; this is the same for the difference between the best and the worst mea-
sures; this was expected since averaging the measure on the last 10 epochs reduces the ﬂuctuations
due to the moving average and standard deviation computed in batch normalization and possibly
too the the random ﬂuctuations due to the ﬁnal learning steps;

• The mean of the measures computed on the 10 runs is signiﬁcantly lower when the measure is
taken at the best epoch than when they are computed either on the single last epoch or on the last
10 epochs. This is expected since the minimum is always below the average. However, presenting
this measure involves using the test data for selecting the best model.

Table 6: Performance measurement and reproducibility issues. Statistics on 10 runs.

Seeds
diff.
diff.
diff.
same
same
same
diff.
diff.
diff.
same
same
same
diff.
diff.
diff.
diff.
diff.
diff.

Impl.
PyT.
PyT.
PyT.
PyT.
PyT.
PyT.
LuaT.
LuaT.
LuaT.
LuaT.
LuaT.
LuaT.
PyT.
PyT.
PyT.
PyT.
PyT.
PyT.

Last
1
10
best
1
10
best
1
10
best
1
10
best
1
10
best
1
10
best

L
100
100
100
100
100
100
100
100
100
100
100
100
82
82
82
100
100
100

k
12
12
12
12
12
12
12
12
12
12
12
12
8
8
8
12
12
12

e Min. Med. Max. Mean±SD RMS(SD)
1
1
1
1
1
1
1
1
1
1
1
1
3
3
3
4
4
4

22.89±0.21
22.87±0.17
22.54±0.24
23.06±0.23
23.04±0.22
22.71±0.18
22.90±0.20
22.86±0.20
22.49±0.18
22.82±0.34
22.87±0.30
22.54±0.29
21.49±0.15
21.45±0.11
21.14±0.14
17.65±0.18
17.66±0.14
17.45±0.16

22.64
22.67
22.13
22.77
22.81
22.44
22.55
22.55
22.17
22.33
22.47
22.24
21.27
21.24
20.84
17.24
17.37
17.11

23.22
23.14
22.91
23.55
23.49
23.02
23.11
23.08
22.75
23.58
23.51
23.24
21.70
21.63
21.30
17.86
17.81
17.66

22.80
22.83
22.56
23.05
22.98
22.67
22.94
22.89
22.52
22.82
22.92
22.51
21.44
21.46
21.18
17.71
17.67
17.46

n/a
0.13
n/a
n/a
0.11
n/a
n/a
0.12
n/a
n/a
0.12
n/a
n/a
0.12
n/a
n/a
0.11
n/a

Following these observations, we propose a method for ensuring the best reproducibility and the
fairest comparisons. Choosing the measure as the minimum of the error rate for all models computed
during the training seems neither realistic nor a good practice since we have no way to know which
model will be the best one without looking at the results (cross-validation cannot be used for that)
and this is like tuning on the test set. Even though this is not necessarily unfair for system comparison
if the measures are done in this condition for all systems, this does introduce a bias for the absolute
performance estimation. Using the error rate at the last iteration or at the 10 last iteration does not
seem to make a difference in the mean but the standard deviation is smaller for the latter, therefore
this one should be preferred when a single experiment is conducted. We also checked that using
the 10 or the 25 last epochs does not make much difference (learning at this point does not seem to
lead to further improvement). A value different from 10 can be used and this is not critical. In all
the CIFAR experiments reported in this paper, we used the average of the error rate for the models
obtained at the last 10 epochs as this should be (slightly) more robust and more conservative. The
case for SVHN experiments is slightly different since there is a much smaller number of much bigger
epochs; we used the last 4 iterations in this case.

These observations have been made in a quite speciﬁc case but the principle and the conclusions
(use of the average of the error rate from the last epochs should lead to more robust and conservative

16

To be submitted as a conference paper at ICLR 2018

results) are likely to be general. Table 6 also shows the results for a coupled ensemble network of
comparable size and for a coupled ensemble network four times bigger. Similar observations can be
made and, additionally, we can observe that both the range and the standard deviations are smaller.
This might be because an averaging is already made between the branches leading to a reduction of
the variance. Though this requires conﬁrmation at larger scales, coupled ensemble networks might
lead to both a better and a more stable performance.

17

7
1
0
2
 
p
e
S
 
8
1
 
 
]

V
C
.
s
c
[
 
 
1
v
3
5
0
6
0
.
9
0
7
1
:
v
i
X
r
a

To be submitted as a conference paper at ICLR 2018

COUPLED ENSEMBLES OF NEURAL NETWORKS

Anuvabh Dutt
Univ. Grenoble Alpes, CNRS, Grenoble-INP, LIG, F-38000 Grenoble France
Anuvabh.Dutt@univ-grenoble-alpes.fr

Denis Pellerin
Univ. Grenoble Alpes, CNRS, Grenoble-INP, GIPSA-Lab, F-38000 Grenoble France
Denis.Pellerin@gipsa-lab.grenoble-inp.fr

Georges Qu´enot
Univ. Grenoble Alpes, CNRS, Grenoble-INP, LIG, F-38000 Grenoble France
Georges.Quenot@imag.fr

ABSTRACT

We investigate in this paper the architecture of deep convolutional networks.
Building on existing state of the art models, we propose a reconﬁguration of the
model parameters into several parallel branches at the global network level, with
each branch being a standalone CNN. We show that this arrangement is an efﬁcient
way to signiﬁcantly reduce the number of parameters without losing performance
or to signiﬁcantly improve the performance with the same level of performance.
The use of branches brings an additional form of regularization. In addition to
the split into parallel branches, we propose a tighter coupling of these branches
by placing the “fuse (averaging) layer” before the Log-Likelihood and SoftMax
layers during training. This gives another signiﬁcant performance improvement,
the tighter coupling favouring the learning of better representations, even at the
level of the individual branches. We refer to this branched architecture as “cou-
pled ensembles”. The approach is very generic and can be applied with almost
any DCNN architecture. With coupled ensembles of DenseNet-BC and parameter
budget of 25M, we obtain error rates of 2.92%, 15.68% and 1.50% respectively
on CIFAR-10, CIFAR-100 and SVHN tasks. For the same budget, DenseNet-BC
has error rate of 3.46%, 17.18%, and 1.8% respectively. With ensembles of cou-
pled ensembles, of DenseNet-BC networks, with 50M total parameters, we obtain
error rates of 2.72%, 15.13% and 1.42% respectively on these tasks.

1

INTRODUCTION

The design of early convolutional architectures (CNN) involved choices of hyper-parameters such
as: ﬁlter size, number of ﬁlters at each layer, and padding (Lecun et al., 1998; Krizhevsky et al.,
2012). Since the introduction of the VGGNet (Simonyan and Zisserman, 2014) the design has
moved towards following a template: ﬁxed ﬁlter size of 3 × 3 and N features maps, down-sample to
half the input resolution only by the use of either maxpool or strided convolutions (Springenberg
et al., 2015), and double the number the computed feature maps following each down-sampling
operation. This philosophy is used by state of the art models such as ResNet (He et al., 2016b) and
DenseNet (Huang et al., 2017). The last two architectures extended the template to include the use
of “skip-connections” between non-contiguous layers.

Our work extends this template by adding another element, which we refer to as “coupled en-
sembling”.
In this set-up, the network is decomposed into several branches, each branch being
functionally similar to a complete CNN (and able to fully do the classiﬁcation task alone, gen-
erally with a lower performance). The proposed template achieves performance comparable to
state of the art models with a signiﬁcantly lower parameter count. The proposed modiﬁcation

1

To be submitted as a conference paper at ICLR 2018

is simple to implement and we provide a wrapper to compose different standard architectures at:
https://github.com/vabh/coupled_ensembles.

In this paper, we make the following contributions: (i) we show that given a parameter budjet,
splitting a large network into an ensemble of smaller parallel branches of the same type, and jointly
training them performs better or at par; (ii) when a ﬁnal SoftMax (SM) layer is used during the
prediction step, we show that ensemble fusion works better when averaging is done before this
layer than when it is done after; (iii) when a ﬁnal Log-Likelihood (LL) layer is used during the
training step, we show that ensemble fusion of branches works better when the fusion is done before
this layer than when it is done after; (iv) combining all these elements, we signiﬁcantly improved
the performance and/or signiﬁcantly reduce the parameter count of state-of-the-art neural network
architectures on CIFAR and SVHN data sets. (v) We show that such multi-branch networks can be
further ensembled at a higher level still producing a signiﬁcant performance gain.

This paper is organised as follows: in section 2, we discuss related work; in section 3, we introduce
the concept of coupled ensembles and the motivation behind the idea; in section 4, we present the
evaluation of the proposed approach and compare it with the state of the art; and we conclude and
discuss future work in section 5.

2 RELATED WORK

Multi-column architectures. The network architecture that we propose has strong similarities
with Cires¸an’s Neural Networks Committees (Cires¸an et al., 2011) and Multi-Column Deep Neural
Network (MCDNN) (Cires¸an et al., 2012), which are a type of ensemble of networks where the
“committee members” or “DNN columns” correspond to our basic block instances (or branches).
However, our coupled ensemble networks differ as following: (i) we train a single model which is
composed of sub-networks, while they train each member or column separately. (ii) we consider a
coupled ensemble of smaller networks for improving the performance of a network, given a budget
of parameters for the entire model. This is contrary to improving it by utilising multiple models of
ﬁxed size and therefore multiplying the overall size (though both are not exclusive); (iii) we consider
placing the averaging (AVG) layer, not only completely at the end of the network but also before
the Log-Likelihood (LL) layer during training and before the Soft-Max (SM) layer during training
and/or during prediction; (iv) we used the same preprocessing for all branches while they consid-
ered different preprocessing (data augmentation) blocks for different members or different subsets
of columns; we consider doing this also in the future.

Multi-branch architectures. Multi-branch architectures have been very successful in several vision
applications (He et al., 2016a; Szegedy et al., 2015). Recently, modiﬁcations have been proposed
(Xie et al., 2017; Chollet, 2017) for these architectures using the concept of “grouped convolutions”,
in order to factorize spatial feature extraction and channel features. These modiﬁcations additionally
advocate the use of template building blocks stacked together to form the complete model. This
modiﬁcation is at the level of the building blocks of their corresponding base architectures: ResNet
and Inception respectively. In contrast we propose a generic modiﬁcation of the structure of the
CNN at the global model level. This includes a template in which the speciﬁc architecture of a
“basic block” is speciﬁed, and then this “basic block” is replicated as parallel branches to form the
ﬁnal composite model.

To further improve the performance of such architectures, Shake-Shake regularization (Gastaldi,
2017) proposes a stochastic mixture of each of the branches and has achieved good results on the
CIFAR datasets. However, the number of epochs required for convergence is much higher compared
to the base model. Additionally, the technique seems to depend on the batch size. In contrast, we
apply our method using the exact same hyper-parameters as used in the underlying CNN.

Zhao et al. (2016) investigate the usage of parallel paths in a ResNet, connecting layers to allow
information exchange between the paths. However this requires modiﬁcation at a local level of each
of the residual blocks. In contrast, our method is a generic rearrangement of a given architecture’s
parameters, which does not introduce additional choices. Additionally, we empirically conﬁrm that
our proposed conﬁguration leads to an efﬁcient usage of parameters.

Neural network ensembles. Ensembling is a reliable technique to increase the performance of
models for a task. Due to the presence of several local minima, multiple trainings of the exact

2

To be submitted as a conference paper at ICLR 2018

same neural network architecture can reach a different distribution of errors on a per-class basis.
Hence, combining their outputs lead to improved performance on the overall task. This was observed
very early (Hansen and Salamon, 1990) and is now commonly used for obtaining top results in
classiﬁcation challenges, despite the increase in training and prediction cost. Our proposed model
architecture is not an ensemble of independent networks given that we have a single model made
up of parallel branches that is trained. This is similar in spirit to the residual block in ResNet
and ResNeXt, and to the inception module in Inception but is done at the full network level. We
would like to emphasize here that “arranging” a given budget of parameters into parallel branches
leads to an increase in performance (as shown in tables 1, 2 and 3). Additionally, the classical
ensembling approach can still be applied for the fusion of independently trained coupled ensemble
networks where it produces a signiﬁcant performance improvement (as shown in table 4)

3 COUPLED ENSEMBLES

TERMINOLOGY

For the following discussion, we deﬁne some terms:

• Branch: the proposed model comprises several branches. Each branch takes as input a data point
and produces a score vector corresponding to the target classes. Current design of CNNs are
referred to as single-branch. The number of branches is denoted by e.

• Basic block: the model architecture used to form a branch. In our experiments, we use DenseNet-

BC and ResNet with pre-activation as basic blocks.

• Fuse Layer:

the operation used to combine each of the parallel branches which make up our
model. In our experiments, each of the branches are combined by taking the average of each of
their predicted log probabilities over the target classes. Section 4.4 explores different choices of
operations for the fuse layer.

We consider a classiﬁcation task in which individual samples are always associated to exactly
one class, labelled from a ﬁnite set. This is the case for CIFAR (Krizhevsky and Hinton, 2009),
SVHN (Netzer et al., 2011) and ILSVRC (Russakovsky et al., 2015) tasks. In theory, this should
work for other tasks as well (for example, segmentation, object detection, etc.).

We consider neural network models whose last layer outputs a score vector of the same dimension
as the number of target classes. This is usually implemented as a linear layer and referred to as
a fully connected (FC) layer. This layer can be followed by a SoftMax (SM) layer to produce a
probability distribution over the target classes. During training, this is followed by a loss layer, for
example, negative log-likelihood (LL). This is the case for all recent network architectures for image
classiﬁcation1 (Krizhevsky et al., 2012; Simonyan and Zisserman, 2014; Szegedy et al., 2015; He
et al., 2016a; Xie et al., 2017; Huang et al., 2016; Zagoruyko and Komodakis, 2016; Huang et al.,
2017). The differences among them is related to what is present before the last FC layer. We are
agnostic to this internal setup (however complex it may or may not be) because the resulting “basic
block” always takes an image as input and produces a vector of N values (one for each target class)
as output, parametrized by a tensor W .

In the case of ensemble predictions, fusion is usually done by computing the individual predic-
tions separately for e model instances and then averaging them. Each of the instances are trained
seperately. This is functionally equivalent to predicting with a “super-network” including the e in-
stances as parallel branches with a ﬁnal averaging (AVG) layer on top. Such super-networks are
generally not implemented because the branch instances often already correspond to the maximum
memory capacity of GPUs. The remaining AVG layer operation can be implemented separately.
Alternatively, it is possible to place the averaging layer just after the last FC layer of the basic block
instances and before the SM layer, which is then “factorized”.

1Though all these networks actually do have a FC layer before the SM one, the last layer need not be a linear
layer, as long as it produces one value for each target label. We will refer to the output of each basic block as
“FC”. Similarly, the proposed method may be easily adapted to multi-label classiﬁcation (i.e. considering non-
exclusive classes) by simply replacing the SM (and possibly also the LL) layer(s) by any variant(s) appropriate
for multi-label classiﬁcation. Again, we will refer to their output as “SM” and “LL”.

3

To be submitted as a conference paper at ICLR 2018

In our setup, a model is composed of parallel branches and each branch produces a score vector for
the target categories. We explore three options to combine these vectors during training:

• Activation (FC) average.

• Probability (SM) average (in practice we do an arithmetic average of log-probabilities).

• Log Likelihood (LL) average (average of the loss of each branch).

We investigate these options in section 4.4. Note that for inference, averaging the FC layer activa-
tions is equivalent to averaging the LogSoftMax values (or to a geometric average of the softmax
values, see section B of supplementary material).

This transformation of having multiple branches, and combining the branch activations by averaging
the log probabilites that they predict for the target categories, leads to a performance improvement,
with a lower parameter count, in all our experiments (see section 4). The parameter vector W of this
composite branched model is the concatenation of the parameter vectors We of the e basic blocks
with 1 ≤ i ≤ e. All parameters are in the “basic blocks” as the “fuse layer” does not contain any
parameters. The e model instances do not really need to share the same architecture.

Three training versions may be considered depending upon whether the “fuse layer” is placed after
the FC, after the SM or after the LL layer. All the instances are trained simultaneously trough a
single loss function and the W parameter vector is obtained in a single training phase. In practice,
in the ﬁrst and the third versions, the SM and LL layers are replaced by a single Cross-Entropy
(CE) layer as this is numerically more stable. Similarly, in the second and intermediate case, a
LogSoftMax (LSM) layer is used instead of the regular SM layer before the arithmetic averaging
(while removing the Log operation in the LL layer). This is equivalent to replacing the arithmetic
average by a geometric one with the regular SM and LL layers. The training can be done in four
different ways: the three coupled ways correspoding to the “fuse layer” plus the the one in which
all basic blocks are trained separately in e independent trainings. Regardless of how the training of
the basic blocks has been performed, it is possible to use any of the two coupled ways for making
‘coupled prediction’ and it is also possible to use the individual basic blocks for making e ‘individual
predictions’. Not all of these combinations are expected to be consistent or equally efﬁcient but all
can be implemented and evaluated as shown in section 4.4.

4 EXPERIMENTS

4.1 DATASETS

We evaluate our proposed architecture on the CIFAR (Krizhevsky and Hinton, 2009) and SVHN
(Netzer et al., 2011) data sets. CIFAR-10 and CIFAR-100 consist each of 50,000 training images
and 10,000 test images, distributed into 10 and 100 categories respectively. SVHN consists of
73,257 training images, 531,131 “easy” training images (we use both for training) and 26,032 testing
images, distributed into 10 categories. Each image from these datasets is of size 32×32 pixels.

4.2 EXPERIMENTAL SET-UP

All hyper parameters are set according to the original descriptions of the “basic block” that is used.
This may not be the optimal setting in our case (especially the learning rate decay schedule) but we
do not alter them, so as to not introduce any bias in comparisons.

For CIFAR-10, CIFAR-100 and SVHN, the input image is normalised by subtracting by the mean
image and dividing by the standard deviation. During training on CIFAR datasets, standard data
augmentation is used, which comprises random horizontal ﬂips and random crops. For SVHN, no
data augmentation is used. However, a dropout ratio of 0.2 is applied in the case of DenseNet when
training on SVHN. Testing is done after normalising the input in the same way as during training.

All error rates are given in percentages and correspond to an average computed on the last 10 epochs
for CIFAR and on the last 4 epochs for SVHN. This measure is more conservative than the one used
by the DenseNet authors (see supplementary material, section D). For DenseNet-BC, Amos and
Kolter (2017)’s PyTorch implementation has been used. All execution times were measured using a

4

To be submitted as a conference paper at ICLR 2018

single NVIDIA 1080Ti GPU with the optimal micro-batch2. Experiments in section 4.3, 4.4 are done
on the CIFAR-100 data set with the “basic block” being DenseNet-BC, depth L = 100, growth rate
k = 12. For experiments in Section 4.5, we consider this same conﬁguration (with a single branch)
as our baseline reference point.

4.3 COMPARISON WITH SINGLE BRANCH AND INDEPENDENT ENSEMBLES

A natural point of comparison of the proposed branched architecture is with an ensemble of indepen-
dent models. Rows 2 (coupled training with SM averaging) and 4 (no averaging) in Table 1 present
the results of these two cases respectively. Row 4 shows the error rate obtained from averaging the
predictions of 4 identical models, each of which were trained separately. We see that even though
the total number of trainable parameters involved is exactly the same, a jointly trained branched
conﬁguration gives a much lower test error (17.61 vs. 18.42 with 4 predictions fused at the FC level
in both cases).

The next point of comparison is with a single branch model comprising a similar number of pa-
rameters as the multi branch conﬁguration. The choice of single branch models has been done by:
increasing k while keeping L constant, by increasing both k and L, or by increasing L while keep-
ing k constant. The last three rows of Table 1 show that the error from the multi branch model is
considerably lower, as compared to a single branch model (17.61 vs. 20.01, with 4 predictions fused
at the FC level).

These observations show that the arranging a given budget of parameters into parallel branches is
efﬁcient in terms of parameters, as compared to having a large single branch or multiple independent
trainings. In Section 4.5 we analyse the relation between the number of branches and the model
performance.

4.4 CHOICE OF FUSE LAYER OPERATION

In this section, we compare the performance of our proposed branched model for different choices
for the positioning of the “fuse layer” (see section 3). Experiments are carried out to evaluate the best
training and prediction fusion combinations. We consider two branched models with e = 2, e = 4,
trained in the following conditions: training with fusion after the LL layer, after the SM layer, or
after the FC layer.

Table 1 shows the performance of the differently trained systems for different prediction conﬁgu-
rations: individual average performance of the trained instances (without fusion) and performance
of the ensemble system with fusion after the SM layer or after the FC layer. Note that this ta-
ble includes models with parameters obtained using different training methods . We can make the
following observations:

• The Avg. FC training with separate predictions (in red) does not work well. This is expected since
a similar FC average may be reached with quite unrelated FC instances. The Avg. FC training
with Avg. SM prediction (in red) works a bit better but is still not good because the non-linearity
of the SM layer distorts the FC average. Indeed, the consistent Avg. FC training with Avg. FC
prediction works quite well though it does not yield the best performance.

• The Avg. FC prediction works at least as well and often signiﬁcantly better than the Avg. SM
prediction whatever the training choice is. This can be explained by the fact that the SM layer
compresses values for probabilities close to 0 and 1 while the values remain more spread and
transmit more information at the FC layer, even for different training conditions.

• The average error rate of each of the “basic blocks” trained jointly in coupled ensembles with SM
fusion is signiﬁcantly lower than the error rate of the individual instances trained separately. This
indicates that the coupling not only forces them to learn complementary features as a group but
also to better learn individually. Averaging the log probabilities forces the network to continuously
update all branches so as to be consistent with each other. This provides a stronger gradient
signal. Additionally, the training loss remains higher compared to single branch models, serving
as a regularizer. The error gradient that is back-propagated from the fuse layer is the same for all

2The micro-bath denotes the number of images samples that were processed in one batch on the GPU so as

to have the best throughput. In practice, minibatch (for parameter update) = n×microbatch

5

To be submitted as a conference paper at ICLR 2018

Table 1: Coupled Ensembles of DenseNet-BCs versus a single model of comparable complexity and
study of training / prediction fusion combinations. Top: e = 2, bottom: e = 4. Performance is given
as the top-1 error rate (mean±standard deviation for the individual branches) on the CIFAR-100
data set with standard data augmentation. Columns “L” and “k” indicate the DenseNet-BC hyper-
parameter values of the “basic block”. Column “e” indicates the number of branches. Column
“Avg.” indicates the type of “fuse layer” during training: “none” for separate trainings (classical
ensembling), “FC”, “SM” and “LL” for fusion (arithmetic averaging) after the FC, SM and LL lay-
ers respectively (not applicable for e = 1). Column “Individual” gives the performance for the
individual “basic blocks” evaluated separately; Columns “FC” and “SM” give the performance with
fusion (arithmetic averaging) during prediction done after the FC and SM layers respectively. The
last three columns give the total number of parameters of the model, the duration of a training itera-
tion (50,000 images) and the prediction time per test image (in batch mode). (*) See supplementary
material, section D; The average and standard deviations are computed here for the independent
trainings (comprising 2 and 4 models respectively.).

L
100
100
100
100
100
124
148

L
100
100
100
100
100
154
220

k
12
12
12
12
17
14
12

k
12
12
12
12
25
17
12

e Avg.
FC
2
SM
2
LL
2
none
2
n/a
1
n/a
1
n/a
1

e Avg.
FC
4
SM
4
LL
4
none
4
n/a
1
n/a
1
n/a
1

Individual
52.68±22.95
22.17±0.32
22.78±0.08
23.13±0.15(*)
21.22±0.12
21.75±0.10
20.80±0.06

Individual
74.36±26.28
22.29±0.11
22.83±0.18
23.13±0.09(*)
20.61±0.01
20.02±0.10
20.01±0.12

FC
22.25
19.06
19.33
20.44
n/a
n/a
n/a

FC
22.55
17.61
18.21
18.42
n/a
n/a
n/a

SM Params Epoch(s) Test(ms)
28.78
19.43
19.91
20.44
n/a
n/a
n/a

1.60M
1.60M
1.60M
1.60M
1.57M
1.55M
1.56M

0.98
0.98
0.98
0.98
0.67
0.77
0.90

174
174
174
171
121
135
159

SM Params Epoch(s) Test(ms)
31.92
17.68
18.92
18.85
n/a
n/a
n/a

3.20M
3.20M
3.20M
3.20M
3.34M
3.29M
3.15M

2.00
2.00
2.00
2.00
0.8
1.3
1.5

402
402
402
341
164
245
326

branches, and this gradient depends on the combined predictions. This means that at every step
all branches act complementary to the other branches’ weight updates.

• All ensemble combinations except those based on the Avg. FC training do signiﬁcantly better
than a single network of comparable size and same depth. For a global network size of about
1.6M (resp. 3.2M) parameters, the error rate decreases from 20.80 (resp. 20.01) for the best
single instance combination to 19.06 (−1.74) with two instances (resp. 17.61 (−2.40) with four
instances).

• The best combination seems to be Avg. SM for training with Avg. FC for prediction.
• The branched model with e = 4 and Avg. SM for the “fuse layer” has the same performance as
a DenseNet-BC (L = 250, k = 24) model (Huang et al., 2017), which has about 5 times more
parameters (15.3M versus 3.2M).

All the following experiments have Avg. SM for the training “fuse layer’ in the branched models.

4.5 CHOICE OF THE NUMBER OF BRANCHES

In this section, we investigate the optimal number of branches e for a given model parameter budget.
We evaluate on CIFAR-100, with DenseNet-BC as the “basic block”, and parameter budget equal
to 0.8M parameters (this is the number of parameters in DenseNet-BC (L = 100, k = 12)). In-
deed, the optimal number of instances e is likely to depend upon the network architecture, upon the
parameter budget and upon the data set but this gives at least one reference. This was investigated
again with larger models, and the results are in table 3 (last four rows).

6

To be submitted as a conference paper at ICLR 2018

Table 2: Different number of branches, e for a ﬁxed parameter count. The models are trained on
CIFAR-100 with standard data augmentation. See table 1 caption for the meaning of row and column
labels. When applicable (e > 1), “fuse layer” is SM Avg. (*) Average and standard deviation on 10
trials with different seeds; Huang et al. (2017) reports 22.27, see supplementary material, section D.

L
100
76
88
94
100
70
82
88
94
64
70
58
64
58
64

k
12
10
9
8
8
9
8
7
7
8
8
7
7
6
6

e
1
2
2
2
2
3
3
3
3
4
4
6
6
8
8

Individual
22.87±0.17(*)
25.58±0.20
25.15±0.31
25.72±0.20
25.42±0.20
26.67±0.40
26.47±0.17
26.92±0.41
26.50±0.12
28.58±0.59
27.65±0.48
30.11±0.53
30.65±0.62
32.15±0.00
31.52±0.38

FC
n/a
21.66
21.87
21.95
21.87
21.10
21.25
22.09
21.95
22.44
21.50
23.87
23.08
25.95
24.42

SM Params Epoch(s) Test(ms)
n/a
22.17
22.19
22.22
22.07
21.24
21.46
22.49
22.35
22.58
22.12
24.22
23.36
25.70
24.69

800k
720k
747k
666k
737k
773k
800k
698k
775k
719k
828k
718k
840k
722k
843k

0.51
0.63
0.71
0.69
0.75
0.77
0.85
0.92
0.98
0.88
0.94
1.08
1.20
1.35
1.51

86
103
119
115
126
129
141
148
160
142
156
179
198
219
250

Table 2 shows the performance for different conﬁgurations of branches e, depth L, and growth rate
k. One difﬁculty is that DenseNet-BC parameter counts are strongly quantiﬁed according to the L
and k values (L has to be a multiple of 6 modulo 4) and, additionally, to the e value in the coupled
ensemble version. This is even more critical in moderate size models like the 800K one targeted
here. We selected model conﬁgurations with parameters just below the target for making a fair
comparison. A few models have slightly more parameters so that some interpolation can be done
for possibly more accurate comparisons. We can make the following observations:

• In the considered case (DenseNet-BC, CIFAR-100 and 800K parameters), the optimal number of
branches is e = 3, L = 70, k = 9. With these parameters, the error rates decreases from 22.87
for the regular (L = 100, k = 12) DenseNet-BC model to 21.10 (−1.77).

• Using 2 to 4 branches yields a signiﬁcant performance gain over the classical (single branch,
e = 1) case, and even over the original performance of 22.27 reported for the (L = 100, k = 12)
DenseNet-BC (see supplementary material, section D).
• Using 6 or 8 branches performs signiﬁcantly less well.
• Slightly varying the L, k and e hyper-parameters around their optimal value does not lead to a
signiﬁcant performance drop, showing that the coupled ensemble approach and the DenseNet-BC
architecture are quite robust relatively to these choices.

• The gain in performance comes at the expense of an increased training and prediction times even
though the model size does not change. This is due to the use of smaller values of k that prevents
good parallelism efﬁciency. This increase is relatively smaller with bigger networks.

The same experiment was done on a validation set with a 40k/10k random split of the CIFAR-
100 training set and we could draw the same conclusions from there; they led to predict that the
(L = 82, k = 8, e = 3) combination should be the best one on the test set. The (L = 70, k = 9, e =
3) combination appears to be slightly better here but the difference is probably not statistically
signiﬁcant.

4.6 COMPARISON WITH THE STATE OF THE ART

We have evaluated the coupled ensemble network approach with networks of various sizes. We used
again Huang et al. (2017)’s DenseNet-BC architecture as the “basic block” since this was the current
state of the art or very close to it at the time we started these experiments. We used Amos and Kolter
(2017)’s PyTorch DenseNet-BC implementation both for the multi-branch (coupled ensembles) and

7

To be submitted as a conference paper at ICLR 2018

single-branch (classical) experiments. We also evaluated the approach using He et al. (2016b)’s
ResNet with pre-activation as the basic block to check if the coupled ensemble approach works well
with other architectures.

Table 3 reports in the upper part the results obtained by the current best systems (see section 2 for
references) and the results obtained with our coupled ensembles approach in the lower part. All
results presented in this table correspond to the training of a single, possibly big, network. Even
if ensembles are considered, they are always coupled as described in section 3 and trained as a
single global network. A further level of ensembling involving multiple trainings is considered in
section 4.7. Results are presented on the CIFAR 10 and 100 data set with standard data augmentation
and on SVHN using the extra training data.

Table 3: Classiﬁcation error comparison with the state of the art, for a single model.

SVHN #Params

System
ResNet L = 110 k = 64
ResNet stochastic depth L = 110 k = 64
ResNet stochastic depth L = 1202 k = 64
ResNet pre-activation L = 164 k = 64
ResNet pre-activation L = 1001 k = 64
DenseNet L = 100 k = 24
DenseNet-BC L = 100 k = 12 (Torch)
DenseNet-BC L = 250 k = 24 (Torch)
DenseNet-BC L = 190 k = 40 (Torch)
Shake-Shake C10 Model S-S-I
Shake-Shake C100 Model S-E-I
Snapshot Ensemble DenseNet-40 (α0 = 0.1)
Snapshot Ensemble DenseNet-40 (α0 = 0.2)
Snapshot Ensemble DenseNet-100 (α0 = 0.2)
SGDR WRN-28-10 Loshchilov and Hutter (2017)
SGDR WRN-28-10 3 snapshots
ResNeXt-29, 8×64d Xie et al. (2017)
ResNeXt-29, 16×64d Xie et al. (2017)
DFN-MR2 Zhao et al. (2016)
DFN-MR3 Zhao et al. (2016)
IGC-L450M2 Zhang et al. (2017)
IGC-L32M26 Zhang et al. (2017)
ResNet pre-activation L = 65 k = 64 e = 2
ResNet pre-activation L = 164 k = 64 e = 2
ResNet pre-activation L = 164 k = 64 e = 4
DenseNet-BC L = 100 k = 12 e = 1
DenseNet-BC L = 112 k = 16 e = 1
DenseNet-BC L = 130 k = 20 e = 1
DenseNet-BC L = 160 k = 24 e = 1
DenseNet-BC L = 166 k = 32 e = 1
DenseNet-BC L = 190 k = 40 e = 1
DenseNet-BC L = 82 k = 8 e = 3
DenseNet-BC L = 82 k = 10 e = 4
DenseNet-BC L = 88 k = 14 e = 4
DenseNet-BC L = 88 k = 20 e = 4
DenseNet-BC L = 94 k = 26 e = 4
DenseNet-BC L = 118 k = 35 e = 3
DenseNet-BC L = 106 k = 33 e = 4
DenseNet-BC L = 76 k = 33 e = 6
DenseNet-BC L = 64 k = 35 e = 8

C10+ C100+
6.61
5.25
4.91
5.46
4.92
3.74
4.51
3.62
3.46
2.86
-
4.99
4.84
3.44
4.03
3.51
3.65
3.58
3.94
3.57
3.25
3.31
5.26
4.24
3.96
4.77
4.47
4.06
3.98
4.03
4.04
4.30
3.78
3.57
3.18
3.01
2.99
2.99
2.92
3.13

-
24.98
-
24.33
22.71
19.25
22.27
17.60
17.18
-
15.85
23.34
21.93
17.41
19.57
17.75
17.77
17.31
19.25
19.00
19.25
18.75
23.24
19.92
18.84
22.87
20.73
19.03
18.92
20.03
18.19
21.25
19.92
17.68
16.79
16.24
16.18
15.68
15.76
15.95

-
-
-
-
-
1.59
1.76
-
-
-
-
1.64
1.73
-
-
-
-
-
1.51
1.55
-
1.56
-
-
-
1.79
1.83
1.84
1.88
1.88
1.79
1.66
1.62
1.55
1.57
1.50
1.50
1.53
1.50
1.50

1.7M
1.7M
10.2M
1.7M
10.2M
27.2M
0.80M
15.3M
25.6M
26.2M
34.4M
6.0M
6.0M
163M
36.5M
110M
34.4M
68.1M
14.9M
24.8M
19.3M
24.1M
1.4M
3.4M
6.8M
0.8M
1.7M
3.4M
6.9M
13.0M
25.8M
0.8M
1.6M
3.5M
7.0M
13.0M
25.7M
25.1M
24.6M
24.9M

8

To be submitted as a conference paper at ICLR 2018

For the ResNet pre-act architecture, the ensemble versions with 2 or 4 branches leads to a sig-
niﬁcantly better performance than single branch versions with comparable or higher number of
parameters.

Regarding the DenseNet-BC architecture, we considered 6 different network sizes, roughly follow-
ing multiples of powers of 2 and ranging from 0.8M up to 25.6M parameters, with two extremes
corresponding to those for which the error rates were available Huang et al. (2017). We chose these
values for the depth L and growth rate k for these points and interpolated between them according
to a log scale as much as possible. Our experiments showed that the trade-off between L and k is
not critical for a given overall parameter count. This was also the case for choosing between the
number of branches e, depth L and growth rate, k for a given overall parameter count budget as long
as e ≥ 3 (or even e ≥ 2 for small networks). For the 6 conﬁgurations, we experimented with both
the single-branch (classical) and multi-branch versions of the model, with e = 4. Additionally, for
the largest model, we tried e = 3, 6, 8 branches.

For the single branch version with extreme network sizes, we obtained error rates signiﬁcantly lower
than those reported by Huang et al. (2017). From what we have checked, the Lua Torch implemen-
tation they used and the PyTorch one we used are equivalent. The difference may be due to the fact
that we used a more conservative measure of the error rate (on the last iterations) and from statistical
differences due to different initializations and/or to non-deterministic computations (see section D
in supplementary material). Still, the coupled ensemble version leads to a signiﬁcantly better per-
formance for all network sizes, even when compared to DenseNet-BC’s reported performance.

Our larger models of coupled DenseNet-BCs (error rates of 2.92% on CIFAR 10, 15.68% on CIFAR
100 and 1.50% on SVHN) perform better than or are on par with all current state of the art imple-
mentations that we are aware of at the time of publication of this work. Only the Shake-Shake S-S-I
model (Gastaldi, 2017) performs slightly better on CIFAR 10.

We also compare the performance of coupled ensembles with model architectures that were ‘learnt’
in a meta learning scenario. The results are presented in the supplementary material, section C.

4.7 ENSEMBLES OF COUPLED ENSEMBLES

The coupled ensemble approach is limited by the size of the network that can ﬁt into GPU memory
during the training and the time that such training takes. With the hardware we have access to, it
was not possible to go much beyond the 25M-parameter scale. For going further, we resorted to the
classical ensembling approach based on independent trainings. An interesting question was whether
we could still signiﬁcantly improve the performance since the classical approach generally plateaus
after quite a small number of models and the coupled ensemble approach already include several.
For instance the SGDR with snapshots approach (Loshchilov and Hutter, 2017) has a signiﬁcant im-
provement from 1 to 3 models but not much improvement from 3 to 16 models (see tables 3 and 4).
As doing multiple times the same training is quite costly when models are large, we instead ensem-
bled the four large coupled ensemble models that we trained for the four values of e = 3, 4, 6, 8.
Results are shown in table 4. We obtained a signiﬁcant gain by fusing two models and a quite small
one from any further fusion of three or four of them. To the best of our knowledge, these ensem-
bles of coupled ensemble networks outperform all state of the art implementations including other
ensemble-based ones at the time of publication of this work.

Table 4: Classiﬁcation error comparison with the state of the art, multiple model trainings.
System
SVHN #Params
SGDR WRN-28-10 3 runs × 3 snapshots
SGDR WRN-28-10 16 runs × 3 snapshots
DenseNet-BC ensemble of ensembles e = 6, 4
DenseNet-BC ensemble of ensembles e = 6, 4, 3
DenseNet-BC ensemble of ensembles e = 8, 6, 4, 3

C10+ C100+
16.64
3.25
16.21
3.14
15.13
2.72
15.04
2.68
15.05
2.73

329M
1752M
50M
75M
100M

-
-
1.42
1.42
1.41

9

To be submitted as a conference paper at ICLR 2018

4.8 PARAMETER USAGE

Figure 1 shows that for a given parameter count, coupled ensemble networks or ensembles of cou-
pled ensemble networks perform signiﬁcantly better for all parameter budgets. Our approach is
shown by the blue diamonds.

Figure 1: Comparison of parameter usage between different methods. Results on CIFAR-10 (top),
CIFAR-100 (middle) and SVHN (bottom) tasks. “DenseNet-BC”: single-branch (PyTorch) conﬁg-
uration; “Ours”: proposed multiple branch conﬁguration using DenseNet-BC as the basic block,
single training up to 25M parameters and ensembles of coupled ensembles beyond; SGDR-WRN:
snapshot ensembles with SGDR on Wide ResNets up to 110M parameters and ensembles of snap-
shot ensembles beyond; ”Other”: all other architectures mentioned in tables 3 and 4.

10

To be submitted as a conference paper at ICLR 2018

5 DISCUSSION

The proposed approach consists in replacing a single deep convolutional network by a number of
“basic blocks” which resemble standalone CNN models. The intermediate score vectors produced
by each of the basics blocks are coupled via a “fuse layer”. At training time, this is done by taking
an arithmetic average of their log-probabilites for the targets. At test time the score vectors are
averaged following the output from each score vector. Both of these aspects leads to a signiﬁcant
performance improvement over a single branch conﬁguration. This improvement comes at the cost
of a small increase in the training and prediction times. The proposed approach leads to the best
performance for a given parameter budget as can be seen in tables 3 and 4, and in ﬁgure 1.

The increase in training and prediction times is mostly due to the sequential processing of branches
during the forward and backward passes. The smaller size of the branches makes the data parallelism
on GPUs less efﬁcient. This effect is not as pronounced for larger models. This could be solved in
two ways. First, as there is no data dependency between the branches (before the averaging layer)
it is possible to extend the data parallelism to the branches, restoring the initial level of parallelism.
This can be done by implementing a parallel implementation of multiples 2D convolutions at the
same time. Second or alternatively, when multiple GPUs are used, it is possible to spread the
branches over the GPUs.

We have currently evaluated the coupled ensemble approach only on relatively small data sets. We
therefore plan to conduct experiments on ImageNet (Russakovsky et al., 2015) to check whether it
will work equally well on large collections.

ACKNOWLEDGEMENTS

This work has been partially supported by the LabEx PERSYVAL-Lab (ANR-11-LABX-0025-01).
Experiments presented in this paper were partly carried out using the Grid’5000 test-bed, supported
by a scientiﬁc interest group hosted by Inria and including CNRS, RENATER and several Universi-
ties as well as other organizations (see https://www.grid5000.fr).

REFERENCES

Amos, B. and Kolter, J. Z. (2017). A PyTorch Implementation of DenseNet. https://github.

com/bamos/densenet.pytorch. Accessed: June 2017.

Chollet, F. (2017). Xception: Deep learning with depthwise separable convolutions. In Proceedings

of the IEEE Conference on Computer Vision and Pattern Recognition.

Cires¸an, D., Meier, U., and Schmidhuber, J. (2012). Multi-column deep neural networks for image
In 2012 IEEE Conference on Computer Vision and Pattern Recognition, pages

classiﬁcation.
3642–3649.

Cires¸an, D. C., Meier, U., Gambardella, L. M., and Schmidhuber, J. (2011). Convolutional neural
In Proceedings of the 2011 In-
network committees for handwritten character classiﬁcation.
ternational Conference on Document Analysis and Recognition, ICDAR ’11, pages 1135–1139,
Washington, DC, USA.

Gastaldi, X. (2017). Shake-shake regularization. In International Conference on Learning Repre-

sentations. arXiv:1705.07485.

Hansen, L. K. and Salamon, P. (1990). Neural network ensembles. IEEE Transactions on Pattern

Analysis and Machine Intelligence, 12(10):993–1001.

He, K., Zhang, X., Ren, S., and Sun, J. (2016a). Deep residual learning for image recognition. In
2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR), pages 770–778.
arXiv:1512.03385.

He, K., Zhang, X., Ren, S., and Sun, J. (2016b). Identity Mappings in Deep Residual Networks,

pages 630–645.

11

To be submitted as a conference paper at ICLR 2018

Huang, G., Liu, Z., van der Maaten, L., and Weinberger, K. Q. (2017). Densely connected con-
volutional networks. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition.

Huang, G., Sun, Y., Liu, Z., Sedra, D., and Weinberger, K. Q. (2016). Deep Networks with Stochastic

Depth, pages 646–661.

Kawaguchi, K. (2016). Deep learning without poor local minima. In Advances in Neural Information

Processing Systems, pages 586–594.

Krizhevsky, A. and Hinton, G. (2009). Learning multiple layers of features from tiny images.

Krizhevsky, A., Sutskever, I., and Hinton, G. E. (2012). Imagenet classiﬁcation with deep convolu-
tional neural networks. In Pereira, F., Burges, C. J. C., Bottou, L., and Weinberger, K. Q., editors,
Advances in Neural Information Processing Systems 25, pages 1097–1105. Curran Associates,
Inc.

Lecun, Y., Bottou, L., Bengio, Y., and Haffner, P. (1998). Gradient-based learning applied to docu-

ment recognition. Proceedings of the IEEE, 86(11):2278–2324.

Loshchilov, I. and Hutter, F. (2017). SGDR: stochastic gradient descent with restarts. In Interna-

tional Conference on Learning Representations.

Netzer, Y., Wang, T., Coates, A., Bissacco, A., Wu, B., and Ng, A. Y. (2011). Reading digits in
In NIPS Workshop on Deep Learning and

natural images with unsupervised feature learning.
Unsupervised Feature Learning 2011.

Russakovsky, O., Deng, J., Su, H., Krause, J., Satheesh, S., Ma, S., Huang, Z., Karpathy, A., Khosla,
A., Bernstein, M., Berg, A. C., and Fei-Fei, L. (2015). ImageNet Large Scale Visual Recognition
Challenge. International Journal of Computer Vision (IJCV), 115(3):211–252.

Simonyan, K. and Zisserman, A. (2014). Very deep convolutional networks for large-scale image

recognition. CoRR, abs/1409.1556. Published at ICLR 2015.

Springenberg, J. T., Dosovitskiy, A., Brox, T., and Riedmiller, M. (2015). Striving for simplicity:

The all convolutional net. In International Conference on Learning Representations.

Szegedy, C., Liu, W., Jia, Y., Sermanet, P., Reed, S. E., Anguelov, D., Erhan, D., Vanhoucke, V., and
Rabinovich, A. (2015). Going deeper with convolutions. In Proceedings of the IEEE conference
on computer vision and pattern recognition, pages 1–9.

Xie, S., Girshick, R., Dollr, P., Tu, Z., and He, K. (2017). Aggregated residual transformations for
deep neural networks. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition.

Zagoruyko, S. and Komodakis, N. (2016). Wide residual networks. In Proceedings of the British

Machine Vision Conference 2016, BMVC 2016, York, UK, September 19-22, 2016.

Zhang, T., Qi, G.-J., Xiao, B., and Wang, J. (2017). Interleaved Group Convolutions for Deep Neural

Networks. In International Conference on Computer Vision.

Zhao, L., Wang, J., Li, X., Tu, Z., and Zeng, W. (2016). On the connection of deep fusion to

ensembling. arXiv preprint arXiv:1611.07718.

Zoph, B. and Le, Q. V. (2017). Neural architecture search with reinforcement learning. In Interna-

tional Conference on Learning Representations.

Zoph, B., Vasudevan, V., Shlens, J., and Le, Q. V. (2017). Learning transferable architectures for

scalable image recognition. arXiv preprint arXiv:1707.07012.

12

To be submitted as a conference paper at ICLR 2018

Supplementary Material

A IMPLEMENTATION

Figure 2 shows the common structure of the test (top) and train (bottom) versions of networks used
as basic blocks. Figure 3 shows how it is possible to place the averaging layer just after the last FC
layer of the basic block instances and before the SM layer which is then “factorized”. The e model
instances do not need to share the same architecture. Figure 3 shows how it is possible to place the
averaging layer just after the last FC layer, just after the SM (actually LSM (LogSoftMax), which is
equivalent to do a geometric mean of the SM values) layer, or just after the LL layer.

Figure 2: Versions of the base network. Top: test, bottom: train.

Figure 3: Test versions of coupled ensemble networks. Top: SM (classical) fusion, bottom: FC
fusion. AVG: averaging layer.

We reuse “basic blocks” from other groups (with appropriate credits, please let us know if any is
missing or requires updating) in their original form as much as possible both for efﬁciency and for
ensuring more meaningful comparisons. When available, we use the PyTorch implementations.

Each of the e branches is deﬁned by a parameter vector We containing the same parameters as
the original implementation. The global network is deﬁned by a parameter vector W which is a
concatenation of all the We parameter vectors. When training is done in the coupled mode and the
prediction is done in a separate mode or vice-versa, a dedicated script is used for splitting the W
vector into the We ones or vice-versa. In all coupled networks, for all train versions and for all test
version, the same global parameter vector W is used with the same split and deﬁning the same basic
block functions. This is how we can combine in any way all of the four possible training conditions
with all the three possible prediction conditions, even though not all of them are consistent or equally
efﬁcient.

The overall network architecture is determined by:

• the global hyper-parameter specifying the train versus test mode;

• the global hyper-parameter e specifying the number of branches;

• the global hyper-parameter specifying after which layer the AVG layer should be placed (FC, SM

or LL);

13

To be submitted as a conference paper at ICLR 2018

Figure 4: Train versions of coupled ensemble networks. Top: LL fusion, middle: SM fusion, bottom:
FC fusion.

• either one basic block to be replicated e times with its own hyper-parameters or a list of e basic

blocks, each with its own hyper-parameters.

B TEST TIME EQUIVALENCE BETWEEN FC AVERAGE AND LOGSOFTMAX

AVERAGE

Given branches E = E1, E2, ..Ee, each Ei produces a score vector of dimension C, where C is the
number of categories. An element of Ei is referenced as Ec
i , were c ∈ [1, C]. FC Average denotes
averaging the raw activations from each branch. LSM Average denotes averaging across branches,
after a LogSoftMax operation in applied on each branch activation vector, separately.
i=1 Ec
Case 1: FC average: Scoresc
i

F C = (cid:80)e

Case 2:

LogSof tM ax(Ec

n) = log

(cid:80)

exp(Ec
e)
c exp(Ec
e)
e) − log

= log exp(Ec

= Ec

e − Ze

(cid:88)

c

exp(Ec
e)

LSM = (cid:80)e

LSM average: Scoresc
e). Hence we
see that the LSM average score vector is a translated version of the FC average score vector. Also,
doing an arithmetic average of LogSoftMax values is equivalent to doing a geometric average of
SoftMax values. This holds during inference where we are interested only in the maximum value.

i=1 Zi, where Ze = log (cid:80)

C exp(Ec

i − (cid:80)e

i=1 Ec

C COMPARISON WITH Learnt ARCHITECTURES

In table 5, we compare the parameter usage and performance of the branched coupled ensembles
with model architectures that were recovered using meta learning techniques.

14

To be submitted as a conference paper at ICLR 2018

Table 5: Classiﬁcation error comparison with learnt architectures.

System
Neural Architecture Search v3 (Zoph and Le, 2017)
NASNet-A (Zoph et al., 2017)
DenseNet-BC L = 82 k = 10 e = 4
DenseNet-BC L = 88 k = 14 e = 4
DenseNet-BC L = 88 k = 20 e = 4

C10+ C100+
3.65
3.41
3.78
3.57
3.18

-
-
19.92
17.68
16.79

SVHN #Params
37.4M
3.3M
1.6M
3.5M
7.0M

-
-
1.62
1.55
1.57

D PERFORMANCE MEASUREMENT AND REPRODUCIBILITY ISSUES

When attempting to compare the relative performance of different methods, we face the issue of the
reproducibility of the experiments and of the statistical signiﬁcance of the observed difference be-
tween performance measures. Even for a same experiment, we identiﬁed the ﬁve following sources
of variation in the performance measure:

• Underlying framework for the implementation: we made experiments with Torch7 (lua) and with

PyTorch.

• Random seed for the network initialization.

• CuDNN non-determinism during training: GPU associative operations are by default fast but
non-deterministic. We observed that the results varies even for a same tool and the same seed. In
practice, the observed variation is as important as when changing the seed.

• Fluctuations associated to the computed moving average and standard deviation in batch normal-
ization: these ﬂuctuations can be observed even when training with the learning rate, the SGD
momentum and the weight decay all set to 0. During the last few epochs of training, their level of
inﬂuence is the same as with the default value of these hyper-parameters.

• Choice of the model instance chosen from training epochs:

the model obtained after the last
epoch, or the best performing model. Note that choosing the best performing model involves
looking at test data.

Regardless of the implementation, the numerical determinism, the Batch Norm moving average,
and the epoch sampling questions, we should still expect a dispersion of the evaluation measure
according to the choice of the random initialization since different random seeds will likely lead
to different local minima. It is generally considered that the local minima obtained with “properly
designed and trained” neural networks should all have similar performance (Kawaguchi, 2016). We
do observe a relatively small dispersion (quantiﬁed by the standard deviation below) conﬁrming this
hypothesis. This dispersion may be small but it is not negligible and it complicates the comparisons
between methods since differences in measures lower than their dispersions is likely to be non-
signiﬁcant. Classical statistical signiﬁcance tests do not help much here since differences that are
statistically signiﬁcant in this sense can be observed between models obtained just with different
seeds (and even with the same seed), everything else being kept equal.

Experiments reported in this section gives an estimation of the dispersion in the particular case of a
moderate scale model. We generally cannot afford doing a large number of trials for larger models.

We tried to quantify the relative importance of the different effects in the particular case of DenseNet-
BC with L = 100, k = 12 on CIFAR 100. Table 6 shows the results obtained for the same exper-
iment in the four groups of three rows. We tried four combinations corresponding to the use of
Torch7 versus PyTorch and to the use of the same seed versus the use of different seeds. For each of
these conﬁguration, we used as the performance measure: (i) the error rate of the model computed
at the last epoch or (ii) the average of the error rate of the models computed at the last 10 epochs,
(iii) the error rate of the model having the lowest error rate over all epochs. For these 2 × 2 × 3
cases, we present the minimum, the median, the maximum and the mean±standard deviation over
10 measures corresponding to 10 identical runs (except for the seed when indicated). Additionally,
in the case of the average of the error rate of the models computed at the 10 last epochs, we present
the root mean square of the standard deviation of the ﬂuctuations on the last 10 epochs (which is the
same as the square root of the mean of their variance). We make the following observations:

15

To be submitted as a conference paper at ICLR 2018

• There does not seem to be a signiﬁcant difference between Torch7 and PyTorch implementations;
• There does not seem to be a signiﬁcant difference between using a same seed and using different
seeds; the dispersion observed using the same seed (with everything else being equal) implies that
there is no way to exactly reproduce results;

• There does not seem to be a signiﬁcant difference between the means over the 10 measures com-
puted on the single last epoch and the means over the 10 measures computed on the last 10 epochs;
• The standard deviation of the measures computed on the 10 runs is slightly but consistently
smaller when the measures are computed on the last 10 epochs than when they are computed
on the single last epoch; this is the same for the difference between the best and the worst mea-
sures; this was expected since averaging the measure on the last 10 epochs reduces the ﬂuctuations
due to the moving average and standard deviation computed in batch normalization and possibly
too the the random ﬂuctuations due to the ﬁnal learning steps;

• The mean of the measures computed on the 10 runs is signiﬁcantly lower when the measure is
taken at the best epoch than when they are computed either on the single last epoch or on the last
10 epochs. This is expected since the minimum is always below the average. However, presenting
this measure involves using the test data for selecting the best model.

Table 6: Performance measurement and reproducibility issues. Statistics on 10 runs.

Seeds
diff.
diff.
diff.
same
same
same
diff.
diff.
diff.
same
same
same
diff.
diff.
diff.
diff.
diff.
diff.

Impl.
PyT.
PyT.
PyT.
PyT.
PyT.
PyT.
LuaT.
LuaT.
LuaT.
LuaT.
LuaT.
LuaT.
PyT.
PyT.
PyT.
PyT.
PyT.
PyT.

Last
1
10
best
1
10
best
1
10
best
1
10
best
1
10
best
1
10
best

L
100
100
100
100
100
100
100
100
100
100
100
100
82
82
82
100
100
100

k
12
12
12
12
12
12
12
12
12
12
12
12
8
8
8
12
12
12

e Min. Med. Max. Mean±SD RMS(SD)
1
1
1
1
1
1
1
1
1
1
1
1
3
3
3
4
4
4

22.89±0.21
22.87±0.17
22.54±0.24
23.06±0.23
23.04±0.22
22.71±0.18
22.90±0.20
22.86±0.20
22.49±0.18
22.82±0.34
22.87±0.30
22.54±0.29
21.49±0.15
21.45±0.11
21.14±0.14
17.65±0.18
17.66±0.14
17.45±0.16

22.64
22.67
22.13
22.77
22.81
22.44
22.55
22.55
22.17
22.33
22.47
22.24
21.27
21.24
20.84
17.24
17.37
17.11

23.22
23.14
22.91
23.55
23.49
23.02
23.11
23.08
22.75
23.58
23.51
23.24
21.70
21.63
21.30
17.86
17.81
17.66

22.80
22.83
22.56
23.05
22.98
22.67
22.94
22.89
22.52
22.82
22.92
22.51
21.44
21.46
21.18
17.71
17.67
17.46

n/a
0.13
n/a
n/a
0.11
n/a
n/a
0.12
n/a
n/a
0.12
n/a
n/a
0.12
n/a
n/a
0.11
n/a

Following these observations, we propose a method for ensuring the best reproducibility and the
fairest comparisons. Choosing the measure as the minimum of the error rate for all models computed
during the training seems neither realistic nor a good practice since we have no way to know which
model will be the best one without looking at the results (cross-validation cannot be used for that)
and this is like tuning on the test set. Even though this is not necessarily unfair for system comparison
if the measures are done in this condition for all systems, this does introduce a bias for the absolute
performance estimation. Using the error rate at the last iteration or at the 10 last iteration does not
seem to make a difference in the mean but the standard deviation is smaller for the latter, therefore
this one should be preferred when a single experiment is conducted. We also checked that using
the 10 or the 25 last epochs does not make much difference (learning at this point does not seem to
lead to further improvement). A value different from 10 can be used and this is not critical. In all
the CIFAR experiments reported in this paper, we used the average of the error rate for the models
obtained at the last 10 epochs as this should be (slightly) more robust and more conservative. The
case for SVHN experiments is slightly different since there is a much smaller number of much bigger
epochs; we used the last 4 iterations in this case.

These observations have been made in a quite speciﬁc case but the principle and the conclusions
(use of the average of the error rate from the last epochs should lead to more robust and conservative

16

To be submitted as a conference paper at ICLR 2018

results) are likely to be general. Table 6 also shows the results for a coupled ensemble network of
comparable size and for a coupled ensemble network four times bigger. Similar observations can be
made and, additionally, we can observe that both the range and the standard deviations are smaller.
This might be because an averaging is already made between the branches leading to a reduction of
the variance. Though this requires conﬁrmation at larger scales, coupled ensemble networks might
lead to both a better and a more stable performance.

17

7
1
0
2
 
p
e
S
 
8
1
 
 
]

V
C
.
s
c
[
 
 
1
v
3
5
0
6
0
.
9
0
7
1
:
v
i
X
r
a

To be submitted as a conference paper at ICLR 2018

COUPLED ENSEMBLES OF NEURAL NETWORKS

Anuvabh Dutt
Univ. Grenoble Alpes, CNRS, Grenoble-INP, LIG, F-38000 Grenoble France
Anuvabh.Dutt@univ-grenoble-alpes.fr

Denis Pellerin
Univ. Grenoble Alpes, CNRS, Grenoble-INP, GIPSA-Lab, F-38000 Grenoble France
Denis.Pellerin@gipsa-lab.grenoble-inp.fr

Georges Qu´enot
Univ. Grenoble Alpes, CNRS, Grenoble-INP, LIG, F-38000 Grenoble France
Georges.Quenot@imag.fr

ABSTRACT

We investigate in this paper the architecture of deep convolutional networks.
Building on existing state of the art models, we propose a reconﬁguration of the
model parameters into several parallel branches at the global network level, with
each branch being a standalone CNN. We show that this arrangement is an efﬁcient
way to signiﬁcantly reduce the number of parameters without losing performance
or to signiﬁcantly improve the performance with the same level of performance.
The use of branches brings an additional form of regularization. In addition to
the split into parallel branches, we propose a tighter coupling of these branches
by placing the “fuse (averaging) layer” before the Log-Likelihood and SoftMax
layers during training. This gives another signiﬁcant performance improvement,
the tighter coupling favouring the learning of better representations, even at the
level of the individual branches. We refer to this branched architecture as “cou-
pled ensembles”. The approach is very generic and can be applied with almost
any DCNN architecture. With coupled ensembles of DenseNet-BC and parameter
budget of 25M, we obtain error rates of 2.92%, 15.68% and 1.50% respectively
on CIFAR-10, CIFAR-100 and SVHN tasks. For the same budget, DenseNet-BC
has error rate of 3.46%, 17.18%, and 1.8% respectively. With ensembles of cou-
pled ensembles, of DenseNet-BC networks, with 50M total parameters, we obtain
error rates of 2.72%, 15.13% and 1.42% respectively on these tasks.

1

INTRODUCTION

The design of early convolutional architectures (CNN) involved choices of hyper-parameters such
as: ﬁlter size, number of ﬁlters at each layer, and padding (Lecun et al., 1998; Krizhevsky et al.,
2012). Since the introduction of the VGGNet (Simonyan and Zisserman, 2014) the design has
moved towards following a template: ﬁxed ﬁlter size of 3 × 3 and N features maps, down-sample to
half the input resolution only by the use of either maxpool or strided convolutions (Springenberg
et al., 2015), and double the number the computed feature maps following each down-sampling
operation. This philosophy is used by state of the art models such as ResNet (He et al., 2016b) and
DenseNet (Huang et al., 2017). The last two architectures extended the template to include the use
of “skip-connections” between non-contiguous layers.

Our work extends this template by adding another element, which we refer to as “coupled en-
sembling”.
In this set-up, the network is decomposed into several branches, each branch being
functionally similar to a complete CNN (and able to fully do the classiﬁcation task alone, gen-
erally with a lower performance). The proposed template achieves performance comparable to
state of the art models with a signiﬁcantly lower parameter count. The proposed modiﬁcation

1

To be submitted as a conference paper at ICLR 2018

is simple to implement and we provide a wrapper to compose different standard architectures at:
https://github.com/vabh/coupled_ensembles.

In this paper, we make the following contributions: (i) we show that given a parameter budjet,
splitting a large network into an ensemble of smaller parallel branches of the same type, and jointly
training them performs better or at par; (ii) when a ﬁnal SoftMax (SM) layer is used during the
prediction step, we show that ensemble fusion works better when averaging is done before this
layer than when it is done after; (iii) when a ﬁnal Log-Likelihood (LL) layer is used during the
training step, we show that ensemble fusion of branches works better when the fusion is done before
this layer than when it is done after; (iv) combining all these elements, we signiﬁcantly improved
the performance and/or signiﬁcantly reduce the parameter count of state-of-the-art neural network
architectures on CIFAR and SVHN data sets. (v) We show that such multi-branch networks can be
further ensembled at a higher level still producing a signiﬁcant performance gain.

This paper is organised as follows: in section 2, we discuss related work; in section 3, we introduce
the concept of coupled ensembles and the motivation behind the idea; in section 4, we present the
evaluation of the proposed approach and compare it with the state of the art; and we conclude and
discuss future work in section 5.

2 RELATED WORK

Multi-column architectures. The network architecture that we propose has strong similarities
with Cires¸an’s Neural Networks Committees (Cires¸an et al., 2011) and Multi-Column Deep Neural
Network (MCDNN) (Cires¸an et al., 2012), which are a type of ensemble of networks where the
“committee members” or “DNN columns” correspond to our basic block instances (or branches).
However, our coupled ensemble networks differ as following: (i) we train a single model which is
composed of sub-networks, while they train each member or column separately. (ii) we consider a
coupled ensemble of smaller networks for improving the performance of a network, given a budget
of parameters for the entire model. This is contrary to improving it by utilising multiple models of
ﬁxed size and therefore multiplying the overall size (though both are not exclusive); (iii) we consider
placing the averaging (AVG) layer, not only completely at the end of the network but also before
the Log-Likelihood (LL) layer during training and before the Soft-Max (SM) layer during training
and/or during prediction; (iv) we used the same preprocessing for all branches while they consid-
ered different preprocessing (data augmentation) blocks for different members or different subsets
of columns; we consider doing this also in the future.

Multi-branch architectures. Multi-branch architectures have been very successful in several vision
applications (He et al., 2016a; Szegedy et al., 2015). Recently, modiﬁcations have been proposed
(Xie et al., 2017; Chollet, 2017) for these architectures using the concept of “grouped convolutions”,
in order to factorize spatial feature extraction and channel features. These modiﬁcations additionally
advocate the use of template building blocks stacked together to form the complete model. This
modiﬁcation is at the level of the building blocks of their corresponding base architectures: ResNet
and Inception respectively. In contrast we propose a generic modiﬁcation of the structure of the
CNN at the global model level. This includes a template in which the speciﬁc architecture of a
“basic block” is speciﬁed, and then this “basic block” is replicated as parallel branches to form the
ﬁnal composite model.

To further improve the performance of such architectures, Shake-Shake regularization (Gastaldi,
2017) proposes a stochastic mixture of each of the branches and has achieved good results on the
CIFAR datasets. However, the number of epochs required for convergence is much higher compared
to the base model. Additionally, the technique seems to depend on the batch size. In contrast, we
apply our method using the exact same hyper-parameters as used in the underlying CNN.

Zhao et al. (2016) investigate the usage of parallel paths in a ResNet, connecting layers to allow
information exchange between the paths. However this requires modiﬁcation at a local level of each
of the residual blocks. In contrast, our method is a generic rearrangement of a given architecture’s
parameters, which does not introduce additional choices. Additionally, we empirically conﬁrm that
our proposed conﬁguration leads to an efﬁcient usage of parameters.

Neural network ensembles. Ensembling is a reliable technique to increase the performance of
models for a task. Due to the presence of several local minima, multiple trainings of the exact

2

To be submitted as a conference paper at ICLR 2018

same neural network architecture can reach a different distribution of errors on a per-class basis.
Hence, combining their outputs lead to improved performance on the overall task. This was observed
very early (Hansen and Salamon, 1990) and is now commonly used for obtaining top results in
classiﬁcation challenges, despite the increase in training and prediction cost. Our proposed model
architecture is not an ensemble of independent networks given that we have a single model made
up of parallel branches that is trained. This is similar in spirit to the residual block in ResNet
and ResNeXt, and to the inception module in Inception but is done at the full network level. We
would like to emphasize here that “arranging” a given budget of parameters into parallel branches
leads to an increase in performance (as shown in tables 1, 2 and 3). Additionally, the classical
ensembling approach can still be applied for the fusion of independently trained coupled ensemble
networks where it produces a signiﬁcant performance improvement (as shown in table 4)

3 COUPLED ENSEMBLES

TERMINOLOGY

For the following discussion, we deﬁne some terms:

• Branch: the proposed model comprises several branches. Each branch takes as input a data point
and produces a score vector corresponding to the target classes. Current design of CNNs are
referred to as single-branch. The number of branches is denoted by e.

• Basic block: the model architecture used to form a branch. In our experiments, we use DenseNet-

BC and ResNet with pre-activation as basic blocks.

• Fuse Layer:

the operation used to combine each of the parallel branches which make up our
model. In our experiments, each of the branches are combined by taking the average of each of
their predicted log probabilities over the target classes. Section 4.4 explores different choices of
operations for the fuse layer.

We consider a classiﬁcation task in which individual samples are always associated to exactly
one class, labelled from a ﬁnite set. This is the case for CIFAR (Krizhevsky and Hinton, 2009),
SVHN (Netzer et al., 2011) and ILSVRC (Russakovsky et al., 2015) tasks. In theory, this should
work for other tasks as well (for example, segmentation, object detection, etc.).

We consider neural network models whose last layer outputs a score vector of the same dimension
as the number of target classes. This is usually implemented as a linear layer and referred to as
a fully connected (FC) layer. This layer can be followed by a SoftMax (SM) layer to produce a
probability distribution over the target classes. During training, this is followed by a loss layer, for
example, negative log-likelihood (LL). This is the case for all recent network architectures for image
classiﬁcation1 (Krizhevsky et al., 2012; Simonyan and Zisserman, 2014; Szegedy et al., 2015; He
et al., 2016a; Xie et al., 2017; Huang et al., 2016; Zagoruyko and Komodakis, 2016; Huang et al.,
2017). The differences among them is related to what is present before the last FC layer. We are
agnostic to this internal setup (however complex it may or may not be) because the resulting “basic
block” always takes an image as input and produces a vector of N values (one for each target class)
as output, parametrized by a tensor W .

In the case of ensemble predictions, fusion is usually done by computing the individual predic-
tions separately for e model instances and then averaging them. Each of the instances are trained
seperately. This is functionally equivalent to predicting with a “super-network” including the e in-
stances as parallel branches with a ﬁnal averaging (AVG) layer on top. Such super-networks are
generally not implemented because the branch instances often already correspond to the maximum
memory capacity of GPUs. The remaining AVG layer operation can be implemented separately.
Alternatively, it is possible to place the averaging layer just after the last FC layer of the basic block
instances and before the SM layer, which is then “factorized”.

1Though all these networks actually do have a FC layer before the SM one, the last layer need not be a linear
layer, as long as it produces one value for each target label. We will refer to the output of each basic block as
“FC”. Similarly, the proposed method may be easily adapted to multi-label classiﬁcation (i.e. considering non-
exclusive classes) by simply replacing the SM (and possibly also the LL) layer(s) by any variant(s) appropriate
for multi-label classiﬁcation. Again, we will refer to their output as “SM” and “LL”.

3

To be submitted as a conference paper at ICLR 2018

In our setup, a model is composed of parallel branches and each branch produces a score vector for
the target categories. We explore three options to combine these vectors during training:

• Activation (FC) average.

• Probability (SM) average (in practice we do an arithmetic average of log-probabilities).

• Log Likelihood (LL) average (average of the loss of each branch).

We investigate these options in section 4.4. Note that for inference, averaging the FC layer activa-
tions is equivalent to averaging the LogSoftMax values (or to a geometric average of the softmax
values, see section B of supplementary material).

This transformation of having multiple branches, and combining the branch activations by averaging
the log probabilites that they predict for the target categories, leads to a performance improvement,
with a lower parameter count, in all our experiments (see section 4). The parameter vector W of this
composite branched model is the concatenation of the parameter vectors We of the e basic blocks
with 1 ≤ i ≤ e. All parameters are in the “basic blocks” as the “fuse layer” does not contain any
parameters. The e model instances do not really need to share the same architecture.

Three training versions may be considered depending upon whether the “fuse layer” is placed after
the FC, after the SM or after the LL layer. All the instances are trained simultaneously trough a
single loss function and the W parameter vector is obtained in a single training phase. In practice,
in the ﬁrst and the third versions, the SM and LL layers are replaced by a single Cross-Entropy
(CE) layer as this is numerically more stable. Similarly, in the second and intermediate case, a
LogSoftMax (LSM) layer is used instead of the regular SM layer before the arithmetic averaging
(while removing the Log operation in the LL layer). This is equivalent to replacing the arithmetic
average by a geometric one with the regular SM and LL layers. The training can be done in four
different ways: the three coupled ways correspoding to the “fuse layer” plus the the one in which
all basic blocks are trained separately in e independent trainings. Regardless of how the training of
the basic blocks has been performed, it is possible to use any of the two coupled ways for making
‘coupled prediction’ and it is also possible to use the individual basic blocks for making e ‘individual
predictions’. Not all of these combinations are expected to be consistent or equally efﬁcient but all
can be implemented and evaluated as shown in section 4.4.

4 EXPERIMENTS

4.1 DATASETS

We evaluate our proposed architecture on the CIFAR (Krizhevsky and Hinton, 2009) and SVHN
(Netzer et al., 2011) data sets. CIFAR-10 and CIFAR-100 consist each of 50,000 training images
and 10,000 test images, distributed into 10 and 100 categories respectively. SVHN consists of
73,257 training images, 531,131 “easy” training images (we use both for training) and 26,032 testing
images, distributed into 10 categories. Each image from these datasets is of size 32×32 pixels.

4.2 EXPERIMENTAL SET-UP

All hyper parameters are set according to the original descriptions of the “basic block” that is used.
This may not be the optimal setting in our case (especially the learning rate decay schedule) but we
do not alter them, so as to not introduce any bias in comparisons.

For CIFAR-10, CIFAR-100 and SVHN, the input image is normalised by subtracting by the mean
image and dividing by the standard deviation. During training on CIFAR datasets, standard data
augmentation is used, which comprises random horizontal ﬂips and random crops. For SVHN, no
data augmentation is used. However, a dropout ratio of 0.2 is applied in the case of DenseNet when
training on SVHN. Testing is done after normalising the input in the same way as during training.

All error rates are given in percentages and correspond to an average computed on the last 10 epochs
for CIFAR and on the last 4 epochs for SVHN. This measure is more conservative than the one used
by the DenseNet authors (see supplementary material, section D). For DenseNet-BC, Amos and
Kolter (2017)’s PyTorch implementation has been used. All execution times were measured using a

4

To be submitted as a conference paper at ICLR 2018

single NVIDIA 1080Ti GPU with the optimal micro-batch2. Experiments in section 4.3, 4.4 are done
on the CIFAR-100 data set with the “basic block” being DenseNet-BC, depth L = 100, growth rate
k = 12. For experiments in Section 4.5, we consider this same conﬁguration (with a single branch)
as our baseline reference point.

4.3 COMPARISON WITH SINGLE BRANCH AND INDEPENDENT ENSEMBLES

A natural point of comparison of the proposed branched architecture is with an ensemble of indepen-
dent models. Rows 2 (coupled training with SM averaging) and 4 (no averaging) in Table 1 present
the results of these two cases respectively. Row 4 shows the error rate obtained from averaging the
predictions of 4 identical models, each of which were trained separately. We see that even though
the total number of trainable parameters involved is exactly the same, a jointly trained branched
conﬁguration gives a much lower test error (17.61 vs. 18.42 with 4 predictions fused at the FC level
in both cases).

The next point of comparison is with a single branch model comprising a similar number of pa-
rameters as the multi branch conﬁguration. The choice of single branch models has been done by:
increasing k while keeping L constant, by increasing both k and L, or by increasing L while keep-
ing k constant. The last three rows of Table 1 show that the error from the multi branch model is
considerably lower, as compared to a single branch model (17.61 vs. 20.01, with 4 predictions fused
at the FC level).

These observations show that the arranging a given budget of parameters into parallel branches is
efﬁcient in terms of parameters, as compared to having a large single branch or multiple independent
trainings. In Section 4.5 we analyse the relation between the number of branches and the model
performance.

4.4 CHOICE OF FUSE LAYER OPERATION

In this section, we compare the performance of our proposed branched model for different choices
for the positioning of the “fuse layer” (see section 3). Experiments are carried out to evaluate the best
training and prediction fusion combinations. We consider two branched models with e = 2, e = 4,
trained in the following conditions: training with fusion after the LL layer, after the SM layer, or
after the FC layer.

Table 1 shows the performance of the differently trained systems for different prediction conﬁgu-
rations: individual average performance of the trained instances (without fusion) and performance
of the ensemble system with fusion after the SM layer or after the FC layer. Note that this ta-
ble includes models with parameters obtained using different training methods . We can make the
following observations:

• The Avg. FC training with separate predictions (in red) does not work well. This is expected since
a similar FC average may be reached with quite unrelated FC instances. The Avg. FC training
with Avg. SM prediction (in red) works a bit better but is still not good because the non-linearity
of the SM layer distorts the FC average. Indeed, the consistent Avg. FC training with Avg. FC
prediction works quite well though it does not yield the best performance.

• The Avg. FC prediction works at least as well and often signiﬁcantly better than the Avg. SM
prediction whatever the training choice is. This can be explained by the fact that the SM layer
compresses values for probabilities close to 0 and 1 while the values remain more spread and
transmit more information at the FC layer, even for different training conditions.

• The average error rate of each of the “basic blocks” trained jointly in coupled ensembles with SM
fusion is signiﬁcantly lower than the error rate of the individual instances trained separately. This
indicates that the coupling not only forces them to learn complementary features as a group but
also to better learn individually. Averaging the log probabilities forces the network to continuously
update all branches so as to be consistent with each other. This provides a stronger gradient
signal. Additionally, the training loss remains higher compared to single branch models, serving
as a regularizer. The error gradient that is back-propagated from the fuse layer is the same for all

2The micro-bath denotes the number of images samples that were processed in one batch on the GPU so as

to have the best throughput. In practice, minibatch (for parameter update) = n×microbatch

5

To be submitted as a conference paper at ICLR 2018

Table 1: Coupled Ensembles of DenseNet-BCs versus a single model of comparable complexity and
study of training / prediction fusion combinations. Top: e = 2, bottom: e = 4. Performance is given
as the top-1 error rate (mean±standard deviation for the individual branches) on the CIFAR-100
data set with standard data augmentation. Columns “L” and “k” indicate the DenseNet-BC hyper-
parameter values of the “basic block”. Column “e” indicates the number of branches. Column
“Avg.” indicates the type of “fuse layer” during training: “none” for separate trainings (classical
ensembling), “FC”, “SM” and “LL” for fusion (arithmetic averaging) after the FC, SM and LL lay-
ers respectively (not applicable for e = 1). Column “Individual” gives the performance for the
individual “basic blocks” evaluated separately; Columns “FC” and “SM” give the performance with
fusion (arithmetic averaging) during prediction done after the FC and SM layers respectively. The
last three columns give the total number of parameters of the model, the duration of a training itera-
tion (50,000 images) and the prediction time per test image (in batch mode). (*) See supplementary
material, section D; The average and standard deviations are computed here for the independent
trainings (comprising 2 and 4 models respectively.).

L
100
100
100
100
100
124
148

L
100
100
100
100
100
154
220

k
12
12
12
12
17
14
12

k
12
12
12
12
25
17
12

e Avg.
FC
2
SM
2
LL
2
none
2
n/a
1
n/a
1
n/a
1

e Avg.
FC
4
SM
4
LL
4
none
4
n/a
1
n/a
1
n/a
1

Individual
52.68±22.95
22.17±0.32
22.78±0.08
23.13±0.15(*)
21.22±0.12
21.75±0.10
20.80±0.06

Individual
74.36±26.28
22.29±0.11
22.83±0.18
23.13±0.09(*)
20.61±0.01
20.02±0.10
20.01±0.12

FC
22.25
19.06
19.33
20.44
n/a
n/a
n/a

FC
22.55
17.61
18.21
18.42
n/a
n/a
n/a

SM Params Epoch(s) Test(ms)
28.78
19.43
19.91
20.44
n/a
n/a
n/a

1.60M
1.60M
1.60M
1.60M
1.57M
1.55M
1.56M

0.98
0.98
0.98
0.98
0.67
0.77
0.90

174
174
174
171
121
135
159

SM Params Epoch(s) Test(ms)
31.92
17.68
18.92
18.85
n/a
n/a
n/a

3.20M
3.20M
3.20M
3.20M
3.34M
3.29M
3.15M

2.00
2.00
2.00
2.00
0.8
1.3
1.5

402
402
402
341
164
245
326

branches, and this gradient depends on the combined predictions. This means that at every step
all branches act complementary to the other branches’ weight updates.

• All ensemble combinations except those based on the Avg. FC training do signiﬁcantly better
than a single network of comparable size and same depth. For a global network size of about
1.6M (resp. 3.2M) parameters, the error rate decreases from 20.80 (resp. 20.01) for the best
single instance combination to 19.06 (−1.74) with two instances (resp. 17.61 (−2.40) with four
instances).

• The best combination seems to be Avg. SM for training with Avg. FC for prediction.
• The branched model with e = 4 and Avg. SM for the “fuse layer” has the same performance as
a DenseNet-BC (L = 250, k = 24) model (Huang et al., 2017), which has about 5 times more
parameters (15.3M versus 3.2M).

All the following experiments have Avg. SM for the training “fuse layer’ in the branched models.

4.5 CHOICE OF THE NUMBER OF BRANCHES

In this section, we investigate the optimal number of branches e for a given model parameter budget.
We evaluate on CIFAR-100, with DenseNet-BC as the “basic block”, and parameter budget equal
to 0.8M parameters (this is the number of parameters in DenseNet-BC (L = 100, k = 12)). In-
deed, the optimal number of instances e is likely to depend upon the network architecture, upon the
parameter budget and upon the data set but this gives at least one reference. This was investigated
again with larger models, and the results are in table 3 (last four rows).

6

To be submitted as a conference paper at ICLR 2018

Table 2: Different number of branches, e for a ﬁxed parameter count. The models are trained on
CIFAR-100 with standard data augmentation. See table 1 caption for the meaning of row and column
labels. When applicable (e > 1), “fuse layer” is SM Avg. (*) Average and standard deviation on 10
trials with different seeds; Huang et al. (2017) reports 22.27, see supplementary material, section D.

L
100
76
88
94
100
70
82
88
94
64
70
58
64
58
64

k
12
10
9
8
8
9
8
7
7
8
8
7
7
6
6

e
1
2
2
2
2
3
3
3
3
4
4
6
6
8
8

Individual
22.87±0.17(*)
25.58±0.20
25.15±0.31
25.72±0.20
25.42±0.20
26.67±0.40
26.47±0.17
26.92±0.41
26.50±0.12
28.58±0.59
27.65±0.48
30.11±0.53
30.65±0.62
32.15±0.00
31.52±0.38

FC
n/a
21.66
21.87
21.95
21.87
21.10
21.25
22.09
21.95
22.44
21.50
23.87
23.08
25.95
24.42

SM Params Epoch(s) Test(ms)
n/a
22.17
22.19
22.22
22.07
21.24
21.46
22.49
22.35
22.58
22.12
24.22
23.36
25.70
24.69

800k
720k
747k
666k
737k
773k
800k
698k
775k
719k
828k
718k
840k
722k
843k

0.51
0.63
0.71
0.69
0.75
0.77
0.85
0.92
0.98
0.88
0.94
1.08
1.20
1.35
1.51

86
103
119
115
126
129
141
148
160
142
156
179
198
219
250

Table 2 shows the performance for different conﬁgurations of branches e, depth L, and growth rate
k. One difﬁculty is that DenseNet-BC parameter counts are strongly quantiﬁed according to the L
and k values (L has to be a multiple of 6 modulo 4) and, additionally, to the e value in the coupled
ensemble version. This is even more critical in moderate size models like the 800K one targeted
here. We selected model conﬁgurations with parameters just below the target for making a fair
comparison. A few models have slightly more parameters so that some interpolation can be done
for possibly more accurate comparisons. We can make the following observations:

• In the considered case (DenseNet-BC, CIFAR-100 and 800K parameters), the optimal number of
branches is e = 3, L = 70, k = 9. With these parameters, the error rates decreases from 22.87
for the regular (L = 100, k = 12) DenseNet-BC model to 21.10 (−1.77).

• Using 2 to 4 branches yields a signiﬁcant performance gain over the classical (single branch,
e = 1) case, and even over the original performance of 22.27 reported for the (L = 100, k = 12)
DenseNet-BC (see supplementary material, section D).
• Using 6 or 8 branches performs signiﬁcantly less well.
• Slightly varying the L, k and e hyper-parameters around their optimal value does not lead to a
signiﬁcant performance drop, showing that the coupled ensemble approach and the DenseNet-BC
architecture are quite robust relatively to these choices.

• The gain in performance comes at the expense of an increased training and prediction times even
though the model size does not change. This is due to the use of smaller values of k that prevents
good parallelism efﬁciency. This increase is relatively smaller with bigger networks.

The same experiment was done on a validation set with a 40k/10k random split of the CIFAR-
100 training set and we could draw the same conclusions from there; they led to predict that the
(L = 82, k = 8, e = 3) combination should be the best one on the test set. The (L = 70, k = 9, e =
3) combination appears to be slightly better here but the difference is probably not statistically
signiﬁcant.

4.6 COMPARISON WITH THE STATE OF THE ART

We have evaluated the coupled ensemble network approach with networks of various sizes. We used
again Huang et al. (2017)’s DenseNet-BC architecture as the “basic block” since this was the current
state of the art or very close to it at the time we started these experiments. We used Amos and Kolter
(2017)’s PyTorch DenseNet-BC implementation both for the multi-branch (coupled ensembles) and

7

To be submitted as a conference paper at ICLR 2018

single-branch (classical) experiments. We also evaluated the approach using He et al. (2016b)’s
ResNet with pre-activation as the basic block to check if the coupled ensemble approach works well
with other architectures.

Table 3 reports in the upper part the results obtained by the current best systems (see section 2 for
references) and the results obtained with our coupled ensembles approach in the lower part. All
results presented in this table correspond to the training of a single, possibly big, network. Even
if ensembles are considered, they are always coupled as described in section 3 and trained as a
single global network. A further level of ensembling involving multiple trainings is considered in
section 4.7. Results are presented on the CIFAR 10 and 100 data set with standard data augmentation
and on SVHN using the extra training data.

Table 3: Classiﬁcation error comparison with the state of the art, for a single model.

SVHN #Params

System
ResNet L = 110 k = 64
ResNet stochastic depth L = 110 k = 64
ResNet stochastic depth L = 1202 k = 64
ResNet pre-activation L = 164 k = 64
ResNet pre-activation L = 1001 k = 64
DenseNet L = 100 k = 24
DenseNet-BC L = 100 k = 12 (Torch)
DenseNet-BC L = 250 k = 24 (Torch)
DenseNet-BC L = 190 k = 40 (Torch)
Shake-Shake C10 Model S-S-I
Shake-Shake C100 Model S-E-I
Snapshot Ensemble DenseNet-40 (α0 = 0.1)
Snapshot Ensemble DenseNet-40 (α0 = 0.2)
Snapshot Ensemble DenseNet-100 (α0 = 0.2)
SGDR WRN-28-10 Loshchilov and Hutter (2017)
SGDR WRN-28-10 3 snapshots
ResNeXt-29, 8×64d Xie et al. (2017)
ResNeXt-29, 16×64d Xie et al. (2017)
DFN-MR2 Zhao et al. (2016)
DFN-MR3 Zhao et al. (2016)
IGC-L450M2 Zhang et al. (2017)
IGC-L32M26 Zhang et al. (2017)
ResNet pre-activation L = 65 k = 64 e = 2
ResNet pre-activation L = 164 k = 64 e = 2
ResNet pre-activation L = 164 k = 64 e = 4
DenseNet-BC L = 100 k = 12 e = 1
DenseNet-BC L = 112 k = 16 e = 1
DenseNet-BC L = 130 k = 20 e = 1
DenseNet-BC L = 160 k = 24 e = 1
DenseNet-BC L = 166 k = 32 e = 1
DenseNet-BC L = 190 k = 40 e = 1
DenseNet-BC L = 82 k = 8 e = 3
DenseNet-BC L = 82 k = 10 e = 4
DenseNet-BC L = 88 k = 14 e = 4
DenseNet-BC L = 88 k = 20 e = 4
DenseNet-BC L = 94 k = 26 e = 4
DenseNet-BC L = 118 k = 35 e = 3
DenseNet-BC L = 106 k = 33 e = 4
DenseNet-BC L = 76 k = 33 e = 6
DenseNet-BC L = 64 k = 35 e = 8

C10+ C100+
6.61
5.25
4.91
5.46
4.92
3.74
4.51
3.62
3.46
2.86
-
4.99
4.84
3.44
4.03
3.51
3.65
3.58
3.94
3.57
3.25
3.31
5.26
4.24
3.96
4.77
4.47
4.06
3.98
4.03
4.04
4.30
3.78
3.57
3.18
3.01
2.99
2.99
2.92
3.13

-
24.98
-
24.33
22.71
19.25
22.27
17.60
17.18
-
15.85
23.34
21.93
17.41
19.57
17.75
17.77
17.31
19.25
19.00
19.25
18.75
23.24
19.92
18.84
22.87
20.73
19.03
18.92
20.03
18.19
21.25
19.92
17.68
16.79
16.24
16.18
15.68
15.76
15.95

-
-
-
-
-
1.59
1.76
-
-
-
-
1.64
1.73
-
-
-
-
-
1.51
1.55
-
1.56
-
-
-
1.79
1.83
1.84
1.88
1.88
1.79
1.66
1.62
1.55
1.57
1.50
1.50
1.53
1.50
1.50

1.7M
1.7M
10.2M
1.7M
10.2M
27.2M
0.80M
15.3M
25.6M
26.2M
34.4M
6.0M
6.0M
163M
36.5M
110M
34.4M
68.1M
14.9M
24.8M
19.3M
24.1M
1.4M
3.4M
6.8M
0.8M
1.7M
3.4M
6.9M
13.0M
25.8M
0.8M
1.6M
3.5M
7.0M
13.0M
25.7M
25.1M
24.6M
24.9M

8

To be submitted as a conference paper at ICLR 2018

For the ResNet pre-act architecture, the ensemble versions with 2 or 4 branches leads to a sig-
niﬁcantly better performance than single branch versions with comparable or higher number of
parameters.

Regarding the DenseNet-BC architecture, we considered 6 different network sizes, roughly follow-
ing multiples of powers of 2 and ranging from 0.8M up to 25.6M parameters, with two extremes
corresponding to those for which the error rates were available Huang et al. (2017). We chose these
values for the depth L and growth rate k for these points and interpolated between them according
to a log scale as much as possible. Our experiments showed that the trade-off between L and k is
not critical for a given overall parameter count. This was also the case for choosing between the
number of branches e, depth L and growth rate, k for a given overall parameter count budget as long
as e ≥ 3 (or even e ≥ 2 for small networks). For the 6 conﬁgurations, we experimented with both
the single-branch (classical) and multi-branch versions of the model, with e = 4. Additionally, for
the largest model, we tried e = 3, 6, 8 branches.

For the single branch version with extreme network sizes, we obtained error rates signiﬁcantly lower
than those reported by Huang et al. (2017). From what we have checked, the Lua Torch implemen-
tation they used and the PyTorch one we used are equivalent. The difference may be due to the fact
that we used a more conservative measure of the error rate (on the last iterations) and from statistical
differences due to different initializations and/or to non-deterministic computations (see section D
in supplementary material). Still, the coupled ensemble version leads to a signiﬁcantly better per-
formance for all network sizes, even when compared to DenseNet-BC’s reported performance.

Our larger models of coupled DenseNet-BCs (error rates of 2.92% on CIFAR 10, 15.68% on CIFAR
100 and 1.50% on SVHN) perform better than or are on par with all current state of the art imple-
mentations that we are aware of at the time of publication of this work. Only the Shake-Shake S-S-I
model (Gastaldi, 2017) performs slightly better on CIFAR 10.

We also compare the performance of coupled ensembles with model architectures that were ‘learnt’
in a meta learning scenario. The results are presented in the supplementary material, section C.

4.7 ENSEMBLES OF COUPLED ENSEMBLES

The coupled ensemble approach is limited by the size of the network that can ﬁt into GPU memory
during the training and the time that such training takes. With the hardware we have access to, it
was not possible to go much beyond the 25M-parameter scale. For going further, we resorted to the
classical ensembling approach based on independent trainings. An interesting question was whether
we could still signiﬁcantly improve the performance since the classical approach generally plateaus
after quite a small number of models and the coupled ensemble approach already include several.
For instance the SGDR with snapshots approach (Loshchilov and Hutter, 2017) has a signiﬁcant im-
provement from 1 to 3 models but not much improvement from 3 to 16 models (see tables 3 and 4).
As doing multiple times the same training is quite costly when models are large, we instead ensem-
bled the four large coupled ensemble models that we trained for the four values of e = 3, 4, 6, 8.
Results are shown in table 4. We obtained a signiﬁcant gain by fusing two models and a quite small
one from any further fusion of three or four of them. To the best of our knowledge, these ensem-
bles of coupled ensemble networks outperform all state of the art implementations including other
ensemble-based ones at the time of publication of this work.

Table 4: Classiﬁcation error comparison with the state of the art, multiple model trainings.
System
SVHN #Params
SGDR WRN-28-10 3 runs × 3 snapshots
SGDR WRN-28-10 16 runs × 3 snapshots
DenseNet-BC ensemble of ensembles e = 6, 4
DenseNet-BC ensemble of ensembles e = 6, 4, 3
DenseNet-BC ensemble of ensembles e = 8, 6, 4, 3

C10+ C100+
16.64
3.25
16.21
3.14
15.13
2.72
15.04
2.68
15.05
2.73

329M
1752M
50M
75M
100M

-
-
1.42
1.42
1.41

9

To be submitted as a conference paper at ICLR 2018

4.8 PARAMETER USAGE

Figure 1 shows that for a given parameter count, coupled ensemble networks or ensembles of cou-
pled ensemble networks perform signiﬁcantly better for all parameter budgets. Our approach is
shown by the blue diamonds.

Figure 1: Comparison of parameter usage between different methods. Results on CIFAR-10 (top),
CIFAR-100 (middle) and SVHN (bottom) tasks. “DenseNet-BC”: single-branch (PyTorch) conﬁg-
uration; “Ours”: proposed multiple branch conﬁguration using DenseNet-BC as the basic block,
single training up to 25M parameters and ensembles of coupled ensembles beyond; SGDR-WRN:
snapshot ensembles with SGDR on Wide ResNets up to 110M parameters and ensembles of snap-
shot ensembles beyond; ”Other”: all other architectures mentioned in tables 3 and 4.

10

To be submitted as a conference paper at ICLR 2018

5 DISCUSSION

The proposed approach consists in replacing a single deep convolutional network by a number of
“basic blocks” which resemble standalone CNN models. The intermediate score vectors produced
by each of the basics blocks are coupled via a “fuse layer”. At training time, this is done by taking
an arithmetic average of their log-probabilites for the targets. At test time the score vectors are
averaged following the output from each score vector. Both of these aspects leads to a signiﬁcant
performance improvement over a single branch conﬁguration. This improvement comes at the cost
of a small increase in the training and prediction times. The proposed approach leads to the best
performance for a given parameter budget as can be seen in tables 3 and 4, and in ﬁgure 1.

The increase in training and prediction times is mostly due to the sequential processing of branches
during the forward and backward passes. The smaller size of the branches makes the data parallelism
on GPUs less efﬁcient. This effect is not as pronounced for larger models. This could be solved in
two ways. First, as there is no data dependency between the branches (before the averaging layer)
it is possible to extend the data parallelism to the branches, restoring the initial level of parallelism.
This can be done by implementing a parallel implementation of multiples 2D convolutions at the
same time. Second or alternatively, when multiple GPUs are used, it is possible to spread the
branches over the GPUs.

We have currently evaluated the coupled ensemble approach only on relatively small data sets. We
therefore plan to conduct experiments on ImageNet (Russakovsky et al., 2015) to check whether it
will work equally well on large collections.

ACKNOWLEDGEMENTS

This work has been partially supported by the LabEx PERSYVAL-Lab (ANR-11-LABX-0025-01).
Experiments presented in this paper were partly carried out using the Grid’5000 test-bed, supported
by a scientiﬁc interest group hosted by Inria and including CNRS, RENATER and several Universi-
ties as well as other organizations (see https://www.grid5000.fr).

REFERENCES

Amos, B. and Kolter, J. Z. (2017). A PyTorch Implementation of DenseNet. https://github.

com/bamos/densenet.pytorch. Accessed: June 2017.

Chollet, F. (2017). Xception: Deep learning with depthwise separable convolutions. In Proceedings

of the IEEE Conference on Computer Vision and Pattern Recognition.

Cires¸an, D., Meier, U., and Schmidhuber, J. (2012). Multi-column deep neural networks for image
In 2012 IEEE Conference on Computer Vision and Pattern Recognition, pages

classiﬁcation.
3642–3649.

Cires¸an, D. C., Meier, U., Gambardella, L. M., and Schmidhuber, J. (2011). Convolutional neural
In Proceedings of the 2011 In-
network committees for handwritten character classiﬁcation.
ternational Conference on Document Analysis and Recognition, ICDAR ’11, pages 1135–1139,
Washington, DC, USA.

Gastaldi, X. (2017). Shake-shake regularization. In International Conference on Learning Repre-

sentations. arXiv:1705.07485.

Hansen, L. K. and Salamon, P. (1990). Neural network ensembles. IEEE Transactions on Pattern

Analysis and Machine Intelligence, 12(10):993–1001.

He, K., Zhang, X., Ren, S., and Sun, J. (2016a). Deep residual learning for image recognition. In
2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR), pages 770–778.
arXiv:1512.03385.

He, K., Zhang, X., Ren, S., and Sun, J. (2016b). Identity Mappings in Deep Residual Networks,

pages 630–645.

11

To be submitted as a conference paper at ICLR 2018

Huang, G., Liu, Z., van der Maaten, L., and Weinberger, K. Q. (2017). Densely connected con-
volutional networks. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition.

Huang, G., Sun, Y., Liu, Z., Sedra, D., and Weinberger, K. Q. (2016). Deep Networks with Stochastic

Depth, pages 646–661.

Kawaguchi, K. (2016). Deep learning without poor local minima. In Advances in Neural Information

Processing Systems, pages 586–594.

Krizhevsky, A. and Hinton, G. (2009). Learning multiple layers of features from tiny images.

Krizhevsky, A., Sutskever, I., and Hinton, G. E. (2012). Imagenet classiﬁcation with deep convolu-
tional neural networks. In Pereira, F., Burges, C. J. C., Bottou, L., and Weinberger, K. Q., editors,
Advances in Neural Information Processing Systems 25, pages 1097–1105. Curran Associates,
Inc.

Lecun, Y., Bottou, L., Bengio, Y., and Haffner, P. (1998). Gradient-based learning applied to docu-

ment recognition. Proceedings of the IEEE, 86(11):2278–2324.

Loshchilov, I. and Hutter, F. (2017). SGDR: stochastic gradient descent with restarts. In Interna-

tional Conference on Learning Representations.

Netzer, Y., Wang, T., Coates, A., Bissacco, A., Wu, B., and Ng, A. Y. (2011). Reading digits in
In NIPS Workshop on Deep Learning and

natural images with unsupervised feature learning.
Unsupervised Feature Learning 2011.

Russakovsky, O., Deng, J., Su, H., Krause, J., Satheesh, S., Ma, S., Huang, Z., Karpathy, A., Khosla,
A., Bernstein, M., Berg, A. C., and Fei-Fei, L. (2015). ImageNet Large Scale Visual Recognition
Challenge. International Journal of Computer Vision (IJCV), 115(3):211–252.

Simonyan, K. and Zisserman, A. (2014). Very deep convolutional networks for large-scale image

recognition. CoRR, abs/1409.1556. Published at ICLR 2015.

Springenberg, J. T., Dosovitskiy, A., Brox, T., and Riedmiller, M. (2015). Striving for simplicity:

The all convolutional net. In International Conference on Learning Representations.

Szegedy, C., Liu, W., Jia, Y., Sermanet, P., Reed, S. E., Anguelov, D., Erhan, D., Vanhoucke, V., and
Rabinovich, A. (2015). Going deeper with convolutions. In Proceedings of the IEEE conference
on computer vision and pattern recognition, pages 1–9.

Xie, S., Girshick, R., Dollr, P., Tu, Z., and He, K. (2017). Aggregated residual transformations for
deep neural networks. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition.

Zagoruyko, S. and Komodakis, N. (2016). Wide residual networks. In Proceedings of the British

Machine Vision Conference 2016, BMVC 2016, York, UK, September 19-22, 2016.

Zhang, T., Qi, G.-J., Xiao, B., and Wang, J. (2017). Interleaved Group Convolutions for Deep Neural

Networks. In International Conference on Computer Vision.

Zhao, L., Wang, J., Li, X., Tu, Z., and Zeng, W. (2016). On the connection of deep fusion to

ensembling. arXiv preprint arXiv:1611.07718.

Zoph, B. and Le, Q. V. (2017). Neural architecture search with reinforcement learning. In Interna-

tional Conference on Learning Representations.

Zoph, B., Vasudevan, V., Shlens, J., and Le, Q. V. (2017). Learning transferable architectures for

scalable image recognition. arXiv preprint arXiv:1707.07012.

12

To be submitted as a conference paper at ICLR 2018

Supplementary Material

A IMPLEMENTATION

Figure 2 shows the common structure of the test (top) and train (bottom) versions of networks used
as basic blocks. Figure 3 shows how it is possible to place the averaging layer just after the last FC
layer of the basic block instances and before the SM layer which is then “factorized”. The e model
instances do not need to share the same architecture. Figure 3 shows how it is possible to place the
averaging layer just after the last FC layer, just after the SM (actually LSM (LogSoftMax), which is
equivalent to do a geometric mean of the SM values) layer, or just after the LL layer.

Figure 2: Versions of the base network. Top: test, bottom: train.

Figure 3: Test versions of coupled ensemble networks. Top: SM (classical) fusion, bottom: FC
fusion. AVG: averaging layer.

We reuse “basic blocks” from other groups (with appropriate credits, please let us know if any is
missing or requires updating) in their original form as much as possible both for efﬁciency and for
ensuring more meaningful comparisons. When available, we use the PyTorch implementations.

Each of the e branches is deﬁned by a parameter vector We containing the same parameters as
the original implementation. The global network is deﬁned by a parameter vector W which is a
concatenation of all the We parameter vectors. When training is done in the coupled mode and the
prediction is done in a separate mode or vice-versa, a dedicated script is used for splitting the W
vector into the We ones or vice-versa. In all coupled networks, for all train versions and for all test
version, the same global parameter vector W is used with the same split and deﬁning the same basic
block functions. This is how we can combine in any way all of the four possible training conditions
with all the three possible prediction conditions, even though not all of them are consistent or equally
efﬁcient.

The overall network architecture is determined by:

• the global hyper-parameter specifying the train versus test mode;

• the global hyper-parameter e specifying the number of branches;

• the global hyper-parameter specifying after which layer the AVG layer should be placed (FC, SM

or LL);

13

To be submitted as a conference paper at ICLR 2018

Figure 4: Train versions of coupled ensemble networks. Top: LL fusion, middle: SM fusion, bottom:
FC fusion.

• either one basic block to be replicated e times with its own hyper-parameters or a list of e basic

blocks, each with its own hyper-parameters.

B TEST TIME EQUIVALENCE BETWEEN FC AVERAGE AND LOGSOFTMAX

AVERAGE

Given branches E = E1, E2, ..Ee, each Ei produces a score vector of dimension C, where C is the
number of categories. An element of Ei is referenced as Ec
i , were c ∈ [1, C]. FC Average denotes
averaging the raw activations from each branch. LSM Average denotes averaging across branches,
after a LogSoftMax operation in applied on each branch activation vector, separately.
i=1 Ec
Case 1: FC average: Scoresc
i

F C = (cid:80)e

Case 2:

LogSof tM ax(Ec

n) = log

(cid:80)

exp(Ec
e)
c exp(Ec
e)
e) − log

= log exp(Ec

= Ec

e − Ze

(cid:88)

c

exp(Ec
e)

LSM = (cid:80)e

LSM average: Scoresc
e). Hence we
see that the LSM average score vector is a translated version of the FC average score vector. Also,
doing an arithmetic average of LogSoftMax values is equivalent to doing a geometric average of
SoftMax values. This holds during inference where we are interested only in the maximum value.

i=1 Zi, where Ze = log (cid:80)

C exp(Ec

i − (cid:80)e

i=1 Ec

C COMPARISON WITH Learnt ARCHITECTURES

In table 5, we compare the parameter usage and performance of the branched coupled ensembles
with model architectures that were recovered using meta learning techniques.

14

To be submitted as a conference paper at ICLR 2018

Table 5: Classiﬁcation error comparison with learnt architectures.

System
Neural Architecture Search v3 (Zoph and Le, 2017)
NASNet-A (Zoph et al., 2017)
DenseNet-BC L = 82 k = 10 e = 4
DenseNet-BC L = 88 k = 14 e = 4
DenseNet-BC L = 88 k = 20 e = 4

C10+ C100+
3.65
3.41
3.78
3.57
3.18

-
-
19.92
17.68
16.79

SVHN #Params
37.4M
3.3M
1.6M
3.5M
7.0M

-
-
1.62
1.55
1.57

D PERFORMANCE MEASUREMENT AND REPRODUCIBILITY ISSUES

When attempting to compare the relative performance of different methods, we face the issue of the
reproducibility of the experiments and of the statistical signiﬁcance of the observed difference be-
tween performance measures. Even for a same experiment, we identiﬁed the ﬁve following sources
of variation in the performance measure:

• Underlying framework for the implementation: we made experiments with Torch7 (lua) and with

PyTorch.

• Random seed for the network initialization.

• CuDNN non-determinism during training: GPU associative operations are by default fast but
non-deterministic. We observed that the results varies even for a same tool and the same seed. In
practice, the observed variation is as important as when changing the seed.

• Fluctuations associated to the computed moving average and standard deviation in batch normal-
ization: these ﬂuctuations can be observed even when training with the learning rate, the SGD
momentum and the weight decay all set to 0. During the last few epochs of training, their level of
inﬂuence is the same as with the default value of these hyper-parameters.

• Choice of the model instance chosen from training epochs:

the model obtained after the last
epoch, or the best performing model. Note that choosing the best performing model involves
looking at test data.

Regardless of the implementation, the numerical determinism, the Batch Norm moving average,
and the epoch sampling questions, we should still expect a dispersion of the evaluation measure
according to the choice of the random initialization since different random seeds will likely lead
to different local minima. It is generally considered that the local minima obtained with “properly
designed and trained” neural networks should all have similar performance (Kawaguchi, 2016). We
do observe a relatively small dispersion (quantiﬁed by the standard deviation below) conﬁrming this
hypothesis. This dispersion may be small but it is not negligible and it complicates the comparisons
between methods since differences in measures lower than their dispersions is likely to be non-
signiﬁcant. Classical statistical signiﬁcance tests do not help much here since differences that are
statistically signiﬁcant in this sense can be observed between models obtained just with different
seeds (and even with the same seed), everything else being kept equal.

Experiments reported in this section gives an estimation of the dispersion in the particular case of a
moderate scale model. We generally cannot afford doing a large number of trials for larger models.

We tried to quantify the relative importance of the different effects in the particular case of DenseNet-
BC with L = 100, k = 12 on CIFAR 100. Table 6 shows the results obtained for the same exper-
iment in the four groups of three rows. We tried four combinations corresponding to the use of
Torch7 versus PyTorch and to the use of the same seed versus the use of different seeds. For each of
these conﬁguration, we used as the performance measure: (i) the error rate of the model computed
at the last epoch or (ii) the average of the error rate of the models computed at the last 10 epochs,
(iii) the error rate of the model having the lowest error rate over all epochs. For these 2 × 2 × 3
cases, we present the minimum, the median, the maximum and the mean±standard deviation over
10 measures corresponding to 10 identical runs (except for the seed when indicated). Additionally,
in the case of the average of the error rate of the models computed at the 10 last epochs, we present
the root mean square of the standard deviation of the ﬂuctuations on the last 10 epochs (which is the
same as the square root of the mean of their variance). We make the following observations:

15

To be submitted as a conference paper at ICLR 2018

• There does not seem to be a signiﬁcant difference between Torch7 and PyTorch implementations;
• There does not seem to be a signiﬁcant difference between using a same seed and using different
seeds; the dispersion observed using the same seed (with everything else being equal) implies that
there is no way to exactly reproduce results;

• There does not seem to be a signiﬁcant difference between the means over the 10 measures com-
puted on the single last epoch and the means over the 10 measures computed on the last 10 epochs;
• The standard deviation of the measures computed on the 10 runs is slightly but consistently
smaller when the measures are computed on the last 10 epochs than when they are computed
on the single last epoch; this is the same for the difference between the best and the worst mea-
sures; this was expected since averaging the measure on the last 10 epochs reduces the ﬂuctuations
due to the moving average and standard deviation computed in batch normalization and possibly
too the the random ﬂuctuations due to the ﬁnal learning steps;

• The mean of the measures computed on the 10 runs is signiﬁcantly lower when the measure is
taken at the best epoch than when they are computed either on the single last epoch or on the last
10 epochs. This is expected since the minimum is always below the average. However, presenting
this measure involves using the test data for selecting the best model.

Table 6: Performance measurement and reproducibility issues. Statistics on 10 runs.

Seeds
diff.
diff.
diff.
same
same
same
diff.
diff.
diff.
same
same
same
diff.
diff.
diff.
diff.
diff.
diff.

Impl.
PyT.
PyT.
PyT.
PyT.
PyT.
PyT.
LuaT.
LuaT.
LuaT.
LuaT.
LuaT.
LuaT.
PyT.
PyT.
PyT.
PyT.
PyT.
PyT.

Last
1
10
best
1
10
best
1
10
best
1
10
best
1
10
best
1
10
best

L
100
100
100
100
100
100
100
100
100
100
100
100
82
82
82
100
100
100

k
12
12
12
12
12
12
12
12
12
12
12
12
8
8
8
12
12
12

e Min. Med. Max. Mean±SD RMS(SD)
1
1
1
1
1
1
1
1
1
1
1
1
3
3
3
4
4
4

22.89±0.21
22.87±0.17
22.54±0.24
23.06±0.23
23.04±0.22
22.71±0.18
22.90±0.20
22.86±0.20
22.49±0.18
22.82±0.34
22.87±0.30
22.54±0.29
21.49±0.15
21.45±0.11
21.14±0.14
17.65±0.18
17.66±0.14
17.45±0.16

22.64
22.67
22.13
22.77
22.81
22.44
22.55
22.55
22.17
22.33
22.47
22.24
21.27
21.24
20.84
17.24
17.37
17.11

23.22
23.14
22.91
23.55
23.49
23.02
23.11
23.08
22.75
23.58
23.51
23.24
21.70
21.63
21.30
17.86
17.81
17.66

22.80
22.83
22.56
23.05
22.98
22.67
22.94
22.89
22.52
22.82
22.92
22.51
21.44
21.46
21.18
17.71
17.67
17.46

n/a
0.13
n/a
n/a
0.11
n/a
n/a
0.12
n/a
n/a
0.12
n/a
n/a
0.12
n/a
n/a
0.11
n/a

Following these observations, we propose a method for ensuring the best reproducibility and the
fairest comparisons. Choosing the measure as the minimum of the error rate for all models computed
during the training seems neither realistic nor a good practice since we have no way to know which
model will be the best one without looking at the results (cross-validation cannot be used for that)
and this is like tuning on the test set. Even though this is not necessarily unfair for system comparison
if the measures are done in this condition for all systems, this does introduce a bias for the absolute
performance estimation. Using the error rate at the last iteration or at the 10 last iteration does not
seem to make a difference in the mean but the standard deviation is smaller for the latter, therefore
this one should be preferred when a single experiment is conducted. We also checked that using
the 10 or the 25 last epochs does not make much difference (learning at this point does not seem to
lead to further improvement). A value different from 10 can be used and this is not critical. In all
the CIFAR experiments reported in this paper, we used the average of the error rate for the models
obtained at the last 10 epochs as this should be (slightly) more robust and more conservative. The
case for SVHN experiments is slightly different since there is a much smaller number of much bigger
epochs; we used the last 4 iterations in this case.

These observations have been made in a quite speciﬁc case but the principle and the conclusions
(use of the average of the error rate from the last epochs should lead to more robust and conservative

16

To be submitted as a conference paper at ICLR 2018

results) are likely to be general. Table 6 also shows the results for a coupled ensemble network of
comparable size and for a coupled ensemble network four times bigger. Similar observations can be
made and, additionally, we can observe that both the range and the standard deviations are smaller.
This might be because an averaging is already made between the branches leading to a reduction of
the variance. Though this requires conﬁrmation at larger scales, coupled ensemble networks might
lead to both a better and a more stable performance.

17

7
1
0
2
 
p
e
S
 
8
1
 
 
]

V
C
.
s
c
[
 
 
1
v
3
5
0
6
0
.
9
0
7
1
:
v
i
X
r
a

To be submitted as a conference paper at ICLR 2018

COUPLED ENSEMBLES OF NEURAL NETWORKS

Anuvabh Dutt
Univ. Grenoble Alpes, CNRS, Grenoble-INP, LIG, F-38000 Grenoble France
Anuvabh.Dutt@univ-grenoble-alpes.fr

Denis Pellerin
Univ. Grenoble Alpes, CNRS, Grenoble-INP, GIPSA-Lab, F-38000 Grenoble France
Denis.Pellerin@gipsa-lab.grenoble-inp.fr

Georges Qu´enot
Univ. Grenoble Alpes, CNRS, Grenoble-INP, LIG, F-38000 Grenoble France
Georges.Quenot@imag.fr

ABSTRACT

We investigate in this paper the architecture of deep convolutional networks.
Building on existing state of the art models, we propose a reconﬁguration of the
model parameters into several parallel branches at the global network level, with
each branch being a standalone CNN. We show that this arrangement is an efﬁcient
way to signiﬁcantly reduce the number of parameters without losing performance
or to signiﬁcantly improve the performance with the same level of performance.
The use of branches brings an additional form of regularization. In addition to
the split into parallel branches, we propose a tighter coupling of these branches
by placing the “fuse (averaging) layer” before the Log-Likelihood and SoftMax
layers during training. This gives another signiﬁcant performance improvement,
the tighter coupling favouring the learning of better representations, even at the
level of the individual branches. We refer to this branched architecture as “cou-
pled ensembles”. The approach is very generic and can be applied with almost
any DCNN architecture. With coupled ensembles of DenseNet-BC and parameter
budget of 25M, we obtain error rates of 2.92%, 15.68% and 1.50% respectively
on CIFAR-10, CIFAR-100 and SVHN tasks. For the same budget, DenseNet-BC
has error rate of 3.46%, 17.18%, and 1.8% respectively. With ensembles of cou-
pled ensembles, of DenseNet-BC networks, with 50M total parameters, we obtain
error rates of 2.72%, 15.13% and 1.42% respectively on these tasks.

1

INTRODUCTION

The design of early convolutional architectures (CNN) involved choices of hyper-parameters such
as: ﬁlter size, number of ﬁlters at each layer, and padding (Lecun et al., 1998; Krizhevsky et al.,
2012). Since the introduction of the VGGNet (Simonyan and Zisserman, 2014) the design has
moved towards following a template: ﬁxed ﬁlter size of 3 × 3 and N features maps, down-sample to
half the input resolution only by the use of either maxpool or strided convolutions (Springenberg
et al., 2015), and double the number the computed feature maps following each down-sampling
operation. This philosophy is used by state of the art models such as ResNet (He et al., 2016b) and
DenseNet (Huang et al., 2017). The last two architectures extended the template to include the use
of “skip-connections” between non-contiguous layers.

Our work extends this template by adding another element, which we refer to as “coupled en-
sembling”.
In this set-up, the network is decomposed into several branches, each branch being
functionally similar to a complete CNN (and able to fully do the classiﬁcation task alone, gen-
erally with a lower performance). The proposed template achieves performance comparable to
state of the art models with a signiﬁcantly lower parameter count. The proposed modiﬁcation

1

To be submitted as a conference paper at ICLR 2018

is simple to implement and we provide a wrapper to compose different standard architectures at:
https://github.com/vabh/coupled_ensembles.

In this paper, we make the following contributions: (i) we show that given a parameter budjet,
splitting a large network into an ensemble of smaller parallel branches of the same type, and jointly
training them performs better or at par; (ii) when a ﬁnal SoftMax (SM) layer is used during the
prediction step, we show that ensemble fusion works better when averaging is done before this
layer than when it is done after; (iii) when a ﬁnal Log-Likelihood (LL) layer is used during the
training step, we show that ensemble fusion of branches works better when the fusion is done before
this layer than when it is done after; (iv) combining all these elements, we signiﬁcantly improved
the performance and/or signiﬁcantly reduce the parameter count of state-of-the-art neural network
architectures on CIFAR and SVHN data sets. (v) We show that such multi-branch networks can be
further ensembled at a higher level still producing a signiﬁcant performance gain.

This paper is organised as follows: in section 2, we discuss related work; in section 3, we introduce
the concept of coupled ensembles and the motivation behind the idea; in section 4, we present the
evaluation of the proposed approach and compare it with the state of the art; and we conclude and
discuss future work in section 5.

2 RELATED WORK

Multi-column architectures. The network architecture that we propose has strong similarities
with Cires¸an’s Neural Networks Committees (Cires¸an et al., 2011) and Multi-Column Deep Neural
Network (MCDNN) (Cires¸an et al., 2012), which are a type of ensemble of networks where the
“committee members” or “DNN columns” correspond to our basic block instances (or branches).
However, our coupled ensemble networks differ as following: (i) we train a single model which is
composed of sub-networks, while they train each member or column separately. (ii) we consider a
coupled ensemble of smaller networks for improving the performance of a network, given a budget
of parameters for the entire model. This is contrary to improving it by utilising multiple models of
ﬁxed size and therefore multiplying the overall size (though both are not exclusive); (iii) we consider
placing the averaging (AVG) layer, not only completely at the end of the network but also before
the Log-Likelihood (LL) layer during training and before the Soft-Max (SM) layer during training
and/or during prediction; (iv) we used the same preprocessing for all branches while they consid-
ered different preprocessing (data augmentation) blocks for different members or different subsets
of columns; we consider doing this also in the future.

Multi-branch architectures. Multi-branch architectures have been very successful in several vision
applications (He et al., 2016a; Szegedy et al., 2015). Recently, modiﬁcations have been proposed
(Xie et al., 2017; Chollet, 2017) for these architectures using the concept of “grouped convolutions”,
in order to factorize spatial feature extraction and channel features. These modiﬁcations additionally
advocate the use of template building blocks stacked together to form the complete model. This
modiﬁcation is at the level of the building blocks of their corresponding base architectures: ResNet
and Inception respectively. In contrast we propose a generic modiﬁcation of the structure of the
CNN at the global model level. This includes a template in which the speciﬁc architecture of a
“basic block” is speciﬁed, and then this “basic block” is replicated as parallel branches to form the
ﬁnal composite model.

To further improve the performance of such architectures, Shake-Shake regularization (Gastaldi,
2017) proposes a stochastic mixture of each of the branches and has achieved good results on the
CIFAR datasets. However, the number of epochs required for convergence is much higher compared
to the base model. Additionally, the technique seems to depend on the batch size. In contrast, we
apply our method using the exact same hyper-parameters as used in the underlying CNN.

Zhao et al. (2016) investigate the usage of parallel paths in a ResNet, connecting layers to allow
information exchange between the paths. However this requires modiﬁcation at a local level of each
of the residual blocks. In contrast, our method is a generic rearrangement of a given architecture’s
parameters, which does not introduce additional choices. Additionally, we empirically conﬁrm that
our proposed conﬁguration leads to an efﬁcient usage of parameters.

Neural network ensembles. Ensembling is a reliable technique to increase the performance of
models for a task. Due to the presence of several local minima, multiple trainings of the exact

2

To be submitted as a conference paper at ICLR 2018

same neural network architecture can reach a different distribution of errors on a per-class basis.
Hence, combining their outputs lead to improved performance on the overall task. This was observed
very early (Hansen and Salamon, 1990) and is now commonly used for obtaining top results in
classiﬁcation challenges, despite the increase in training and prediction cost. Our proposed model
architecture is not an ensemble of independent networks given that we have a single model made
up of parallel branches that is trained. This is similar in spirit to the residual block in ResNet
and ResNeXt, and to the inception module in Inception but is done at the full network level. We
would like to emphasize here that “arranging” a given budget of parameters into parallel branches
leads to an increase in performance (as shown in tables 1, 2 and 3). Additionally, the classical
ensembling approach can still be applied for the fusion of independently trained coupled ensemble
networks where it produces a signiﬁcant performance improvement (as shown in table 4)

3 COUPLED ENSEMBLES

TERMINOLOGY

For the following discussion, we deﬁne some terms:

• Branch: the proposed model comprises several branches. Each branch takes as input a data point
and produces a score vector corresponding to the target classes. Current design of CNNs are
referred to as single-branch. The number of branches is denoted by e.

• Basic block: the model architecture used to form a branch. In our experiments, we use DenseNet-

BC and ResNet with pre-activation as basic blocks.

• Fuse Layer:

the operation used to combine each of the parallel branches which make up our
model. In our experiments, each of the branches are combined by taking the average of each of
their predicted log probabilities over the target classes. Section 4.4 explores different choices of
operations for the fuse layer.

We consider a classiﬁcation task in which individual samples are always associated to exactly
one class, labelled from a ﬁnite set. This is the case for CIFAR (Krizhevsky and Hinton, 2009),
SVHN (Netzer et al., 2011) and ILSVRC (Russakovsky et al., 2015) tasks. In theory, this should
work for other tasks as well (for example, segmentation, object detection, etc.).

We consider neural network models whose last layer outputs a score vector of the same dimension
as the number of target classes. This is usually implemented as a linear layer and referred to as
a fully connected (FC) layer. This layer can be followed by a SoftMax (SM) layer to produce a
probability distribution over the target classes. During training, this is followed by a loss layer, for
example, negative log-likelihood (LL). This is the case for all recent network architectures for image
classiﬁcation1 (Krizhevsky et al., 2012; Simonyan and Zisserman, 2014; Szegedy et al., 2015; He
et al., 2016a; Xie et al., 2017; Huang et al., 2016; Zagoruyko and Komodakis, 2016; Huang et al.,
2017). The differences among them is related to what is present before the last FC layer. We are
agnostic to this internal setup (however complex it may or may not be) because the resulting “basic
block” always takes an image as input and produces a vector of N values (one for each target class)
as output, parametrized by a tensor W .

In the case of ensemble predictions, fusion is usually done by computing the individual predic-
tions separately for e model instances and then averaging them. Each of the instances are trained
seperately. This is functionally equivalent to predicting with a “super-network” including the e in-
stances as parallel branches with a ﬁnal averaging (AVG) layer on top. Such super-networks are
generally not implemented because the branch instances often already correspond to the maximum
memory capacity of GPUs. The remaining AVG layer operation can be implemented separately.
Alternatively, it is possible to place the averaging layer just after the last FC layer of the basic block
instances and before the SM layer, which is then “factorized”.

1Though all these networks actually do have a FC layer before the SM one, the last layer need not be a linear
layer, as long as it produces one value for each target label. We will refer to the output of each basic block as
“FC”. Similarly, the proposed method may be easily adapted to multi-label classiﬁcation (i.e. considering non-
exclusive classes) by simply replacing the SM (and possibly also the LL) layer(s) by any variant(s) appropriate
for multi-label classiﬁcation. Again, we will refer to their output as “SM” and “LL”.

3

To be submitted as a conference paper at ICLR 2018

In our setup, a model is composed of parallel branches and each branch produces a score vector for
the target categories. We explore three options to combine these vectors during training:

• Activation (FC) average.

• Probability (SM) average (in practice we do an arithmetic average of log-probabilities).

• Log Likelihood (LL) average (average of the loss of each branch).

We investigate these options in section 4.4. Note that for inference, averaging the FC layer activa-
tions is equivalent to averaging the LogSoftMax values (or to a geometric average of the softmax
values, see section B of supplementary material).

This transformation of having multiple branches, and combining the branch activations by averaging
the log probabilites that they predict for the target categories, leads to a performance improvement,
with a lower parameter count, in all our experiments (see section 4). The parameter vector W of this
composite branched model is the concatenation of the parameter vectors We of the e basic blocks
with 1 ≤ i ≤ e. All parameters are in the “basic blocks” as the “fuse layer” does not contain any
parameters. The e model instances do not really need to share the same architecture.

Three training versions may be considered depending upon whether the “fuse layer” is placed after
the FC, after the SM or after the LL layer. All the instances are trained simultaneously trough a
single loss function and the W parameter vector is obtained in a single training phase. In practice,
in the ﬁrst and the third versions, the SM and LL layers are replaced by a single Cross-Entropy
(CE) layer as this is numerically more stable. Similarly, in the second and intermediate case, a
LogSoftMax (LSM) layer is used instead of the regular SM layer before the arithmetic averaging
(while removing the Log operation in the LL layer). This is equivalent to replacing the arithmetic
average by a geometric one with the regular SM and LL layers. The training can be done in four
different ways: the three coupled ways correspoding to the “fuse layer” plus the the one in which
all basic blocks are trained separately in e independent trainings. Regardless of how the training of
the basic blocks has been performed, it is possible to use any of the two coupled ways for making
‘coupled prediction’ and it is also possible to use the individual basic blocks for making e ‘individual
predictions’. Not all of these combinations are expected to be consistent or equally efﬁcient but all
can be implemented and evaluated as shown in section 4.4.

4 EXPERIMENTS

4.1 DATASETS

We evaluate our proposed architecture on the CIFAR (Krizhevsky and Hinton, 2009) and SVHN
(Netzer et al., 2011) data sets. CIFAR-10 and CIFAR-100 consist each of 50,000 training images
and 10,000 test images, distributed into 10 and 100 categories respectively. SVHN consists of
73,257 training images, 531,131 “easy” training images (we use both for training) and 26,032 testing
images, distributed into 10 categories. Each image from these datasets is of size 32×32 pixels.

4.2 EXPERIMENTAL SET-UP

All hyper parameters are set according to the original descriptions of the “basic block” that is used.
This may not be the optimal setting in our case (especially the learning rate decay schedule) but we
do not alter them, so as to not introduce any bias in comparisons.

For CIFAR-10, CIFAR-100 and SVHN, the input image is normalised by subtracting by the mean
image and dividing by the standard deviation. During training on CIFAR datasets, standard data
augmentation is used, which comprises random horizontal ﬂips and random crops. For SVHN, no
data augmentation is used. However, a dropout ratio of 0.2 is applied in the case of DenseNet when
training on SVHN. Testing is done after normalising the input in the same way as during training.

All error rates are given in percentages and correspond to an average computed on the last 10 epochs
for CIFAR and on the last 4 epochs for SVHN. This measure is more conservative than the one used
by the DenseNet authors (see supplementary material, section D). For DenseNet-BC, Amos and
Kolter (2017)’s PyTorch implementation has been used. All execution times were measured using a

4

To be submitted as a conference paper at ICLR 2018

single NVIDIA 1080Ti GPU with the optimal micro-batch2. Experiments in section 4.3, 4.4 are done
on the CIFAR-100 data set with the “basic block” being DenseNet-BC, depth L = 100, growth rate
k = 12. For experiments in Section 4.5, we consider this same conﬁguration (with a single branch)
as our baseline reference point.

4.3 COMPARISON WITH SINGLE BRANCH AND INDEPENDENT ENSEMBLES

A natural point of comparison of the proposed branched architecture is with an ensemble of indepen-
dent models. Rows 2 (coupled training with SM averaging) and 4 (no averaging) in Table 1 present
the results of these two cases respectively. Row 4 shows the error rate obtained from averaging the
predictions of 4 identical models, each of which were trained separately. We see that even though
the total number of trainable parameters involved is exactly the same, a jointly trained branched
conﬁguration gives a much lower test error (17.61 vs. 18.42 with 4 predictions fused at the FC level
in both cases).

The next point of comparison is with a single branch model comprising a similar number of pa-
rameters as the multi branch conﬁguration. The choice of single branch models has been done by:
increasing k while keeping L constant, by increasing both k and L, or by increasing L while keep-
ing k constant. The last three rows of Table 1 show that the error from the multi branch model is
considerably lower, as compared to a single branch model (17.61 vs. 20.01, with 4 predictions fused
at the FC level).

These observations show that the arranging a given budget of parameters into parallel branches is
efﬁcient in terms of parameters, as compared to having a large single branch or multiple independent
trainings. In Section 4.5 we analyse the relation between the number of branches and the model
performance.

4.4 CHOICE OF FUSE LAYER OPERATION

In this section, we compare the performance of our proposed branched model for different choices
for the positioning of the “fuse layer” (see section 3). Experiments are carried out to evaluate the best
training and prediction fusion combinations. We consider two branched models with e = 2, e = 4,
trained in the following conditions: training with fusion after the LL layer, after the SM layer, or
after the FC layer.

Table 1 shows the performance of the differently trained systems for different prediction conﬁgu-
rations: individual average performance of the trained instances (without fusion) and performance
of the ensemble system with fusion after the SM layer or after the FC layer. Note that this ta-
ble includes models with parameters obtained using different training methods . We can make the
following observations:

• The Avg. FC training with separate predictions (in red) does not work well. This is expected since
a similar FC average may be reached with quite unrelated FC instances. The Avg. FC training
with Avg. SM prediction (in red) works a bit better but is still not good because the non-linearity
of the SM layer distorts the FC average. Indeed, the consistent Avg. FC training with Avg. FC
prediction works quite well though it does not yield the best performance.

• The Avg. FC prediction works at least as well and often signiﬁcantly better than the Avg. SM
prediction whatever the training choice is. This can be explained by the fact that the SM layer
compresses values for probabilities close to 0 and 1 while the values remain more spread and
transmit more information at the FC layer, even for different training conditions.

• The average error rate of each of the “basic blocks” trained jointly in coupled ensembles with SM
fusion is signiﬁcantly lower than the error rate of the individual instances trained separately. This
indicates that the coupling not only forces them to learn complementary features as a group but
also to better learn individually. Averaging the log probabilities forces the network to continuously
update all branches so as to be consistent with each other. This provides a stronger gradient
signal. Additionally, the training loss remains higher compared to single branch models, serving
as a regularizer. The error gradient that is back-propagated from the fuse layer is the same for all

2The micro-bath denotes the number of images samples that were processed in one batch on the GPU so as

to have the best throughput. In practice, minibatch (for parameter update) = n×microbatch

5

To be submitted as a conference paper at ICLR 2018

Table 1: Coupled Ensembles of DenseNet-BCs versus a single model of comparable complexity and
study of training / prediction fusion combinations. Top: e = 2, bottom: e = 4. Performance is given
as the top-1 error rate (mean±standard deviation for the individual branches) on the CIFAR-100
data set with standard data augmentation. Columns “L” and “k” indicate the DenseNet-BC hyper-
parameter values of the “basic block”. Column “e” indicates the number of branches. Column
“Avg.” indicates the type of “fuse layer” during training: “none” for separate trainings (classical
ensembling), “FC”, “SM” and “LL” for fusion (arithmetic averaging) after the FC, SM and LL lay-
ers respectively (not applicable for e = 1). Column “Individual” gives the performance for the
individual “basic blocks” evaluated separately; Columns “FC” and “SM” give the performance with
fusion (arithmetic averaging) during prediction done after the FC and SM layers respectively. The
last three columns give the total number of parameters of the model, the duration of a training itera-
tion (50,000 images) and the prediction time per test image (in batch mode). (*) See supplementary
material, section D; The average and standard deviations are computed here for the independent
trainings (comprising 2 and 4 models respectively.).

L
100
100
100
100
100
124
148

L
100
100
100
100
100
154
220

k
12
12
12
12
17
14
12

k
12
12
12
12
25
17
12

e Avg.
FC
2
SM
2
LL
2
none
2
n/a
1
n/a
1
n/a
1

e Avg.
FC
4
SM
4
LL
4
none
4
n/a
1
n/a
1
n/a
1

Individual
52.68±22.95
22.17±0.32
22.78±0.08
23.13±0.15(*)
21.22±0.12
21.75±0.10
20.80±0.06

Individual
74.36±26.28
22.29±0.11
22.83±0.18
23.13±0.09(*)
20.61±0.01
20.02±0.10
20.01±0.12

FC
22.25
19.06
19.33
20.44
n/a
n/a
n/a

FC
22.55
17.61
18.21
18.42
n/a
n/a
n/a

SM Params Epoch(s) Test(ms)
28.78
19.43
19.91
20.44
n/a
n/a
n/a

1.60M
1.60M
1.60M
1.60M
1.57M
1.55M
1.56M

0.98
0.98
0.98
0.98
0.67
0.77
0.90

174
174
174
171
121
135
159

SM Params Epoch(s) Test(ms)
31.92
17.68
18.92
18.85
n/a
n/a
n/a

3.20M
3.20M
3.20M
3.20M
3.34M
3.29M
3.15M

2.00
2.00
2.00
2.00
0.8
1.3
1.5

402
402
402
341
164
245
326

branches, and this gradient depends on the combined predictions. This means that at every step
all branches act complementary to the other branches’ weight updates.

• All ensemble combinations except those based on the Avg. FC training do signiﬁcantly better
than a single network of comparable size and same depth. For a global network size of about
1.6M (resp. 3.2M) parameters, the error rate decreases from 20.80 (resp. 20.01) for the best
single instance combination to 19.06 (−1.74) with two instances (resp. 17.61 (−2.40) with four
instances).

• The best combination seems to be Avg. SM for training with Avg. FC for prediction.
• The branched model with e = 4 and Avg. SM for the “fuse layer” has the same performance as
a DenseNet-BC (L = 250, k = 24) model (Huang et al., 2017), which has about 5 times more
parameters (15.3M versus 3.2M).

All the following experiments have Avg. SM for the training “fuse layer’ in the branched models.

4.5 CHOICE OF THE NUMBER OF BRANCHES

In this section, we investigate the optimal number of branches e for a given model parameter budget.
We evaluate on CIFAR-100, with DenseNet-BC as the “basic block”, and parameter budget equal
to 0.8M parameters (this is the number of parameters in DenseNet-BC (L = 100, k = 12)). In-
deed, the optimal number of instances e is likely to depend upon the network architecture, upon the
parameter budget and upon the data set but this gives at least one reference. This was investigated
again with larger models, and the results are in table 3 (last four rows).

6

To be submitted as a conference paper at ICLR 2018

Table 2: Different number of branches, e for a ﬁxed parameter count. The models are trained on
CIFAR-100 with standard data augmentation. See table 1 caption for the meaning of row and column
labels. When applicable (e > 1), “fuse layer” is SM Avg. (*) Average and standard deviation on 10
trials with different seeds; Huang et al. (2017) reports 22.27, see supplementary material, section D.

L
100
76
88
94
100
70
82
88
94
64
70
58
64
58
64

k
12
10
9
8
8
9
8
7
7
8
8
7
7
6
6

e
1
2
2
2
2
3
3
3
3
4
4
6
6
8
8

Individual
22.87±0.17(*)
25.58±0.20
25.15±0.31
25.72±0.20
25.42±0.20
26.67±0.40
26.47±0.17
26.92±0.41
26.50±0.12
28.58±0.59
27.65±0.48
30.11±0.53
30.65±0.62
32.15±0.00
31.52±0.38

FC
n/a
21.66
21.87
21.95
21.87
21.10
21.25
22.09
21.95
22.44
21.50
23.87
23.08
25.95
24.42

SM Params Epoch(s) Test(ms)
n/a
22.17
22.19
22.22
22.07
21.24
21.46
22.49
22.35
22.58
22.12
24.22
23.36
25.70
24.69

800k
720k
747k
666k
737k
773k
800k
698k
775k
719k
828k
718k
840k
722k
843k

0.51
0.63
0.71
0.69
0.75
0.77
0.85
0.92
0.98
0.88
0.94
1.08
1.20
1.35
1.51

86
103
119
115
126
129
141
148
160
142
156
179
198
219
250

Table 2 shows the performance for different conﬁgurations of branches e, depth L, and growth rate
k. One difﬁculty is that DenseNet-BC parameter counts are strongly quantiﬁed according to the L
and k values (L has to be a multiple of 6 modulo 4) and, additionally, to the e value in the coupled
ensemble version. This is even more critical in moderate size models like the 800K one targeted
here. We selected model conﬁgurations with parameters just below the target for making a fair
comparison. A few models have slightly more parameters so that some interpolation can be done
for possibly more accurate comparisons. We can make the following observations:

• In the considered case (DenseNet-BC, CIFAR-100 and 800K parameters), the optimal number of
branches is e = 3, L = 70, k = 9. With these parameters, the error rates decreases from 22.87
for the regular (L = 100, k = 12) DenseNet-BC model to 21.10 (−1.77).

• Using 2 to 4 branches yields a signiﬁcant performance gain over the classical (single branch,
e = 1) case, and even over the original performance of 22.27 reported for the (L = 100, k = 12)
DenseNet-BC (see supplementary material, section D).
• Using 6 or 8 branches performs signiﬁcantly less well.
• Slightly varying the L, k and e hyper-parameters around their optimal value does not lead to a
signiﬁcant performance drop, showing that the coupled ensemble approach and the DenseNet-BC
architecture are quite robust relatively to these choices.

• The gain in performance comes at the expense of an increased training and prediction times even
though the model size does not change. This is due to the use of smaller values of k that prevents
good parallelism efﬁciency. This increase is relatively smaller with bigger networks.

The same experiment was done on a validation set with a 40k/10k random split of the CIFAR-
100 training set and we could draw the same conclusions from there; they led to predict that the
(L = 82, k = 8, e = 3) combination should be the best one on the test set. The (L = 70, k = 9, e =
3) combination appears to be slightly better here but the difference is probably not statistically
signiﬁcant.

4.6 COMPARISON WITH THE STATE OF THE ART

We have evaluated the coupled ensemble network approach with networks of various sizes. We used
again Huang et al. (2017)’s DenseNet-BC architecture as the “basic block” since this was the current
state of the art or very close to it at the time we started these experiments. We used Amos and Kolter
(2017)’s PyTorch DenseNet-BC implementation both for the multi-branch (coupled ensembles) and

7

To be submitted as a conference paper at ICLR 2018

single-branch (classical) experiments. We also evaluated the approach using He et al. (2016b)’s
ResNet with pre-activation as the basic block to check if the coupled ensemble approach works well
with other architectures.

Table 3 reports in the upper part the results obtained by the current best systems (see section 2 for
references) and the results obtained with our coupled ensembles approach in the lower part. All
results presented in this table correspond to the training of a single, possibly big, network. Even
if ensembles are considered, they are always coupled as described in section 3 and trained as a
single global network. A further level of ensembling involving multiple trainings is considered in
section 4.7. Results are presented on the CIFAR 10 and 100 data set with standard data augmentation
and on SVHN using the extra training data.

Table 3: Classiﬁcation error comparison with the state of the art, for a single model.

SVHN #Params

System
ResNet L = 110 k = 64
ResNet stochastic depth L = 110 k = 64
ResNet stochastic depth L = 1202 k = 64
ResNet pre-activation L = 164 k = 64
ResNet pre-activation L = 1001 k = 64
DenseNet L = 100 k = 24
DenseNet-BC L = 100 k = 12 (Torch)
DenseNet-BC L = 250 k = 24 (Torch)
DenseNet-BC L = 190 k = 40 (Torch)
Shake-Shake C10 Model S-S-I
Shake-Shake C100 Model S-E-I
Snapshot Ensemble DenseNet-40 (α0 = 0.1)
Snapshot Ensemble DenseNet-40 (α0 = 0.2)
Snapshot Ensemble DenseNet-100 (α0 = 0.2)
SGDR WRN-28-10 Loshchilov and Hutter (2017)
SGDR WRN-28-10 3 snapshots
ResNeXt-29, 8×64d Xie et al. (2017)
ResNeXt-29, 16×64d Xie et al. (2017)
DFN-MR2 Zhao et al. (2016)
DFN-MR3 Zhao et al. (2016)
IGC-L450M2 Zhang et al. (2017)
IGC-L32M26 Zhang et al. (2017)
ResNet pre-activation L = 65 k = 64 e = 2
ResNet pre-activation L = 164 k = 64 e = 2
ResNet pre-activation L = 164 k = 64 e = 4
DenseNet-BC L = 100 k = 12 e = 1
DenseNet-BC L = 112 k = 16 e = 1
DenseNet-BC L = 130 k = 20 e = 1
DenseNet-BC L = 160 k = 24 e = 1
DenseNet-BC L = 166 k = 32 e = 1
DenseNet-BC L = 190 k = 40 e = 1
DenseNet-BC L = 82 k = 8 e = 3
DenseNet-BC L = 82 k = 10 e = 4
DenseNet-BC L = 88 k = 14 e = 4
DenseNet-BC L = 88 k = 20 e = 4
DenseNet-BC L = 94 k = 26 e = 4
DenseNet-BC L = 118 k = 35 e = 3
DenseNet-BC L = 106 k = 33 e = 4
DenseNet-BC L = 76 k = 33 e = 6
DenseNet-BC L = 64 k = 35 e = 8

C10+ C100+
6.61
5.25
4.91
5.46
4.92
3.74
4.51
3.62
3.46
2.86
-
4.99
4.84
3.44
4.03
3.51
3.65
3.58
3.94
3.57
3.25
3.31
5.26
4.24
3.96
4.77
4.47
4.06
3.98
4.03
4.04
4.30
3.78
3.57
3.18
3.01
2.99
2.99
2.92
3.13

-
24.98
-
24.33
22.71
19.25
22.27
17.60
17.18
-
15.85
23.34
21.93
17.41
19.57
17.75
17.77
17.31
19.25
19.00
19.25
18.75
23.24
19.92
18.84
22.87
20.73
19.03
18.92
20.03
18.19
21.25
19.92
17.68
16.79
16.24
16.18
15.68
15.76
15.95

-
-
-
-
-
1.59
1.76
-
-
-
-
1.64
1.73
-
-
-
-
-
1.51
1.55
-
1.56
-
-
-
1.79
1.83
1.84
1.88
1.88
1.79
1.66
1.62
1.55
1.57
1.50
1.50
1.53
1.50
1.50

1.7M
1.7M
10.2M
1.7M
10.2M
27.2M
0.80M
15.3M
25.6M
26.2M
34.4M
6.0M
6.0M
163M
36.5M
110M
34.4M
68.1M
14.9M
24.8M
19.3M
24.1M
1.4M
3.4M
6.8M
0.8M
1.7M
3.4M
6.9M
13.0M
25.8M
0.8M
1.6M
3.5M
7.0M
13.0M
25.7M
25.1M
24.6M
24.9M

8

To be submitted as a conference paper at ICLR 2018

For the ResNet pre-act architecture, the ensemble versions with 2 or 4 branches leads to a sig-
niﬁcantly better performance than single branch versions with comparable or higher number of
parameters.

Regarding the DenseNet-BC architecture, we considered 6 different network sizes, roughly follow-
ing multiples of powers of 2 and ranging from 0.8M up to 25.6M parameters, with two extremes
corresponding to those for which the error rates were available Huang et al. (2017). We chose these
values for the depth L and growth rate k for these points and interpolated between them according
to a log scale as much as possible. Our experiments showed that the trade-off between L and k is
not critical for a given overall parameter count. This was also the case for choosing between the
number of branches e, depth L and growth rate, k for a given overall parameter count budget as long
as e ≥ 3 (or even e ≥ 2 for small networks). For the 6 conﬁgurations, we experimented with both
the single-branch (classical) and multi-branch versions of the model, with e = 4. Additionally, for
the largest model, we tried e = 3, 6, 8 branches.

For the single branch version with extreme network sizes, we obtained error rates signiﬁcantly lower
than those reported by Huang et al. (2017). From what we have checked, the Lua Torch implemen-
tation they used and the PyTorch one we used are equivalent. The difference may be due to the fact
that we used a more conservative measure of the error rate (on the last iterations) and from statistical
differences due to different initializations and/or to non-deterministic computations (see section D
in supplementary material). Still, the coupled ensemble version leads to a signiﬁcantly better per-
formance for all network sizes, even when compared to DenseNet-BC’s reported performance.

Our larger models of coupled DenseNet-BCs (error rates of 2.92% on CIFAR 10, 15.68% on CIFAR
100 and 1.50% on SVHN) perform better than or are on par with all current state of the art imple-
mentations that we are aware of at the time of publication of this work. Only the Shake-Shake S-S-I
model (Gastaldi, 2017) performs slightly better on CIFAR 10.

We also compare the performance of coupled ensembles with model architectures that were ‘learnt’
in a meta learning scenario. The results are presented in the supplementary material, section C.

4.7 ENSEMBLES OF COUPLED ENSEMBLES

The coupled ensemble approach is limited by the size of the network that can ﬁt into GPU memory
during the training and the time that such training takes. With the hardware we have access to, it
was not possible to go much beyond the 25M-parameter scale. For going further, we resorted to the
classical ensembling approach based on independent trainings. An interesting question was whether
we could still signiﬁcantly improve the performance since the classical approach generally plateaus
after quite a small number of models and the coupled ensemble approach already include several.
For instance the SGDR with snapshots approach (Loshchilov and Hutter, 2017) has a signiﬁcant im-
provement from 1 to 3 models but not much improvement from 3 to 16 models (see tables 3 and 4).
As doing multiple times the same training is quite costly when models are large, we instead ensem-
bled the four large coupled ensemble models that we trained for the four values of e = 3, 4, 6, 8.
Results are shown in table 4. We obtained a signiﬁcant gain by fusing two models and a quite small
one from any further fusion of three or four of them. To the best of our knowledge, these ensem-
bles of coupled ensemble networks outperform all state of the art implementations including other
ensemble-based ones at the time of publication of this work.

Table 4: Classiﬁcation error comparison with the state of the art, multiple model trainings.
System
SVHN #Params
SGDR WRN-28-10 3 runs × 3 snapshots
SGDR WRN-28-10 16 runs × 3 snapshots
DenseNet-BC ensemble of ensembles e = 6, 4
DenseNet-BC ensemble of ensembles e = 6, 4, 3
DenseNet-BC ensemble of ensembles e = 8, 6, 4, 3

C10+ C100+
16.64
3.25
16.21
3.14
15.13
2.72
15.04
2.68
15.05
2.73

329M
1752M
50M
75M
100M

-
-
1.42
1.42
1.41

9

To be submitted as a conference paper at ICLR 2018

4.8 PARAMETER USAGE

Figure 1 shows that for a given parameter count, coupled ensemble networks or ensembles of cou-
pled ensemble networks perform signiﬁcantly better for all parameter budgets. Our approach is
shown by the blue diamonds.

Figure 1: Comparison of parameter usage between different methods. Results on CIFAR-10 (top),
CIFAR-100 (middle) and SVHN (bottom) tasks. “DenseNet-BC”: single-branch (PyTorch) conﬁg-
uration; “Ours”: proposed multiple branch conﬁguration using DenseNet-BC as the basic block,
single training up to 25M parameters and ensembles of coupled ensembles beyond; SGDR-WRN:
snapshot ensembles with SGDR on Wide ResNets up to 110M parameters and ensembles of snap-
shot ensembles beyond; ”Other”: all other architectures mentioned in tables 3 and 4.

10

To be submitted as a conference paper at ICLR 2018

5 DISCUSSION

The proposed approach consists in replacing a single deep convolutional network by a number of
“basic blocks” which resemble standalone CNN models. The intermediate score vectors produced
by each of the basics blocks are coupled via a “fuse layer”. At training time, this is done by taking
an arithmetic average of their log-probabilites for the targets. At test time the score vectors are
averaged following the output from each score vector. Both of these aspects leads to a signiﬁcant
performance improvement over a single branch conﬁguration. This improvement comes at the cost
of a small increase in the training and prediction times. The proposed approach leads to the best
performance for a given parameter budget as can be seen in tables 3 and 4, and in ﬁgure 1.

The increase in training and prediction times is mostly due to the sequential processing of branches
during the forward and backward passes. The smaller size of the branches makes the data parallelism
on GPUs less efﬁcient. This effect is not as pronounced for larger models. This could be solved in
two ways. First, as there is no data dependency between the branches (before the averaging layer)
it is possible to extend the data parallelism to the branches, restoring the initial level of parallelism.
This can be done by implementing a parallel implementation of multiples 2D convolutions at the
same time. Second or alternatively, when multiple GPUs are used, it is possible to spread the
branches over the GPUs.

We have currently evaluated the coupled ensemble approach only on relatively small data sets. We
therefore plan to conduct experiments on ImageNet (Russakovsky et al., 2015) to check whether it
will work equally well on large collections.

ACKNOWLEDGEMENTS

This work has been partially supported by the LabEx PERSYVAL-Lab (ANR-11-LABX-0025-01).
Experiments presented in this paper were partly carried out using the Grid’5000 test-bed, supported
by a scientiﬁc interest group hosted by Inria and including CNRS, RENATER and several Universi-
ties as well as other organizations (see https://www.grid5000.fr).

REFERENCES

Amos, B. and Kolter, J. Z. (2017). A PyTorch Implementation of DenseNet. https://github.

com/bamos/densenet.pytorch. Accessed: June 2017.

Chollet, F. (2017). Xception: Deep learning with depthwise separable convolutions. In Proceedings

of the IEEE Conference on Computer Vision and Pattern Recognition.

Cires¸an, D., Meier, U., and Schmidhuber, J. (2012). Multi-column deep neural networks for image
In 2012 IEEE Conference on Computer Vision and Pattern Recognition, pages

classiﬁcation.
3642–3649.

Cires¸an, D. C., Meier, U., Gambardella, L. M., and Schmidhuber, J. (2011). Convolutional neural
In Proceedings of the 2011 In-
network committees for handwritten character classiﬁcation.
ternational Conference on Document Analysis and Recognition, ICDAR ’11, pages 1135–1139,
Washington, DC, USA.

Gastaldi, X. (2017). Shake-shake regularization. In International Conference on Learning Repre-

sentations. arXiv:1705.07485.

Hansen, L. K. and Salamon, P. (1990). Neural network ensembles. IEEE Transactions on Pattern

Analysis and Machine Intelligence, 12(10):993–1001.

He, K., Zhang, X., Ren, S., and Sun, J. (2016a). Deep residual learning for image recognition. In
2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR), pages 770–778.
arXiv:1512.03385.

He, K., Zhang, X., Ren, S., and Sun, J. (2016b). Identity Mappings in Deep Residual Networks,

pages 630–645.

11

To be submitted as a conference paper at ICLR 2018

Huang, G., Liu, Z., van der Maaten, L., and Weinberger, K. Q. (2017). Densely connected con-
volutional networks. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition.

Huang, G., Sun, Y., Liu, Z., Sedra, D., and Weinberger, K. Q. (2016). Deep Networks with Stochastic

Depth, pages 646–661.

Kawaguchi, K. (2016). Deep learning without poor local minima. In Advances in Neural Information

Processing Systems, pages 586–594.

Krizhevsky, A. and Hinton, G. (2009). Learning multiple layers of features from tiny images.

Krizhevsky, A., Sutskever, I., and Hinton, G. E. (2012). Imagenet classiﬁcation with deep convolu-
tional neural networks. In Pereira, F., Burges, C. J. C., Bottou, L., and Weinberger, K. Q., editors,
Advances in Neural Information Processing Systems 25, pages 1097–1105. Curran Associates,
Inc.

Lecun, Y., Bottou, L., Bengio, Y., and Haffner, P. (1998). Gradient-based learning applied to docu-

ment recognition. Proceedings of the IEEE, 86(11):2278–2324.

Loshchilov, I. and Hutter, F. (2017). SGDR: stochastic gradient descent with restarts. In Interna-

tional Conference on Learning Representations.

Netzer, Y., Wang, T., Coates, A., Bissacco, A., Wu, B., and Ng, A. Y. (2011). Reading digits in
In NIPS Workshop on Deep Learning and

natural images with unsupervised feature learning.
Unsupervised Feature Learning 2011.

Russakovsky, O., Deng, J., Su, H., Krause, J., Satheesh, S., Ma, S., Huang, Z., Karpathy, A., Khosla,
A., Bernstein, M., Berg, A. C., and Fei-Fei, L. (2015). ImageNet Large Scale Visual Recognition
Challenge. International Journal of Computer Vision (IJCV), 115(3):211–252.

Simonyan, K. and Zisserman, A. (2014). Very deep convolutional networks for large-scale image

recognition. CoRR, abs/1409.1556. Published at ICLR 2015.

Springenberg, J. T., Dosovitskiy, A., Brox, T., and Riedmiller, M. (2015). Striving for simplicity:

The all convolutional net. In International Conference on Learning Representations.

Szegedy, C., Liu, W., Jia, Y., Sermanet, P., Reed, S. E., Anguelov, D., Erhan, D., Vanhoucke, V., and
Rabinovich, A. (2015). Going deeper with convolutions. In Proceedings of the IEEE conference
on computer vision and pattern recognition, pages 1–9.

Xie, S., Girshick, R., Dollr, P., Tu, Z., and He, K. (2017). Aggregated residual transformations for
deep neural networks. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition.

Zagoruyko, S. and Komodakis, N. (2016). Wide residual networks. In Proceedings of the British

Machine Vision Conference 2016, BMVC 2016, York, UK, September 19-22, 2016.

Zhang, T., Qi, G.-J., Xiao, B., and Wang, J. (2017). Interleaved Group Convolutions for Deep Neural

Networks. In International Conference on Computer Vision.

Zhao, L., Wang, J., Li, X., Tu, Z., and Zeng, W. (2016). On the connection of deep fusion to

ensembling. arXiv preprint arXiv:1611.07718.

Zoph, B. and Le, Q. V. (2017). Neural architecture search with reinforcement learning. In Interna-

tional Conference on Learning Representations.

Zoph, B., Vasudevan, V., Shlens, J., and Le, Q. V. (2017). Learning transferable architectures for

scalable image recognition. arXiv preprint arXiv:1707.07012.

12

To be submitted as a conference paper at ICLR 2018

Supplementary Material

A IMPLEMENTATION

Figure 2 shows the common structure of the test (top) and train (bottom) versions of networks used
as basic blocks. Figure 3 shows how it is possible to place the averaging layer just after the last FC
layer of the basic block instances and before the SM layer which is then “factorized”. The e model
instances do not need to share the same architecture. Figure 3 shows how it is possible to place the
averaging layer just after the last FC layer, just after the SM (actually LSM (LogSoftMax), which is
equivalent to do a geometric mean of the SM values) layer, or just after the LL layer.

Figure 2: Versions of the base network. Top: test, bottom: train.

Figure 3: Test versions of coupled ensemble networks. Top: SM (classical) fusion, bottom: FC
fusion. AVG: averaging layer.

We reuse “basic blocks” from other groups (with appropriate credits, please let us know if any is
missing or requires updating) in their original form as much as possible both for efﬁciency and for
ensuring more meaningful comparisons. When available, we use the PyTorch implementations.

Each of the e branches is deﬁned by a parameter vector We containing the same parameters as
the original implementation. The global network is deﬁned by a parameter vector W which is a
concatenation of all the We parameter vectors. When training is done in the coupled mode and the
prediction is done in a separate mode or vice-versa, a dedicated script is used for splitting the W
vector into the We ones or vice-versa. In all coupled networks, for all train versions and for all test
version, the same global parameter vector W is used with the same split and deﬁning the same basic
block functions. This is how we can combine in any way all of the four possible training conditions
with all the three possible prediction conditions, even though not all of them are consistent or equally
efﬁcient.

The overall network architecture is determined by:

• the global hyper-parameter specifying the train versus test mode;

• the global hyper-parameter e specifying the number of branches;

• the global hyper-parameter specifying after which layer the AVG layer should be placed (FC, SM

or LL);

13

To be submitted as a conference paper at ICLR 2018

Figure 4: Train versions of coupled ensemble networks. Top: LL fusion, middle: SM fusion, bottom:
FC fusion.

• either one basic block to be replicated e times with its own hyper-parameters or a list of e basic

blocks, each with its own hyper-parameters.

B TEST TIME EQUIVALENCE BETWEEN FC AVERAGE AND LOGSOFTMAX

AVERAGE

Given branches E = E1, E2, ..Ee, each Ei produces a score vector of dimension C, where C is the
number of categories. An element of Ei is referenced as Ec
i , were c ∈ [1, C]. FC Average denotes
averaging the raw activations from each branch. LSM Average denotes averaging across branches,
after a LogSoftMax operation in applied on each branch activation vector, separately.
i=1 Ec
Case 1: FC average: Scoresc
i

F C = (cid:80)e

Case 2:

LogSof tM ax(Ec

n) = log

(cid:80)

exp(Ec
e)
c exp(Ec
e)
e) − log

= log exp(Ec

= Ec

e − Ze

(cid:88)

c

exp(Ec
e)

LSM = (cid:80)e

LSM average: Scoresc
e). Hence we
see that the LSM average score vector is a translated version of the FC average score vector. Also,
doing an arithmetic average of LogSoftMax values is equivalent to doing a geometric average of
SoftMax values. This holds during inference where we are interested only in the maximum value.

i=1 Zi, where Ze = log (cid:80)

C exp(Ec

i − (cid:80)e

i=1 Ec

C COMPARISON WITH Learnt ARCHITECTURES

In table 5, we compare the parameter usage and performance of the branched coupled ensembles
with model architectures that were recovered using meta learning techniques.

14

To be submitted as a conference paper at ICLR 2018

Table 5: Classiﬁcation error comparison with learnt architectures.

System
Neural Architecture Search v3 (Zoph and Le, 2017)
NASNet-A (Zoph et al., 2017)
DenseNet-BC L = 82 k = 10 e = 4
DenseNet-BC L = 88 k = 14 e = 4
DenseNet-BC L = 88 k = 20 e = 4

C10+ C100+
3.65
3.41
3.78
3.57
3.18

-
-
19.92
17.68
16.79

SVHN #Params
37.4M
3.3M
1.6M
3.5M
7.0M

-
-
1.62
1.55
1.57

D PERFORMANCE MEASUREMENT AND REPRODUCIBILITY ISSUES

When attempting to compare the relative performance of different methods, we face the issue of the
reproducibility of the experiments and of the statistical signiﬁcance of the observed difference be-
tween performance measures. Even for a same experiment, we identiﬁed the ﬁve following sources
of variation in the performance measure:

• Underlying framework for the implementation: we made experiments with Torch7 (lua) and with

PyTorch.

• Random seed for the network initialization.

• CuDNN non-determinism during training: GPU associative operations are by default fast but
non-deterministic. We observed that the results varies even for a same tool and the same seed. In
practice, the observed variation is as important as when changing the seed.

• Fluctuations associated to the computed moving average and standard deviation in batch normal-
ization: these ﬂuctuations can be observed even when training with the learning rate, the SGD
momentum and the weight decay all set to 0. During the last few epochs of training, their level of
inﬂuence is the same as with the default value of these hyper-parameters.

• Choice of the model instance chosen from training epochs:

the model obtained after the last
epoch, or the best performing model. Note that choosing the best performing model involves
looking at test data.

Regardless of the implementation, the numerical determinism, the Batch Norm moving average,
and the epoch sampling questions, we should still expect a dispersion of the evaluation measure
according to the choice of the random initialization since different random seeds will likely lead
to different local minima. It is generally considered that the local minima obtained with “properly
designed and trained” neural networks should all have similar performance (Kawaguchi, 2016). We
do observe a relatively small dispersion (quantiﬁed by the standard deviation below) conﬁrming this
hypothesis. This dispersion may be small but it is not negligible and it complicates the comparisons
between methods since differences in measures lower than their dispersions is likely to be non-
signiﬁcant. Classical statistical signiﬁcance tests do not help much here since differences that are
statistically signiﬁcant in this sense can be observed between models obtained just with different
seeds (and even with the same seed), everything else being kept equal.

Experiments reported in this section gives an estimation of the dispersion in the particular case of a
moderate scale model. We generally cannot afford doing a large number of trials for larger models.

We tried to quantify the relative importance of the different effects in the particular case of DenseNet-
BC with L = 100, k = 12 on CIFAR 100. Table 6 shows the results obtained for the same exper-
iment in the four groups of three rows. We tried four combinations corresponding to the use of
Torch7 versus PyTorch and to the use of the same seed versus the use of different seeds. For each of
these conﬁguration, we used as the performance measure: (i) the error rate of the model computed
at the last epoch or (ii) the average of the error rate of the models computed at the last 10 epochs,
(iii) the error rate of the model having the lowest error rate over all epochs. For these 2 × 2 × 3
cases, we present the minimum, the median, the maximum and the mean±standard deviation over
10 measures corresponding to 10 identical runs (except for the seed when indicated). Additionally,
in the case of the average of the error rate of the models computed at the 10 last epochs, we present
the root mean square of the standard deviation of the ﬂuctuations on the last 10 epochs (which is the
same as the square root of the mean of their variance). We make the following observations:

15

To be submitted as a conference paper at ICLR 2018

• There does not seem to be a signiﬁcant difference between Torch7 and PyTorch implementations;
• There does not seem to be a signiﬁcant difference between using a same seed and using different
seeds; the dispersion observed using the same seed (with everything else being equal) implies that
there is no way to exactly reproduce results;

• There does not seem to be a signiﬁcant difference between the means over the 10 measures com-
puted on the single last epoch and the means over the 10 measures computed on the last 10 epochs;
• The standard deviation of the measures computed on the 10 runs is slightly but consistently
smaller when the measures are computed on the last 10 epochs than when they are computed
on the single last epoch; this is the same for the difference between the best and the worst mea-
sures; this was expected since averaging the measure on the last 10 epochs reduces the ﬂuctuations
due to the moving average and standard deviation computed in batch normalization and possibly
too the the random ﬂuctuations due to the ﬁnal learning steps;

• The mean of the measures computed on the 10 runs is signiﬁcantly lower when the measure is
taken at the best epoch than when they are computed either on the single last epoch or on the last
10 epochs. This is expected since the minimum is always below the average. However, presenting
this measure involves using the test data for selecting the best model.

Table 6: Performance measurement and reproducibility issues. Statistics on 10 runs.

Seeds
diff.
diff.
diff.
same
same
same
diff.
diff.
diff.
same
same
same
diff.
diff.
diff.
diff.
diff.
diff.

Impl.
PyT.
PyT.
PyT.
PyT.
PyT.
PyT.
LuaT.
LuaT.
LuaT.
LuaT.
LuaT.
LuaT.
PyT.
PyT.
PyT.
PyT.
PyT.
PyT.

Last
1
10
best
1
10
best
1
10
best
1
10
best
1
10
best
1
10
best

L
100
100
100
100
100
100
100
100
100
100
100
100
82
82
82
100
100
100

k
12
12
12
12
12
12
12
12
12
12
12
12
8
8
8
12
12
12

e Min. Med. Max. Mean±SD RMS(SD)
1
1
1
1
1
1
1
1
1
1
1
1
3
3
3
4
4
4

22.89±0.21
22.87±0.17
22.54±0.24
23.06±0.23
23.04±0.22
22.71±0.18
22.90±0.20
22.86±0.20
22.49±0.18
22.82±0.34
22.87±0.30
22.54±0.29
21.49±0.15
21.45±0.11
21.14±0.14
17.65±0.18
17.66±0.14
17.45±0.16

22.64
22.67
22.13
22.77
22.81
22.44
22.55
22.55
22.17
22.33
22.47
22.24
21.27
21.24
20.84
17.24
17.37
17.11

23.22
23.14
22.91
23.55
23.49
23.02
23.11
23.08
22.75
23.58
23.51
23.24
21.70
21.63
21.30
17.86
17.81
17.66

22.80
22.83
22.56
23.05
22.98
22.67
22.94
22.89
22.52
22.82
22.92
22.51
21.44
21.46
21.18
17.71
17.67
17.46

n/a
0.13
n/a
n/a
0.11
n/a
n/a
0.12
n/a
n/a
0.12
n/a
n/a
0.12
n/a
n/a
0.11
n/a

Following these observations, we propose a method for ensuring the best reproducibility and the
fairest comparisons. Choosing the measure as the minimum of the error rate for all models computed
during the training seems neither realistic nor a good practice since we have no way to know which
model will be the best one without looking at the results (cross-validation cannot be used for that)
and this is like tuning on the test set. Even though this is not necessarily unfair for system comparison
if the measures are done in this condition for all systems, this does introduce a bias for the absolute
performance estimation. Using the error rate at the last iteration or at the 10 last iteration does not
seem to make a difference in the mean but the standard deviation is smaller for the latter, therefore
this one should be preferred when a single experiment is conducted. We also checked that using
the 10 or the 25 last epochs does not make much difference (learning at this point does not seem to
lead to further improvement). A value different from 10 can be used and this is not critical. In all
the CIFAR experiments reported in this paper, we used the average of the error rate for the models
obtained at the last 10 epochs as this should be (slightly) more robust and more conservative. The
case for SVHN experiments is slightly different since there is a much smaller number of much bigger
epochs; we used the last 4 iterations in this case.

These observations have been made in a quite speciﬁc case but the principle and the conclusions
(use of the average of the error rate from the last epochs should lead to more robust and conservative

16

To be submitted as a conference paper at ICLR 2018

results) are likely to be general. Table 6 also shows the results for a coupled ensemble network of
comparable size and for a coupled ensemble network four times bigger. Similar observations can be
made and, additionally, we can observe that both the range and the standard deviations are smaller.
This might be because an averaging is already made between the branches leading to a reduction of
the variance. Though this requires conﬁrmation at larger scales, coupled ensemble networks might
lead to both a better and a more stable performance.

17

