An Adversarial Neuro-Tensorial Approach For Learning Disentangled
Representations

Mengjiao Wang1 Zhixin Shu2 Shiyang Cheng1 Yannis Panagakis1 Dimitris Samaras2 Stefanos Zafeiriou1

1 Imperial College London

2 Stony Brook University

1 {m.wang15,shiyang.cheng11,i.panagakis,s.zafeiriou}@imperial.ac.uk 2 {zhshu,samaras}@cs.stonybrook.edu

8
1
0
2
 
b
e
F
 
4
2
 
 
]

V
C
.
s
c
[
 
 
2
v
2
0
4
0
1
.
1
1
7
1
:
v
i
X
r
a

Abstract

Several factors contribute to the appearance of an object
in a visual scene, including pose, illumination, and defor-
mation, among others. Each factor accounts for a source
of variability in the data, while the multiplicative interac-
tions of these factors emulate the entangled variability, giv-
ing rise to the rich structure of visual object appearance.
Disentangling such unobserved factors from visual data is
a challenging task, especially when the data have been cap-
tured in uncontrolled recording conditions (also referred to
as “in-the-wild”) and label information is not available.

In this paper, we propose the ﬁrst unsupervised deep
learning method (with pseudo-supervision) for disentan-
gling multiple latent factors of variation in face images
captured in-the-wild. To this end, we propose a deep la-
tent variable model, where the multiplicative interactions of
multiple latent factors of variation are explicitly modelled
by means of multilinear (tensor) structure. We demonstrate
that the proposed approach indeed learns disentangled rep-
resentations of facial expressions and pose, which can be
used in various applications, including face editing, as well
as 3D face reconstruction and classiﬁcation of facial ex-
pression, identity and pose.

1. Introduction

The appearance of visual objects is signiﬁcantly affected
by multiple factors of variability such as, for example, pose,
illumination, identity, and expression in case of faces. Each
factor accounts for a source of variability in the data, while
their complex interactions give rise to the observed entan-
gled variability. Discovering the modes of variation, or in
other words disentangling the latent factors of variations in
visual data, is a very important problem in the intersection
of statistics, machine learning, and computer vision.

Factor analysis [12] and the closely related Principal
Component Analysis (PCA) [16] are probably the most
popular statistical methods that ﬁnd a single mode of varia-
tion explaining the data. Nevertheless, visual appearance
(e.g., facial appearance) is affected by several modes of

variations. Hence, methods such as PCA are not able to
identify such multiple factors of variation. For example,
when PCA is applied to facial images, the ﬁrst principal
component captures both pose and expressions variations.

An early approach for learning different modes of vari-
ation in the data is TensorFaces [36].
In particular, Ten-
sorFaces is a strictly supervised method as it not only re-
quires the facial data to be labelled (e.g., in terms of expres-
sion, identity, illumination etc.) but the data tensor must
also contain all samples in all different variations. This is
the primary reason that the use of such tensor decomposi-
tions is still limited to databases that have been captured in a
strictly controlled environment, such as the Weizmann face
database [36].

Recent unsupervised tensor decompositions methods
[32, 37] automatically discover the modes of variation in
In particular, the most recent one [37]
unlabelled data.
assumes that the original visual data have been produced
by a hidden multilinear structure and the aim of the unsu-
pervised tensor decomposition is to discover both the un-
derlying multilinear structure, as well as the corresponding
weights (coefﬁcients) that best explain the data. Special in-
stances of the unsupervised tensor decomposition are the
Shape-from-Shading (SfS) decompositions in [17, 31] and
the multilinear decompositions for 3D face description in
[37].
In [37], it is shown that the method indeed can be
used to learn representations where many modes of varia-
tion have been disentangled (e.g., identity, expression and
illumination etc.). Nevertheless, the method in [37] is not
able to ﬁnd pose variations and bypasses this problem by
applying it to faces which have been frontalised by applying
a warping function (e.g., piece-wise afﬁne warping [25]).

Another promising line of research for discovering la-
tent representations is unsupervised Deep Neural Networks
(DNNs). Unsupervised DNNs architectures include the
Auto-Encoders (AE) [1], as well as the Generative Ad-
versarial Networks (GANs) [13] or adversarial versions
of AE, e.g., the Adversarial Auto-Encoders (AAE) [23].
Even though GANs, as well as AAEs, provide very elegant
frameworks for discovering powerful low-dimensional em-

1

Expression Editing

Pose Editing

Figure 1: Given a single in-the-wild image, our network learns disentangled representations for pose, illumination, expression
and identity. Using these representations, we are able to manipulate the image and edit the pose or expression.

beddings without having to align the faces, due to the com-
plexity of the networks, unavoidably all modes of variation
are multiplexed in the latent-representation. Only with the
use of labels it is possible to model/learn the manifold over
the latent representation, usually as a post-processing step
[30].

In this paper, we show that it is possible to learn a dis-
entangled representation of the human face captured in ar-
bitrary recording conditions in an unsupervised manner1 by
imposing a multilinear structure on the latent representa-
tion of an AAE [30]. To the best of our knowledge, this is
the ﬁrst time that unsupervised tensor decompositions have
been combined with DNNs for learning disentangled repre-
sentations. We demonstrate the power of the proposed ap-
proach by showing expression/pose transfer using only the
latent variable that is related to expression/pose. We also
demonstrate that the disentangled low-dimensional embed-
dings are useful for many other applications, such as facial
expression, pose, and identity recognition and clustering.
An example of the proposed approach is given in Fig. 1. In
particular, the left pair of images have been decomposed,
using the encoder of the proposed neural network E(·), into
many different latent representations including latent rep-
resentations for pose, illumination, identity and expression.
Since our framework has learned a disentangled represen-
tation we can easily transfer the expression by only chang-
ing the latent variable related to expression and passing the
latent vector into the decoder of our neural network D(·).
Similarly, we can transfer the pose merely by changing the
latent variable related to pose.

2. Related Work

Learning disentangled representations that explain mul-
tiple factors of variation in the data as disjoint latent dimen-

1Our methodology uses the information produced by an automatic 3D
face ﬁtting procedure [4] but it does not make use of any labels in the
training set.

sions is desirable in several machine learning, computer vi-
sion, and graphics tasks.

Indeed, bilinear factor analysis models [33] have been
employed for disentangling two factors of variation (e.g.,
head pose and facial identity) in the data.
Identity, ex-
pression, pose, and illumination variations are disentangled
in [36] by applying Tucker decomposition (also known as
multilinear Singular Value Decomposition (SVD) [10]) into
a carefully constructed tensor through label information. In-
terestingly, the modes of variation in well aligned images
can be recovered via a multilinear matrix factorization [37]
without any supervision. However, inference in [37] might
be ill-posed.

More recently, both supervised and unsupervised deep
learning methods have been developed for disentangled rep-
resentations learning. Transforming auto-encoders [15] is
among the earliest methods for disentangling latent factors
by means of auto-encoder capsules. In [11] hidden factors
of variation are disentangled via inference in a variant of
the restricted Boltzmann machine. Disentangled represen-
tations of input images are obtained by the hidden layers of
deep networks in [8] and through a higher-order Boltzmann
machine in [27]. The Deep Convolutional Inverse Graph-
ics Network [20] learns a representation that is disentangled
with respect to transformations such as out-of-plane rota-
tions and lighting variations. Methods in [6, 24, 5, 34, 35]
extract disentangled and interpretable visual representations
by employing adversarial training. The method in [30] dis-
entangles the latent representations of illumination, surface
normals, and albedo of face images using an image render-
ing pipeline. Trained with pseudo-supervision, [30] under-
takes multiple image editing tasks by manipulating the rel-
evant latent representations. Nonetheless, this editing ap-
proach still requires expression labelling, as well as sufﬁ-
cient sampling of a speciﬁc expression.

Here, the proposed network is able to edit the expression
of a face image given another single in-the-wild face image
of arbitrary expression. Furthermore, we are able to edit the

Figure 2: Our network is an end-to-end trained auto-encoder. The encoder E extracts latent variables corresponding to
illumination, pose, expression and identity from the input image x. These latent variables are then fed into the decoder D
to reconstruct the image. We impose a multilinear structure and enforce the disentangling of variations. The grey triangles
represent the losses: adversarial loss A, L1 and L2 losses.

pose of a face in the image which is not possible in [30].

3.1. Facial Texture

3. Proposed Method

In this section, we will introduce the main multilinear
models used to describe three different image modalities,
namely texture, 3D shape and 3D surface normals. To this
end, we assume that for each different modality there is a
different core tensor but all modalities share the same latent
representation of weights regarding identity and expression.
During training all the core tensors inside the network are
randomly initialised and learnt end-to-end. In the following,
we assume that we have a set of n facial images (e.g., in the
training batch) and their corresponding 3D facial shape, as
well as their normals per pixel (the 3D shape and normals
have been produced by ﬁtting a 3D model on the 2D image,
e.g., [4]).

The main assumption here follows from [37]. That is,
the rich structure of visual data is a result of multiplica-
tive interactions of hidden (latent) factors and hence the un-
derlying multilinear structure, as well as the corresponding
weights (coefﬁcients) that best explain the data can be re-
covered using the unsupervised tensor decomposition [37].
Indeed, following [37], disentangled representations can
be learnt (e.g., identity, expression, and illumination, etc.)
from frontalised facial images. The frontalisation process is
performed by applying a piecewise afﬁne transform using
the sparse shape recovered by a face alignment process. In-
evitably, this process suffers from warping artifacts. There-
fore, rather than applying any warping process, we perform
the multilinear decomposition only on near frontal faces,
which can be automatically detected during the 3D face ﬁt-
ting stage. In particular, assuming a near frontal facial im-
age rasterised in a vector xf ∈ Rkx×1, given a core tensor

Q ∈ Rkx×kl×kexp×kid 2, this can be decomposed as

3.4. 3D Facial Pose

xf = Q ×2 zl ×3 zexp ×4 zid,

(1)

where zl ∈ Rkl , zexp ∈ Rkexp and zid ∈ Rkid are the
weights that correspond to illumination, expression and
identity respectively. The equivalent form in case that we
have a number of images in the batch stacked in the columns
of a matrix Xf ∈ Rkx×n is

Xf = Q(1)(Zl (cid:12) Zexp (cid:12) Zid),

(2)

where Q(1) is a mode-1 matricisation of tensor Q and Zl,
Zexp and Zid are the corresponding matrices that gather the
weights of the decomposition for all images in the batch.
That is, Zexp ∈ Rkexp×n stacks the n latent variables of
expressions of the images, Zid ∈ Rkid×n stacks the n latent
variables of identity and Zl ∈ Rkl×n stacks the n latent
variables of illumination.

3.2. 3D Facial Shape

It is quite common to use a bilinear model for disentan-
gling identity and expression in 3D facial shape [3]. Hence,
for 3D shape we assume that there is a different core tensor
B ∈ Rk3d×kexp×kid and each 3D facial shape x3d ∈ Rk3d
can be decomposed as:

x3d = B ×2 zexp ×3 zid,

where zexp and zid are exactly the same weights as in the
texture decomposition (2). The tensor decomposition for
the n images in the batch is therefore written as as

(3)

(4)

X3d = B(1)(Zexp (cid:12) Zid),

where B(1) is a mode-1 matricization of tensor B.

3.3. Facial Normals

The tensor decomposition we opted to use for facial nor-
mals was exactly the same as the texture, hence we can use
the same core tensor and weights. The difference is that
since facial normals do not depend on illumination param-
eters (assuming a Lambertian illumination model), we just
need to replace the illumination weights with a constant3.
Thus, the decomposition for normals can be written as

1
kl
where 1 is a matrix of ones.

XN = Q(1)(

1 (cid:12) Zexp (cid:12) Zid),

(5)

2 Tensors notation: Tensors (i.e., multidimensional arrays) are and de-
noted by calligraphic letters, e.g., X . The mode-m matricisation of a ten-
sor X ∈ RI1×I2×···×IM maps X to a matrix X(m) ∈ RIm× ¯Im . The
mode-m vector product of a tensor X ∈ RI1×I2×...×IM with a vector
x ∈ RIm , denoted by X ×n x ∈ RI1×I2×···×In−1×In+1×···×IN .

The Kronecker product is denoted by ⊗ and the Khatri-Rao (i.e.,
column-wise Kronecker product) product is denoted by (cid:12). More details
on tensors and multilinear operators can be found in [18].

3This is also the way that normals are computed in [37] up to a scaling

factor

Finally, we deﬁne another latent variable regarding 3D
pose. This latent variable zp ∈ R9 represents a 3D rota-
tion. We denote by xi ∈ Rkx an image at index i. The
indexing is denoted in the following by the superscript. The
corresponding zi
p can be reshaped into a rotation matrix
Ri ∈ R3×3. As proposed in [39], we apply this rotation
to the feature of the image xi created by 2-way synthesis
(explained in Section 3.5). This feature vector is the i-th
column of the feature matrix resulting from the 2-way syn-
thesis (Zexp (cid:12) Zid) ∈ Rkexpkid×n. We denote this feature
vector corresponding to a single image as (Zexp (cid:12) Zid)i ∈
Rkexpkid . Next (Zexp (cid:12) Zid)i is reshaped into a 3 × kexpkid
matrix and left-multiplied by Ri. After another round of
vectorisation, the resulting feature ∈ Rkexpkid becomes the
input of the decoders for normal and albedo. This trans-
formation from feature vector (Zexp (cid:12) Zid)i to the rotated
feature is called rotation.

3

3.5. Network Architecture

We incorporate the structure imposed by Equations (2),
(4) and (5) into an auto-encoder network, see Figure 2. For
some matrices Yi ∈ Rkyi×n, we refer to the operation Y1 (cid:12)
Y2 ∈ Rky1ky2×n as 2-way synthesis and Y1 (cid:12) Y2 (cid:12) Y3 ∈
Rky1ky2ky3×n as 3-way synthesis. The multiplication of a
feature matrix by B(1) or Q(1), mode-1 matricisations of
tensors B and Q, is referred to as projection and can be
represented by an unbiased fully-connected layer.

Our network follows the architecture of [30]. The en-
coder E receives an input image x and the convolutional
encoder stack ﬁrst encodes it into zi, an intermediate la-
tent variable vector of size 128 × 1. zi is then transformed
into latent codes for background zb, mask zm, illumina-
tion zl, pose zp, identity zid and expression zexp via fully-
connected layers.

E(x) = [zb, zm, zl, zp, zid, zexp]T .

(6)

The decoder D takes in the latent codes as input. zb and
zm (128 × 1 vectors) are directly passed into convolutional
decoder stacks to estimate background and face mask re-
spectively. The remaining latent variables follow 3 streams:

1. zexp (15×1 vector) and zid (80×1 vector) are joined by
2-way synthesis and projection to estimate facial shape
ˆx3d.

2. The result of 2-way synthesis of zexp and zid is rotated
using zp. The rotated feature is passed into 2 different
convolutional decoder stacks: one for normal estima-
tion and another for albedo. Using the estimated nor-
mal map, albedo, illumination component zl, mask and
background, we render a reconstructed image ˆx.

3. zexp, zid and zl are combined by a 3-way synthesis and
projection to estimate frontal normal map and a frontal
reconstruction of the image.

Streams 1 and 3 drive the disentangling of expression and
identity components, while stream 2 focuses on the recon-
struction of the image by adding the pose components.

D(zb, zm, zl, zp, zid, zexp) = ˆx.

(7)

Our input images are aligned and cropped facial im-
ages from the CelebA database [21] of size 64 × 64, so
kx = 3 × 64 × 64. k3d = 3 × 9375, kl = 9, kid = 80 and
kexp = 15. More details on the network such as the convo-
lutional encoder stacks and decoder stacks can be found in
the supplementary material.

3.6. Training

We use in-the-wild face images for training. Hence, we
only have access to the image itself (x) while ground truth
labelling for pose, illumination, normal, albedo, expression,
identity or 3D shape is unavailable. The main loss function
is the reconstruction loss of the image x:

Ex = Erecon + λadvEadv + λveriEveri,

(8)

where ˆx is the reconstructed image, Erecon = (cid:107)x − ˆx(cid:107)2
2 is
the reconstruction loss, λadv and lambdaadv are regularisa-
tion weights, Eadv represents the adversarial loss and Everi
the veriﬁcation loss. We use the pre-trained veriﬁcation net-
work V [40] to ﬁnd face embeddings of our images x and ˆx.
As both images are supposed to represent the same person,
we minimise the cosine distance between the embeddings:
Everi = 1 − cos(V(x), V( ˆx)). Simultaneously, a discrimi-
native network D is trained to distinguish between the gen-
erated and real images [13]. We incorporate the discrimi-
native information by following the auto-encoder loss dis-
tribution matching approach of [2]. The discriminative net-
work D is itself an auto-encoder trying to reconstruct the in-
put image x so the adversarial loss is Eadv = (cid:107) ˆx−D( ˆx)(cid:107)1.
D is trained to minimise (cid:107)x − D(x)(cid:107)1 − kt(cid:107) ˆx − D( ˆx)(cid:107)1.
As fully unsupervised training often results in semanti-
cally meaningless latent representations, Shu et al. [30] pro-
posed to train with pseudo ground truth values for normals,
lighting and 3D facial shape. We adopt here this technique
and introduce further pseudo ground truth values for pose
ˆxp, expression
ˆxexp and ˆxid
are obtained by ﬁtting coarse face geometry to every image
in the training set using a 3D Morphable Model [4]. We
incorporated the constraints used in [30] for illumination,
normals and albedo. Hence, the following new objectives
are introduced:

ˆxexp and identity ˆxid.

ˆxp,

Ep = (cid:107)zp − ˆxp(cid:107)2
2,

(9)

where ˆxp is a 3D camera rotation matrix.

Eexp = (cid:107)f c(zexp) − ˆxexp(cid:107)2
2,
ˆxexp ∈ R28 is a
where fc(·) is a fully-connected layer and
pseudo ground truth vector representing 3DMM expression
components of the image x.

(10)

Eid = (cid:107)f c(zid) − ˆxid(cid:107)2
2
where fc(·) is a fully-connected layer and ˆxid ∈ R157 is
a pseudo ground truth vector representing 3DMM identity
components of the image x.

(11)

Multilinear Losses

Directly applying the above losses as constraints to the la-
tent variables does not result in a well-disentangled repre-
sentation. To achieve a better performance, we impose a
tensor structure on the image using the following losses:

E3d = (cid:107) ˆx3d − B ×2 zexp ×3 zid(cid:107)2
2,

(12)

where ˆx3d is the 3D facial shape of the ﬁtted model.

Ef = (cid:107)xf − Q ×2 zl ×3 zexp ×4 zid)(cid:107)2
2,

(13)

where xf is a semi-frontal face image. During training, Ef
is only applied on near-frontal face images ﬁltered using ˆxp.

En = (cid:107) ˆnf − Q ×2

1 ×3 zexp ×4 zid)(cid:107)2
2

(14)

1
kl

where ˆnf is a near frontal normal map. During training, the
loss En is only applied on near frontal normal maps.

The model is trained end-to-end by applying gradient de-
scent to batches of images, where Equations (12), (13) and
(14) are written in the following general form:

E = (cid:107)X − B(1)(Z(1) (cid:12) Z(2) (cid:12) · · · (cid:12) Z(M ))(cid:107)2
F ,

(15)

where M is the number of modes of variations, X ∈ Rk×n
is a data matrix, B(1) is the mode-1 matricisation of a tensor
B and Z(i) ∈ Rkzi×n are the latent variables matrices.

The partial derivative of (15) with respect to the latent
variable Z(i) are computed as follows: Let ˆx = vec(X) be
the vectorised X, ˆz(i) = vec(Z(i)) be the vectorised Z(i),
ˆZ(i+1) =

ˆZ(i−1) = Z(1) (cid:12) Z(2) (cid:12) · · · (cid:12) Z(i−1) and
Z(i+1) (cid:12) · · · (cid:12) Z(M ) , then (15) is equivalent with:

(cid:107) ˆx − (I ⊗ B(1))vec(Z(1) (cid:12) Z(2) (cid:12) · · · (cid:12) Z(M ))(cid:107)2
F

=(cid:107) ˆx − (I ⊗ B(1))(I (cid:12) ˆZ(i−1)) ⊗ I
ˆZ(i+1)(I ⊗ 1)) · ˆz(i)(cid:107)2
2

· I (cid:12) (

(16)
Consequently the partial derivative of (15) with respect
to Z(i) is obtained by matricising the partial derivative

Figure 3: Our proof-of-concept network is an end-to-end trained auto-encoder. The encoder E extracts latent variables
corresponding to expression and identity from the input image x. These latent variables are then fed into the decoder D to
reconstruct the image. A separate stream also reconstructs facial texture from zid. We impose a multilinear structure and
enforce the disentanglement of variations. In the extended version b) the encoder also extracts a latent variable corresponding
to pose. The decoder takes in this information and reconstructs an image containing pose variations.

Original Image Expression

Our Recon Our Exp Edit Ground Truth Original Image Expression

Our Recon Our Exp Edit Ground Truth

Figure 4: Our network is able to transfer the expression from one face to another by disentangling the expression components
of the images. The ground truth has been computed using the ground truth texture with synthetic identity and expression
components.

of (16) with respect to Z(i), which is easy to compute an-
alytically. The derivation of this can be found in the sup-
plemental material. To efﬁciently compute the above men-
tioned operations, Tensorly [19] has been employed.

4. Proof of Concept Experiments

We develop a lighter version of our proposed network, a
proof-of-concept network (visualised in Figure 3), to show
that our network is able to learn and disentangle pose, ex-
pression and identity.

In order to showcase the ability of the network, we lever-
age our newly proposed 4DFAB database [7], where sub-
jects were invited to attend four sessions at different times in
a span of ﬁve years. In each experiment session, the subject
was asked to articulate 6 different facial expressions (anger,
disgust, fear, happiness, sadness, surprise), and we manu-
ally select the most expressive mesh (i.e. the apex frame)
for this experiment. In total, 1795 facial meshes from 364
recording sessions (with 170 unique identities) are used. We
keep 148 identities for training and leave 22 identities for

Input

Ground
Truth

Recons-
truction

Input

Ground
Truth

Recons-
truction

Figure 5: Given a single image, we infer meaningful expression and identity components to reconstruct a 3D mesh of the
face. We compare the reconstruction (last row) against the ground truth (2nd row).

Figure 6: Given a single image, we infer the facial texture. We compare the reconstructed facial texture (last row) against the
ground truth texture (2nd row).

Original Image

Pose

Our Recon Our Pose Edit Ground Truth Original Image

Pose

Our Recon Our Pose Edit Ground Truth

Figure 7: Our network is able to transfer the pose from one face to another by disentangling the pose, expression and identity
components of the images. The ground truth has been computed using the ground truth texture with synthetic pose, identity
and expression components.

testing. Note that there are no overlapping of identities be-
tween both sets. Within the training set, we synthetically
augment each facial mesh by generating new facial meshes
with 20 randomly selected expressions. Our training set

contains in total 35900 meshes. The test set contains 387
meshes. For each mesh, we have the ground truth facial
texture as well as expression and identity components of
the 3DMM model.

Original Image Expression

Our Recon Our Exp Edit

Baseline

Original Image Expression

Our Recon Our Exp Edit

Baseline

Figure 8: Our network is able to transfer the expression from one face to another by disentangling the expression components
of the images. We compare our expression editing results with a baseline where a 3DMM has been ﬁt to both input images.

4.1. Disentangling Expression and Identity

We create frontal images of the facial meshes. Hence
there is no illumination or pose variation in this training
dataset. We train a lighter version of our network by remov-
ing the illumination and pose streams, a proof-of-concept
network, visualised in Figure 3, on this synthetic dataset.

4.1.1 Expression Editing

We show the disentanglement between expression and iden-
tity by transferring the expression of one person to another.
For this experiment, we work with unseen data (a hold-
out set consisting of 22 unseen identities) and no labels. We
ﬁrst encode both input images xi and xj:

where E(·) is our encoder and zexp and zid are the latent
representations of expression and identity respectively.

Assuming we want xi to emulate the expression of xj,

we decode on:

D(zj

exp, zi

id) = xji,

(18)

where D(·) is our decoder. The resulting xji becomes our
edited image where xi has the expression of xj. Figure 4
shows how the network is able to separate expression and
identity. The edited images clearly maintain the identity
while expression changes.

E(xi) = zi
E(xj) = zj

exp, zi
id,
exp, zj
id,

4.1.2

3D Reconstruction and Facial Texture

(17)

The latent variables zexp and zid that our network learns
are extremely meaningful. Not only can they be used to re-
construct the image in 2D, but also they can be mapped into

Original
Image

Expression Our Recon

B & W

[37]

Expression Our Recon

B & W

[37]

Original
Image

Our Exp
Edit

Our Exp
Edit

Figure 9: We compare our expression editing results with [37]. As [37] is not able to disentangle pose, editing expressions
from images of different poses returns noisy results.

Original Image

Pose

Our Recon Our Pose Edit

Baseline

Original Image

Pose

Our Recon Our Pose Edit

Baseline

Figure 10: Our network is able to transfer the pose of one face to another by disentangling the pose components of the images.
We compare our pose editing results with a baseline where a 3DMM has been ﬁt to both input images.

the expression (xexp) and identity (xid) components of a
3DMM model. This mapping is learnt inside the network.
By replacing the expression and identity components of a
ˆxexp and ˆxid, we are able to recon-
mean face shape with
struct the 3D mesh of a face given a single input image.
We compare these reconstructed meshes against the ground
truth 3DMM used to create the input image in Figure 5.

4.2. Disentangling Pose, Expression and Identity

Our synthetic training set contains in total 35900 meshes.
For each mesh, we have the ground truth facial texture as
well as expression and identity components of the 3DMM,
from which we create a corresponding image with one of
7 given poses. As there is no illumination variation in this
training set, we train a proof-of-concept network by remov-
ing the illumination stream, visualised in Figure 3b, on this
synthetic dataset.

At the same time, the network is able to learn a map-
ping from zid to facial texture. Therefore, we can predict
the facial texture given a single input image. We compare
the reconstructed facial texture with the ground truth facial
texture in Figure 6.

4.2.1 Pose Editing

We show the disentanglement between pose, expression and
identity by transferring the pose of one person to another.

Source

ˆssource

[30]
ˆssource

Reconstruc-
tion

Ground
Truth

Reconstruc-
tion

Ground
Truth

Input

Input

Target

Reconstruc-
tion

ˆstarget

stransf er

Result

Ours

[30]

Ours

[30]

Figure 11: Using the illumination and normals estimated by
our network, we are able to relight target faces using illumi-
nation from the source image. The source ˆssource and target
shading ˆstarget are displayed to visualise against the new
transferred shading stransf er. We compare against [30].

Figure 7 shows how the network is able to separate pose
from expression and identity. This experiment highlights
the ability of our proposed network to learn large pose vari-
ations even from proﬁle to frontal faces.

5. Experiments in-the-wild

We train our network on in-the-wild data and perform
several experiments on unseen data to show that our net-
work is indeed able to disentangle illumination, pose, ex-
pression and identity.

We edit expression or pose by swapping the latent ex-
pression/pose component learnt by the encoder E (Eq. (6))
with the latent expression/pose component predicted from
another image. We feed the decoder D (Eq. (7)) with the
modiﬁed latent component to retrieve our edited image.

5.1. Expression and Pose Editing in-the-wild

Given two in-the-wild images of faces, we are able to
transfer the expression or pose of one person to another.
Transferring the expression from two different facial images
without ﬁtting a 3D model is a very challenging problem.

Figure 12: Given a single image, we infer meaningful ex-
pression and identity components to reconstruct a 3D mesh
of the face. We compare the reconstruction against the
ground truth provided by 3DMM ﬁtting.

Generally, it is considered in the context of the same person
under an elaborate blending framework [41] or by transfer-
ring certain classes of expressions [29].

For this experiment, we work with completely unseen
data (a hold-out set of CelebA) and no labels. We ﬁrst en-
code both input images xi and xj:

E(xi) = zi
E(xj) = zj

exp, zi
exp, zj

id, zi
p
id, zj
p,

(19)

(20)

where E(·) is our encoder and zexp, zid, zp are the la-
tent representations of expression, identity and pose respec-
tively.

Assuming we want xi to take on the expression or pose

of xj, we then decode on:

D(zj
D(zi

exp, zi
exp, zi

id, zi
id, zj

p) = xjii
p) = xiij,

where D(·) is our decoder.

The resulting xjii then becomes our result image where
xi has the expression of xj. xjii is the edited image where
xi changed to the pose of xj.

As there is currently no prior work for this expression
editing experiment without ﬁtting an AAM [9] or 3DMM,
we used the image synthesised by the 3DMM ﬁtted models
as a baseline, which indeed performs quite well. Compared
with our method, other very closely related works [37, 30]

Method Mean±Std against [38]

<35◦

<40◦

[37]
[30]
Proposed

33.37◦± 3.29◦
30.09◦± 4.66◦
28.67◦± 5.79◦

75.3% 96.3%
84.6% 98.1%
89.1% 96.3%

Table 1: Angular error for the various surface normal esti-
mation methods on the Photoface [42] dataset

lighted image result xtransf er. In Figure 11 we show the
performance of our method and compare against [30] on
illumination transfer. We observe that our method outper-
forms [30] as we obtain more realistic looking results. We
include further comparison images with [30] in the supple-
mental material.

5.3. 3D Reconstruction

The latent variables zexp and zid that our network learns
are extremely meaningful. Not only can they be used to re-
construct the image in 2D, they can be mapped into the ex-
pression (xexp) and identity (xid) components of a 3DMM.
This mapping is learnt inside the network. By replacing the
expression and identity components of a mean face shape
ˆxexp and ˆxid, we are able to reconstruct the 3D mesh
with
of a face given a single in-the-wild 2D image. We compare
these reconstructed meshes against the ﬁtted 3DMM to the
input image.

The results of the experiment are visualised in Figure 12.
We observe that the reconstruction is very close to the
ground truth. Both techniques though do not capture well
the identity of the person in the input image due to a known
weakness in 3DMM.

5.4. Normal Estimation

We evaluate our method on the surface normal estima-
tion task on the Photoface [42] dataset which has informa-
tion about illumination. Assuming the normals found using
calibrated Photometric Stereo [38] as “ground truth”, we
calculate the angular error between our estimated normals
and the “ground truth”. Figure 13 and Table 1 quantitatively
evaluates our proposed method against prior works [37, 30]
in the normal estimation task. We observe that our proposed
method performs on par or outperforms previous methods.

5.5. Quantitative Evaluation of the Latent Space

We want to test whether our latent space corresponds
well to the variation that it is supposed to learn. For our
quantitative experiment, we used Multi-PIE [14] as our test
dataset. This dataset contains labelled variations in iden-
tity, expressions and pose. Disentanglement of variations in
Multi-PIE is particularly challenging as its images are cap-
tured under laboratory conditions which is quite different

Figure 13: Comparison of the estimated normals obtained
using the proposed model vs the ones obtained by [37] and
[30].

are not able to disentangle illumination, pose, expression
In particular, [30] disentangles illumination
and identity.
of an image while [37] disentangles illumination, expres-
sion and identity from “frontalised” images. Hence they are
not able to disentangle pose. None of these methods can
be applied to the expression/pose editing experiments on a
dataset that contains pose variations such as CelebA. If [37]
is applied directly on our test images, it would not be able
to perform expression editing well, as shown by Figure 9.

For the 3DMM baseline, we ﬁt a shape model to both im-
ages and extract the expression components of the model.
We then generate a new face shape using the expression
components of one face and the identity components of an-
other face in the same 3DMM setting. This technique has
much higher overhead than our proposed method as it re-
quires time-consuming 3DMM ﬁtting of the images. Our
expression editing results and the baseline results are shown
in Figure 8. Though the baseline is very strong, it does not
change the texture of the face which can produce unnatu-
ral looking faces shown with original expression. Also, the
baseline method can not ﬁll up the inner mouth area. Our
editing results show more natural looking faces.

For pose editing, the background is unknown once the
pose has changed, thus, for this experiment, we mainly fo-
cus on the face region. Figure 10 shows our pose editing
results. For the baseline method, we ﬁt a 3DMM to both
images and estimate the rotation matrix. We then synthe-
sise xi with the rotation of xj. This technique has high
overhead as it requires expensive 3DMM ﬁtting of the im-
ages.

5.2. Illumination Editing

We transfer illumination by estimating the normals ˆn,
albedo ˆa and illumination components ˆl of the source
(xsource) and target (xtarget) images. Then we use ˆntarget
and ˆlsource to compute the transferred shading stransf er
and multiply the new shading by ˆatarget to create the re-

Zexp

Z0

Figure 14: Visualisation of our Zexp and baseline Z0 using t-SNE. Our latent Zexp clusters better with regards to expression
than the latent space Z0 of an auto-encoder.

Zp

Z0

Figure 15: Visualisation of our Zp and baseline Z0 using t-SNE. It is evident that the proposed disentangled Zp clusters
better with regards to pose than the latent space Z0 of an auto-encoder.

from that of our training images. As a matter of fact, the ex-
pressions contained in Multi-PIE do not correspond to the 7
basic expressions and can be easily confused.

We encoded 10368 images of the Multi-PIE dataset with
54 identities, 6 expressions and 7 poses and trained a linear
SVM classiﬁer using 90% of the identity labels and the la-
tent variables zid. We then test on the remaining 10% zid
to check whether they are discriminative for identity clas-
siﬁcation. We use 10-fold cross-validation to evaluate the
accuracy of the learnt classiﬁer. We repeat this experiment
for expression with zexp and pose with zp respectively. Our
results in Table 2 show that our latent representation is in-
deed discriminative. This experiment showcases the dis-
criminative power of our latent representation on a previ-
In order to quantitatively compare
ously unseen dataset.
with [37], we run another experiment on only frontal im-
ages of the dataset with 54 identities, 6 expressions and 16
illuminations. The results in Table 3 shows how our pro-
posed model outperforms [37] in these classiﬁcation tasks.
Our latent representation has stronger discriminative power
than the one learnt by [37].

We visualise, using t-SNE [22], the latent Zexp and Zp
encoded from Multi-PIE according to their expression and
pose label and compare against the latent representation Z0
learnt by an in-house large-scale adversarial auto-encoder

zidentity

zexpression

zpose

Accuracy

83.85%

86.07%

95.73%

Table 2: Classiﬁcation accuracy results: we try to classify
54 identities using zid, 6 expressions using zexp and 7 poses
using zp.

of similar architecture trained with 2 million faces [23]. Fig-
ures 14 and 15 show that even though our encoder has not
seen any images of Multi-PIE, it manages to create informa-
tive latent representations that cluster well expression and
pose (contrary to the representation learned by the tested
auto-encoder).

6. Conclusion

We proposed the ﬁrst, to the best of our knowledge, at-
tempt to jointly disentangle modes of variation that corre-
spond to expression, identity, illumination and pose using
no explicit labels regarding these attributes. More speciﬁ-
cally, we proposed the ﬁrst, as far as we know, approach that
combines a powerful Deep Convolutional Neural Network
(DCNN) architecture with unsupervised tensor decomposi-
tions. We demonstrate the power of our methodology in ex-
pression and pose transfer, as well as discovering powerful

Identity

zidentity C [37]

Accuracy

99.33% 19.18 %

Expression

zexpression E [37]

Accuracy

78.92%

35.49

Illumination

zillumination L [37]

Accuracy

64.11%

48.85%

Table 3: Classiﬁcation accuracy results in comparison
with [37]: As [37] works on frontal images, we only con-
sider frontal images in this experiment. We try to classify
54 identities using zid vs. C, 6 expressions using zexp vs.
E and 16 illumination using zill vs. L.

features for pose and expression classiﬁcation.

References

[1] Y. Bengio, A. Courville, and P. Vincent. Representation
learning: A review and new perspectives. IEEE transactions
on pattern analysis and machine intelligence, 35(8):1798–
1828, 2013. 1

[2] D. Berthelot, T. Schumm, and L. Metz. Began: Boundary
equilibrium generative adversarial networks. arXiv preprint
arXiv:1703.10717, 2017. 5

[3] T. Bolkart and S. Wuhrer. A robust multilinear model learn-
ing framework for 3d faces. In Proceedings of the IEEE Con-
ference on Computer Vision and Pattern Recognition, pages
4911–4919, 2016. 4

[4] J. Booth, E. Antonakos, S. Ploumpis, G. Trigeorgis, Y. Pana-
gakis, and S. Zafeiriou. 3d face morphable models” in-the-
wild”. arXiv preprint arXiv:1701.05360, 2017. 2, 3, 5
[5] C. X. D. T. Chaoyue Wang, Chaohui Wang. Tag disen-
tangled generative adversarial network for object image re-
rendering. In Proceedings of the Twenty-Sixth International
Joint Conference on Artiﬁcial Intelligence, IJCAI-17, pages
2901–2907, 2017. 2

[6] X. Chen, Y. Duan, R. Houthooft, J. Schulman, I. Sutskever,
and P. Abbeel. Infogan: Interpretable representation learning
by information maximizing generative adversarial nets.
In
Advances in Neural Information Processing Systems, pages
2172–2180, 2016. 2

[7] S. Cheng, I. Kotsia, M. Pantic, and S. Zafeiriou. 4dfab: A
large scale 4d facial expression database for biometric appli-
cations. In arXiv:1712.01443, 2017. 6

[8] B. Cheung, J. A. Livezey, A. K. Bansal, and B. A. Olshausen.
Discovering hidden factors of variation in deep networks.
arXiv preprint arXiv:1412.6583, 2014. 2

[9] T. F. Cootes, G. J. Edwards, and C. J. Taylor. Active appear-
IEEE Transactions on pattern analysis and

ance models.
machine intelligence, 23(6):681–685, 2001. 10

[10] L. De Lathauwer, B. De Moor, and J. Vandewalle. A multi-
linear singular value decomposition. SIAM journal on Matrix
Analysis and Applications, 21(4):1253–1278, 2000. 2
[11] G. Desjardins, A. Courville, and Y. Bengio. Disentangling
factors of variation via generative entangling. arXiv preprint
arXiv:1210.5474, 2012. 2

[12] L. R. Fabrigar and D. T. Wegener. Exploratory factor analy-

sis. Oxford University Press, 2011. 1

[13] I. Goodfellow,

J. Pouget-Abadie, M. Mirza, B. Xu,
D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio. Gen-
erative adversarial nets. In Advances in neural information
processing systems, pages 2672–2680, 2014. 1, 5

[14] R. Gross, I. Matthews, J. Cohn, T. Kanade, and S. Baker.
Image and Vision Computing, 28(5):807–813,

Multi-PIE.
2010. 11

[15] G. E. Hinton, A. Krizhevsky, and S. D. Wang. Transform-
ing auto-encoders. In International Conference on Artiﬁcial
Neural Networks, pages 44–51. Springer, 2011. 2

[16] H. Hotelling. Analysis of a complex of statistical variables
into principal components. Journal of educational psychol-
ogy, 24(6):417, 1933. 1
[17] I. Kemelmacher-Shlizerman.

Internet based morphable
model. In Proceedings of the IEEE International Conference
on Computer Vision, pages 3256–3263, 2013. 1

[18] T. G. Kolda and B. W. Bader. Tensor Decompositions and
Applications. SIAM Review, 51(3):455–500, 2008. 4
[19] J. Kossaiﬁ, Y. Panagakis, and M. Pantic. Tensorly: Tensor

learning in python. ArXiv e-print. 6

[20] T. D. Kulkarni, W. F. Whitney, P. Kohli, and J. Tenenbaum.
Deep convolutional inverse graphics network. In Advances in
Neural Information Processing Systems, pages 2539–2547,
2015. 2

[21] Z. Liu, P. Luo, X. Wang, and X. Tang. Deep learning face
attributes in the wild. In Proceedings of International Con-
ference on Computer Vision (ICCV), 2015. 5

[22] L. v. d. Maaten and G. Hinton. Visualizing data using t-sne.
Journal of Machine Learning Research, 9(Nov):2579–2605,
2008. 12

[23] A. Makhzani, J. Shlens, N. Jaitly, I. Goodfellow, and B. Frey.
Adversarial autoencoders. arXiv preprint arXiv:1511.05644,
2015. 1, 12

[24] M. F. Mathieu, J. J. Zhao, J. Zhao, A. Ramesh, P. Sprech-
mann, and Y. LeCun. Disentangling factors of variation
In Ad-
in deep representation using adversarial training.
vances in Neural Information Processing Systems, pages
5040–5048, 2016. 2

[25] I. Matthews and S. Baker. Active appearance models revis-
International journal of computer vision, 60(2):135–

ited.
164, 2004. 1

[26] H. Neudecker. Some theorems on matrix differentiation
with special reference to kronecker matrix products. Journal
of the American Statistical Association, 64(327):953–963,
1969. 15

[42] S. Zafeiriou, G. A. Atkinson, M. F. Hansen, W. A. P. Smith,
V. Argyriou, M. Petrou, M. L. Smith, and L. N. Smith.
Face recognition and veriﬁcation using photometric stereo:
The photoface database and a comprehensive evaluation.
IEEE Transactions on Information Forensics and Security,
8(1):121–135, 2013. 11

[27] S. Reed, K. Sohn, Y. Zhang, and H. Lee. Learning to disen-
tangle factors of variation with manifold interaction. In E. P.
Xing and T. Jebara, editors, Proceedings of the 31st Interna-
tional Conference on Machine Learning, volume 32 of Pro-
ceedings of Machine Learning Research, pages 1431–1439,
Bejing, China, 22–24 Jun 2014. PMLR. 2

[28] F. Roemer.

Advanced algebraic concepts for efﬁcient
PhD thesis, Univer-

multi-channel signal processing.
sit¨atsbibliothek Ilmenau, 2012. 15

[29] C. Sagonas, Y. Panagakis, A. Leidinger, S. Zafeiriou, et al.
Robust joint and individual variance explained. In Proceed-
ings of IEEE InternationalConference on Computer Vision
& Pattern Recognition (CVPR), 2017. 10

[30] Z. Shu, E. Yumer, S. Hadap, K. Sunkavalli, E. Shechtman,
and D. Samaras. Neural face editing with intrinsic image
In Proceedings of the IEEE Conference on
disentangling.
Computer Vision and Pattern Recognition, (CVPR), 2017. 2,
4, 5, 10, 11, 18

[31] P. Snape, Y. Panagakis, and S. Zafeiriou. Automatic con-
In Pro-
struction of robust spherical harmonic subspaces.
ceedings of the IEEE Conference on Computer Vision and
Pattern Recognition, pages 91–100, 2015. 1

[32] Y. Tang, R. Salakhutdinov, and G. Hinton. Tensor analyzers.
In International Conference on Machine Learning, pages
163–171, 2013. 1

[33] J. B. Tenenbaum and W. T. Freeman. Separating style and
content with bilinear models. Neural Comput., 12(6):1247–
1283, June 2000. 2

[34] A. Tewari, M. Zoll¨ofer, H. Kim, P. Garrido, F. Bernard,
P. Perez, and T. Christian. MoFA: Model-based Deep Con-
volutional Face Autoencoder for Unsupervised Monocular
In The IEEE International Conference on
Reconstruction.
Computer Vision (ICCV), 2017. 2

[35] L. Tran, X. Yin, and X. Liu. Disentangled representation
learning gan for pose-invariant face recognition. In CVPR,
volume 4, page 7, 2017. 2

[36] M. A. O. Vasilescu and D. Terzopoulos. Multilinear analysis
of image ensembles: Tensorfaces. In European Conference
on Computer Vision, pages 447–460. Springer, 2002. 1, 2

[37] M. Wang, Y. Panagakis, P. Snape, S. Zafeiriou, et al. Learn-
ing the multilinear structure of visual data. In Proceedings
of the IEEE Conference on Computer Vision and Pattern
Recognition, pages 4592–4600, 2017. 1, 2, 3, 4, 9, 10, 11,
12, 13, 18, 19

[38] R. J. Woodham. Photometric method for determining surface

orientation from multiple images, 1980. 11

[39] D. E. Worrall, S. J. Garbin, D. Turmukhambetov, and
G. J. Brostow. Interpretable transformations with encoder-
decoder networks. In The IEEE International Conference on
Computer Vision (ICCV), Oct 2017. 4

[40] X. Wu, R. He, and Z. Sun. A lightened CNN for deep face

representation. arXiv preprint arXiv:1511.02683, 2015. 5

[41] F. Yang,

J. Wang, E. Shechtman, L. Bourdev, and
D. Metaxas. Expression ﬂow for 3d-aware face component
In ACM Transactions on Graphics (TOG), vol-
transfer.
ume 30, page 60. ACM, 2011. 10

Using vec(Z(1) (cid:12) Z(2)) = I (cid:12) (Z(2)(I ⊗ 1)) ·

vec(Z(1))[28] and let

ˆZ(i+1) = Z(i+1) (cid:12) · · · (cid:12) Z(M ):

(cid:107) ˆx − (I ⊗ B(1))(I (cid:12) ˆZ(i−1)) ⊗ I · vec( ˆZ(i))(cid:107)2

2

=(cid:107) ˆx − (I ⊗ B(1))(I (cid:12) ˆZ(i−1)) ⊗ I

· I (cid:12) (

ˆZ(i+1)(I ⊗ 1)) · vec(Z(i))(cid:107)2
2

Let ˆz(i) = vec(Z(i)) be a vectorisation of Z(i), this be-

comes:

(cid:107) ˆx − (I ⊗ B(1))(I (cid:12) ˆZ(i−1)) ⊗ I
ˆZ(i+1)(I ⊗ 1)) · ˆz(i)(cid:107)2
· I (cid:12) (
2

(24)

(16)

We then compute the partial derivative of (16) with re-

spect to ˆz(i):

∂(cid:107) ˆx − A ˆz(i)(cid:107)2
2
∂ ˆz(i)

= 2AT (A · ˆz(i) − ˆx),

(25)

where A = (I ⊗B(1))(I (cid:12) ˆZ(i−1))⊗I ·I (cid:12)(

ˆZ(i+1)(I ⊗1)).
The partial derivative of (15) with respect to Z(i) is ob-

tained by matricising (25).

C. More expression and pose transfer images

Figures 16 and 17 show additional expression and pose

editing results.

A. Network Details

The convolutional encoder stack (Fig. 2) is composed of
three convolutions with 96 ∗ 5 × 5, 48 ∗ 5 × 5 and 24 ∗ 5 × 5
ﬁlter sets. Each convolution is followed by max-pooling
and a thresholding nonlinearity. We pad the ﬁlter responses
so that the ﬁnal output of the convolutional stack is a set
of ﬁlter responses with size 24 ∗ 8 × 8 for an input image
3 ∗ 64 × 64. The pooling indices of the max-pooling are
preserved for the unpooling layers in the decoder stack.

The decoder stacks for the mask and background are
strictly symmetric to the encoder stack and have skip con-
nections to the input encoder stack at the corresponding un-
pooling layers. These skip connections between the encoder
and the decoder allow for the details of the background to
be preserved.

The other decoder stacks use upsampling and are also

strictly symmetric to the encoder stack.

B. Derivation Details

The model is trained end-to-end by applying gradient de-
scent to batches of images, where (12), (13) and (14) are
written in the following general form:

E = (cid:107)X − B(1)(Z(1) (cid:12) Z(2) (cid:12) · · · (cid:12) Z(M ))(cid:107)2
F ,

(15)

where X ∈ Rk×n is a data matrix, B(1) is the mode-1 ma-
tricisation of a tensor B and Z(i) ∈ Rkzi×n are the latent
variables matrices.

The partial derivative of (15) with respect to the latent
variable Z(i) are computed as follows: Let ˆx = vec(X) be
a vectorisation of X , then (15) is equivalent with:

(cid:107)X − B(1)(Z(1) (cid:12) Z(2) (cid:12) · · · (cid:12) Z(M ))(cid:107)2
F

=(cid:107)vec(X − B(1)(Z(1) (cid:12) Z(2) (cid:12) · · · (cid:12) Z(M )))(cid:107)2
2
=(cid:107) ˆx − vec(B(1)(Z(1) (cid:12) Z(2) (cid:12) · · · (cid:12) Z(M )))(cid:107)2
2,

(21)

as both the Frobenius norm and the L2 norm are the sum of
all elements squared.

(cid:107) ˆx − vec(B(1)(Z(1) (cid:12) Z(2) (cid:12) · · · (cid:12) Z(M )))(cid:107)2
2
=(cid:107) ˆx − (I ⊗ B(1))vec(Z(1) (cid:12) Z(2) (cid:12) · · · (cid:12) Z(M ))(cid:107)2
2,
(22)

as the property vec(BZ) = (I ⊗ B)vec(Z) holds [26].

Using vec(Z(1)(cid:12)Z(2)) = (I (cid:12)Z(1))⊗I ·vec(Z(2))[28]
ˆZ(i−1) = Z(1) (cid:12) Z(2) (cid:12) · · · (cid:12) Z(i−1) and ˆZ(i) =

and let
Z(i) (cid:12) · · · (cid:12) Z(M ) the following holds:

(cid:107) ˆx − (I ⊗ B(1))vec(Z(1) (cid:12) Z(2) (cid:12) · · · (cid:12) Z(M ))(cid:107)2
2

=(cid:107) ˆx − (I ⊗ B(1))(I (cid:12) ˆZ(i−1)) ⊗ I · vec( ˆZ(i))(cid:107)2

2

(23)

Original Image Expression

Recon

Our Exp Edit

Baseline

Original Image Expression

Recon

Our Exp Edit

Baseline

Original Image

Pose

Recon

Our Pose Edit

Pose

Recon

Our Pose Edit

Baseline

Figure 16: Expression Editing
Original Image

Baseline

Figure 17: Pose Editing

Figure 18: Expression Interpolation

Figure 19: Identity Interpolation

D. Interpolation Results

E. Expression Transfer from Video

exp / zi

id of the input image xi on the
We interpolate zi
id of the target image xt on the
right-hand side to the zt
left-hand side. The interpolation is linear and at 0.1 interval.
For the interpolation we do not modify the background so
the background remains that of image xi.

exp / zt

For expression interpolation, we expect the identity and
pose to stay the same as the input image xi and only the
expression to change gradually from the expression of the
input image to the expression of the target image xt. Fig-
ure 18 shows the expression interpolation. We can clearly
see the change in expression while pose and identity remain
constant.

For identity interpolation, we expect the expression and
pose to stay the same as the input image xi and only the
identity to change gradually from the identity of the input
image to the identity of the target image xt. Figure 19
shows the identity interpolation. We can clearly observe
the change in identity while other variations remain limited.

We conducted another challenging experiment to test the
potential of our method. Can we transfer facial expressions
from an “in-the-wild” video to a given template image (also
“in-the-wild” image)? For this experiment, we split the in-
put video into frames and extract the expression component
zexp of each frame. Then we replace the expression compo-
nent of the template image with the zexp of the video frames
and decode them. The decoded images form a new video
sequence where the person in the template image has taken
on the expression of the input video at each frame. The re-
sult can be seen here: https://youtu.be/tUTRSrY_
ON8. The original video is shown on the left side while the
template image is shown on the right side. The result of
the expression transfer is the 2nd video from the left. We
compare against a baseline (3rd video from the left) where
the template image has been warped to the landmarks of
the input video. We can clearly see that our method is able
to disentangle expression from pose and the change is only

Source

ˆssource

[30] ˆssource

Target

ˆstarget

stransf er

Result

Target

ˆstarget

stransf er

Result

Ours

[30]

Ours

[30]

Ours

[30]

Ours

[30]

Figure 20: We relight target faces using illumination from the source image. We compare against results presented in [30].

at the expression level. The baseline though is only able
to transform expression and pose together. Our result video
also displays expressions that are more natural to the person
in the template image. To conclude, we are able to animate a
template face using the disentangled facial expression com-
ponents of a video sequence.

F. Relighting

Figure 20 shows more relighting comparison results
with [30]. Here we compare directly with images provided
by [30] in their paper.

G. Further Expression Editing Comparison

Figure 21 shows further expression editing comparison
results with [37]. The method proposed in [37] does not

Original Image Expression

Our Recon Our Exp Edit

B & W

[37]

Figure 21: We compare our expression editing results with [37]. As [37] requires frontalisation of the face, applying it on
our aligned input data does not achieve good results.

disentangle pose and hence requires a “frontalisation” of
the face to work optimally. Our proposed method on the
other hand is able to edit expressions directly on aligned im-
ages. To visualise the difference, we run [37] directly on our
aligned test images to compare with our proposed method.
As expected the results returned by [37] does not perform
well given this setup. So given the same input (aligned im-
ages from CelebA) our proposed method is able to edit ex-
pression directly whereas [37] requires further “frontalisa-
tion” transformations to obtain good results. This is due to
[37] not being able to disentangle pose.

