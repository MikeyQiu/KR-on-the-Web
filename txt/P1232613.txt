8
1
0
2
 
r
a

M
 
6
1
 
 
]

V
C
.
s
c
[
 
 
2
v
1
1
3
0
0
.
2
1
7
1
:
v
i
X
r
a

Folded Recurrent Neural Networks for Future
Video Prediction

Marc Oliu
Universitat Oberta de Catalunya
Centre de Visio per Computador
Rambla del Poblenou, 156, 08018 Barcelona
moliusimon@uoc.edu

Javier Selva
Universitat de Barcelona
Gran Via de les Corts Catalanes, 585, 08007 Barcelona
javier.selva.castello@est.ﬁb.upc.edu

Sergio Escalera
Universitat de Barcelona
Centre de Visio per Computador
Gran Via de les Corts Catalanes, 585, 08007 Barcelona
sergio@maia.ub.es

Abstract. Main challenges in future video prediction are high variabil-
ity in videos, temporal propagation of errors, and non-speciﬁcity of future
frames. This work introduces bijective Gated Recurrent Units (bGRU).
Standard GRUs update a state, exposed as output, given an input. We
extend them by considering the input as another recurrent state, and
update it given the output using an extra set of logic gates. Stacking
multiple such layers results in a recurrent auto-encoder: the operators
updating the outputs comprise the encoder, while the ones updating the
inputs form the decoder. Being the encoder and decoder states shared,
the representation is stratiﬁed during learning: some information is not
passed to the next layers. We show how only the encoder or decoder needs
to be applied for encoding or prediction. This reduces the computational
cost and avoids re-encoding predictions when generating multiple frames,
mitigating error propagation. Furthermore, it is possible to remove lay-
ers from a trained model, giving an insight to the role of each layer. Our
approach improves state of the art results on MMNIST and UCF101,
being competitive on KTH with 2 and 3 times less memory usage and
computational cost than the best scored approach.

Keywords: future video prediction, unsupervised learning, recurrent
neural networks

1 Introduction

Future video prediction is a challenging task that recently received much atten-
tion due to its capabilities for learning in an unsupervised manner, making it

2

possible to leverage large volumes of unlabelled data for video-related tasks such
as action and gesture recognition [1,2,3], task planning [4,5], weather prediction
[6], optical ﬂow estimation [7] and new view synthesis [3].

One of the main problems in this task is the need of expensive models both
in terms of memory and computational power in order to capture the variability
present in video data. Another problem is the propagation of errors in recurrent
models, which is tied to the inherent uncertainty of video prediction: given a se-
ries of previous frames, there are multiple feasible futures. This, left unchecked,
results in a blurry prediction averaging the space of possible futures that prop-
agates back into the network when predicting subsequent frames.

In this work we propose a new approach to recurrent auto-encoders (AE) with
state sharing between encoder and decoder. We show how the exposed state in
Gated Recurrent Units (GRU) can be used to create a bijective mapping between
the input and output of each layer. To do so, the input is treated as a recurrent
state, adding another set of logic gates to update it based on the output. Creating
a stack of these layers allows for a bidirectional ﬂow of information. Using the
forward gates to encode inputs and the backward ones to generate predictions,
we obtain a structure similar to an AE1, but with many inherent advantages. It
reduces memory and computational costs during both training and testing: only
the encoder or decoder is executed for input encoding or prediction, respectively.
Furthermore, the representation is stratiﬁed, encoding only part of the input at
each layer: low level information not necessary to capture higher level dynamics is
not passed to the next layer. Also, it naturally provides a noisy identity mapping
of the input, facilitating the initial stages of training: the input to the ﬁrst
bGRU holds the last encoded frame or, if preceded by convolutional layers, an
over-complete representation of the same. During generation, that ﬁrst untrained
bGRU randomly modiﬁes the last input, introducing a noise signal. The approach
also mitigates the propagation of errors: while it does not solve the problem of
blur, it prevents its magniﬁcation in subsequent predictions. Moreover, a trained
network can be deconstructed in order to analyse the role of each layer in the
ﬁnal predictions, making the model more explainable. Since the encoder and
decoder states are shared, the architecture can be thought of as a recurrent AE
folded in half, with encoder and decoder layers overlapping. We call our method
Folded Recurrent Neural Network (fRNN). Our main contributions are: 1) A
new shared-state recurrent AE with lower memory and computational costs. 2)
Mitigation of error propagation through time. 3) It naturally provides an identity
function during training. 4) Model explainability and optimisation through layer
removal. 5) Demonstration of representation stratiﬁcation.

2 Related work

While initial proposals focused on prediction on small patches [8,9], future video
prediction is nowadays generally approached by building a deep model capable

1 Code available at https://github.com/moliusimon/frnn.

3

of understanding the input sequence in a manner that allows for the generation
of the following frames.

Building Blocks. Due to the characteristics of the problem, an AE setting
has been widely used [1,4,10,11,12]: the encoder extracts valuable information
from the input and the decoder produces new frames. Generally, encoder and
decoder are CNNs that tackle the spatial dimension. LSTMs are commonly used
to handle the temporal dynamics and project the representations into the future.
Some works compute the temporal dynamics at the deep representation bridg-
ing the encoder and decoder [4,7,13,12]. Others jointly handle space and time
by using Convolutional LSTMs [10,2,7,14,15] (or GRUs, as in our case), which
use convolutional kernels at their gates. For instance, Lotter et al. [2] use a re-
current residual network with convolutional LSTM where each layer minimises
the discrepancies from previous block predictions. Common variations of the AE
also include a conditional term to guide the temporal transform, such as a time
diﬀerential [16] or prior knowledge of scene events, reducing the space of possible
futures. Oh et al. [4] predict future frames on Atari games conditioning on the
action taken by the player. Some works propose such action conditioned mod-
els foreseeing an application for autonomous agents learning in an unsupervised
fashion [10,14]. Finn et al. [10] predict a sequence of future frames within a phys-
ical system based on both previous frames and actions taken by a robotic arm
interacting with the scene. The method was recently applied to task planning
[5] and adapted to perform stochastic future frame prediction [17].

Bridge connections. Introducing bridge connections (connections between
equivalent layers of encoder and decoder) is also common [10,3,13,11]. This allows
for a stratiﬁed representation of the input sequence, reducing the capacity needs
of subsequent layers. Video Ladder Networks (VLN) [13] use a convolutional AE
topology implementing skip connections. Pairs of convolutions are grouped into
residual blocks, horizontally passing information between corresponding blocks,
both by directly and by using a recurrent bridge layer. This topology was fur-
ther extended with Recurrent Ladder Networks (RLN) [18], where the recurrent
bridge connections were removed, and the residual blocks replaced by recurrent
layers. We propose an alternative to bridge connections by completely sharing
the state between encoder and decoder, reducing computational needs while
maintaining the stratiﬁcation ability. Both VLN and RLN share some similar-
ities with our approach: they propose a recurrent AE with bridge connections
between encoder and decoder. However, using skip connections instead of state
sharing has some disadvantages: higher number of parameters and memory re-
quirements, impossibility to skip the encoding/decoding steps (resulting in a
higher computational cost) and reduced explainability due to not allowing lay-
ers to be removed after training. Finally, bridge connections do not provide an
initial identity function during training. This makes it hard for the model to con-
verge in some cases: when the background is homogeneous the model may not
learn a proper initial mapping between input and output, but set the weights to
zero and adjust the bias of the last layer, eliminating the gradient in the process.

4

Prediction atom. Most of the proposed architectures for future frame gen-
eration directly predict at pixel level (as in our case). However, some models
have been designed to predict motion and use it to transform the input into
future frames. For instance, using the input sequence to anticipate optical ﬂow
[3,7] or convolutional kernels [19,20]. Other methods propose mapping the in-
put sequence onto predeﬁned feature spaces, such as aﬃne transforms [21] or
human pose vectors [22]. These systems use sequences of such features instead
of working directly at pixel level. Then, they use the predicted feature vectors
to generate the next frames.

Loss and GANs. Commonly used loss functions such as L2 or MSE tend
to average the space of possible futures. For this reason, some works[23,11,22,15]
propose using Generative Adversarial Networks (GAN) [24] to help traditional
losses choose among possible futures by ensuring realistic looking frames and co-
herent sequences. Mathieu et al. [23] use a plain multi-scale CNN in an adversar-
ial setting and propose the Gradient Diﬀerence Loss to sharpen the predictions.
Disentangled Motion/Content. Some authors encode content and mo-
tion separately. Villegas et al. [11] use an AE architecture with a two-stream
encoder: for motion, a CNN + LSTM encodes diﬀerence images; for appearance,
a plain CNN encodes the last input frame. In a similar fashion, Denton et al. [12]
use two separate encoders and an adversarial setting to obtain a disentangled
representation of content and motion. Alternatively, some works predict motion
and content in parallel to beneﬁt from the combined strengths of both tasks.
While Sedaghat et al. [25] propose using an encoding with a dual objective (ﬂow
and future frame), Liang et al. [15] use a dual GAN setting and combine both
predicted frame and motion to generate the actual next frame.

Feedback Predictions. Finally, an important aspect of the recurrent-based
models is that they are based on the use of feedback predictions. In general, a
model is trained to predict a speciﬁc number of time-steps into the future. In
order to predict further in time they need to use their own predictions as in-
put. This, if not handled properly, may accentuate small mistakes causing the
predictions to quickly deteriorate over time. Our model solves this by enabling
encoder and decoder to be executed any number of times independently. This is
similar to the proposal by Srivastava et al. [1], which uses a recurrent AE ap-
proach where an input sequence is encoded and its state copied into the decoder.
The decoder is then applied to generate a given number of frames. However, it
is limited to a single recurrent layer for each part.

3 Proposed method

We propose an architecture based on recurrent convolutional AEs to deal with
the network capacity and error propagation problems for future video prediction.
It consists on a series of bijective GRU layers, which allow for a bidirectional
ﬂow of information between input and output: they consider the input as a
recurrent state and update it using an extra set of gates. These are then stacked,
forming an encoder and decoder using, respectively, the forward and backward

5

Fig. 1. Left: Scheme of a bGRU. Shadowed areas illustrate how multiple bGRU layers
are stacked. Right: fRNN topology. The recurrent states of the encoder and decoder are
shared, resulting in a bidirectional mapping between states. Shadowed areas represent
unnecessary circuitry: re-encoding of the predictions is avoided thanks to the decoder
updating all the states. Left-Right: Blue and red correspond to forward and backward
gates, respectively. Rectangles represent the recurrent state cell.

functions of the bijective GRUs (Fig.1). We call it Folded Recurrent Neural
Network (fRNN). Because of the state sharing between encoder and decoder,
the topology allows for: stratiﬁcation of the encoded information, lower memory
and computational requirements compared to regular recurrent AEs, mitigated
propagation of errors, and increased explainability through layer removal.

3.1 Bijective Gated Recurrent Units

GRUs have their state fully exposed as output. This allows us to deﬁne a bidi-
rectional mapping between input and output by replicating the logic gates of
the GRU layer. To do so, we consider the input as a state on itself. Lets deﬁne
t = f l
the output of a GRU at layer l and time step t as hl
, hl
t−1) given an
input hl−1
and its state at the previous time step hl
t−1. A second set of weights
can be used to deﬁne an inverse mapping hl−1
b(hl
t = f l
t−1) using the output
of the forward function at the current time step to update its input, which is
treated as the hidden state of the inverse function. This is illustrated in Fig. 1.
We will refer to this double mapping as bijective GRU (bGRU).

f (hl−1

t, hl−1

t

t

3.2 Folded Recurrent Neural Network

By stacking multiple bGRUs, a recurrent AE is obtained. Given n bGRUs, the
encoder is deﬁned by the set of forward functions E = {f 1
f } and the
f ,
decoder by the set of backward functions D = {f n
b }. This is illustrated
in Fig. 1, and is equivalent to a recurrent AE, but with shared states, having
3 main advantages: 1) It is not necessary to feed the predictions back into the

b , ..., f 1

..., f n

6

network in order to generate the following predictions. Because the states are
shared, the decoder already updates all the states except for the bridge state
between encoder and decoder. The bridge state is updated by applying the last
layer of the encoder before generating the next prediction. The shadowed area
in Fig. 1 shows the section of the computational graph that is not required when
performing multiple sequential predictions. For the same reason, when consider-
ing multiple sequential elements before prediction, only the encoder is required.
2) Because the network updates its states from the higher level representations
to the lowest ones during prediction, errors introduced at a given layer during
generation are not propagated back into deeper layers, leaving the higher-level
dynamics unaﬀected. 3) The model implicitly provides a noisy identity model
during training, as it is shown in Fig. 7, when all bGRU layers are removed. The
input state of the ﬁrst bGRU layer is either the input image itself or, when ﬁrst
applying a series of convolutional layers, an over-complete representation of the
input. A noise signal is then introduced to the representation by the backward
function of the untrained ﬁrst bGRU layer. Consequently providing the model
with an initial identity model. As we show in Section 4.3, this helps the model to
converge in some datasets like MMNIST: when the same background is shared
across instances, it prevents the model from killing the gradients by adjusting
the biases to match the background and setting the weights to zero.

This approach shares some similarities with VLN and RLN. As with them,
part of the information can be passed directly between corresponding layers of
the encoder and decoder, not having to encode a full representation of the input
into the deepest layer. However, our model implicitly passes the information
through the shared recurrent states, making bridge connections unnecessary.
When compared against an equivalent recurrent AE with bridge connections,
this results in a much lower computational and memory cost. More speciﬁcally,
the number of weights in a pair of forward and backward functions is equal to
3(hl−1
+ 2hl−1 hl) in the case of bGRU, where hl corresponds to the state
size of layer l. When using bridge connections, as in the case of VLN and RLN,
+ 4hl−1 hl). This corresponds to an
+ hl
that value is incremented to 3(hl−1
increase of 44% in the number of parameters when one state has double the size
of the other, and of 50% when they have the same size. Furthermore, both the
encoder and decoder must be applied at each time step. Thus, memory usage is
doubled and computational cost is increased by a factor of between 2.88 and 3.

+ hl

2

2

2

2

3.3 Training Folded RNNs

In a regular recurrent AE, a ground truth frame is introduced at each time step
by applying both encoder and decoder. The output is used as a supervision point,
comparing it to the next ground truth frame in the sequence. This implies all
predictions are at a single time step from the last ground truth prediction. Here,
we propose a training approach for fRNNs that exploits the ability of the topol-
ogy of skipping the model encoder or decoder at a given time step. First g ground
truth frames are shown to the network by passing them through the encoder.

7

The decoder is then applied p times, producing p predictions. This results in
only half the memory requirements: either encoder or decoder is applied at each
step, never both. This has the same advantage as the approach by Srivastava
[1], where recurrently applying the decoder without further ground truth inputs
encourages the network to learn video dynamics. This also prevents the network
from learning an identity model, i.e. copying the last input to the output.

4 Experiments

Here, we ﬁrst discuss data, evaluation protocol, and methods. Then we provide a
detailed quantitative and qualitative evaluation. We ﬁnish with a brief analysis
on the stratiﬁcation of sequence representation among bGRU layers2.

4.1 Data and evaluation protocol

We considered 3 datasets of diﬀerent complexity in order to analyse the per-
formance of the proposed method: Moving MNIST (MMNIST)[1], KTH [26],
and UCF101 [27]. MMNIST consists of 64 × 64 grayscale sequences of length 20
displaying pairs of digits moving around the image. The sequences are gener-
ated by randomly sampling pairs of digits and trajectories. It contains a ﬁxed
test partition with 10000 sequences. We generated a million extra samples for
training. KTH consists of 600 videos of 15-20 seconds with 25 subjects perform-
ing 6 actions in 4 diﬀerent settings. The videos are grayscale, at a resolution of
120 × 160 pixels and 25 fps. The dataset has been split into subjects 1 to 16 for
training, and 17 to 25 for testing, resulting in 383 and 216 sequences, respec-
tively. Frame size is reduced to 64 × 80 using bilinear interpolation, removing
5 pixels from the left and right borders before resizing. UCF101 displays 101
actions, such as playing instruments, weight lifting or sports. It is the most chal-
lenging dataset considered, with a high intra-class variability. It contains 9950
training sequences and 3361 test sequences. These are RGB at a resolution of
320 × 240 pixels and 25 fps. To increase motion between consecutive frames, one
of every two frames was removed. Following the same procedure as with KTH,
the frame size is reduced to 64 × 85.

All methods are tested using 10 input frames to generate the following 10
frames. We use 3 common metrics for video prediction analysis: Mean Squared
Error (MSE), Peak Signal-to-Noise Ratio (PSNR), and Structural Dissimilarity
(DSSIM). MSE and PSNR are objective measurements of reconstruction quality.
DSSIM is a measure of the perceived quality. For DSSIM we use a Gaussian
sliding window of size 11 × 11 and σ = 1.5.

4.2 Methods

To train the proposed method we used RMSProp with learning rate of 0.0001
and batch size of 12, sampling a random sub-sequence at each epoch. Weights

2 Additional qualitative results, as well as an extended table of quantitative results by

time step, are shown in the supplementary material.

8

Conv 1 Conv 2 Pool 1 bGRU 1 bGRU 2 Pool 2 bGRU 3 bGRU 4 Pool 3 bGRU 5 bGRU 6 Pool 4 bGRU 7 bGRU 8

32

Num. Units
Kernel size 5 × 5
Stride
Activation tanh

1

64
5 × 5
1
tanh

-
2 × 2
2
-

128
5 × 5
1

128
5 × 5
1

256
5 × 5
1

256
5 × 5
1

-
2 × 2
2
-

512
3 × 3
1

512
3 × 3
1

-
2 × 2
2
-

-
2 × 2
2
-

256
3 × 3
1

256
3 × 3
1

sigmoid & tanh

sigmoid & tanh

sigmoid & tanh

sigmoid & tanh

Table 1. Parameters of the topology used for the experiments. The decoder applies
the same topology in reverse, using nearest neighbours interpolation and transposed
convolutions to revert the pooling and convolutional layers.

were orthogonally initialised, with biases set to 0. For testing, we considered all
sub-sequences of length 20. Our network topology consists of two convolutional
layers followed by 8 convolutional bGRU layers, applying a 2 × 2 max pooling
every 2 layers. Topology details are shown in Table 1. We use deconvolution and
nearest neighbours interpolation to invert the convolutional and max pooling
layers, respectively. We train with L1 loss.

For evaluation, we include a stub baseline model predicting the last input
frame, and design a second baseline (RLadder) to evaluate the advantages of us-
ing state sharing. RLadder has the same topology as the fRNN model, but uses
bridge connections instead of state sharing. Note that to keep the same state size
on GRU layers, using bridge connections doubles the memory size and almost
triples the computational cost (Sec.3.2). This is similar to how RLN [18] works,
but using regular conv GRU layers in the decoder. We also compare against
Srivastava [1] and Mathieu [23]. The former only handles the temporal dimen-
sion explicitly with LSTMs, while the latter only treats the spatial dimensions
using 3D CNN. Next, we compare against Villegas [11], which, contrary to our
proposal, uses feedback predictions. Finally, we compare against Lotter et al. [2]
which is based on residual error reduction. All of them were adapted to train
using 10 frames as input and predicting the next 10, using the topologies and
parameters deﬁned by the authors.

4.3 Quantitative analysis

The ﬁrst row of Fig. 2 displays the results for the MMNIST dataset for the
proposed method, baselines, and state of the art alternatives. Mean scores are
shown in Table 2. fRNN performs best on all time steps and metrics, followed by
Srivastava et al. [1]. These two are the only methods to provide valid predictions
on this dataset. Most other methods predict a black frame, with Mathieu et al.
[23] progressively blurring the digits. This is caused by a loss of gradient during
the ﬁrst stages of training. On more complex datasets the methods start by
learning an identity function, then reﬁning the results. This is possible since in
many sequences most of the frame remains unchanged. In the case of MMNIST,
where the background is homogeneous, it is much easier for the models to set the
weights of the output layer to zero and set the biases to match the background
colour. This cuts the gradient and prevents further learning. Srivastava et al.
[1] use an auxiliary decoder to reconstruct the input frames, forcing the model
to learn an identity function. This, as discussed at the end of Section 3.2, is
implicitly handled in our method, giving an initial solution to improve on and

9

Fig. 2. Quantitative results on the considered datasets in terms of the number of time
steps since the last input frame. From top to bottom: MMNIST, KTH, and UCF101.
From left to right: MSE, PSNR, and DSSIM. For MMNIST, RLadder is pre-trained to
learn an initial identity mapping, allowing it to converge.

MMNIST

MSE

PSNR DSSIM
Baseline 0.06989 11.745 0.20718
RLadder 0.04254 13.857 0.13788
Lotter [2] 0.04161 13.968 0.13825
Srivastava [1] 0.01737 18.183 0.08164
Mathieu [23] 0.02748 15.969 0.29565
Villegas [11] 0.04254 13.857 0.13896
fRNN 0.00947 21.386 0.04376

MSE

KTH
PSNR DSSIM
0.00366 29.071 0.07900
0.00139 31.268 0.05945
0.00309 28.424 0.09170
0.00995 21.220 0.19860
0.00180 29.341 0.10410
0.00165 30.946 0.07657
0.00175 29.299 0.07251

MSE

UCF101
PSNR DSSIM
0.01294 22.859 0.15043
0.00918 23.558 0.13395
0.01550 19.869 0.21389
0.14866 10.021 0.42555
0.00926 22.781 0.16262
0.00940 23.457 0.14150
0.00908 23.872 0.13055

Table 2. Average results over 10 time steps.

preventing the models from learning a black image. In order to verify this eﬀect,
we pre-trained RLadder on the KTH dataset. While this dataset has completely
diﬀerent dynamics, the initial step to solve the problem remains: providing an
identity function. Afterwards the model is ﬁne-tuned on the MMNIST dataset.
As it is shown in Fig. 2 (dashed lines), this results in the model converging, with
an accuracy comparable to Srivastava et al. [1] for the 3 evaluation metrics.

On the KTH dataset, Table 2 shows the best approach is our RLadder base-
line followed by fRNN and Villegas et al. [11], both having similar results, but
with Villegas et al. having slightly lower MSE and higher PSNR, and fRNN a
lower DSSIM. While both approaches obtain comparable average results, the er-
ror increases faster over time in the case of Villegas et al. (second row in Fig.2).
Mathieu obtains good scores for MSE and PSNR, but has a much worse DSSIM.

10

For the UCF101 dataset, as shown in Table 2, our fRNN approach is the
best performing for all 3 metrics. When looking at the third row of Fig. 5, one
can see that Villegas et al. starts out with results similar to fRNN on the ﬁrst
frame, but as in the case of KTH and MMNIST, the predictions degrade faster
than with the proposed approach. Two methods display low performance in most
cases. Lotter et al. works well for the ﬁrst predicted frame in the case of KTH
and UCF101, but the error rapidly increases on the following predictions. This
is due to a magniﬁcation of artefacts introduced on the ﬁrst prediction, making
the method unable to predict multiple frames without supervision. In the case
of Srivastava et al. the problem is about capacity: it uses fully connected LSTM
layers, making the number of parameters explode quickly with the state cell
size. This severely limits the representation capacity for complex datasets such
as KTH and UCF101.

Overall, for the considered methods, fRNN is the best performing on MMINST
and UCF101, the later being the most complex of the 3 datasets. We achieved
these results with a simple topology: apart from the proposed bGRU layers, we
use conventional max pooling with an L1 loss. There are no normalisation or
regularisation mechanisms, specialised activation functions, complex topologies
or image transform operators. In the case of MMNIST, fRNN shows the ability
to ﬁnd a good initial representation and converges to good predictions where
most other methods fail. In the case of KTH, fRNN has an overall accuracy
comparable to that of Villegas et al., being more stable over time. It is only
surpassed by the proposed RLadder baseline, a method equivalent to fRNN but
with 2 and 3 times more memory and computational requirements.

4.4 Qualitative analysis

In this section we evaluate our approach qualitatively on some samples from
the three considered datasets. Fig. 3 shows the last 5 input frames from some
MMNIST sequences along with the next 10 ground truth frames and their corre-
sponding fRNN predictions. The 10 predictions are generated sequentially with-
out showing the previous ground truth/prediction to the network, that is, only
using the decoder. As it can be seen, the digits maintain their sharpness across
the sequence of predictions. Also, the bounces at the edges of the image are done
correctly, and the digits do not distort or deform when crossing. This shows the
network internally encodes the appearance of each digit, making it possible to
reconstruct them after sharing the same region in the image plane.

Qualitative examples of fRNN predictions on the KTH dataset are shown in
Fig. 4. It shows three actions: hand waving, walking, and boxing. The blur stops
increasing after the ﬁrst three predictions, generating plausible motions for the
corresponding actions while background artefacts are not introduced. Although
the movement patterns for each type of action have a wide range of variability
on its trajectory, bGRU gives relatively sharp predictions for the limbs. The ﬁrst
and third examples also show the ability of the model to recover from blur. The
blur slightly increases for the arms while the action is performed, but decreases
again as these reach the ﬁnal position.

11

Fig. 3. fRNN predictions on MMNIST. First row for each sequence shows last 5 inputs
and target frames. Yellow frames are model predictions.

Fig. 4. fRNN predictions on KTH. First row for each sequence shows last 5 inputs and
target frames. Yellow frames are model predictions.

Fig. 5 shows fRNN predictions on the UCF101 dataset. These correspond
to two diﬀerent physical exercises and a girl playing the piano. Common to all
predictions, the static parts do not lose sharpness over time, and the background
is properly reconstructed after an occlusion. The network correctly predicts ac-
tions with low variability, as shown in rows 1-2, where a repetitive movement is
performed, and in last row, where the girl recovers a correct body posture. These
dynamic regions introduce blur due to the uncertainty of the action, averaging
the possible futures. The ﬁrst row also shows an interesting behaviour: while the
woman is standing up, the upper body becomes blurry due to uncertainty, but
as the woman ﬁnishes her motion and ends up in the expected upright position,
the frames sharpen again. Since the model does not propagate errors to deeper
layers nor makes use of previous predictions for the following ones, the introduc-
tion of blur does not imply this blur will be propagated. In this example, while
the middle motion could have multiple predictions depending on the movement
pace and the inclination of the body while performing it, the ﬁnal body pose has
a lower uncertainty.

In Fig. 6 we compare predictions from the proposed approach against the
RLadder baseline and other state of the art methods. For the MMNIST dataset

12

Fig. 5. fRNN predictions on UCF. First row for each sequence shows last 5 inputs and
target frames. Yellow frames are model predictions.

we did not consider Villegas et al. and Lotter et al. since these methods fail to
successfully converge and they predict a sequence of black frames. From the rest
of approaches, fRNN obtains the best predictions, with little blur or distortion.
The RLadder baseline is the second best approach. It does not introduce blur,
but heavily deforms the digits after they cross. Srivastava et al. and Mathieu et
al. both accumulate blur over time, but while the former does so to a smaller
degree, the later makes the digits unrecognisable after ﬁve frames.

For KTH, Villegas et al. obtains outstanding qualitative results. It predicts
plausible dynamics and maintains the sharpness of both the individual and back-
ground. Both fRNN and RLadder follow closely, predicting plausible dynamics,
but not being as good as Villegas et al. at maintaining the sharpness of the
individual. On UCF101 the best prediction is obtained by our model, with little
blur or distortion compared to the other methods. The second best is Villegas
et al., successfully capturing the movement patterns but introducing more blur
and important distorsions on the last frame. When looking at the background,
fRNN proposes a plausible initial estimation and progressively completes it as
the woman moves. On the other hand, Villegas et al. modiﬁes already generated
regions as more background is uncovered, generating an unrealistic sequence re-
garding the background. Srivastava and Lotter fail on both KTH and UCF101.
Srivastava et al. heavily distort the frames. As discussed in Section 4.3, this is
due to the use of fully connected recurrent layers, which constrains the state size
and prevents the model from encoding relevant information on more complex
scenarios. In the case of Lotter, it makes good predictions for the ﬁrst frame,
but rapidly accumulates artefacts.

4.5 Representation stratiﬁcation analysis

Here we analyse the stratiﬁcation of the sequence representation among the
bGRU layers. Because bGRU units allow for a bijective mapping between states,
it is possible to remove the deepest layers of a trained network, allowing us to
check how the predictions are aﬀected and providing an insight on the dynamics
captured by each layer. Speciﬁcally, the same sequences are predicted multiple

Input 1

Input 5

Input 10

GT 1

GT 5

GT 10

13

Pred. 1

Pred. 5
fRNN

Pred. 10

Pred. 1

Pred. 10

Pred. 1

Pred. 5
RLadder

Pred. 5
Srivastava et al.

Pred. 10

Mathieu et al.

Villegas et al.

Lotter et al.

Fig. 6. Predictions at 1, 5, and 10 time steps from the last ground truth frame. RLadder
predictions on MMNIST are from the model pre-trained on KTH.

times, removing a layer each time. To our knowledge, this is the ﬁrst topology
allowing for a direct observation of the behaviour encoded on each layer.

This is shown in Fig. 7 for the MMNIST dataset. The analysed model consists
of 10 layers: 2 convolutional layers and 8 bGRU layers. Firstly, removing the last
2 bGRU layers has no signiﬁcant impact on prediction. This shows that, for
this simple dataset, the network has a higher capacity than required. Further
removing layers does not result in a loss of pixel-level information, but on a
progressive loss of behaviours, from more complex to simpler ones. This means
information at a given level of abstraction is not encoded into higher level layers.
When removing the third deepest bGRU layer, the digits stop bouncing and keep
their linear trajectories, exiting the image. This indicates this layer is in charge
of encoding information on bouncing dynamics. When removing the next layer,
digits stop behaving correctly on the boundaries of the image. Parts of the digit
bounce while others keep the previous trajectory. While this also has to do with
bouncing dynamics, the layer seems to be in charge of recognising digits as single
units following the same movement pattern. When removed, diﬀerent segments
of the digit are allowed to move as separate elements. Finally, with only 3-2

14

8 bGRU layers

6 bGRU layers

5 bGRU layers

4 bGRU layers

3 bGRU layers

2 bGRU layers

1 bGRU layer

0 bGRU layers

Fig. 7. Moving MNIST predictions with fRNN layer removal. Removing all bGRU
layers (last row) leaves two convolutional layers and their transposed convolutions,
providing an identity mapping.

bGRU layers the digits are distorted in various ways. With only two layers left,
the general linear dynamics are still captured by the model. By leaving a single
bGRU layer, the linear dynamics are lost.

According to these results, linear movement dynamics are captured at pixel
level on the ﬁrst two bGRU layers. The next two start aggregating these move-
ment patterns into single-trajectory components, preventing their distortion.
The collision of these components with image bounds is also detected. The ﬁfth
layer aggregates single-motion components into digits, forcing them to follow the
same motion. This seems to have the eﬀect of preventing bounces, likely due to

15

only one of the components reaching the edge of the image. It is the sixth bGRU
layer that provides a coherent bouncing pattern for the whole digit.

5 Conclusions

We presented Folded Recurrent Neural Networks, a new recurrent architecture
for video prediction with lower computational and memory cost compared to
equivalent recurrent AE models. This is achieved by using the proposed bijec-
tive GRUs, which horizontally pass information between the encoder and de-
coder. This eliminates the need for using the entire AE at any given step: only
the encoder or decoder needs to be executed for both input encoding and pre-
diction, respectively. It also facilitates the convergence by naturally providing
a noisy identity function during training. We evaluated our approach on three
video datasets, outperforming state of the art prediction results on MMNIST
and UCF101, and obtaining competitive results on KTH with 2 and 3 times less
memory usage and computational cost than the best scored approach. Qualita-
tively, the model can limit and recover from blur by preventing its propagation
from low to high level dynamics. We also demonstrated stratiﬁcation of the
representation, topology optimisation, and model explainability through layer
removal. Each layer has been shown to modify the state of the previous one by
adding more complex behaviours: removing a layer eliminates its behaviours but
leaves lower-level ones untouched.

16

References

1. Srivastava, N., Mansimov, E., Salakhudinov, R.: Unsupervised learning of video
In: International Conference on Machine Learning.

representations using lstms.
(2015) 843–852

2. Lotter, W., Kreiman, G., Cox, D.: Deep predictive coding networks for video
prediction and unsupervised learning. arXiv preprint arXiv:1605.08104 (2016)
3. Liu, Z., Yeh, R., Tang, X., Liu, Y., Agarwala, A.: Video frame synthesis using deep

voxel ﬂow. arXiv preprint arXiv:1702.02463 (2017)

4. Oh, J., Guo, X., Lee, H., Lewis, R.L., Singh, S.: Action-conditional video prediction
using deep networks in atari games. In: Advances in Neural Information Processing
Systems. (2015) 2863–2871

5. Ebert, F., Finn, C., Lee, A.X., Levine, S.: Self-supervised visual planning with

temporal skip connections. arXiv preprint arXiv:1710.05268 (2017)

6. SHI, X., Chen, Z., Wang, H., Yeung, D.Y., Wong, W.k., WOO, W.c.: Convolutional
lstm network: A machine learning approach for precipitation nowcasting. In Cortes,
C., Lawrence, N.D., Lee, D.D., Sugiyama, M., Garnett, R., eds.: Advances in Neural
Information Processing Systems (NIPS) 28. Curran Associates, Inc. (2015) 802–810
7. Patraucean, V., Handa, A., Cipolla, R.: Spatio-temporal video autoencoder with

diﬀerentiable memory. arXiv preprint arXiv:1511.06309 (2015)

8. Ranzato, M., Szlam, A., Bruna, J., Mathieu, M., Collobert, R., Chopra, S.: Video
(language) modeling: a baseline for generative models of natural videos. CoRR
abs/1412.6604 (2014)

9. Michalski, V., Memisevic, R., Konda, K.: Modeling deep temporal dependencies
In: Advances in neural information processing

with recurrent grammar cells””.
systems. (2014) 1925–1933

10. Finn, C., Goodfellow, I., Levine, S.: Unsupervised learning for physical interaction
through video prediction. In: Advances in Neural Information Processing Systems.
(2016) 64–72

11. Villegas, R., Yang, J., Hong, S., Lin, X., Lee, H.: Decomposing motion and content

for natural video sequence prediction. ICLR 1(2) (2017) 7

12. Denton, E.L., Birodkar, v.: Unsupervised learning of disentangled representations
In Guyon, I., Luxburg, U.V., Bengio, S., Wallach, H., Fergus, R.,
from video.
Vishwanathan, S., Garnett, R., eds.: Advances in Neural Information Processing
Systems 30. Curran Associates, Inc. (2017) 4417–4426

13. Cricri, F., Honkala, M., Ni, X., Aksu, E., Gabbouj, M.: Video ladder networks.

arXiv preprint arXiv:1612.01756 (2016)

14. Kalchbrenner, N., Oord, A., Simonyan, K., Danihelka, I., Vinyals, O., Graves, A.,
Kavukcuoglu, K.: Video pixel networks. In: International Conference on Machine
Learning. (2017) 1771–1779

15. Liang, X., Lee, L., Dai, W., Xing, E.P.: Dual motion gan for future-ﬂow embed-
In: Proceedings of the IEEE International Conference on

ded video prediction.
Computer Vision. (2017)

16. Vukoti´c, V., Pintea, S.L., Raymond, C., Gravier, G., Van Gemert, J.: One-step
time-dependent future video frame prediction with a convolutional encoder-decoder
neural network. arXiv preprint arXiv:1702.04125 (2017)

17. Babaeizadeh, M., Finn, C., Erhan, D., Campbell, R.H., Levine, S.: Stochastic vari-
ational video prediction. In: International Conference on Learning Representations.
(2018)

17

18. Ilin, A., Pr´emont-Schwarz, I., Hao, T.H., Rasmus, A., Boney, R., Valpola, H.:

Recurrent ladder networks. arXiv preprint arXiv:1707.09219 (2017)

19. Jia, X., De Brabandere, B., Tuytelaars, T., Gool, L.V.: Dynamic ﬁlter networks. In
Lee, D.D., Sugiyama, M., Luxburg, U.V., Guyon, I., Garnett, R., eds.: Advances in
Neural Information Processing Systems 29. Curran Associates, Inc. (2016) 667–675
20. Xue, T., Wu, J., Bouman, K., Freeman, B.: Visual dynamics: Probabilistic future
frame synthesis via cross convolutional networks. In: Advances in Neural Informa-
tion Processing Systems. (2016) 91–99

21. van Amersfoort, J.R., Kannan, A., Ranzato, M., Szlam, A., Tran, D., Chintala, S.:
Transformation-based models of video sequences. CoRR abs/1701.08435 (2017)
22. Walker, J., Marino, K., Gupta, A., Hebert, M.: The pose knows: Video forecasting
by generating pose futures. In: The IEEE International Conference on Computer
Vision (ICCV). (Oct 2017)

23. Mathieu, M., Couprie, C., LeCun, Y.: Deep multi-scale video prediction beyond

mean square error. arXiv preprint arXiv:1511.05440 (2015)

24. Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S.,
Courville, A., Bengio, Y.: Generative adversarial nets. In Ghahramani, Z., Welling,
M., Cortes, C., Lawrence, N.D., Weinberger, K.Q., eds.: Advances in Neural Infor-
mation Processing Systems 27. Curran Associates, Inc. (2014) 2672–2680

25. Sedaghat, N., Zolfaghari, M., Brox, T.: Hybrid learning of optical ﬂow and next
frame prediction to boost optical ﬂow in the wild. arXiv preprint arXiv:1612.03777
(2016)

26. Schuldt, C., Laptev, I., Caputo, B.: Recognizing human actions: a local svm ap-
proach. In: Pattern Recognition, 2004. ICPR 2004. Proceedings of the 17th Inter-
national Conference on. Volume 3., IEEE (2004) 32–36

27. Soomro, K., Zamir, A.R., Shah, M.: Ucf101: A dataset of 101 human actions classes

from videos in the wild. arXiv preprint arXiv:1212.0402 (2012)

8
1
0
2
 
r
a

M
 
6
1
 
 
]

V
C
.
s
c
[
 
 
2
v
1
1
3
0
0
.
2
1
7
1
:
v
i
X
r
a

Folded Recurrent Neural Networks for Future
Video Prediction

Marc Oliu
Universitat Oberta de Catalunya
Centre de Visio per Computador
Rambla del Poblenou, 156, 08018 Barcelona
moliusimon@uoc.edu

Javier Selva
Universitat de Barcelona
Gran Via de les Corts Catalanes, 585, 08007 Barcelona
javier.selva.castello@est.ﬁb.upc.edu

Sergio Escalera
Universitat de Barcelona
Centre de Visio per Computador
Gran Via de les Corts Catalanes, 585, 08007 Barcelona
sergio@maia.ub.es

Abstract. Main challenges in future video prediction are high variabil-
ity in videos, temporal propagation of errors, and non-speciﬁcity of future
frames. This work introduces bijective Gated Recurrent Units (bGRU).
Standard GRUs update a state, exposed as output, given an input. We
extend them by considering the input as another recurrent state, and
update it given the output using an extra set of logic gates. Stacking
multiple such layers results in a recurrent auto-encoder: the operators
updating the outputs comprise the encoder, while the ones updating the
inputs form the decoder. Being the encoder and decoder states shared,
the representation is stratiﬁed during learning: some information is not
passed to the next layers. We show how only the encoder or decoder needs
to be applied for encoding or prediction. This reduces the computational
cost and avoids re-encoding predictions when generating multiple frames,
mitigating error propagation. Furthermore, it is possible to remove lay-
ers from a trained model, giving an insight to the role of each layer. Our
approach improves state of the art results on MMNIST and UCF101,
being competitive on KTH with 2 and 3 times less memory usage and
computational cost than the best scored approach.

Keywords: future video prediction, unsupervised learning, recurrent
neural networks

1 Introduction

Future video prediction is a challenging task that recently received much atten-
tion due to its capabilities for learning in an unsupervised manner, making it

2

possible to leverage large volumes of unlabelled data for video-related tasks such
as action and gesture recognition [1,2,3], task planning [4,5], weather prediction
[6], optical ﬂow estimation [7] and new view synthesis [3].

One of the main problems in this task is the need of expensive models both
in terms of memory and computational power in order to capture the variability
present in video data. Another problem is the propagation of errors in recurrent
models, which is tied to the inherent uncertainty of video prediction: given a se-
ries of previous frames, there are multiple feasible futures. This, left unchecked,
results in a blurry prediction averaging the space of possible futures that prop-
agates back into the network when predicting subsequent frames.

In this work we propose a new approach to recurrent auto-encoders (AE) with
state sharing between encoder and decoder. We show how the exposed state in
Gated Recurrent Units (GRU) can be used to create a bijective mapping between
the input and output of each layer. To do so, the input is treated as a recurrent
state, adding another set of logic gates to update it based on the output. Creating
a stack of these layers allows for a bidirectional ﬂow of information. Using the
forward gates to encode inputs and the backward ones to generate predictions,
we obtain a structure similar to an AE1, but with many inherent advantages. It
reduces memory and computational costs during both training and testing: only
the encoder or decoder is executed for input encoding or prediction, respectively.
Furthermore, the representation is stratiﬁed, encoding only part of the input at
each layer: low level information not necessary to capture higher level dynamics is
not passed to the next layer. Also, it naturally provides a noisy identity mapping
of the input, facilitating the initial stages of training: the input to the ﬁrst
bGRU holds the last encoded frame or, if preceded by convolutional layers, an
over-complete representation of the same. During generation, that ﬁrst untrained
bGRU randomly modiﬁes the last input, introducing a noise signal. The approach
also mitigates the propagation of errors: while it does not solve the problem of
blur, it prevents its magniﬁcation in subsequent predictions. Moreover, a trained
network can be deconstructed in order to analyse the role of each layer in the
ﬁnal predictions, making the model more explainable. Since the encoder and
decoder states are shared, the architecture can be thought of as a recurrent AE
folded in half, with encoder and decoder layers overlapping. We call our method
Folded Recurrent Neural Network (fRNN). Our main contributions are: 1) A
new shared-state recurrent AE with lower memory and computational costs. 2)
Mitigation of error propagation through time. 3) It naturally provides an identity
function during training. 4) Model explainability and optimisation through layer
removal. 5) Demonstration of representation stratiﬁcation.

2 Related work

While initial proposals focused on prediction on small patches [8,9], future video
prediction is nowadays generally approached by building a deep model capable

1 Code available at https://github.com/moliusimon/frnn.

3

of understanding the input sequence in a manner that allows for the generation
of the following frames.

Building Blocks. Due to the characteristics of the problem, an AE setting
has been widely used [1,4,10,11,12]: the encoder extracts valuable information
from the input and the decoder produces new frames. Generally, encoder and
decoder are CNNs that tackle the spatial dimension. LSTMs are commonly used
to handle the temporal dynamics and project the representations into the future.
Some works compute the temporal dynamics at the deep representation bridg-
ing the encoder and decoder [4,7,13,12]. Others jointly handle space and time
by using Convolutional LSTMs [10,2,7,14,15] (or GRUs, as in our case), which
use convolutional kernels at their gates. For instance, Lotter et al. [2] use a re-
current residual network with convolutional LSTM where each layer minimises
the discrepancies from previous block predictions. Common variations of the AE
also include a conditional term to guide the temporal transform, such as a time
diﬀerential [16] or prior knowledge of scene events, reducing the space of possible
futures. Oh et al. [4] predict future frames on Atari games conditioning on the
action taken by the player. Some works propose such action conditioned mod-
els foreseeing an application for autonomous agents learning in an unsupervised
fashion [10,14]. Finn et al. [10] predict a sequence of future frames within a phys-
ical system based on both previous frames and actions taken by a robotic arm
interacting with the scene. The method was recently applied to task planning
[5] and adapted to perform stochastic future frame prediction [17].

Bridge connections. Introducing bridge connections (connections between
equivalent layers of encoder and decoder) is also common [10,3,13,11]. This allows
for a stratiﬁed representation of the input sequence, reducing the capacity needs
of subsequent layers. Video Ladder Networks (VLN) [13] use a convolutional AE
topology implementing skip connections. Pairs of convolutions are grouped into
residual blocks, horizontally passing information between corresponding blocks,
both by directly and by using a recurrent bridge layer. This topology was fur-
ther extended with Recurrent Ladder Networks (RLN) [18], where the recurrent
bridge connections were removed, and the residual blocks replaced by recurrent
layers. We propose an alternative to bridge connections by completely sharing
the state between encoder and decoder, reducing computational needs while
maintaining the stratiﬁcation ability. Both VLN and RLN share some similar-
ities with our approach: they propose a recurrent AE with bridge connections
between encoder and decoder. However, using skip connections instead of state
sharing has some disadvantages: higher number of parameters and memory re-
quirements, impossibility to skip the encoding/decoding steps (resulting in a
higher computational cost) and reduced explainability due to not allowing lay-
ers to be removed after training. Finally, bridge connections do not provide an
initial identity function during training. This makes it hard for the model to con-
verge in some cases: when the background is homogeneous the model may not
learn a proper initial mapping between input and output, but set the weights to
zero and adjust the bias of the last layer, eliminating the gradient in the process.

4

Prediction atom. Most of the proposed architectures for future frame gen-
eration directly predict at pixel level (as in our case). However, some models
have been designed to predict motion and use it to transform the input into
future frames. For instance, using the input sequence to anticipate optical ﬂow
[3,7] or convolutional kernels [19,20]. Other methods propose mapping the in-
put sequence onto predeﬁned feature spaces, such as aﬃne transforms [21] or
human pose vectors [22]. These systems use sequences of such features instead
of working directly at pixel level. Then, they use the predicted feature vectors
to generate the next frames.

Loss and GANs. Commonly used loss functions such as L2 or MSE tend
to average the space of possible futures. For this reason, some works[23,11,22,15]
propose using Generative Adversarial Networks (GAN) [24] to help traditional
losses choose among possible futures by ensuring realistic looking frames and co-
herent sequences. Mathieu et al. [23] use a plain multi-scale CNN in an adversar-
ial setting and propose the Gradient Diﬀerence Loss to sharpen the predictions.
Disentangled Motion/Content. Some authors encode content and mo-
tion separately. Villegas et al. [11] use an AE architecture with a two-stream
encoder: for motion, a CNN + LSTM encodes diﬀerence images; for appearance,
a plain CNN encodes the last input frame. In a similar fashion, Denton et al. [12]
use two separate encoders and an adversarial setting to obtain a disentangled
representation of content and motion. Alternatively, some works predict motion
and content in parallel to beneﬁt from the combined strengths of both tasks.
While Sedaghat et al. [25] propose using an encoding with a dual objective (ﬂow
and future frame), Liang et al. [15] use a dual GAN setting and combine both
predicted frame and motion to generate the actual next frame.

Feedback Predictions. Finally, an important aspect of the recurrent-based
models is that they are based on the use of feedback predictions. In general, a
model is trained to predict a speciﬁc number of time-steps into the future. In
order to predict further in time they need to use their own predictions as in-
put. This, if not handled properly, may accentuate small mistakes causing the
predictions to quickly deteriorate over time. Our model solves this by enabling
encoder and decoder to be executed any number of times independently. This is
similar to the proposal by Srivastava et al. [1], which uses a recurrent AE ap-
proach where an input sequence is encoded and its state copied into the decoder.
The decoder is then applied to generate a given number of frames. However, it
is limited to a single recurrent layer for each part.

3 Proposed method

We propose an architecture based on recurrent convolutional AEs to deal with
the network capacity and error propagation problems for future video prediction.
It consists on a series of bijective GRU layers, which allow for a bidirectional
ﬂow of information between input and output: they consider the input as a
recurrent state and update it using an extra set of gates. These are then stacked,
forming an encoder and decoder using, respectively, the forward and backward

5

Fig. 1. Left: Scheme of a bGRU. Shadowed areas illustrate how multiple bGRU layers
are stacked. Right: fRNN topology. The recurrent states of the encoder and decoder are
shared, resulting in a bidirectional mapping between states. Shadowed areas represent
unnecessary circuitry: re-encoding of the predictions is avoided thanks to the decoder
updating all the states. Left-Right: Blue and red correspond to forward and backward
gates, respectively. Rectangles represent the recurrent state cell.

functions of the bijective GRUs (Fig.1). We call it Folded Recurrent Neural
Network (fRNN). Because of the state sharing between encoder and decoder,
the topology allows for: stratiﬁcation of the encoded information, lower memory
and computational requirements compared to regular recurrent AEs, mitigated
propagation of errors, and increased explainability through layer removal.

3.1 Bijective Gated Recurrent Units

GRUs have their state fully exposed as output. This allows us to deﬁne a bidi-
rectional mapping between input and output by replicating the logic gates of
the GRU layer. To do so, we consider the input as a state on itself. Lets deﬁne
t = f l
the output of a GRU at layer l and time step t as hl
, hl
t−1) given an
input hl−1
and its state at the previous time step hl
t−1. A second set of weights
can be used to deﬁne an inverse mapping hl−1
b(hl
t = f l
t−1) using the output
of the forward function at the current time step to update its input, which is
treated as the hidden state of the inverse function. This is illustrated in Fig. 1.
We will refer to this double mapping as bijective GRU (bGRU).

f (hl−1

t, hl−1

t

t

3.2 Folded Recurrent Neural Network

By stacking multiple bGRUs, a recurrent AE is obtained. Given n bGRUs, the
encoder is deﬁned by the set of forward functions E = {f 1
f } and the
f ,
decoder by the set of backward functions D = {f n
b }. This is illustrated
in Fig. 1, and is equivalent to a recurrent AE, but with shared states, having
3 main advantages: 1) It is not necessary to feed the predictions back into the

b , ..., f 1

..., f n

6

network in order to generate the following predictions. Because the states are
shared, the decoder already updates all the states except for the bridge state
between encoder and decoder. The bridge state is updated by applying the last
layer of the encoder before generating the next prediction. The shadowed area
in Fig. 1 shows the section of the computational graph that is not required when
performing multiple sequential predictions. For the same reason, when consider-
ing multiple sequential elements before prediction, only the encoder is required.
2) Because the network updates its states from the higher level representations
to the lowest ones during prediction, errors introduced at a given layer during
generation are not propagated back into deeper layers, leaving the higher-level
dynamics unaﬀected. 3) The model implicitly provides a noisy identity model
during training, as it is shown in Fig. 7, when all bGRU layers are removed. The
input state of the ﬁrst bGRU layer is either the input image itself or, when ﬁrst
applying a series of convolutional layers, an over-complete representation of the
input. A noise signal is then introduced to the representation by the backward
function of the untrained ﬁrst bGRU layer. Consequently providing the model
with an initial identity model. As we show in Section 4.3, this helps the model to
converge in some datasets like MMNIST: when the same background is shared
across instances, it prevents the model from killing the gradients by adjusting
the biases to match the background and setting the weights to zero.

This approach shares some similarities with VLN and RLN. As with them,
part of the information can be passed directly between corresponding layers of
the encoder and decoder, not having to encode a full representation of the input
into the deepest layer. However, our model implicitly passes the information
through the shared recurrent states, making bridge connections unnecessary.
When compared against an equivalent recurrent AE with bridge connections,
this results in a much lower computational and memory cost. More speciﬁcally,
the number of weights in a pair of forward and backward functions is equal to
3(hl−1
+ 2hl−1 hl) in the case of bGRU, where hl corresponds to the state
size of layer l. When using bridge connections, as in the case of VLN and RLN,
+ 4hl−1 hl). This corresponds to an
+ hl
that value is incremented to 3(hl−1
increase of 44% in the number of parameters when one state has double the size
of the other, and of 50% when they have the same size. Furthermore, both the
encoder and decoder must be applied at each time step. Thus, memory usage is
doubled and computational cost is increased by a factor of between 2.88 and 3.

+ hl

2

2

2

2

3.3 Training Folded RNNs

In a regular recurrent AE, a ground truth frame is introduced at each time step
by applying both encoder and decoder. The output is used as a supervision point,
comparing it to the next ground truth frame in the sequence. This implies all
predictions are at a single time step from the last ground truth prediction. Here,
we propose a training approach for fRNNs that exploits the ability of the topol-
ogy of skipping the model encoder or decoder at a given time step. First g ground
truth frames are shown to the network by passing them through the encoder.

7

The decoder is then applied p times, producing p predictions. This results in
only half the memory requirements: either encoder or decoder is applied at each
step, never both. This has the same advantage as the approach by Srivastava
[1], where recurrently applying the decoder without further ground truth inputs
encourages the network to learn video dynamics. This also prevents the network
from learning an identity model, i.e. copying the last input to the output.

4 Experiments

Here, we ﬁrst discuss data, evaluation protocol, and methods. Then we provide a
detailed quantitative and qualitative evaluation. We ﬁnish with a brief analysis
on the stratiﬁcation of sequence representation among bGRU layers2.

4.1 Data and evaluation protocol

We considered 3 datasets of diﬀerent complexity in order to analyse the per-
formance of the proposed method: Moving MNIST (MMNIST)[1], KTH [26],
and UCF101 [27]. MMNIST consists of 64 × 64 grayscale sequences of length 20
displaying pairs of digits moving around the image. The sequences are gener-
ated by randomly sampling pairs of digits and trajectories. It contains a ﬁxed
test partition with 10000 sequences. We generated a million extra samples for
training. KTH consists of 600 videos of 15-20 seconds with 25 subjects perform-
ing 6 actions in 4 diﬀerent settings. The videos are grayscale, at a resolution of
120 × 160 pixels and 25 fps. The dataset has been split into subjects 1 to 16 for
training, and 17 to 25 for testing, resulting in 383 and 216 sequences, respec-
tively. Frame size is reduced to 64 × 80 using bilinear interpolation, removing
5 pixels from the left and right borders before resizing. UCF101 displays 101
actions, such as playing instruments, weight lifting or sports. It is the most chal-
lenging dataset considered, with a high intra-class variability. It contains 9950
training sequences and 3361 test sequences. These are RGB at a resolution of
320 × 240 pixels and 25 fps. To increase motion between consecutive frames, one
of every two frames was removed. Following the same procedure as with KTH,
the frame size is reduced to 64 × 85.

All methods are tested using 10 input frames to generate the following 10
frames. We use 3 common metrics for video prediction analysis: Mean Squared
Error (MSE), Peak Signal-to-Noise Ratio (PSNR), and Structural Dissimilarity
(DSSIM). MSE and PSNR are objective measurements of reconstruction quality.
DSSIM is a measure of the perceived quality. For DSSIM we use a Gaussian
sliding window of size 11 × 11 and σ = 1.5.

4.2 Methods

To train the proposed method we used RMSProp with learning rate of 0.0001
and batch size of 12, sampling a random sub-sequence at each epoch. Weights

2 Additional qualitative results, as well as an extended table of quantitative results by

time step, are shown in the supplementary material.

8

Conv 1 Conv 2 Pool 1 bGRU 1 bGRU 2 Pool 2 bGRU 3 bGRU 4 Pool 3 bGRU 5 bGRU 6 Pool 4 bGRU 7 bGRU 8

32

Num. Units
Kernel size 5 × 5
Stride
Activation tanh

1

64
5 × 5
1
tanh

-
2 × 2
2
-

128
5 × 5
1

128
5 × 5
1

256
5 × 5
1

256
5 × 5
1

-
2 × 2
2
-

512
3 × 3
1

512
3 × 3
1

-
2 × 2
2
-

-
2 × 2
2
-

256
3 × 3
1

256
3 × 3
1

sigmoid & tanh

sigmoid & tanh

sigmoid & tanh

sigmoid & tanh

Table 1. Parameters of the topology used for the experiments. The decoder applies
the same topology in reverse, using nearest neighbours interpolation and transposed
convolutions to revert the pooling and convolutional layers.

were orthogonally initialised, with biases set to 0. For testing, we considered all
sub-sequences of length 20. Our network topology consists of two convolutional
layers followed by 8 convolutional bGRU layers, applying a 2 × 2 max pooling
every 2 layers. Topology details are shown in Table 1. We use deconvolution and
nearest neighbours interpolation to invert the convolutional and max pooling
layers, respectively. We train with L1 loss.

For evaluation, we include a stub baseline model predicting the last input
frame, and design a second baseline (RLadder) to evaluate the advantages of us-
ing state sharing. RLadder has the same topology as the fRNN model, but uses
bridge connections instead of state sharing. Note that to keep the same state size
on GRU layers, using bridge connections doubles the memory size and almost
triples the computational cost (Sec.3.2). This is similar to how RLN [18] works,
but using regular conv GRU layers in the decoder. We also compare against
Srivastava [1] and Mathieu [23]. The former only handles the temporal dimen-
sion explicitly with LSTMs, while the latter only treats the spatial dimensions
using 3D CNN. Next, we compare against Villegas [11], which, contrary to our
proposal, uses feedback predictions. Finally, we compare against Lotter et al. [2]
which is based on residual error reduction. All of them were adapted to train
using 10 frames as input and predicting the next 10, using the topologies and
parameters deﬁned by the authors.

4.3 Quantitative analysis

The ﬁrst row of Fig. 2 displays the results for the MMNIST dataset for the
proposed method, baselines, and state of the art alternatives. Mean scores are
shown in Table 2. fRNN performs best on all time steps and metrics, followed by
Srivastava et al. [1]. These two are the only methods to provide valid predictions
on this dataset. Most other methods predict a black frame, with Mathieu et al.
[23] progressively blurring the digits. This is caused by a loss of gradient during
the ﬁrst stages of training. On more complex datasets the methods start by
learning an identity function, then reﬁning the results. This is possible since in
many sequences most of the frame remains unchanged. In the case of MMNIST,
where the background is homogeneous, it is much easier for the models to set the
weights of the output layer to zero and set the biases to match the background
colour. This cuts the gradient and prevents further learning. Srivastava et al.
[1] use an auxiliary decoder to reconstruct the input frames, forcing the model
to learn an identity function. This, as discussed at the end of Section 3.2, is
implicitly handled in our method, giving an initial solution to improve on and

9

Fig. 2. Quantitative results on the considered datasets in terms of the number of time
steps since the last input frame. From top to bottom: MMNIST, KTH, and UCF101.
From left to right: MSE, PSNR, and DSSIM. For MMNIST, RLadder is pre-trained to
learn an initial identity mapping, allowing it to converge.

MMNIST

MSE

PSNR DSSIM
Baseline 0.06989 11.745 0.20718
RLadder 0.04254 13.857 0.13788
Lotter [2] 0.04161 13.968 0.13825
Srivastava [1] 0.01737 18.183 0.08164
Mathieu [23] 0.02748 15.969 0.29565
Villegas [11] 0.04254 13.857 0.13896
fRNN 0.00947 21.386 0.04376

MSE

KTH
PSNR DSSIM
0.00366 29.071 0.07900
0.00139 31.268 0.05945
0.00309 28.424 0.09170
0.00995 21.220 0.19860
0.00180 29.341 0.10410
0.00165 30.946 0.07657
0.00175 29.299 0.07251

MSE

UCF101
PSNR DSSIM
0.01294 22.859 0.15043
0.00918 23.558 0.13395
0.01550 19.869 0.21389
0.14866 10.021 0.42555
0.00926 22.781 0.16262
0.00940 23.457 0.14150
0.00908 23.872 0.13055

Table 2. Average results over 10 time steps.

preventing the models from learning a black image. In order to verify this eﬀect,
we pre-trained RLadder on the KTH dataset. While this dataset has completely
diﬀerent dynamics, the initial step to solve the problem remains: providing an
identity function. Afterwards the model is ﬁne-tuned on the MMNIST dataset.
As it is shown in Fig. 2 (dashed lines), this results in the model converging, with
an accuracy comparable to Srivastava et al. [1] for the 3 evaluation metrics.

On the KTH dataset, Table 2 shows the best approach is our RLadder base-
line followed by fRNN and Villegas et al. [11], both having similar results, but
with Villegas et al. having slightly lower MSE and higher PSNR, and fRNN a
lower DSSIM. While both approaches obtain comparable average results, the er-
ror increases faster over time in the case of Villegas et al. (second row in Fig.2).
Mathieu obtains good scores for MSE and PSNR, but has a much worse DSSIM.

10

For the UCF101 dataset, as shown in Table 2, our fRNN approach is the
best performing for all 3 metrics. When looking at the third row of Fig. 5, one
can see that Villegas et al. starts out with results similar to fRNN on the ﬁrst
frame, but as in the case of KTH and MMNIST, the predictions degrade faster
than with the proposed approach. Two methods display low performance in most
cases. Lotter et al. works well for the ﬁrst predicted frame in the case of KTH
and UCF101, but the error rapidly increases on the following predictions. This
is due to a magniﬁcation of artefacts introduced on the ﬁrst prediction, making
the method unable to predict multiple frames without supervision. In the case
of Srivastava et al. the problem is about capacity: it uses fully connected LSTM
layers, making the number of parameters explode quickly with the state cell
size. This severely limits the representation capacity for complex datasets such
as KTH and UCF101.

Overall, for the considered methods, fRNN is the best performing on MMINST
and UCF101, the later being the most complex of the 3 datasets. We achieved
these results with a simple topology: apart from the proposed bGRU layers, we
use conventional max pooling with an L1 loss. There are no normalisation or
regularisation mechanisms, specialised activation functions, complex topologies
or image transform operators. In the case of MMNIST, fRNN shows the ability
to ﬁnd a good initial representation and converges to good predictions where
most other methods fail. In the case of KTH, fRNN has an overall accuracy
comparable to that of Villegas et al., being more stable over time. It is only
surpassed by the proposed RLadder baseline, a method equivalent to fRNN but
with 2 and 3 times more memory and computational requirements.

4.4 Qualitative analysis

In this section we evaluate our approach qualitatively on some samples from
the three considered datasets. Fig. 3 shows the last 5 input frames from some
MMNIST sequences along with the next 10 ground truth frames and their corre-
sponding fRNN predictions. The 10 predictions are generated sequentially with-
out showing the previous ground truth/prediction to the network, that is, only
using the decoder. As it can be seen, the digits maintain their sharpness across
the sequence of predictions. Also, the bounces at the edges of the image are done
correctly, and the digits do not distort or deform when crossing. This shows the
network internally encodes the appearance of each digit, making it possible to
reconstruct them after sharing the same region in the image plane.

Qualitative examples of fRNN predictions on the KTH dataset are shown in
Fig. 4. It shows three actions: hand waving, walking, and boxing. The blur stops
increasing after the ﬁrst three predictions, generating plausible motions for the
corresponding actions while background artefacts are not introduced. Although
the movement patterns for each type of action have a wide range of variability
on its trajectory, bGRU gives relatively sharp predictions for the limbs. The ﬁrst
and third examples also show the ability of the model to recover from blur. The
blur slightly increases for the arms while the action is performed, but decreases
again as these reach the ﬁnal position.

11

Fig. 3. fRNN predictions on MMNIST. First row for each sequence shows last 5 inputs
and target frames. Yellow frames are model predictions.

Fig. 4. fRNN predictions on KTH. First row for each sequence shows last 5 inputs and
target frames. Yellow frames are model predictions.

Fig. 5 shows fRNN predictions on the UCF101 dataset. These correspond
to two diﬀerent physical exercises and a girl playing the piano. Common to all
predictions, the static parts do not lose sharpness over time, and the background
is properly reconstructed after an occlusion. The network correctly predicts ac-
tions with low variability, as shown in rows 1-2, where a repetitive movement is
performed, and in last row, where the girl recovers a correct body posture. These
dynamic regions introduce blur due to the uncertainty of the action, averaging
the possible futures. The ﬁrst row also shows an interesting behaviour: while the
woman is standing up, the upper body becomes blurry due to uncertainty, but
as the woman ﬁnishes her motion and ends up in the expected upright position,
the frames sharpen again. Since the model does not propagate errors to deeper
layers nor makes use of previous predictions for the following ones, the introduc-
tion of blur does not imply this blur will be propagated. In this example, while
the middle motion could have multiple predictions depending on the movement
pace and the inclination of the body while performing it, the ﬁnal body pose has
a lower uncertainty.

In Fig. 6 we compare predictions from the proposed approach against the
RLadder baseline and other state of the art methods. For the MMNIST dataset

12

Fig. 5. fRNN predictions on UCF. First row for each sequence shows last 5 inputs and
target frames. Yellow frames are model predictions.

we did not consider Villegas et al. and Lotter et al. since these methods fail to
successfully converge and they predict a sequence of black frames. From the rest
of approaches, fRNN obtains the best predictions, with little blur or distortion.
The RLadder baseline is the second best approach. It does not introduce blur,
but heavily deforms the digits after they cross. Srivastava et al. and Mathieu et
al. both accumulate blur over time, but while the former does so to a smaller
degree, the later makes the digits unrecognisable after ﬁve frames.

For KTH, Villegas et al. obtains outstanding qualitative results. It predicts
plausible dynamics and maintains the sharpness of both the individual and back-
ground. Both fRNN and RLadder follow closely, predicting plausible dynamics,
but not being as good as Villegas et al. at maintaining the sharpness of the
individual. On UCF101 the best prediction is obtained by our model, with little
blur or distortion compared to the other methods. The second best is Villegas
et al., successfully capturing the movement patterns but introducing more blur
and important distorsions on the last frame. When looking at the background,
fRNN proposes a plausible initial estimation and progressively completes it as
the woman moves. On the other hand, Villegas et al. modiﬁes already generated
regions as more background is uncovered, generating an unrealistic sequence re-
garding the background. Srivastava and Lotter fail on both KTH and UCF101.
Srivastava et al. heavily distort the frames. As discussed in Section 4.3, this is
due to the use of fully connected recurrent layers, which constrains the state size
and prevents the model from encoding relevant information on more complex
scenarios. In the case of Lotter, it makes good predictions for the ﬁrst frame,
but rapidly accumulates artefacts.

4.5 Representation stratiﬁcation analysis

Here we analyse the stratiﬁcation of the sequence representation among the
bGRU layers. Because bGRU units allow for a bijective mapping between states,
it is possible to remove the deepest layers of a trained network, allowing us to
check how the predictions are aﬀected and providing an insight on the dynamics
captured by each layer. Speciﬁcally, the same sequences are predicted multiple

Input 1

Input 5

Input 10

GT 1

GT 5

GT 10

13

Pred. 1

Pred. 5
fRNN

Pred. 10

Pred. 1

Pred. 10

Pred. 1

Pred. 5
RLadder

Pred. 5
Srivastava et al.

Pred. 10

Mathieu et al.

Villegas et al.

Lotter et al.

Fig. 6. Predictions at 1, 5, and 10 time steps from the last ground truth frame. RLadder
predictions on MMNIST are from the model pre-trained on KTH.

times, removing a layer each time. To our knowledge, this is the ﬁrst topology
allowing for a direct observation of the behaviour encoded on each layer.

This is shown in Fig. 7 for the MMNIST dataset. The analysed model consists
of 10 layers: 2 convolutional layers and 8 bGRU layers. Firstly, removing the last
2 bGRU layers has no signiﬁcant impact on prediction. This shows that, for
this simple dataset, the network has a higher capacity than required. Further
removing layers does not result in a loss of pixel-level information, but on a
progressive loss of behaviours, from more complex to simpler ones. This means
information at a given level of abstraction is not encoded into higher level layers.
When removing the third deepest bGRU layer, the digits stop bouncing and keep
their linear trajectories, exiting the image. This indicates this layer is in charge
of encoding information on bouncing dynamics. When removing the next layer,
digits stop behaving correctly on the boundaries of the image. Parts of the digit
bounce while others keep the previous trajectory. While this also has to do with
bouncing dynamics, the layer seems to be in charge of recognising digits as single
units following the same movement pattern. When removed, diﬀerent segments
of the digit are allowed to move as separate elements. Finally, with only 3-2

14

8 bGRU layers

6 bGRU layers

5 bGRU layers

4 bGRU layers

3 bGRU layers

2 bGRU layers

1 bGRU layer

0 bGRU layers

Fig. 7. Moving MNIST predictions with fRNN layer removal. Removing all bGRU
layers (last row) leaves two convolutional layers and their transposed convolutions,
providing an identity mapping.

bGRU layers the digits are distorted in various ways. With only two layers left,
the general linear dynamics are still captured by the model. By leaving a single
bGRU layer, the linear dynamics are lost.

According to these results, linear movement dynamics are captured at pixel
level on the ﬁrst two bGRU layers. The next two start aggregating these move-
ment patterns into single-trajectory components, preventing their distortion.
The collision of these components with image bounds is also detected. The ﬁfth
layer aggregates single-motion components into digits, forcing them to follow the
same motion. This seems to have the eﬀect of preventing bounces, likely due to

15

only one of the components reaching the edge of the image. It is the sixth bGRU
layer that provides a coherent bouncing pattern for the whole digit.

5 Conclusions

We presented Folded Recurrent Neural Networks, a new recurrent architecture
for video prediction with lower computational and memory cost compared to
equivalent recurrent AE models. This is achieved by using the proposed bijec-
tive GRUs, which horizontally pass information between the encoder and de-
coder. This eliminates the need for using the entire AE at any given step: only
the encoder or decoder needs to be executed for both input encoding and pre-
diction, respectively. It also facilitates the convergence by naturally providing
a noisy identity function during training. We evaluated our approach on three
video datasets, outperforming state of the art prediction results on MMNIST
and UCF101, and obtaining competitive results on KTH with 2 and 3 times less
memory usage and computational cost than the best scored approach. Qualita-
tively, the model can limit and recover from blur by preventing its propagation
from low to high level dynamics. We also demonstrated stratiﬁcation of the
representation, topology optimisation, and model explainability through layer
removal. Each layer has been shown to modify the state of the previous one by
adding more complex behaviours: removing a layer eliminates its behaviours but
leaves lower-level ones untouched.

16

References

1. Srivastava, N., Mansimov, E., Salakhudinov, R.: Unsupervised learning of video
In: International Conference on Machine Learning.

representations using lstms.
(2015) 843–852

2. Lotter, W., Kreiman, G., Cox, D.: Deep predictive coding networks for video
prediction and unsupervised learning. arXiv preprint arXiv:1605.08104 (2016)
3. Liu, Z., Yeh, R., Tang, X., Liu, Y., Agarwala, A.: Video frame synthesis using deep

voxel ﬂow. arXiv preprint arXiv:1702.02463 (2017)

4. Oh, J., Guo, X., Lee, H., Lewis, R.L., Singh, S.: Action-conditional video prediction
using deep networks in atari games. In: Advances in Neural Information Processing
Systems. (2015) 2863–2871

5. Ebert, F., Finn, C., Lee, A.X., Levine, S.: Self-supervised visual planning with

temporal skip connections. arXiv preprint arXiv:1710.05268 (2017)

6. SHI, X., Chen, Z., Wang, H., Yeung, D.Y., Wong, W.k., WOO, W.c.: Convolutional
lstm network: A machine learning approach for precipitation nowcasting. In Cortes,
C., Lawrence, N.D., Lee, D.D., Sugiyama, M., Garnett, R., eds.: Advances in Neural
Information Processing Systems (NIPS) 28. Curran Associates, Inc. (2015) 802–810
7. Patraucean, V., Handa, A., Cipolla, R.: Spatio-temporal video autoencoder with

diﬀerentiable memory. arXiv preprint arXiv:1511.06309 (2015)

8. Ranzato, M., Szlam, A., Bruna, J., Mathieu, M., Collobert, R., Chopra, S.: Video
(language) modeling: a baseline for generative models of natural videos. CoRR
abs/1412.6604 (2014)

9. Michalski, V., Memisevic, R., Konda, K.: Modeling deep temporal dependencies
In: Advances in neural information processing

with recurrent grammar cells””.
systems. (2014) 1925–1933

10. Finn, C., Goodfellow, I., Levine, S.: Unsupervised learning for physical interaction
through video prediction. In: Advances in Neural Information Processing Systems.
(2016) 64–72

11. Villegas, R., Yang, J., Hong, S., Lin, X., Lee, H.: Decomposing motion and content

for natural video sequence prediction. ICLR 1(2) (2017) 7

12. Denton, E.L., Birodkar, v.: Unsupervised learning of disentangled representations
In Guyon, I., Luxburg, U.V., Bengio, S., Wallach, H., Fergus, R.,
from video.
Vishwanathan, S., Garnett, R., eds.: Advances in Neural Information Processing
Systems 30. Curran Associates, Inc. (2017) 4417–4426

13. Cricri, F., Honkala, M., Ni, X., Aksu, E., Gabbouj, M.: Video ladder networks.

arXiv preprint arXiv:1612.01756 (2016)

14. Kalchbrenner, N., Oord, A., Simonyan, K., Danihelka, I., Vinyals, O., Graves, A.,
Kavukcuoglu, K.: Video pixel networks. In: International Conference on Machine
Learning. (2017) 1771–1779

15. Liang, X., Lee, L., Dai, W., Xing, E.P.: Dual motion gan for future-ﬂow embed-
In: Proceedings of the IEEE International Conference on

ded video prediction.
Computer Vision. (2017)

16. Vukoti´c, V., Pintea, S.L., Raymond, C., Gravier, G., Van Gemert, J.: One-step
time-dependent future video frame prediction with a convolutional encoder-decoder
neural network. arXiv preprint arXiv:1702.04125 (2017)

17. Babaeizadeh, M., Finn, C., Erhan, D., Campbell, R.H., Levine, S.: Stochastic vari-
ational video prediction. In: International Conference on Learning Representations.
(2018)

17

18. Ilin, A., Pr´emont-Schwarz, I., Hao, T.H., Rasmus, A., Boney, R., Valpola, H.:

Recurrent ladder networks. arXiv preprint arXiv:1707.09219 (2017)

19. Jia, X., De Brabandere, B., Tuytelaars, T., Gool, L.V.: Dynamic ﬁlter networks. In
Lee, D.D., Sugiyama, M., Luxburg, U.V., Guyon, I., Garnett, R., eds.: Advances in
Neural Information Processing Systems 29. Curran Associates, Inc. (2016) 667–675
20. Xue, T., Wu, J., Bouman, K., Freeman, B.: Visual dynamics: Probabilistic future
frame synthesis via cross convolutional networks. In: Advances in Neural Informa-
tion Processing Systems. (2016) 91–99

21. van Amersfoort, J.R., Kannan, A., Ranzato, M., Szlam, A., Tran, D., Chintala, S.:
Transformation-based models of video sequences. CoRR abs/1701.08435 (2017)
22. Walker, J., Marino, K., Gupta, A., Hebert, M.: The pose knows: Video forecasting
by generating pose futures. In: The IEEE International Conference on Computer
Vision (ICCV). (Oct 2017)

23. Mathieu, M., Couprie, C., LeCun, Y.: Deep multi-scale video prediction beyond

mean square error. arXiv preprint arXiv:1511.05440 (2015)

24. Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S.,
Courville, A., Bengio, Y.: Generative adversarial nets. In Ghahramani, Z., Welling,
M., Cortes, C., Lawrence, N.D., Weinberger, K.Q., eds.: Advances in Neural Infor-
mation Processing Systems 27. Curran Associates, Inc. (2014) 2672–2680

25. Sedaghat, N., Zolfaghari, M., Brox, T.: Hybrid learning of optical ﬂow and next
frame prediction to boost optical ﬂow in the wild. arXiv preprint arXiv:1612.03777
(2016)

26. Schuldt, C., Laptev, I., Caputo, B.: Recognizing human actions: a local svm ap-
proach. In: Pattern Recognition, 2004. ICPR 2004. Proceedings of the 17th Inter-
national Conference on. Volume 3., IEEE (2004) 32–36

27. Soomro, K., Zamir, A.R., Shah, M.: Ucf101: A dataset of 101 human actions classes

from videos in the wild. arXiv preprint arXiv:1212.0402 (2012)

