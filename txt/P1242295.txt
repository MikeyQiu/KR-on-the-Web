Greedy, Joint Syntactic-Semantic Parsing with Stack LSTMs

Swabha Swayamdipta♣ Miguel Ballesteros♦ Chris Dyer♠ Noah A. Smith♥
♣School of Computer Science, Carnegie Mellon University, Pittsburgh, PA 15213, USA
♦Natural Language Processing Group, Universitat Pompeu Fabra, Barcelona, Spain
♠Google DeepMind, London, UK
♥Computer Science & Engineering, University of Washington, Seattle, WA 98195, USA
swabha@cs.cmu.edu, miguel.ballesteros@upf.edu,
cdyer@cs.cmu.edu, nasmith@cs.washington.edu

Abstract

We present a transition-based parser that
jointly produces syntactic and semantic
It learns a representation
dependencies.
of the entire algorithm state, using stack
long short-term memories. Our greedy in-
ference algorithm has linear time, includ-
ing feature extraction. On the CoNLL
2008–9 English shared tasks, we obtain
the best published parsing performance
among models that jointly learn syntax
and semantics.

1

Introduction

We introduce a new joint syntactic and semantic
dependency parser. Our parser draws from the
algorithmic insights of the incremental structure
building approach of Henderson et al. (2008), with
two key differences. First, it learns representations
for the parser’s entire algorithmic state, not just the
top items on the stack or the most recent parser
states; in fact, it uses no expert-crafted features at
all. Second, it uses entirely greedy inference rather
than beam search. We ﬁnd that it outperforms all
previous joint parsing models, including Hender-
son et al. (2008) and variants (Gesmundo et al.,
2009; Titov et al., 2009; Henderson et al., 2013) on
the CoNLL 2008 and 2009 (English) shared tasks.
Our parser’s multilingual results are comparable to
the top systems at CoNLL 2009.

Joint models like ours have frequently been pro-
posed as a way to avoid cascading errors in NLP
pipelines; varying degrees of success have been at-
tained for a range of joint syntactic-semantic anal-
ysis tasks (Sutton and McCallum, 2005; Hender-
son et al., 2008; Toutanova et al., 2008; Johansson,
2009; Llu´ıs et al., 2013, inter alia).

One reason pipelines often dominate is that they
make available the complete syntactic parse tree,

and arbitrarily-scoped syntactic features—such as
the “path” between predicate and argument, pro-
posed by Gildea and Jurafsky (2002)—for seman-
tic analysis. Such features are a mainstay of high-
performance semantic role labeling (SRL) sys-
tems (Roth and Woodsend, 2014; Lei et al., 2015;
FitzGerald et al., 2015; Foland and Martin, 2015),
but they are expensive to extract (Johansson, 2009;
He et al., 2013).

This study shows how recent advances in repre-
sentation learning can bypass those expensive fea-
tures, discovering cheap alternatives available dur-
ing a greedy parsing procedure. The speciﬁc ad-
vance we employ is the stack LSTM (Dyer et al.,
2015), a neural network that continuously summa-
rizes the contents of the stack data structures in
which a transition-based parser’s state is conven-
tionally encoded. Stack LSTMs were shown to ob-
viate many features used in syntactic dependency
parsing; here we ﬁnd them to do the same for joint
syntactic-semantic dependency parsing.

We believe this is an especially important ﬁnd-
ing for greedy models that cast parsing as a se-
quence of decisions made based on algorithmic
state, where linguistic theory and researcher intu-
itions offer less guidance in feature design.

Our system’s performance does not match that
of the top expert-crafted feature-based systems
(Zhao et al., 2009; Bj¨orkelund et al., 2010; Roth
and Woodsend, 2014; Lei et al., 2015), systems
which perform optimal decoding (T¨ackstr¨om et
al., 2015), or of systems that exploit additional,
differently-annotated datasets (FitzGerald et al.,
2015). Many advances in those systems are or-
thogonal to our model, and we expect future work
to achieve further gains by integrating them.

Because our system is very fast— with an
end-to-end runtime of 177.6±18 seconds to parse
the CoNLL 2009 English test data on a single
core—we believe it will be useful in practical set-

8
1
0
2
 
l
u
J
 
5
 
 
]
L
C
.
s
c
[
 
 
2
v
4
5
9
8
0
.
6
0
6
1
:
v
i
X
r
a

root

sbj

vc

oprd

im

tmp

all are expected to reopen soon

expect.01

reopen.01

A1

C-A1

A1

AM-TMP

Figure 1: Example of a joint parse. Syntactic de-
pendencies are shown by arcs above the sentence
and semantic dependencies below; predicates are
marked in boldface. C- denotes continuation of
argument A1. Correspondences between depen-
dencies might be close (between expected and to)
or not (between reopen and all).

tings. Our open-source implementation has been
released.1

2

Joint Syntactic and Semantic
Dependency Parsing

We largely follow the transition-based, synchro-
nized algorithm of Henderson et al. (2013) to pre-
dict joint parse structures. The input to the algo-
rithm is a sentence annotated with part-of-speech
tags. The output consists of a labeled syntactic de-
pendency tree and a directed SRL graph, in which
a subset of words in the sentence are selected as
predicates, disambiguated to a sense, and linked
by labeled, directed edges to their semantic argu-
ments. Figure 1 shows an example.

2.1 Transition-Based Procedure

The two parses are constructed in a bottom-up
fashion,
incrementally processing words in the
sentence from left to right. The state of the pars-
ing algorithm at timestep t is represented by three
stack data structures: a syntactic stack St, a se-
mantic stack Mt—each containing partially built
structures—and a buffer of input words Bt. Our
algorithm also places partial syntactic and seman-
tic parse structures onto the front of the buffer,
so it is also implemented as a stack. Each arc in
the output corresponds to a transition (or “action”)
chosen based on the current state; every transition
modiﬁes the state by updating St, Mt, and Bt to
St+1, Mt+1, and Bt+1, respectively. While each
state may license several valid actions, each action

1https://github.com/clab/

joint-lstm-parser

has a deterministic effect on the state of the algo-
rithm.

Initially, S0 and M0 are empty, and B0 contains
the input sentence with the ﬁrst word at the front
of B and a special root symbol at the end.2 Execu-
tion ends on iteration t such that Bt is empty and
St and Mt contain only a single structure headed
by root.

2.2 Transitions for Joint Parsing

There are separate sets of syntactic and semantic
transitions; the former manipulate S and B, the
latter M and B. All are formally deﬁned in Ta-
ble 1. The syntactic transitions are from the “arc-
eager” algorithm of Nivre (2008). They include:

• S-SHIFT, which copies3 an item from the front

of B and pushes it on S.

• S-REDUCE pops an item from S.
• S-RIGHT((cid:96)) creates a syntactic dependency.
Let u be the element at the top of S and v be
the element at the front of B. The new depen-
dency has u as head, v as dependent, and label
(cid:96). u is popped off S, and the resulting structure,
rooted at u, is pushed on S. Finally, v is copied
to the top of S.

• S-LEFT((cid:96)) creates a syntactic dependency with
label (cid:96) in the reverse direction as S-RIGHT. The
top of S, u, is popped. The front of B, v, is
replaced by the new structure, rooted at v.

The semantic transitions are similar, operating

on the semantic stack.

• M-SHIFT removes an item from the front of B

and pushes it on M .

• M-REDUCE pops an item from M .
• M-RIGHT(r) creates a semantic dependency.
Let u be the element at the top of M and v,
the front of B. The new dependency has u as
head, v as dependent, and label r. u is popped
off M , and the resulting structure, rooted at u,
is pushed on M .

• M-LEFT(r) creates a semantic dependency
with label r in the reverse direction as M-
RIGHT. The buffer front, v, is replaced by the
new v-rooted structure. M remains unchanged.

2This works better for the arc-eager algorithm (Balles-
teros and Nivre, 2013), in contrast to Henderson et al. (2013),
who initialized with root at the buffer front.

3Note that in the original arc-eager algorithm (Nivre,
2008), SHIFT and RIGHT-ARC actions move the item on the
buffer front to the stack, whereas we only copy it (to allow
the semantic operations to have access to it).

ﬁed and the algorithm returns to syntactic transi-
tions. This implies that, for each word, its left-
side syntactic dependencies are resolved before its
left-side semantic dependencies. An example run
of the algorithm is shown in Figure 3.

2.3 Constraints on Transitions

To ensure that the parser never enters an invalid
state, the sequence of transitions is constrained,
following Henderson et al. (2013). Actions that
copy or move items from the buffer (S-SHIFT,
S-RIGHT and M-SHIFT) are forbidden when the
buffer is empty. Actions that pop from a stack
(S-REDUCE and M-REDUCE) are forbidden when
that stack is empty. We disallow actions corre-
sponding to the same dependency, or the same
predicate to be repeated in the sequence. Repet-
itive M-SWAP transitions are disallowed to avoid
inﬁnite swapping. Finally, as noted above, we re-
strict the parser to syntactic actions until it needs
to shift an item from B to S, after which it can
only execute semantic actions until it executes an
M-SHIFT.

Asymptotic runtime complexity of this greedy
algorithm is linear in the length of the input, fol-
lowing the analysis by Nivre (2009).5

3 Statistical Model

The transitions in §2 describe the execution paths
our algorithm can take; like past work, we apply
a statistical classiﬁer to decide which transition to
take at each timestep, given the current state. The
novelty of our model is that it learns a ﬁnite-length
vector representation of the entire joint parser’s
state (S, M , and B) in order to make this decision.

3.1 Stack Long Short-Term Memory (LSTM)

LSTMs are recurrent neural networks equipped
with specialized memory components in addition
to a hidden state (Hochreiter and Schmidhuber,
1997; Graves, 2013) to model sequences. Stack
LSTMs (Dyer et al., 2015) are LSTMs that al-
low for stack operations: query, push, and pop.
A “stack pointer” is maintained which determines
which cell in the LSTM provides the memory and
hidden units when computing the new memory
cell contents. Query provides a summary of the
stack in a single ﬁxed-length vector. Push adds

semantic transitions, hence we only copy it.

5The analysis in (Nivre, 2009) does not consider SWAP
actions. However, since we constrain the number of such ac-
tions, the linear time complexity of the algorithm stays intact.

Figure 2: Example of an SRL graph with an arc
from predicate problem.01 to itself, ﬁlling the A2
role. Our SELF(A2) transition allows recovering
this semantic dependency.

Because SRL graphs allow a node to be a se-
mantic argument of two parents—like all in the
example in Figure 1—M-LEFT and M-RIGHT
do not remove the dependent from the semantic
stack and buffer respectively, unlike their syntactic
equivalents, S-LEFT and S-RIGHT. We use two
other semantic transitions from Henderson et al.
(2013) which have no syntactic analogues:

• M-SWAP swaps the top two items on M , to al-

low for crossing semantic arcs.

• M-PRED(p) marks the item at the front of B
as a semantic predicate with the sense p, and
replaces it with the disambiguated predicate.

The CoNLL 2009 corpus introduces semantic
self-dependencies where many nominal predicates
(from NomBank) are marked as their own argu-
ments; these account for 6.68% of all semantic
arcs in the English corpus. An example involving
an eventive noun is shown in Figure 2. We intro-
duce a new semantic transition, not in Henderson
et al. (2013), to handle such cases:

• M-SELF(r) adds a dependency, with label r be-
tween the item at the front of B and itself. The
result replaces the item at the front of B.

Note that the syntactic and semantic transitions
both operate on the same buffer, though they in-
dependently specify the syntax and semantics, re-
spectively. In order to ensure that both syntactic
and semantic parses are produced, the syntactic
and semantic transitions are interleaved. Only syn-
tactic transitions are considered until a transition is
chosen that copies an item from the buffer front to
the syntactic stack (either S-SHIFT or S-RIGHT).
The algorithm then switches to semantic transi-
tions until a buffer-modifying transition is taken
(M-SHIFT).4 At this point, the buffer is modi-

4Had we moved the item at the buffer front during the
syntactic transitions, it would have been unavailable for the

St
S
(u, u), S

(u, u), S

(u, u), S
S
S
S
S
S
S
S

Mt
M
M

M

Bt
(v, v), B
B

Action
S-SHIFT
S-REDUCE

St+1
(v, v), S
S

(v, v), B

S-RIGHT((cid:96))

(v, v), (gs(u, v, l), u), S

M
M
(u, u), M
(u, u), M
(u, u), M
(u, u), (v, v), M
M
M

(v, v), B
(v, v), B
B
(v, v), B
(v, v), B
B
(v, v), B
(v, v), B

S-LEFT((cid:96))
M-SHIFT
M-REDUCE
M-RIGHT(r)
M-LEFT(r)
M-SWAP
M-PRED(p)
M-SELF(r)

S
S
S
S
S
S
S
S

M

(v, v), B

Mt+1
M
M

M (gs(v, u, l), v), B

Bt+1
(v, v), B
B

Dependency
—
—
S ∪ u (cid:96)→ v
S ∪ u (cid:96)← v
B
—
B
—
M ∪ u r→ v
(v, v), B
(u, u), M (gm(v, u, r), v), B M ∪ u r← v
B
(gd(v, p), v), B

(v, v), (u, u), M
M
M (gm(v, v, r), v), B M ∪ v r↔ v

(v, v), M
M
(gm(u, v, r), u), M

—
—

Table 1: Parser transitions along with the modiﬁcations to the stacks and the buffer resulting from each.
Syntactic transitions are shown above, semantic below. Italic symbols denote symbolic representations
of words and relations, and bold symbols indicate (learned) embeddings (§3.5) of words and relations;
each element in a stack or buffer includes both symbolic and vector representations, either atomic or
recursive. S represents the set of syntactic transitions, and M the set of semantic transitions.

an element to the top of the stack, resulting in a
new summary. Pop, which does not correspond to
a conventional LSTM operation, moves the stack
pointer to the preceding timestep, resulting in a
stack summary as it was before the popped item
was observed. Implementation details (Dyer et al.,
2015; Goldberg, 2015) and code have been made
publicly available.6

Using stack LSTMs, we construct a represen-
tation of the algorithm state by decomposing it
into smaller pieces that are combined by recursive
function evaluations (similar to the way a list is
built by a concatenate operation that operates on a
list and an element). This enables information that
would be distant from the “top” of the stack to be
carried forward, potentially helping the learner.

3.2 Stack LSTMs for Joint Parsing

four

Our algorithm employs
stack LSTMs,
one each for the S, M , and B data struc-
tures.Like Dyer et al. (2015), we use a fourth stack
LSTM, A, for the history of actions—A is never
popped from, only pushed to. Figure 4 illustrates
the architecture. The algorithm’s state at timestep
t is encoded by the four vectors summarizing the
four stack LSTMs, and this is the input to the clas-
siﬁer that chooses among the allowable transitions
at that timestep.

Let st, mt, bt, and at denote the summaries
of St, Mt, Bt, and At, respectively. Let At =
Allowed(St, Mt, Bt, At) denote the allowed tran-
sitions given the current stacks and buffer. The
parser state at time t is given by a rectiﬁed linear
unit (Nair and Hinton, 2010) in vector yt:

where W and d are the parameters of the classi-
ﬁer. The transition selected at timestep t is

arg max
τ ∈At
≡ arg max
τ ∈At

qτ + θτ · yt

(1)

score(τ ; St, Mt, Bt, At)

where θτ and qτ are parameters for each transi-
tion type τ . Note that only allowed transitions are
considered in the decision rule (see §2.3).

3.3 Composition Functions

To use stack LSTMs, we require vector representa-
tions of the elements that are stored in the stacks.
Speciﬁcally, we require vector representations of
atoms (words, possibly with part-of-speech tags)
and parse fragments. Word vectors can be pre-
trained or learned directly; we consider a concate-
nation of both in our experiments; part-of-speech
vectors are learned and concatenated to the same.
To obtain vector representations of parse frag-
ments, we use neural networks which recursively
compute representations of the complex structured
output (Dyer et al., 2015). The tree structures here
are always ternary trees, with each internal node’s
three children including a head, a dependent, and
a label. The vectors for leaves are word vectors
and vectors corresponding to syntactic and seman-
tic relation types.

The vector for an internal node is a squashed
(tanh) afﬁne transformation of its children’s vec-
tors. For syntactic and semantic attachments, re-
spectively, the composition function is:

yt = elementwisemax {0, d + W[st; mt; bt; at]}

6https://github.com/clab/lstm-parser

gs(v, u, l) = tanh(Zs[v; u; l] + es)
gm(v, u, r) = tanh(Zm[v; u; r] + em)

(2)

(3)

d
e
t
c
e
p
x
e

→
−
e
r
a

c
v

1
0
.
t
c
e
p
x
e
−
1
←
A

d
r
p
o

o
t

→
−
d
e
t
c
e
p
x
e

o
t

-

1
→
A
−
C
1
0
.
t
c
e
p
x
e

n
e
p
o
e
r

i

→
m
−
o
t

1
0
.
n
e
p
o
e
r

−
1
←
A

e
r
a
−
←

j
b
s

n
o
o
s

P
M
→
T
−
-
M
A

1
0
.
n
e
p
o
e
r

n
o
o
s

t

→
p
m
−
n
e
p
o
e
r

t
o
o
r

t
o
o
r

−
←

e
r
a

—

—

—

l
l
a

—

—

—

—

l
l
a

—

—

—

—

—

l
l
a

—

—

—

—

—

—

—

—

—

—

—

y
c
n
e
d
n
e
p
e
D

B

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a

,
l
l
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a

,
l
l
a
[

,
o
t

,
o
t

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
o
t

,
d
e
t
c
e
p
x
e
[

,
d
e
t
c
e
p
x
e
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
l
l
a
[

]
l
l
a
[

]
e
r
a
[

]
e
r
a
[

]
[

S

]
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

)
1
0
.
t
c
e
p
x
e
(
D
E
R
P
-
M

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
d
e
t
c
e
p
x
e

,
l
l
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
d
e
t
c
e
p
x
e

,
l
l
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
d
e
t
c
e
p
x
e

,
l
l
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
d
r
p
o
(
T
H
G

I

R

-
S
*
*
*

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
[

]
[

]
n
o
o
s

,
n
e
p
o
e
r

]
n
o
o
s

,
n
e
p
o
e
r

]
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
o
t

,
o
t

,
o
t

,
o
t

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
n
e
p
o
e
r
[

]
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
p
m

t
(
T
H
G

I

R

-
S

]
n
e
p
o
e
r
[

]
n
o
o
s

,
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
P
M
T
-
M
A
(
T
H
G

I

-

R
M

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

,
o
t

,
o
t

,
o
t

,
o
t

,
o
t

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
1
A
-
C

(
T
H
G

I

-

R
M

E
C
U
D
E
R
M

-

T
F
I

H
S
-
M

)

m

i
(
T
H
G

I

R

-
S

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
1
0
.
n
e
p
o
e
r
(
D
E
R
P
-
M

]
e
r
a
[

]
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

M

]
[

]
[

]
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
e
r
a

,
l
l
a
[

]
e
r
a

,
l
l
a
[

]
e
r
a

,
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
o
t

,
l
l
a
[

]
o
t

,
l
l
a
[

]
o
t

,
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
[

]
n
e
p
o
e
r
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
t
o
o
r
[

]
[

)
j
b
s
(
T
F
E
L
-
S

T
F
I

H
S
-
S

T
F
I

H
S
-
M

)
c
v
(
T
H
G

I

R

-
S

T
F
I

H
S
-
S

T
F
I

H
S
-
M

E
C
U
D
E
R
M

-

)
1
A
(
T
F
E
L
-
M

T
F
I

H
S
-
M

n
o
i
t
i
s
n
a
r
T

E
C
U
D
E
R
M

-

)
1
A
(
T
F
E
L
-
M

E
C
U
D
E
R
M

-

T
F
I

H
S
-
M

E
C
U
D
E
R
M

-

E
C
U
D
E
R

-
S

E
C
U
D
E
R

-
S

E
C
U
D
E
R

-
S

E
C
U
D
E
R

-
S

T
F
I

H
S
-
M

)
t
o
o
r
(
T
F
E
L
-
S

E
C
U
D
E
R
M

-

T
F
I

H
S
-
M

T
F
I

H
S
-
S

Figure 3: Joint parser transition sequence for the sentence in Figure 1, “all are expected to reopen soon.”
Syntactic labels are in lower-case and semantic role labels are capitalized. *** marks the operation
predicted in Figure 4.

where v and u are vectors corresponding to atomic
words or composed parse fragments; l and r are
learned vector representations for syntactic and se-
mantic labels respectively. Syntactic and semantic
parameters are separated (Zs, es and Zm, em, re-
spectively).

Finally, for predicates, we use another recur-
sive function to compose the word representa-

tion, v with a learned representation for the dis-
mabiguated sense of the predicate, p:

gd(v, p) = tanh(Zd[v; p] + ed)

(4)

where Zd and ed are parameters of the model.
Note that, because syntactic and semantic transi-
tions are interleaved, the fragmented structures are
a blend of syntactic and semantic compositions.

Figure 4: Stack LSTM for joint parsing. The state
illustrated corresponds to the ***-marked row in
the example transition sequence in Fig. 3.

Figure 5 shows an example.

3.4 Training

Training the classiﬁer requires transforming each
training instance (a joint parse) into a transition se-
quence, a deterministic operation under our tran-
sition set. Given a collection of algorithm states
at time t and correct classiﬁcation decisions τt, we
minimize the sum of log-loss terms, given (for one
timestep) by:

− log

(cid:80)

exp(qτt + θτt · yt)

τ (cid:48)∈At

exp(qτ (cid:48) + θτ (cid:48) · yt)

(5)

with respect to the classiﬁer and LSTM parame-
ters. Note that the loss is differentiable with re-
spect to the parameters; gradients are calculated
using backpropagation. We apply stochastic gra-
dient descent with dropout for all neural network
parameters.

3.5 Pretrained Embeddings

Following Dyer et al. (2015), “structured skip-
gram” embeddings (Ling et al., 2015) were used,
trained on the English (AFP section), German,
Spanish and Chinese Gigaword corpora, with a
window of size 5; training was stopped after 5
epochs. For out-of-vocabulary words, a randomly
initialized vector of the same dimension was used.

3.6 Predicate Sense Disambiguation

Figure 5: Example of a joint parse tree fragment
with vector representations shown at each node.
The vectors are obtained by recursive composition
of representations of head, dependent, and label
vectors. Syntactic dependencies and labels are in
green, semantic in blue.

are lexeme-speciﬁc, we need a way to handle un-
seen predicates at test time. When a predicate is
encountered at test time that was not observed in
training, our system constructs a predicate from
the predicted lemma of the word at that position
and defaults to the “01” sense, which is correct
for 91.22% of predicates by type in the English
CoNLL 2009 training data.

4 Experimental Setup

Our model is evaluated on the CoNLL shared
tasks on joint syntactic and semantic dependency
parsing in 2008 (Surdeanu et al., 2008) and
2009 (Hajiˇc et al., 2009). The standard training,
development and test splits of all datasets were
used. Per the shared task guidelines, automati-
cally predicted POS tags and lemmas provided in
the datasets were used for all experiments. As
a preprocessing step, pseudo-projectivization of
the syntactic trees (Nivre et al., 2007) was used,
which allowed an accurate conversion of even the
non-projective syntactic trees into syntactic transi-
tions. However, the oracle conversion of semantic
parses into transitions is not perfect despite using
the M-SWAP action, due to the presence of multi-
ple crossing arcs.7

The standard evaluation metrics include the
syntactic labeled attachment score (LAS), the se-

Predicate sense disambiguation is handled within
the model (M-PRED transitions), but since senses

7For 1.5% of English sentences in the CoNLL 2009 En-
glish dataset, the transition sequence incorrectly encodes the
gold-standard joint parse; details in Henderson et al. (2013).

mantic F1 score on both in-domain (WSJ) and out-
of-domain (Brown corpus) data, and their macro
average (Macro F1) to score joint systems. Be-
cause the task was deﬁned somewhat differently
in each year, each dataset is considered in turn.

4.1 CoNLL 2008

The CoNLL 2008 dataset contains annotations
from the Penn Treebank (Marcus et al., 1993),
PropBank (Palmer et al., 2005) and Nom-
Bank (Meyers et al., 2004). The shared task evalu-
ated systems on predicate identiﬁcation in addition
to predicate sense disambiguation and SRL.

To identify predicates, we trained a zero-
Markov order bidirectional LSTM two-class clas-
siﬁer. As input to the classiﬁer, we use learned rep-
resentations of word lemmas and POS tags. This
model achieves an F1 score of 91.43% on marking
words as predicates (or not).

Hyperparameters The input representation for
a word consists of pretrained embeddings (size
100 for English, 80 for Chinese, 64 for Ger-
man and Spanish), concatenated with additional
learned word and POS tag embeddings (size 32
and 12, respectively). Learned embeddings for
syntactic and semantic arc labels are of size 20
and predicates 100. Two-layer LSTMs with hid-
den state dimension 100 were used for each of the
four stacks. The parser state yt and the composi-
tion function g are of dimension 100. A dropout
rate of 0.2 (Zaremba et al., 2014) was used on all
layers at training time, tuned on the development
data from the set of values {0.1, 0.2, 0.3, 1.0}. The
learned representations for actions are of size 100,
similarly tuned from {10, 20, 30, 40, 100}. Other
hyperparameters have been set intuitively; careful
tuning is expected to yield improvements (Weiss
et al., 2015).

An initial learning rate of 0.1 for stochastic gra-
dient descent was used and updated in every train-
ing epoch with a decay rate of 0.1 (Dyer et al.,
2015). Training is stopped when the development
performance does not improve for approximately
6–7 hours of elapsed time. Experiments were run
on a single thread on a CPU, with memory require-
ments of up to 512 MB.

4.2 CoNLL 2009

Relative to the CoNLL 2008 task (above), the
main change in 2009 is that predicates are pre-
identiﬁed, and systems are only evaluated on pred-

icate sense disambiguation (not
identiﬁcation).
Hence, the bidirectional LSTM classiﬁer is not
used here. The preprocessing for projectivity, and
the hyperparameter selection is the same as in
§4.1.

In addition to the joint approach described in
the preceding sections, we experiment here with
several variants:

Semantics-only:
the set of syntactic transitions
S, the syntactic stack S, and the syntactic compo-
sition function gs are discarded. As a result, the set
of constraints on transitions is a subset of the full
set of constraints in §2.3. Effectively, this model
does not use any syntactic features, similar to Col-
lobert et al. (2011) and Zhou and Xu (2015). It
provides a controlled test of the beneﬁt of explicit
syntax in a semantic parser.

all semantic transitions in M, the
Syntax-only:
semantic stack M , and the semantic composition
function gm are discarded. S-SHIFT and S-RIGHT
now move the item from the front of the buffer to
the syntactic stack, instead of copying. The set of
constraints on the transitions is again a subset of
the full set of constraints. This model is an arc-
eager variant of Dyer et al. (2015), and serves to
check whether semantic parsing degrades syntac-
tic performance.

Hybrid:
the semantics parameters are trained
using automatically predicted syntax from the
syntax-only model. At test time, only seman-
tic parses are predicted. This setup bears simi-
larity to other approaches which pipeline syntax
and semantics, extracting features from the syn-
tactic parse to help SRL. However, unlike other
approaches, this model does not offer the entire
syntactic tree for feature extraction, since only the
partial syntactic structures present on the syntactic
stack (and potentially the buffer) are visible at a
given timestep. This model helps show the effect
of joint prediction.

5 Results and Discussion

CoNLL 2008 (Table 2) Our joint model signif-
icantly outperforms the joint model of Hender-
son et al. (2008), from which our set of tran-
sitions is derived, showing the beneﬁt of learn-
ing a representation for the entire algorithmic
state. Several other joint learning models have
been proposed (Llu´ıs and M`arquez, 2008; Jo-
hansson, 2009; Titov et al., 2009) for the same

Model

joint models:
Llu´ıs and M`arquez (2008)
Henderson et al. (2008)
Johansson (2009)
Titov et al. (2009)
CoNLL 2008 best:
#3: Zhao and Kit (2008)
#2: Che et al. (2008)
#2: Ciaramita et al. (2008)
#1: J&N (2008)
Joint (this work)

LAS

Sem. Macro
F1

F1

85.8
87.6
86.6
87.5

87.7
86.7
87.4
89.3
89.1

70.3
73.1
77.1
76.1

76.7
78.5
78.0
81.6
80.5

78.1
80.5
81.8
81.8

82.2
82.7
82.7
85.5
84.9

Table 2: Joint parsers: comparison on the CoNLL
2008 test (WSJ+Brown) set.

task; our joint model surpasses the performance
of all these models. The best reported systems on
the CoNLL 2008 task are due to Johansson and
Nugues (2008), Che et al. (2008), Ciaramita et
al. (2008) and Zhao and Kit (2008), all of which
pipeline syntax and semantics; our system’s se-
mantic and overall performance is comparable to
these. We fall behind only Johansson and Nugues
(2008), whose success was attributed to carefully
designed global SRL features integrated into a
pipeline of classiﬁers, making them asymptoti-
cally slower.

CoNLL 2009 English (Table 3) All of our
models (Syntax-only, Semantics-only, Hybrid and
Joint) improve over Gesmundo et al.
(2009)
and Henderson et al. (2013), demonstrating the
beneﬁt of our entire-parser-state representation
learner compared to the more locally scoped
model.

Given that syntax has consistently proven useful
in SRL, we expected our Semantics-only model
to underperform Hybrid and Joint, and it did. In
the training domain, syntax and semantics bene-
ﬁt each other (Joint outperforms Hybrid). Out-
of-domain (the Brown test set), the Hybrid pulls
ahead, a sign that Joint overﬁts to WSJ. As a
syntactic parser, our Syntax-only model performs
slightly better than Dyer et al. (2015), who achieve
89.56 LAS on this task.
Joint parsing is very
slightly better still.

The overall performance of Joint is on par with
the other winning participants at the CoNLL 2009
shared task (Zhao et al., 2009; Che et al., 2009;
Gesmundo et al., 2009), falling behind only Zhao
et al. (2009), who carefully designed language-

speciﬁc features and used a series of pipelines for
the joint task, resulting in an accurate but compu-
tationally expensive system.

State-of-the-art SRL systems (shown in the last
block of Table 3) which use advances orthog-
onal to the contributions in this paper, perform
better than our models. Many of these systems
use expert-crafted features derived from full syn-
tactic parses in a pipeline of classiﬁers followed
by a global reranker (Bj¨orkelund et al., 2009;
Bj¨orkelund et al., 2010; Roth and Woodsend,
2014); we have not used these features or rerank-
ing. Lei et al. (2015) use syntactic parses to obtain
interaction features between predicates and their
arguments and then compress feature representa-
tions using a low-rank tensor. T¨ackstr¨om et al.
(2015) present an exact inference algorithm for
SRL based on dynamic programming and their lo-
cal and structured models make use of many syn-
tactic features from a pipeline; our search pro-
cedure is greedy. Their algorithm is adopted
by FitzGerald et al. (2015) for inference in a model
that jointly learns representations from a combina-
tion of PropBank and FrameNet annotations; we
have not experimented with extra annotations.

Our system achieves an end-to-end runtime of
177.6±18 seconds to parse the CoNLL 2009 En-
glish test set on a single core. This is almost 2.5
times faster than the pipeline model of Lei et al.
(2015) (439.9±42 seconds) on the same machine.8

CoNLL 2009 Multilingual (Table 4) We tested
the joint model on the non-English CoNLL 2009
datasets, and the results demonstrate that it adapts
easily—it is on par with the top three systems in
most cases. We note that our Chinese parser relies
on pretrained word embeddings for its superior
performance; without them (not shown), it was on
par with the others. Japanese is a small-data case
(4,393 training examples), illustrating our model’s
dependence on reasonably large training datasets.
We have not extended our model to incorporate
morphological features, which are used by the sys-
tems to which we compare. Future work might in-
corporate morphological features where available;
this could potentially improve performance, espe-
cially in highly inﬂective languages like Czech.
An alternative might be to infer word-internal rep-
resentations using character-based word embed-

8See

SRLParser; unlike other state-of-the-art systems,
one is publicly available.

https://github.com/taolei87/
this

Model

LAS

Sem. F1
(WSJ)

Sem. F1
(Brown)

Macro
F1

88.79
88.48
89.19

89.83

89.83
89.94

CoNLL’09 best:
#3 G+ ’09
#2 C+ ’09
#1 Z+ ’09a
this work:
Syntax-only
Sem.-only
Hybrid
Joint
pipelines:
R&W ’14
L+ ’15
T+ ’15
F+ ’15

83.24
85.51
86.15

84.39
84.58
84.97

86.34
86.58
87.30
87.80

70.65
73.82
74.58

86.03
87.00
87.69

87.20
87.45

73.87
75.64
74.48

75.90
75.57
75.50
75.50

Table 3: Comparison on the CoNLL 2009 English
test set. The ﬁrst block presents results of other
models evaluated for both syntax and semantics on
the CoNLL 2009 task. The second block presents
our models. The third block presents the best pub-
lished models, each using its own syntactic pre-
processing.

dings, which was found beneﬁcial for syntactic
parsing (Ballesteros et al., 2015).

Language
Catalan
Chinese
Czech
English
German
Japanese
Spanish
Average

#1 C+’09
81.84
76.38
83.27
87.00
82.44
85.65
81.90
82.64

#2 Z+ ’09a
83.01
76.23
80.87
87.69
81.22
85.28
83.31
82.52

#3 G+ ’09
82.66
76.15
83.21
86.03
79.59
84.91
82.43
82.14

Joint
82.40
79.27
79.53
87.45
81.05
80.91
83.11
81.96

Table 4: Comparison of macro F1 scores on the
multilingual CoNLL 2009 test set.

6 Related Work

Other approaches to joint modeling, not consid-
ered in our experiments, are notable. Llu´ıs et al.
(2013) propose a graph-based joint model using
dual decomposition for agreement between syn-
tax and semantics, but do not achieve competi-
tive performance on the CoNLL 2009 task. Lewis
et al. (2015) proposed an efﬁcient joint model for
CCG syntax and SRL, which performs better than
a pipelined model. However, their training neces-
sitates CCG annotation, ours does not. Moreover,
their evaluation metric rewards semantic depen-
dencies regardless of where they attach within the
argument span given by a PropBank constituent,

making direct comparison to our evaluation infea-
sible. Krishnamurthy and Mitchell (2014) pro-
pose a joint CCG parsing and relation extraction
model which improves over pipelines, but their
task is different from ours. Li et al. (2010) also
perform joint syntactic and semantic dependency
parsing for Chinese, but do not report results on
the CoNLL 2009 dataset.

There has also been an increased interest in
models which use neural networks for SRL. Col-
lobert et al. (2011) proposed models which per-
form many NLP tasks without hand-crafted fea-
tures. Though they did not achieve the best results
on the constituent-based SRL task (Carreras and
M`arquez, 2005), their approach inspired Zhou and
Xu (2015), who achieved state-of-the-art results
using deep bidirectional LSTMs. Our approach
for dependency-based SRL is not directly compa-
rable.

7 Conclusion

We presented an incremental, greedy parser for
joint syntactic and semantic dependency parsing.
Our model surpasses the performance of previous
joint models on the CoNLL 2008 and 2009 En-
glish tasks, without using expert-crafted, expen-
sive features of the full syntactic parse.

Acknowledgments

The authors thank Sam Thomson, Lingpeng Kong,
Mark Yatskar, Eunsol Choi, George Mulcaire, and
Luheng He, as well as the anonymous review-
ers, for many useful comments. This research
was supported in part by DARPA grant FA8750-
12-2-0342 funded under the DEFT program and
by the U.S. Army Research Ofﬁce under grant
number W911NF-10-1-0533. Any opinion, ﬁnd-
ings, and conclusions or recommendations ex-
pressed in this material are those of the author(s)
and do not necessarily reﬂect the view of the
U.S. Army Research Ofﬁce or the U.S. Govern-
ment. Miguel Ballesteros was supported by the
European Commission under the contract num-
bers FP7-ICT-610411 (project MULTISENSOR)
and H2020-RIA-645012 (project KRISTINA).

References

[Ballesteros and Nivre2013] Miguel Ballesteros

and
Joakim Nivre. 2013. Going to the roots of de-
Computational Linguistics,
pendency parsing.
39(1):5–13.

[Ballesteros et al.2015] Miguel Ballesteros, Chris Dyer,
Improved transition-
and Noah A. Smith. 2015.
based parsing by modeling characters instead of
words with LSTMs. In Proc. of EMNLP.

[Bj¨orkelund et al.2009] Anders Bj¨orkelund,

Love
Hafdell, and Pierre Nugues. 2009. Multilingual
semantic role labeling. In Proc. of CoNLL.

[Bj¨orkelund et al.2010] Anders Bj¨orkelund,

Bernd
Bohnet, Love Hafdell, and Pierre Nugues. 2010.
A high-performance syntactic and semantic depen-
dency parser. In Proc. of COLING.

[Carreras and M`arquez2005] Xavier Carreras and Llu´ıs
Introduction to the CoNLL-2005
In Proc. of

M`arquez. 2005.
shared task: Semantic role labeling.
CoNLL.

[Che et al.2008] Wanxiang Che, Zhenghua Li, Yuxuan
Hu, Yongqiang Li, Bing Qin, Ting Liu, and Sheng
Li. 2008. A cascaded syntactic and semantic de-
pendency parsing system. In Proc. of CoNLL.

[Che et al.2009] Wanxiang

Li,
Zhenghua
and
Yongqiang Li, Yuhang Guo, Bing Qin,
Ting Liu. 2009. Multilingual dependency-based
syntactic and semantic parsing. In Proc. of CoNLL.

Che,

[Ciaramita et al.2008] Massimiliano

Ciaramita,
Giuseppe Attardi, Felice Dell’Orletta, and Mi-
hai Surdeanu.
DeSRL: A linear-time
semantic role labeling system. In Proc. of CoNLL.

2008.

[Collobert et al.2011] Ronan Collobert, Jason Weston,
L´eon Bottou, Michael Karlen, Koray Kavukcuoglu,
and Pavel Kuksa.
2011. Natural language pro-
cessing (almost) from scratch. Journal of Machine
Learning Research, 12:2493–2537.

[Dyer et al.2015] Chris Dyer, Miguel Ballesteros,
Wang Ling, Austin Matthews, and Noah A. Smith.
2015. Transition-based dependency parsing with
stack long short-term memory. In Proc. of ACL.

[FitzGerald et al.2015] Nicholas FitzGerald, Oscar
T¨ackstr¨om, Kuzman Ganchev, and Dipanjan Das.
2015. Semantic role labelling with neural network
factors. In Proc. of EMNLP.

[Foland and Martin2015] William R. Foland and James
2015. Dependencybased semantic role
In

Martin.
labeling using convolutional neural networks.
Proc. of *SEM.

[Gesmundo et al.2009] Andrea Gesmundo, James Hen-
derson, Paola Merlo, and Ivan Titov. 2009. A latent
variable model of synchronous syntactic-semantic
parsing for multiple languages. In Proc. of CoNLL.

[Gildea and Jurafsky2002] Daniel Gildea and Daniel
Jurafsky. 2002. Automatic labeling of semantic
roles. Computational Linguistics, 28(3):245–288.

[Graves2013] Alex Graves.

Generat-
ing sequences with recurrent neural networks.
arXiv:1308.0850.

2013.

[Hajiˇc et al.2009] Jan Hajiˇc, Massimiliano Cia-
ramita, Richard Johansson, Daisuke Kawahara,
Maria Ant`onia Mart´ı, Llu´ıs M`arquez, Adam Mey-
ers, Joakim Nivre, Sebastian Pad´o, Jan ˇStˇep´anek,
Pavel Straˇn´ak, Mihai Surdeanu, Nianwen Xue, and
Yi Zhang. 2009. The CoNLL-2009 shared task:
Syntactic and semantic dependencies in multiple
languages. In Proc. of CoNLL.

[He et al.2013] He He, Hal Daum´e III, and Jason Eis-
ner. 2013. Dynamic feature selection for depen-
dency parsing. In Proc. of EMNLP.

[Henderson et al.2008] James Henderson, Paola Merlo,
Gabriele Musillo, and Ivan Titov. 2008. A latent
variable model of synchronous parsing for syntactic
and semantic dependencies. In Proc. of CoNLL.

[Henderson et al.2013] James Henderson, Paola Merlo,
Ivan Titov, and Gabriele Musillo. 2013. Multi-
lingual joint parsing of syntactic and semantic de-
pendencies with a latent variable model. Computa-
tional Linguistics, 39(4):949–998.

[Hochreiter and Schmidhuber1997] Sepp Hochreiter
and J¨urgen Schmidhuber. 1997. Long short-term
memory. Neural Computation, 9(8):1735–1780.

[Johansson and Nugues2008] Richard Johansson and
Pierre Nugues. 2008. Dependency-based syntactic-
semantic analysis with PropBank and NomBank. In
Proc. of CoNLL.

[Johansson2009] Richard Johansson. 2009. Statistical
bistratal dependency parsing. In Proc. of EMNLP.

[Krishnamurthy and Mitchell2014] Jayant

Krishna-
murthy and Tom M. Mitchell. 2014. Joint syntactic
and semantic parsing with combinatory categorial
grammar. In Proc. of ACL.

[Lei et al.2015] Tao Lei, Yuan Zhang, Llu´ıs M`arquez
i Villodre, Alessandro Moschitti, and Regina Barzi-
lay. 2015. High-order low-rank tensors for semantic
role labeling. In Proc. of NAACL.

[Lewis et al.2015] Mike Lewis, Luheng He, and Luke
Zettlemoyer. 2015. Joint A* CCG parsing and se-
mantic role labelling. In Proc. of EMNLP.

[Li et al.2010] Junhui Li, Guodong Zhou,

Hwee Tou Ng.
2010.
mantic parsing of Chinese. In Proc. of ACL.

and
Joint syntactic and se-

[Ling et al.2015] Wang Ling, Chris Dyer, Alan Black,
and Isabel Trancoso. 2015. Two/too simple adapta-
tions of word2vec for syntax problems. In Proc. of
NAACL.

[Goldberg2015] Yoav Goldberg. 2015. A primer on
neural network models for natural language process-
ing. arXiv:1510.00726.

[Llu´ıs and M`arquez2008] Xavier Llu´ıs

and Llu´ıs
M`arquez. 2008. A joint model for parsing syntactic
and semantic dependencies. In Proc. of CoNLL.

[Llu´ıs et al.2013] Xavier Llu´ıs, Xavier Carreras, and
Llu´ıs M`arquez. 2013. Joint arc-factored parsing of
syntactic and semantic dependencies. Transactions
of the ACL, 1:219–230.

[Toutanova et al.2008] Kristina

Aria
Toutanova,
2008.
Haghighi, and Christopher D. Manning.
A global joint model for semantic role labeling.
Computational Linguistics, 34(2):161–191.

[Weiss et al.2015] David Weiss, Chris Alberti, Michael
Collins, and Slav Petrov. 2015. Structured train-
ing for neural network transition-based parsing. In
Proc. of ACL.

[Zaremba et al.2014] Wojciech

Sutskever, and Oriol Vinyals.
neural network regularization. arXiv:1409.2329.

Ilya
Zaremba,
2014. Recurrent

[Zhao and Kit2008] Hai Zhao and Chunyu Kit. 2008.
Parsing syntactic and semantic dependencies with
two single-stage maximum entropy models. In Proc.
of CoNLL.

[Zhao et al.2009] Hai Zhao, Wenliang Chen, Jun’ichi
Kazama, Kiyotaka Uchimoto, and Kentaro Tori-
sawa. 2009. Multilingual dependency learning: Ex-
ploiting rich features for tagging syntactic and se-
mantic dependencies. In Proc. of CoNLL.

[Zhou and Xu2015] Jie Zhou and Wei Xu. 2015. End-
to-end learning of semantic role labeling using re-
current neural networks. In Proc. of ACL.

[Marcus et al.1993] Mitchell P. Marcus, Mary Ann
1993.
Marcinkiewicz, and Beatrice Santorini.
Building a large annotated corpus of English:
The Penn treebank. Computational Linguistics,
19(2):313–330.

[Meyers et al.2004] Adam Meyers, Ruth Reeves,
Catherine Macleod, Rachel Szekely, Veronika
Zielinska, Brian Young, and Ralph Grishman. 2004.
The NomBank project: An interim report. In Proc.
of NAACL.

[Nair and Hinton2010] Vinod Nair and Geoffrey E.
Hinton. 2010. Rectiﬁed linear units improve re-
stricted Boltzmann machines. In Proc. of ICML.

[Nivre et al.2007] Joakim Nivre, Johan Hall, Jens Nils-
son, Atanas Chanev, G¨ulsen Eryigit, Sandra K¨ubler,
Svetoslav Marinov, and Erwin Marsi. 2007. Malt-
Parser: A language-independent system for data-
driven dependency parsing. Natural Language En-
gineering, 13:95–135.

[Nivre2008] Joakim Nivre. 2008. Algorithms for de-
terministic incremental dependency parsing. Com-
putational Linguistics, 34(4):513–553.

[Nivre2009] Joakim Nivre. 2009. Non-projective de-
pendency parsing in expected linear time. In Proc.
of ACL.

[Palmer et al.2005] Martha Palmer, Daniel Gildea, and
Paul Kingsbury. 2005. The Proposition Bank: An
annotated corpus of semantic roles. Computational
Linguistics, 31(1):71–106.

[Roth and Woodsend2014] Michael Roth and Kristian
Woodsend. 2014. Composition of word represen-
tations improves semantic role labelling. In Proc. of
EMNLP.

[Surdeanu et al.2008] Mihai Surdeanu, Richard Johans-
son, Adam Meyers, Llu´ıs M`arquez, and Joakim
Nivre. 2008. The CoNLL-2008 shared task on joint
parsing of syntactic and semantic dependencies. In
Proc. of CoNLL.

[Sutton and McCallum2005] Charles Sutton and An-
drew McCallum. 2005. Joint parsing and semantic
role labeling. In Proc. of CoNLL.

[T¨ackstr¨om et al.2015] Oscar T¨ackstr¨om, Kuzman
Efﬁcient
Ganchev, and Dipanjan Das.
inference and structured learning for semantic role
labeling. Transactions of the ACL, 3:29–41.

2015.

[Titov et al.2009] Ivan Titov, James Henderson, Paola
Merlo, and Gabriele Musillo. 2009. Online graph
planarisation for synchronous parsing of semantic
and syntactic dependencies. In Proc. of IJCAI.

Greedy, Joint Syntactic-Semantic Parsing with Stack LSTMs

Swabha Swayamdipta♣ Miguel Ballesteros♦ Chris Dyer♠ Noah A. Smith♥
♣School of Computer Science, Carnegie Mellon University, Pittsburgh, PA 15213, USA
♦Natural Language Processing Group, Universitat Pompeu Fabra, Barcelona, Spain
♠Google DeepMind, London, UK
♥Computer Science & Engineering, University of Washington, Seattle, WA 98195, USA
swabha@cs.cmu.edu, miguel.ballesteros@upf.edu,
cdyer@cs.cmu.edu, nasmith@cs.washington.edu

Abstract

We present a transition-based parser that
jointly produces syntactic and semantic
It learns a representation
dependencies.
of the entire algorithm state, using stack
long short-term memories. Our greedy in-
ference algorithm has linear time, includ-
ing feature extraction. On the CoNLL
2008–9 English shared tasks, we obtain
the best published parsing performance
among models that jointly learn syntax
and semantics.

1

Introduction

We introduce a new joint syntactic and semantic
dependency parser. Our parser draws from the
algorithmic insights of the incremental structure
building approach of Henderson et al. (2008), with
two key differences. First, it learns representations
for the parser’s entire algorithmic state, not just the
top items on the stack or the most recent parser
states; in fact, it uses no expert-crafted features at
all. Second, it uses entirely greedy inference rather
than beam search. We ﬁnd that it outperforms all
previous joint parsing models, including Hender-
son et al. (2008) and variants (Gesmundo et al.,
2009; Titov et al., 2009; Henderson et al., 2013) on
the CoNLL 2008 and 2009 (English) shared tasks.
Our parser’s multilingual results are comparable to
the top systems at CoNLL 2009.

Joint models like ours have frequently been pro-
posed as a way to avoid cascading errors in NLP
pipelines; varying degrees of success have been at-
tained for a range of joint syntactic-semantic anal-
ysis tasks (Sutton and McCallum, 2005; Hender-
son et al., 2008; Toutanova et al., 2008; Johansson,
2009; Llu´ıs et al., 2013, inter alia).

One reason pipelines often dominate is that they
make available the complete syntactic parse tree,

and arbitrarily-scoped syntactic features—such as
the “path” between predicate and argument, pro-
posed by Gildea and Jurafsky (2002)—for seman-
tic analysis. Such features are a mainstay of high-
performance semantic role labeling (SRL) sys-
tems (Roth and Woodsend, 2014; Lei et al., 2015;
FitzGerald et al., 2015; Foland and Martin, 2015),
but they are expensive to extract (Johansson, 2009;
He et al., 2013).

This study shows how recent advances in repre-
sentation learning can bypass those expensive fea-
tures, discovering cheap alternatives available dur-
ing a greedy parsing procedure. The speciﬁc ad-
vance we employ is the stack LSTM (Dyer et al.,
2015), a neural network that continuously summa-
rizes the contents of the stack data structures in
which a transition-based parser’s state is conven-
tionally encoded. Stack LSTMs were shown to ob-
viate many features used in syntactic dependency
parsing; here we ﬁnd them to do the same for joint
syntactic-semantic dependency parsing.

We believe this is an especially important ﬁnd-
ing for greedy models that cast parsing as a se-
quence of decisions made based on algorithmic
state, where linguistic theory and researcher intu-
itions offer less guidance in feature design.

Our system’s performance does not match that
of the top expert-crafted feature-based systems
(Zhao et al., 2009; Bj¨orkelund et al., 2010; Roth
and Woodsend, 2014; Lei et al., 2015), systems
which perform optimal decoding (T¨ackstr¨om et
al., 2015), or of systems that exploit additional,
differently-annotated datasets (FitzGerald et al.,
2015). Many advances in those systems are or-
thogonal to our model, and we expect future work
to achieve further gains by integrating them.

Because our system is very fast— with an
end-to-end runtime of 177.6±18 seconds to parse
the CoNLL 2009 English test data on a single
core—we believe it will be useful in practical set-

8
1
0
2
 
l
u
J
 
5
 
 
]
L
C
.
s
c
[
 
 
2
v
4
5
9
8
0
.
6
0
6
1
:
v
i
X
r
a

root

sbj

vc

oprd

im

tmp

all are expected to reopen soon

expect.01

reopen.01

A1

C-A1

A1

AM-TMP

Figure 1: Example of a joint parse. Syntactic de-
pendencies are shown by arcs above the sentence
and semantic dependencies below; predicates are
marked in boldface. C- denotes continuation of
argument A1. Correspondences between depen-
dencies might be close (between expected and to)
or not (between reopen and all).

tings. Our open-source implementation has been
released.1

2

Joint Syntactic and Semantic
Dependency Parsing

We largely follow the transition-based, synchro-
nized algorithm of Henderson et al. (2013) to pre-
dict joint parse structures. The input to the algo-
rithm is a sentence annotated with part-of-speech
tags. The output consists of a labeled syntactic de-
pendency tree and a directed SRL graph, in which
a subset of words in the sentence are selected as
predicates, disambiguated to a sense, and linked
by labeled, directed edges to their semantic argu-
ments. Figure 1 shows an example.

2.1 Transition-Based Procedure

The two parses are constructed in a bottom-up
fashion,
incrementally processing words in the
sentence from left to right. The state of the pars-
ing algorithm at timestep t is represented by three
stack data structures: a syntactic stack St, a se-
mantic stack Mt—each containing partially built
structures—and a buffer of input words Bt. Our
algorithm also places partial syntactic and seman-
tic parse structures onto the front of the buffer,
so it is also implemented as a stack. Each arc in
the output corresponds to a transition (or “action”)
chosen based on the current state; every transition
modiﬁes the state by updating St, Mt, and Bt to
St+1, Mt+1, and Bt+1, respectively. While each
state may license several valid actions, each action

1https://github.com/clab/

joint-lstm-parser

has a deterministic effect on the state of the algo-
rithm.

Initially, S0 and M0 are empty, and B0 contains
the input sentence with the ﬁrst word at the front
of B and a special root symbol at the end.2 Execu-
tion ends on iteration t such that Bt is empty and
St and Mt contain only a single structure headed
by root.

2.2 Transitions for Joint Parsing

There are separate sets of syntactic and semantic
transitions; the former manipulate S and B, the
latter M and B. All are formally deﬁned in Ta-
ble 1. The syntactic transitions are from the “arc-
eager” algorithm of Nivre (2008). They include:

• S-SHIFT, which copies3 an item from the front

of B and pushes it on S.

• S-REDUCE pops an item from S.
• S-RIGHT((cid:96)) creates a syntactic dependency.
Let u be the element at the top of S and v be
the element at the front of B. The new depen-
dency has u as head, v as dependent, and label
(cid:96). u is popped off S, and the resulting structure,
rooted at u, is pushed on S. Finally, v is copied
to the top of S.

• S-LEFT((cid:96)) creates a syntactic dependency with
label (cid:96) in the reverse direction as S-RIGHT. The
top of S, u, is popped. The front of B, v, is
replaced by the new structure, rooted at v.

The semantic transitions are similar, operating

on the semantic stack.

• M-SHIFT removes an item from the front of B

and pushes it on M .

• M-REDUCE pops an item from M .
• M-RIGHT(r) creates a semantic dependency.
Let u be the element at the top of M and v,
the front of B. The new dependency has u as
head, v as dependent, and label r. u is popped
off M , and the resulting structure, rooted at u,
is pushed on M .

• M-LEFT(r) creates a semantic dependency
with label r in the reverse direction as M-
RIGHT. The buffer front, v, is replaced by the
new v-rooted structure. M remains unchanged.

2This works better for the arc-eager algorithm (Balles-
teros and Nivre, 2013), in contrast to Henderson et al. (2013),
who initialized with root at the buffer front.

3Note that in the original arc-eager algorithm (Nivre,
2008), SHIFT and RIGHT-ARC actions move the item on the
buffer front to the stack, whereas we only copy it (to allow
the semantic operations to have access to it).

ﬁed and the algorithm returns to syntactic transi-
tions. This implies that, for each word, its left-
side syntactic dependencies are resolved before its
left-side semantic dependencies. An example run
of the algorithm is shown in Figure 3.

2.3 Constraints on Transitions

To ensure that the parser never enters an invalid
state, the sequence of transitions is constrained,
following Henderson et al. (2013). Actions that
copy or move items from the buffer (S-SHIFT,
S-RIGHT and M-SHIFT) are forbidden when the
buffer is empty. Actions that pop from a stack
(S-REDUCE and M-REDUCE) are forbidden when
that stack is empty. We disallow actions corre-
sponding to the same dependency, or the same
predicate to be repeated in the sequence. Repet-
itive M-SWAP transitions are disallowed to avoid
inﬁnite swapping. Finally, as noted above, we re-
strict the parser to syntactic actions until it needs
to shift an item from B to S, after which it can
only execute semantic actions until it executes an
M-SHIFT.

Asymptotic runtime complexity of this greedy
algorithm is linear in the length of the input, fol-
lowing the analysis by Nivre (2009).5

3 Statistical Model

The transitions in §2 describe the execution paths
our algorithm can take; like past work, we apply
a statistical classiﬁer to decide which transition to
take at each timestep, given the current state. The
novelty of our model is that it learns a ﬁnite-length
vector representation of the entire joint parser’s
state (S, M , and B) in order to make this decision.

3.1 Stack Long Short-Term Memory (LSTM)

LSTMs are recurrent neural networks equipped
with specialized memory components in addition
to a hidden state (Hochreiter and Schmidhuber,
1997; Graves, 2013) to model sequences. Stack
LSTMs (Dyer et al., 2015) are LSTMs that al-
low for stack operations: query, push, and pop.
A “stack pointer” is maintained which determines
which cell in the LSTM provides the memory and
hidden units when computing the new memory
cell contents. Query provides a summary of the
stack in a single ﬁxed-length vector. Push adds

semantic transitions, hence we only copy it.

5The analysis in (Nivre, 2009) does not consider SWAP
actions. However, since we constrain the number of such ac-
tions, the linear time complexity of the algorithm stays intact.

Figure 2: Example of an SRL graph with an arc
from predicate problem.01 to itself, ﬁlling the A2
role. Our SELF(A2) transition allows recovering
this semantic dependency.

Because SRL graphs allow a node to be a se-
mantic argument of two parents—like all in the
example in Figure 1—M-LEFT and M-RIGHT
do not remove the dependent from the semantic
stack and buffer respectively, unlike their syntactic
equivalents, S-LEFT and S-RIGHT. We use two
other semantic transitions from Henderson et al.
(2013) which have no syntactic analogues:

• M-SWAP swaps the top two items on M , to al-

low for crossing semantic arcs.

• M-PRED(p) marks the item at the front of B
as a semantic predicate with the sense p, and
replaces it with the disambiguated predicate.

The CoNLL 2009 corpus introduces semantic
self-dependencies where many nominal predicates
(from NomBank) are marked as their own argu-
ments; these account for 6.68% of all semantic
arcs in the English corpus. An example involving
an eventive noun is shown in Figure 2. We intro-
duce a new semantic transition, not in Henderson
et al. (2013), to handle such cases:

• M-SELF(r) adds a dependency, with label r be-
tween the item at the front of B and itself. The
result replaces the item at the front of B.

Note that the syntactic and semantic transitions
both operate on the same buffer, though they in-
dependently specify the syntax and semantics, re-
spectively. In order to ensure that both syntactic
and semantic parses are produced, the syntactic
and semantic transitions are interleaved. Only syn-
tactic transitions are considered until a transition is
chosen that copies an item from the buffer front to
the syntactic stack (either S-SHIFT or S-RIGHT).
The algorithm then switches to semantic transi-
tions until a buffer-modifying transition is taken
(M-SHIFT).4 At this point, the buffer is modi-

4Had we moved the item at the buffer front during the
syntactic transitions, it would have been unavailable for the

St
S
(u, u), S

(u, u), S

(u, u), S
S
S
S
S
S
S
S

Mt
M
M

M

Bt
(v, v), B
B

Action
S-SHIFT
S-REDUCE

St+1
(v, v), S
S

(v, v), B

S-RIGHT((cid:96))

(v, v), (gs(u, v, l), u), S

M
M
(u, u), M
(u, u), M
(u, u), M
(u, u), (v, v), M
M
M

(v, v), B
(v, v), B
B
(v, v), B
(v, v), B
B
(v, v), B
(v, v), B

S-LEFT((cid:96))
M-SHIFT
M-REDUCE
M-RIGHT(r)
M-LEFT(r)
M-SWAP
M-PRED(p)
M-SELF(r)

S
S
S
S
S
S
S
S

M

(v, v), B

Mt+1
M
M

M (gs(v, u, l), v), B

Bt+1
(v, v), B
B

Dependency
—
—
S ∪ u (cid:96)→ v
S ∪ u (cid:96)← v
B
—
B
—
M ∪ u r→ v
(v, v), B
(u, u), M (gm(v, u, r), v), B M ∪ u r← v
B
(gd(v, p), v), B

(v, v), (u, u), M
M
M (gm(v, v, r), v), B M ∪ v r↔ v

(v, v), M
M
(gm(u, v, r), u), M

—
—

Table 1: Parser transitions along with the modiﬁcations to the stacks and the buffer resulting from each.
Syntactic transitions are shown above, semantic below. Italic symbols denote symbolic representations
of words and relations, and bold symbols indicate (learned) embeddings (§3.5) of words and relations;
each element in a stack or buffer includes both symbolic and vector representations, either atomic or
recursive. S represents the set of syntactic transitions, and M the set of semantic transitions.

an element to the top of the stack, resulting in a
new summary. Pop, which does not correspond to
a conventional LSTM operation, moves the stack
pointer to the preceding timestep, resulting in a
stack summary as it was before the popped item
was observed. Implementation details (Dyer et al.,
2015; Goldberg, 2015) and code have been made
publicly available.6

Using stack LSTMs, we construct a represen-
tation of the algorithm state by decomposing it
into smaller pieces that are combined by recursive
function evaluations (similar to the way a list is
built by a concatenate operation that operates on a
list and an element). This enables information that
would be distant from the “top” of the stack to be
carried forward, potentially helping the learner.

3.2 Stack LSTMs for Joint Parsing

four

Our algorithm employs
stack LSTMs,
one each for the S, M , and B data struc-
tures.Like Dyer et al. (2015), we use a fourth stack
LSTM, A, for the history of actions—A is never
popped from, only pushed to. Figure 4 illustrates
the architecture. The algorithm’s state at timestep
t is encoded by the four vectors summarizing the
four stack LSTMs, and this is the input to the clas-
siﬁer that chooses among the allowable transitions
at that timestep.

Let st, mt, bt, and at denote the summaries
of St, Mt, Bt, and At, respectively. Let At =
Allowed(St, Mt, Bt, At) denote the allowed tran-
sitions given the current stacks and buffer. The
parser state at time t is given by a rectiﬁed linear
unit (Nair and Hinton, 2010) in vector yt:

where W and d are the parameters of the classi-
ﬁer. The transition selected at timestep t is

arg max
τ ∈At
≡ arg max
τ ∈At

qτ + θτ · yt

(1)

score(τ ; St, Mt, Bt, At)

where θτ and qτ are parameters for each transi-
tion type τ . Note that only allowed transitions are
considered in the decision rule (see §2.3).

3.3 Composition Functions

To use stack LSTMs, we require vector representa-
tions of the elements that are stored in the stacks.
Speciﬁcally, we require vector representations of
atoms (words, possibly with part-of-speech tags)
and parse fragments. Word vectors can be pre-
trained or learned directly; we consider a concate-
nation of both in our experiments; part-of-speech
vectors are learned and concatenated to the same.
To obtain vector representations of parse frag-
ments, we use neural networks which recursively
compute representations of the complex structured
output (Dyer et al., 2015). The tree structures here
are always ternary trees, with each internal node’s
three children including a head, a dependent, and
a label. The vectors for leaves are word vectors
and vectors corresponding to syntactic and seman-
tic relation types.

The vector for an internal node is a squashed
(tanh) afﬁne transformation of its children’s vec-
tors. For syntactic and semantic attachments, re-
spectively, the composition function is:

yt = elementwisemax {0, d + W[st; mt; bt; at]}

6https://github.com/clab/lstm-parser

gs(v, u, l) = tanh(Zs[v; u; l] + es)
gm(v, u, r) = tanh(Zm[v; u; r] + em)

(2)

(3)

d
e
t
c
e
p
x
e

→
−
e
r
a

c
v

1
0
.
t
c
e
p
x
e
−
1
←
A

d
r
p
o

o
t

→
−
d
e
t
c
e
p
x
e

o
t

-

1
→
A
−
C
1
0
.
t
c
e
p
x
e

n
e
p
o
e
r

i

→
m
−
o
t

1
0
.
n
e
p
o
e
r

−
1
←
A

e
r
a
−
←

j
b
s

n
o
o
s

P
M
→
T
−
-
M
A

1
0
.
n
e
p
o
e
r

n
o
o
s

t

→
p
m
−
n
e
p
o
e
r

t
o
o
r

t
o
o
r

−
←

e
r
a

—

—

—

l
l
a

—

—

—

—

l
l
a

—

—

—

—

—

l
l
a

—

—

—

—

—

—

—

—

—

—

—

y
c
n
e
d
n
e
p
e
D

B

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a

,
l
l
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a

,
l
l
a
[

,
o
t

,
o
t

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
o
t

,
d
e
t
c
e
p
x
e
[

,
d
e
t
c
e
p
x
e
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
l
l
a
[

]
l
l
a
[

]
e
r
a
[

]
e
r
a
[

]
[

S

]
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

)
1
0
.
t
c
e
p
x
e
(
D
E
R
P
-
M

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
d
e
t
c
e
p
x
e

,
l
l
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
d
e
t
c
e
p
x
e

,
l
l
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
d
e
t
c
e
p
x
e

,
l
l
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
d
r
p
o
(
T
H
G

I

R

-
S
*
*
*

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
[

]
[

]
n
o
o
s

,
n
e
p
o
e
r

]
n
o
o
s

,
n
e
p
o
e
r

]
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
o
t

,
o
t

,
o
t

,
o
t

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
n
e
p
o
e
r
[

]
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
p
m

t
(
T
H
G

I

R

-
S

]
n
e
p
o
e
r
[

]
n
o
o
s

,
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
P
M
T
-
M
A
(
T
H
G

I

-

R
M

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

,
o
t

,
o
t

,
o
t

,
o
t

,
o
t

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
1
A
-
C

(
T
H
G

I

-

R
M

E
C
U
D
E
R
M

-

T
F
I

H
S
-
M

)

m

i
(
T
H
G

I

R

-
S

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
1
0
.
n
e
p
o
e
r
(
D
E
R
P
-
M

]
e
r
a
[

]
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

M

]
[

]
[

]
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
e
r
a

,
l
l
a
[

]
e
r
a

,
l
l
a
[

]
e
r
a

,
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
o
t

,
l
l
a
[

]
o
t

,
l
l
a
[

]
o
t

,
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
[

]
n
e
p
o
e
r
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
t
o
o
r
[

]
[

)
j
b
s
(
T
F
E
L
-
S

T
F
I

H
S
-
S

T
F
I

H
S
-
M

)
c
v
(
T
H
G

I

R

-
S

T
F
I

H
S
-
S

T
F
I

H
S
-
M

E
C
U
D
E
R
M

-

)
1
A
(
T
F
E
L
-
M

T
F
I

H
S
-
M

n
o
i
t
i
s
n
a
r
T

E
C
U
D
E
R
M

-

)
1
A
(
T
F
E
L
-
M

E
C
U
D
E
R
M

-

T
F
I

H
S
-
M

E
C
U
D
E
R
M

-

E
C
U
D
E
R

-
S

E
C
U
D
E
R

-
S

E
C
U
D
E
R

-
S

E
C
U
D
E
R

-
S

T
F
I

H
S
-
M

)
t
o
o
r
(
T
F
E
L
-
S

E
C
U
D
E
R
M

-

T
F
I

H
S
-
M

T
F
I

H
S
-
S

Figure 3: Joint parser transition sequence for the sentence in Figure 1, “all are expected to reopen soon.”
Syntactic labels are in lower-case and semantic role labels are capitalized. *** marks the operation
predicted in Figure 4.

where v and u are vectors corresponding to atomic
words or composed parse fragments; l and r are
learned vector representations for syntactic and se-
mantic labels respectively. Syntactic and semantic
parameters are separated (Zs, es and Zm, em, re-
spectively).

Finally, for predicates, we use another recur-
sive function to compose the word representa-

tion, v with a learned representation for the dis-
mabiguated sense of the predicate, p:

gd(v, p) = tanh(Zd[v; p] + ed)

(4)

where Zd and ed are parameters of the model.
Note that, because syntactic and semantic transi-
tions are interleaved, the fragmented structures are
a blend of syntactic and semantic compositions.

Figure 4: Stack LSTM for joint parsing. The state
illustrated corresponds to the ***-marked row in
the example transition sequence in Fig. 3.

Figure 5 shows an example.

3.4 Training

Training the classiﬁer requires transforming each
training instance (a joint parse) into a transition se-
quence, a deterministic operation under our tran-
sition set. Given a collection of algorithm states
at time t and correct classiﬁcation decisions τt, we
minimize the sum of log-loss terms, given (for one
timestep) by:

− log

(cid:80)

exp(qτt + θτt · yt)

τ (cid:48)∈At

exp(qτ (cid:48) + θτ (cid:48) · yt)

(5)

with respect to the classiﬁer and LSTM parame-
ters. Note that the loss is differentiable with re-
spect to the parameters; gradients are calculated
using backpropagation. We apply stochastic gra-
dient descent with dropout for all neural network
parameters.

3.5 Pretrained Embeddings

Following Dyer et al. (2015), “structured skip-
gram” embeddings (Ling et al., 2015) were used,
trained on the English (AFP section), German,
Spanish and Chinese Gigaword corpora, with a
window of size 5; training was stopped after 5
epochs. For out-of-vocabulary words, a randomly
initialized vector of the same dimension was used.

3.6 Predicate Sense Disambiguation

Figure 5: Example of a joint parse tree fragment
with vector representations shown at each node.
The vectors are obtained by recursive composition
of representations of head, dependent, and label
vectors. Syntactic dependencies and labels are in
green, semantic in blue.

are lexeme-speciﬁc, we need a way to handle un-
seen predicates at test time. When a predicate is
encountered at test time that was not observed in
training, our system constructs a predicate from
the predicted lemma of the word at that position
and defaults to the “01” sense, which is correct
for 91.22% of predicates by type in the English
CoNLL 2009 training data.

4 Experimental Setup

Our model is evaluated on the CoNLL shared
tasks on joint syntactic and semantic dependency
parsing in 2008 (Surdeanu et al., 2008) and
2009 (Hajiˇc et al., 2009). The standard training,
development and test splits of all datasets were
used. Per the shared task guidelines, automati-
cally predicted POS tags and lemmas provided in
the datasets were used for all experiments. As
a preprocessing step, pseudo-projectivization of
the syntactic trees (Nivre et al., 2007) was used,
which allowed an accurate conversion of even the
non-projective syntactic trees into syntactic transi-
tions. However, the oracle conversion of semantic
parses into transitions is not perfect despite using
the M-SWAP action, due to the presence of multi-
ple crossing arcs.7

The standard evaluation metrics include the
syntactic labeled attachment score (LAS), the se-

Predicate sense disambiguation is handled within
the model (M-PRED transitions), but since senses

7For 1.5% of English sentences in the CoNLL 2009 En-
glish dataset, the transition sequence incorrectly encodes the
gold-standard joint parse; details in Henderson et al. (2013).

mantic F1 score on both in-domain (WSJ) and out-
of-domain (Brown corpus) data, and their macro
average (Macro F1) to score joint systems. Be-
cause the task was deﬁned somewhat differently
in each year, each dataset is considered in turn.

4.1 CoNLL 2008

The CoNLL 2008 dataset contains annotations
from the Penn Treebank (Marcus et al., 1993),
PropBank (Palmer et al., 2005) and Nom-
Bank (Meyers et al., 2004). The shared task evalu-
ated systems on predicate identiﬁcation in addition
to predicate sense disambiguation and SRL.

To identify predicates, we trained a zero-
Markov order bidirectional LSTM two-class clas-
siﬁer. As input to the classiﬁer, we use learned rep-
resentations of word lemmas and POS tags. This
model achieves an F1 score of 91.43% on marking
words as predicates (or not).

Hyperparameters The input representation for
a word consists of pretrained embeddings (size
100 for English, 80 for Chinese, 64 for Ger-
man and Spanish), concatenated with additional
learned word and POS tag embeddings (size 32
and 12, respectively). Learned embeddings for
syntactic and semantic arc labels are of size 20
and predicates 100. Two-layer LSTMs with hid-
den state dimension 100 were used for each of the
four stacks. The parser state yt and the composi-
tion function g are of dimension 100. A dropout
rate of 0.2 (Zaremba et al., 2014) was used on all
layers at training time, tuned on the development
data from the set of values {0.1, 0.2, 0.3, 1.0}. The
learned representations for actions are of size 100,
similarly tuned from {10, 20, 30, 40, 100}. Other
hyperparameters have been set intuitively; careful
tuning is expected to yield improvements (Weiss
et al., 2015).

An initial learning rate of 0.1 for stochastic gra-
dient descent was used and updated in every train-
ing epoch with a decay rate of 0.1 (Dyer et al.,
2015). Training is stopped when the development
performance does not improve for approximately
6–7 hours of elapsed time. Experiments were run
on a single thread on a CPU, with memory require-
ments of up to 512 MB.

4.2 CoNLL 2009

Relative to the CoNLL 2008 task (above), the
main change in 2009 is that predicates are pre-
identiﬁed, and systems are only evaluated on pred-

icate sense disambiguation (not
identiﬁcation).
Hence, the bidirectional LSTM classiﬁer is not
used here. The preprocessing for projectivity, and
the hyperparameter selection is the same as in
§4.1.

In addition to the joint approach described in
the preceding sections, we experiment here with
several variants:

Semantics-only:
the set of syntactic transitions
S, the syntactic stack S, and the syntactic compo-
sition function gs are discarded. As a result, the set
of constraints on transitions is a subset of the full
set of constraints in §2.3. Effectively, this model
does not use any syntactic features, similar to Col-
lobert et al. (2011) and Zhou and Xu (2015). It
provides a controlled test of the beneﬁt of explicit
syntax in a semantic parser.

all semantic transitions in M, the
Syntax-only:
semantic stack M , and the semantic composition
function gm are discarded. S-SHIFT and S-RIGHT
now move the item from the front of the buffer to
the syntactic stack, instead of copying. The set of
constraints on the transitions is again a subset of
the full set of constraints. This model is an arc-
eager variant of Dyer et al. (2015), and serves to
check whether semantic parsing degrades syntac-
tic performance.

Hybrid:
the semantics parameters are trained
using automatically predicted syntax from the
syntax-only model. At test time, only seman-
tic parses are predicted. This setup bears simi-
larity to other approaches which pipeline syntax
and semantics, extracting features from the syn-
tactic parse to help SRL. However, unlike other
approaches, this model does not offer the entire
syntactic tree for feature extraction, since only the
partial syntactic structures present on the syntactic
stack (and potentially the buffer) are visible at a
given timestep. This model helps show the effect
of joint prediction.

5 Results and Discussion

CoNLL 2008 (Table 2) Our joint model signif-
icantly outperforms the joint model of Hender-
son et al. (2008), from which our set of tran-
sitions is derived, showing the beneﬁt of learn-
ing a representation for the entire algorithmic
state. Several other joint learning models have
been proposed (Llu´ıs and M`arquez, 2008; Jo-
hansson, 2009; Titov et al., 2009) for the same

Model

joint models:
Llu´ıs and M`arquez (2008)
Henderson et al. (2008)
Johansson (2009)
Titov et al. (2009)
CoNLL 2008 best:
#3: Zhao and Kit (2008)
#2: Che et al. (2008)
#2: Ciaramita et al. (2008)
#1: J&N (2008)
Joint (this work)

LAS

Sem. Macro
F1

F1

85.8
87.6
86.6
87.5

87.7
86.7
87.4
89.3
89.1

70.3
73.1
77.1
76.1

76.7
78.5
78.0
81.6
80.5

78.1
80.5
81.8
81.8

82.2
82.7
82.7
85.5
84.9

Table 2: Joint parsers: comparison on the CoNLL
2008 test (WSJ+Brown) set.

task; our joint model surpasses the performance
of all these models. The best reported systems on
the CoNLL 2008 task are due to Johansson and
Nugues (2008), Che et al. (2008), Ciaramita et
al. (2008) and Zhao and Kit (2008), all of which
pipeline syntax and semantics; our system’s se-
mantic and overall performance is comparable to
these. We fall behind only Johansson and Nugues
(2008), whose success was attributed to carefully
designed global SRL features integrated into a
pipeline of classiﬁers, making them asymptoti-
cally slower.

CoNLL 2009 English (Table 3) All of our
models (Syntax-only, Semantics-only, Hybrid and
Joint) improve over Gesmundo et al.
(2009)
and Henderson et al. (2013), demonstrating the
beneﬁt of our entire-parser-state representation
learner compared to the more locally scoped
model.

Given that syntax has consistently proven useful
in SRL, we expected our Semantics-only model
to underperform Hybrid and Joint, and it did. In
the training domain, syntax and semantics bene-
ﬁt each other (Joint outperforms Hybrid). Out-
of-domain (the Brown test set), the Hybrid pulls
ahead, a sign that Joint overﬁts to WSJ. As a
syntactic parser, our Syntax-only model performs
slightly better than Dyer et al. (2015), who achieve
89.56 LAS on this task.
Joint parsing is very
slightly better still.

The overall performance of Joint is on par with
the other winning participants at the CoNLL 2009
shared task (Zhao et al., 2009; Che et al., 2009;
Gesmundo et al., 2009), falling behind only Zhao
et al. (2009), who carefully designed language-

speciﬁc features and used a series of pipelines for
the joint task, resulting in an accurate but compu-
tationally expensive system.

State-of-the-art SRL systems (shown in the last
block of Table 3) which use advances orthog-
onal to the contributions in this paper, perform
better than our models. Many of these systems
use expert-crafted features derived from full syn-
tactic parses in a pipeline of classiﬁers followed
by a global reranker (Bj¨orkelund et al., 2009;
Bj¨orkelund et al., 2010; Roth and Woodsend,
2014); we have not used these features or rerank-
ing. Lei et al. (2015) use syntactic parses to obtain
interaction features between predicates and their
arguments and then compress feature representa-
tions using a low-rank tensor. T¨ackstr¨om et al.
(2015) present an exact inference algorithm for
SRL based on dynamic programming and their lo-
cal and structured models make use of many syn-
tactic features from a pipeline; our search pro-
cedure is greedy. Their algorithm is adopted
by FitzGerald et al. (2015) for inference in a model
that jointly learns representations from a combina-
tion of PropBank and FrameNet annotations; we
have not experimented with extra annotations.

Our system achieves an end-to-end runtime of
177.6±18 seconds to parse the CoNLL 2009 En-
glish test set on a single core. This is almost 2.5
times faster than the pipeline model of Lei et al.
(2015) (439.9±42 seconds) on the same machine.8

CoNLL 2009 Multilingual (Table 4) We tested
the joint model on the non-English CoNLL 2009
datasets, and the results demonstrate that it adapts
easily—it is on par with the top three systems in
most cases. We note that our Chinese parser relies
on pretrained word embeddings for its superior
performance; without them (not shown), it was on
par with the others. Japanese is a small-data case
(4,393 training examples), illustrating our model’s
dependence on reasonably large training datasets.
We have not extended our model to incorporate
morphological features, which are used by the sys-
tems to which we compare. Future work might in-
corporate morphological features where available;
this could potentially improve performance, espe-
cially in highly inﬂective languages like Czech.
An alternative might be to infer word-internal rep-
resentations using character-based word embed-

8See

SRLParser; unlike other state-of-the-art systems,
one is publicly available.

https://github.com/taolei87/
this

Model

LAS

Sem. F1
(WSJ)

Sem. F1
(Brown)

Macro
F1

88.79
88.48
89.19

89.83

89.83
89.94

CoNLL’09 best:
#3 G+ ’09
#2 C+ ’09
#1 Z+ ’09a
this work:
Syntax-only
Sem.-only
Hybrid
Joint
pipelines:
R&W ’14
L+ ’15
T+ ’15
F+ ’15

83.24
85.51
86.15

84.39
84.58
84.97

86.34
86.58
87.30
87.80

70.65
73.82
74.58

86.03
87.00
87.69

87.20
87.45

73.87
75.64
74.48

75.90
75.57
75.50
75.50

Table 3: Comparison on the CoNLL 2009 English
test set. The ﬁrst block presents results of other
models evaluated for both syntax and semantics on
the CoNLL 2009 task. The second block presents
our models. The third block presents the best pub-
lished models, each using its own syntactic pre-
processing.

dings, which was found beneﬁcial for syntactic
parsing (Ballesteros et al., 2015).

Language
Catalan
Chinese
Czech
English
German
Japanese
Spanish
Average

#1 C+’09
81.84
76.38
83.27
87.00
82.44
85.65
81.90
82.64

#2 Z+ ’09a
83.01
76.23
80.87
87.69
81.22
85.28
83.31
82.52

#3 G+ ’09
82.66
76.15
83.21
86.03
79.59
84.91
82.43
82.14

Joint
82.40
79.27
79.53
87.45
81.05
80.91
83.11
81.96

Table 4: Comparison of macro F1 scores on the
multilingual CoNLL 2009 test set.

6 Related Work

Other approaches to joint modeling, not consid-
ered in our experiments, are notable. Llu´ıs et al.
(2013) propose a graph-based joint model using
dual decomposition for agreement between syn-
tax and semantics, but do not achieve competi-
tive performance on the CoNLL 2009 task. Lewis
et al. (2015) proposed an efﬁcient joint model for
CCG syntax and SRL, which performs better than
a pipelined model. However, their training neces-
sitates CCG annotation, ours does not. Moreover,
their evaluation metric rewards semantic depen-
dencies regardless of where they attach within the
argument span given by a PropBank constituent,

making direct comparison to our evaluation infea-
sible. Krishnamurthy and Mitchell (2014) pro-
pose a joint CCG parsing and relation extraction
model which improves over pipelines, but their
task is different from ours. Li et al. (2010) also
perform joint syntactic and semantic dependency
parsing for Chinese, but do not report results on
the CoNLL 2009 dataset.

There has also been an increased interest in
models which use neural networks for SRL. Col-
lobert et al. (2011) proposed models which per-
form many NLP tasks without hand-crafted fea-
tures. Though they did not achieve the best results
on the constituent-based SRL task (Carreras and
M`arquez, 2005), their approach inspired Zhou and
Xu (2015), who achieved state-of-the-art results
using deep bidirectional LSTMs. Our approach
for dependency-based SRL is not directly compa-
rable.

7 Conclusion

We presented an incremental, greedy parser for
joint syntactic and semantic dependency parsing.
Our model surpasses the performance of previous
joint models on the CoNLL 2008 and 2009 En-
glish tasks, without using expert-crafted, expen-
sive features of the full syntactic parse.

Acknowledgments

The authors thank Sam Thomson, Lingpeng Kong,
Mark Yatskar, Eunsol Choi, George Mulcaire, and
Luheng He, as well as the anonymous review-
ers, for many useful comments. This research
was supported in part by DARPA grant FA8750-
12-2-0342 funded under the DEFT program and
by the U.S. Army Research Ofﬁce under grant
number W911NF-10-1-0533. Any opinion, ﬁnd-
ings, and conclusions or recommendations ex-
pressed in this material are those of the author(s)
and do not necessarily reﬂect the view of the
U.S. Army Research Ofﬁce or the U.S. Govern-
ment. Miguel Ballesteros was supported by the
European Commission under the contract num-
bers FP7-ICT-610411 (project MULTISENSOR)
and H2020-RIA-645012 (project KRISTINA).

References

[Ballesteros and Nivre2013] Miguel Ballesteros

and
Joakim Nivre. 2013. Going to the roots of de-
Computational Linguistics,
pendency parsing.
39(1):5–13.

[Ballesteros et al.2015] Miguel Ballesteros, Chris Dyer,
Improved transition-
and Noah A. Smith. 2015.
based parsing by modeling characters instead of
words with LSTMs. In Proc. of EMNLP.

[Bj¨orkelund et al.2009] Anders Bj¨orkelund,

Love
Hafdell, and Pierre Nugues. 2009. Multilingual
semantic role labeling. In Proc. of CoNLL.

[Bj¨orkelund et al.2010] Anders Bj¨orkelund,

Bernd
Bohnet, Love Hafdell, and Pierre Nugues. 2010.
A high-performance syntactic and semantic depen-
dency parser. In Proc. of COLING.

[Carreras and M`arquez2005] Xavier Carreras and Llu´ıs
Introduction to the CoNLL-2005
In Proc. of

M`arquez. 2005.
shared task: Semantic role labeling.
CoNLL.

[Che et al.2008] Wanxiang Che, Zhenghua Li, Yuxuan
Hu, Yongqiang Li, Bing Qin, Ting Liu, and Sheng
Li. 2008. A cascaded syntactic and semantic de-
pendency parsing system. In Proc. of CoNLL.

[Che et al.2009] Wanxiang

Li,
Zhenghua
and
Yongqiang Li, Yuhang Guo, Bing Qin,
Ting Liu. 2009. Multilingual dependency-based
syntactic and semantic parsing. In Proc. of CoNLL.

Che,

[Ciaramita et al.2008] Massimiliano

Ciaramita,
Giuseppe Attardi, Felice Dell’Orletta, and Mi-
hai Surdeanu.
DeSRL: A linear-time
semantic role labeling system. In Proc. of CoNLL.

2008.

[Collobert et al.2011] Ronan Collobert, Jason Weston,
L´eon Bottou, Michael Karlen, Koray Kavukcuoglu,
and Pavel Kuksa.
2011. Natural language pro-
cessing (almost) from scratch. Journal of Machine
Learning Research, 12:2493–2537.

[Dyer et al.2015] Chris Dyer, Miguel Ballesteros,
Wang Ling, Austin Matthews, and Noah A. Smith.
2015. Transition-based dependency parsing with
stack long short-term memory. In Proc. of ACL.

[FitzGerald et al.2015] Nicholas FitzGerald, Oscar
T¨ackstr¨om, Kuzman Ganchev, and Dipanjan Das.
2015. Semantic role labelling with neural network
factors. In Proc. of EMNLP.

[Foland and Martin2015] William R. Foland and James
2015. Dependencybased semantic role
In

Martin.
labeling using convolutional neural networks.
Proc. of *SEM.

[Gesmundo et al.2009] Andrea Gesmundo, James Hen-
derson, Paola Merlo, and Ivan Titov. 2009. A latent
variable model of synchronous syntactic-semantic
parsing for multiple languages. In Proc. of CoNLL.

[Gildea and Jurafsky2002] Daniel Gildea and Daniel
Jurafsky. 2002. Automatic labeling of semantic
roles. Computational Linguistics, 28(3):245–288.

[Graves2013] Alex Graves.

Generat-
ing sequences with recurrent neural networks.
arXiv:1308.0850.

2013.

[Hajiˇc et al.2009] Jan Hajiˇc, Massimiliano Cia-
ramita, Richard Johansson, Daisuke Kawahara,
Maria Ant`onia Mart´ı, Llu´ıs M`arquez, Adam Mey-
ers, Joakim Nivre, Sebastian Pad´o, Jan ˇStˇep´anek,
Pavel Straˇn´ak, Mihai Surdeanu, Nianwen Xue, and
Yi Zhang. 2009. The CoNLL-2009 shared task:
Syntactic and semantic dependencies in multiple
languages. In Proc. of CoNLL.

[He et al.2013] He He, Hal Daum´e III, and Jason Eis-
ner. 2013. Dynamic feature selection for depen-
dency parsing. In Proc. of EMNLP.

[Henderson et al.2008] James Henderson, Paola Merlo,
Gabriele Musillo, and Ivan Titov. 2008. A latent
variable model of synchronous parsing for syntactic
and semantic dependencies. In Proc. of CoNLL.

[Henderson et al.2013] James Henderson, Paola Merlo,
Ivan Titov, and Gabriele Musillo. 2013. Multi-
lingual joint parsing of syntactic and semantic de-
pendencies with a latent variable model. Computa-
tional Linguistics, 39(4):949–998.

[Hochreiter and Schmidhuber1997] Sepp Hochreiter
and J¨urgen Schmidhuber. 1997. Long short-term
memory. Neural Computation, 9(8):1735–1780.

[Johansson and Nugues2008] Richard Johansson and
Pierre Nugues. 2008. Dependency-based syntactic-
semantic analysis with PropBank and NomBank. In
Proc. of CoNLL.

[Johansson2009] Richard Johansson. 2009. Statistical
bistratal dependency parsing. In Proc. of EMNLP.

[Krishnamurthy and Mitchell2014] Jayant

Krishna-
murthy and Tom M. Mitchell. 2014. Joint syntactic
and semantic parsing with combinatory categorial
grammar. In Proc. of ACL.

[Lei et al.2015] Tao Lei, Yuan Zhang, Llu´ıs M`arquez
i Villodre, Alessandro Moschitti, and Regina Barzi-
lay. 2015. High-order low-rank tensors for semantic
role labeling. In Proc. of NAACL.

[Lewis et al.2015] Mike Lewis, Luheng He, and Luke
Zettlemoyer. 2015. Joint A* CCG parsing and se-
mantic role labelling. In Proc. of EMNLP.

[Li et al.2010] Junhui Li, Guodong Zhou,

Hwee Tou Ng.
2010.
mantic parsing of Chinese. In Proc. of ACL.

and
Joint syntactic and se-

[Ling et al.2015] Wang Ling, Chris Dyer, Alan Black,
and Isabel Trancoso. 2015. Two/too simple adapta-
tions of word2vec for syntax problems. In Proc. of
NAACL.

[Goldberg2015] Yoav Goldberg. 2015. A primer on
neural network models for natural language process-
ing. arXiv:1510.00726.

[Llu´ıs and M`arquez2008] Xavier Llu´ıs

and Llu´ıs
M`arquez. 2008. A joint model for parsing syntactic
and semantic dependencies. In Proc. of CoNLL.

[Llu´ıs et al.2013] Xavier Llu´ıs, Xavier Carreras, and
Llu´ıs M`arquez. 2013. Joint arc-factored parsing of
syntactic and semantic dependencies. Transactions
of the ACL, 1:219–230.

[Toutanova et al.2008] Kristina

Aria
Toutanova,
2008.
Haghighi, and Christopher D. Manning.
A global joint model for semantic role labeling.
Computational Linguistics, 34(2):161–191.

[Weiss et al.2015] David Weiss, Chris Alberti, Michael
Collins, and Slav Petrov. 2015. Structured train-
ing for neural network transition-based parsing. In
Proc. of ACL.

[Zaremba et al.2014] Wojciech

Sutskever, and Oriol Vinyals.
neural network regularization. arXiv:1409.2329.

Ilya
Zaremba,
2014. Recurrent

[Zhao and Kit2008] Hai Zhao and Chunyu Kit. 2008.
Parsing syntactic and semantic dependencies with
two single-stage maximum entropy models. In Proc.
of CoNLL.

[Zhao et al.2009] Hai Zhao, Wenliang Chen, Jun’ichi
Kazama, Kiyotaka Uchimoto, and Kentaro Tori-
sawa. 2009. Multilingual dependency learning: Ex-
ploiting rich features for tagging syntactic and se-
mantic dependencies. In Proc. of CoNLL.

[Zhou and Xu2015] Jie Zhou and Wei Xu. 2015. End-
to-end learning of semantic role labeling using re-
current neural networks. In Proc. of ACL.

[Marcus et al.1993] Mitchell P. Marcus, Mary Ann
1993.
Marcinkiewicz, and Beatrice Santorini.
Building a large annotated corpus of English:
The Penn treebank. Computational Linguistics,
19(2):313–330.

[Meyers et al.2004] Adam Meyers, Ruth Reeves,
Catherine Macleod, Rachel Szekely, Veronika
Zielinska, Brian Young, and Ralph Grishman. 2004.
The NomBank project: An interim report. In Proc.
of NAACL.

[Nair and Hinton2010] Vinod Nair and Geoffrey E.
Hinton. 2010. Rectiﬁed linear units improve re-
stricted Boltzmann machines. In Proc. of ICML.

[Nivre et al.2007] Joakim Nivre, Johan Hall, Jens Nils-
son, Atanas Chanev, G¨ulsen Eryigit, Sandra K¨ubler,
Svetoslav Marinov, and Erwin Marsi. 2007. Malt-
Parser: A language-independent system for data-
driven dependency parsing. Natural Language En-
gineering, 13:95–135.

[Nivre2008] Joakim Nivre. 2008. Algorithms for de-
terministic incremental dependency parsing. Com-
putational Linguistics, 34(4):513–553.

[Nivre2009] Joakim Nivre. 2009. Non-projective de-
pendency parsing in expected linear time. In Proc.
of ACL.

[Palmer et al.2005] Martha Palmer, Daniel Gildea, and
Paul Kingsbury. 2005. The Proposition Bank: An
annotated corpus of semantic roles. Computational
Linguistics, 31(1):71–106.

[Roth and Woodsend2014] Michael Roth and Kristian
Woodsend. 2014. Composition of word represen-
tations improves semantic role labelling. In Proc. of
EMNLP.

[Surdeanu et al.2008] Mihai Surdeanu, Richard Johans-
son, Adam Meyers, Llu´ıs M`arquez, and Joakim
Nivre. 2008. The CoNLL-2008 shared task on joint
parsing of syntactic and semantic dependencies. In
Proc. of CoNLL.

[Sutton and McCallum2005] Charles Sutton and An-
drew McCallum. 2005. Joint parsing and semantic
role labeling. In Proc. of CoNLL.

[T¨ackstr¨om et al.2015] Oscar T¨ackstr¨om, Kuzman
Efﬁcient
Ganchev, and Dipanjan Das.
inference and structured learning for semantic role
labeling. Transactions of the ACL, 3:29–41.

2015.

[Titov et al.2009] Ivan Titov, James Henderson, Paola
Merlo, and Gabriele Musillo. 2009. Online graph
planarisation for synchronous parsing of semantic
and syntactic dependencies. In Proc. of IJCAI.

Greedy, Joint Syntactic-Semantic Parsing with Stack LSTMs

Swabha Swayamdipta♣ Miguel Ballesteros♦ Chris Dyer♠ Noah A. Smith♥
♣School of Computer Science, Carnegie Mellon University, Pittsburgh, PA 15213, USA
♦Natural Language Processing Group, Universitat Pompeu Fabra, Barcelona, Spain
♠Google DeepMind, London, UK
♥Computer Science & Engineering, University of Washington, Seattle, WA 98195, USA
swabha@cs.cmu.edu, miguel.ballesteros@upf.edu,
cdyer@cs.cmu.edu, nasmith@cs.washington.edu

Abstract

We present a transition-based parser that
jointly produces syntactic and semantic
It learns a representation
dependencies.
of the entire algorithm state, using stack
long short-term memories. Our greedy in-
ference algorithm has linear time, includ-
ing feature extraction. On the CoNLL
2008–9 English shared tasks, we obtain
the best published parsing performance
among models that jointly learn syntax
and semantics.

1

Introduction

We introduce a new joint syntactic and semantic
dependency parser. Our parser draws from the
algorithmic insights of the incremental structure
building approach of Henderson et al. (2008), with
two key differences. First, it learns representations
for the parser’s entire algorithmic state, not just the
top items on the stack or the most recent parser
states; in fact, it uses no expert-crafted features at
all. Second, it uses entirely greedy inference rather
than beam search. We ﬁnd that it outperforms all
previous joint parsing models, including Hender-
son et al. (2008) and variants (Gesmundo et al.,
2009; Titov et al., 2009; Henderson et al., 2013) on
the CoNLL 2008 and 2009 (English) shared tasks.
Our parser’s multilingual results are comparable to
the top systems at CoNLL 2009.

Joint models like ours have frequently been pro-
posed as a way to avoid cascading errors in NLP
pipelines; varying degrees of success have been at-
tained for a range of joint syntactic-semantic anal-
ysis tasks (Sutton and McCallum, 2005; Hender-
son et al., 2008; Toutanova et al., 2008; Johansson,
2009; Llu´ıs et al., 2013, inter alia).

One reason pipelines often dominate is that they
make available the complete syntactic parse tree,

and arbitrarily-scoped syntactic features—such as
the “path” between predicate and argument, pro-
posed by Gildea and Jurafsky (2002)—for seman-
tic analysis. Such features are a mainstay of high-
performance semantic role labeling (SRL) sys-
tems (Roth and Woodsend, 2014; Lei et al., 2015;
FitzGerald et al., 2015; Foland and Martin, 2015),
but they are expensive to extract (Johansson, 2009;
He et al., 2013).

This study shows how recent advances in repre-
sentation learning can bypass those expensive fea-
tures, discovering cheap alternatives available dur-
ing a greedy parsing procedure. The speciﬁc ad-
vance we employ is the stack LSTM (Dyer et al.,
2015), a neural network that continuously summa-
rizes the contents of the stack data structures in
which a transition-based parser’s state is conven-
tionally encoded. Stack LSTMs were shown to ob-
viate many features used in syntactic dependency
parsing; here we ﬁnd them to do the same for joint
syntactic-semantic dependency parsing.

We believe this is an especially important ﬁnd-
ing for greedy models that cast parsing as a se-
quence of decisions made based on algorithmic
state, where linguistic theory and researcher intu-
itions offer less guidance in feature design.

Our system’s performance does not match that
of the top expert-crafted feature-based systems
(Zhao et al., 2009; Bj¨orkelund et al., 2010; Roth
and Woodsend, 2014; Lei et al., 2015), systems
which perform optimal decoding (T¨ackstr¨om et
al., 2015), or of systems that exploit additional,
differently-annotated datasets (FitzGerald et al.,
2015). Many advances in those systems are or-
thogonal to our model, and we expect future work
to achieve further gains by integrating them.

Because our system is very fast— with an
end-to-end runtime of 177.6±18 seconds to parse
the CoNLL 2009 English test data on a single
core—we believe it will be useful in practical set-

8
1
0
2
 
l
u
J
 
5
 
 
]
L
C
.
s
c
[
 
 
2
v
4
5
9
8
0
.
6
0
6
1
:
v
i
X
r
a

root

sbj

vc

oprd

im

tmp

all are expected to reopen soon

expect.01

reopen.01

A1

C-A1

A1

AM-TMP

Figure 1: Example of a joint parse. Syntactic de-
pendencies are shown by arcs above the sentence
and semantic dependencies below; predicates are
marked in boldface. C- denotes continuation of
argument A1. Correspondences between depen-
dencies might be close (between expected and to)
or not (between reopen and all).

tings. Our open-source implementation has been
released.1

2

Joint Syntactic and Semantic
Dependency Parsing

We largely follow the transition-based, synchro-
nized algorithm of Henderson et al. (2013) to pre-
dict joint parse structures. The input to the algo-
rithm is a sentence annotated with part-of-speech
tags. The output consists of a labeled syntactic de-
pendency tree and a directed SRL graph, in which
a subset of words in the sentence are selected as
predicates, disambiguated to a sense, and linked
by labeled, directed edges to their semantic argu-
ments. Figure 1 shows an example.

2.1 Transition-Based Procedure

The two parses are constructed in a bottom-up
fashion,
incrementally processing words in the
sentence from left to right. The state of the pars-
ing algorithm at timestep t is represented by three
stack data structures: a syntactic stack St, a se-
mantic stack Mt—each containing partially built
structures—and a buffer of input words Bt. Our
algorithm also places partial syntactic and seman-
tic parse structures onto the front of the buffer,
so it is also implemented as a stack. Each arc in
the output corresponds to a transition (or “action”)
chosen based on the current state; every transition
modiﬁes the state by updating St, Mt, and Bt to
St+1, Mt+1, and Bt+1, respectively. While each
state may license several valid actions, each action

1https://github.com/clab/

joint-lstm-parser

has a deterministic effect on the state of the algo-
rithm.

Initially, S0 and M0 are empty, and B0 contains
the input sentence with the ﬁrst word at the front
of B and a special root symbol at the end.2 Execu-
tion ends on iteration t such that Bt is empty and
St and Mt contain only a single structure headed
by root.

2.2 Transitions for Joint Parsing

There are separate sets of syntactic and semantic
transitions; the former manipulate S and B, the
latter M and B. All are formally deﬁned in Ta-
ble 1. The syntactic transitions are from the “arc-
eager” algorithm of Nivre (2008). They include:

• S-SHIFT, which copies3 an item from the front

of B and pushes it on S.

• S-REDUCE pops an item from S.
• S-RIGHT((cid:96)) creates a syntactic dependency.
Let u be the element at the top of S and v be
the element at the front of B. The new depen-
dency has u as head, v as dependent, and label
(cid:96). u is popped off S, and the resulting structure,
rooted at u, is pushed on S. Finally, v is copied
to the top of S.

• S-LEFT((cid:96)) creates a syntactic dependency with
label (cid:96) in the reverse direction as S-RIGHT. The
top of S, u, is popped. The front of B, v, is
replaced by the new structure, rooted at v.

The semantic transitions are similar, operating

on the semantic stack.

• M-SHIFT removes an item from the front of B

and pushes it on M .

• M-REDUCE pops an item from M .
• M-RIGHT(r) creates a semantic dependency.
Let u be the element at the top of M and v,
the front of B. The new dependency has u as
head, v as dependent, and label r. u is popped
off M , and the resulting structure, rooted at u,
is pushed on M .

• M-LEFT(r) creates a semantic dependency
with label r in the reverse direction as M-
RIGHT. The buffer front, v, is replaced by the
new v-rooted structure. M remains unchanged.

2This works better for the arc-eager algorithm (Balles-
teros and Nivre, 2013), in contrast to Henderson et al. (2013),
who initialized with root at the buffer front.

3Note that in the original arc-eager algorithm (Nivre,
2008), SHIFT and RIGHT-ARC actions move the item on the
buffer front to the stack, whereas we only copy it (to allow
the semantic operations to have access to it).

ﬁed and the algorithm returns to syntactic transi-
tions. This implies that, for each word, its left-
side syntactic dependencies are resolved before its
left-side semantic dependencies. An example run
of the algorithm is shown in Figure 3.

2.3 Constraints on Transitions

To ensure that the parser never enters an invalid
state, the sequence of transitions is constrained,
following Henderson et al. (2013). Actions that
copy or move items from the buffer (S-SHIFT,
S-RIGHT and M-SHIFT) are forbidden when the
buffer is empty. Actions that pop from a stack
(S-REDUCE and M-REDUCE) are forbidden when
that stack is empty. We disallow actions corre-
sponding to the same dependency, or the same
predicate to be repeated in the sequence. Repet-
itive M-SWAP transitions are disallowed to avoid
inﬁnite swapping. Finally, as noted above, we re-
strict the parser to syntactic actions until it needs
to shift an item from B to S, after which it can
only execute semantic actions until it executes an
M-SHIFT.

Asymptotic runtime complexity of this greedy
algorithm is linear in the length of the input, fol-
lowing the analysis by Nivre (2009).5

3 Statistical Model

The transitions in §2 describe the execution paths
our algorithm can take; like past work, we apply
a statistical classiﬁer to decide which transition to
take at each timestep, given the current state. The
novelty of our model is that it learns a ﬁnite-length
vector representation of the entire joint parser’s
state (S, M , and B) in order to make this decision.

3.1 Stack Long Short-Term Memory (LSTM)

LSTMs are recurrent neural networks equipped
with specialized memory components in addition
to a hidden state (Hochreiter and Schmidhuber,
1997; Graves, 2013) to model sequences. Stack
LSTMs (Dyer et al., 2015) are LSTMs that al-
low for stack operations: query, push, and pop.
A “stack pointer” is maintained which determines
which cell in the LSTM provides the memory and
hidden units when computing the new memory
cell contents. Query provides a summary of the
stack in a single ﬁxed-length vector. Push adds

semantic transitions, hence we only copy it.

5The analysis in (Nivre, 2009) does not consider SWAP
actions. However, since we constrain the number of such ac-
tions, the linear time complexity of the algorithm stays intact.

Figure 2: Example of an SRL graph with an arc
from predicate problem.01 to itself, ﬁlling the A2
role. Our SELF(A2) transition allows recovering
this semantic dependency.

Because SRL graphs allow a node to be a se-
mantic argument of two parents—like all in the
example in Figure 1—M-LEFT and M-RIGHT
do not remove the dependent from the semantic
stack and buffer respectively, unlike their syntactic
equivalents, S-LEFT and S-RIGHT. We use two
other semantic transitions from Henderson et al.
(2013) which have no syntactic analogues:

• M-SWAP swaps the top two items on M , to al-

low for crossing semantic arcs.

• M-PRED(p) marks the item at the front of B
as a semantic predicate with the sense p, and
replaces it with the disambiguated predicate.

The CoNLL 2009 corpus introduces semantic
self-dependencies where many nominal predicates
(from NomBank) are marked as their own argu-
ments; these account for 6.68% of all semantic
arcs in the English corpus. An example involving
an eventive noun is shown in Figure 2. We intro-
duce a new semantic transition, not in Henderson
et al. (2013), to handle such cases:

• M-SELF(r) adds a dependency, with label r be-
tween the item at the front of B and itself. The
result replaces the item at the front of B.

Note that the syntactic and semantic transitions
both operate on the same buffer, though they in-
dependently specify the syntax and semantics, re-
spectively. In order to ensure that both syntactic
and semantic parses are produced, the syntactic
and semantic transitions are interleaved. Only syn-
tactic transitions are considered until a transition is
chosen that copies an item from the buffer front to
the syntactic stack (either S-SHIFT or S-RIGHT).
The algorithm then switches to semantic transi-
tions until a buffer-modifying transition is taken
(M-SHIFT).4 At this point, the buffer is modi-

4Had we moved the item at the buffer front during the
syntactic transitions, it would have been unavailable for the

St
S
(u, u), S

(u, u), S

(u, u), S
S
S
S
S
S
S
S

Mt
M
M

M

Bt
(v, v), B
B

Action
S-SHIFT
S-REDUCE

St+1
(v, v), S
S

(v, v), B

S-RIGHT((cid:96))

(v, v), (gs(u, v, l), u), S

M
M
(u, u), M
(u, u), M
(u, u), M
(u, u), (v, v), M
M
M

(v, v), B
(v, v), B
B
(v, v), B
(v, v), B
B
(v, v), B
(v, v), B

S-LEFT((cid:96))
M-SHIFT
M-REDUCE
M-RIGHT(r)
M-LEFT(r)
M-SWAP
M-PRED(p)
M-SELF(r)

S
S
S
S
S
S
S
S

M

(v, v), B

Mt+1
M
M

M (gs(v, u, l), v), B

Bt+1
(v, v), B
B

Dependency
—
—
S ∪ u (cid:96)→ v
S ∪ u (cid:96)← v
B
—
B
—
M ∪ u r→ v
(v, v), B
(u, u), M (gm(v, u, r), v), B M ∪ u r← v
B
(gd(v, p), v), B

(v, v), (u, u), M
M
M (gm(v, v, r), v), B M ∪ v r↔ v

(v, v), M
M
(gm(u, v, r), u), M

—
—

Table 1: Parser transitions along with the modiﬁcations to the stacks and the buffer resulting from each.
Syntactic transitions are shown above, semantic below. Italic symbols denote symbolic representations
of words and relations, and bold symbols indicate (learned) embeddings (§3.5) of words and relations;
each element in a stack or buffer includes both symbolic and vector representations, either atomic or
recursive. S represents the set of syntactic transitions, and M the set of semantic transitions.

an element to the top of the stack, resulting in a
new summary. Pop, which does not correspond to
a conventional LSTM operation, moves the stack
pointer to the preceding timestep, resulting in a
stack summary as it was before the popped item
was observed. Implementation details (Dyer et al.,
2015; Goldberg, 2015) and code have been made
publicly available.6

Using stack LSTMs, we construct a represen-
tation of the algorithm state by decomposing it
into smaller pieces that are combined by recursive
function evaluations (similar to the way a list is
built by a concatenate operation that operates on a
list and an element). This enables information that
would be distant from the “top” of the stack to be
carried forward, potentially helping the learner.

3.2 Stack LSTMs for Joint Parsing

four

Our algorithm employs
stack LSTMs,
one each for the S, M , and B data struc-
tures.Like Dyer et al. (2015), we use a fourth stack
LSTM, A, for the history of actions—A is never
popped from, only pushed to. Figure 4 illustrates
the architecture. The algorithm’s state at timestep
t is encoded by the four vectors summarizing the
four stack LSTMs, and this is the input to the clas-
siﬁer that chooses among the allowable transitions
at that timestep.

Let st, mt, bt, and at denote the summaries
of St, Mt, Bt, and At, respectively. Let At =
Allowed(St, Mt, Bt, At) denote the allowed tran-
sitions given the current stacks and buffer. The
parser state at time t is given by a rectiﬁed linear
unit (Nair and Hinton, 2010) in vector yt:

where W and d are the parameters of the classi-
ﬁer. The transition selected at timestep t is

arg max
τ ∈At
≡ arg max
τ ∈At

qτ + θτ · yt

(1)

score(τ ; St, Mt, Bt, At)

where θτ and qτ are parameters for each transi-
tion type τ . Note that only allowed transitions are
considered in the decision rule (see §2.3).

3.3 Composition Functions

To use stack LSTMs, we require vector representa-
tions of the elements that are stored in the stacks.
Speciﬁcally, we require vector representations of
atoms (words, possibly with part-of-speech tags)
and parse fragments. Word vectors can be pre-
trained or learned directly; we consider a concate-
nation of both in our experiments; part-of-speech
vectors are learned and concatenated to the same.
To obtain vector representations of parse frag-
ments, we use neural networks which recursively
compute representations of the complex structured
output (Dyer et al., 2015). The tree structures here
are always ternary trees, with each internal node’s
three children including a head, a dependent, and
a label. The vectors for leaves are word vectors
and vectors corresponding to syntactic and seman-
tic relation types.

The vector for an internal node is a squashed
(tanh) afﬁne transformation of its children’s vec-
tors. For syntactic and semantic attachments, re-
spectively, the composition function is:

yt = elementwisemax {0, d + W[st; mt; bt; at]}

6https://github.com/clab/lstm-parser

gs(v, u, l) = tanh(Zs[v; u; l] + es)
gm(v, u, r) = tanh(Zm[v; u; r] + em)

(2)

(3)

d
e
t
c
e
p
x
e

→
−
e
r
a

c
v

1
0
.
t
c
e
p
x
e
−
1
←
A

d
r
p
o

o
t

→
−
d
e
t
c
e
p
x
e

o
t

-

1
→
A
−
C
1
0
.
t
c
e
p
x
e

n
e
p
o
e
r

i

→
m
−
o
t

1
0
.
n
e
p
o
e
r

−
1
←
A

e
r
a
−
←

j
b
s

n
o
o
s

P
M
→
T
−
-
M
A

1
0
.
n
e
p
o
e
r

n
o
o
s

t

→
p
m
−
n
e
p
o
e
r

t
o
o
r

t
o
o
r

−
←

e
r
a

—

—

—

l
l
a

—

—

—

—

l
l
a

—

—

—

—

—

l
l
a

—

—

—

—

—

—

—

—

—

—

—

y
c
n
e
d
n
e
p
e
D

B

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a

,
l
l
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a

,
l
l
a
[

,
o
t

,
o
t

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
o
t

,
d
e
t
c
e
p
x
e
[

,
d
e
t
c
e
p
x
e
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
l
l
a
[

]
l
l
a
[

]
e
r
a
[

]
e
r
a
[

]
[

S

]
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

)
1
0
.
t
c
e
p
x
e
(
D
E
R
P
-
M

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
d
e
t
c
e
p
x
e

,
l
l
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
d
e
t
c
e
p
x
e

,
l
l
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
d
e
t
c
e
p
x
e

,
l
l
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
d
r
p
o
(
T
H
G

I

R

-
S
*
*
*

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
[

]
[

]
n
o
o
s

,
n
e
p
o
e
r

]
n
o
o
s

,
n
e
p
o
e
r

]
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
o
t

,
o
t

,
o
t

,
o
t

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
n
e
p
o
e
r
[

]
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
p
m

t
(
T
H
G

I

R

-
S

]
n
e
p
o
e
r
[

]
n
o
o
s

,
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
P
M
T
-
M
A
(
T
H
G

I

-

R
M

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

,
o
t

,
o
t

,
o
t

,
o
t

,
o
t

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
1
A
-
C

(
T
H
G

I

-

R
M

E
C
U
D
E
R
M

-

T
F
I

H
S
-
M

)

m

i
(
T
H
G

I

R

-
S

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
1
0
.
n
e
p
o
e
r
(
D
E
R
P
-
M

]
e
r
a
[

]
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

M

]
[

]
[

]
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
e
r
a

,
l
l
a
[

]
e
r
a

,
l
l
a
[

]
e
r
a

,
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
o
t

,
l
l
a
[

]
o
t

,
l
l
a
[

]
o
t

,
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
[

]
n
e
p
o
e
r
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
t
o
o
r
[

]
[

)
j
b
s
(
T
F
E
L
-
S

T
F
I

H
S
-
S

T
F
I

H
S
-
M

)
c
v
(
T
H
G

I

R

-
S

T
F
I

H
S
-
S

T
F
I

H
S
-
M

E
C
U
D
E
R
M

-

)
1
A
(
T
F
E
L
-
M

T
F
I

H
S
-
M

n
o
i
t
i
s
n
a
r
T

E
C
U
D
E
R
M

-

)
1
A
(
T
F
E
L
-
M

E
C
U
D
E
R
M

-

T
F
I

H
S
-
M

E
C
U
D
E
R
M

-

E
C
U
D
E
R

-
S

E
C
U
D
E
R

-
S

E
C
U
D
E
R

-
S

E
C
U
D
E
R

-
S

T
F
I

H
S
-
M

)
t
o
o
r
(
T
F
E
L
-
S

E
C
U
D
E
R
M

-

T
F
I

H
S
-
M

T
F
I

H
S
-
S

Figure 3: Joint parser transition sequence for the sentence in Figure 1, “all are expected to reopen soon.”
Syntactic labels are in lower-case and semantic role labels are capitalized. *** marks the operation
predicted in Figure 4.

where v and u are vectors corresponding to atomic
words or composed parse fragments; l and r are
learned vector representations for syntactic and se-
mantic labels respectively. Syntactic and semantic
parameters are separated (Zs, es and Zm, em, re-
spectively).

Finally, for predicates, we use another recur-
sive function to compose the word representa-

tion, v with a learned representation for the dis-
mabiguated sense of the predicate, p:

gd(v, p) = tanh(Zd[v; p] + ed)

(4)

where Zd and ed are parameters of the model.
Note that, because syntactic and semantic transi-
tions are interleaved, the fragmented structures are
a blend of syntactic and semantic compositions.

Figure 4: Stack LSTM for joint parsing. The state
illustrated corresponds to the ***-marked row in
the example transition sequence in Fig. 3.

Figure 5 shows an example.

3.4 Training

Training the classiﬁer requires transforming each
training instance (a joint parse) into a transition se-
quence, a deterministic operation under our tran-
sition set. Given a collection of algorithm states
at time t and correct classiﬁcation decisions τt, we
minimize the sum of log-loss terms, given (for one
timestep) by:

− log

(cid:80)

exp(qτt + θτt · yt)

τ (cid:48)∈At

exp(qτ (cid:48) + θτ (cid:48) · yt)

(5)

with respect to the classiﬁer and LSTM parame-
ters. Note that the loss is differentiable with re-
spect to the parameters; gradients are calculated
using backpropagation. We apply stochastic gra-
dient descent with dropout for all neural network
parameters.

3.5 Pretrained Embeddings

Following Dyer et al. (2015), “structured skip-
gram” embeddings (Ling et al., 2015) were used,
trained on the English (AFP section), German,
Spanish and Chinese Gigaword corpora, with a
window of size 5; training was stopped after 5
epochs. For out-of-vocabulary words, a randomly
initialized vector of the same dimension was used.

3.6 Predicate Sense Disambiguation

Figure 5: Example of a joint parse tree fragment
with vector representations shown at each node.
The vectors are obtained by recursive composition
of representations of head, dependent, and label
vectors. Syntactic dependencies and labels are in
green, semantic in blue.

are lexeme-speciﬁc, we need a way to handle un-
seen predicates at test time. When a predicate is
encountered at test time that was not observed in
training, our system constructs a predicate from
the predicted lemma of the word at that position
and defaults to the “01” sense, which is correct
for 91.22% of predicates by type in the English
CoNLL 2009 training data.

4 Experimental Setup

Our model is evaluated on the CoNLL shared
tasks on joint syntactic and semantic dependency
parsing in 2008 (Surdeanu et al., 2008) and
2009 (Hajiˇc et al., 2009). The standard training,
development and test splits of all datasets were
used. Per the shared task guidelines, automati-
cally predicted POS tags and lemmas provided in
the datasets were used for all experiments. As
a preprocessing step, pseudo-projectivization of
the syntactic trees (Nivre et al., 2007) was used,
which allowed an accurate conversion of even the
non-projective syntactic trees into syntactic transi-
tions. However, the oracle conversion of semantic
parses into transitions is not perfect despite using
the M-SWAP action, due to the presence of multi-
ple crossing arcs.7

The standard evaluation metrics include the
syntactic labeled attachment score (LAS), the se-

Predicate sense disambiguation is handled within
the model (M-PRED transitions), but since senses

7For 1.5% of English sentences in the CoNLL 2009 En-
glish dataset, the transition sequence incorrectly encodes the
gold-standard joint parse; details in Henderson et al. (2013).

mantic F1 score on both in-domain (WSJ) and out-
of-domain (Brown corpus) data, and their macro
average (Macro F1) to score joint systems. Be-
cause the task was deﬁned somewhat differently
in each year, each dataset is considered in turn.

4.1 CoNLL 2008

The CoNLL 2008 dataset contains annotations
from the Penn Treebank (Marcus et al., 1993),
PropBank (Palmer et al., 2005) and Nom-
Bank (Meyers et al., 2004). The shared task evalu-
ated systems on predicate identiﬁcation in addition
to predicate sense disambiguation and SRL.

To identify predicates, we trained a zero-
Markov order bidirectional LSTM two-class clas-
siﬁer. As input to the classiﬁer, we use learned rep-
resentations of word lemmas and POS tags. This
model achieves an F1 score of 91.43% on marking
words as predicates (or not).

Hyperparameters The input representation for
a word consists of pretrained embeddings (size
100 for English, 80 for Chinese, 64 for Ger-
man and Spanish), concatenated with additional
learned word and POS tag embeddings (size 32
and 12, respectively). Learned embeddings for
syntactic and semantic arc labels are of size 20
and predicates 100. Two-layer LSTMs with hid-
den state dimension 100 were used for each of the
four stacks. The parser state yt and the composi-
tion function g are of dimension 100. A dropout
rate of 0.2 (Zaremba et al., 2014) was used on all
layers at training time, tuned on the development
data from the set of values {0.1, 0.2, 0.3, 1.0}. The
learned representations for actions are of size 100,
similarly tuned from {10, 20, 30, 40, 100}. Other
hyperparameters have been set intuitively; careful
tuning is expected to yield improvements (Weiss
et al., 2015).

An initial learning rate of 0.1 for stochastic gra-
dient descent was used and updated in every train-
ing epoch with a decay rate of 0.1 (Dyer et al.,
2015). Training is stopped when the development
performance does not improve for approximately
6–7 hours of elapsed time. Experiments were run
on a single thread on a CPU, with memory require-
ments of up to 512 MB.

4.2 CoNLL 2009

Relative to the CoNLL 2008 task (above), the
main change in 2009 is that predicates are pre-
identiﬁed, and systems are only evaluated on pred-

icate sense disambiguation (not
identiﬁcation).
Hence, the bidirectional LSTM classiﬁer is not
used here. The preprocessing for projectivity, and
the hyperparameter selection is the same as in
§4.1.

In addition to the joint approach described in
the preceding sections, we experiment here with
several variants:

Semantics-only:
the set of syntactic transitions
S, the syntactic stack S, and the syntactic compo-
sition function gs are discarded. As a result, the set
of constraints on transitions is a subset of the full
set of constraints in §2.3. Effectively, this model
does not use any syntactic features, similar to Col-
lobert et al. (2011) and Zhou and Xu (2015). It
provides a controlled test of the beneﬁt of explicit
syntax in a semantic parser.

all semantic transitions in M, the
Syntax-only:
semantic stack M , and the semantic composition
function gm are discarded. S-SHIFT and S-RIGHT
now move the item from the front of the buffer to
the syntactic stack, instead of copying. The set of
constraints on the transitions is again a subset of
the full set of constraints. This model is an arc-
eager variant of Dyer et al. (2015), and serves to
check whether semantic parsing degrades syntac-
tic performance.

Hybrid:
the semantics parameters are trained
using automatically predicted syntax from the
syntax-only model. At test time, only seman-
tic parses are predicted. This setup bears simi-
larity to other approaches which pipeline syntax
and semantics, extracting features from the syn-
tactic parse to help SRL. However, unlike other
approaches, this model does not offer the entire
syntactic tree for feature extraction, since only the
partial syntactic structures present on the syntactic
stack (and potentially the buffer) are visible at a
given timestep. This model helps show the effect
of joint prediction.

5 Results and Discussion

CoNLL 2008 (Table 2) Our joint model signif-
icantly outperforms the joint model of Hender-
son et al. (2008), from which our set of tran-
sitions is derived, showing the beneﬁt of learn-
ing a representation for the entire algorithmic
state. Several other joint learning models have
been proposed (Llu´ıs and M`arquez, 2008; Jo-
hansson, 2009; Titov et al., 2009) for the same

Model

joint models:
Llu´ıs and M`arquez (2008)
Henderson et al. (2008)
Johansson (2009)
Titov et al. (2009)
CoNLL 2008 best:
#3: Zhao and Kit (2008)
#2: Che et al. (2008)
#2: Ciaramita et al. (2008)
#1: J&N (2008)
Joint (this work)

LAS

Sem. Macro
F1

F1

85.8
87.6
86.6
87.5

87.7
86.7
87.4
89.3
89.1

70.3
73.1
77.1
76.1

76.7
78.5
78.0
81.6
80.5

78.1
80.5
81.8
81.8

82.2
82.7
82.7
85.5
84.9

Table 2: Joint parsers: comparison on the CoNLL
2008 test (WSJ+Brown) set.

task; our joint model surpasses the performance
of all these models. The best reported systems on
the CoNLL 2008 task are due to Johansson and
Nugues (2008), Che et al. (2008), Ciaramita et
al. (2008) and Zhao and Kit (2008), all of which
pipeline syntax and semantics; our system’s se-
mantic and overall performance is comparable to
these. We fall behind only Johansson and Nugues
(2008), whose success was attributed to carefully
designed global SRL features integrated into a
pipeline of classiﬁers, making them asymptoti-
cally slower.

CoNLL 2009 English (Table 3) All of our
models (Syntax-only, Semantics-only, Hybrid and
Joint) improve over Gesmundo et al.
(2009)
and Henderson et al. (2013), demonstrating the
beneﬁt of our entire-parser-state representation
learner compared to the more locally scoped
model.

Given that syntax has consistently proven useful
in SRL, we expected our Semantics-only model
to underperform Hybrid and Joint, and it did. In
the training domain, syntax and semantics bene-
ﬁt each other (Joint outperforms Hybrid). Out-
of-domain (the Brown test set), the Hybrid pulls
ahead, a sign that Joint overﬁts to WSJ. As a
syntactic parser, our Syntax-only model performs
slightly better than Dyer et al. (2015), who achieve
89.56 LAS on this task.
Joint parsing is very
slightly better still.

The overall performance of Joint is on par with
the other winning participants at the CoNLL 2009
shared task (Zhao et al., 2009; Che et al., 2009;
Gesmundo et al., 2009), falling behind only Zhao
et al. (2009), who carefully designed language-

speciﬁc features and used a series of pipelines for
the joint task, resulting in an accurate but compu-
tationally expensive system.

State-of-the-art SRL systems (shown in the last
block of Table 3) which use advances orthog-
onal to the contributions in this paper, perform
better than our models. Many of these systems
use expert-crafted features derived from full syn-
tactic parses in a pipeline of classiﬁers followed
by a global reranker (Bj¨orkelund et al., 2009;
Bj¨orkelund et al., 2010; Roth and Woodsend,
2014); we have not used these features or rerank-
ing. Lei et al. (2015) use syntactic parses to obtain
interaction features between predicates and their
arguments and then compress feature representa-
tions using a low-rank tensor. T¨ackstr¨om et al.
(2015) present an exact inference algorithm for
SRL based on dynamic programming and their lo-
cal and structured models make use of many syn-
tactic features from a pipeline; our search pro-
cedure is greedy. Their algorithm is adopted
by FitzGerald et al. (2015) for inference in a model
that jointly learns representations from a combina-
tion of PropBank and FrameNet annotations; we
have not experimented with extra annotations.

Our system achieves an end-to-end runtime of
177.6±18 seconds to parse the CoNLL 2009 En-
glish test set on a single core. This is almost 2.5
times faster than the pipeline model of Lei et al.
(2015) (439.9±42 seconds) on the same machine.8

CoNLL 2009 Multilingual (Table 4) We tested
the joint model on the non-English CoNLL 2009
datasets, and the results demonstrate that it adapts
easily—it is on par with the top three systems in
most cases. We note that our Chinese parser relies
on pretrained word embeddings for its superior
performance; without them (not shown), it was on
par with the others. Japanese is a small-data case
(4,393 training examples), illustrating our model’s
dependence on reasonably large training datasets.
We have not extended our model to incorporate
morphological features, which are used by the sys-
tems to which we compare. Future work might in-
corporate morphological features where available;
this could potentially improve performance, espe-
cially in highly inﬂective languages like Czech.
An alternative might be to infer word-internal rep-
resentations using character-based word embed-

8See

SRLParser; unlike other state-of-the-art systems,
one is publicly available.

https://github.com/taolei87/
this

Model

LAS

Sem. F1
(WSJ)

Sem. F1
(Brown)

Macro
F1

88.79
88.48
89.19

89.83

89.83
89.94

CoNLL’09 best:
#3 G+ ’09
#2 C+ ’09
#1 Z+ ’09a
this work:
Syntax-only
Sem.-only
Hybrid
Joint
pipelines:
R&W ’14
L+ ’15
T+ ’15
F+ ’15

83.24
85.51
86.15

84.39
84.58
84.97

86.34
86.58
87.30
87.80

70.65
73.82
74.58

86.03
87.00
87.69

87.20
87.45

73.87
75.64
74.48

75.90
75.57
75.50
75.50

Table 3: Comparison on the CoNLL 2009 English
test set. The ﬁrst block presents results of other
models evaluated for both syntax and semantics on
the CoNLL 2009 task. The second block presents
our models. The third block presents the best pub-
lished models, each using its own syntactic pre-
processing.

dings, which was found beneﬁcial for syntactic
parsing (Ballesteros et al., 2015).

Language
Catalan
Chinese
Czech
English
German
Japanese
Spanish
Average

#1 C+’09
81.84
76.38
83.27
87.00
82.44
85.65
81.90
82.64

#2 Z+ ’09a
83.01
76.23
80.87
87.69
81.22
85.28
83.31
82.52

#3 G+ ’09
82.66
76.15
83.21
86.03
79.59
84.91
82.43
82.14

Joint
82.40
79.27
79.53
87.45
81.05
80.91
83.11
81.96

Table 4: Comparison of macro F1 scores on the
multilingual CoNLL 2009 test set.

6 Related Work

Other approaches to joint modeling, not consid-
ered in our experiments, are notable. Llu´ıs et al.
(2013) propose a graph-based joint model using
dual decomposition for agreement between syn-
tax and semantics, but do not achieve competi-
tive performance on the CoNLL 2009 task. Lewis
et al. (2015) proposed an efﬁcient joint model for
CCG syntax and SRL, which performs better than
a pipelined model. However, their training neces-
sitates CCG annotation, ours does not. Moreover,
their evaluation metric rewards semantic depen-
dencies regardless of where they attach within the
argument span given by a PropBank constituent,

making direct comparison to our evaluation infea-
sible. Krishnamurthy and Mitchell (2014) pro-
pose a joint CCG parsing and relation extraction
model which improves over pipelines, but their
task is different from ours. Li et al. (2010) also
perform joint syntactic and semantic dependency
parsing for Chinese, but do not report results on
the CoNLL 2009 dataset.

There has also been an increased interest in
models which use neural networks for SRL. Col-
lobert et al. (2011) proposed models which per-
form many NLP tasks without hand-crafted fea-
tures. Though they did not achieve the best results
on the constituent-based SRL task (Carreras and
M`arquez, 2005), their approach inspired Zhou and
Xu (2015), who achieved state-of-the-art results
using deep bidirectional LSTMs. Our approach
for dependency-based SRL is not directly compa-
rable.

7 Conclusion

We presented an incremental, greedy parser for
joint syntactic and semantic dependency parsing.
Our model surpasses the performance of previous
joint models on the CoNLL 2008 and 2009 En-
glish tasks, without using expert-crafted, expen-
sive features of the full syntactic parse.

Acknowledgments

The authors thank Sam Thomson, Lingpeng Kong,
Mark Yatskar, Eunsol Choi, George Mulcaire, and
Luheng He, as well as the anonymous review-
ers, for many useful comments. This research
was supported in part by DARPA grant FA8750-
12-2-0342 funded under the DEFT program and
by the U.S. Army Research Ofﬁce under grant
number W911NF-10-1-0533. Any opinion, ﬁnd-
ings, and conclusions or recommendations ex-
pressed in this material are those of the author(s)
and do not necessarily reﬂect the view of the
U.S. Army Research Ofﬁce or the U.S. Govern-
ment. Miguel Ballesteros was supported by the
European Commission under the contract num-
bers FP7-ICT-610411 (project MULTISENSOR)
and H2020-RIA-645012 (project KRISTINA).

References

[Ballesteros and Nivre2013] Miguel Ballesteros

and
Joakim Nivre. 2013. Going to the roots of de-
Computational Linguistics,
pendency parsing.
39(1):5–13.

[Ballesteros et al.2015] Miguel Ballesteros, Chris Dyer,
Improved transition-
and Noah A. Smith. 2015.
based parsing by modeling characters instead of
words with LSTMs. In Proc. of EMNLP.

[Bj¨orkelund et al.2009] Anders Bj¨orkelund,

Love
Hafdell, and Pierre Nugues. 2009. Multilingual
semantic role labeling. In Proc. of CoNLL.

[Bj¨orkelund et al.2010] Anders Bj¨orkelund,

Bernd
Bohnet, Love Hafdell, and Pierre Nugues. 2010.
A high-performance syntactic and semantic depen-
dency parser. In Proc. of COLING.

[Carreras and M`arquez2005] Xavier Carreras and Llu´ıs
Introduction to the CoNLL-2005
In Proc. of

M`arquez. 2005.
shared task: Semantic role labeling.
CoNLL.

[Che et al.2008] Wanxiang Che, Zhenghua Li, Yuxuan
Hu, Yongqiang Li, Bing Qin, Ting Liu, and Sheng
Li. 2008. A cascaded syntactic and semantic de-
pendency parsing system. In Proc. of CoNLL.

[Che et al.2009] Wanxiang

Li,
Zhenghua
and
Yongqiang Li, Yuhang Guo, Bing Qin,
Ting Liu. 2009. Multilingual dependency-based
syntactic and semantic parsing. In Proc. of CoNLL.

Che,

[Ciaramita et al.2008] Massimiliano

Ciaramita,
Giuseppe Attardi, Felice Dell’Orletta, and Mi-
hai Surdeanu.
DeSRL: A linear-time
semantic role labeling system. In Proc. of CoNLL.

2008.

[Collobert et al.2011] Ronan Collobert, Jason Weston,
L´eon Bottou, Michael Karlen, Koray Kavukcuoglu,
and Pavel Kuksa.
2011. Natural language pro-
cessing (almost) from scratch. Journal of Machine
Learning Research, 12:2493–2537.

[Dyer et al.2015] Chris Dyer, Miguel Ballesteros,
Wang Ling, Austin Matthews, and Noah A. Smith.
2015. Transition-based dependency parsing with
stack long short-term memory. In Proc. of ACL.

[FitzGerald et al.2015] Nicholas FitzGerald, Oscar
T¨ackstr¨om, Kuzman Ganchev, and Dipanjan Das.
2015. Semantic role labelling with neural network
factors. In Proc. of EMNLP.

[Foland and Martin2015] William R. Foland and James
2015. Dependencybased semantic role
In

Martin.
labeling using convolutional neural networks.
Proc. of *SEM.

[Gesmundo et al.2009] Andrea Gesmundo, James Hen-
derson, Paola Merlo, and Ivan Titov. 2009. A latent
variable model of synchronous syntactic-semantic
parsing for multiple languages. In Proc. of CoNLL.

[Gildea and Jurafsky2002] Daniel Gildea and Daniel
Jurafsky. 2002. Automatic labeling of semantic
roles. Computational Linguistics, 28(3):245–288.

[Graves2013] Alex Graves.

Generat-
ing sequences with recurrent neural networks.
arXiv:1308.0850.

2013.

[Hajiˇc et al.2009] Jan Hajiˇc, Massimiliano Cia-
ramita, Richard Johansson, Daisuke Kawahara,
Maria Ant`onia Mart´ı, Llu´ıs M`arquez, Adam Mey-
ers, Joakim Nivre, Sebastian Pad´o, Jan ˇStˇep´anek,
Pavel Straˇn´ak, Mihai Surdeanu, Nianwen Xue, and
Yi Zhang. 2009. The CoNLL-2009 shared task:
Syntactic and semantic dependencies in multiple
languages. In Proc. of CoNLL.

[He et al.2013] He He, Hal Daum´e III, and Jason Eis-
ner. 2013. Dynamic feature selection for depen-
dency parsing. In Proc. of EMNLP.

[Henderson et al.2008] James Henderson, Paola Merlo,
Gabriele Musillo, and Ivan Titov. 2008. A latent
variable model of synchronous parsing for syntactic
and semantic dependencies. In Proc. of CoNLL.

[Henderson et al.2013] James Henderson, Paola Merlo,
Ivan Titov, and Gabriele Musillo. 2013. Multi-
lingual joint parsing of syntactic and semantic de-
pendencies with a latent variable model. Computa-
tional Linguistics, 39(4):949–998.

[Hochreiter and Schmidhuber1997] Sepp Hochreiter
and J¨urgen Schmidhuber. 1997. Long short-term
memory. Neural Computation, 9(8):1735–1780.

[Johansson and Nugues2008] Richard Johansson and
Pierre Nugues. 2008. Dependency-based syntactic-
semantic analysis with PropBank and NomBank. In
Proc. of CoNLL.

[Johansson2009] Richard Johansson. 2009. Statistical
bistratal dependency parsing. In Proc. of EMNLP.

[Krishnamurthy and Mitchell2014] Jayant

Krishna-
murthy and Tom M. Mitchell. 2014. Joint syntactic
and semantic parsing with combinatory categorial
grammar. In Proc. of ACL.

[Lei et al.2015] Tao Lei, Yuan Zhang, Llu´ıs M`arquez
i Villodre, Alessandro Moschitti, and Regina Barzi-
lay. 2015. High-order low-rank tensors for semantic
role labeling. In Proc. of NAACL.

[Lewis et al.2015] Mike Lewis, Luheng He, and Luke
Zettlemoyer. 2015. Joint A* CCG parsing and se-
mantic role labelling. In Proc. of EMNLP.

[Li et al.2010] Junhui Li, Guodong Zhou,

Hwee Tou Ng.
2010.
mantic parsing of Chinese. In Proc. of ACL.

and
Joint syntactic and se-

[Ling et al.2015] Wang Ling, Chris Dyer, Alan Black,
and Isabel Trancoso. 2015. Two/too simple adapta-
tions of word2vec for syntax problems. In Proc. of
NAACL.

[Goldberg2015] Yoav Goldberg. 2015. A primer on
neural network models for natural language process-
ing. arXiv:1510.00726.

[Llu´ıs and M`arquez2008] Xavier Llu´ıs

and Llu´ıs
M`arquez. 2008. A joint model for parsing syntactic
and semantic dependencies. In Proc. of CoNLL.

[Llu´ıs et al.2013] Xavier Llu´ıs, Xavier Carreras, and
Llu´ıs M`arquez. 2013. Joint arc-factored parsing of
syntactic and semantic dependencies. Transactions
of the ACL, 1:219–230.

[Toutanova et al.2008] Kristina

Aria
Toutanova,
2008.
Haghighi, and Christopher D. Manning.
A global joint model for semantic role labeling.
Computational Linguistics, 34(2):161–191.

[Weiss et al.2015] David Weiss, Chris Alberti, Michael
Collins, and Slav Petrov. 2015. Structured train-
ing for neural network transition-based parsing. In
Proc. of ACL.

[Zaremba et al.2014] Wojciech

Sutskever, and Oriol Vinyals.
neural network regularization. arXiv:1409.2329.

Ilya
Zaremba,
2014. Recurrent

[Zhao and Kit2008] Hai Zhao and Chunyu Kit. 2008.
Parsing syntactic and semantic dependencies with
two single-stage maximum entropy models. In Proc.
of CoNLL.

[Zhao et al.2009] Hai Zhao, Wenliang Chen, Jun’ichi
Kazama, Kiyotaka Uchimoto, and Kentaro Tori-
sawa. 2009. Multilingual dependency learning: Ex-
ploiting rich features for tagging syntactic and se-
mantic dependencies. In Proc. of CoNLL.

[Zhou and Xu2015] Jie Zhou and Wei Xu. 2015. End-
to-end learning of semantic role labeling using re-
current neural networks. In Proc. of ACL.

[Marcus et al.1993] Mitchell P. Marcus, Mary Ann
1993.
Marcinkiewicz, and Beatrice Santorini.
Building a large annotated corpus of English:
The Penn treebank. Computational Linguistics,
19(2):313–330.

[Meyers et al.2004] Adam Meyers, Ruth Reeves,
Catherine Macleod, Rachel Szekely, Veronika
Zielinska, Brian Young, and Ralph Grishman. 2004.
The NomBank project: An interim report. In Proc.
of NAACL.

[Nair and Hinton2010] Vinod Nair and Geoffrey E.
Hinton. 2010. Rectiﬁed linear units improve re-
stricted Boltzmann machines. In Proc. of ICML.

[Nivre et al.2007] Joakim Nivre, Johan Hall, Jens Nils-
son, Atanas Chanev, G¨ulsen Eryigit, Sandra K¨ubler,
Svetoslav Marinov, and Erwin Marsi. 2007. Malt-
Parser: A language-independent system for data-
driven dependency parsing. Natural Language En-
gineering, 13:95–135.

[Nivre2008] Joakim Nivre. 2008. Algorithms for de-
terministic incremental dependency parsing. Com-
putational Linguistics, 34(4):513–553.

[Nivre2009] Joakim Nivre. 2009. Non-projective de-
pendency parsing in expected linear time. In Proc.
of ACL.

[Palmer et al.2005] Martha Palmer, Daniel Gildea, and
Paul Kingsbury. 2005. The Proposition Bank: An
annotated corpus of semantic roles. Computational
Linguistics, 31(1):71–106.

[Roth and Woodsend2014] Michael Roth and Kristian
Woodsend. 2014. Composition of word represen-
tations improves semantic role labelling. In Proc. of
EMNLP.

[Surdeanu et al.2008] Mihai Surdeanu, Richard Johans-
son, Adam Meyers, Llu´ıs M`arquez, and Joakim
Nivre. 2008. The CoNLL-2008 shared task on joint
parsing of syntactic and semantic dependencies. In
Proc. of CoNLL.

[Sutton and McCallum2005] Charles Sutton and An-
drew McCallum. 2005. Joint parsing and semantic
role labeling. In Proc. of CoNLL.

[T¨ackstr¨om et al.2015] Oscar T¨ackstr¨om, Kuzman
Efﬁcient
Ganchev, and Dipanjan Das.
inference and structured learning for semantic role
labeling. Transactions of the ACL, 3:29–41.

2015.

[Titov et al.2009] Ivan Titov, James Henderson, Paola
Merlo, and Gabriele Musillo. 2009. Online graph
planarisation for synchronous parsing of semantic
and syntactic dependencies. In Proc. of IJCAI.

Greedy, Joint Syntactic-Semantic Parsing with Stack LSTMs

Swabha Swayamdipta♣ Miguel Ballesteros♦ Chris Dyer♠ Noah A. Smith♥
♣School of Computer Science, Carnegie Mellon University, Pittsburgh, PA 15213, USA
♦Natural Language Processing Group, Universitat Pompeu Fabra, Barcelona, Spain
♠Google DeepMind, London, UK
♥Computer Science & Engineering, University of Washington, Seattle, WA 98195, USA
swabha@cs.cmu.edu, miguel.ballesteros@upf.edu,
cdyer@cs.cmu.edu, nasmith@cs.washington.edu

Abstract

We present a transition-based parser that
jointly produces syntactic and semantic
It learns a representation
dependencies.
of the entire algorithm state, using stack
long short-term memories. Our greedy in-
ference algorithm has linear time, includ-
ing feature extraction. On the CoNLL
2008–9 English shared tasks, we obtain
the best published parsing performance
among models that jointly learn syntax
and semantics.

1

Introduction

We introduce a new joint syntactic and semantic
dependency parser. Our parser draws from the
algorithmic insights of the incremental structure
building approach of Henderson et al. (2008), with
two key differences. First, it learns representations
for the parser’s entire algorithmic state, not just the
top items on the stack or the most recent parser
states; in fact, it uses no expert-crafted features at
all. Second, it uses entirely greedy inference rather
than beam search. We ﬁnd that it outperforms all
previous joint parsing models, including Hender-
son et al. (2008) and variants (Gesmundo et al.,
2009; Titov et al., 2009; Henderson et al., 2013) on
the CoNLL 2008 and 2009 (English) shared tasks.
Our parser’s multilingual results are comparable to
the top systems at CoNLL 2009.

Joint models like ours have frequently been pro-
posed as a way to avoid cascading errors in NLP
pipelines; varying degrees of success have been at-
tained for a range of joint syntactic-semantic anal-
ysis tasks (Sutton and McCallum, 2005; Hender-
son et al., 2008; Toutanova et al., 2008; Johansson,
2009; Llu´ıs et al., 2013, inter alia).

One reason pipelines often dominate is that they
make available the complete syntactic parse tree,

and arbitrarily-scoped syntactic features—such as
the “path” between predicate and argument, pro-
posed by Gildea and Jurafsky (2002)—for seman-
tic analysis. Such features are a mainstay of high-
performance semantic role labeling (SRL) sys-
tems (Roth and Woodsend, 2014; Lei et al., 2015;
FitzGerald et al., 2015; Foland and Martin, 2015),
but they are expensive to extract (Johansson, 2009;
He et al., 2013).

This study shows how recent advances in repre-
sentation learning can bypass those expensive fea-
tures, discovering cheap alternatives available dur-
ing a greedy parsing procedure. The speciﬁc ad-
vance we employ is the stack LSTM (Dyer et al.,
2015), a neural network that continuously summa-
rizes the contents of the stack data structures in
which a transition-based parser’s state is conven-
tionally encoded. Stack LSTMs were shown to ob-
viate many features used in syntactic dependency
parsing; here we ﬁnd them to do the same for joint
syntactic-semantic dependency parsing.

We believe this is an especially important ﬁnd-
ing for greedy models that cast parsing as a se-
quence of decisions made based on algorithmic
state, where linguistic theory and researcher intu-
itions offer less guidance in feature design.

Our system’s performance does not match that
of the top expert-crafted feature-based systems
(Zhao et al., 2009; Bj¨orkelund et al., 2010; Roth
and Woodsend, 2014; Lei et al., 2015), systems
which perform optimal decoding (T¨ackstr¨om et
al., 2015), or of systems that exploit additional,
differently-annotated datasets (FitzGerald et al.,
2015). Many advances in those systems are or-
thogonal to our model, and we expect future work
to achieve further gains by integrating them.

Because our system is very fast— with an
end-to-end runtime of 177.6±18 seconds to parse
the CoNLL 2009 English test data on a single
core—we believe it will be useful in practical set-

8
1
0
2
 
l
u
J
 
5
 
 
]
L
C
.
s
c
[
 
 
2
v
4
5
9
8
0
.
6
0
6
1
:
v
i
X
r
a

root

sbj

vc

oprd

im

tmp

all are expected to reopen soon

expect.01

reopen.01

A1

C-A1

A1

AM-TMP

Figure 1: Example of a joint parse. Syntactic de-
pendencies are shown by arcs above the sentence
and semantic dependencies below; predicates are
marked in boldface. C- denotes continuation of
argument A1. Correspondences between depen-
dencies might be close (between expected and to)
or not (between reopen and all).

tings. Our open-source implementation has been
released.1

2

Joint Syntactic and Semantic
Dependency Parsing

We largely follow the transition-based, synchro-
nized algorithm of Henderson et al. (2013) to pre-
dict joint parse structures. The input to the algo-
rithm is a sentence annotated with part-of-speech
tags. The output consists of a labeled syntactic de-
pendency tree and a directed SRL graph, in which
a subset of words in the sentence are selected as
predicates, disambiguated to a sense, and linked
by labeled, directed edges to their semantic argu-
ments. Figure 1 shows an example.

2.1 Transition-Based Procedure

The two parses are constructed in a bottom-up
fashion,
incrementally processing words in the
sentence from left to right. The state of the pars-
ing algorithm at timestep t is represented by three
stack data structures: a syntactic stack St, a se-
mantic stack Mt—each containing partially built
structures—and a buffer of input words Bt. Our
algorithm also places partial syntactic and seman-
tic parse structures onto the front of the buffer,
so it is also implemented as a stack. Each arc in
the output corresponds to a transition (or “action”)
chosen based on the current state; every transition
modiﬁes the state by updating St, Mt, and Bt to
St+1, Mt+1, and Bt+1, respectively. While each
state may license several valid actions, each action

1https://github.com/clab/

joint-lstm-parser

has a deterministic effect on the state of the algo-
rithm.

Initially, S0 and M0 are empty, and B0 contains
the input sentence with the ﬁrst word at the front
of B and a special root symbol at the end.2 Execu-
tion ends on iteration t such that Bt is empty and
St and Mt contain only a single structure headed
by root.

2.2 Transitions for Joint Parsing

There are separate sets of syntactic and semantic
transitions; the former manipulate S and B, the
latter M and B. All are formally deﬁned in Ta-
ble 1. The syntactic transitions are from the “arc-
eager” algorithm of Nivre (2008). They include:

• S-SHIFT, which copies3 an item from the front

of B and pushes it on S.

• S-REDUCE pops an item from S.
• S-RIGHT((cid:96)) creates a syntactic dependency.
Let u be the element at the top of S and v be
the element at the front of B. The new depen-
dency has u as head, v as dependent, and label
(cid:96). u is popped off S, and the resulting structure,
rooted at u, is pushed on S. Finally, v is copied
to the top of S.

• S-LEFT((cid:96)) creates a syntactic dependency with
label (cid:96) in the reverse direction as S-RIGHT. The
top of S, u, is popped. The front of B, v, is
replaced by the new structure, rooted at v.

The semantic transitions are similar, operating

on the semantic stack.

• M-SHIFT removes an item from the front of B

and pushes it on M .

• M-REDUCE pops an item from M .
• M-RIGHT(r) creates a semantic dependency.
Let u be the element at the top of M and v,
the front of B. The new dependency has u as
head, v as dependent, and label r. u is popped
off M , and the resulting structure, rooted at u,
is pushed on M .

• M-LEFT(r) creates a semantic dependency
with label r in the reverse direction as M-
RIGHT. The buffer front, v, is replaced by the
new v-rooted structure. M remains unchanged.

2This works better for the arc-eager algorithm (Balles-
teros and Nivre, 2013), in contrast to Henderson et al. (2013),
who initialized with root at the buffer front.

3Note that in the original arc-eager algorithm (Nivre,
2008), SHIFT and RIGHT-ARC actions move the item on the
buffer front to the stack, whereas we only copy it (to allow
the semantic operations to have access to it).

ﬁed and the algorithm returns to syntactic transi-
tions. This implies that, for each word, its left-
side syntactic dependencies are resolved before its
left-side semantic dependencies. An example run
of the algorithm is shown in Figure 3.

2.3 Constraints on Transitions

To ensure that the parser never enters an invalid
state, the sequence of transitions is constrained,
following Henderson et al. (2013). Actions that
copy or move items from the buffer (S-SHIFT,
S-RIGHT and M-SHIFT) are forbidden when the
buffer is empty. Actions that pop from a stack
(S-REDUCE and M-REDUCE) are forbidden when
that stack is empty. We disallow actions corre-
sponding to the same dependency, or the same
predicate to be repeated in the sequence. Repet-
itive M-SWAP transitions are disallowed to avoid
inﬁnite swapping. Finally, as noted above, we re-
strict the parser to syntactic actions until it needs
to shift an item from B to S, after which it can
only execute semantic actions until it executes an
M-SHIFT.

Asymptotic runtime complexity of this greedy
algorithm is linear in the length of the input, fol-
lowing the analysis by Nivre (2009).5

3 Statistical Model

The transitions in §2 describe the execution paths
our algorithm can take; like past work, we apply
a statistical classiﬁer to decide which transition to
take at each timestep, given the current state. The
novelty of our model is that it learns a ﬁnite-length
vector representation of the entire joint parser’s
state (S, M , and B) in order to make this decision.

3.1 Stack Long Short-Term Memory (LSTM)

LSTMs are recurrent neural networks equipped
with specialized memory components in addition
to a hidden state (Hochreiter and Schmidhuber,
1997; Graves, 2013) to model sequences. Stack
LSTMs (Dyer et al., 2015) are LSTMs that al-
low for stack operations: query, push, and pop.
A “stack pointer” is maintained which determines
which cell in the LSTM provides the memory and
hidden units when computing the new memory
cell contents. Query provides a summary of the
stack in a single ﬁxed-length vector. Push adds

semantic transitions, hence we only copy it.

5The analysis in (Nivre, 2009) does not consider SWAP
actions. However, since we constrain the number of such ac-
tions, the linear time complexity of the algorithm stays intact.

Figure 2: Example of an SRL graph with an arc
from predicate problem.01 to itself, ﬁlling the A2
role. Our SELF(A2) transition allows recovering
this semantic dependency.

Because SRL graphs allow a node to be a se-
mantic argument of two parents—like all in the
example in Figure 1—M-LEFT and M-RIGHT
do not remove the dependent from the semantic
stack and buffer respectively, unlike their syntactic
equivalents, S-LEFT and S-RIGHT. We use two
other semantic transitions from Henderson et al.
(2013) which have no syntactic analogues:

• M-SWAP swaps the top two items on M , to al-

low for crossing semantic arcs.

• M-PRED(p) marks the item at the front of B
as a semantic predicate with the sense p, and
replaces it with the disambiguated predicate.

The CoNLL 2009 corpus introduces semantic
self-dependencies where many nominal predicates
(from NomBank) are marked as their own argu-
ments; these account for 6.68% of all semantic
arcs in the English corpus. An example involving
an eventive noun is shown in Figure 2. We intro-
duce a new semantic transition, not in Henderson
et al. (2013), to handle such cases:

• M-SELF(r) adds a dependency, with label r be-
tween the item at the front of B and itself. The
result replaces the item at the front of B.

Note that the syntactic and semantic transitions
both operate on the same buffer, though they in-
dependently specify the syntax and semantics, re-
spectively. In order to ensure that both syntactic
and semantic parses are produced, the syntactic
and semantic transitions are interleaved. Only syn-
tactic transitions are considered until a transition is
chosen that copies an item from the buffer front to
the syntactic stack (either S-SHIFT or S-RIGHT).
The algorithm then switches to semantic transi-
tions until a buffer-modifying transition is taken
(M-SHIFT).4 At this point, the buffer is modi-

4Had we moved the item at the buffer front during the
syntactic transitions, it would have been unavailable for the

St
S
(u, u), S

(u, u), S

(u, u), S
S
S
S
S
S
S
S

Mt
M
M

M

Bt
(v, v), B
B

Action
S-SHIFT
S-REDUCE

St+1
(v, v), S
S

(v, v), B

S-RIGHT((cid:96))

(v, v), (gs(u, v, l), u), S

M
M
(u, u), M
(u, u), M
(u, u), M
(u, u), (v, v), M
M
M

(v, v), B
(v, v), B
B
(v, v), B
(v, v), B
B
(v, v), B
(v, v), B

S-LEFT((cid:96))
M-SHIFT
M-REDUCE
M-RIGHT(r)
M-LEFT(r)
M-SWAP
M-PRED(p)
M-SELF(r)

S
S
S
S
S
S
S
S

M

(v, v), B

Mt+1
M
M

M (gs(v, u, l), v), B

Bt+1
(v, v), B
B

Dependency
—
—
S ∪ u (cid:96)→ v
S ∪ u (cid:96)← v
B
—
B
—
M ∪ u r→ v
(v, v), B
(u, u), M (gm(v, u, r), v), B M ∪ u r← v
B
(gd(v, p), v), B

(v, v), (u, u), M
M
M (gm(v, v, r), v), B M ∪ v r↔ v

(v, v), M
M
(gm(u, v, r), u), M

—
—

Table 1: Parser transitions along with the modiﬁcations to the stacks and the buffer resulting from each.
Syntactic transitions are shown above, semantic below. Italic symbols denote symbolic representations
of words and relations, and bold symbols indicate (learned) embeddings (§3.5) of words and relations;
each element in a stack or buffer includes both symbolic and vector representations, either atomic or
recursive. S represents the set of syntactic transitions, and M the set of semantic transitions.

an element to the top of the stack, resulting in a
new summary. Pop, which does not correspond to
a conventional LSTM operation, moves the stack
pointer to the preceding timestep, resulting in a
stack summary as it was before the popped item
was observed. Implementation details (Dyer et al.,
2015; Goldberg, 2015) and code have been made
publicly available.6

Using stack LSTMs, we construct a represen-
tation of the algorithm state by decomposing it
into smaller pieces that are combined by recursive
function evaluations (similar to the way a list is
built by a concatenate operation that operates on a
list and an element). This enables information that
would be distant from the “top” of the stack to be
carried forward, potentially helping the learner.

3.2 Stack LSTMs for Joint Parsing

four

Our algorithm employs
stack LSTMs,
one each for the S, M , and B data struc-
tures.Like Dyer et al. (2015), we use a fourth stack
LSTM, A, for the history of actions—A is never
popped from, only pushed to. Figure 4 illustrates
the architecture. The algorithm’s state at timestep
t is encoded by the four vectors summarizing the
four stack LSTMs, and this is the input to the clas-
siﬁer that chooses among the allowable transitions
at that timestep.

Let st, mt, bt, and at denote the summaries
of St, Mt, Bt, and At, respectively. Let At =
Allowed(St, Mt, Bt, At) denote the allowed tran-
sitions given the current stacks and buffer. The
parser state at time t is given by a rectiﬁed linear
unit (Nair and Hinton, 2010) in vector yt:

where W and d are the parameters of the classi-
ﬁer. The transition selected at timestep t is

arg max
τ ∈At
≡ arg max
τ ∈At

qτ + θτ · yt

(1)

score(τ ; St, Mt, Bt, At)

where θτ and qτ are parameters for each transi-
tion type τ . Note that only allowed transitions are
considered in the decision rule (see §2.3).

3.3 Composition Functions

To use stack LSTMs, we require vector representa-
tions of the elements that are stored in the stacks.
Speciﬁcally, we require vector representations of
atoms (words, possibly with part-of-speech tags)
and parse fragments. Word vectors can be pre-
trained or learned directly; we consider a concate-
nation of both in our experiments; part-of-speech
vectors are learned and concatenated to the same.
To obtain vector representations of parse frag-
ments, we use neural networks which recursively
compute representations of the complex structured
output (Dyer et al., 2015). The tree structures here
are always ternary trees, with each internal node’s
three children including a head, a dependent, and
a label. The vectors for leaves are word vectors
and vectors corresponding to syntactic and seman-
tic relation types.

The vector for an internal node is a squashed
(tanh) afﬁne transformation of its children’s vec-
tors. For syntactic and semantic attachments, re-
spectively, the composition function is:

yt = elementwisemax {0, d + W[st; mt; bt; at]}

6https://github.com/clab/lstm-parser

gs(v, u, l) = tanh(Zs[v; u; l] + es)
gm(v, u, r) = tanh(Zm[v; u; r] + em)

(2)

(3)

d
e
t
c
e
p
x
e

→
−
e
r
a

c
v

1
0
.
t
c
e
p
x
e
−
1
←
A

d
r
p
o

o
t

→
−
d
e
t
c
e
p
x
e

o
t

-

1
→
A
−
C
1
0
.
t
c
e
p
x
e

n
e
p
o
e
r

i

→
m
−
o
t

1
0
.
n
e
p
o
e
r

−
1
←
A

e
r
a
−
←

j
b
s

n
o
o
s

P
M
→
T
−
-
M
A

1
0
.
n
e
p
o
e
r

n
o
o
s

t

→
p
m
−
n
e
p
o
e
r

t
o
o
r

t
o
o
r

−
←

e
r
a

—

—

—

l
l
a

—

—

—

—

l
l
a

—

—

—

—

—

l
l
a

—

—

—

—

—

—

—

—

—

—

—

y
c
n
e
d
n
e
p
e
D

B

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a

,
l
l
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a

,
l
l
a
[

,
o
t

,
o
t

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
o
t

,
d
e
t
c
e
p
x
e
[

,
d
e
t
c
e
p
x
e
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
l
l
a
[

]
l
l
a
[

]
e
r
a
[

]
e
r
a
[

]
[

S

]
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

)
1
0
.
t
c
e
p
x
e
(
D
E
R
P
-
M

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
d
e
t
c
e
p
x
e

,
l
l
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
d
e
t
c
e
p
x
e

,
l
l
a
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
d
e
t
c
e
p
x
e

,
l
l
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
d
r
p
o
(
T
H
G

I

R

-
S
*
*
*

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r

,
o
t
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s

,
n
e
p
o
e
r
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r

,
n
o
o
s
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

]
[

]
[

]
n
o
o
s

,
n
e
p
o
e
r

]
n
o
o
s

,
n
e
p
o
e
r

]
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
o
t

,
o
t

,
o
t

,
o
t

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
d
e
t
c
e
p
x
e

,
e
r
a
[

]
n
e
p
o
e
r
[

]
n
o
o
s

,
n
e
p
o
e
r

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
p
m

t
(
T
H
G

I

R

-
S

]
n
e
p
o
e
r
[

]
n
o
o
s

,
n
e
p
o
e
r

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
P
M
T
-
M
A
(
T
H
G

I

-

R
M

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

]
n
e
p
o
e
r

,
o
t

,
o
t

,
o
t

,
o
t

,
o
t

,
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

]
o
t

,
d
e
t
c
e
p
x
e

,
e
r
a
[

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
1
A
-
C

(
T
H
G

I

-

R
M

E
C
U
D
E
R
M

-

T
F
I

H
S
-
M

)

m

i
(
T
H
G

I

R

-
S

,
d
e
t
c
e
p
x
e

,
e
r
a
[

)
1
0
.
n
e
p
o
e
r
(
D
E
R
P
-
M

]
e
r
a
[

]
[

]
t
o
o
r
[

]
t
o
o
r
[

]
t
o
o
r
[

M

]
[

]
[

]
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
e
r
a

,
l
l
a
[

]
e
r
a

,
l
l
a
[

]
e
r
a

,
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
o
t

,
l
l
a
[

]
o
t

,
l
l
a
[

]
o
t

,
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
l
l
a
[

]
[

]
n
e
p
o
e
r
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
n
o
o
s
[

]
t
o
o
r
[

]
[

)
j
b
s
(
T
F
E
L
-
S

T
F
I

H
S
-
S

T
F
I

H
S
-
M

)
c
v
(
T
H
G

I

R

-
S

T
F
I

H
S
-
S

T
F
I

H
S
-
M

E
C
U
D
E
R
M

-

)
1
A
(
T
F
E
L
-
M

T
F
I

H
S
-
M

n
o
i
t
i
s
n
a
r
T

E
C
U
D
E
R
M

-

)
1
A
(
T
F
E
L
-
M

E
C
U
D
E
R
M

-

T
F
I

H
S
-
M

E
C
U
D
E
R
M

-

E
C
U
D
E
R

-
S

E
C
U
D
E
R

-
S

E
C
U
D
E
R

-
S

E
C
U
D
E
R

-
S

T
F
I

H
S
-
M

)
t
o
o
r
(
T
F
E
L
-
S

E
C
U
D
E
R
M

-

T
F
I

H
S
-
M

T
F
I

H
S
-
S

Figure 3: Joint parser transition sequence for the sentence in Figure 1, “all are expected to reopen soon.”
Syntactic labels are in lower-case and semantic role labels are capitalized. *** marks the operation
predicted in Figure 4.

where v and u are vectors corresponding to atomic
words or composed parse fragments; l and r are
learned vector representations for syntactic and se-
mantic labels respectively. Syntactic and semantic
parameters are separated (Zs, es and Zm, em, re-
spectively).

Finally, for predicates, we use another recur-
sive function to compose the word representa-

tion, v with a learned representation for the dis-
mabiguated sense of the predicate, p:

gd(v, p) = tanh(Zd[v; p] + ed)

(4)

where Zd and ed are parameters of the model.
Note that, because syntactic and semantic transi-
tions are interleaved, the fragmented structures are
a blend of syntactic and semantic compositions.

Figure 4: Stack LSTM for joint parsing. The state
illustrated corresponds to the ***-marked row in
the example transition sequence in Fig. 3.

Figure 5 shows an example.

3.4 Training

Training the classiﬁer requires transforming each
training instance (a joint parse) into a transition se-
quence, a deterministic operation under our tran-
sition set. Given a collection of algorithm states
at time t and correct classiﬁcation decisions τt, we
minimize the sum of log-loss terms, given (for one
timestep) by:

− log

(cid:80)

exp(qτt + θτt · yt)

τ (cid:48)∈At

exp(qτ (cid:48) + θτ (cid:48) · yt)

(5)

with respect to the classiﬁer and LSTM parame-
ters. Note that the loss is differentiable with re-
spect to the parameters; gradients are calculated
using backpropagation. We apply stochastic gra-
dient descent with dropout for all neural network
parameters.

3.5 Pretrained Embeddings

Following Dyer et al. (2015), “structured skip-
gram” embeddings (Ling et al., 2015) were used,
trained on the English (AFP section), German,
Spanish and Chinese Gigaword corpora, with a
window of size 5; training was stopped after 5
epochs. For out-of-vocabulary words, a randomly
initialized vector of the same dimension was used.

3.6 Predicate Sense Disambiguation

Figure 5: Example of a joint parse tree fragment
with vector representations shown at each node.
The vectors are obtained by recursive composition
of representations of head, dependent, and label
vectors. Syntactic dependencies and labels are in
green, semantic in blue.

are lexeme-speciﬁc, we need a way to handle un-
seen predicates at test time. When a predicate is
encountered at test time that was not observed in
training, our system constructs a predicate from
the predicted lemma of the word at that position
and defaults to the “01” sense, which is correct
for 91.22% of predicates by type in the English
CoNLL 2009 training data.

4 Experimental Setup

Our model is evaluated on the CoNLL shared
tasks on joint syntactic and semantic dependency
parsing in 2008 (Surdeanu et al., 2008) and
2009 (Hajiˇc et al., 2009). The standard training,
development and test splits of all datasets were
used. Per the shared task guidelines, automati-
cally predicted POS tags and lemmas provided in
the datasets were used for all experiments. As
a preprocessing step, pseudo-projectivization of
the syntactic trees (Nivre et al., 2007) was used,
which allowed an accurate conversion of even the
non-projective syntactic trees into syntactic transi-
tions. However, the oracle conversion of semantic
parses into transitions is not perfect despite using
the M-SWAP action, due to the presence of multi-
ple crossing arcs.7

The standard evaluation metrics include the
syntactic labeled attachment score (LAS), the se-

Predicate sense disambiguation is handled within
the model (M-PRED transitions), but since senses

7For 1.5% of English sentences in the CoNLL 2009 En-
glish dataset, the transition sequence incorrectly encodes the
gold-standard joint parse; details in Henderson et al. (2013).

mantic F1 score on both in-domain (WSJ) and out-
of-domain (Brown corpus) data, and their macro
average (Macro F1) to score joint systems. Be-
cause the task was deﬁned somewhat differently
in each year, each dataset is considered in turn.

4.1 CoNLL 2008

The CoNLL 2008 dataset contains annotations
from the Penn Treebank (Marcus et al., 1993),
PropBank (Palmer et al., 2005) and Nom-
Bank (Meyers et al., 2004). The shared task evalu-
ated systems on predicate identiﬁcation in addition
to predicate sense disambiguation and SRL.

To identify predicates, we trained a zero-
Markov order bidirectional LSTM two-class clas-
siﬁer. As input to the classiﬁer, we use learned rep-
resentations of word lemmas and POS tags. This
model achieves an F1 score of 91.43% on marking
words as predicates (or not).

Hyperparameters The input representation for
a word consists of pretrained embeddings (size
100 for English, 80 for Chinese, 64 for Ger-
man and Spanish), concatenated with additional
learned word and POS tag embeddings (size 32
and 12, respectively). Learned embeddings for
syntactic and semantic arc labels are of size 20
and predicates 100. Two-layer LSTMs with hid-
den state dimension 100 were used for each of the
four stacks. The parser state yt and the composi-
tion function g are of dimension 100. A dropout
rate of 0.2 (Zaremba et al., 2014) was used on all
layers at training time, tuned on the development
data from the set of values {0.1, 0.2, 0.3, 1.0}. The
learned representations for actions are of size 100,
similarly tuned from {10, 20, 30, 40, 100}. Other
hyperparameters have been set intuitively; careful
tuning is expected to yield improvements (Weiss
et al., 2015).

An initial learning rate of 0.1 for stochastic gra-
dient descent was used and updated in every train-
ing epoch with a decay rate of 0.1 (Dyer et al.,
2015). Training is stopped when the development
performance does not improve for approximately
6–7 hours of elapsed time. Experiments were run
on a single thread on a CPU, with memory require-
ments of up to 512 MB.

4.2 CoNLL 2009

Relative to the CoNLL 2008 task (above), the
main change in 2009 is that predicates are pre-
identiﬁed, and systems are only evaluated on pred-

icate sense disambiguation (not
identiﬁcation).
Hence, the bidirectional LSTM classiﬁer is not
used here. The preprocessing for projectivity, and
the hyperparameter selection is the same as in
§4.1.

In addition to the joint approach described in
the preceding sections, we experiment here with
several variants:

Semantics-only:
the set of syntactic transitions
S, the syntactic stack S, and the syntactic compo-
sition function gs are discarded. As a result, the set
of constraints on transitions is a subset of the full
set of constraints in §2.3. Effectively, this model
does not use any syntactic features, similar to Col-
lobert et al. (2011) and Zhou and Xu (2015). It
provides a controlled test of the beneﬁt of explicit
syntax in a semantic parser.

all semantic transitions in M, the
Syntax-only:
semantic stack M , and the semantic composition
function gm are discarded. S-SHIFT and S-RIGHT
now move the item from the front of the buffer to
the syntactic stack, instead of copying. The set of
constraints on the transitions is again a subset of
the full set of constraints. This model is an arc-
eager variant of Dyer et al. (2015), and serves to
check whether semantic parsing degrades syntac-
tic performance.

Hybrid:
the semantics parameters are trained
using automatically predicted syntax from the
syntax-only model. At test time, only seman-
tic parses are predicted. This setup bears simi-
larity to other approaches which pipeline syntax
and semantics, extracting features from the syn-
tactic parse to help SRL. However, unlike other
approaches, this model does not offer the entire
syntactic tree for feature extraction, since only the
partial syntactic structures present on the syntactic
stack (and potentially the buffer) are visible at a
given timestep. This model helps show the effect
of joint prediction.

5 Results and Discussion

CoNLL 2008 (Table 2) Our joint model signif-
icantly outperforms the joint model of Hender-
son et al. (2008), from which our set of tran-
sitions is derived, showing the beneﬁt of learn-
ing a representation for the entire algorithmic
state. Several other joint learning models have
been proposed (Llu´ıs and M`arquez, 2008; Jo-
hansson, 2009; Titov et al., 2009) for the same

Model

joint models:
Llu´ıs and M`arquez (2008)
Henderson et al. (2008)
Johansson (2009)
Titov et al. (2009)
CoNLL 2008 best:
#3: Zhao and Kit (2008)
#2: Che et al. (2008)
#2: Ciaramita et al. (2008)
#1: J&N (2008)
Joint (this work)

LAS

Sem. Macro
F1

F1

85.8
87.6
86.6
87.5

87.7
86.7
87.4
89.3
89.1

70.3
73.1
77.1
76.1

76.7
78.5
78.0
81.6
80.5

78.1
80.5
81.8
81.8

82.2
82.7
82.7
85.5
84.9

Table 2: Joint parsers: comparison on the CoNLL
2008 test (WSJ+Brown) set.

task; our joint model surpasses the performance
of all these models. The best reported systems on
the CoNLL 2008 task are due to Johansson and
Nugues (2008), Che et al. (2008), Ciaramita et
al. (2008) and Zhao and Kit (2008), all of which
pipeline syntax and semantics; our system’s se-
mantic and overall performance is comparable to
these. We fall behind only Johansson and Nugues
(2008), whose success was attributed to carefully
designed global SRL features integrated into a
pipeline of classiﬁers, making them asymptoti-
cally slower.

CoNLL 2009 English (Table 3) All of our
models (Syntax-only, Semantics-only, Hybrid and
Joint) improve over Gesmundo et al.
(2009)
and Henderson et al. (2013), demonstrating the
beneﬁt of our entire-parser-state representation
learner compared to the more locally scoped
model.

Given that syntax has consistently proven useful
in SRL, we expected our Semantics-only model
to underperform Hybrid and Joint, and it did. In
the training domain, syntax and semantics bene-
ﬁt each other (Joint outperforms Hybrid). Out-
of-domain (the Brown test set), the Hybrid pulls
ahead, a sign that Joint overﬁts to WSJ. As a
syntactic parser, our Syntax-only model performs
slightly better than Dyer et al. (2015), who achieve
89.56 LAS on this task.
Joint parsing is very
slightly better still.

The overall performance of Joint is on par with
the other winning participants at the CoNLL 2009
shared task (Zhao et al., 2009; Che et al., 2009;
Gesmundo et al., 2009), falling behind only Zhao
et al. (2009), who carefully designed language-

speciﬁc features and used a series of pipelines for
the joint task, resulting in an accurate but compu-
tationally expensive system.

State-of-the-art SRL systems (shown in the last
block of Table 3) which use advances orthog-
onal to the contributions in this paper, perform
better than our models. Many of these systems
use expert-crafted features derived from full syn-
tactic parses in a pipeline of classiﬁers followed
by a global reranker (Bj¨orkelund et al., 2009;
Bj¨orkelund et al., 2010; Roth and Woodsend,
2014); we have not used these features or rerank-
ing. Lei et al. (2015) use syntactic parses to obtain
interaction features between predicates and their
arguments and then compress feature representa-
tions using a low-rank tensor. T¨ackstr¨om et al.
(2015) present an exact inference algorithm for
SRL based on dynamic programming and their lo-
cal and structured models make use of many syn-
tactic features from a pipeline; our search pro-
cedure is greedy. Their algorithm is adopted
by FitzGerald et al. (2015) for inference in a model
that jointly learns representations from a combina-
tion of PropBank and FrameNet annotations; we
have not experimented with extra annotations.

Our system achieves an end-to-end runtime of
177.6±18 seconds to parse the CoNLL 2009 En-
glish test set on a single core. This is almost 2.5
times faster than the pipeline model of Lei et al.
(2015) (439.9±42 seconds) on the same machine.8

CoNLL 2009 Multilingual (Table 4) We tested
the joint model on the non-English CoNLL 2009
datasets, and the results demonstrate that it adapts
easily—it is on par with the top three systems in
most cases. We note that our Chinese parser relies
on pretrained word embeddings for its superior
performance; without them (not shown), it was on
par with the others. Japanese is a small-data case
(4,393 training examples), illustrating our model’s
dependence on reasonably large training datasets.
We have not extended our model to incorporate
morphological features, which are used by the sys-
tems to which we compare. Future work might in-
corporate morphological features where available;
this could potentially improve performance, espe-
cially in highly inﬂective languages like Czech.
An alternative might be to infer word-internal rep-
resentations using character-based word embed-

8See

SRLParser; unlike other state-of-the-art systems,
one is publicly available.

https://github.com/taolei87/
this

Model

LAS

Sem. F1
(WSJ)

Sem. F1
(Brown)

Macro
F1

88.79
88.48
89.19

89.83

89.83
89.94

CoNLL’09 best:
#3 G+ ’09
#2 C+ ’09
#1 Z+ ’09a
this work:
Syntax-only
Sem.-only
Hybrid
Joint
pipelines:
R&W ’14
L+ ’15
T+ ’15
F+ ’15

83.24
85.51
86.15

84.39
84.58
84.97

86.34
86.58
87.30
87.80

70.65
73.82
74.58

86.03
87.00
87.69

87.20
87.45

73.87
75.64
74.48

75.90
75.57
75.50
75.50

Table 3: Comparison on the CoNLL 2009 English
test set. The ﬁrst block presents results of other
models evaluated for both syntax and semantics on
the CoNLL 2009 task. The second block presents
our models. The third block presents the best pub-
lished models, each using its own syntactic pre-
processing.

dings, which was found beneﬁcial for syntactic
parsing (Ballesteros et al., 2015).

Language
Catalan
Chinese
Czech
English
German
Japanese
Spanish
Average

#1 C+’09
81.84
76.38
83.27
87.00
82.44
85.65
81.90
82.64

#2 Z+ ’09a
83.01
76.23
80.87
87.69
81.22
85.28
83.31
82.52

#3 G+ ’09
82.66
76.15
83.21
86.03
79.59
84.91
82.43
82.14

Joint
82.40
79.27
79.53
87.45
81.05
80.91
83.11
81.96

Table 4: Comparison of macro F1 scores on the
multilingual CoNLL 2009 test set.

6 Related Work

Other approaches to joint modeling, not consid-
ered in our experiments, are notable. Llu´ıs et al.
(2013) propose a graph-based joint model using
dual decomposition for agreement between syn-
tax and semantics, but do not achieve competi-
tive performance on the CoNLL 2009 task. Lewis
et al. (2015) proposed an efﬁcient joint model for
CCG syntax and SRL, which performs better than
a pipelined model. However, their training neces-
sitates CCG annotation, ours does not. Moreover,
their evaluation metric rewards semantic depen-
dencies regardless of where they attach within the
argument span given by a PropBank constituent,

making direct comparison to our evaluation infea-
sible. Krishnamurthy and Mitchell (2014) pro-
pose a joint CCG parsing and relation extraction
model which improves over pipelines, but their
task is different from ours. Li et al. (2010) also
perform joint syntactic and semantic dependency
parsing for Chinese, but do not report results on
the CoNLL 2009 dataset.

There has also been an increased interest in
models which use neural networks for SRL. Col-
lobert et al. (2011) proposed models which per-
form many NLP tasks without hand-crafted fea-
tures. Though they did not achieve the best results
on the constituent-based SRL task (Carreras and
M`arquez, 2005), their approach inspired Zhou and
Xu (2015), who achieved state-of-the-art results
using deep bidirectional LSTMs. Our approach
for dependency-based SRL is not directly compa-
rable.

7 Conclusion

We presented an incremental, greedy parser for
joint syntactic and semantic dependency parsing.
Our model surpasses the performance of previous
joint models on the CoNLL 2008 and 2009 En-
glish tasks, without using expert-crafted, expen-
sive features of the full syntactic parse.

Acknowledgments

The authors thank Sam Thomson, Lingpeng Kong,
Mark Yatskar, Eunsol Choi, George Mulcaire, and
Luheng He, as well as the anonymous review-
ers, for many useful comments. This research
was supported in part by DARPA grant FA8750-
12-2-0342 funded under the DEFT program and
by the U.S. Army Research Ofﬁce under grant
number W911NF-10-1-0533. Any opinion, ﬁnd-
ings, and conclusions or recommendations ex-
pressed in this material are those of the author(s)
and do not necessarily reﬂect the view of the
U.S. Army Research Ofﬁce or the U.S. Govern-
ment. Miguel Ballesteros was supported by the
European Commission under the contract num-
bers FP7-ICT-610411 (project MULTISENSOR)
and H2020-RIA-645012 (project KRISTINA).

References

[Ballesteros and Nivre2013] Miguel Ballesteros

and
Joakim Nivre. 2013. Going to the roots of de-
Computational Linguistics,
pendency parsing.
39(1):5–13.

[Ballesteros et al.2015] Miguel Ballesteros, Chris Dyer,
Improved transition-
and Noah A. Smith. 2015.
based parsing by modeling characters instead of
words with LSTMs. In Proc. of EMNLP.

[Bj¨orkelund et al.2009] Anders Bj¨orkelund,

Love
Hafdell, and Pierre Nugues. 2009. Multilingual
semantic role labeling. In Proc. of CoNLL.

[Bj¨orkelund et al.2010] Anders Bj¨orkelund,

Bernd
Bohnet, Love Hafdell, and Pierre Nugues. 2010.
A high-performance syntactic and semantic depen-
dency parser. In Proc. of COLING.

[Carreras and M`arquez2005] Xavier Carreras and Llu´ıs
Introduction to the CoNLL-2005
In Proc. of

M`arquez. 2005.
shared task: Semantic role labeling.
CoNLL.

[Che et al.2008] Wanxiang Che, Zhenghua Li, Yuxuan
Hu, Yongqiang Li, Bing Qin, Ting Liu, and Sheng
Li. 2008. A cascaded syntactic and semantic de-
pendency parsing system. In Proc. of CoNLL.

[Che et al.2009] Wanxiang

Li,
Zhenghua
and
Yongqiang Li, Yuhang Guo, Bing Qin,
Ting Liu. 2009. Multilingual dependency-based
syntactic and semantic parsing. In Proc. of CoNLL.

Che,

[Ciaramita et al.2008] Massimiliano

Ciaramita,
Giuseppe Attardi, Felice Dell’Orletta, and Mi-
hai Surdeanu.
DeSRL: A linear-time
semantic role labeling system. In Proc. of CoNLL.

2008.

[Collobert et al.2011] Ronan Collobert, Jason Weston,
L´eon Bottou, Michael Karlen, Koray Kavukcuoglu,
and Pavel Kuksa.
2011. Natural language pro-
cessing (almost) from scratch. Journal of Machine
Learning Research, 12:2493–2537.

[Dyer et al.2015] Chris Dyer, Miguel Ballesteros,
Wang Ling, Austin Matthews, and Noah A. Smith.
2015. Transition-based dependency parsing with
stack long short-term memory. In Proc. of ACL.

[FitzGerald et al.2015] Nicholas FitzGerald, Oscar
T¨ackstr¨om, Kuzman Ganchev, and Dipanjan Das.
2015. Semantic role labelling with neural network
factors. In Proc. of EMNLP.

[Foland and Martin2015] William R. Foland and James
2015. Dependencybased semantic role
In

Martin.
labeling using convolutional neural networks.
Proc. of *SEM.

[Gesmundo et al.2009] Andrea Gesmundo, James Hen-
derson, Paola Merlo, and Ivan Titov. 2009. A latent
variable model of synchronous syntactic-semantic
parsing for multiple languages. In Proc. of CoNLL.

[Gildea and Jurafsky2002] Daniel Gildea and Daniel
Jurafsky. 2002. Automatic labeling of semantic
roles. Computational Linguistics, 28(3):245–288.

[Graves2013] Alex Graves.

Generat-
ing sequences with recurrent neural networks.
arXiv:1308.0850.

2013.

[Hajiˇc et al.2009] Jan Hajiˇc, Massimiliano Cia-
ramita, Richard Johansson, Daisuke Kawahara,
Maria Ant`onia Mart´ı, Llu´ıs M`arquez, Adam Mey-
ers, Joakim Nivre, Sebastian Pad´o, Jan ˇStˇep´anek,
Pavel Straˇn´ak, Mihai Surdeanu, Nianwen Xue, and
Yi Zhang. 2009. The CoNLL-2009 shared task:
Syntactic and semantic dependencies in multiple
languages. In Proc. of CoNLL.

[He et al.2013] He He, Hal Daum´e III, and Jason Eis-
ner. 2013. Dynamic feature selection for depen-
dency parsing. In Proc. of EMNLP.

[Henderson et al.2008] James Henderson, Paola Merlo,
Gabriele Musillo, and Ivan Titov. 2008. A latent
variable model of synchronous parsing for syntactic
and semantic dependencies. In Proc. of CoNLL.

[Henderson et al.2013] James Henderson, Paola Merlo,
Ivan Titov, and Gabriele Musillo. 2013. Multi-
lingual joint parsing of syntactic and semantic de-
pendencies with a latent variable model. Computa-
tional Linguistics, 39(4):949–998.

[Hochreiter and Schmidhuber1997] Sepp Hochreiter
and J¨urgen Schmidhuber. 1997. Long short-term
memory. Neural Computation, 9(8):1735–1780.

[Johansson and Nugues2008] Richard Johansson and
Pierre Nugues. 2008. Dependency-based syntactic-
semantic analysis with PropBank and NomBank. In
Proc. of CoNLL.

[Johansson2009] Richard Johansson. 2009. Statistical
bistratal dependency parsing. In Proc. of EMNLP.

[Krishnamurthy and Mitchell2014] Jayant

Krishna-
murthy and Tom M. Mitchell. 2014. Joint syntactic
and semantic parsing with combinatory categorial
grammar. In Proc. of ACL.

[Lei et al.2015] Tao Lei, Yuan Zhang, Llu´ıs M`arquez
i Villodre, Alessandro Moschitti, and Regina Barzi-
lay. 2015. High-order low-rank tensors for semantic
role labeling. In Proc. of NAACL.

[Lewis et al.2015] Mike Lewis, Luheng He, and Luke
Zettlemoyer. 2015. Joint A* CCG parsing and se-
mantic role labelling. In Proc. of EMNLP.

[Li et al.2010] Junhui Li, Guodong Zhou,

Hwee Tou Ng.
2010.
mantic parsing of Chinese. In Proc. of ACL.

and
Joint syntactic and se-

[Ling et al.2015] Wang Ling, Chris Dyer, Alan Black,
and Isabel Trancoso. 2015. Two/too simple adapta-
tions of word2vec for syntax problems. In Proc. of
NAACL.

[Goldberg2015] Yoav Goldberg. 2015. A primer on
neural network models for natural language process-
ing. arXiv:1510.00726.

[Llu´ıs and M`arquez2008] Xavier Llu´ıs

and Llu´ıs
M`arquez. 2008. A joint model for parsing syntactic
and semantic dependencies. In Proc. of CoNLL.

[Llu´ıs et al.2013] Xavier Llu´ıs, Xavier Carreras, and
Llu´ıs M`arquez. 2013. Joint arc-factored parsing of
syntactic and semantic dependencies. Transactions
of the ACL, 1:219–230.

[Toutanova et al.2008] Kristina

Aria
Toutanova,
2008.
Haghighi, and Christopher D. Manning.
A global joint model for semantic role labeling.
Computational Linguistics, 34(2):161–191.

[Weiss et al.2015] David Weiss, Chris Alberti, Michael
Collins, and Slav Petrov. 2015. Structured train-
ing for neural network transition-based parsing. In
Proc. of ACL.

[Zaremba et al.2014] Wojciech

Sutskever, and Oriol Vinyals.
neural network regularization. arXiv:1409.2329.

Ilya
Zaremba,
2014. Recurrent

[Zhao and Kit2008] Hai Zhao and Chunyu Kit. 2008.
Parsing syntactic and semantic dependencies with
two single-stage maximum entropy models. In Proc.
of CoNLL.

[Zhao et al.2009] Hai Zhao, Wenliang Chen, Jun’ichi
Kazama, Kiyotaka Uchimoto, and Kentaro Tori-
sawa. 2009. Multilingual dependency learning: Ex-
ploiting rich features for tagging syntactic and se-
mantic dependencies. In Proc. of CoNLL.

[Zhou and Xu2015] Jie Zhou and Wei Xu. 2015. End-
to-end learning of semantic role labeling using re-
current neural networks. In Proc. of ACL.

[Marcus et al.1993] Mitchell P. Marcus, Mary Ann
1993.
Marcinkiewicz, and Beatrice Santorini.
Building a large annotated corpus of English:
The Penn treebank. Computational Linguistics,
19(2):313–330.

[Meyers et al.2004] Adam Meyers, Ruth Reeves,
Catherine Macleod, Rachel Szekely, Veronika
Zielinska, Brian Young, and Ralph Grishman. 2004.
The NomBank project: An interim report. In Proc.
of NAACL.

[Nair and Hinton2010] Vinod Nair and Geoffrey E.
Hinton. 2010. Rectiﬁed linear units improve re-
stricted Boltzmann machines. In Proc. of ICML.

[Nivre et al.2007] Joakim Nivre, Johan Hall, Jens Nils-
son, Atanas Chanev, G¨ulsen Eryigit, Sandra K¨ubler,
Svetoslav Marinov, and Erwin Marsi. 2007. Malt-
Parser: A language-independent system for data-
driven dependency parsing. Natural Language En-
gineering, 13:95–135.

[Nivre2008] Joakim Nivre. 2008. Algorithms for de-
terministic incremental dependency parsing. Com-
putational Linguistics, 34(4):513–553.

[Nivre2009] Joakim Nivre. 2009. Non-projective de-
pendency parsing in expected linear time. In Proc.
of ACL.

[Palmer et al.2005] Martha Palmer, Daniel Gildea, and
Paul Kingsbury. 2005. The Proposition Bank: An
annotated corpus of semantic roles. Computational
Linguistics, 31(1):71–106.

[Roth and Woodsend2014] Michael Roth and Kristian
Woodsend. 2014. Composition of word represen-
tations improves semantic role labelling. In Proc. of
EMNLP.

[Surdeanu et al.2008] Mihai Surdeanu, Richard Johans-
son, Adam Meyers, Llu´ıs M`arquez, and Joakim
Nivre. 2008. The CoNLL-2008 shared task on joint
parsing of syntactic and semantic dependencies. In
Proc. of CoNLL.

[Sutton and McCallum2005] Charles Sutton and An-
drew McCallum. 2005. Joint parsing and semantic
role labeling. In Proc. of CoNLL.

[T¨ackstr¨om et al.2015] Oscar T¨ackstr¨om, Kuzman
Efﬁcient
Ganchev, and Dipanjan Das.
inference and structured learning for semantic role
labeling. Transactions of the ACL, 3:29–41.

2015.

[Titov et al.2009] Ivan Titov, James Henderson, Paola
Merlo, and Gabriele Musillo. 2009. Online graph
planarisation for synchronous parsing of semantic
and syntactic dependencies. In Proc. of IJCAI.

