Multilingual Part-of-Speech Tagging with
Bidirectional Long Short-Term Memory Models and Auxiliary Loss

Barbara Plank
University of Groningen
The Netherlands
b.plank@rug.nl

Anders Søgaard
University of Copenhagen
Denmark
soegaard@hum.ku.dk

Yoav Goldberg
Bar-Ilan University
Israel
yoav.goldberg@gmail.com

6
1
0
2
 
l
u
J
 
1
2
 
 
]
L
C
.
s
c
[
 
 
3
v
9
2
5
5
0
.
4
0
6
1
:
v
i
X
r
a

Abstract

Bidirectional long short-term memory (bi-
LSTM) networks have recently proven
successful for various NLP sequence mod-
eling tasks, but
little is known about
their reliance to input representations, tar-
get languages, data set size, and label
noise. We address these issues and eval-
uate bi-LSTMs with word, character, and
unicode byte embeddings for POS tag-
ging. We compare bi-LSTMs to tradi-
tional POS taggers across languages and
data sizes. We also present a novel bi-
LSTM model, which combines the POS
tagging loss function with an auxiliary
loss function that accounts for rare words.
The model obtains state-of-the-art perfor-
mance across 22 languages, and works es-
pecially well for morphologically complex
languages. Our analysis suggests that bi-
LSTMs are less sensitive to training data
size and label corruptions (at small noise
levels) than previously assumed.

1

Introduction

Recently, bidirectional long short-term memory
networks (bi-LSTM) (Graves and Schmidhuber,
2005; Hochreiter and Schmidhuber, 1997) have
been used for language modelling (Ling et al.,
2015), POS tagging (Ling et al., 2015; Wang
et al., 2015), transition-based dependency pars-
ing (Ballesteros et al., 2015; Kiperwasser and
Goldberg, 2016), ﬁne-grained sentiment analysis
(Liu et al., 2015), syntactic chunking (Huang et
al., 2015), and semantic role labeling (Zhou and
Xu, 2015). LSTMs are recurrent neural networks
(RNNs) in which layers are designed to prevent
vanishing gradients. Bidirectional LSTMs make a
backward and forward pass through the sequence

before passing on to the next layer. For further de-
tails, see (Goldberg, 2015; Cho, 2015).

We consider using bi-LSTMs for POS tagging.
Previous work on using deep learning-based meth-
ods for POS tagging has focused either on a sin-
gle language (Collobert et al., 2011; Wang et al.,
2015) or a small set of languages (Ling et al.,
Instead we
2015; Santos and Zadrozny, 2014).
evaluate our models across 22 languages. In ad-
dition, we compare performance with represen-
tations at different levels of granularity (words,
characters, and bytes). These levels of represen-
tation were previously introduced in different ef-
forts (Chrupała, 2013; Zhang et al., 2015; Ling
et al., 2015; Santos and Zadrozny, 2014; Gillick
et al., 2016; Kim et al., 2015), but a comparative
evaluation was missing.

Moreover, deep networks are often said to re-
quire large volumes of training data. We investi-
gate to what extent bi-LSTMs are more sensitive
to the amount of training data and label noise than
standard POS taggers.

Finally, we introduce a novel model, a bi-LSTM
trained with auxiliary loss. The model jointly pre-
dicts the POS and the log frequency of the word.
The intuition behind this model is that the aux-
iliary loss, being predictive of word frequency,
helps to differentiate the representations of rare
and common words. We indeed observe perfor-
mance gains on rare and out-of-vocabulary words.
These performance gains transfer into general im-
provements for morphologically rich languages.

Contributions
In this paper, we a) evaluate the
effectiveness of different representations in bi-
LSTMs, b) compare these models across a large
set of languages and under varying conditions
(data size, label noise) and c) propose a novel bi-
LSTM model with auxiliary loss (LOGFREQ).

2 Tagging with bi-LSTMs

Recurrent neural networks (RNNs) (Elman, 1990)
allow the computation of ﬁxed-size vector repre-
sentations for word sequences of arbitrary length.
An RNN is a function that reads in n vectors
x1, ..., xn and produces an output vector hn, that
depends on the entire sequence x1, ..., xn. The
vector hn is then fed as an input to some classi-
ﬁer, or higher-level RNNs in stacked/hierarchical
models. The entire network is trained jointly such
that the hidden representation captures the impor-
tant information from the sequence for the predic-
tion task.

A bidirectional recurrent neural network (bi-
RNN) (Graves and Schmidhuber, 2005) is an ex-
tension of an RNN that reads the input sequence
twice, from left to right and right to left, and the
encodings are concatenated. The literature uses
the term bi-RNN to refer to two related architec-
tures, which we refer to here as “context bi-RNN”
and “sequence bi-RNN”. In a sequence bi-RNN
(bi-RNNseq), the input is a sequence of vectors
x1:n and the output is a concatenation (◦) of a for-
ward (f ) and reverse (r) RNN each reading the
sequence in a different directions:

v = bi-RNNseq(x1:n) = RNNf (x1:n) ◦ RNNr(xn:1)

In a context bi-RNN (bi-RNNctx), we get an addi-
tional input i indicating a sequence position, and
the resulting vectors vi result from concatenating
the RNN encodings up to i:

vi = bi-RNNctx(x1:n, i) = RNNf (x1:i) ◦ RNNr(xn:i)

Thus, the state vector vi in this bi-RNN encodes
information at position i and its entire sequential
context. Another view of the context bi-RNN is
of taking a sequence x1:n and returning the corre-
sponding sequence of state vectors v1:n.

LSTMs (Hochreiter and Schmidhuber, 1997)
are a variant of RNNs that replace the cells of
RNNs with LSTM cells that were designed to pre-
vent vanishing gradients. Bidirectional LSTMs
are the bi-RNN counterpart based on LSTMs.

Our basic bi-LSTM tagging model is a context
bi-LSTM taking as input word embeddings (cid:126)w. We
incorporate subtoken information using an hierar-
chical bi-LSTM architecture (Ling et al., 2015;
Ballesteros et al., 2015). We compute subtoken-
level (either characters (cid:126)c or unicode byte(cid:126)b) embed-
dings of words using a sequence bi-LSTM at the

lower level. This representation is then concate-
nated with the (learned) word embeddings vector
(cid:126)w which forms the input to the context bi-LSTM at
the next layer. This model, illustrated in Figure 1
(lower part in left ﬁgure), is inspired by Balles-
teros et al. (2015). We also test models in which
we only keep sub-token information, e.g., either
both byte and character embeddings (Figure 1,
right) or a single (sub-)token representation alone.

Figure 1: Right: bi-LSTM, illustrated with (cid:126)b + (cid:126)c
(bytes and characters), for (cid:126)w + (cid:126)c replace (cid:126)b with
words (cid:126)w. Left: FREQBIN, our multi-task bi-
LSTM that predicts at every time step the tag and
the frequency class for the token.

In our novel model, cf. Figure 1 left, we train
the bi-LSTM tagger to predict both the tags of the
sequence, as well as a label that represents the
log frequency of the token as estimated from the
training data. Our combined cross-entropy loss
is now: L( ˆyt, yt) + L( ˆya, ya), where t stands for
a POS tag and a is the log frequency label, i.e.,
a = int(log(f reqtrain(w)). Combining this log
frequency objective with the tagging task can be
seen as an instance of multi-task learning in which
the labels are predicted jointly. The idea behind
this model is to make the representation predictive
for frequency, which encourages the model to not
share representations between common and rare
words, thus beneﬁting the handling of rare tokens.

3 Experiments

All bi-LSTM models were implemented in
CNN/pycnn,1 a ﬂexible neural network library.
For all models we use the same hyperparameters,
which were set on English dev, i.e., SGD train-
ing with cross-entropy loss, no mini-batches, 20

1https://github.com/clab/cnn

epochs, default learning rate (0.1), 128 dimensions
for word embeddings, 100 for character and byte
embeddings, 100 hidden states and Gaussian noise
with σ=0.2. As training is stochastic in nature, we
use a ﬁxed seed throughout. Embeddings are not
initialized with pre-trained embeddings, except
when reported otherwise. In that case we use off-
the-shelf polyglot embeddings (Al-Rfou et al.,
2013).2 No further unlabeled data is considered
in this paper. The code is released at: https:
//github.com/bplank/bilstm-aux

Taggers We want to compare POS taggers un-
der varying conditions. We hence use three dif-
ferent types of taggers: our implementation of a
bi-LSTM; TNT (Brants, 2000)—a second order
HMM with sufﬁx trie handling for OOVs. We use
TNT as it was among the best performing taggers
evaluated in Horsmann et al. (2015).3 We comple-
ment the NN-based and HMM-based tagger with
a CRF tagger, using a freely available implemen-
tation (Plank et al., 2014) based on crfsuite.

3.1 Datasets

For the multilingual experiments, we use the
data from the Universal Dependencies project
v1.2 (Nivre et al., 2015) (17 POS) with the canon-
ical data splits. For languages with token segmen-
tation ambiguity we use the provided gold seg-
mentation.
If there is more than one treebank
per language, we use the treebank that has the
canonical language name (e.g., Finnish instead of
Finnish-FTB). We consider all languages that have
at least 60k tokens and are distributed with word
forms, resulting in 22 languages. We also re-
port accuracies on WSJ (45 POS) using the stan-
dard splits (Collins, 2002; Manning, 2011). The
overview of languages is provided in Table 1.

3.2 Results

Our results are given in Table 2. First of all, no-
tice that TNT performs remarkably well across the
22 languages, closely followed by CRF. The bi-
LSTM tagger ( (cid:126)w) without lower-level bi-LSTM
for subtokens falls short, outperforms the tradi-
tional taggers only on 3 languages. The bi-LSTM

2https://sites.google.com/site/rmyeid/

projects/polyglot

3They found TreeTagger was closely followed by Hun-
Pos, a re-implementation of TnT, and Stanford and ClearNLP
were lower ranked. In an initial investigation, we compared
Tnt, HunPos and TreeTagger and found Tnt to be consistently
better than Treetagger, Hunpos followed closely but crashed
on some languages (e.g., Arabic).

COARSE

FINE

COARSE

FINE

non-IE
ar
Indoeuropean
bg
Indoeuropean
cs
Indoeuropean
da
Indoeuropean
de
Indoeuropean
en
Indoeuropean
es
eu Language isolate
Indoeuropean
fa
non-IE
ﬁ
Indoeuropean
fr

Semitic
Slavic
Slavic
Germanic
Germanic
Germanic
Romance

Indo-Iranian
Uralic
Romance

he
hi
hr
id
it
nl
no
pl
pt
sl
sv

Austronesian

Semitic
Indo-Iranian

non-IE
Indoeuropean
Indoeuropean Slavic
non-IE
Indoeuropean Romance
Indoeuropean Germanic
Indoeuropean Germanic
Indoeuropean Slavic
Indoeuropean Romance
Indoeuropean Slavic
Indoeuropean Germanic

Table 1: Grouping of languages.

model clearly beneﬁts from character representa-
tions. The model using characters alone ((cid:126)c) works
remarkably well, it improves over TNT on 9 lan-
guages (incl. Slavic and Nordic languages). The
combined word+character representation model is
the best representation, outperforming the baseline
on all except one language (Indonesian), provid-
ing strong results already without pre-trained em-
beddings. This model ( (cid:126)w + (cid:126)c) reaches the biggest
improvement (more than +2% accuracy) on He-
brew and Slovene. Initializing the word embed-
dings (+POLYGLOT) with off-the-shelf language-
speciﬁc embeddings further improves accuracy.
The only system we are aware of that evaluates on
UD is Gillick et al. (2016) (last column). However,
note that these results are not strictly comparable
as they use the earlier UD v1.1 version.

The overall best system is the multi-task bi-
LSTM FREQBIN (it uses (cid:126)w + (cid:126)c and POLYGLOT
initialization for (cid:126)w). While on macro average it
is on par with bi-LSTM (cid:126)w + (cid:126)c, it obtains the best
results on 12/22 languages, and it is successful in
predicting POS for OOV tokens (cf. Table 2 OOV
ACC columns), especially for languages like Ara-
bic, Farsi, Hebrew, Finnish.

We examined simple RNNs and conﬁrm the
ﬁnding of Ling et al. (2015) that they performed
worse than their LSTM counterparts. Finally, the
bi-LSTM tagger is competitive on WSJ, cf. Ta-
ble 3.

Rare words
In order to evaluate the effect of
modeling sub-token information, we examine ac-
curacy rates at different frequency rates. Figure 2
shows absolute improvements in accuracy of bi-
LSTM (cid:126)w + (cid:126)c over mean log frequency, for dif-
ferent language families. We see that especially
for Slavic and non-Indoeuropean languages, hav-
ing high morphologic complexity, most of the im-
provement is obtained in the Zipﬁan tail. Rare to-
kens beneﬁt from the sub-token representations.

BASELINES
CRF
TNT

BI-LSTM using:
(cid:126)c + (cid:126)b

(cid:126)c

(cid:126)w

(cid:126)w + (cid:126)c

(cid:126)w + (cid:126)c +POLYGLOT
bi-LSTM FREQBIN bi-LSTM FREQBIN

OOV ACC

avg

94.61

94.27

96.00†

94.29

94.01

92.37

Indoeur.
non-Indo.
Germanic
Romance
Slavic

ar
bg
cs
da
de
en
es
eu
fa
ﬁ
fr
he
hi
hr
id
it
nl
no
pl
pt
sl
sv

94.70
94.57
93.27
95.37
95.64

97.82
96.84
96.82
94.29
92.64
92.66
94.55
93.35
95.98
93.59
94.51
93.71
94.53
94.06
93.16
96.16
88.54
96.31
95.57
96.27
94.92
95.19

94.58
93.62
93.21
95.53
94.96

97.56
96.36
96.56
93.83
91.38
93.35
94.23
91.63
95.65
90.32
95.14
93.63
96.00
93.16
92.96
96.43
90.03
96.21
93.96
96.32
94.77
94.45

96.15†
95.67†
95.09†
96.51†
96.91†

98.91
98.02
97.80
96.19
92.64
94.46
95.12
94.70
97.19
94.85
95.80
95.79
96.23
94.76
93.11
97.59
93.32
97.57
96.41
97.53
97.55
96.36

94.58
93.51
92.89
94.76
96.45

98.68
97.89
96.38
95.12
90.02
91.62
93.06
92.48
95.82
90.25
94.39
93.74
93.40
95.32
91.37
95.62
89.11
95.87
95.80
95.96
96.87
95.57

94.28
93.16
92.59
94.49
96.26

98.43
97.78
96.08
94.88
90.11
91.57
92.29
92.72
95.03
89.15
93.69
93.58
92.99
94.47
91.46
95.77
87.74
95.75
96.19
96.20
96.77
95.50

92.72
91.97
91.18
94.71
91.79

95.48
95.12
93.77
91.96
90.33
92.10
93.60
88.00
95.31
87.95
94.44
93.97
95.99
89.24
90.48
96.57
84.96
94.39
89.73
94.24
91.09
93.32

96.50

96.63
96.21
95.55
96.93
97.42

98.87
98.23
98.02
96.16
93.51
95.17
95.67
95.38
97.60
95.74
96.20
96.92
96.97
96.27
93.32
97.90
93.82
98.06
97.63
97.94
96.97
96.60

96.52

96.63
96.28
95.49
96.93
97.50

98.91
97.97
98.24
96.35
93.38
95.16
95.74
95.51
97.49
95.85
96.11
96.96
97.10
96.82
93.41
97.95
93.30
98.03
97.62
97.90
96.84
96.69

83.48

82.77
87.44
81.22
81.31
86.66

95.04
87.40
89.02
77.09
81.95
71.23
71.38
79.87
80.00
86.34
78.09
80.11
81.19
84.62
88.25
83.59
76.62
92.05
91.77
92.16
80.48
88.37

BTS

95.70

–
–
–
–
–

–
97.84
98.50
95.52
92.87
93.87
95.80
–
96.82
95.48
95.75
–
–
–
92.85
97.56
–
–
–
–
–
95.57

87.98

87.63
90.39
85.45
86.07
91.69

96.21
90.56
91.30
86.35
86.77
80.11
79.27
84.30
89.05
88.85
83.54
88.83
85.27
92.71
87.67
89.15
75.95
93.72
94.94
92.33
88.94
89.80

Table 2: Tagging accuracies on UD 1.2 test sets. (cid:126)w: words, (cid:126)c: characters, (cid:126)b: bytes. Bold/†: best
accuracy/representation; +POLYGLOT: using pre-trained embeddings. FREQBIN: our multi-task model.
OOV ACC: accuracies on OOVs. BTS: best results in Gillick et al. (2016) (not strictly comparable).

WSJ

Convnet (Santos and Zadrozny, 2014)
Convnet reimplementation (Ling et al., 2015)
Bi-RNN (Ling et al., 2015)
Bi-LSTM (Ling et al., 2015)

Our bi-LSTM (cid:126)w+(cid:126)c

Accuracy

97.32
96.80
95.93
97.36

97.22

Table 3: Comparison POS accuracy on WSJ; bi-
LSTM: 30 epochs, σ=0.3, no POLYGLOT.

ing amounts of training instances (number of sen-
tences). The learning curves in Figure 3 show
similar trends across language families.4 TNT
is better with little data, bi-LSTM is better with
more data, and bi-LSTM always wins over CRF.
The bi-LSTM model performs already surpris-
ingly well after only 500 training sentences. For
non-Indoeuropean languages it is on par and above

4We observe the same pattern with more, 40, iterations.

Figure 2: Absolute improvements of bi-LSTM
( (cid:126)w + (cid:126)c) over TNT vs mean log frequency.

Data set size Prior work mostly used large
data sets when applying neural network based
approaches (Zhang et al., 2015). We evaluate
how brittle such models are with respect to their
more traditional counterparts by training bi-LSTM
( (cid:126)w + (cid:126)c without Polyglot embeddings) for increas-

state-of-the-art performance close to taggers us-
ing carefully designed feature templates. Ling et
al. (2015) extend this line and compare a novel
bi-LSTM model,
learning word representations
through character embeddings. They evaluate
their model on a language modeling and POS tag-
ging setup, and show that bi-LSTMs outperform
the CNN approach of Santos and Zadrozny (2014).
Similarly, Labeau et al. (2015) evaluate character
embeddings for German. Bi-LSTMs for POS tag-
ging are also reported in Wang et al. (2015), how-
ever, they only explore word embeddings, ortho-
graphic information and evaluate on WSJ only. A
related study is Cheng et al. (2015) who propose a
multi-task RNN for named entity recognition by
jointly predicting the next token and current to-
ken’s name label. Our model is simpler, it uses
a very coarse set of labels rather then integrating
an entire language modeling task which is compu-
tationally more expensive. An interesting recent
study is Gillick et al. (2016), they build a single
byte-to-span model for multiple languages based
on a sequence-to-sequence RNN (Sutskever et al.,
2014) achieving impressive results. We would like
to extend this work in their direction.

5 Conclusions

We evaluated token and subtoken-level representa-
tions for neural network-based part-of-speech tag-
ging across 22 languages and proposed a novel
multi-task bi-LSTM with auxiliary loss. The aux-
iliary loss is effective at improving the accuracy of
rare words.

Subtoken representations are necessary to ob-
tain a state-of-the-art POS tagger, and charac-
ter embeddings are particularly helpful for non-
Indoeuropean and Slavic languages.

Combining them with word embeddings in a hi-
erarchical network provides the best representa-
tion. The bi-LSTM tagger is as effective as the
CRF and HMM taggers with already as little as
500 training sentences, but is less robust to label
noise (at higher noise rates).

Acknowledgments

We thank the anonymous reviewers for their feed-
back. AS is funded by the ERC Starting Grant
LOWLANDS No. 313695. YG is supported by
The Israeli Science Foundation (grant number
1555/15) and a Google Research Award.

Figure 3: Amount of training data (number of sen-
tences) vs tagging accuracy.

the other taggers with even less data (100 sen-
tences). This shows that the bi-LSTMs often needs
more data than the generative markovian model,
but this is deﬁnitely less than what we expected.

Label Noise We investigated the susceptibility
of the models to noise, by artiﬁcially corrupting
training labels. Our initial results show that at low
noise rates, bi-LSTMs and TNT are affected sim-
ilarly, their accuracies drop to a similar degree.
Only at higher noise levels (more than 30% cor-
rupted labels), bi-LSTMs are less robust, showing
higher drops in accuracy compared to TNT. This
is the case for all investigated language families.

4 Related Work

introduced
Character embeddings were ﬁrst
by Sutskever et al. (2011) for language model-
ing. Early applications include text classiﬁca-
tion (Chrupała, 2013; Zhang et al., 2015). Re-
cently, these representations were successfully ap-
plied to a range of structured prediction tasks. For
POS tagging, Santos and Zadrozny (2014) were
the ﬁrst to propose character-based models. They
use a convolutional neural network (CNN; or con-
vnet) and evaluated their model on English (PTB)
and Portuguese, showing that the model achieves

References

Rami Al-Rfou, Bryan Perozzi, and Steven Skiena.
2013. Polyglot: Distributed Word Representations
for Multilingual NLP. In CoNLL.

Miguel Ballesteros, Chris Dyer, and Noah A. Smith.
2015. Improved Transition-based Parsing by Mod-
eling Characters instead of Words with LSTMs. In
EMNLP.

Thorsten Brants.
speech tagger.
ence on Applied natural language processing.

2000. Tnt: a statistical part-of-
In Proceedings of the sixth confer-

Hao Cheng, Hao Fang, and Mari Ostendorf. 2015.
Open-Domain Name Error Detection using a Multi-
Task RNN. In EMNLP.

Yoon Kim, Yacine Jernite, David Sontag, and Alexan-
der M Rush. 2015. Character-aware neural lan-
guage models. arXiv preprint arXiv:1508.06615.

E. Kiperwasser and Y. Goldberg. 2016. Simple and
Accurate Dependency Parsing Using Bidirectional
LSTM Feature Representations. ArXiv e-prints.

Matthieu Labeau, Kevin L¨oser, and Alexandre Al-
lauzen. 2015. Non-lexical neural architecture for
ﬁne-grained pos tagging. In EMNLP.

Wang Ling, Chris Dyer, Alan W Black, Isabel Tran-
coso, Ramon Fermandez, Silvio Amir, Luis Marujo,
and Tiago Luis. 2015. Finding function in form:
Compositional character models for open vocabu-
lary word representation. In EMNLP.

Kyunghyun Cho.

standing with distributed representation.
abs/1511.07916.

2015. Natural language under-
ArXiv,

Pengfei Liu, Shaﬁq Joty, and Helen Meng. 2015. Fine-
grained opinion mining with recurrent neural net-
works and word embeddings. In EMNLP.

Grzegorz Chrupała. 2013. Text segmentation with
In Workshop on
character-level text embeddings.
Deep Learning for Audio, Speech and Language
Processing, ICML.

Christopher D Manning. 2011. Part-of-speech tag-
ging from 97% to 100%: is it time for some linguis-
tics? In Computational Linguistics and Intelligent
Text Processing. Springer.

Michael Collins. 2002. Discriminative training meth-

Joakim Nivre,

ods for Hidden Markov Models. In EMNLP.

Ronan Collobert, Jason Weston, L´eon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
The Journal of Machine Learning Re-
scratch.
search, 12:2493–2537.

Jeffrey L Elman. 1990. Finding structure in time.

Cognitive science, 14(2):179–211.

Dan Gillick, Cliff Brunk, Oriol Vinyals, and Amarnag
Subramanya. 2016. Multilingual language process-
ing from bytes. In NAACL.

Yoav Goldberg. 2015. A primer on neural network
models for natural language processing. ArXiv,
abs/1510.00726.

Alex Graves and J¨urgen Schmidhuber. 2005. Frame-
wise phoneme classiﬁcation with bidirectional lstm
and other neural network architectures. Neural Net-
works, 18(5):602–610.

Sepp Hochreiter and J¨urgen Schmidhuber.

1997.
Neural computation,

Long short-term memory.
9(8):1735–1780.

Tobias Horsmann, Nicolai Erbs, and Torsten Zesch.
2015. Fast or accurate?–a comparative evaluation of
pos tagging models. In Proceedings of the Interna-
tional Conference of the German Society for Com-
putational Linguistics and Language Technology.

ˇZeljko Agi´c, Maria Jesus Aranzabe,
Masayuki Asahara, Aitziber Atutxa, Miguel Balles-
teros, John Bauer, Kepa Bengoetxea, Riyaz Ah-
mad Bhat, Cristina Bosco, Sam Bowman, Giuseppe
G. A. Celano, Miriam Connor, Marie-Catherine
de Marneffe, Arantza Diaz de Ilarraza, Kaja Do-
brovoljc, Timothy Dozat, Tomaˇz Erjavec, Rich´ard
Farkas, Jennifer Foster, Daniel Galbraith, Filip Gin-
ter, Iakes Goenaga, Koldo Gojenola, Yoav Gold-
berg, Berta Gonzales, Bruno Guillaume, Jan Hajiˇc,
Dag Haug, Radu Ion, Elena Irimia, Anders Jo-
hannsen, Hiroshi Kanayama, Jenna Kanerva, Simon
Krek, Veronika Laippala, Alessandro Lenci, Nikola
Ljubeˇsi´c, Teresa Lynn, Christopher Manning, Ctlina
Mrnduc, David Mareˇcek, H´ector Mart´ınez Alonso,
Jan Maˇsek, Yuji Matsumoto, Ryan McDonald,
Anna Missil¨a, Verginica Mititelu, Yusuke Miyao,
Simonetta Montemagni, Shunsuke Mori, Hanna
Nurmi, Petya Osenova, Lilja Øvrelid, Elena Pascual,
Marco Passarotti, Cenel-Augusto Perez, Slav Petrov,
Jussi Piitulainen, Barbara Plank, Martin Popel,
Prokopis Prokopidis, Sampo Pyysalo, Loganathan
Ramasamy, Rudolf Rosa, Shadi Saleh, Sebastian
Schuster, Wolfgang Seeker, Mojgan Seraji, Natalia
Silveira, Maria Simi, Radu Simionescu, Katalin
Simk´o, Kiril Simov, Aaron Smith, Jan ˇStˇep´anek,
Alane Suhr, Zsolt Sz´ant´o, Takaaki Tanaka, Reut
Tsarfaty, Sumire Uematsu, Larraitz Uria, Viktor
Varga, Veronika Vincze, Zdenˇek ˇZabokrtsk´y, Daniel
Zeman, and Hanzhi Zhu. 2015. Universal depen-
dencies 1.2. LINDAT/CLARIN digital library at In-
stitute of Formal and Applied Linguistics, Charles
University in Prague.

Zhiheng Huang, Wei Xu, and Kai Yu. 2015. Bidi-
rectional LSTM-CRF models for sequence tagging.
arXiv preprint arXiv:1508.01991.

Barbara Plank, Dirk Hovy, Ryan McDonald, and An-
ders Søgaard. 2014. Adapting taggers to twitter us-
ing not-so-distant supervision. In COLING.

Cicero D Santos and Bianca Zadrozny. 2014. Learning
character-level representations for part-of-speech
tagging. In ICML.

Ilya Sutskever, James Martens, and Geoffrey E Hin-
ton. 2011. Generating text with recurrent neural
networks. In ICML.

Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014.
Sequence to sequence learning with neural net-
works. In NIPS.

Peilu Wang, Yao Qian, Frank K. Soong, Lei He, and
Hai Zhao. 2015. Part-of-speech tagging with bidi-
rectional long short-term memory recurrent neural
network. pre-print, abs/1510.06168.

Xiang Zhang, Junbo Zhao, and Yann LeCun. 2015.
Character-level convolutional networks for text clas-
siﬁcation. In Advances in Neural Information Pro-
cessing Systems, pages 649–657.

Jie Zhou and Wei Xu. 2015. End-to-end learning of
semantic role labeling using recurrent neural net-
works. In ACL.

Multilingual Part-of-Speech Tagging with
Bidirectional Long Short-Term Memory Models and Auxiliary Loss

Barbara Plank
University of Groningen
The Netherlands
b.plank@rug.nl

Anders Søgaard
University of Copenhagen
Denmark
soegaard@hum.ku.dk

Yoav Goldberg
Bar-Ilan University
Israel
yoav.goldberg@gmail.com

6
1
0
2
 
l
u
J
 
1
2
 
 
]
L
C
.
s
c
[
 
 
3
v
9
2
5
5
0
.
4
0
6
1
:
v
i
X
r
a

Abstract

Bidirectional long short-term memory (bi-
LSTM) networks have recently proven
successful for various NLP sequence mod-
eling tasks, but
little is known about
their reliance to input representations, tar-
get languages, data set size, and label
noise. We address these issues and eval-
uate bi-LSTMs with word, character, and
unicode byte embeddings for POS tag-
ging. We compare bi-LSTMs to tradi-
tional POS taggers across languages and
data sizes. We also present a novel bi-
LSTM model, which combines the POS
tagging loss function with an auxiliary
loss function that accounts for rare words.
The model obtains state-of-the-art perfor-
mance across 22 languages, and works es-
pecially well for morphologically complex
languages. Our analysis suggests that bi-
LSTMs are less sensitive to training data
size and label corruptions (at small noise
levels) than previously assumed.

1

Introduction

Recently, bidirectional long short-term memory
networks (bi-LSTM) (Graves and Schmidhuber,
2005; Hochreiter and Schmidhuber, 1997) have
been used for language modelling (Ling et al.,
2015), POS tagging (Ling et al., 2015; Wang
et al., 2015), transition-based dependency pars-
ing (Ballesteros et al., 2015; Kiperwasser and
Goldberg, 2016), ﬁne-grained sentiment analysis
(Liu et al., 2015), syntactic chunking (Huang et
al., 2015), and semantic role labeling (Zhou and
Xu, 2015). LSTMs are recurrent neural networks
(RNNs) in which layers are designed to prevent
vanishing gradients. Bidirectional LSTMs make a
backward and forward pass through the sequence

before passing on to the next layer. For further de-
tails, see (Goldberg, 2015; Cho, 2015).

We consider using bi-LSTMs for POS tagging.
Previous work on using deep learning-based meth-
ods for POS tagging has focused either on a sin-
gle language (Collobert et al., 2011; Wang et al.,
2015) or a small set of languages (Ling et al.,
Instead we
2015; Santos and Zadrozny, 2014).
evaluate our models across 22 languages. In ad-
dition, we compare performance with represen-
tations at different levels of granularity (words,
characters, and bytes). These levels of represen-
tation were previously introduced in different ef-
forts (Chrupała, 2013; Zhang et al., 2015; Ling
et al., 2015; Santos and Zadrozny, 2014; Gillick
et al., 2016; Kim et al., 2015), but a comparative
evaluation was missing.

Moreover, deep networks are often said to re-
quire large volumes of training data. We investi-
gate to what extent bi-LSTMs are more sensitive
to the amount of training data and label noise than
standard POS taggers.

Finally, we introduce a novel model, a bi-LSTM
trained with auxiliary loss. The model jointly pre-
dicts the POS and the log frequency of the word.
The intuition behind this model is that the aux-
iliary loss, being predictive of word frequency,
helps to differentiate the representations of rare
and common words. We indeed observe perfor-
mance gains on rare and out-of-vocabulary words.
These performance gains transfer into general im-
provements for morphologically rich languages.

Contributions
In this paper, we a) evaluate the
effectiveness of different representations in bi-
LSTMs, b) compare these models across a large
set of languages and under varying conditions
(data size, label noise) and c) propose a novel bi-
LSTM model with auxiliary loss (LOGFREQ).

2 Tagging with bi-LSTMs

Recurrent neural networks (RNNs) (Elman, 1990)
allow the computation of ﬁxed-size vector repre-
sentations for word sequences of arbitrary length.
An RNN is a function that reads in n vectors
x1, ..., xn and produces an output vector hn, that
depends on the entire sequence x1, ..., xn. The
vector hn is then fed as an input to some classi-
ﬁer, or higher-level RNNs in stacked/hierarchical
models. The entire network is trained jointly such
that the hidden representation captures the impor-
tant information from the sequence for the predic-
tion task.

A bidirectional recurrent neural network (bi-
RNN) (Graves and Schmidhuber, 2005) is an ex-
tension of an RNN that reads the input sequence
twice, from left to right and right to left, and the
encodings are concatenated. The literature uses
the term bi-RNN to refer to two related architec-
tures, which we refer to here as “context bi-RNN”
and “sequence bi-RNN”. In a sequence bi-RNN
(bi-RNNseq), the input is a sequence of vectors
x1:n and the output is a concatenation (◦) of a for-
ward (f ) and reverse (r) RNN each reading the
sequence in a different directions:

v = bi-RNNseq(x1:n) = RNNf (x1:n) ◦ RNNr(xn:1)

In a context bi-RNN (bi-RNNctx), we get an addi-
tional input i indicating a sequence position, and
the resulting vectors vi result from concatenating
the RNN encodings up to i:

vi = bi-RNNctx(x1:n, i) = RNNf (x1:i) ◦ RNNr(xn:i)

Thus, the state vector vi in this bi-RNN encodes
information at position i and its entire sequential
context. Another view of the context bi-RNN is
of taking a sequence x1:n and returning the corre-
sponding sequence of state vectors v1:n.

LSTMs (Hochreiter and Schmidhuber, 1997)
are a variant of RNNs that replace the cells of
RNNs with LSTM cells that were designed to pre-
vent vanishing gradients. Bidirectional LSTMs
are the bi-RNN counterpart based on LSTMs.

Our basic bi-LSTM tagging model is a context
bi-LSTM taking as input word embeddings (cid:126)w. We
incorporate subtoken information using an hierar-
chical bi-LSTM architecture (Ling et al., 2015;
Ballesteros et al., 2015). We compute subtoken-
level (either characters (cid:126)c or unicode byte(cid:126)b) embed-
dings of words using a sequence bi-LSTM at the

lower level. This representation is then concate-
nated with the (learned) word embeddings vector
(cid:126)w which forms the input to the context bi-LSTM at
the next layer. This model, illustrated in Figure 1
(lower part in left ﬁgure), is inspired by Balles-
teros et al. (2015). We also test models in which
we only keep sub-token information, e.g., either
both byte and character embeddings (Figure 1,
right) or a single (sub-)token representation alone.

Figure 1: Right: bi-LSTM, illustrated with (cid:126)b + (cid:126)c
(bytes and characters), for (cid:126)w + (cid:126)c replace (cid:126)b with
words (cid:126)w. Left: FREQBIN, our multi-task bi-
LSTM that predicts at every time step the tag and
the frequency class for the token.

In our novel model, cf. Figure 1 left, we train
the bi-LSTM tagger to predict both the tags of the
sequence, as well as a label that represents the
log frequency of the token as estimated from the
training data. Our combined cross-entropy loss
is now: L( ˆyt, yt) + L( ˆya, ya), where t stands for
a POS tag and a is the log frequency label, i.e.,
a = int(log(f reqtrain(w)). Combining this log
frequency objective with the tagging task can be
seen as an instance of multi-task learning in which
the labels are predicted jointly. The idea behind
this model is to make the representation predictive
for frequency, which encourages the model to not
share representations between common and rare
words, thus beneﬁting the handling of rare tokens.

3 Experiments

All bi-LSTM models were implemented in
CNN/pycnn,1 a ﬂexible neural network library.
For all models we use the same hyperparameters,
which were set on English dev, i.e., SGD train-
ing with cross-entropy loss, no mini-batches, 20

1https://github.com/clab/cnn

epochs, default learning rate (0.1), 128 dimensions
for word embeddings, 100 for character and byte
embeddings, 100 hidden states and Gaussian noise
with σ=0.2. As training is stochastic in nature, we
use a ﬁxed seed throughout. Embeddings are not
initialized with pre-trained embeddings, except
when reported otherwise. In that case we use off-
the-shelf polyglot embeddings (Al-Rfou et al.,
2013).2 No further unlabeled data is considered
in this paper. The code is released at: https:
//github.com/bplank/bilstm-aux

Taggers We want to compare POS taggers un-
der varying conditions. We hence use three dif-
ferent types of taggers: our implementation of a
bi-LSTM; TNT (Brants, 2000)—a second order
HMM with sufﬁx trie handling for OOVs. We use
TNT as it was among the best performing taggers
evaluated in Horsmann et al. (2015).3 We comple-
ment the NN-based and HMM-based tagger with
a CRF tagger, using a freely available implemen-
tation (Plank et al., 2014) based on crfsuite.

3.1 Datasets

For the multilingual experiments, we use the
data from the Universal Dependencies project
v1.2 (Nivre et al., 2015) (17 POS) with the canon-
ical data splits. For languages with token segmen-
tation ambiguity we use the provided gold seg-
mentation.
If there is more than one treebank
per language, we use the treebank that has the
canonical language name (e.g., Finnish instead of
Finnish-FTB). We consider all languages that have
at least 60k tokens and are distributed with word
forms, resulting in 22 languages. We also re-
port accuracies on WSJ (45 POS) using the stan-
dard splits (Collins, 2002; Manning, 2011). The
overview of languages is provided in Table 1.

3.2 Results

Our results are given in Table 2. First of all, no-
tice that TNT performs remarkably well across the
22 languages, closely followed by CRF. The bi-
LSTM tagger ( (cid:126)w) without lower-level bi-LSTM
for subtokens falls short, outperforms the tradi-
tional taggers only on 3 languages. The bi-LSTM

2https://sites.google.com/site/rmyeid/

projects/polyglot

3They found TreeTagger was closely followed by Hun-
Pos, a re-implementation of TnT, and Stanford and ClearNLP
were lower ranked. In an initial investigation, we compared
Tnt, HunPos and TreeTagger and found Tnt to be consistently
better than Treetagger, Hunpos followed closely but crashed
on some languages (e.g., Arabic).

COARSE

FINE

COARSE

FINE

non-IE
ar
Indoeuropean
bg
Indoeuropean
cs
Indoeuropean
da
Indoeuropean
de
Indoeuropean
en
Indoeuropean
es
eu Language isolate
Indoeuropean
fa
non-IE
ﬁ
Indoeuropean
fr

Semitic
Slavic
Slavic
Germanic
Germanic
Germanic
Romance

Indo-Iranian
Uralic
Romance

he
hi
hr
id
it
nl
no
pl
pt
sl
sv

Austronesian

Semitic
Indo-Iranian

non-IE
Indoeuropean
Indoeuropean Slavic
non-IE
Indoeuropean Romance
Indoeuropean Germanic
Indoeuropean Germanic
Indoeuropean Slavic
Indoeuropean Romance
Indoeuropean Slavic
Indoeuropean Germanic

Table 1: Grouping of languages.

model clearly beneﬁts from character representa-
tions. The model using characters alone ((cid:126)c) works
remarkably well, it improves over TNT on 9 lan-
guages (incl. Slavic and Nordic languages). The
combined word+character representation model is
the best representation, outperforming the baseline
on all except one language (Indonesian), provid-
ing strong results already without pre-trained em-
beddings. This model ( (cid:126)w + (cid:126)c) reaches the biggest
improvement (more than +2% accuracy) on He-
brew and Slovene. Initializing the word embed-
dings (+POLYGLOT) with off-the-shelf language-
speciﬁc embeddings further improves accuracy.
The only system we are aware of that evaluates on
UD is Gillick et al. (2016) (last column). However,
note that these results are not strictly comparable
as they use the earlier UD v1.1 version.

The overall best system is the multi-task bi-
LSTM FREQBIN (it uses (cid:126)w + (cid:126)c and POLYGLOT
initialization for (cid:126)w). While on macro average it
is on par with bi-LSTM (cid:126)w + (cid:126)c, it obtains the best
results on 12/22 languages, and it is successful in
predicting POS for OOV tokens (cf. Table 2 OOV
ACC columns), especially for languages like Ara-
bic, Farsi, Hebrew, Finnish.

We examined simple RNNs and conﬁrm the
ﬁnding of Ling et al. (2015) that they performed
worse than their LSTM counterparts. Finally, the
bi-LSTM tagger is competitive on WSJ, cf. Ta-
ble 3.

Rare words
In order to evaluate the effect of
modeling sub-token information, we examine ac-
curacy rates at different frequency rates. Figure 2
shows absolute improvements in accuracy of bi-
LSTM (cid:126)w + (cid:126)c over mean log frequency, for dif-
ferent language families. We see that especially
for Slavic and non-Indoeuropean languages, hav-
ing high morphologic complexity, most of the im-
provement is obtained in the Zipﬁan tail. Rare to-
kens beneﬁt from the sub-token representations.

BASELINES
CRF
TNT

BI-LSTM using:
(cid:126)c + (cid:126)b

(cid:126)c

(cid:126)w

(cid:126)w + (cid:126)c

(cid:126)w + (cid:126)c +POLYGLOT
bi-LSTM FREQBIN bi-LSTM FREQBIN

OOV ACC

avg

94.61

94.27

96.00†

94.29

94.01

92.37

Indoeur.
non-Indo.
Germanic
Romance
Slavic

ar
bg
cs
da
de
en
es
eu
fa
ﬁ
fr
he
hi
hr
id
it
nl
no
pl
pt
sl
sv

94.70
94.57
93.27
95.37
95.64

97.82
96.84
96.82
94.29
92.64
92.66
94.55
93.35
95.98
93.59
94.51
93.71
94.53
94.06
93.16
96.16
88.54
96.31
95.57
96.27
94.92
95.19

94.58
93.62
93.21
95.53
94.96

97.56
96.36
96.56
93.83
91.38
93.35
94.23
91.63
95.65
90.32
95.14
93.63
96.00
93.16
92.96
96.43
90.03
96.21
93.96
96.32
94.77
94.45

96.15†
95.67†
95.09†
96.51†
96.91†

98.91
98.02
97.80
96.19
92.64
94.46
95.12
94.70
97.19
94.85
95.80
95.79
96.23
94.76
93.11
97.59
93.32
97.57
96.41
97.53
97.55
96.36

94.58
93.51
92.89
94.76
96.45

98.68
97.89
96.38
95.12
90.02
91.62
93.06
92.48
95.82
90.25
94.39
93.74
93.40
95.32
91.37
95.62
89.11
95.87
95.80
95.96
96.87
95.57

94.28
93.16
92.59
94.49
96.26

98.43
97.78
96.08
94.88
90.11
91.57
92.29
92.72
95.03
89.15
93.69
93.58
92.99
94.47
91.46
95.77
87.74
95.75
96.19
96.20
96.77
95.50

92.72
91.97
91.18
94.71
91.79

95.48
95.12
93.77
91.96
90.33
92.10
93.60
88.00
95.31
87.95
94.44
93.97
95.99
89.24
90.48
96.57
84.96
94.39
89.73
94.24
91.09
93.32

96.50

96.63
96.21
95.55
96.93
97.42

98.87
98.23
98.02
96.16
93.51
95.17
95.67
95.38
97.60
95.74
96.20
96.92
96.97
96.27
93.32
97.90
93.82
98.06
97.63
97.94
96.97
96.60

96.52

96.63
96.28
95.49
96.93
97.50

98.91
97.97
98.24
96.35
93.38
95.16
95.74
95.51
97.49
95.85
96.11
96.96
97.10
96.82
93.41
97.95
93.30
98.03
97.62
97.90
96.84
96.69

83.48

82.77
87.44
81.22
81.31
86.66

95.04
87.40
89.02
77.09
81.95
71.23
71.38
79.87
80.00
86.34
78.09
80.11
81.19
84.62
88.25
83.59
76.62
92.05
91.77
92.16
80.48
88.37

BTS

95.70

–
–
–
–
–

–
97.84
98.50
95.52
92.87
93.87
95.80
–
96.82
95.48
95.75
–
–
–
92.85
97.56
–
–
–
–
–
95.57

87.98

87.63
90.39
85.45
86.07
91.69

96.21
90.56
91.30
86.35
86.77
80.11
79.27
84.30
89.05
88.85
83.54
88.83
85.27
92.71
87.67
89.15
75.95
93.72
94.94
92.33
88.94
89.80

Table 2: Tagging accuracies on UD 1.2 test sets. (cid:126)w: words, (cid:126)c: characters, (cid:126)b: bytes. Bold/†: best
accuracy/representation; +POLYGLOT: using pre-trained embeddings. FREQBIN: our multi-task model.
OOV ACC: accuracies on OOVs. BTS: best results in Gillick et al. (2016) (not strictly comparable).

WSJ

Convnet (Santos and Zadrozny, 2014)
Convnet reimplementation (Ling et al., 2015)
Bi-RNN (Ling et al., 2015)
Bi-LSTM (Ling et al., 2015)

Our bi-LSTM (cid:126)w+(cid:126)c

Accuracy

97.32
96.80
95.93
97.36

97.22

Table 3: Comparison POS accuracy on WSJ; bi-
LSTM: 30 epochs, σ=0.3, no POLYGLOT.

ing amounts of training instances (number of sen-
tences). The learning curves in Figure 3 show
similar trends across language families.4 TNT
is better with little data, bi-LSTM is better with
more data, and bi-LSTM always wins over CRF.
The bi-LSTM model performs already surpris-
ingly well after only 500 training sentences. For
non-Indoeuropean languages it is on par and above

4We observe the same pattern with more, 40, iterations.

Figure 2: Absolute improvements of bi-LSTM
( (cid:126)w + (cid:126)c) over TNT vs mean log frequency.

Data set size Prior work mostly used large
data sets when applying neural network based
approaches (Zhang et al., 2015). We evaluate
how brittle such models are with respect to their
more traditional counterparts by training bi-LSTM
( (cid:126)w + (cid:126)c without Polyglot embeddings) for increas-

state-of-the-art performance close to taggers us-
ing carefully designed feature templates. Ling et
al. (2015) extend this line and compare a novel
bi-LSTM model,
learning word representations
through character embeddings. They evaluate
their model on a language modeling and POS tag-
ging setup, and show that bi-LSTMs outperform
the CNN approach of Santos and Zadrozny (2014).
Similarly, Labeau et al. (2015) evaluate character
embeddings for German. Bi-LSTMs for POS tag-
ging are also reported in Wang et al. (2015), how-
ever, they only explore word embeddings, ortho-
graphic information and evaluate on WSJ only. A
related study is Cheng et al. (2015) who propose a
multi-task RNN for named entity recognition by
jointly predicting the next token and current to-
ken’s name label. Our model is simpler, it uses
a very coarse set of labels rather then integrating
an entire language modeling task which is compu-
tationally more expensive. An interesting recent
study is Gillick et al. (2016), they build a single
byte-to-span model for multiple languages based
on a sequence-to-sequence RNN (Sutskever et al.,
2014) achieving impressive results. We would like
to extend this work in their direction.

5 Conclusions

We evaluated token and subtoken-level representa-
tions for neural network-based part-of-speech tag-
ging across 22 languages and proposed a novel
multi-task bi-LSTM with auxiliary loss. The aux-
iliary loss is effective at improving the accuracy of
rare words.

Subtoken representations are necessary to ob-
tain a state-of-the-art POS tagger, and charac-
ter embeddings are particularly helpful for non-
Indoeuropean and Slavic languages.

Combining them with word embeddings in a hi-
erarchical network provides the best representa-
tion. The bi-LSTM tagger is as effective as the
CRF and HMM taggers with already as little as
500 training sentences, but is less robust to label
noise (at higher noise rates).

Acknowledgments

We thank the anonymous reviewers for their feed-
back. AS is funded by the ERC Starting Grant
LOWLANDS No. 313695. YG is supported by
The Israeli Science Foundation (grant number
1555/15) and a Google Research Award.

Figure 3: Amount of training data (number of sen-
tences) vs tagging accuracy.

the other taggers with even less data (100 sen-
tences). This shows that the bi-LSTMs often needs
more data than the generative markovian model,
but this is deﬁnitely less than what we expected.

Label Noise We investigated the susceptibility
of the models to noise, by artiﬁcially corrupting
training labels. Our initial results show that at low
noise rates, bi-LSTMs and TNT are affected sim-
ilarly, their accuracies drop to a similar degree.
Only at higher noise levels (more than 30% cor-
rupted labels), bi-LSTMs are less robust, showing
higher drops in accuracy compared to TNT. This
is the case for all investigated language families.

4 Related Work

introduced
Character embeddings were ﬁrst
by Sutskever et al. (2011) for language model-
ing. Early applications include text classiﬁca-
tion (Chrupała, 2013; Zhang et al., 2015). Re-
cently, these representations were successfully ap-
plied to a range of structured prediction tasks. For
POS tagging, Santos and Zadrozny (2014) were
the ﬁrst to propose character-based models. They
use a convolutional neural network (CNN; or con-
vnet) and evaluated their model on English (PTB)
and Portuguese, showing that the model achieves

References

Rami Al-Rfou, Bryan Perozzi, and Steven Skiena.
2013. Polyglot: Distributed Word Representations
for Multilingual NLP. In CoNLL.

Miguel Ballesteros, Chris Dyer, and Noah A. Smith.
2015. Improved Transition-based Parsing by Mod-
eling Characters instead of Words with LSTMs. In
EMNLP.

Thorsten Brants.
speech tagger.
ence on Applied natural language processing.

2000. Tnt: a statistical part-of-
In Proceedings of the sixth confer-

Hao Cheng, Hao Fang, and Mari Ostendorf. 2015.
Open-Domain Name Error Detection using a Multi-
Task RNN. In EMNLP.

Yoon Kim, Yacine Jernite, David Sontag, and Alexan-
der M Rush. 2015. Character-aware neural lan-
guage models. arXiv preprint arXiv:1508.06615.

E. Kiperwasser and Y. Goldberg. 2016. Simple and
Accurate Dependency Parsing Using Bidirectional
LSTM Feature Representations. ArXiv e-prints.

Matthieu Labeau, Kevin L¨oser, and Alexandre Al-
lauzen. 2015. Non-lexical neural architecture for
ﬁne-grained pos tagging. In EMNLP.

Wang Ling, Chris Dyer, Alan W Black, Isabel Tran-
coso, Ramon Fermandez, Silvio Amir, Luis Marujo,
and Tiago Luis. 2015. Finding function in form:
Compositional character models for open vocabu-
lary word representation. In EMNLP.

Kyunghyun Cho.

standing with distributed representation.
abs/1511.07916.

2015. Natural language under-
ArXiv,

Pengfei Liu, Shaﬁq Joty, and Helen Meng. 2015. Fine-
grained opinion mining with recurrent neural net-
works and word embeddings. In EMNLP.

Grzegorz Chrupała. 2013. Text segmentation with
In Workshop on
character-level text embeddings.
Deep Learning for Audio, Speech and Language
Processing, ICML.

Christopher D Manning. 2011. Part-of-speech tag-
ging from 97% to 100%: is it time for some linguis-
tics? In Computational Linguistics and Intelligent
Text Processing. Springer.

Michael Collins. 2002. Discriminative training meth-

Joakim Nivre,

ods for Hidden Markov Models. In EMNLP.

Ronan Collobert, Jason Weston, L´eon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
The Journal of Machine Learning Re-
scratch.
search, 12:2493–2537.

Jeffrey L Elman. 1990. Finding structure in time.

Cognitive science, 14(2):179–211.

Dan Gillick, Cliff Brunk, Oriol Vinyals, and Amarnag
Subramanya. 2016. Multilingual language process-
ing from bytes. In NAACL.

Yoav Goldberg. 2015. A primer on neural network
models for natural language processing. ArXiv,
abs/1510.00726.

Alex Graves and J¨urgen Schmidhuber. 2005. Frame-
wise phoneme classiﬁcation with bidirectional lstm
and other neural network architectures. Neural Net-
works, 18(5):602–610.

Sepp Hochreiter and J¨urgen Schmidhuber.

1997.
Neural computation,

Long short-term memory.
9(8):1735–1780.

Tobias Horsmann, Nicolai Erbs, and Torsten Zesch.
2015. Fast or accurate?–a comparative evaluation of
pos tagging models. In Proceedings of the Interna-
tional Conference of the German Society for Com-
putational Linguistics and Language Technology.

ˇZeljko Agi´c, Maria Jesus Aranzabe,
Masayuki Asahara, Aitziber Atutxa, Miguel Balles-
teros, John Bauer, Kepa Bengoetxea, Riyaz Ah-
mad Bhat, Cristina Bosco, Sam Bowman, Giuseppe
G. A. Celano, Miriam Connor, Marie-Catherine
de Marneffe, Arantza Diaz de Ilarraza, Kaja Do-
brovoljc, Timothy Dozat, Tomaˇz Erjavec, Rich´ard
Farkas, Jennifer Foster, Daniel Galbraith, Filip Gin-
ter, Iakes Goenaga, Koldo Gojenola, Yoav Gold-
berg, Berta Gonzales, Bruno Guillaume, Jan Hajiˇc,
Dag Haug, Radu Ion, Elena Irimia, Anders Jo-
hannsen, Hiroshi Kanayama, Jenna Kanerva, Simon
Krek, Veronika Laippala, Alessandro Lenci, Nikola
Ljubeˇsi´c, Teresa Lynn, Christopher Manning, Ctlina
Mrnduc, David Mareˇcek, H´ector Mart´ınez Alonso,
Jan Maˇsek, Yuji Matsumoto, Ryan McDonald,
Anna Missil¨a, Verginica Mititelu, Yusuke Miyao,
Simonetta Montemagni, Shunsuke Mori, Hanna
Nurmi, Petya Osenova, Lilja Øvrelid, Elena Pascual,
Marco Passarotti, Cenel-Augusto Perez, Slav Petrov,
Jussi Piitulainen, Barbara Plank, Martin Popel,
Prokopis Prokopidis, Sampo Pyysalo, Loganathan
Ramasamy, Rudolf Rosa, Shadi Saleh, Sebastian
Schuster, Wolfgang Seeker, Mojgan Seraji, Natalia
Silveira, Maria Simi, Radu Simionescu, Katalin
Simk´o, Kiril Simov, Aaron Smith, Jan ˇStˇep´anek,
Alane Suhr, Zsolt Sz´ant´o, Takaaki Tanaka, Reut
Tsarfaty, Sumire Uematsu, Larraitz Uria, Viktor
Varga, Veronika Vincze, Zdenˇek ˇZabokrtsk´y, Daniel
Zeman, and Hanzhi Zhu. 2015. Universal depen-
dencies 1.2. LINDAT/CLARIN digital library at In-
stitute of Formal and Applied Linguistics, Charles
University in Prague.

Zhiheng Huang, Wei Xu, and Kai Yu. 2015. Bidi-
rectional LSTM-CRF models for sequence tagging.
arXiv preprint arXiv:1508.01991.

Barbara Plank, Dirk Hovy, Ryan McDonald, and An-
ders Søgaard. 2014. Adapting taggers to twitter us-
ing not-so-distant supervision. In COLING.

Cicero D Santos and Bianca Zadrozny. 2014. Learning
character-level representations for part-of-speech
tagging. In ICML.

Ilya Sutskever, James Martens, and Geoffrey E Hin-
ton. 2011. Generating text with recurrent neural
networks. In ICML.

Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014.
Sequence to sequence learning with neural net-
works. In NIPS.

Peilu Wang, Yao Qian, Frank K. Soong, Lei He, and
Hai Zhao. 2015. Part-of-speech tagging with bidi-
rectional long short-term memory recurrent neural
network. pre-print, abs/1510.06168.

Xiang Zhang, Junbo Zhao, and Yann LeCun. 2015.
Character-level convolutional networks for text clas-
siﬁcation. In Advances in Neural Information Pro-
cessing Systems, pages 649–657.

Jie Zhou and Wei Xu. 2015. End-to-end learning of
semantic role labeling using recurrent neural net-
works. In ACL.

Multilingual Part-of-Speech Tagging with
Bidirectional Long Short-Term Memory Models and Auxiliary Loss

Barbara Plank
University of Groningen
The Netherlands
b.plank@rug.nl

Anders Søgaard
University of Copenhagen
Denmark
soegaard@hum.ku.dk

Yoav Goldberg
Bar-Ilan University
Israel
yoav.goldberg@gmail.com

6
1
0
2
 
l
u
J
 
1
2
 
 
]
L
C
.
s
c
[
 
 
3
v
9
2
5
5
0
.
4
0
6
1
:
v
i
X
r
a

Abstract

Bidirectional long short-term memory (bi-
LSTM) networks have recently proven
successful for various NLP sequence mod-
eling tasks, but
little is known about
their reliance to input representations, tar-
get languages, data set size, and label
noise. We address these issues and eval-
uate bi-LSTMs with word, character, and
unicode byte embeddings for POS tag-
ging. We compare bi-LSTMs to tradi-
tional POS taggers across languages and
data sizes. We also present a novel bi-
LSTM model, which combines the POS
tagging loss function with an auxiliary
loss function that accounts for rare words.
The model obtains state-of-the-art perfor-
mance across 22 languages, and works es-
pecially well for morphologically complex
languages. Our analysis suggests that bi-
LSTMs are less sensitive to training data
size and label corruptions (at small noise
levels) than previously assumed.

1

Introduction

Recently, bidirectional long short-term memory
networks (bi-LSTM) (Graves and Schmidhuber,
2005; Hochreiter and Schmidhuber, 1997) have
been used for language modelling (Ling et al.,
2015), POS tagging (Ling et al., 2015; Wang
et al., 2015), transition-based dependency pars-
ing (Ballesteros et al., 2015; Kiperwasser and
Goldberg, 2016), ﬁne-grained sentiment analysis
(Liu et al., 2015), syntactic chunking (Huang et
al., 2015), and semantic role labeling (Zhou and
Xu, 2015). LSTMs are recurrent neural networks
(RNNs) in which layers are designed to prevent
vanishing gradients. Bidirectional LSTMs make a
backward and forward pass through the sequence

before passing on to the next layer. For further de-
tails, see (Goldberg, 2015; Cho, 2015).

We consider using bi-LSTMs for POS tagging.
Previous work on using deep learning-based meth-
ods for POS tagging has focused either on a sin-
gle language (Collobert et al., 2011; Wang et al.,
2015) or a small set of languages (Ling et al.,
Instead we
2015; Santos and Zadrozny, 2014).
evaluate our models across 22 languages. In ad-
dition, we compare performance with represen-
tations at different levels of granularity (words,
characters, and bytes). These levels of represen-
tation were previously introduced in different ef-
forts (Chrupała, 2013; Zhang et al., 2015; Ling
et al., 2015; Santos and Zadrozny, 2014; Gillick
et al., 2016; Kim et al., 2015), but a comparative
evaluation was missing.

Moreover, deep networks are often said to re-
quire large volumes of training data. We investi-
gate to what extent bi-LSTMs are more sensitive
to the amount of training data and label noise than
standard POS taggers.

Finally, we introduce a novel model, a bi-LSTM
trained with auxiliary loss. The model jointly pre-
dicts the POS and the log frequency of the word.
The intuition behind this model is that the aux-
iliary loss, being predictive of word frequency,
helps to differentiate the representations of rare
and common words. We indeed observe perfor-
mance gains on rare and out-of-vocabulary words.
These performance gains transfer into general im-
provements for morphologically rich languages.

Contributions
In this paper, we a) evaluate the
effectiveness of different representations in bi-
LSTMs, b) compare these models across a large
set of languages and under varying conditions
(data size, label noise) and c) propose a novel bi-
LSTM model with auxiliary loss (LOGFREQ).

2 Tagging with bi-LSTMs

Recurrent neural networks (RNNs) (Elman, 1990)
allow the computation of ﬁxed-size vector repre-
sentations for word sequences of arbitrary length.
An RNN is a function that reads in n vectors
x1, ..., xn and produces an output vector hn, that
depends on the entire sequence x1, ..., xn. The
vector hn is then fed as an input to some classi-
ﬁer, or higher-level RNNs in stacked/hierarchical
models. The entire network is trained jointly such
that the hidden representation captures the impor-
tant information from the sequence for the predic-
tion task.

A bidirectional recurrent neural network (bi-
RNN) (Graves and Schmidhuber, 2005) is an ex-
tension of an RNN that reads the input sequence
twice, from left to right and right to left, and the
encodings are concatenated. The literature uses
the term bi-RNN to refer to two related architec-
tures, which we refer to here as “context bi-RNN”
and “sequence bi-RNN”. In a sequence bi-RNN
(bi-RNNseq), the input is a sequence of vectors
x1:n and the output is a concatenation (◦) of a for-
ward (f ) and reverse (r) RNN each reading the
sequence in a different directions:

v = bi-RNNseq(x1:n) = RNNf (x1:n) ◦ RNNr(xn:1)

In a context bi-RNN (bi-RNNctx), we get an addi-
tional input i indicating a sequence position, and
the resulting vectors vi result from concatenating
the RNN encodings up to i:

vi = bi-RNNctx(x1:n, i) = RNNf (x1:i) ◦ RNNr(xn:i)

Thus, the state vector vi in this bi-RNN encodes
information at position i and its entire sequential
context. Another view of the context bi-RNN is
of taking a sequence x1:n and returning the corre-
sponding sequence of state vectors v1:n.

LSTMs (Hochreiter and Schmidhuber, 1997)
are a variant of RNNs that replace the cells of
RNNs with LSTM cells that were designed to pre-
vent vanishing gradients. Bidirectional LSTMs
are the bi-RNN counterpart based on LSTMs.

Our basic bi-LSTM tagging model is a context
bi-LSTM taking as input word embeddings (cid:126)w. We
incorporate subtoken information using an hierar-
chical bi-LSTM architecture (Ling et al., 2015;
Ballesteros et al., 2015). We compute subtoken-
level (either characters (cid:126)c or unicode byte(cid:126)b) embed-
dings of words using a sequence bi-LSTM at the

lower level. This representation is then concate-
nated with the (learned) word embeddings vector
(cid:126)w which forms the input to the context bi-LSTM at
the next layer. This model, illustrated in Figure 1
(lower part in left ﬁgure), is inspired by Balles-
teros et al. (2015). We also test models in which
we only keep sub-token information, e.g., either
both byte and character embeddings (Figure 1,
right) or a single (sub-)token representation alone.

Figure 1: Right: bi-LSTM, illustrated with (cid:126)b + (cid:126)c
(bytes and characters), for (cid:126)w + (cid:126)c replace (cid:126)b with
words (cid:126)w. Left: FREQBIN, our multi-task bi-
LSTM that predicts at every time step the tag and
the frequency class for the token.

In our novel model, cf. Figure 1 left, we train
the bi-LSTM tagger to predict both the tags of the
sequence, as well as a label that represents the
log frequency of the token as estimated from the
training data. Our combined cross-entropy loss
is now: L( ˆyt, yt) + L( ˆya, ya), where t stands for
a POS tag and a is the log frequency label, i.e.,
a = int(log(f reqtrain(w)). Combining this log
frequency objective with the tagging task can be
seen as an instance of multi-task learning in which
the labels are predicted jointly. The idea behind
this model is to make the representation predictive
for frequency, which encourages the model to not
share representations between common and rare
words, thus beneﬁting the handling of rare tokens.

3 Experiments

All bi-LSTM models were implemented in
CNN/pycnn,1 a ﬂexible neural network library.
For all models we use the same hyperparameters,
which were set on English dev, i.e., SGD train-
ing with cross-entropy loss, no mini-batches, 20

1https://github.com/clab/cnn

epochs, default learning rate (0.1), 128 dimensions
for word embeddings, 100 for character and byte
embeddings, 100 hidden states and Gaussian noise
with σ=0.2. As training is stochastic in nature, we
use a ﬁxed seed throughout. Embeddings are not
initialized with pre-trained embeddings, except
when reported otherwise. In that case we use off-
the-shelf polyglot embeddings (Al-Rfou et al.,
2013).2 No further unlabeled data is considered
in this paper. The code is released at: https:
//github.com/bplank/bilstm-aux

Taggers We want to compare POS taggers un-
der varying conditions. We hence use three dif-
ferent types of taggers: our implementation of a
bi-LSTM; TNT (Brants, 2000)—a second order
HMM with sufﬁx trie handling for OOVs. We use
TNT as it was among the best performing taggers
evaluated in Horsmann et al. (2015).3 We comple-
ment the NN-based and HMM-based tagger with
a CRF tagger, using a freely available implemen-
tation (Plank et al., 2014) based on crfsuite.

3.1 Datasets

For the multilingual experiments, we use the
data from the Universal Dependencies project
v1.2 (Nivre et al., 2015) (17 POS) with the canon-
ical data splits. For languages with token segmen-
tation ambiguity we use the provided gold seg-
mentation.
If there is more than one treebank
per language, we use the treebank that has the
canonical language name (e.g., Finnish instead of
Finnish-FTB). We consider all languages that have
at least 60k tokens and are distributed with word
forms, resulting in 22 languages. We also re-
port accuracies on WSJ (45 POS) using the stan-
dard splits (Collins, 2002; Manning, 2011). The
overview of languages is provided in Table 1.

3.2 Results

Our results are given in Table 2. First of all, no-
tice that TNT performs remarkably well across the
22 languages, closely followed by CRF. The bi-
LSTM tagger ( (cid:126)w) without lower-level bi-LSTM
for subtokens falls short, outperforms the tradi-
tional taggers only on 3 languages. The bi-LSTM

2https://sites.google.com/site/rmyeid/

projects/polyglot

3They found TreeTagger was closely followed by Hun-
Pos, a re-implementation of TnT, and Stanford and ClearNLP
were lower ranked. In an initial investigation, we compared
Tnt, HunPos and TreeTagger and found Tnt to be consistently
better than Treetagger, Hunpos followed closely but crashed
on some languages (e.g., Arabic).

COARSE

FINE

COARSE

FINE

non-IE
ar
Indoeuropean
bg
Indoeuropean
cs
Indoeuropean
da
Indoeuropean
de
Indoeuropean
en
Indoeuropean
es
eu Language isolate
Indoeuropean
fa
non-IE
ﬁ
Indoeuropean
fr

Semitic
Slavic
Slavic
Germanic
Germanic
Germanic
Romance

Indo-Iranian
Uralic
Romance

he
hi
hr
id
it
nl
no
pl
pt
sl
sv

Austronesian

Semitic
Indo-Iranian

non-IE
Indoeuropean
Indoeuropean Slavic
non-IE
Indoeuropean Romance
Indoeuropean Germanic
Indoeuropean Germanic
Indoeuropean Slavic
Indoeuropean Romance
Indoeuropean Slavic
Indoeuropean Germanic

Table 1: Grouping of languages.

model clearly beneﬁts from character representa-
tions. The model using characters alone ((cid:126)c) works
remarkably well, it improves over TNT on 9 lan-
guages (incl. Slavic and Nordic languages). The
combined word+character representation model is
the best representation, outperforming the baseline
on all except one language (Indonesian), provid-
ing strong results already without pre-trained em-
beddings. This model ( (cid:126)w + (cid:126)c) reaches the biggest
improvement (more than +2% accuracy) on He-
brew and Slovene. Initializing the word embed-
dings (+POLYGLOT) with off-the-shelf language-
speciﬁc embeddings further improves accuracy.
The only system we are aware of that evaluates on
UD is Gillick et al. (2016) (last column). However,
note that these results are not strictly comparable
as they use the earlier UD v1.1 version.

The overall best system is the multi-task bi-
LSTM FREQBIN (it uses (cid:126)w + (cid:126)c and POLYGLOT
initialization for (cid:126)w). While on macro average it
is on par with bi-LSTM (cid:126)w + (cid:126)c, it obtains the best
results on 12/22 languages, and it is successful in
predicting POS for OOV tokens (cf. Table 2 OOV
ACC columns), especially for languages like Ara-
bic, Farsi, Hebrew, Finnish.

We examined simple RNNs and conﬁrm the
ﬁnding of Ling et al. (2015) that they performed
worse than their LSTM counterparts. Finally, the
bi-LSTM tagger is competitive on WSJ, cf. Ta-
ble 3.

Rare words
In order to evaluate the effect of
modeling sub-token information, we examine ac-
curacy rates at different frequency rates. Figure 2
shows absolute improvements in accuracy of bi-
LSTM (cid:126)w + (cid:126)c over mean log frequency, for dif-
ferent language families. We see that especially
for Slavic and non-Indoeuropean languages, hav-
ing high morphologic complexity, most of the im-
provement is obtained in the Zipﬁan tail. Rare to-
kens beneﬁt from the sub-token representations.

BASELINES
CRF
TNT

BI-LSTM using:
(cid:126)c + (cid:126)b

(cid:126)c

(cid:126)w

(cid:126)w + (cid:126)c

(cid:126)w + (cid:126)c +POLYGLOT
bi-LSTM FREQBIN bi-LSTM FREQBIN

OOV ACC

avg

94.61

94.27

96.00†

94.29

94.01

92.37

Indoeur.
non-Indo.
Germanic
Romance
Slavic

ar
bg
cs
da
de
en
es
eu
fa
ﬁ
fr
he
hi
hr
id
it
nl
no
pl
pt
sl
sv

94.70
94.57
93.27
95.37
95.64

97.82
96.84
96.82
94.29
92.64
92.66
94.55
93.35
95.98
93.59
94.51
93.71
94.53
94.06
93.16
96.16
88.54
96.31
95.57
96.27
94.92
95.19

94.58
93.62
93.21
95.53
94.96

97.56
96.36
96.56
93.83
91.38
93.35
94.23
91.63
95.65
90.32
95.14
93.63
96.00
93.16
92.96
96.43
90.03
96.21
93.96
96.32
94.77
94.45

96.15†
95.67†
95.09†
96.51†
96.91†

98.91
98.02
97.80
96.19
92.64
94.46
95.12
94.70
97.19
94.85
95.80
95.79
96.23
94.76
93.11
97.59
93.32
97.57
96.41
97.53
97.55
96.36

94.58
93.51
92.89
94.76
96.45

98.68
97.89
96.38
95.12
90.02
91.62
93.06
92.48
95.82
90.25
94.39
93.74
93.40
95.32
91.37
95.62
89.11
95.87
95.80
95.96
96.87
95.57

94.28
93.16
92.59
94.49
96.26

98.43
97.78
96.08
94.88
90.11
91.57
92.29
92.72
95.03
89.15
93.69
93.58
92.99
94.47
91.46
95.77
87.74
95.75
96.19
96.20
96.77
95.50

92.72
91.97
91.18
94.71
91.79

95.48
95.12
93.77
91.96
90.33
92.10
93.60
88.00
95.31
87.95
94.44
93.97
95.99
89.24
90.48
96.57
84.96
94.39
89.73
94.24
91.09
93.32

96.50

96.63
96.21
95.55
96.93
97.42

98.87
98.23
98.02
96.16
93.51
95.17
95.67
95.38
97.60
95.74
96.20
96.92
96.97
96.27
93.32
97.90
93.82
98.06
97.63
97.94
96.97
96.60

96.52

96.63
96.28
95.49
96.93
97.50

98.91
97.97
98.24
96.35
93.38
95.16
95.74
95.51
97.49
95.85
96.11
96.96
97.10
96.82
93.41
97.95
93.30
98.03
97.62
97.90
96.84
96.69

83.48

82.77
87.44
81.22
81.31
86.66

95.04
87.40
89.02
77.09
81.95
71.23
71.38
79.87
80.00
86.34
78.09
80.11
81.19
84.62
88.25
83.59
76.62
92.05
91.77
92.16
80.48
88.37

BTS

95.70

–
–
–
–
–

–
97.84
98.50
95.52
92.87
93.87
95.80
–
96.82
95.48
95.75
–
–
–
92.85
97.56
–
–
–
–
–
95.57

87.98

87.63
90.39
85.45
86.07
91.69

96.21
90.56
91.30
86.35
86.77
80.11
79.27
84.30
89.05
88.85
83.54
88.83
85.27
92.71
87.67
89.15
75.95
93.72
94.94
92.33
88.94
89.80

Table 2: Tagging accuracies on UD 1.2 test sets. (cid:126)w: words, (cid:126)c: characters, (cid:126)b: bytes. Bold/†: best
accuracy/representation; +POLYGLOT: using pre-trained embeddings. FREQBIN: our multi-task model.
OOV ACC: accuracies on OOVs. BTS: best results in Gillick et al. (2016) (not strictly comparable).

WSJ

Convnet (Santos and Zadrozny, 2014)
Convnet reimplementation (Ling et al., 2015)
Bi-RNN (Ling et al., 2015)
Bi-LSTM (Ling et al., 2015)

Our bi-LSTM (cid:126)w+(cid:126)c

Accuracy

97.32
96.80
95.93
97.36

97.22

Table 3: Comparison POS accuracy on WSJ; bi-
LSTM: 30 epochs, σ=0.3, no POLYGLOT.

ing amounts of training instances (number of sen-
tences). The learning curves in Figure 3 show
similar trends across language families.4 TNT
is better with little data, bi-LSTM is better with
more data, and bi-LSTM always wins over CRF.
The bi-LSTM model performs already surpris-
ingly well after only 500 training sentences. For
non-Indoeuropean languages it is on par and above

4We observe the same pattern with more, 40, iterations.

Figure 2: Absolute improvements of bi-LSTM
( (cid:126)w + (cid:126)c) over TNT vs mean log frequency.

Data set size Prior work mostly used large
data sets when applying neural network based
approaches (Zhang et al., 2015). We evaluate
how brittle such models are with respect to their
more traditional counterparts by training bi-LSTM
( (cid:126)w + (cid:126)c without Polyglot embeddings) for increas-

state-of-the-art performance close to taggers us-
ing carefully designed feature templates. Ling et
al. (2015) extend this line and compare a novel
bi-LSTM model,
learning word representations
through character embeddings. They evaluate
their model on a language modeling and POS tag-
ging setup, and show that bi-LSTMs outperform
the CNN approach of Santos and Zadrozny (2014).
Similarly, Labeau et al. (2015) evaluate character
embeddings for German. Bi-LSTMs for POS tag-
ging are also reported in Wang et al. (2015), how-
ever, they only explore word embeddings, ortho-
graphic information and evaluate on WSJ only. A
related study is Cheng et al. (2015) who propose a
multi-task RNN for named entity recognition by
jointly predicting the next token and current to-
ken’s name label. Our model is simpler, it uses
a very coarse set of labels rather then integrating
an entire language modeling task which is compu-
tationally more expensive. An interesting recent
study is Gillick et al. (2016), they build a single
byte-to-span model for multiple languages based
on a sequence-to-sequence RNN (Sutskever et al.,
2014) achieving impressive results. We would like
to extend this work in their direction.

5 Conclusions

We evaluated token and subtoken-level representa-
tions for neural network-based part-of-speech tag-
ging across 22 languages and proposed a novel
multi-task bi-LSTM with auxiliary loss. The aux-
iliary loss is effective at improving the accuracy of
rare words.

Subtoken representations are necessary to ob-
tain a state-of-the-art POS tagger, and charac-
ter embeddings are particularly helpful for non-
Indoeuropean and Slavic languages.

Combining them with word embeddings in a hi-
erarchical network provides the best representa-
tion. The bi-LSTM tagger is as effective as the
CRF and HMM taggers with already as little as
500 training sentences, but is less robust to label
noise (at higher noise rates).

Acknowledgments

We thank the anonymous reviewers for their feed-
back. AS is funded by the ERC Starting Grant
LOWLANDS No. 313695. YG is supported by
The Israeli Science Foundation (grant number
1555/15) and a Google Research Award.

Figure 3: Amount of training data (number of sen-
tences) vs tagging accuracy.

the other taggers with even less data (100 sen-
tences). This shows that the bi-LSTMs often needs
more data than the generative markovian model,
but this is deﬁnitely less than what we expected.

Label Noise We investigated the susceptibility
of the models to noise, by artiﬁcially corrupting
training labels. Our initial results show that at low
noise rates, bi-LSTMs and TNT are affected sim-
ilarly, their accuracies drop to a similar degree.
Only at higher noise levels (more than 30% cor-
rupted labels), bi-LSTMs are less robust, showing
higher drops in accuracy compared to TNT. This
is the case for all investigated language families.

4 Related Work

introduced
Character embeddings were ﬁrst
by Sutskever et al. (2011) for language model-
ing. Early applications include text classiﬁca-
tion (Chrupała, 2013; Zhang et al., 2015). Re-
cently, these representations were successfully ap-
plied to a range of structured prediction tasks. For
POS tagging, Santos and Zadrozny (2014) were
the ﬁrst to propose character-based models. They
use a convolutional neural network (CNN; or con-
vnet) and evaluated their model on English (PTB)
and Portuguese, showing that the model achieves

References

Rami Al-Rfou, Bryan Perozzi, and Steven Skiena.
2013. Polyglot: Distributed Word Representations
for Multilingual NLP. In CoNLL.

Miguel Ballesteros, Chris Dyer, and Noah A. Smith.
2015. Improved Transition-based Parsing by Mod-
eling Characters instead of Words with LSTMs. In
EMNLP.

Thorsten Brants.
speech tagger.
ence on Applied natural language processing.

2000. Tnt: a statistical part-of-
In Proceedings of the sixth confer-

Hao Cheng, Hao Fang, and Mari Ostendorf. 2015.
Open-Domain Name Error Detection using a Multi-
Task RNN. In EMNLP.

Yoon Kim, Yacine Jernite, David Sontag, and Alexan-
der M Rush. 2015. Character-aware neural lan-
guage models. arXiv preprint arXiv:1508.06615.

E. Kiperwasser and Y. Goldberg. 2016. Simple and
Accurate Dependency Parsing Using Bidirectional
LSTM Feature Representations. ArXiv e-prints.

Matthieu Labeau, Kevin L¨oser, and Alexandre Al-
lauzen. 2015. Non-lexical neural architecture for
ﬁne-grained pos tagging. In EMNLP.

Wang Ling, Chris Dyer, Alan W Black, Isabel Tran-
coso, Ramon Fermandez, Silvio Amir, Luis Marujo,
and Tiago Luis. 2015. Finding function in form:
Compositional character models for open vocabu-
lary word representation. In EMNLP.

Kyunghyun Cho.

standing with distributed representation.
abs/1511.07916.

2015. Natural language under-
ArXiv,

Pengfei Liu, Shaﬁq Joty, and Helen Meng. 2015. Fine-
grained opinion mining with recurrent neural net-
works and word embeddings. In EMNLP.

Grzegorz Chrupała. 2013. Text segmentation with
In Workshop on
character-level text embeddings.
Deep Learning for Audio, Speech and Language
Processing, ICML.

Christopher D Manning. 2011. Part-of-speech tag-
ging from 97% to 100%: is it time for some linguis-
tics? In Computational Linguistics and Intelligent
Text Processing. Springer.

Michael Collins. 2002. Discriminative training meth-

Joakim Nivre,

ods for Hidden Markov Models. In EMNLP.

Ronan Collobert, Jason Weston, L´eon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
The Journal of Machine Learning Re-
scratch.
search, 12:2493–2537.

Jeffrey L Elman. 1990. Finding structure in time.

Cognitive science, 14(2):179–211.

Dan Gillick, Cliff Brunk, Oriol Vinyals, and Amarnag
Subramanya. 2016. Multilingual language process-
ing from bytes. In NAACL.

Yoav Goldberg. 2015. A primer on neural network
models for natural language processing. ArXiv,
abs/1510.00726.

Alex Graves and J¨urgen Schmidhuber. 2005. Frame-
wise phoneme classiﬁcation with bidirectional lstm
and other neural network architectures. Neural Net-
works, 18(5):602–610.

Sepp Hochreiter and J¨urgen Schmidhuber.

1997.
Neural computation,

Long short-term memory.
9(8):1735–1780.

Tobias Horsmann, Nicolai Erbs, and Torsten Zesch.
2015. Fast or accurate?–a comparative evaluation of
pos tagging models. In Proceedings of the Interna-
tional Conference of the German Society for Com-
putational Linguistics and Language Technology.

ˇZeljko Agi´c, Maria Jesus Aranzabe,
Masayuki Asahara, Aitziber Atutxa, Miguel Balles-
teros, John Bauer, Kepa Bengoetxea, Riyaz Ah-
mad Bhat, Cristina Bosco, Sam Bowman, Giuseppe
G. A. Celano, Miriam Connor, Marie-Catherine
de Marneffe, Arantza Diaz de Ilarraza, Kaja Do-
brovoljc, Timothy Dozat, Tomaˇz Erjavec, Rich´ard
Farkas, Jennifer Foster, Daniel Galbraith, Filip Gin-
ter, Iakes Goenaga, Koldo Gojenola, Yoav Gold-
berg, Berta Gonzales, Bruno Guillaume, Jan Hajiˇc,
Dag Haug, Radu Ion, Elena Irimia, Anders Jo-
hannsen, Hiroshi Kanayama, Jenna Kanerva, Simon
Krek, Veronika Laippala, Alessandro Lenci, Nikola
Ljubeˇsi´c, Teresa Lynn, Christopher Manning, Ctlina
Mrnduc, David Mareˇcek, H´ector Mart´ınez Alonso,
Jan Maˇsek, Yuji Matsumoto, Ryan McDonald,
Anna Missil¨a, Verginica Mititelu, Yusuke Miyao,
Simonetta Montemagni, Shunsuke Mori, Hanna
Nurmi, Petya Osenova, Lilja Øvrelid, Elena Pascual,
Marco Passarotti, Cenel-Augusto Perez, Slav Petrov,
Jussi Piitulainen, Barbara Plank, Martin Popel,
Prokopis Prokopidis, Sampo Pyysalo, Loganathan
Ramasamy, Rudolf Rosa, Shadi Saleh, Sebastian
Schuster, Wolfgang Seeker, Mojgan Seraji, Natalia
Silveira, Maria Simi, Radu Simionescu, Katalin
Simk´o, Kiril Simov, Aaron Smith, Jan ˇStˇep´anek,
Alane Suhr, Zsolt Sz´ant´o, Takaaki Tanaka, Reut
Tsarfaty, Sumire Uematsu, Larraitz Uria, Viktor
Varga, Veronika Vincze, Zdenˇek ˇZabokrtsk´y, Daniel
Zeman, and Hanzhi Zhu. 2015. Universal depen-
dencies 1.2. LINDAT/CLARIN digital library at In-
stitute of Formal and Applied Linguistics, Charles
University in Prague.

Zhiheng Huang, Wei Xu, and Kai Yu. 2015. Bidi-
rectional LSTM-CRF models for sequence tagging.
arXiv preprint arXiv:1508.01991.

Barbara Plank, Dirk Hovy, Ryan McDonald, and An-
ders Søgaard. 2014. Adapting taggers to twitter us-
ing not-so-distant supervision. In COLING.

Cicero D Santos and Bianca Zadrozny. 2014. Learning
character-level representations for part-of-speech
tagging. In ICML.

Ilya Sutskever, James Martens, and Geoffrey E Hin-
ton. 2011. Generating text with recurrent neural
networks. In ICML.

Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014.
Sequence to sequence learning with neural net-
works. In NIPS.

Peilu Wang, Yao Qian, Frank K. Soong, Lei He, and
Hai Zhao. 2015. Part-of-speech tagging with bidi-
rectional long short-term memory recurrent neural
network. pre-print, abs/1510.06168.

Xiang Zhang, Junbo Zhao, and Yann LeCun. 2015.
Character-level convolutional networks for text clas-
siﬁcation. In Advances in Neural Information Pro-
cessing Systems, pages 649–657.

Jie Zhou and Wei Xu. 2015. End-to-end learning of
semantic role labeling using recurrent neural net-
works. In ACL.

Multilingual Part-of-Speech Tagging with
Bidirectional Long Short-Term Memory Models and Auxiliary Loss

Barbara Plank
University of Groningen
The Netherlands
b.plank@rug.nl

Anders Søgaard
University of Copenhagen
Denmark
soegaard@hum.ku.dk

Yoav Goldberg
Bar-Ilan University
Israel
yoav.goldberg@gmail.com

6
1
0
2
 
l
u
J
 
1
2
 
 
]
L
C
.
s
c
[
 
 
3
v
9
2
5
5
0
.
4
0
6
1
:
v
i
X
r
a

Abstract

Bidirectional long short-term memory (bi-
LSTM) networks have recently proven
successful for various NLP sequence mod-
eling tasks, but
little is known about
their reliance to input representations, tar-
get languages, data set size, and label
noise. We address these issues and eval-
uate bi-LSTMs with word, character, and
unicode byte embeddings for POS tag-
ging. We compare bi-LSTMs to tradi-
tional POS taggers across languages and
data sizes. We also present a novel bi-
LSTM model, which combines the POS
tagging loss function with an auxiliary
loss function that accounts for rare words.
The model obtains state-of-the-art perfor-
mance across 22 languages, and works es-
pecially well for morphologically complex
languages. Our analysis suggests that bi-
LSTMs are less sensitive to training data
size and label corruptions (at small noise
levels) than previously assumed.

1

Introduction

Recently, bidirectional long short-term memory
networks (bi-LSTM) (Graves and Schmidhuber,
2005; Hochreiter and Schmidhuber, 1997) have
been used for language modelling (Ling et al.,
2015), POS tagging (Ling et al., 2015; Wang
et al., 2015), transition-based dependency pars-
ing (Ballesteros et al., 2015; Kiperwasser and
Goldberg, 2016), ﬁne-grained sentiment analysis
(Liu et al., 2015), syntactic chunking (Huang et
al., 2015), and semantic role labeling (Zhou and
Xu, 2015). LSTMs are recurrent neural networks
(RNNs) in which layers are designed to prevent
vanishing gradients. Bidirectional LSTMs make a
backward and forward pass through the sequence

before passing on to the next layer. For further de-
tails, see (Goldberg, 2015; Cho, 2015).

We consider using bi-LSTMs for POS tagging.
Previous work on using deep learning-based meth-
ods for POS tagging has focused either on a sin-
gle language (Collobert et al., 2011; Wang et al.,
2015) or a small set of languages (Ling et al.,
Instead we
2015; Santos and Zadrozny, 2014).
evaluate our models across 22 languages. In ad-
dition, we compare performance with represen-
tations at different levels of granularity (words,
characters, and bytes). These levels of represen-
tation were previously introduced in different ef-
forts (Chrupała, 2013; Zhang et al., 2015; Ling
et al., 2015; Santos and Zadrozny, 2014; Gillick
et al., 2016; Kim et al., 2015), but a comparative
evaluation was missing.

Moreover, deep networks are often said to re-
quire large volumes of training data. We investi-
gate to what extent bi-LSTMs are more sensitive
to the amount of training data and label noise than
standard POS taggers.

Finally, we introduce a novel model, a bi-LSTM
trained with auxiliary loss. The model jointly pre-
dicts the POS and the log frequency of the word.
The intuition behind this model is that the aux-
iliary loss, being predictive of word frequency,
helps to differentiate the representations of rare
and common words. We indeed observe perfor-
mance gains on rare and out-of-vocabulary words.
These performance gains transfer into general im-
provements for morphologically rich languages.

Contributions
In this paper, we a) evaluate the
effectiveness of different representations in bi-
LSTMs, b) compare these models across a large
set of languages and under varying conditions
(data size, label noise) and c) propose a novel bi-
LSTM model with auxiliary loss (LOGFREQ).

2 Tagging with bi-LSTMs

Recurrent neural networks (RNNs) (Elman, 1990)
allow the computation of ﬁxed-size vector repre-
sentations for word sequences of arbitrary length.
An RNN is a function that reads in n vectors
x1, ..., xn and produces an output vector hn, that
depends on the entire sequence x1, ..., xn. The
vector hn is then fed as an input to some classi-
ﬁer, or higher-level RNNs in stacked/hierarchical
models. The entire network is trained jointly such
that the hidden representation captures the impor-
tant information from the sequence for the predic-
tion task.

A bidirectional recurrent neural network (bi-
RNN) (Graves and Schmidhuber, 2005) is an ex-
tension of an RNN that reads the input sequence
twice, from left to right and right to left, and the
encodings are concatenated. The literature uses
the term bi-RNN to refer to two related architec-
tures, which we refer to here as “context bi-RNN”
and “sequence bi-RNN”. In a sequence bi-RNN
(bi-RNNseq), the input is a sequence of vectors
x1:n and the output is a concatenation (◦) of a for-
ward (f ) and reverse (r) RNN each reading the
sequence in a different directions:

v = bi-RNNseq(x1:n) = RNNf (x1:n) ◦ RNNr(xn:1)

In a context bi-RNN (bi-RNNctx), we get an addi-
tional input i indicating a sequence position, and
the resulting vectors vi result from concatenating
the RNN encodings up to i:

vi = bi-RNNctx(x1:n, i) = RNNf (x1:i) ◦ RNNr(xn:i)

Thus, the state vector vi in this bi-RNN encodes
information at position i and its entire sequential
context. Another view of the context bi-RNN is
of taking a sequence x1:n and returning the corre-
sponding sequence of state vectors v1:n.

LSTMs (Hochreiter and Schmidhuber, 1997)
are a variant of RNNs that replace the cells of
RNNs with LSTM cells that were designed to pre-
vent vanishing gradients. Bidirectional LSTMs
are the bi-RNN counterpart based on LSTMs.

Our basic bi-LSTM tagging model is a context
bi-LSTM taking as input word embeddings (cid:126)w. We
incorporate subtoken information using an hierar-
chical bi-LSTM architecture (Ling et al., 2015;
Ballesteros et al., 2015). We compute subtoken-
level (either characters (cid:126)c or unicode byte(cid:126)b) embed-
dings of words using a sequence bi-LSTM at the

lower level. This representation is then concate-
nated with the (learned) word embeddings vector
(cid:126)w which forms the input to the context bi-LSTM at
the next layer. This model, illustrated in Figure 1
(lower part in left ﬁgure), is inspired by Balles-
teros et al. (2015). We also test models in which
we only keep sub-token information, e.g., either
both byte and character embeddings (Figure 1,
right) or a single (sub-)token representation alone.

Figure 1: Right: bi-LSTM, illustrated with (cid:126)b + (cid:126)c
(bytes and characters), for (cid:126)w + (cid:126)c replace (cid:126)b with
words (cid:126)w. Left: FREQBIN, our multi-task bi-
LSTM that predicts at every time step the tag and
the frequency class for the token.

In our novel model, cf. Figure 1 left, we train
the bi-LSTM tagger to predict both the tags of the
sequence, as well as a label that represents the
log frequency of the token as estimated from the
training data. Our combined cross-entropy loss
is now: L( ˆyt, yt) + L( ˆya, ya), where t stands for
a POS tag and a is the log frequency label, i.e.,
a = int(log(f reqtrain(w)). Combining this log
frequency objective with the tagging task can be
seen as an instance of multi-task learning in which
the labels are predicted jointly. The idea behind
this model is to make the representation predictive
for frequency, which encourages the model to not
share representations between common and rare
words, thus beneﬁting the handling of rare tokens.

3 Experiments

All bi-LSTM models were implemented in
CNN/pycnn,1 a ﬂexible neural network library.
For all models we use the same hyperparameters,
which were set on English dev, i.e., SGD train-
ing with cross-entropy loss, no mini-batches, 20

1https://github.com/clab/cnn

epochs, default learning rate (0.1), 128 dimensions
for word embeddings, 100 for character and byte
embeddings, 100 hidden states and Gaussian noise
with σ=0.2. As training is stochastic in nature, we
use a ﬁxed seed throughout. Embeddings are not
initialized with pre-trained embeddings, except
when reported otherwise. In that case we use off-
the-shelf polyglot embeddings (Al-Rfou et al.,
2013).2 No further unlabeled data is considered
in this paper. The code is released at: https:
//github.com/bplank/bilstm-aux

Taggers We want to compare POS taggers un-
der varying conditions. We hence use three dif-
ferent types of taggers: our implementation of a
bi-LSTM; TNT (Brants, 2000)—a second order
HMM with sufﬁx trie handling for OOVs. We use
TNT as it was among the best performing taggers
evaluated in Horsmann et al. (2015).3 We comple-
ment the NN-based and HMM-based tagger with
a CRF tagger, using a freely available implemen-
tation (Plank et al., 2014) based on crfsuite.

3.1 Datasets

For the multilingual experiments, we use the
data from the Universal Dependencies project
v1.2 (Nivre et al., 2015) (17 POS) with the canon-
ical data splits. For languages with token segmen-
tation ambiguity we use the provided gold seg-
mentation.
If there is more than one treebank
per language, we use the treebank that has the
canonical language name (e.g., Finnish instead of
Finnish-FTB). We consider all languages that have
at least 60k tokens and are distributed with word
forms, resulting in 22 languages. We also re-
port accuracies on WSJ (45 POS) using the stan-
dard splits (Collins, 2002; Manning, 2011). The
overview of languages is provided in Table 1.

3.2 Results

Our results are given in Table 2. First of all, no-
tice that TNT performs remarkably well across the
22 languages, closely followed by CRF. The bi-
LSTM tagger ( (cid:126)w) without lower-level bi-LSTM
for subtokens falls short, outperforms the tradi-
tional taggers only on 3 languages. The bi-LSTM

2https://sites.google.com/site/rmyeid/

projects/polyglot

3They found TreeTagger was closely followed by Hun-
Pos, a re-implementation of TnT, and Stanford and ClearNLP
were lower ranked. In an initial investigation, we compared
Tnt, HunPos and TreeTagger and found Tnt to be consistently
better than Treetagger, Hunpos followed closely but crashed
on some languages (e.g., Arabic).

COARSE

FINE

COARSE

FINE

non-IE
ar
Indoeuropean
bg
Indoeuropean
cs
Indoeuropean
da
Indoeuropean
de
Indoeuropean
en
Indoeuropean
es
eu Language isolate
Indoeuropean
fa
non-IE
ﬁ
Indoeuropean
fr

Semitic
Slavic
Slavic
Germanic
Germanic
Germanic
Romance

Indo-Iranian
Uralic
Romance

he
hi
hr
id
it
nl
no
pl
pt
sl
sv

Austronesian

Semitic
Indo-Iranian

non-IE
Indoeuropean
Indoeuropean Slavic
non-IE
Indoeuropean Romance
Indoeuropean Germanic
Indoeuropean Germanic
Indoeuropean Slavic
Indoeuropean Romance
Indoeuropean Slavic
Indoeuropean Germanic

Table 1: Grouping of languages.

model clearly beneﬁts from character representa-
tions. The model using characters alone ((cid:126)c) works
remarkably well, it improves over TNT on 9 lan-
guages (incl. Slavic and Nordic languages). The
combined word+character representation model is
the best representation, outperforming the baseline
on all except one language (Indonesian), provid-
ing strong results already without pre-trained em-
beddings. This model ( (cid:126)w + (cid:126)c) reaches the biggest
improvement (more than +2% accuracy) on He-
brew and Slovene. Initializing the word embed-
dings (+POLYGLOT) with off-the-shelf language-
speciﬁc embeddings further improves accuracy.
The only system we are aware of that evaluates on
UD is Gillick et al. (2016) (last column). However,
note that these results are not strictly comparable
as they use the earlier UD v1.1 version.

The overall best system is the multi-task bi-
LSTM FREQBIN (it uses (cid:126)w + (cid:126)c and POLYGLOT
initialization for (cid:126)w). While on macro average it
is on par with bi-LSTM (cid:126)w + (cid:126)c, it obtains the best
results on 12/22 languages, and it is successful in
predicting POS for OOV tokens (cf. Table 2 OOV
ACC columns), especially for languages like Ara-
bic, Farsi, Hebrew, Finnish.

We examined simple RNNs and conﬁrm the
ﬁnding of Ling et al. (2015) that they performed
worse than their LSTM counterparts. Finally, the
bi-LSTM tagger is competitive on WSJ, cf. Ta-
ble 3.

Rare words
In order to evaluate the effect of
modeling sub-token information, we examine ac-
curacy rates at different frequency rates. Figure 2
shows absolute improvements in accuracy of bi-
LSTM (cid:126)w + (cid:126)c over mean log frequency, for dif-
ferent language families. We see that especially
for Slavic and non-Indoeuropean languages, hav-
ing high morphologic complexity, most of the im-
provement is obtained in the Zipﬁan tail. Rare to-
kens beneﬁt from the sub-token representations.

BASELINES
CRF
TNT

BI-LSTM using:
(cid:126)c + (cid:126)b

(cid:126)c

(cid:126)w

(cid:126)w + (cid:126)c

(cid:126)w + (cid:126)c +POLYGLOT
bi-LSTM FREQBIN bi-LSTM FREQBIN

OOV ACC

avg

94.61

94.27

96.00†

94.29

94.01

92.37

Indoeur.
non-Indo.
Germanic
Romance
Slavic

ar
bg
cs
da
de
en
es
eu
fa
ﬁ
fr
he
hi
hr
id
it
nl
no
pl
pt
sl
sv

94.70
94.57
93.27
95.37
95.64

97.82
96.84
96.82
94.29
92.64
92.66
94.55
93.35
95.98
93.59
94.51
93.71
94.53
94.06
93.16
96.16
88.54
96.31
95.57
96.27
94.92
95.19

94.58
93.62
93.21
95.53
94.96

97.56
96.36
96.56
93.83
91.38
93.35
94.23
91.63
95.65
90.32
95.14
93.63
96.00
93.16
92.96
96.43
90.03
96.21
93.96
96.32
94.77
94.45

96.15†
95.67†
95.09†
96.51†
96.91†

98.91
98.02
97.80
96.19
92.64
94.46
95.12
94.70
97.19
94.85
95.80
95.79
96.23
94.76
93.11
97.59
93.32
97.57
96.41
97.53
97.55
96.36

94.58
93.51
92.89
94.76
96.45

98.68
97.89
96.38
95.12
90.02
91.62
93.06
92.48
95.82
90.25
94.39
93.74
93.40
95.32
91.37
95.62
89.11
95.87
95.80
95.96
96.87
95.57

94.28
93.16
92.59
94.49
96.26

98.43
97.78
96.08
94.88
90.11
91.57
92.29
92.72
95.03
89.15
93.69
93.58
92.99
94.47
91.46
95.77
87.74
95.75
96.19
96.20
96.77
95.50

92.72
91.97
91.18
94.71
91.79

95.48
95.12
93.77
91.96
90.33
92.10
93.60
88.00
95.31
87.95
94.44
93.97
95.99
89.24
90.48
96.57
84.96
94.39
89.73
94.24
91.09
93.32

96.50

96.63
96.21
95.55
96.93
97.42

98.87
98.23
98.02
96.16
93.51
95.17
95.67
95.38
97.60
95.74
96.20
96.92
96.97
96.27
93.32
97.90
93.82
98.06
97.63
97.94
96.97
96.60

96.52

96.63
96.28
95.49
96.93
97.50

98.91
97.97
98.24
96.35
93.38
95.16
95.74
95.51
97.49
95.85
96.11
96.96
97.10
96.82
93.41
97.95
93.30
98.03
97.62
97.90
96.84
96.69

83.48

82.77
87.44
81.22
81.31
86.66

95.04
87.40
89.02
77.09
81.95
71.23
71.38
79.87
80.00
86.34
78.09
80.11
81.19
84.62
88.25
83.59
76.62
92.05
91.77
92.16
80.48
88.37

BTS

95.70

–
–
–
–
–

–
97.84
98.50
95.52
92.87
93.87
95.80
–
96.82
95.48
95.75
–
–
–
92.85
97.56
–
–
–
–
–
95.57

87.98

87.63
90.39
85.45
86.07
91.69

96.21
90.56
91.30
86.35
86.77
80.11
79.27
84.30
89.05
88.85
83.54
88.83
85.27
92.71
87.67
89.15
75.95
93.72
94.94
92.33
88.94
89.80

Table 2: Tagging accuracies on UD 1.2 test sets. (cid:126)w: words, (cid:126)c: characters, (cid:126)b: bytes. Bold/†: best
accuracy/representation; +POLYGLOT: using pre-trained embeddings. FREQBIN: our multi-task model.
OOV ACC: accuracies on OOVs. BTS: best results in Gillick et al. (2016) (not strictly comparable).

WSJ

Convnet (Santos and Zadrozny, 2014)
Convnet reimplementation (Ling et al., 2015)
Bi-RNN (Ling et al., 2015)
Bi-LSTM (Ling et al., 2015)

Our bi-LSTM (cid:126)w+(cid:126)c

Accuracy

97.32
96.80
95.93
97.36

97.22

Table 3: Comparison POS accuracy on WSJ; bi-
LSTM: 30 epochs, σ=0.3, no POLYGLOT.

ing amounts of training instances (number of sen-
tences). The learning curves in Figure 3 show
similar trends across language families.4 TNT
is better with little data, bi-LSTM is better with
more data, and bi-LSTM always wins over CRF.
The bi-LSTM model performs already surpris-
ingly well after only 500 training sentences. For
non-Indoeuropean languages it is on par and above

4We observe the same pattern with more, 40, iterations.

Figure 2: Absolute improvements of bi-LSTM
( (cid:126)w + (cid:126)c) over TNT vs mean log frequency.

Data set size Prior work mostly used large
data sets when applying neural network based
approaches (Zhang et al., 2015). We evaluate
how brittle such models are with respect to their
more traditional counterparts by training bi-LSTM
( (cid:126)w + (cid:126)c without Polyglot embeddings) for increas-

state-of-the-art performance close to taggers us-
ing carefully designed feature templates. Ling et
al. (2015) extend this line and compare a novel
bi-LSTM model,
learning word representations
through character embeddings. They evaluate
their model on a language modeling and POS tag-
ging setup, and show that bi-LSTMs outperform
the CNN approach of Santos and Zadrozny (2014).
Similarly, Labeau et al. (2015) evaluate character
embeddings for German. Bi-LSTMs for POS tag-
ging are also reported in Wang et al. (2015), how-
ever, they only explore word embeddings, ortho-
graphic information and evaluate on WSJ only. A
related study is Cheng et al. (2015) who propose a
multi-task RNN for named entity recognition by
jointly predicting the next token and current to-
ken’s name label. Our model is simpler, it uses
a very coarse set of labels rather then integrating
an entire language modeling task which is compu-
tationally more expensive. An interesting recent
study is Gillick et al. (2016), they build a single
byte-to-span model for multiple languages based
on a sequence-to-sequence RNN (Sutskever et al.,
2014) achieving impressive results. We would like
to extend this work in their direction.

5 Conclusions

We evaluated token and subtoken-level representa-
tions for neural network-based part-of-speech tag-
ging across 22 languages and proposed a novel
multi-task bi-LSTM with auxiliary loss. The aux-
iliary loss is effective at improving the accuracy of
rare words.

Subtoken representations are necessary to ob-
tain a state-of-the-art POS tagger, and charac-
ter embeddings are particularly helpful for non-
Indoeuropean and Slavic languages.

Combining them with word embeddings in a hi-
erarchical network provides the best representa-
tion. The bi-LSTM tagger is as effective as the
CRF and HMM taggers with already as little as
500 training sentences, but is less robust to label
noise (at higher noise rates).

Acknowledgments

We thank the anonymous reviewers for their feed-
back. AS is funded by the ERC Starting Grant
LOWLANDS No. 313695. YG is supported by
The Israeli Science Foundation (grant number
1555/15) and a Google Research Award.

Figure 3: Amount of training data (number of sen-
tences) vs tagging accuracy.

the other taggers with even less data (100 sen-
tences). This shows that the bi-LSTMs often needs
more data than the generative markovian model,
but this is deﬁnitely less than what we expected.

Label Noise We investigated the susceptibility
of the models to noise, by artiﬁcially corrupting
training labels. Our initial results show that at low
noise rates, bi-LSTMs and TNT are affected sim-
ilarly, their accuracies drop to a similar degree.
Only at higher noise levels (more than 30% cor-
rupted labels), bi-LSTMs are less robust, showing
higher drops in accuracy compared to TNT. This
is the case for all investigated language families.

4 Related Work

introduced
Character embeddings were ﬁrst
by Sutskever et al. (2011) for language model-
ing. Early applications include text classiﬁca-
tion (Chrupała, 2013; Zhang et al., 2015). Re-
cently, these representations were successfully ap-
plied to a range of structured prediction tasks. For
POS tagging, Santos and Zadrozny (2014) were
the ﬁrst to propose character-based models. They
use a convolutional neural network (CNN; or con-
vnet) and evaluated their model on English (PTB)
and Portuguese, showing that the model achieves

References

Rami Al-Rfou, Bryan Perozzi, and Steven Skiena.
2013. Polyglot: Distributed Word Representations
for Multilingual NLP. In CoNLL.

Miguel Ballesteros, Chris Dyer, and Noah A. Smith.
2015. Improved Transition-based Parsing by Mod-
eling Characters instead of Words with LSTMs. In
EMNLP.

Thorsten Brants.
speech tagger.
ence on Applied natural language processing.

2000. Tnt: a statistical part-of-
In Proceedings of the sixth confer-

Hao Cheng, Hao Fang, and Mari Ostendorf. 2015.
Open-Domain Name Error Detection using a Multi-
Task RNN. In EMNLP.

Yoon Kim, Yacine Jernite, David Sontag, and Alexan-
der M Rush. 2015. Character-aware neural lan-
guage models. arXiv preprint arXiv:1508.06615.

E. Kiperwasser and Y. Goldberg. 2016. Simple and
Accurate Dependency Parsing Using Bidirectional
LSTM Feature Representations. ArXiv e-prints.

Matthieu Labeau, Kevin L¨oser, and Alexandre Al-
lauzen. 2015. Non-lexical neural architecture for
ﬁne-grained pos tagging. In EMNLP.

Wang Ling, Chris Dyer, Alan W Black, Isabel Tran-
coso, Ramon Fermandez, Silvio Amir, Luis Marujo,
and Tiago Luis. 2015. Finding function in form:
Compositional character models for open vocabu-
lary word representation. In EMNLP.

Kyunghyun Cho.

standing with distributed representation.
abs/1511.07916.

2015. Natural language under-
ArXiv,

Pengfei Liu, Shaﬁq Joty, and Helen Meng. 2015. Fine-
grained opinion mining with recurrent neural net-
works and word embeddings. In EMNLP.

Grzegorz Chrupała. 2013. Text segmentation with
In Workshop on
character-level text embeddings.
Deep Learning for Audio, Speech and Language
Processing, ICML.

Christopher D Manning. 2011. Part-of-speech tag-
ging from 97% to 100%: is it time for some linguis-
tics? In Computational Linguistics and Intelligent
Text Processing. Springer.

Michael Collins. 2002. Discriminative training meth-

Joakim Nivre,

ods for Hidden Markov Models. In EMNLP.

Ronan Collobert, Jason Weston, L´eon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
The Journal of Machine Learning Re-
scratch.
search, 12:2493–2537.

Jeffrey L Elman. 1990. Finding structure in time.

Cognitive science, 14(2):179–211.

Dan Gillick, Cliff Brunk, Oriol Vinyals, and Amarnag
Subramanya. 2016. Multilingual language process-
ing from bytes. In NAACL.

Yoav Goldberg. 2015. A primer on neural network
models for natural language processing. ArXiv,
abs/1510.00726.

Alex Graves and J¨urgen Schmidhuber. 2005. Frame-
wise phoneme classiﬁcation with bidirectional lstm
and other neural network architectures. Neural Net-
works, 18(5):602–610.

Sepp Hochreiter and J¨urgen Schmidhuber.

1997.
Neural computation,

Long short-term memory.
9(8):1735–1780.

Tobias Horsmann, Nicolai Erbs, and Torsten Zesch.
2015. Fast or accurate?–a comparative evaluation of
pos tagging models. In Proceedings of the Interna-
tional Conference of the German Society for Com-
putational Linguistics and Language Technology.

ˇZeljko Agi´c, Maria Jesus Aranzabe,
Masayuki Asahara, Aitziber Atutxa, Miguel Balles-
teros, John Bauer, Kepa Bengoetxea, Riyaz Ah-
mad Bhat, Cristina Bosco, Sam Bowman, Giuseppe
G. A. Celano, Miriam Connor, Marie-Catherine
de Marneffe, Arantza Diaz de Ilarraza, Kaja Do-
brovoljc, Timothy Dozat, Tomaˇz Erjavec, Rich´ard
Farkas, Jennifer Foster, Daniel Galbraith, Filip Gin-
ter, Iakes Goenaga, Koldo Gojenola, Yoav Gold-
berg, Berta Gonzales, Bruno Guillaume, Jan Hajiˇc,
Dag Haug, Radu Ion, Elena Irimia, Anders Jo-
hannsen, Hiroshi Kanayama, Jenna Kanerva, Simon
Krek, Veronika Laippala, Alessandro Lenci, Nikola
Ljubeˇsi´c, Teresa Lynn, Christopher Manning, Ctlina
Mrnduc, David Mareˇcek, H´ector Mart´ınez Alonso,
Jan Maˇsek, Yuji Matsumoto, Ryan McDonald,
Anna Missil¨a, Verginica Mititelu, Yusuke Miyao,
Simonetta Montemagni, Shunsuke Mori, Hanna
Nurmi, Petya Osenova, Lilja Øvrelid, Elena Pascual,
Marco Passarotti, Cenel-Augusto Perez, Slav Petrov,
Jussi Piitulainen, Barbara Plank, Martin Popel,
Prokopis Prokopidis, Sampo Pyysalo, Loganathan
Ramasamy, Rudolf Rosa, Shadi Saleh, Sebastian
Schuster, Wolfgang Seeker, Mojgan Seraji, Natalia
Silveira, Maria Simi, Radu Simionescu, Katalin
Simk´o, Kiril Simov, Aaron Smith, Jan ˇStˇep´anek,
Alane Suhr, Zsolt Sz´ant´o, Takaaki Tanaka, Reut
Tsarfaty, Sumire Uematsu, Larraitz Uria, Viktor
Varga, Veronika Vincze, Zdenˇek ˇZabokrtsk´y, Daniel
Zeman, and Hanzhi Zhu. 2015. Universal depen-
dencies 1.2. LINDAT/CLARIN digital library at In-
stitute of Formal and Applied Linguistics, Charles
University in Prague.

Zhiheng Huang, Wei Xu, and Kai Yu. 2015. Bidi-
rectional LSTM-CRF models for sequence tagging.
arXiv preprint arXiv:1508.01991.

Barbara Plank, Dirk Hovy, Ryan McDonald, and An-
ders Søgaard. 2014. Adapting taggers to twitter us-
ing not-so-distant supervision. In COLING.

Cicero D Santos and Bianca Zadrozny. 2014. Learning
character-level representations for part-of-speech
tagging. In ICML.

Ilya Sutskever, James Martens, and Geoffrey E Hin-
ton. 2011. Generating text with recurrent neural
networks. In ICML.

Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014.
Sequence to sequence learning with neural net-
works. In NIPS.

Peilu Wang, Yao Qian, Frank K. Soong, Lei He, and
Hai Zhao. 2015. Part-of-speech tagging with bidi-
rectional long short-term memory recurrent neural
network. pre-print, abs/1510.06168.

Xiang Zhang, Junbo Zhao, and Yann LeCun. 2015.
Character-level convolutional networks for text clas-
siﬁcation. In Advances in Neural Information Pro-
cessing Systems, pages 649–657.

Jie Zhou and Wei Xu. 2015. End-to-end learning of
semantic role labeling using recurrent neural net-
works. In ACL.

