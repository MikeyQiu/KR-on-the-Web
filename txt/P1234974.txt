SLING: A framework for frame semantic parsing

Michael Ringgaard
Google Inc.
ringgaard@google.com

Rahul Gupta
Google Inc.
grahul@google.com

Fernando C. N. Pereira
Google Inc.
pereira@google.com

7
1
0
2
 
t
c
O
 
9
1
 
 
]
L
C
.
s
c
[
 
 
1
v
2
3
0
7
0
.
0
1
7
1
:
v
i
X
r
a

Abstract

We describe SLING, a framework for
parsing natural
language into seman-
SLING supports general
tic frames.
transition-based, neural-network parsing
with bidirectional LSTM input encoding
and a Transition Based Recurrent Unit
(TBRU) for output decoding. The parsing
model is trained end-to-end using only the
text tokens as input. The transition system
has been designed to output frame graphs
directly without any intervening symbolic
representation. The SLING framework in-
cludes an efﬁcient and scalable frame store
implementation as well as a neural net-
work JIT compiler for fast inference dur-
ing parsing. SLING is implemented in
C++ and it is available for download on
GitHub.

1

Introduction

Recent advances in machine learning make it prac-
tical to train recurrent multi-level neural network
classiﬁers, allowing us to rethink the design and
implementation of natural language understanding
(NLU) systems.

Earlier machine-learned NLU systems were
commonly organized as pipelines of separately
trained stages for syntactic and semantic annota-
tion of text. A typical pipeline would start with
part-of-speech (POS) tagging, followed by con-
stituency or dependency parsing for syntactic anal-
ysis. Using the POS tags and parse trees as feature
inputs, later stages in the pipeline could then de-
rive semantically relevant annotations such as en-
tity and concept mentions, entity types, corefer-
ence relationships, and semantic roles (SRL).

For simplicity and efﬁciency, each stage in a
practical NLU pipeline would just output its best

hypothesis and pass it on to the next stage (Finkel
Obviously, errors could then
et al., 2006).
accumulate throughout
the pipeline making it
much harder for the system to perform accu-
rately. For instance, F1 on SRL drops by more
than 10% when going from gold to system parse
trees (Toutanova and Manning, 2005).

However, applications may not need the inter-
mediate annotations produced by the earlier stages
of a NLU pipeline, so it would be preferable if all
stages could be trained together to optimize an ob-
jective based on the output annotations needed for
a particular application.

Earlier NLU pipelines often used linear clas-
siﬁers for each stage. Linear classiﬁers achieve
simplicity and training efﬁciency at the expense
of feature complexity, requiring elaborate feature
extraction, many different feature types, and fea-
ture combinations to achieve reasonable accuracy.
With deep learning, we can use embeddings, mul-
tiple layers, and recurrent network connections to
reduce the need for complex feature design. The
internal learned representations in model hidden
layers replace the hand-crafted feature combina-
tions and intermediate representations in pipelined
systems.

The SLING parser exploits deep learning to by-
pass those limitations of classic pipelined systems.
It is a transition-based parser that outputs frame
graphs directly without any intervening symbolic
representation (see Section 5). Transition-based
parsing is often associated with dependency pars-
ing, but we have designed a specialized transition
system that outputs frame graphs instead of depen-
dency trees.

We use a recurrent feed-forward unit for pre-
dicting the actions in the transition sequence,
where the hidden activations from predicting each
transition step are fed back into subsequent steps.
A bidirectional LSTM (biLSTM) encodes the in-

put into a sequence of vectors(Figure 1). This
neural network architecture has been implemented
using DRAGNN (Kong et al., 2017) and Tensor-
Flow (Abadi et al., 2016).

The SLING framework and a semantic parser
built in it are now available as open-source code
on GitHub.1

In Section 2 we introduce frame semantics, the
linguistic theory that inspired SLING, as well as
the SLING frame store, a C++ framework for
representing and storing semantic frames com-
pactly and efﬁciently. Section 4 introduces the
parser’s frame-semantics-oriented attention mech-
anism, and Section 5 describes the transition sys-
tem used for producing frame graphs. Section 6
describes the features used by the parser. In sec-
tions 7 and 8 we describe our experiments on
OntoNotes, and section 9 describes the fast parser
runtime.

2 Frame semantics

While frames in SLING are not tied to any partic-
ular linguistic theory or knowledge ontology, they
are inspired by frame semantics, the theory of lin-
guistic meaning originally developed by Charles
Fillmore (Fillmore, 1982). Frame semantics con-
nects linguistic semantics to encyclopedic knowl-
edge, with the central idea that understanding the
meaning of a word requires access to all the essen-
tial knowledge that relates to that word. A word
evokes a frame representing the speciﬁc concept it
refers to.

A semantic frame is a set of statements that
give ”characteristic features, attributes, and func-
tions of a denotatum, and its characteristic inter-
actions with things necessarily or typically asso-
ciated with it.” (Alan, 2001). A semantic frame
can also be viewed as a coherent group of concepts
such that complete knowledge of one of them re-
quires knowledge of all of them.

Frame semantics is not just for individual con-
cepts, but can be generalized to phrases, enti-
ties, constructions, and other larger and more
complex linguistic and ontological units.
Se-
mantic frames can also model world knowledge
and inferential relationships in common sense,
metaphor (Narayanan, 1999a), metonymy, ac-
tion (Narayanan, 1999b), and perspective (Chang
et al., 2002).

3 Frames in SLING

SLING represents frames with data structures con-
sisting of a list of slots, where each slot has a
name (role) and a value. The slot values can be
literals like numbers and strings, or links to other
frames. A collection of interlinked frames can thus
be seen as a directed graph where the frames are
the (typed) nodes and the slots are the (labeled)
edges. A frame graph can also be viewed as a
feature structure (Carpenter, 2005) and uniﬁcation
can be used for induction of new frames from ex-
isting frames. Frames can also be used to represent
more basic data structures such as a C struct with
ﬁelds, a JSON object, or a record in a database.

SLING frames live inside a frame store. A
store is a container that tracks all the frames that
have been allocated in the store, and serves as a
memory allocation arena for them. When mak-
ing a new frame, one speciﬁes the store where the
frame should be allocated. The frame will live in
this store until the store is deleted or the frame is
garbage collected because there no remaining live
references to it.2

SLING frames are externally represented in
a superset of JSON that allows references be-
tween frames (JSON objects) with the #n syn-
tax. Frames can be assigned identiﬁers (ids) us-
ing the =#n syntax. SLING frames can have both
numeric and named ids and both slot names and
values can be frame references. Where JSON ob-
jects can only represent trees, SLING frames can
be used for representing arbitrary graphs. SLING
has special syntax for built-in slot names:

Syntax Symbol
id:name
=name
isa:name
:name
is:name
+name

RDF
rdf:ID
rdf:InstanceOf
rdfs:subClassOf

Documents are also represented using frames,
where the document frame has slots for the docu-
ment text, the tokens, and the mention phrases and
the frames they evoke. See Figure 2 for an exam-
ple.

4 Attention

The SLING parser is a kind of sequence-to-
sequence model that ﬁrst encodes the input text to-
ken sequence with a bidirectional LSTM encoder

2See the SLING Guide for a detailed description of the

1https://github.com/google/sling

SLING frame store implementation.

Figure 1: Neural network architecture of the SLING parser. The input is encoded by a bi-directional
LSTM and fed into a recurrent feed-forward (FF) unit that proposes transition system actions. The
hidden layer activations and the transition system state are combined to create the input feature vector
for the next step. The FF unit is run repeatedly until the transition system has reached a ﬁnal state.

and then runs the transition system on that encod-
ing to produce a sequence of transitions, where
each transition updates the system state that com-
bined with the input encoding form the input for
the transition feed-forward cell that predicts the
next transition (Figure 1).

Sequence-to-sequence models often rely on an
“attention” mechanism to focus the decoder on the
parts of the input most relevant for producing the
next output symbol.
In this work, however, we
use a somewhat difference attention mechanism,
loosely inspired on neuroscience models of atten-
tion and awareness (Nelson et al., 2017; Graziano,
2013). In our model, attention focuses on parts of
the frame representation that the parser has cre-
ated so far, rather than focusing on (encodings of)
input tokens as is common for other sequence-to-
sequence attention mechanisms.

We maintain an attention buffer as part of the
transition system state. This an ordered list of
frames, where the order represents closeness to
the center of attention. Transition system actions

maintain the attention buffer, bringing a frame to
the front when the frame is evoked or re-evoked
by the input text. When a new frame is evoked,
it will merge the concept and its roles into a new
coherent chunk of meaning, which is represented
by the new frame and its relations to other frames,
and this will become the new center of attention.
Our hypothesis is that by maintaining this atten-
tion mechanism, we only need to look at a few
recent frames brought into attention to build the
desired frame graph.

5 Transition system

Transition systems are widely used in parsing to
build dependency parse trees as a side effect of
performing a sequence state transitions (si, ai)
where si is a state and ai is an action. Ac-
tion ai computes the new state si+1 from state
si. For example, the arc-standard transition sys-
tem (Nivre, 2006) uses a sequence of SHIFT,
LEFT-ARC(label), and RIGHT-ARC(label) ac-
tions, operating on a state whose main component

{

:/s/document
/s/document/text: "John hit the ball"
/s/document/tokens: [

{/s/token/text: "John" /s/token/start: 0
/s/token/start: 5
{/s/token/text: "hit"
{/s/token/text: "the"
/s/token/start: 9
{/s/token/text: "ball" /s/token/start: 13 /s/token/length: 4}

/s/token/length: 4},
/s/token/length: 3},
/s/token/length: 3},

]
/s/document/mention: {

:/s/phrase /s/phrase/begin: 0
/s/phrase/evokes: {=#1 :/saft/person }

}
/s/document/mention: {

:/s/phrase /s/phrase/begin: 1
/s/phrase/evokes: {

:/pb/hit-01
/pb/arg0: #1
/pb/arg1: #2

}

}
/s/document/mention: {

:/s/phrase /s/phrase/begin: 3
/s/phrase/evokes: {=#2 :/saft/consumer_good }

}

}

Figure 2: The text “John hit the ball” in SLING frame notation. The document itself is represented by a
frame that has the text, an array of tokens and the mentions that evoke frames. There are three frames:
a person frame (John), a consumer good frame (bat) and a hit-01 frame. The hit frame has the person
frame as the agent (arg0) and the ball frame as the object (arg1).

is a stack, to build a dependency parse tree.

actions:

We use the same idea to construct a frame graph
where frames can be evoked by phrases in the in-
put. But instead of using a stack in the state, we
use the attention buffer introduced in the previous
section that keeps track of the most salient frames
in the discourse.

The attention buffer is a priority list of all the
frames evoked so far. The front of the buffer serves
as the working memory for the parser. Actions op-
erate on the front of the buffer and in some cases
other frames in the buffer. The transition system
simultaneously builds the frame graph and main-
tains the attention buffer by moving the frame in-
volved involved in an action to the front of the at-
tention buffer. At any time, each evoked frame has
a unique position in the attention buffer.

The transition system consists of the following

• SHIFT – Moves to next input token. Only
valid when not at the end of the input buffer.

• STOP – Signals that we have reach the end
of the parse. This is only valid when at the
end of the input buffer. Multiple STOP ac-
tions can be added to the transition sequence,
e.g. to make all sequences in a beam have the
same length. After a STOP is issued, no other
actions are permitted except more STOP ac-
tions.

• EVOKE(type, n) – Evokes a frame of type
type from the next n tokens in the input. The
evoked frame is inserted at the front of the
attention buffer, becoming the new center of
attention.

• REFER(frame, n) – Makes a new mention
from the next n tokens in the input evoking
an existing frame in the attention buffer. This
frame is moved to the front of the attention
buffer and will become the new center of at-
tention.

an oracle sequence generator that takes a doc-
ument and converts it to a canonical transition
sequence in a way similar to how this is done
for transition-based dependency parsing (Nivre,
2006). For example, the sentence “John hit the
ball” generates the following transition sequence:

• CONNECT(source, role, target) – Adds
slot to source frame in the attention buffer
with name role and value target where tar-
get is an existing frame in the attention buffer.
The source frame become the new center of
attention.

• ASSIGN(source, role, value) – Adds slot
to source frame in the attention buffer with
name role and constant value value and
moves the frame to the front of the buffer.
This action is only used for assigning a con-
stant value to a slot, in contrast to CON-
NECT where the value is another frame in
the attention buffer.

• EMBED(target, role, type) – Creates a new
frame with type type and adds a slot to it with
name role and value target where target is
an existing frame in the attention buffer. The
new frame becomes the center of attention.

• ELABORATE(source, role, type) – Creates
a new frame with type type and adds a slot
to an existing frame source in the attention
buffer with role set to the new frame. The
new frame becomes the center of attention.

In summary, EVOKE and REFER are used to
evoke frames from text mentions, while ELABO-
RATE and EMBED are used to create frames not
directly evoked by text.

This transition system can generate any con-
nected frame graph where the frames are either di-
rectly on indirectly evoked by phrases in the text.
A frame can be evoked by multiple mentions and
the graph can have cycles.

The transition system can potentially have an
unbounded number of actions since it is parame-
terized by phrase length and attention buffer in-
dices which can be arbitrarily large. In the current
implementation, we only consider the top k frames
in the attention buffer (k = 5) and we do not con-
sider any phrases longer than those in the training
corpus.

Multiple transition sequences can generate the
same frame annotations, but we have implemented

EVOKE(/saft/person, 1)
SHIFT
EVOKE(/pb/hit-01, 1)
CONNECT(0, /pb/arg0, 1)
SHIFT
SHIFT
EVOKE(/saft/consumer_good, 1)
CONNECT(1, /pb/arg1, 0)
SHIFT
STOP

6 Features

The biLSTM uses only lexical features based on
the current input word:

• The current word itself. During training we
initialize the embedding for this feature from
pre-trained word embeddings (Mikolov et al.,
2013) for all the words in the the training
data.

• The preﬁxes and sufﬁxes of the current input
word. We use only preﬁxes up to three char-
acters in our experiments.

• Word shape features based on the characters
in the current input word: hyphenation, cap-
italization, punctuation, quotes, and digits.
Each of these features has its own embedding
matrix.

The TBRU is a simple feed-forward unit with
a single hidden layer. It takes the hidden activa-
tions from the biLSTM as well as the activations
from the hidden layer from the previous steps as
raw input features, and maps them through em-
bedding matrices to get the input vector for the
hidden layer. More speciﬁcally, the inputs to the
TBRU are as follows:

• The left-to-right and right-to-left LSTMs
supply their activations for the current token
in the parser state.

• The attention feature looks at

the top-k
frames in the attention buffer and ﬁnds the
phrases in the text (if any) that evoked them.

The activations from the left-to-right and
right-to-left LSTMs for the last token of each
of those phrases are are included as TBRU
inputs, serving as continuous lexical repre-
sentations of the top-k frames in the attention
buffer.

• The hidden layer activations of the transition
steps which evoked or brought into focus the
top-k frames in the attention buffer are also
inputs to the TBRU, providing a continuous
representation for the semantic frame con-
texts that evoked those frames most recently.

• The history feature uses the hidden activa-
tions in the feed-forward unit from the pre-
vious k steps as feature inputs to the current
step.

• Embeddings of triples of the form (si, ri, ti),
0 < si, ti ≤ k encode the fact that the frame
at position si in the attention buffer has a role
ri with the frame at position ti in the atten-
tion buffer as its value. Back-off features are
added for the source roles (si, ri), target role
(ri, ti), and unlabeled roles (si, ti).

7 Experiments

We derived a corpus annotated with seman-
tic frames from the OntoNotes corpus (Pradhan
and Xue, 2009). We took the PropBank SRL
layer (Palmer et al., 2005) and converted the
predicate-argument structures into frame annota-
tions. We also annotated the corpus with entity
frames based on entity types from a state-of-the-
art entity tagger. We determined the head token of
each argument span and if this coincided with the
span of an existing frame, then we used it as the
evoking span for the argument frame, otherwise
we just used the head token as the evoking span of
the argument frame.

The various frame types mentioned above are
listed in Table 1. They include 7 conventional
entity types, 6 top-level non-entity types (e.g.
date), 13 measurement types, and more than 5400
PropBank frame types. All the frame roles are
collapsed onto /pb/arg0,
/pb/arg1, and so on.
Our training corpus size was 111, 006 sentences,
2, 206, 274 tokens.

Table 2 shows action statistics for the transi-
tion sequences that generate the gold frames in the
training corpus. As expected, there is one SHIFT

Figure 3: Frame graph quality metrics on dev set
as training progresses. Training was stopped at
120, 000 iterations since we saw very little im-
provement after that.

action per training token, and one STOP action per
training sentence. The EVOKE action occurred
with 5, 532 unique (length, type) arguments in the
corpus, for a raw count of roughly 1.08 million
action tokens. Overall our action space had 6968
action types, which is also the size of the softmax
layer of our TBRU decoder.
Hyperparameters: Our ﬁnal set of hyperpa-
rameters after grid search with a dev corpus
learning rate = 0.0005, optimizer =
was:
Adam (Kingma and Ba, 2014) with β1 = 0.01,
β2 = 0.999, (cid:15) = 1e − 5, no dropout, gradient
clipping at 1.0, exponential moving average, no
layer normalization, and a training batch size of
8. We use 32 dimensional word embeddings, sin-
gle layer LSTMs with 256 dimensions, and a 128
dimensional hidden layer in the feed-forward unit.
We stopped training after 120, 000 steps, where
each step corresponds to processing one training
batch, and evaluated on the dev corpus (15, 084
sentences) after every checkpoint (= 2, 000 steps).
Figure 3 shows the how the various evaluation
metrics evolve as training progresses. Section 8
contains the details of these metrics are evaluated.
We picked the checkpoint with the best ‘Slot F1‘
score.

8 Evaluation

An annotated document consists of a number of
connected frames as well as phrases (token spans)
that evoked these frames. We evaluated annotation
quality by comparing the generated frames with
the gold standard frame annotations from the eval-
uation corpus.

Two documents are matched by constructing a

Type set
Entity types
Top-level non-entity types
Fine-grained measure types

PropBank SRL types

Details
/saft/{person, location, organization, art, consumer good, event, other}
/s/{thing, date, price, measure, time, number}
/s/measure/{area, data, duration, energy, frequency, fuel, length, mass,
power, speed, temperate, voltage, volume}
5426 types, e.g. /pb/write-01, /pb/tune-02

Table 1: Frame types used in the experiments.

Action Type
SHIFT
STOP
EVOKE
CONNECT
ASSIGN
Total

# Unique Args Raw Count
2,206,274
1
111,006
1
1,080,365
5,532
635,734
1,421
5,430
13
4,038,809
6,968

Table 2: Action statistics for the transitions that
generated the gold frames for the OntoNotes train-
ing corpus.

virtual graph where the document is the start node.
The document node is then connected to the spans
and the spans are connected to the frames that
the spans evoke. This graph is then extended by
following the frame-to-frame links via the roles.
Quality is computed by aligning the golden and
predicted graphs and computing precision, recall,
and F1. Those scores are separately computed for
spans, frames, frame types, roles that link to other
frames (referred to as ’roles’), and roles that link
to global constants (referred to as ’labels’).

We also report two aggregate quality scores: (a)
Slot, which is an aggregate of Type, Role, and La-
bel, and (b) Combined, which is an aggregate of
Span, Frame, Type, Role, and Label.

We rated the checkpoints using the Slot-F1 met-
ric and selected the checkpoint with the best Slot-
F1. Intuitively, a high Slot score reﬂects that the
right type of frames are being evoked, along with
the right set of slots and links to other frames.

Figure 3 shows that as training progresses,
the model learns to output the spans and frames
evoked from those spans with fairly good qual-
ity (SPAN F1 ≈ FRAME F1 ≈ 93.81%). It also
gets the type of those frames right with a TYPE
F1 of = 85.88%. ROLE F1 though is lower at
just 69.65%. ROLE F1 measures the accuracy of
correctly getting the frame-frame link, including
the label of the link. Further error analysis will be

required to understand how frame-frame links are
missed by the model. Also note that currently the
roles feature is the only one that captures inter-
frame link information. Augmenting this with
more features should help improve ROLE quality,
as we will investigate in future work.

Finally, we took the best checkpoint, with
SLOT F1 = 79.95% at 118, 000 steps, and eval-
uated it on the test corpus. Table 3 lists the quality
of this model on the test and dev corpora. With
the exception of LABEL accuracies, all the other
metrics exhibit less than half a percent difference
between the test and dev corpora. This illustrates
that despite the lack of dropout, the model gener-
alizes well to unseen text. As for the disparity on
LABEL F1 (95.73 on dev against 92.81 on test),
we observe from Figure 3 that the LABEL accu-
racies follow a different improvement pattern dur-
ing training. On the dev set, LABEL F1 peaked
at 96.18 at 100, 000 steps, and started degrading
slightly from there on to 95.73 at 118, 000 steps,
possibly showing signs of overﬁtting which are ab-
sent in the other metrics.

We have tried increasing the sizes of the LSTM
dimensions, hidden layers, and embeddings, but
this did not improve the results signiﬁcantly.

9 Parser runtime

The SLING parser uses TensorFlow (Abadi et al.,
2016) for training but it also supports annotating
text with frame annotations at runtime.
It can
take advantage of batching and multi-threading to
speed up parsing. However, in practical applica-
tions of the parser, it may not be convenient to
batch documents for processing, so to have a re-
alistic benchmark, we set the batch size to one at
runtime.
In this conﬁguration, the TensorFlow-
based SLING parser runs at 200 tokens per CPU
second.

To speed up parsing, we have created Myelin,
a just-in-time compiler for neural networks that
compiles network cells into x64 machine code at

Metric
Tokens
Sentences
Span

Frame

Type

Role

Label

Slot

Dev
291,746
15,084
93.42
94.21
93.81
93.47
94.16
93.81
85.56
86.20
85.88
70.21
69.11
69.65
96.51
94.97
95.73
80.00
79.90
79.95
87.46
87.79
87.63

Test
216,473
11,623
93.04
94.34
93.69
93.20
94.08
93.64
85.67
86.49
86.08
69.59
69.20
69.39
95.02
90.70
92.81
79.81
80.10
79.96
87.20
87.91
87.55

Precision
Recall
F1
Precision
Recall
F1
Precision
Recall
F1
Precision
Recall
F1
Precision
Recall
F1
Precision
Recall
F1

Recall
F1

Combined Precision

Table 3: Evaluation on dev and test corpora, model
chosen on the Slot-F1 metric on dev corpus.

Runtime

TF
Myelin

Speed

Runtime
size
200 TPS 37.000 KB
2500 TPS

Load
time
10 secs
500 KB 0.5 secs

Table 4: Comparison between TensorFlow-based
SLING parser runtime and Myelin-based parser
runtime using JIT compilation. Speed is measured
as tokens parsed per CPU second, i.e. user+sys in
time(1).

runtime. The generated code exploits such spe-
cialized CPU features as SSE, AVX, and FMA3,
if available. Tensor shapes and model parameters
are ﬁxed at runtime. This allows us to optimize the
network by folding constants, unrolling loops, and
pre-computing embeddings, among other transfor-
mations. The JIT compiler can also ﬁx the data in-
stance layout at compile-time to speed up runtime
data access.

The Myelin-based SLING parser runs at 2500
tokens per CPU second, more than ten times faster
than the TensorFlow-based version (Table 4).

Figure 4: Runtime proﬁle for running the Myelin-
based SLING parser with the left-to-right LSTM
(LR LSTM), right-to-left LSTM (RL LSTM),
Feed-forward excluding logits (FF), Logits for
output actions (LOGITS), and transition system
and feature extraction (TS).

The Myelin-based SLING parser is indepen-
dent of TensorFlow so it only needs to link with
the Myelin runtime (less than 500 KB) instead of
the TensorFlow runtime library (37 MB), and it is
also much faster to initialize (0.5 seconds includ-
ing compilation time) than the TensorFlow-based
parser (10 seconds). Figure 4 shows a breakdown
of the CPU time for the Myelin-based parser run-
time.

Half the time is spent computing the logits for
the output actions. This is expensive because the
OntoNotes-based corpus has 6968 actions, where
the vast majority of the actions are of a form
like EVOKE(/pb/hit-01, 1), one for each Prop-
Bank roleset predicate in the training data. Ta-
ble 2 shows that only about 26% of all the ac-
tions are EVOKE actions. The output layer of
the FF unit could be turned into a cascaded classi-
ﬁer, where if the ﬁrst classiﬁer predicts a generic
EVOKE(/pb/predicate, 1) action, it would use a
secondary classiﬁer to predict the predicate type.
This could almost double the speed of the parser.

10 Conclusion

We have described SLING, a framework for pars-
ing natural language into semantic frames. Our
experiments show that it is feasible to build a se-
mantic parser that outputs frame graphs directly
without any intervening symbolic representation,
only using the tokens as inputs. We illustrated this
on the joint task of predicting entity mentions, en-
tity types, measures, and semantic role labeling.
While the LSTMs and TBRUs are expensive to
compute, we can achieve acceptable parsing speed

using the Myelin JIT compiler. We hope to make
use of SLING in the future for further exploration
into semantic parsing.

Srinivas Narayanan. 1999a. Moving right along: A
computational model of metaphoric reasoning about
events. Proceedings of the National Conference on
Artiﬁcial Intelligence pages 121–128.

Srinivas Narayanan. 1999b. Reasoning about actions
In Proceedings of the
in narrative understanding.
International Joint Conference on Artiﬁcial Intelli-
gence. Morgan Kaufmann, volume 99, pages 350–
357.

Matthew J. Nelson, , et al. 2017. Neurophysiolog-
ical dynamics of phrase-structure building during
sentence processing. Proceedings of the National
Academy of Sciences page 201701590.

Joakim Nivre. 2006.

Inductive dependency parsing,

volume 34. Springer.

Martha Palmer, Daniel Gildea, and Paul Kingsbury.
2005. The proposition bank: An annotated corpus of
semantic roles. Computational linguistics 31(1):71–
106.

Sameer S. Pradhan and Nianwen Xue. 2009.
In HLT-NAACL

Ontonotes: The 90% solution.
(Tutorial Abstracts). pages 11–12.

Kristina Nikolova Toutanova and Christopher D. Man-
ning. 2005. Effective statistical models for syntactic
and semantic disambiguation. Stanford University.

Acknowledgements

We would like to thank Google for supporting us
in this project and allowing us to make SLING
available to the public community. We would
also like to thank the Tensorﬂow and DRAGNN
teams for making their systems publicly available.
Without it, we could not have made SLING open
source.

References

Mart´ın Abadi et al. 2016.

scale machine
distributed systems.
http://arxiv.org/abs/1603.04467.

learning

Tensorﬂow: Large-
heterogeneous
on
CoRR abs/1603.04467.

Keith Alan. 2001.

Natural Language Semantics,

Blackwell Publishers Ltd, Oxford, page 251.

Bob Carpenter. 2005.

The logic of typed feature
structures: with applications to uniﬁcation gram-
mars, logic programs and constraint resolution, vol-
ume 32. Cambridge University Press.

Nancy Chang, Srini Narayanan, and Miriam R. L.
Petruck. 2002. Putting frames in perspective.
In
Proceedings of the 19th international conference on
Computational linguistics-Volume 1. Association for
Computational Linguistics, pages 1–7.

Charles J. Fillmore. 1982. Frame semantics. Linguis-

tics in the Morning Calm pages 111–138.

Jenny Rose Finkel, Christopher D. Manning, and An-
drew Y. Ng. 2006. Solving the problem of cascad-
ing errors: Approximate bayesian inference for lin-
guistic annotation pipelines. In Proceedings of the
2006 Conference on Empirical Methods in Natu-
ral Language Processing. Association for Compu-
tational Linguistics, pages 618–626.

Michael S.A. Graziano. 2013. Consciousness and the

Social Brain. Oxford University Press.

D. P. Kingma and J. Ba. 2014.

Adam: A
Method for Stochastic Optimization. ArXiv e-prints
arXiV:1402.6980 .

Lingpeng Kong, Chris Alberti, Daniel Andor, Ivan
Bogatyy, and David Weiss. 2017. DRAGNN: A
transition-based framework for dynamically con-
nected neural networks. CoRR abs/1703.04474.
http://arxiv.org/abs/1703.04474.

Tomas Mikolov, Kai Chen, Greg Corrado, and Jef-
Efﬁcient estimation of word
arXiv preprint

frey Dean. 2013.
representations in vector space.
arXiv:1301.3781 .

SLING: A framework for frame semantic parsing

Michael Ringgaard
Google Inc.
ringgaard@google.com

Rahul Gupta
Google Inc.
grahul@google.com

Fernando C. N. Pereira
Google Inc.
pereira@google.com

7
1
0
2
 
t
c
O
 
9
1
 
 
]
L
C
.
s
c
[
 
 
1
v
2
3
0
7
0
.
0
1
7
1
:
v
i
X
r
a

Abstract

We describe SLING, a framework for
parsing natural
language into seman-
SLING supports general
tic frames.
transition-based, neural-network parsing
with bidirectional LSTM input encoding
and a Transition Based Recurrent Unit
(TBRU) for output decoding. The parsing
model is trained end-to-end using only the
text tokens as input. The transition system
has been designed to output frame graphs
directly without any intervening symbolic
representation. The SLING framework in-
cludes an efﬁcient and scalable frame store
implementation as well as a neural net-
work JIT compiler for fast inference dur-
ing parsing. SLING is implemented in
C++ and it is available for download on
GitHub.

1

Introduction

Recent advances in machine learning make it prac-
tical to train recurrent multi-level neural network
classiﬁers, allowing us to rethink the design and
implementation of natural language understanding
(NLU) systems.

Earlier machine-learned NLU systems were
commonly organized as pipelines of separately
trained stages for syntactic and semantic annota-
tion of text. A typical pipeline would start with
part-of-speech (POS) tagging, followed by con-
stituency or dependency parsing for syntactic anal-
ysis. Using the POS tags and parse trees as feature
inputs, later stages in the pipeline could then de-
rive semantically relevant annotations such as en-
tity and concept mentions, entity types, corefer-
ence relationships, and semantic roles (SRL).

For simplicity and efﬁciency, each stage in a
practical NLU pipeline would just output its best

hypothesis and pass it on to the next stage (Finkel
Obviously, errors could then
et al., 2006).
accumulate throughout
the pipeline making it
much harder for the system to perform accu-
rately. For instance, F1 on SRL drops by more
than 10% when going from gold to system parse
trees (Toutanova and Manning, 2005).

However, applications may not need the inter-
mediate annotations produced by the earlier stages
of a NLU pipeline, so it would be preferable if all
stages could be trained together to optimize an ob-
jective based on the output annotations needed for
a particular application.

Earlier NLU pipelines often used linear clas-
siﬁers for each stage. Linear classiﬁers achieve
simplicity and training efﬁciency at the expense
of feature complexity, requiring elaborate feature
extraction, many different feature types, and fea-
ture combinations to achieve reasonable accuracy.
With deep learning, we can use embeddings, mul-
tiple layers, and recurrent network connections to
reduce the need for complex feature design. The
internal learned representations in model hidden
layers replace the hand-crafted feature combina-
tions and intermediate representations in pipelined
systems.

The SLING parser exploits deep learning to by-
pass those limitations of classic pipelined systems.
It is a transition-based parser that outputs frame
graphs directly without any intervening symbolic
representation (see Section 5). Transition-based
parsing is often associated with dependency pars-
ing, but we have designed a specialized transition
system that outputs frame graphs instead of depen-
dency trees.

We use a recurrent feed-forward unit for pre-
dicting the actions in the transition sequence,
where the hidden activations from predicting each
transition step are fed back into subsequent steps.
A bidirectional LSTM (biLSTM) encodes the in-

put into a sequence of vectors(Figure 1). This
neural network architecture has been implemented
using DRAGNN (Kong et al., 2017) and Tensor-
Flow (Abadi et al., 2016).

The SLING framework and a semantic parser
built in it are now available as open-source code
on GitHub.1

In Section 2 we introduce frame semantics, the
linguistic theory that inspired SLING, as well as
the SLING frame store, a C++ framework for
representing and storing semantic frames com-
pactly and efﬁciently. Section 4 introduces the
parser’s frame-semantics-oriented attention mech-
anism, and Section 5 describes the transition sys-
tem used for producing frame graphs. Section 6
describes the features used by the parser. In sec-
tions 7 and 8 we describe our experiments on
OntoNotes, and section 9 describes the fast parser
runtime.

2 Frame semantics

While frames in SLING are not tied to any partic-
ular linguistic theory or knowledge ontology, they
are inspired by frame semantics, the theory of lin-
guistic meaning originally developed by Charles
Fillmore (Fillmore, 1982). Frame semantics con-
nects linguistic semantics to encyclopedic knowl-
edge, with the central idea that understanding the
meaning of a word requires access to all the essen-
tial knowledge that relates to that word. A word
evokes a frame representing the speciﬁc concept it
refers to.

A semantic frame is a set of statements that
give ”characteristic features, attributes, and func-
tions of a denotatum, and its characteristic inter-
actions with things necessarily or typically asso-
ciated with it.” (Alan, 2001). A semantic frame
can also be viewed as a coherent group of concepts
such that complete knowledge of one of them re-
quires knowledge of all of them.

Frame semantics is not just for individual con-
cepts, but can be generalized to phrases, enti-
ties, constructions, and other larger and more
complex linguistic and ontological units.
Se-
mantic frames can also model world knowledge
and inferential relationships in common sense,
metaphor (Narayanan, 1999a), metonymy, ac-
tion (Narayanan, 1999b), and perspective (Chang
et al., 2002).

3 Frames in SLING

SLING represents frames with data structures con-
sisting of a list of slots, where each slot has a
name (role) and a value. The slot values can be
literals like numbers and strings, or links to other
frames. A collection of interlinked frames can thus
be seen as a directed graph where the frames are
the (typed) nodes and the slots are the (labeled)
edges. A frame graph can also be viewed as a
feature structure (Carpenter, 2005) and uniﬁcation
can be used for induction of new frames from ex-
isting frames. Frames can also be used to represent
more basic data structures such as a C struct with
ﬁelds, a JSON object, or a record in a database.

SLING frames live inside a frame store. A
store is a container that tracks all the frames that
have been allocated in the store, and serves as a
memory allocation arena for them. When mak-
ing a new frame, one speciﬁes the store where the
frame should be allocated. The frame will live in
this store until the store is deleted or the frame is
garbage collected because there no remaining live
references to it.2

SLING frames are externally represented in
a superset of JSON that allows references be-
tween frames (JSON objects) with the #n syn-
tax. Frames can be assigned identiﬁers (ids) us-
ing the =#n syntax. SLING frames can have both
numeric and named ids and both slot names and
values can be frame references. Where JSON ob-
jects can only represent trees, SLING frames can
be used for representing arbitrary graphs. SLING
has special syntax for built-in slot names:

Syntax Symbol
id:name
=name
isa:name
:name
is:name
+name

RDF
rdf:ID
rdf:InstanceOf
rdfs:subClassOf

Documents are also represented using frames,
where the document frame has slots for the docu-
ment text, the tokens, and the mention phrases and
the frames they evoke. See Figure 2 for an exam-
ple.

4 Attention

The SLING parser is a kind of sequence-to-
sequence model that ﬁrst encodes the input text to-
ken sequence with a bidirectional LSTM encoder

2See the SLING Guide for a detailed description of the

1https://github.com/google/sling

SLING frame store implementation.

Figure 1: Neural network architecture of the SLING parser. The input is encoded by a bi-directional
LSTM and fed into a recurrent feed-forward (FF) unit that proposes transition system actions. The
hidden layer activations and the transition system state are combined to create the input feature vector
for the next step. The FF unit is run repeatedly until the transition system has reached a ﬁnal state.

and then runs the transition system on that encod-
ing to produce a sequence of transitions, where
each transition updates the system state that com-
bined with the input encoding form the input for
the transition feed-forward cell that predicts the
next transition (Figure 1).

Sequence-to-sequence models often rely on an
“attention” mechanism to focus the decoder on the
parts of the input most relevant for producing the
next output symbol.
In this work, however, we
use a somewhat difference attention mechanism,
loosely inspired on neuroscience models of atten-
tion and awareness (Nelson et al., 2017; Graziano,
2013). In our model, attention focuses on parts of
the frame representation that the parser has cre-
ated so far, rather than focusing on (encodings of)
input tokens as is common for other sequence-to-
sequence attention mechanisms.

We maintain an attention buffer as part of the
transition system state. This an ordered list of
frames, where the order represents closeness to
the center of attention. Transition system actions

maintain the attention buffer, bringing a frame to
the front when the frame is evoked or re-evoked
by the input text. When a new frame is evoked,
it will merge the concept and its roles into a new
coherent chunk of meaning, which is represented
by the new frame and its relations to other frames,
and this will become the new center of attention.
Our hypothesis is that by maintaining this atten-
tion mechanism, we only need to look at a few
recent frames brought into attention to build the
desired frame graph.

5 Transition system

Transition systems are widely used in parsing to
build dependency parse trees as a side effect of
performing a sequence state transitions (si, ai)
where si is a state and ai is an action. Ac-
tion ai computes the new state si+1 from state
si. For example, the arc-standard transition sys-
tem (Nivre, 2006) uses a sequence of SHIFT,
LEFT-ARC(label), and RIGHT-ARC(label) ac-
tions, operating on a state whose main component

{

:/s/document
/s/document/text: "John hit the ball"
/s/document/tokens: [

{/s/token/text: "John" /s/token/start: 0
/s/token/start: 5
{/s/token/text: "hit"
{/s/token/text: "the"
/s/token/start: 9
{/s/token/text: "ball" /s/token/start: 13 /s/token/length: 4}

/s/token/length: 4},
/s/token/length: 3},
/s/token/length: 3},

]
/s/document/mention: {

:/s/phrase /s/phrase/begin: 0
/s/phrase/evokes: {=#1 :/saft/person }

}
/s/document/mention: {

:/s/phrase /s/phrase/begin: 1
/s/phrase/evokes: {

:/pb/hit-01
/pb/arg0: #1
/pb/arg1: #2

}

}
/s/document/mention: {

:/s/phrase /s/phrase/begin: 3
/s/phrase/evokes: {=#2 :/saft/consumer_good }

}

}

Figure 2: The text “John hit the ball” in SLING frame notation. The document itself is represented by a
frame that has the text, an array of tokens and the mentions that evoke frames. There are three frames:
a person frame (John), a consumer good frame (bat) and a hit-01 frame. The hit frame has the person
frame as the agent (arg0) and the ball frame as the object (arg1).

is a stack, to build a dependency parse tree.

actions:

We use the same idea to construct a frame graph
where frames can be evoked by phrases in the in-
put. But instead of using a stack in the state, we
use the attention buffer introduced in the previous
section that keeps track of the most salient frames
in the discourse.

The attention buffer is a priority list of all the
frames evoked so far. The front of the buffer serves
as the working memory for the parser. Actions op-
erate on the front of the buffer and in some cases
other frames in the buffer. The transition system
simultaneously builds the frame graph and main-
tains the attention buffer by moving the frame in-
volved involved in an action to the front of the at-
tention buffer. At any time, each evoked frame has
a unique position in the attention buffer.

The transition system consists of the following

• SHIFT – Moves to next input token. Only
valid when not at the end of the input buffer.

• STOP – Signals that we have reach the end
of the parse. This is only valid when at the
end of the input buffer. Multiple STOP ac-
tions can be added to the transition sequence,
e.g. to make all sequences in a beam have the
same length. After a STOP is issued, no other
actions are permitted except more STOP ac-
tions.

• EVOKE(type, n) – Evokes a frame of type
type from the next n tokens in the input. The
evoked frame is inserted at the front of the
attention buffer, becoming the new center of
attention.

• REFER(frame, n) – Makes a new mention
from the next n tokens in the input evoking
an existing frame in the attention buffer. This
frame is moved to the front of the attention
buffer and will become the new center of at-
tention.

an oracle sequence generator that takes a doc-
ument and converts it to a canonical transition
sequence in a way similar to how this is done
for transition-based dependency parsing (Nivre,
2006). For example, the sentence “John hit the
ball” generates the following transition sequence:

• CONNECT(source, role, target) – Adds
slot to source frame in the attention buffer
with name role and value target where tar-
get is an existing frame in the attention buffer.
The source frame become the new center of
attention.

• ASSIGN(source, role, value) – Adds slot
to source frame in the attention buffer with
name role and constant value value and
moves the frame to the front of the buffer.
This action is only used for assigning a con-
stant value to a slot, in contrast to CON-
NECT where the value is another frame in
the attention buffer.

• EMBED(target, role, type) – Creates a new
frame with type type and adds a slot to it with
name role and value target where target is
an existing frame in the attention buffer. The
new frame becomes the center of attention.

• ELABORATE(source, role, type) – Creates
a new frame with type type and adds a slot
to an existing frame source in the attention
buffer with role set to the new frame. The
new frame becomes the center of attention.

In summary, EVOKE and REFER are used to
evoke frames from text mentions, while ELABO-
RATE and EMBED are used to create frames not
directly evoked by text.

This transition system can generate any con-
nected frame graph where the frames are either di-
rectly on indirectly evoked by phrases in the text.
A frame can be evoked by multiple mentions and
the graph can have cycles.

The transition system can potentially have an
unbounded number of actions since it is parame-
terized by phrase length and attention buffer in-
dices which can be arbitrarily large. In the current
implementation, we only consider the top k frames
in the attention buffer (k = 5) and we do not con-
sider any phrases longer than those in the training
corpus.

Multiple transition sequences can generate the
same frame annotations, but we have implemented

EVOKE(/saft/person, 1)
SHIFT
EVOKE(/pb/hit-01, 1)
CONNECT(0, /pb/arg0, 1)
SHIFT
SHIFT
EVOKE(/saft/consumer_good, 1)
CONNECT(1, /pb/arg1, 0)
SHIFT
STOP

6 Features

The biLSTM uses only lexical features based on
the current input word:

• The current word itself. During training we
initialize the embedding for this feature from
pre-trained word embeddings (Mikolov et al.,
2013) for all the words in the the training
data.

• The preﬁxes and sufﬁxes of the current input
word. We use only preﬁxes up to three char-
acters in our experiments.

• Word shape features based on the characters
in the current input word: hyphenation, cap-
italization, punctuation, quotes, and digits.
Each of these features has its own embedding
matrix.

The TBRU is a simple feed-forward unit with
a single hidden layer. It takes the hidden activa-
tions from the biLSTM as well as the activations
from the hidden layer from the previous steps as
raw input features, and maps them through em-
bedding matrices to get the input vector for the
hidden layer. More speciﬁcally, the inputs to the
TBRU are as follows:

• The left-to-right and right-to-left LSTMs
supply their activations for the current token
in the parser state.

• The attention feature looks at

the top-k
frames in the attention buffer and ﬁnds the
phrases in the text (if any) that evoked them.

The activations from the left-to-right and
right-to-left LSTMs for the last token of each
of those phrases are are included as TBRU
inputs, serving as continuous lexical repre-
sentations of the top-k frames in the attention
buffer.

• The hidden layer activations of the transition
steps which evoked or brought into focus the
top-k frames in the attention buffer are also
inputs to the TBRU, providing a continuous
representation for the semantic frame con-
texts that evoked those frames most recently.

• The history feature uses the hidden activa-
tions in the feed-forward unit from the pre-
vious k steps as feature inputs to the current
step.

• Embeddings of triples of the form (si, ri, ti),
0 < si, ti ≤ k encode the fact that the frame
at position si in the attention buffer has a role
ri with the frame at position ti in the atten-
tion buffer as its value. Back-off features are
added for the source roles (si, ri), target role
(ri, ti), and unlabeled roles (si, ti).

7 Experiments

We derived a corpus annotated with seman-
tic frames from the OntoNotes corpus (Pradhan
and Xue, 2009). We took the PropBank SRL
layer (Palmer et al., 2005) and converted the
predicate-argument structures into frame annota-
tions. We also annotated the corpus with entity
frames based on entity types from a state-of-the-
art entity tagger. We determined the head token of
each argument span and if this coincided with the
span of an existing frame, then we used it as the
evoking span for the argument frame, otherwise
we just used the head token as the evoking span of
the argument frame.

The various frame types mentioned above are
listed in Table 1. They include 7 conventional
entity types, 6 top-level non-entity types (e.g.
date), 13 measurement types, and more than 5400
PropBank frame types. All the frame roles are
collapsed onto /pb/arg0,
/pb/arg1, and so on.
Our training corpus size was 111, 006 sentences,
2, 206, 274 tokens.

Table 2 shows action statistics for the transi-
tion sequences that generate the gold frames in the
training corpus. As expected, there is one SHIFT

Figure 3: Frame graph quality metrics on dev set
as training progresses. Training was stopped at
120, 000 iterations since we saw very little im-
provement after that.

action per training token, and one STOP action per
training sentence. The EVOKE action occurred
with 5, 532 unique (length, type) arguments in the
corpus, for a raw count of roughly 1.08 million
action tokens. Overall our action space had 6968
action types, which is also the size of the softmax
layer of our TBRU decoder.
Hyperparameters: Our ﬁnal set of hyperpa-
rameters after grid search with a dev corpus
learning rate = 0.0005, optimizer =
was:
Adam (Kingma and Ba, 2014) with β1 = 0.01,
β2 = 0.999, (cid:15) = 1e − 5, no dropout, gradient
clipping at 1.0, exponential moving average, no
layer normalization, and a training batch size of
8. We use 32 dimensional word embeddings, sin-
gle layer LSTMs with 256 dimensions, and a 128
dimensional hidden layer in the feed-forward unit.
We stopped training after 120, 000 steps, where
each step corresponds to processing one training
batch, and evaluated on the dev corpus (15, 084
sentences) after every checkpoint (= 2, 000 steps).
Figure 3 shows the how the various evaluation
metrics evolve as training progresses. Section 8
contains the details of these metrics are evaluated.
We picked the checkpoint with the best ‘Slot F1‘
score.

8 Evaluation

An annotated document consists of a number of
connected frames as well as phrases (token spans)
that evoked these frames. We evaluated annotation
quality by comparing the generated frames with
the gold standard frame annotations from the eval-
uation corpus.

Two documents are matched by constructing a

Type set
Entity types
Top-level non-entity types
Fine-grained measure types

PropBank SRL types

Details
/saft/{person, location, organization, art, consumer good, event, other}
/s/{thing, date, price, measure, time, number}
/s/measure/{area, data, duration, energy, frequency, fuel, length, mass,
power, speed, temperate, voltage, volume}
5426 types, e.g. /pb/write-01, /pb/tune-02

Table 1: Frame types used in the experiments.

Action Type
SHIFT
STOP
EVOKE
CONNECT
ASSIGN
Total

# Unique Args Raw Count
2,206,274
1
111,006
1
1,080,365
5,532
635,734
1,421
5,430
13
4,038,809
6,968

Table 2: Action statistics for the transitions that
generated the gold frames for the OntoNotes train-
ing corpus.

virtual graph where the document is the start node.
The document node is then connected to the spans
and the spans are connected to the frames that
the spans evoke. This graph is then extended by
following the frame-to-frame links via the roles.
Quality is computed by aligning the golden and
predicted graphs and computing precision, recall,
and F1. Those scores are separately computed for
spans, frames, frame types, roles that link to other
frames (referred to as ’roles’), and roles that link
to global constants (referred to as ’labels’).

We also report two aggregate quality scores: (a)
Slot, which is an aggregate of Type, Role, and La-
bel, and (b) Combined, which is an aggregate of
Span, Frame, Type, Role, and Label.

We rated the checkpoints using the Slot-F1 met-
ric and selected the checkpoint with the best Slot-
F1. Intuitively, a high Slot score reﬂects that the
right type of frames are being evoked, along with
the right set of slots and links to other frames.

Figure 3 shows that as training progresses,
the model learns to output the spans and frames
evoked from those spans with fairly good qual-
ity (SPAN F1 ≈ FRAME F1 ≈ 93.81%). It also
gets the type of those frames right with a TYPE
F1 of = 85.88%. ROLE F1 though is lower at
just 69.65%. ROLE F1 measures the accuracy of
correctly getting the frame-frame link, including
the label of the link. Further error analysis will be

required to understand how frame-frame links are
missed by the model. Also note that currently the
roles feature is the only one that captures inter-
frame link information. Augmenting this with
more features should help improve ROLE quality,
as we will investigate in future work.

Finally, we took the best checkpoint, with
SLOT F1 = 79.95% at 118, 000 steps, and eval-
uated it on the test corpus. Table 3 lists the quality
of this model on the test and dev corpora. With
the exception of LABEL accuracies, all the other
metrics exhibit less than half a percent difference
between the test and dev corpora. This illustrates
that despite the lack of dropout, the model gener-
alizes well to unseen text. As for the disparity on
LABEL F1 (95.73 on dev against 92.81 on test),
we observe from Figure 3 that the LABEL accu-
racies follow a different improvement pattern dur-
ing training. On the dev set, LABEL F1 peaked
at 96.18 at 100, 000 steps, and started degrading
slightly from there on to 95.73 at 118, 000 steps,
possibly showing signs of overﬁtting which are ab-
sent in the other metrics.

We have tried increasing the sizes of the LSTM
dimensions, hidden layers, and embeddings, but
this did not improve the results signiﬁcantly.

9 Parser runtime

The SLING parser uses TensorFlow (Abadi et al.,
2016) for training but it also supports annotating
text with frame annotations at runtime.
It can
take advantage of batching and multi-threading to
speed up parsing. However, in practical applica-
tions of the parser, it may not be convenient to
batch documents for processing, so to have a re-
alistic benchmark, we set the batch size to one at
runtime.
In this conﬁguration, the TensorFlow-
based SLING parser runs at 200 tokens per CPU
second.

To speed up parsing, we have created Myelin,
a just-in-time compiler for neural networks that
compiles network cells into x64 machine code at

Metric
Tokens
Sentences
Span

Frame

Type

Role

Label

Slot

Dev
291,746
15,084
93.42
94.21
93.81
93.47
94.16
93.81
85.56
86.20
85.88
70.21
69.11
69.65
96.51
94.97
95.73
80.00
79.90
79.95
87.46
87.79
87.63

Test
216,473
11,623
93.04
94.34
93.69
93.20
94.08
93.64
85.67
86.49
86.08
69.59
69.20
69.39
95.02
90.70
92.81
79.81
80.10
79.96
87.20
87.91
87.55

Precision
Recall
F1
Precision
Recall
F1
Precision
Recall
F1
Precision
Recall
F1
Precision
Recall
F1
Precision
Recall
F1

Recall
F1

Combined Precision

Table 3: Evaluation on dev and test corpora, model
chosen on the Slot-F1 metric on dev corpus.

Runtime

TF
Myelin

Speed

Runtime
size
200 TPS 37.000 KB
2500 TPS

Load
time
10 secs
500 KB 0.5 secs

Table 4: Comparison between TensorFlow-based
SLING parser runtime and Myelin-based parser
runtime using JIT compilation. Speed is measured
as tokens parsed per CPU second, i.e. user+sys in
time(1).

runtime. The generated code exploits such spe-
cialized CPU features as SSE, AVX, and FMA3,
if available. Tensor shapes and model parameters
are ﬁxed at runtime. This allows us to optimize the
network by folding constants, unrolling loops, and
pre-computing embeddings, among other transfor-
mations. The JIT compiler can also ﬁx the data in-
stance layout at compile-time to speed up runtime
data access.

The Myelin-based SLING parser runs at 2500
tokens per CPU second, more than ten times faster
than the TensorFlow-based version (Table 4).

Figure 4: Runtime proﬁle for running the Myelin-
based SLING parser with the left-to-right LSTM
(LR LSTM), right-to-left LSTM (RL LSTM),
Feed-forward excluding logits (FF), Logits for
output actions (LOGITS), and transition system
and feature extraction (TS).

The Myelin-based SLING parser is indepen-
dent of TensorFlow so it only needs to link with
the Myelin runtime (less than 500 KB) instead of
the TensorFlow runtime library (37 MB), and it is
also much faster to initialize (0.5 seconds includ-
ing compilation time) than the TensorFlow-based
parser (10 seconds). Figure 4 shows a breakdown
of the CPU time for the Myelin-based parser run-
time.

Half the time is spent computing the logits for
the output actions. This is expensive because the
OntoNotes-based corpus has 6968 actions, where
the vast majority of the actions are of a form
like EVOKE(/pb/hit-01, 1), one for each Prop-
Bank roleset predicate in the training data. Ta-
ble 2 shows that only about 26% of all the ac-
tions are EVOKE actions. The output layer of
the FF unit could be turned into a cascaded classi-
ﬁer, where if the ﬁrst classiﬁer predicts a generic
EVOKE(/pb/predicate, 1) action, it would use a
secondary classiﬁer to predict the predicate type.
This could almost double the speed of the parser.

10 Conclusion

We have described SLING, a framework for pars-
ing natural language into semantic frames. Our
experiments show that it is feasible to build a se-
mantic parser that outputs frame graphs directly
without any intervening symbolic representation,
only using the tokens as inputs. We illustrated this
on the joint task of predicting entity mentions, en-
tity types, measures, and semantic role labeling.
While the LSTMs and TBRUs are expensive to
compute, we can achieve acceptable parsing speed

using the Myelin JIT compiler. We hope to make
use of SLING in the future for further exploration
into semantic parsing.

Srinivas Narayanan. 1999a. Moving right along: A
computational model of metaphoric reasoning about
events. Proceedings of the National Conference on
Artiﬁcial Intelligence pages 121–128.

Srinivas Narayanan. 1999b. Reasoning about actions
In Proceedings of the
in narrative understanding.
International Joint Conference on Artiﬁcial Intelli-
gence. Morgan Kaufmann, volume 99, pages 350–
357.

Matthew J. Nelson, , et al. 2017. Neurophysiolog-
ical dynamics of phrase-structure building during
sentence processing. Proceedings of the National
Academy of Sciences page 201701590.

Joakim Nivre. 2006.

Inductive dependency parsing,

volume 34. Springer.

Martha Palmer, Daniel Gildea, and Paul Kingsbury.
2005. The proposition bank: An annotated corpus of
semantic roles. Computational linguistics 31(1):71–
106.

Sameer S. Pradhan and Nianwen Xue. 2009.
In HLT-NAACL

Ontonotes: The 90% solution.
(Tutorial Abstracts). pages 11–12.

Kristina Nikolova Toutanova and Christopher D. Man-
ning. 2005. Effective statistical models for syntactic
and semantic disambiguation. Stanford University.

Acknowledgements

We would like to thank Google for supporting us
in this project and allowing us to make SLING
available to the public community. We would
also like to thank the Tensorﬂow and DRAGNN
teams for making their systems publicly available.
Without it, we could not have made SLING open
source.

References

Mart´ın Abadi et al. 2016.

scale machine
distributed systems.
http://arxiv.org/abs/1603.04467.

learning

Tensorﬂow: Large-
heterogeneous
on
CoRR abs/1603.04467.

Keith Alan. 2001.

Natural Language Semantics,

Blackwell Publishers Ltd, Oxford, page 251.

Bob Carpenter. 2005.

The logic of typed feature
structures: with applications to uniﬁcation gram-
mars, logic programs and constraint resolution, vol-
ume 32. Cambridge University Press.

Nancy Chang, Srini Narayanan, and Miriam R. L.
Petruck. 2002. Putting frames in perspective.
In
Proceedings of the 19th international conference on
Computational linguistics-Volume 1. Association for
Computational Linguistics, pages 1–7.

Charles J. Fillmore. 1982. Frame semantics. Linguis-

tics in the Morning Calm pages 111–138.

Jenny Rose Finkel, Christopher D. Manning, and An-
drew Y. Ng. 2006. Solving the problem of cascad-
ing errors: Approximate bayesian inference for lin-
guistic annotation pipelines. In Proceedings of the
2006 Conference on Empirical Methods in Natu-
ral Language Processing. Association for Compu-
tational Linguistics, pages 618–626.

Michael S.A. Graziano. 2013. Consciousness and the

Social Brain. Oxford University Press.

D. P. Kingma and J. Ba. 2014.

Adam: A
Method for Stochastic Optimization. ArXiv e-prints
arXiV:1402.6980 .

Lingpeng Kong, Chris Alberti, Daniel Andor, Ivan
Bogatyy, and David Weiss. 2017. DRAGNN: A
transition-based framework for dynamically con-
nected neural networks. CoRR abs/1703.04474.
http://arxiv.org/abs/1703.04474.

Tomas Mikolov, Kai Chen, Greg Corrado, and Jef-
Efﬁcient estimation of word
arXiv preprint

frey Dean. 2013.
representations in vector space.
arXiv:1301.3781 .

