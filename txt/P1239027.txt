Deep Multitask Learning for Semantic Dependency Parsing

Hao Peng∗

Sam Thomson† Noah A. Smith∗

∗Paul G. Allen School of Computer Science & Engineering, University of Washington, Seattle, WA, USA
†School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA
@cs.washington.edu, sthomson@cs.cmu.edu
hapeng,nasmith
}

{

7
1
0
2
 
r
p
A
 
5
2
 
 
]
L
C
.
s
c
[
 
 
2
v
5
5
8
6
0
.
4
0
7
1
:
v
i
X
r
a

Abstract

We present a deep neural architecture that
parses sentences into three semantic de-
pendency graph formalisms. By using ef-
ﬁcient, nearly arc-factored inference and
a bidirectional-LSTM composed with a
multi-layer perceptron, our base system is
able to signiﬁcantly improve the state of
the art for semantic dependency parsing,
without using hand-engineered features or
syntax. We then explore two multitask
learning approaches—one that shares pa-
rameters across formalisms, and one that
uses higher-order structures to predict the
graphs jointly. We ﬁnd that both ap-
proaches improve performance across for-
malisms on average, achieving a new state
of the art. Our code is open-source and
available at https://github.com/
Noahs-ARK/NeurboParser.

1

Introduction

Labeled directed graphs are a natural and ﬂexi-
ble representation for semantics (Copestake et al.,
2005; Baker et al., 2007; Surdeanu et al., 2008;
Banarescu et al., 2013, inter alia). Their generality
over trees, for instance, allows them to represent
relational semantics while handling phenomena
like coreference and coordination. Even syntactic
formalisms are moving toward graphs (de Marn-
effe et al., 2014). However, full semantic graphs
can be expensive to annotate, and efforts are frag-
mented across competing semantic theories, lead-
ing to a limited number of annotations in any one
formalism. This makes learning to parse more dif-
ﬁcult, especially for powerful but data-hungry ma-
chine learning techniques like neural networks.

In this work, we hypothesize that the overlap
among theories and their corresponding represen-

(a) DM

(b) PAS

(c) PSD

Figure 1: An example sentence annotated with the
three semantic formalisms of the broad-coverage
semantic dependency parsing shared tasks.

tations can be exploited using multitask learn-
ing (Caruana, 1997), allowing us to learn from
more data. We use the 2015 SemEval shared task
on Broad-Coverage Semantic Dependency Pars-
ing (SDP; Oepen et al., 2015) as our testbed.
The shared task provides an English-language cor-
pus with parallel annotations for three semantic
graph representations, described in
2. Though
§
the shared task was designed in part to encourage
comparison between the formalisms, we are the
ﬁrst to treat SDP as a multitask learning problem.
As a strong baseline, we introduce a new sys-
3).
tem that parses each formalism separately (
It uses a bidirectional-LSTM composed with a
multi-layer perceptron to score arcs and predi-
cates, and has efﬁcient, nearly arc-factored infer-
ence. Experiments show it signiﬁcantly improves
on state-of-the-art methods (
§

We then present two multitask extensions (

3.4).

§

4.2
§

DM

PAS

PSD

id

ood

id

ood

id

ood

# labels
% trees
% projective

59
2.3
2.9

47
9.7
8.8

42
1.2
1.6

41
2.4
3.5

74
91
42.2 51.4
41.9 54.4

Table 1: Graph statistics for in-domain (WSJ,
“id”) and out-of-domain (Brown corpus, “ood”)
data. Numbers taken from Oepen et al. (2015).

and
4.3), with a parameterization and factoriza-
§
tion that implicitly models the relationship be-
tween multiple formalisms. Experiments show
that both techniques improve over our basic
model, with an additional (but smaller) improve-
ment when they are combined (
4.5). Our analy-
§
sis shows that the improvement in unlabeled F1 is
greater for the two formalisms that are more struc-
turally similar, and suggests directions for future
work. Finally, we survey related work (
5), and
§
6).
summarize our contributions and ﬁndings (
§

2 Broad-Coverage Semantic Dependency

Parsing (SDP)

First deﬁned in a SemEval 2014 shared task
(Oepen et al., 2014), and then extended by Oepen
et al. (2015),
the broad-coverage semantic de-
pency parsing (SDP) task is centered around three
semantic formalisms whose annotations have been
converted into bilexical dependencies. See Fig-
ure 1 for an example. The formalisms come
from varied linguistic traditions, but all three aim
to capture predicate-argument relations between
content-bearing words in a sentence.

While at ﬁrst glance similar to syntactic de-
pendencies, semantic dependencies have distinct
goals and characteristics, more akin to semantic
role labeling (SRL; Gildea and Jurafsky, 2002) or
the abstract meaning representation (AMR; Ba-
narescu et al., 2013). They abstract over different
syntactic realizations of the same or similar mean-
ing (e.g., “She gave me the ball.” vs. “She gave
the ball to me.”). Conversely, they attempt to dis-
tinguish between different senses even when real-
ized in similar syntactic forms (e.g., “I baked in
the kitchen.” vs. “I baked in the sun.”).

Structurally, they are labeled directed graphs
whose vertices are tokens in the sentence. This
is in contrast to AMR whose vertices are ab-
stract concepts, with no explicit alignment to to-
kens, which makes parsing more difﬁcult (Flani-
gan et al., 2014). Their arc labels encode broadly-

applicable semantic relations rather than being tai-
lored to any speciﬁc downstream application or
ontology.1 They are not necessarily trees, because
a token may be an argument of more than one
predicate (e.g., in “John wants to eat,” John is
both the wanter and the would-be eater). Their
analyses may optionally leave out non–content-
bearing tokens, such as punctuation or the in-
ﬁnitival “to,” or prepositions that simply mark
the type of relation holding between other words.
But when restricted to content-bearing tokens (in-
cluding adjectives, adverbs, etc.), the subgraph
In this sense, SDP provides a
is connected.
whole-sentence analysis. This is in contrast to
PropBank-style SRL, which gives an analysis of
only verbal and nominal predicates (Palmer et al.,
2005). Semantic dependency graphs also tend to
have higher levels of nonprojectivity than syntac-
tic trees (Oepen et al., 2014). Sentences with
graphs containing cycles have been removed from
the dataset by the organizers, so all remaining
graphs are directed acyclic graphs. Table 1 sum-
marizes some of the dataset’s high-level statistics.

three formalisms.

Formalisms. Following the SemEval shared
tasks, we consider
The
DM (DELPH-IN MRS)
representation comes
from DeepBank (Flickinger et al., 2012), which
are manually-corrected parses from the LinGO
English Resource Grammar
(Copestake and
Flickinger, 2000). LinGO is a head-driven phrase
structure grammar (HPSG; Pollard and Sag, 1994)
with minimal
recursion semantics (Copestake
et al., 2005). The PAS (Predicate-Argument Struc-
tures) representation is extracted from the Enju
Treebank, which consists of automatic parses from
the Enju HPSG parser (Miyao, 2006). PAS an-
notations are also available for the Penn Chinese
Treebank (Xue et al., 2005). The PSD (Prague Se-
mantic Dependencies) representation is extracted
from the tectogrammatical layer of the Prague
Czech-English Dependency Treebank (Hajiˇc et al.,
2012). PSD annotations are also available for a
Czech translation of the WSJ Corpus. In this work,
we train and evaluate only on English annotations.
Of the three, PAS follows syntax most closely,
and prior work has found it the easiest to pre-
dict. PSD has the largest set of labels, and parsers

1This may make another disambiguation step necessary
to use these representations in a downstream task, but there
is evidence that modeling semantic composition separately
from grounding in any ontology is an effective way to achieve
broad coverage (Kwiatkowski et al., 2013).

(a) First-order.

(b) Second-order.

(c) Third-order.

Figure 2: Examples of local structures. We refer
to the number of arcs that a structure contains as
its order.

have signiﬁcantly lower performance on it (Oepen
et al., 2015).

3 Single-Task SDP

Here we introduce our basic model, in which train-
ing and prediction for each formalism is kept com-
pletely separate. We also lay out basic notation,
which will be reused for our multitask extensions.

3.1 Problem Formulation

The output of semantic dependency parsing is a
labeled directed graph (see Figure 1). Each arc
, indicating the
has a label from a predeﬁned set
semantic relation of the child to the head. Given
input sentence x, let
(x) be the set of possible
semantic graphs over x. The graph we seek maxi-
mizes a score function S:

L

Y

ˆy = arg max

S(x, y),

(1)

y∈Y(x)

We decompose S into a sum of local scores s for
local structures (or “parts”) p in the graph:

S(x, y) =

s(p).

(2)

p∈y
(cid:88)

For notational simplicity, we omit the dependence
of s on x. See Figure 2a for examples of local
structures. s is a parameterized function, whose
parameters (denoted Θ and suppressed here for
clarity) will be learned from the training data
(
3.3). Since we search over every possible la-
§
beled graph (i.e., considering each labeled arc for
each pair of words), our approach can be consid-
ered a graph-based (or all-pairs) method. The
models presented in this work all share this com-
mon graph-based approach, differing only in the
set of structures they score and in the parameter-
ization of the scoring function s. This approach
also underlies state-of-the-art approaches to SDP
(Martins and Almeida, 2014).

3.2 Basic Model

Our basic model is inspired by recent successes in
neural arc-factored graph-based dependency pars-
ing (Kiperwasser and Goldberg, 2016; Dozat and
Manning, 2017; Kuncoro et al., 2016). It borrows
heavily from the neural arc-scoring architectures
in those works, but decodes with a different algo-
rithm under slightly different constraints.

3.2.1 Basic Structures

Our basic model factors over three types of struc-
tures (p in Equation 2):

;

•

•

•

j;

→

→·

predicate, indicating a predicate word, de-
noted i
unlabeled arc, representing the existence of
an arc from a predicate to an argument, de-
noted i
labeled arc, an arc labeled with a semantic
role, denoted i

j.
Here i and j are word indices in a given sen-
tence, and (cid:96) indicates the arc label. This list corre-
sponds to the most basic structures used by Mar-
tins and Almeida (2014). Selecting an output y
corresponds precisely to selecting which instanti-
ations of these structures are included.

(cid:96)
→

To ensure the internal consistency of predic-
tions, the following constraints are enforced dur-
ing decoding:

if and only if there exists at least one j

•

•

j;

→

i
→·
such that i
If i
→
(cid:96)
such that i
→
there must not exist any i

j, then there must be exactly one label (cid:96)
j, then
j. Conversely, if not i

→

(cid:96)
→

j;

We also enforce a determinism constraint (Flani-
gan et al., 2014): certain labels must not appear on
more than one arc emanating from the same token.
The set of deterministic labels is decided based on
their appearance in the training set. Notably, we do
not enforce that the predicted graph is connected
or spanning. If not for the predicate and determin-
ism constraints, our model would be arc-factored,
and decoding could be done for each i, j pair in-
dependently. Our structures do overlap though,
and we employ AD3 (Martins et al., 2011) to ﬁnd
the highest-scoring internally consistent semantic
graph. AD3 is an approximate discrete optimiza-
tion algorithm based on dual decomposition.
It
can be used to decode factor graphs over discrete
variables when scored structures overlap, as is the
case here.

3.2.2 Basic Scoring

Similarly to Kiperwasser and Goldberg (2016),
our model learns representations of tokens in a
sentence using a bi-directional LSTM (BiLSTM).
Each different type of structure (predicate, unla-
beled arc, labeled arc) then shares these same BiL-
STM representations, feeding them into a multi-
layer perceptron (MLP) which is speciﬁc to the
structure type. We present the architecture slightly
differently from prior work, to make the transition
to the multitask scenario (
4) smoother. In our pre-
§
sentation, we separate the model into a function
φ that represents the input (corresponding to the
BiLSTM and the initial layers of the MLPs), and a
function ψ that represents the output (correspond-
ing to the ﬁnal layers of the MLPs), with the scores
given by their inner product.2

Distributed input representations. Long short-
term memory networks (LSTMs) are a variant
of recurrent neural networks (RNNs) designed
to alleviate the vanishing gradient problem in
RNNs (Hochreiter and Schmidhuber, 1997). A
bi-directional LSTM (BiLSTM) runs over the se-
quence in both directions (Schuster and Paliwal,
1997; Graves, 2012).

Given an input sentence x and its corresponding
part-of-speech tag sequence, each token is mapped
to a concatenation of its word embedding vector
and POS tag vector. Two LSTMs are then run
in opposite directions over the input vector se-
quence, outputting the concatenation of the two
hidden vectors at each position i: hi =
−→h i; ←−h i
(we omit hi’s dependence on x and its own pa-
(cid:3)
rameters). hi can be thought of as an encoder that
contextualizes each token conditioning on all of
its context, without any Markov assumption. h’s
parameters are learned jointly with the rest of the
model (
3.3); we refer the readers to Cho (2015)
for technical details.

§

(cid:2)

The input representation φ of a predicate struc-

ture depends on the representation of one word:

Figure 3: Illustration of the architecture of the ba-
sic model. i and j denote the indices of tokens in
the given sentence. The ﬁgure depicts single-layer
BiLSTM and MLPs, while in practice we use two
layers for both.

For unlabeled arc and labeled arc structures, it de-
pends on both the head and the modiﬁer (but not
the label, which is captured in the distributed out-
put representation):

φ(i

j) = tanh

CUA

hi; hj

+ bUA

,

φ(i

j) = tanh

(cid:0)

CLA

(cid:2)
hi; hj

(cid:3)

+ bLA

(cid:1)
.

(3b)

(3c)

→
(cid:96)
→

(cid:2)

(cid:3)

(cid:1)

(cid:0)

Distributed output representations. NLP re-
searchers have found that embedding discrete out-
put labels into a low dimensional real space is
an effective way to capture commonalities among
them (Srikumar and Manning, 2014; Hermann
et al., 2014; FitzGerald et al., 2015, inter alia).
In neural language models (Bengio et al., 2003;
Mnih and Hinton, 2007, inter alia) the weights of
the output layer could also be regarded as an out-
put embedding.

We associate each ﬁrst-order structure p with a
d-dimensional real vector ψ(p) which does not de-
pend on particular words in p. Predicates and un-
labeled arcs are each mapped to a single vector:

and each label gets a vector:

ψ(i

ψ(i

→·

) = ψpred,
j) = ψUA,

→

(4a)

(4b)

ψ(i

j) = ψLA((cid:96)).

(4c)

(cid:96)
→

φ(i

) = tanh

Cpredhi + bpred

.

(3a)

→·

Scoring. Finally, we use an inner product to
score ﬁrst-order structures:

(cid:0)

(cid:1)

2For clarity, we present single-layer BiLSTMs and MLPs,

while in practice we use two layers for both.

s(p) = φ(p)

ψ(p).

(5)

·

Figure 3 illustrates our basic model’s architecture.

3.3 Learning

The parameters of the model are learned using
a max-margin objective.
Informally, the goal is
to learn parameters for the score function so that
the gold parse is scored over every incorrect parse
with a margin proportional to the cost of the incor-
N
rect parse. More formally, let
i=1
be the training set consisting of N pairs of sen-
tence xi and its gold parse yi. Training is then the
following (cid:96)2-regularized empirical risk minimiza-
tion problem:

(xi, yi)

=

D

(cid:8)

(cid:9)

min
Θ

λ
2 (cid:107)

2 +
Θ
(cid:107)

1
N

N

L

xi, yi; Θ

,

(6)

i=1
(cid:88)

(cid:0)

(cid:1)

where Θ is all parameters in the model, and L is
the structured hinge loss:

(7)

L

xi, yi; Θ

= max
y∈Y(xi)

S

xi, y

+ c

y, yi

(cid:0)

(cid:1)

(cid:0)

(cid:8)

S

(cid:0)
.

(cid:1)(cid:9)

(cid:1)
xi, yi

(cid:0)
−
c is a weighted Hamming distance that trades off
between precision and recall (Taskar et al., 2004).
Following Martins and Almeida (2014), we en-
courage recall over precision by using the costs
0.6 for false negative arc predictions and 0.4 for
false positives.

(cid:1)

3.4 Experiments

We evaluate our basic model on the English
dataset from SemEval 2015 Task 18 closed track.3
We split as in previous work (Almeida and Mar-
tins, 2015; Du et al., 2015), resulting in 33,964
00–19 of the WSJ cor-
training sentences from
§
pus, 1,692 development sentences from
20, 1,410
§
sentences from
21 as in-domain test data, and
1,849 sentences sampled from the Brown Corpus
as out-of-domain test data.

§

The closed track differs from the open and gold
tracks in that it does not allow access to any
syntactic analyses.
In the open track, additional
machine generated syntactic parses are provided,
while the gold-track gives access to various gold-
standard syntactic analyses. Our model is evalu-
ated with closed track data; it does not have access
to any syntactic analyses during training or test.

We refer the readers to

4.4 for implementa-
§
tion details, including training procedures, hyper-
parameters, pruning techniques, etc..

3http://sdp.delph-in.net
4Paired bootstrap, p < 0.05 after Bonferroni correction.

Model

DM PAS PSD Avg.

id

ood

Du et al., 2015
A&M, 2015
BASIC

Du et al., 2015
A&M, 2015
BASIC

89.1
88.2
89.4

81.8
81.8
84.5

91.3
90.9
92.2

87.2
86.9
88.3

75.7
76.4
77.6

73.3
74.8
75.3

86.3
86.0
87.4

81.7
82.0
83.6

Table 2: Labeled parsing performance (F1 score)
on both in-domain (id) and out-of-domain (ood)
test data. The last column shows the micro-
average over the three tasks. Bold font indicates
best performance without syntax. Underlines indi-
cate statistical signiﬁcance with Bonferroni (1936)
correction compared to the best baseline system.4

Empirical results. As our model uses no ex-
plicit syntactic information, the most comparable
models to ours are two state-of-the-art closed track
systems due to Du et al. (2015) and Almeida and
Martins (2015). Du et al. (2015) rely on graph-
tree transformation techniques proposed by Du
et al. (2014), and apply a voting ensemble to well-
studied tree-oriented parsers. Closely related to
ours is Almeida and Martins (2015), who used
rich, hand-engineered second-order features and
AD3 for inference.

Table 2 compares our basic model to both base-
line systems (labeled F1 score) on SemEval 2015
Task 18 test data. Scores of those systems are re-
peated from the ofﬁcial evaluation results. Our ba-
sic model signiﬁcantly outperforms the best pub-
lished results with a 1.1% absolute improvement
on the in-domain test set and 1.6% on the out-of-
domain test set.

4 Multitask SDP

We introduce two extensions to our single-task
model, both of which use training data for all
three formalisms to improve performance on each
formalism’s parsing task. We describe a ﬁrst-
order model, where representation functions are
enhanced by parameter sharing while inference
is kept separate for each task (
4.2). We then
§
introduce a model with cross-task higher-order
structures that uses joint inference across different
4.3). Both multitask models use AD3 for
tasks (
§
decoding, and are trained with the same margin-
based objective, as in our single-task model.

4.1 Problem Formulation

{

=

∈ T

We will use an additional superscript t
to
distinguish the three tasks (e.g., y(t), φ(t)), where
. Our task is now to pre-
DM, PAS, PSD
}
T
y(t)
t∈T for a given input sen-
dict three graphs
}
tence x. Multitask SDP can also be understood
as parsing x into a single uniﬁed multigraph y =
t∈T y(t). Similarly to Equations 1–2, we decom-
pose y’s score S(x, y) into a sum of local scores
(cid:83)
for local structures in y, and we seek a multigraph
ˆy that maximizes S(x, y).

{

4.2 Multitask SDP with Parameter Sharing

A common approach when using BiLSTMs for
multitask learning is to share the BiLSTM part of
the model across tasks, while training specialized
classiﬁers for each task (Søgaard and Goldberg,
2016). In this spirit, we let each task keep its own
specialized MLPs, and explore two variants of our
model that share parameters at the BiLSTM level.
The ﬁrst variant consists of a set of task-speciﬁc
BiLSTM encoders as well as a common one that
is shared across all tasks. We denote it FREDA.
FREDA uses a neural generalization of “frustrat-
ingly easy” domain adaptation (Daum´e III, 2007;
Kim et al., 2016), where one augments domain-
speciﬁc features with a shared set of features to
capture global patterns. Formally, let
t∈T
denote the three task-speciﬁc encoders. We intro-
duce another encoder
h that is shared across all
tasks. Then a new set of input functions
t∈T
(cid:101)
can be deﬁned as in Equations 3a–3c, for example:

φ(t)

h(t)

{

{

}

}

φ(t)(i

(cid:96)
→

j) = tanh

C

(t)
LA

h

(t)
i

; h

(t)
j ;

(8)

(cid:0)

hi;
(cid:2)

hj

+ b

(t)
LA

.

(cid:101)

(cid:3)
(cid:1)
The predicate and unlabeled arc versions are anal-
remain
ogous. The output representations
task-speciﬁc, and the score is still the inner prod-
uct between the input representation and the out-
put representation.

ψ(t)
{

(cid:101)

}

The second variant, which we call SHARED,
uses only the shared encoder
h, and doesn’t use
h(t)
task-speciﬁc encoders
. It can be understood
as a special case of FREDA where the dimensions
of the task-speciﬁc encoders are 0.

(cid:101)

}

{

4.3 Multitask SDP with Cross-Task

Structures

In syntactic parsing, higher-order structures have
commonly been used to model interactions be-

tween multiple adjacent arcs in the same depen-
dency tree (Carreras, 2007; Smith and Eisner,
2008; Martins et al., 2009; Zhang et al., 2014,
inter alia). Llu´ıs et al. (2013), in contrast, used
second-order structures to jointly model syntactic
dependencies and semantic roles. Similarly, we
use higher-order structures across tasks instead of
within tasks.
In this work, we look at interac-
tions between arcs that share the same head and
modiﬁer.5 See Figures 2b and 2c for examples of
higher-order cross-task structures.

Higher-order structure scoring. Borrowing
from Lei et al. (2014), we introduce a low-rank
tensor scoring strategy that, given a higher-order
structure p, models interactions between the ﬁrst-
order structures (i.e., arcs) p is made up of. This
approach builds on and extends the parameter
sharing techniques in
It can either follow
4.2.
FREDA or SHARED to get the input representations
for ﬁrst-order structures.

§

We ﬁrst introduce basic tensor notation. The or-
der of a tensor is the number of its dimensions.
The outer product of two vectors forms a second-
order tensor (matrix) where [u
v]i,j = uivj. We
denote the inner product of two tensors of the
same dimensions by
, which ﬁrst takes their
·(cid:105)
element-wise product, then sums all the elements
in the resulting tensor.

,
(cid:104)·

⊗

p(t)

For example, let p be a labeled third-order struc-
ture, including one labeled arc from each of the
t∈T . Intuitively,
three different tasks: p =
s(p) should capture every pairwise interaction be-
tween the three input and three output representa-
tions of p. Formally, we want the score function
to include a parameter for each term in the outer
product of the representation vectors: s(p) =

{

}

W,

(cid:42)

φ(t)

p(t)

ψ(t)

p(t)

,

(9)

t∈T (cid:16)
(cid:79)

(cid:17)
where W is a sixth-order tensor of parameters.6

(cid:17)(cid:17)

(cid:16)

(cid:16)

(cid:43)

⊗

With typical dimensions of representation vec-
tors, this leads to an unreasonably large number of

5In the future we hope to model structures over larger mo-
tifs, both across and within tasks, to potentially capture when
an arc in one formalism corresponds to a path in another for-
malism, for example.

6This is, of course, not the only way to model interactions
between several representations. For instance, one could con-
catenate them and feed them into another MLP. Our prelim-
inary experiments in this direction suggested that it may be
less effective given a similar number of parameters, but we
did not run full experiments.

parameters. Following Lei et al. (2014), we upper-
bound the rank of W by r to limit the number of
parameters (r is a hyperparameter, decided empir-
ically). Using the fact that a tensor of rank at most
r can be decomposed into a sum of r rank-1 ten-
sors (Hitchcock, 1927), we reparameterize W to
enforce the low-rank constraint by construction:

r

W =

U

(t)
LA

V

(t)
LA

,
(cid:19)

j,:
(cid:105)

j,: ⊗
(cid:105)

(cid:104)

(10)

t∈T (cid:18)(cid:104)
j=1
(cid:79)
(cid:88)
(t)
(t)
LA, V
LA ∈

Rr×d are now our parame-
where U
]j,: denotes the jth row of a matrix. Substi-
ters. [
·
tuting this back into Equation 9 and rearranging,
the score function s(p) can then be rewritten as:

r

j=1
(cid:88)

t∈T (cid:104)
(cid:89)

U

(t)
LAφ(t)

p(t)

V

(t)
LAψ(t)

p(t)

j

(cid:17)(cid:105)

(cid:104)

(cid:16)

.

j

(cid:16)

(cid:17)(cid:105)

(11)
We refer readers to Kolda and Bader (2009) for
mathematical details.

For labeled higher-order structures our parame-

V

U
{

(t)
LA}

ters consist of the set of six matrices,

(t)
LA} ∪
. These parameters are shared between
{
second-order and third-order labeled structures.
Labeled second-order structures are scored as
Equation 11, but with the product extending over
only the two relevant tasks. Concretely, only four
of the representation functions are used rather than
all six, along with the four corresponding ma-
. Unlabeled cross-
trices from
V
task structures are scored analogously, reusing the
same representations, but with a separate set of pa-
rameter matrices

(t)
UA} ∪ {
Note that we are not doing tensor factorization;
(t)
(t)
(t)
we are learning U
UA di-
LA, U
LA, V
rectly, and W is never explicitly instantiated.

(t)
.
UA}
(t)
UA, and V

(t)
LA} ∪ {

(t)
LA}

U
{

U

V

{

Inference and learning. Given a sentence, we
use AD3 to jointly decode all three formalisms.7
The training objective used for learning is the sum
of the losses for individual tasks.

4.4

Implementation Details

Each input token is mapped to a concatenation of
three real vectors: a pre-trained word vector; a
randomly-initialized word vector; and a randomly-
initialized POS tag vector.8 All three are updated

7Joint inference comes at a cost; our third-order model is
able to decode roughly 5.2 sentences (i.e., 15.5 task-speciﬁc
graphs) per second on a single Xeon E5-2690 2.60GHz CPU.
8There are minor differences in the part-of-speech data
provided with the three formalisms. For the basic models, we

Hyperparameter

Pre-trained word embedding dimension
Randomly-initialized word embedding dimension
POS tag embedding dimension
Dimensions of representations φ and ψ
MLP layers
BiLSTM layers
BiLSTM dimensions
Rank of tensor r
α for word dropout

Value

100
25
25
100
2
2
200
100
0.25

Table 3: Hyperparameters used in the experi-
ments.

during training. We use 100-dimensional GloVe
(Pennington et al., 2014) vectors trained over
Wikipedia and Gigaword as pre-trained word em-
beddings. To deal with out-of-vocabulary words,
we apply word dropout (Iyyer et al., 2015) and
randomly replace a word w with a special unk-
symbol with probability
1+#(w) , where #(w) is
the count of w in the training set.

α

Models are trained for up to 30 epochs with
Adam (Kingma and Ba, 2015), with β1 = β2 =
0.9, and initial learning rate η0 = 10−3. The
learning rate η is annealed at a rate of 0.5 ev-
ery 10 epochs (Dozat and Manning, 2017). We
apply early-stopping based on the labeled F1
score on the development set.9 We set
the
maximum number of iterations of AD3 to 500
and round decisions when it doesn’t converge.
We clip the (cid:96)2 norm of gradients to 1 (Graves,
2013; Sutskever et al., 2014), and we do not
use mini-batches. Randomly initialized parame-
ters are sampled from a uniform distribution over
, where dr and
−
dc are the number of the rows and columns in the
(cid:2)
matrix, respectively. An (cid:96)2 penalty of λ = 10−6 is
applied to all weights. Other hyperparameters are
summarized in Table 3.

6/(dr + dc),

6/(dr + dc)

(cid:112)

(cid:112)

(cid:3)

We use the same pruner as Martins and Almeida
(2014), where a ﬁrst-order feature-rich unlabeled
pruning model is trained for each task, and arcs
with posterior probability below 10−4 are dis-
carded. We further prune labeled structures that
appear less than 30 times in the training set.
In
the development set, about 10% of the arcs remain
after pruning, with a recall of around 99%.

use the POS tags provided with the respective dataset; for the
multitask models, we use the (automatic) POS tags provided
with DM.

9Micro-averaged labeled F1 for the multitask models.

4.5 Experiments

Experimental settings. We compare four multi-
task variants to the basic model, as well as the two
baseline systems introduced in

3.4.
§

•

•

•

•

SHARED1 is a ﬁrst-order model. It uses a sin-
gle shared BiLSTM encoder, and keeps the
inference separate for each task.
FREDA1 is a ﬁrst-order model based on “frus-
tratingly easy” parameter sharing. It uses a
shared encoder as well as task-speciﬁc ones.
The inference is kept separate for each task.
SHARED3 is a third-order model. It follows
SHARED1 and uses a single shared BiLSTM
encoder, but additionally employs cross-task
structures and inference.
FREDA3 is also a third-order model. It com-
bines FREDA1 and SHARED3 by using both
“frustratingly easy” parameter sharing and
cross-task structures and inference.

In addition, we also examine the effects of syn-
tax by comparing our models to the state-of-the-art
open track system (Almeida and Martins, 2015).10

Main results overview. Table 4a compares our
models to the best published results (labeled F1
score) on SemEval 2015 Task 18 in-domain test
set. Our basic model improves over all closed
track entries in all formalisms. It is even with the
best open track system for DM and PSD, but im-
proves on PAS and on average, without making
use of any syntax. Three of our four multitask
variants further improve over our basic model;
SHARED1’s differences are statistically insigniﬁ-
cant. Our best models (SHARED3, FREDA3) out-
perform the previous state-of-the-art closed track
system by 1.7% absolute F1, and the best open
track system by 0.9%, without the use of syntax.

We observe similar trends on the out-of-domain
test set (Table 4b), with the exception that, on
PSD, our best-performing model’s improvement
over the open-track system of Almeida and Mar-
tins (2015) is not statistically signiﬁcant.

The extent to which we might beneﬁt from syn-
tactic information remains unclear. With auto-
matically generated syntactic parses, Almeida and
Martins (2015) manage to obtain more than 1%
absolute improvements over their closed track en-

10Kanerva et al. (2015) was the winner of the gold track,
which overall saw higher performance than the closed and
open tracks. Since gold-standard syntactic analyses are not
available in most realistic scenarios, we do not include it in
this comparison.

(a) Labeled F1 score on the in-domain test set.

Du et al., 2015
A&M, 2015 (closed)
A&M, 2015 (open)†
BASIC

SHARED1
FREDA1

SHARED3
FREDA3

Du et al., 2015
A&M, 2015 (closed)
A&M, 2015 (open)†
BASIC

SHARED1
FREDA1

SHARED3
FREDA3

DM PAS PSD Avg.

89.1
88.2
89.4
89.4

89.7
90.0

90.3
90.4

81.8
81.8
83.8
84.5

84.4
84.9

85.3
85.3

91.3
90.9
91.7
92.2

91.9
92.3

92.5
92.7

87.2
86.9
87.6
88.3

88.1
88.3

88.4
89.0

75.7
76.4
77.6
77.6

77.8
78.1

78.5
78.5

73.3
74.8
76.2
75.3

75.4
75.8

76.1
76.4

86.3
86.0
87.1
87.4

87.4
87.7

88.0
88.0

81.7
82.0
83.3
83.6

83.5
83.9

84.1
84.4

DM PAS PSD Avg.

(b) Labeled F1 score on the out-of-domain test set.

†

Table 4: The last columns show the micro-average
denotes the use of syntac-
over the three tasks.
tic parses. Bold font indicates best performance
among all systems, and underlines indicate statis-
tical signiﬁcance with Bonferroni correction com-
pared to A&M, 2015 (open), the strongest baseline
system.

try, which is consistent with the extensive evalua-
tion by Zhang et al. (2016), but we leave the incor-
poration of syntactic trees to future work. Syntac-
tic parsing could be treated as yet another output
task, as explored in Llu´ıs et al. (2013) and in the
transition-based frameworks of Henderson et al.
(2013) and Swayamdipta et al. (2016).

Effects of structural overlap. We hypothesized
that the overlap between formalisms would enable
multitask learning to be effective; in this section
we investigate in more detail how structural over-
lap affected performance. By looking at undi-
rected overlap between unlabeled arcs, we dis-
cover that modeling only arcs in the same direc-
tion may have been a design mistake.

DM and PAS are more structurally similar to
each other than either is to PSD. Table 5 compares
the structural similarities between the three for-

Undirected

Directed

DM PAS

PSD

DM PAS

PSD

DM
-
PAS
70.0
PSD 57.4

67.2
-
56.3

56.8
54.9
-

-
66.9
26.4

64.2
-
29.6

26.1
26.1
-

Table 5: Pairwise structural similarities between
the three formalisms in unlabeled F1 score. Scores
from Oepen et al. (2015).

DM

PAS

PSD

UF

91.7
91.9

LF

90.4
90.8

UF

93.1
93.4

LF

91.6
92.0

UF

89.0
88.6

LF

79.8
80.4

FREDA1
FREDA3

Table 6: Unlabeled (UF ) and labeled (LF ) pars-
ing performance of FREDA1 and FREDA3 on the
development set of SemEval 2015 Task 18.

malisms in unlabeled F1 score (each formalism’s
gold-standard unlabeled graph is used as a predic-
tion of each other formalism’s gold-standard un-
labeled graph). All three formalisms have more
than 50% overlap when ignoring arcs’ directions,
but considering direction, PSD is clearly different;
PSD reverses the direction about half of the time
it shares an edge with another formalism. A con-
crete example can be found in Figure 1, where DM
and PAS both have an arc from “Last” to “week,”
while PSD has an arc from “week” to “Last.”

We can compare FREDA3 to FREDA1 to isolate
the effect of modeling higher-order structures. Ta-
ble 6 shows performance on the development data
in both unlabeled and labeled F1. We can see
that FREDA3’s unlabeled performance improves
on DM and PAS, but degrades on PSD. This sup-
ports our hypothesis, and suggests that in future
work, a more careful selection of structures to
model might lead to further improvements.

5 Related Work

We note two important strands of related work.

Graph-based parsing. Graph-based parsing
was originally invented to handle non-projective
syntax (McDonald et al., 2005; Koo et al., 2010;
inter alia), but has been
Martins et al., 2013,
adapted to semantic parsing (Flanigan et al.,
2014; Martins and Almeida, 2014; Thomson
et al., 2014; Kuhlmann, 2014, inter alia). Local
structure scoring was traditionally done with
linear models over hand-engineered features, but
lately, various forms of representation learning

have been explored to learn feature combinations
(Lei et al., 2014; Taub-Tabib et al., 2015; Pei et al.,
2015, inter alia). Our work is perhaps closest
to those who used BiLSTMs to encode inputs
(Kiperwasser and Goldberg, 2016; Kuncoro
et al., 2016; Wang and Chang, 2016; Dozat and
Manning, 2017; Ma and Hovy, 2016).

Multitask learning in NLP. There have been
many efforts in NLP to use joint learning to re-
place pipelines, motivated by concerns about cas-
cading errors. Collobert and Weston (2008) pro-
posed sharing the same word representation while
solving multiple NLP tasks. Zhang and Weiss
(2016) use a continuous stacking model for POS
tagging and parsing. Ammar et al. (2016) and Guo
et al. (2016) explored parameter sharing for multi-
lingual parsing. Johansson (2013) and Kshirsagar
et al. (2015) applied ideas from domain adapta-
tion to multitask learning. Successes in multitask
learning have been enabled by advances in repre-
sentation learning as well as earlier explorations of
parameter sharing (Ando and Zhang, 2005; Blitzer
et al., 2006; Daum´e III, 2007).

6 Conclusion

We showed two orthogonal ways to apply deep
multitask learning to graph-based parsing. The
ﬁrst shares parameters when encoding tokens in
the input with recurrent neural networks, and
the second introduces interactions between out-
put structures across formalisms. Without using
syntactic parsing,
these approaches outperform
even state-of-the-art semantic dependency pars-
ing systems that use syntax. Because our tech-
niques apply to labeled directed graphs in gen-
eral, they can easily be extended to incorporate
more formalisms, semantic or otherwise.
In fu-
ture work we hope to explore cross-task scor-
ing and inference for tasks where parallel an-
notations are not available. Our code is open-
source and available at https://github.
com/Noahs-ARK/NeurboParser.

Acknowledgements

We thank the Ark, Maxwell Forbes, Luheng He,
Kenton Lee, Julian Michael, and Jin-ge Yao for
their helpful comments on an earlier version of this
draft, and the anonymous reviewers for their valu-
able feedback. This work was supported by NSF
grant IIS-1562364 and DARPA grant FA8750-12-
2-0342 funded under the DEFT program.

References

Mariana S. C. Almeida and Andr´e F. T. Martins. 2015.
Lisbon: Evaluating TurboSemanticParser on multi-
ple languages and out-of-domain data. In Proc. of
SemEval.

Waleed Ammar, George Mulcaire, Miguel Ballesteros,
Chris Dyer, and Noah Smith. 2016. Many lan-
guages, one parser. TACL 4:431–444.

Rie Kubota Ando and Tong Zhang. 2005. A framework
for learning predictive structures from multiple tasks
and unlabeled data. JMLR 6:1817–1853.

Collin Baker, Michael Ellsworth, and Katrin Erk. 2007.
SemEval’07 task 19: Frame semantic structure ex-
traction. In Proc. of SemEval.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Grifﬁtt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract meaning representation
for sembanking. In Proc. of LAW VII & ID.

Yoshua Bengio, R`ejean Ducharme, Pascal Vincent, and
Christian Janvin. 2003. A neural probabilistic lan-
guage model. JMLR 3:1137–1155.

John Blitzer, Ryan McDonald, and Fernando Pereira.
2006. Domain adaptation with structural correspon-
dence learning. In Proc. of EMNLP.

Carlo E. Bonferroni. 1936. Teoria statistica delle classi
e calcolo delle probabilit`a. Pubblicazioni del R. Is-
tituto Superiore di Scienze Economiche e Commer-
ciali di Firenze 8:3–62.

Xavier Carreras. 2007. Experiments with a higher-
In Proc. of

order projective dependency parser.
CoNLL.

Rich Caruana. 1997. Multitask learning. Machine

Learning 28(1):41–75.

Kyunghyun Cho. 2015.
derstanding with
ArXiv:1511.07916.

Natural

distributed

language un-
representation.

Ronan Collobert and Jason Weston. 2008. A uniﬁed
architecture for natural language processing: Deep
neural networks with multitask learning. In Proc. of
ICML.

Ann Copestake and Dan Flickinger. 2000.

An
open source grammar development environment and
broad-coverage English grammar using HPSG.
In
Proc. of LREC.

Ann Copestake, Dan Flickinger, Ivan A. Sag, and Carl
Pollard. 2005. Minimal recursion semantics: An in-
troduction. Research on Language & Computation
3(4):281–332.

Hal Daum´e III. 2007. Frustratingly easy domain adap-

tation. In Proc. of ACL.

Marie-Catherine de Marneffe, Timothy Dozat, Na-
talia Silveira, Katri Haverinen, Filip Ginter, Joakim
Nivre, and Christopher D. Manning. 2014. Univer-
sal Stanford dependencies: A cross-linguistic typol-
ogy. In Proc. of LREC.

Timothy Dozat and Christopher D. Manning. 2017.
Deep biafﬁne attention for neural dependency pars-
ing. In Proc. of ICLR.

Yantao Du, Fan Zhang, Weiwei Sun, and Xiaojun Wan.
2014. Peking: Proﬁling syntactic tree parsing tech-
niques for semantic graph parsing. In Proc. of Se-
mEval.

Yantao Du, Fan Zhang, Xun Zhang, Weiwei Sun, and
Xiaojun Wan. 2015. Peking: Building semantic de-
In Proc. of
pendency graphs with a hybrid parser.
SemEval.

Nicholas FitzGerald, Oscar T¨ackstr¨om, Kuzman
Ganchev, and Dipanjan Das. 2015. Semantic role
In Proc. of
labeling with neural network factors.
EMNLP.

Jeffrey Flanigan, Sam Thomson, Jaime Carbonell,
Chris Dyer, and Noah A. Smith. 2014. A discrim-
inative graph-based parser for the abstract meaning
representation. In Proc. of ACL.

Daniel Flickinger, Yi Zhang, and Valia Kordoni. 2012.
DeepBank: A dynamically annotated treebank of the
Wall Street Journal. In Proc. of TLT.

Daniel Gildea and Daniel Jurafsky. 2002. Automatic
labeling of semantic roles. Computational Linguis-
tics 28(3):245–288.

Alex Graves. 2012. Supervised Sequence Labelling
with Recurrent Neural Networks, volume 385 of
Studies in Computational Intelligence. Springer.

Alex Graves. 2013. Generating sequences with recur-

rent neural networks. ArXiv 1308.0850.

Jiang Guo, Wanxiang Che, Haifeng Wang, and Ting
Liu. 2016. A universal framework for inductive
transfer parsing across multi-typed treebanks.
In
Proc. of COLING.

Jan Hajiˇc, Eva Hajiˇcov´a, Jarmila Panevov´a, Petr
Sgall, Ondˇrej Bojar, Silvie Cinkov´a, Eva Fuˇc´ıkov´a,
Marie Mikulov´a, Petr Pajas, Jan Popelka, Jiˇr´ı
Semeck´y, Jana ˇSindlerov´a, Jan ˇStˇep´anek, Josef
Toman, Zdeˇnka Ureˇsov´a, and Zdenˇek ˇZabokrtsk´y.
2012. Announcing Prague Czech-English depen-
dency treebank 2.0. In Proc. LREC.

James Henderson, Paola Merlo,

Ivan Titov, and
Gabriele Musillo. 2013. Multi-lingual joint pars-
ing of syntactic and semantic dependencies with a
latent variable model. Computational Linguistics
39(4):949–998.

Karl Moritz Hermann, Dipanjan Das, Jason Weston,
and Kuzman Ganchev. 2014. Semantic frame iden-
tiﬁcation with distributed word representations. In
Proc. of ACL.

Frank L. Hitchcock. 1927. The expression of a tensor
or a polyadic as a sum of products. Journal of Math-
ematical Physics 6(1):164–189.

Sepp Hochreiter and J¨urgen Schmidhuber. 1997.
Long Short-Term Memory. Neural Computation
9(8):1735–1780.

Mohit Iyyer, Varun Manjunatha, Jordan Boyd-Graber,
and Hal Daum´e III. 2015. Deep unordered compo-
sition rivals syntactic methods for text classiﬁcation.
In Proc. of ACL.

Richard Johansson. 2013. Training parsers on incom-

patible treebanks. In Proc. of NAACL.

Jenna Kanerva, Juhani Luotolahti, and Filip Ginter.
2015. Turku: Semantic dependency parsing as a se-
quence classiﬁcation. In Proc. of SemEval.

Young-Bum Kim, Karl Stratos, and Ruhi Sarikaya.
2016. Frustratingly easy neural domain adaptation.
In Proc. of COLING.

Tao Lei, Yu Xin, Yuan Zhang, Regina Barzilay, and
Tommi Jaakkola. 2014. Low-rank tensors for scor-
ing dependency structures. In Proc. of ACL.

Xavier Llu´ıs, Xavier Carreras, and Llu´ıs M`arquez.
2013. Joint arc-factored parsing of syntactic and se-
mantic dependencies. TACL 1:219–230.

Xuezhe Ma and Eduard Hovy. 2016. Neural prob-
abilistic model for non-projective MST parsing.
ArXiv 1701.00874.

Andr´e F. T. Martins and Mariana S. C. Almeida. 2014.
Priberam: A turbo semantic parser with second or-
der features. In Proc. of SemEval.

Andr´e F. T. Martins, Miguel B. Almeida, and Noah A.
Smith. 2013. Turning on the turbo: Fast third-order
non-projective turbo parsers. In Proc. of ACL.

Andr´e F. T. Martins, Noah Smith, and Eric Xing. 2009.
Concise integer linear programming formulations
for dependency parsing. In Proc. of ACL.

Andr´e F. T. Martins, Noah A. Smith, Pedro M. Q.
Aguiar, and M´ario A. T. Figueiredo. 2011. Dual de-
composition with many overlapping components. In
Proc. of EMNLP.

Diederik P. Kingma and Jimmy Ba. 2015. Adam:
In Proc. of

A method for stochastic optimization.
ICLR.

Ryan McDonald, Koby Crammer, and Fernando
Pereira. 2005. Online large-margin training of de-
pendency parsers. In Proc. of ACL.

Eliyahu Kiperwasser and Yoav Goldberg. 2016. Sim-
ple and accurate dependency parsing using bidirec-
tional LSTM feature representations. TACL 4:313–
327.

Tamara G. Kolda and Brett W. Bader. 2009. Ten-
sor decompositions and applications. SIAM Review
51(3):455–500.

Terry Koo, Alexander M. Rush, Michael Collins,
Tommi Jaakkola, and David Sontag. 2010. Dual
decomposition for parsing with non-projective head
automata. In Proc. of EMNLP.

Meghana Kshirsagar, Sam Thomson, Nathan Schnei-
der, Jaime Carbonell, Noah A. Smith, and Chris
Dyer. 2015. Frame-semantic role labeling with het-
erogeneous annotations. In Proc. of ACL.

Marco Kuhlmann. 2014. Link¨oping: Cubic-time graph
parsing with a simple scoring scheme. In Proc. of
SemEval.

Adhiguna Kuncoro, Miguel Ballesteros, Lingpeng
Kong, Chris Dyer, and Noah A. Smith. 2016. Dis-
tilling an ensemble of greedy dependency parsers
into one MST parser. In Proc. of EMNLP.

Tom Kwiatkowski, Eunsol Choi, Yoav Artzi, and
Luke S. Zettlemoyer. 2013.
Scaling semantic
parsers with on-the-ﬂy ontology matching. In Proc.
of EMNLP.

Yusuke Miyao. 2006. From linguistic theory to syntac-
tic analysis: Corpus-oriented grammar development
and feature forest model.

Andriy Mnih and Geoffrey Hinton. 2007. Three new
graphical models for statistical language modelling.
In Proc. of ICML.

Stephan Oepen, Marco Kuhlmann, Yusuke Miyao,
Daniel Zeman, Silvie Cinkov´a, Dan Flickinger, Jan
Hajiˇc, and Zdeˇnka Ureˇsov´a. 2015. SemEval 2015
task 18: Broad-coverage semantic dependency pars-
ing. In Proc. of SemEval.

Stephan Oepen, Marco Kuhlmann, Yusuke Miyao,
Daniel Zeman, Dan Flickinger, Jan Hajiˇc, Angelina
Ivanova, and Yi Zhang. 2014. SemEval 2014 task
8: Broad-coverage semantic dependency parsing. In
Proc. of SemEval.

Martha Palmer, Daniel Gildea, and Paul Kingsbury.
2005. The proposition bank: An annotated cor-
pus of semantic roles. Computational Linguistics
31(1):71–106.

Wenzhe Pei, Tao Ge, and Baobao Chang. 2015. An
effective neural network model for graph-based de-
pendency parsing. In Proc. of ACL.

Jeffrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. GloVe: Global vectors for
word representation. In Proc. of EMNLP.

Carl Pollard and Ivan A. Sag. 1994. Head-Driven
The University of

Phrase Structure Grammar.
Chicago Press.

Yuan Zhang and David Weiss. 2016.

Stack-
propagation: Improved representation learning for
syntax. In Proc. of ACL.

Mike Schuster and Kuldip K. Paliwal. 1997. Bidirec-
tional recurrent neural networks. IEEE Transactions
on Signal Processing 45(11):2673–2681.

David Smith and Jason Eisner. 2008. Dependency
parsing by belief propagation. In Proc. of EMNLP.

Anders Søgaard and Yoav Goldberg. 2016. Deep
multi-task learning with low level tasks supervised
at lower layers. In Proc. of ACL.

Vivek Srikumar and Christopher D Manning. 2014.
Learning distributed representations for structured
output prediction. In Proc. of NIPS.

Mihai Surdeanu, Richard Johansson, Adam Meyers,
Llu´ıs M`arquez, and Joakim Nivre. 2008.
The
CoNLL-2008 shared task on joint parsing of syntac-
tic and semantic dependencies. In Proc. of CoNLL.

Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. 2014.
Sequence to sequence learning with neural net-
works. In Proc. of NIPS.

Swabha Swayamdipta, Miguel Ballesteros, Chris Dyer,
and Noah A. Smith. 2016. Greedy, joint syntactic-
In Proc. of
semantic parsing with stack LSTMs.
CoNLL.

Ben Taskar, Carlos Guestrin, and Daphne Koller. 2004.
Max-margin Markov networks. In Advances in Neu-
ral Information Processing Systems 16.

Hillel Taub-Tabib, Yoav Goldberg, and Amir Glober-
son. 2015. Template kernels for dependency pars-
ing. In Proc. of NAACL.

Sam Thomson, Brendan O’Connor, Jeffrey Flani-
gan, David Bamman,
Jesse Dodge, Swabha
Swayamdipta, Nathan Schneider, Chris Dyer, and
Noah A. Smith. 2014. CMU: Arc-factored, discrim-
inative semantic dependency parsing. In Proc. of Se-
mEval.

Wenhui Wang and Baobao Chang. 2016. Graph-based
dependency parsing with bidirectional LSTM.
In
Proc. of ACL.

Naiwen Xue, Fei Xia, Fu-dong Chiou, and Martha
Palmer. 2005. The Penn Chinese TreeBank: Phrase
structure annotation of a large corpus. Natural Lan-
guage Engineering 11(2):207–238.

Xun Zhang, Yantao Du, Weiwei Sun, and Xiaojun
Wan. 2016. Transition-based parsing for deep de-
Computational Linguistics
pendency structures.
42(3):353–389.

Yuan Zhang, Tao Lei, Regina Barzilay, and Tommi S.
Jaakkola. 2014. Greed is good if randomized:
New inference for dependency parsing. In Proc. of
EMNLP.

Deep Multitask Learning for Semantic Dependency Parsing

Hao Peng∗

Sam Thomson† Noah A. Smith∗

∗Paul G. Allen School of Computer Science & Engineering, University of Washington, Seattle, WA, USA
†School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA
@cs.washington.edu, sthomson@cs.cmu.edu
hapeng,nasmith
}

{

7
1
0
2
 
r
p
A
 
5
2
 
 
]
L
C
.
s
c
[
 
 
2
v
5
5
8
6
0
.
4
0
7
1
:
v
i
X
r
a

Abstract

We present a deep neural architecture that
parses sentences into three semantic de-
pendency graph formalisms. By using ef-
ﬁcient, nearly arc-factored inference and
a bidirectional-LSTM composed with a
multi-layer perceptron, our base system is
able to signiﬁcantly improve the state of
the art for semantic dependency parsing,
without using hand-engineered features or
syntax. We then explore two multitask
learning approaches—one that shares pa-
rameters across formalisms, and one that
uses higher-order structures to predict the
graphs jointly. We ﬁnd that both ap-
proaches improve performance across for-
malisms on average, achieving a new state
of the art. Our code is open-source and
available at https://github.com/
Noahs-ARK/NeurboParser.

1

Introduction

Labeled directed graphs are a natural and ﬂexi-
ble representation for semantics (Copestake et al.,
2005; Baker et al., 2007; Surdeanu et al., 2008;
Banarescu et al., 2013, inter alia). Their generality
over trees, for instance, allows them to represent
relational semantics while handling phenomena
like coreference and coordination. Even syntactic
formalisms are moving toward graphs (de Marn-
effe et al., 2014). However, full semantic graphs
can be expensive to annotate, and efforts are frag-
mented across competing semantic theories, lead-
ing to a limited number of annotations in any one
formalism. This makes learning to parse more dif-
ﬁcult, especially for powerful but data-hungry ma-
chine learning techniques like neural networks.

In this work, we hypothesize that the overlap
among theories and their corresponding represen-

(a) DM

(b) PAS

(c) PSD

Figure 1: An example sentence annotated with the
three semantic formalisms of the broad-coverage
semantic dependency parsing shared tasks.

tations can be exploited using multitask learn-
ing (Caruana, 1997), allowing us to learn from
more data. We use the 2015 SemEval shared task
on Broad-Coverage Semantic Dependency Pars-
ing (SDP; Oepen et al., 2015) as our testbed.
The shared task provides an English-language cor-
pus with parallel annotations for three semantic
graph representations, described in
2. Though
§
the shared task was designed in part to encourage
comparison between the formalisms, we are the
ﬁrst to treat SDP as a multitask learning problem.
As a strong baseline, we introduce a new sys-
3).
tem that parses each formalism separately (
It uses a bidirectional-LSTM composed with a
multi-layer perceptron to score arcs and predi-
cates, and has efﬁcient, nearly arc-factored infer-
ence. Experiments show it signiﬁcantly improves
on state-of-the-art methods (
§

We then present two multitask extensions (

3.4).

§

4.2
§

DM

PAS

PSD

id

ood

id

ood

id

ood

# labels
% trees
% projective

59
2.3
2.9

47
9.7
8.8

42
1.2
1.6

41
2.4
3.5

74
91
42.2 51.4
41.9 54.4

Table 1: Graph statistics for in-domain (WSJ,
“id”) and out-of-domain (Brown corpus, “ood”)
data. Numbers taken from Oepen et al. (2015).

and
4.3), with a parameterization and factoriza-
§
tion that implicitly models the relationship be-
tween multiple formalisms. Experiments show
that both techniques improve over our basic
model, with an additional (but smaller) improve-
ment when they are combined (
4.5). Our analy-
§
sis shows that the improvement in unlabeled F1 is
greater for the two formalisms that are more struc-
turally similar, and suggests directions for future
work. Finally, we survey related work (
5), and
§
6).
summarize our contributions and ﬁndings (
§

2 Broad-Coverage Semantic Dependency

Parsing (SDP)

First deﬁned in a SemEval 2014 shared task
(Oepen et al., 2014), and then extended by Oepen
et al. (2015),
the broad-coverage semantic de-
pency parsing (SDP) task is centered around three
semantic formalisms whose annotations have been
converted into bilexical dependencies. See Fig-
ure 1 for an example. The formalisms come
from varied linguistic traditions, but all three aim
to capture predicate-argument relations between
content-bearing words in a sentence.

While at ﬁrst glance similar to syntactic de-
pendencies, semantic dependencies have distinct
goals and characteristics, more akin to semantic
role labeling (SRL; Gildea and Jurafsky, 2002) or
the abstract meaning representation (AMR; Ba-
narescu et al., 2013). They abstract over different
syntactic realizations of the same or similar mean-
ing (e.g., “She gave me the ball.” vs. “She gave
the ball to me.”). Conversely, they attempt to dis-
tinguish between different senses even when real-
ized in similar syntactic forms (e.g., “I baked in
the kitchen.” vs. “I baked in the sun.”).

Structurally, they are labeled directed graphs
whose vertices are tokens in the sentence. This
is in contrast to AMR whose vertices are ab-
stract concepts, with no explicit alignment to to-
kens, which makes parsing more difﬁcult (Flani-
gan et al., 2014). Their arc labels encode broadly-

applicable semantic relations rather than being tai-
lored to any speciﬁc downstream application or
ontology.1 They are not necessarily trees, because
a token may be an argument of more than one
predicate (e.g., in “John wants to eat,” John is
both the wanter and the would-be eater). Their
analyses may optionally leave out non–content-
bearing tokens, such as punctuation or the in-
ﬁnitival “to,” or prepositions that simply mark
the type of relation holding between other words.
But when restricted to content-bearing tokens (in-
cluding adjectives, adverbs, etc.), the subgraph
In this sense, SDP provides a
is connected.
whole-sentence analysis. This is in contrast to
PropBank-style SRL, which gives an analysis of
only verbal and nominal predicates (Palmer et al.,
2005). Semantic dependency graphs also tend to
have higher levels of nonprojectivity than syntac-
tic trees (Oepen et al., 2014). Sentences with
graphs containing cycles have been removed from
the dataset by the organizers, so all remaining
graphs are directed acyclic graphs. Table 1 sum-
marizes some of the dataset’s high-level statistics.

three formalisms.

Formalisms. Following the SemEval shared
tasks, we consider
The
DM (DELPH-IN MRS)
representation comes
from DeepBank (Flickinger et al., 2012), which
are manually-corrected parses from the LinGO
English Resource Grammar
(Copestake and
Flickinger, 2000). LinGO is a head-driven phrase
structure grammar (HPSG; Pollard and Sag, 1994)
with minimal
recursion semantics (Copestake
et al., 2005). The PAS (Predicate-Argument Struc-
tures) representation is extracted from the Enju
Treebank, which consists of automatic parses from
the Enju HPSG parser (Miyao, 2006). PAS an-
notations are also available for the Penn Chinese
Treebank (Xue et al., 2005). The PSD (Prague Se-
mantic Dependencies) representation is extracted
from the tectogrammatical layer of the Prague
Czech-English Dependency Treebank (Hajiˇc et al.,
2012). PSD annotations are also available for a
Czech translation of the WSJ Corpus. In this work,
we train and evaluate only on English annotations.
Of the three, PAS follows syntax most closely,
and prior work has found it the easiest to pre-
dict. PSD has the largest set of labels, and parsers

1This may make another disambiguation step necessary
to use these representations in a downstream task, but there
is evidence that modeling semantic composition separately
from grounding in any ontology is an effective way to achieve
broad coverage (Kwiatkowski et al., 2013).

(a) First-order.

(b) Second-order.

(c) Third-order.

Figure 2: Examples of local structures. We refer
to the number of arcs that a structure contains as
its order.

have signiﬁcantly lower performance on it (Oepen
et al., 2015).

3 Single-Task SDP

Here we introduce our basic model, in which train-
ing and prediction for each formalism is kept com-
pletely separate. We also lay out basic notation,
which will be reused for our multitask extensions.

3.1 Problem Formulation

The output of semantic dependency parsing is a
labeled directed graph (see Figure 1). Each arc
, indicating the
has a label from a predeﬁned set
semantic relation of the child to the head. Given
input sentence x, let
(x) be the set of possible
semantic graphs over x. The graph we seek maxi-
mizes a score function S:

L

Y

ˆy = arg max

S(x, y),

(1)

y∈Y(x)

We decompose S into a sum of local scores s for
local structures (or “parts”) p in the graph:

S(x, y) =

s(p).

(2)

p∈y
(cid:88)

For notational simplicity, we omit the dependence
of s on x. See Figure 2a for examples of local
structures. s is a parameterized function, whose
parameters (denoted Θ and suppressed here for
clarity) will be learned from the training data
(
3.3). Since we search over every possible la-
§
beled graph (i.e., considering each labeled arc for
each pair of words), our approach can be consid-
ered a graph-based (or all-pairs) method. The
models presented in this work all share this com-
mon graph-based approach, differing only in the
set of structures they score and in the parameter-
ization of the scoring function s. This approach
also underlies state-of-the-art approaches to SDP
(Martins and Almeida, 2014).

3.2 Basic Model

Our basic model is inspired by recent successes in
neural arc-factored graph-based dependency pars-
ing (Kiperwasser and Goldberg, 2016; Dozat and
Manning, 2017; Kuncoro et al., 2016). It borrows
heavily from the neural arc-scoring architectures
in those works, but decodes with a different algo-
rithm under slightly different constraints.

3.2.1 Basic Structures

Our basic model factors over three types of struc-
tures (p in Equation 2):

;

•

•

•

j;

→

→·

predicate, indicating a predicate word, de-
noted i
unlabeled arc, representing the existence of
an arc from a predicate to an argument, de-
noted i
labeled arc, an arc labeled with a semantic
role, denoted i

j.
Here i and j are word indices in a given sen-
tence, and (cid:96) indicates the arc label. This list corre-
sponds to the most basic structures used by Mar-
tins and Almeida (2014). Selecting an output y
corresponds precisely to selecting which instanti-
ations of these structures are included.

(cid:96)
→

To ensure the internal consistency of predic-
tions, the following constraints are enforced dur-
ing decoding:

if and only if there exists at least one j

•

•

j;

→

i
→·
such that i
If i
→
(cid:96)
such that i
→
there must not exist any i

j, then there must be exactly one label (cid:96)
j, then
j. Conversely, if not i

→

(cid:96)
→

j;

We also enforce a determinism constraint (Flani-
gan et al., 2014): certain labels must not appear on
more than one arc emanating from the same token.
The set of deterministic labels is decided based on
their appearance in the training set. Notably, we do
not enforce that the predicted graph is connected
or spanning. If not for the predicate and determin-
ism constraints, our model would be arc-factored,
and decoding could be done for each i, j pair in-
dependently. Our structures do overlap though,
and we employ AD3 (Martins et al., 2011) to ﬁnd
the highest-scoring internally consistent semantic
graph. AD3 is an approximate discrete optimiza-
tion algorithm based on dual decomposition.
It
can be used to decode factor graphs over discrete
variables when scored structures overlap, as is the
case here.

3.2.2 Basic Scoring

Similarly to Kiperwasser and Goldberg (2016),
our model learns representations of tokens in a
sentence using a bi-directional LSTM (BiLSTM).
Each different type of structure (predicate, unla-
beled arc, labeled arc) then shares these same BiL-
STM representations, feeding them into a multi-
layer perceptron (MLP) which is speciﬁc to the
structure type. We present the architecture slightly
differently from prior work, to make the transition
to the multitask scenario (
4) smoother. In our pre-
§
sentation, we separate the model into a function
φ that represents the input (corresponding to the
BiLSTM and the initial layers of the MLPs), and a
function ψ that represents the output (correspond-
ing to the ﬁnal layers of the MLPs), with the scores
given by their inner product.2

Distributed input representations. Long short-
term memory networks (LSTMs) are a variant
of recurrent neural networks (RNNs) designed
to alleviate the vanishing gradient problem in
RNNs (Hochreiter and Schmidhuber, 1997). A
bi-directional LSTM (BiLSTM) runs over the se-
quence in both directions (Schuster and Paliwal,
1997; Graves, 2012).

Given an input sentence x and its corresponding
part-of-speech tag sequence, each token is mapped
to a concatenation of its word embedding vector
and POS tag vector. Two LSTMs are then run
in opposite directions over the input vector se-
quence, outputting the concatenation of the two
hidden vectors at each position i: hi =
−→h i; ←−h i
(we omit hi’s dependence on x and its own pa-
(cid:3)
rameters). hi can be thought of as an encoder that
contextualizes each token conditioning on all of
its context, without any Markov assumption. h’s
parameters are learned jointly with the rest of the
model (
3.3); we refer the readers to Cho (2015)
for technical details.

§

(cid:2)

The input representation φ of a predicate struc-

ture depends on the representation of one word:

Figure 3: Illustration of the architecture of the ba-
sic model. i and j denote the indices of tokens in
the given sentence. The ﬁgure depicts single-layer
BiLSTM and MLPs, while in practice we use two
layers for both.

For unlabeled arc and labeled arc structures, it de-
pends on both the head and the modiﬁer (but not
the label, which is captured in the distributed out-
put representation):

φ(i

j) = tanh

CUA

hi; hj

+ bUA

,

φ(i

j) = tanh

(cid:0)

CLA

(cid:2)
hi; hj

(cid:3)

+ bLA

(cid:1)
.

(3b)

(3c)

→
(cid:96)
→

(cid:2)

(cid:3)

(cid:1)

(cid:0)

Distributed output representations. NLP re-
searchers have found that embedding discrete out-
put labels into a low dimensional real space is
an effective way to capture commonalities among
them (Srikumar and Manning, 2014; Hermann
et al., 2014; FitzGerald et al., 2015, inter alia).
In neural language models (Bengio et al., 2003;
Mnih and Hinton, 2007, inter alia) the weights of
the output layer could also be regarded as an out-
put embedding.

We associate each ﬁrst-order structure p with a
d-dimensional real vector ψ(p) which does not de-
pend on particular words in p. Predicates and un-
labeled arcs are each mapped to a single vector:

and each label gets a vector:

ψ(i

ψ(i

→·

) = ψpred,
j) = ψUA,

→

(4a)

(4b)

ψ(i

j) = ψLA((cid:96)).

(4c)

(cid:96)
→

φ(i

) = tanh

Cpredhi + bpred

.

(3a)

→·

Scoring. Finally, we use an inner product to
score ﬁrst-order structures:

(cid:0)

(cid:1)

2For clarity, we present single-layer BiLSTMs and MLPs,

while in practice we use two layers for both.

s(p) = φ(p)

ψ(p).

(5)

·

Figure 3 illustrates our basic model’s architecture.

3.3 Learning

The parameters of the model are learned using
a max-margin objective.
Informally, the goal is
to learn parameters for the score function so that
the gold parse is scored over every incorrect parse
with a margin proportional to the cost of the incor-
N
rect parse. More formally, let
i=1
be the training set consisting of N pairs of sen-
tence xi and its gold parse yi. Training is then the
following (cid:96)2-regularized empirical risk minimiza-
tion problem:

(xi, yi)

=

D

(cid:9)

(cid:8)

min
Θ

λ
2 (cid:107)

2 +
Θ
(cid:107)

1
N

N

L

xi, yi; Θ

,

(6)

i=1
(cid:88)

(cid:0)

(cid:1)

where Θ is all parameters in the model, and L is
the structured hinge loss:

(7)

L

xi, yi; Θ

= max
y∈Y(xi)

S

xi, y

+ c

y, yi

(cid:0)

(cid:1)

(cid:0)

(cid:8)

S

(cid:0)
.

(cid:1)(cid:9)

(cid:1)
xi, yi

(cid:0)
−
c is a weighted Hamming distance that trades off
between precision and recall (Taskar et al., 2004).
Following Martins and Almeida (2014), we en-
courage recall over precision by using the costs
0.6 for false negative arc predictions and 0.4 for
false positives.

(cid:1)

3.4 Experiments

We evaluate our basic model on the English
dataset from SemEval 2015 Task 18 closed track.3
We split as in previous work (Almeida and Mar-
tins, 2015; Du et al., 2015), resulting in 33,964
00–19 of the WSJ cor-
training sentences from
§
pus, 1,692 development sentences from
20, 1,410
§
sentences from
21 as in-domain test data, and
1,849 sentences sampled from the Brown Corpus
as out-of-domain test data.

§

The closed track differs from the open and gold
tracks in that it does not allow access to any
syntactic analyses.
In the open track, additional
machine generated syntactic parses are provided,
while the gold-track gives access to various gold-
standard syntactic analyses. Our model is evalu-
ated with closed track data; it does not have access
to any syntactic analyses during training or test.

We refer the readers to

4.4 for implementa-
§
tion details, including training procedures, hyper-
parameters, pruning techniques, etc..

3http://sdp.delph-in.net
4Paired bootstrap, p < 0.05 after Bonferroni correction.

Model

DM PAS PSD Avg.

id

ood

Du et al., 2015
A&M, 2015
BASIC

Du et al., 2015
A&M, 2015
BASIC

89.1
88.2
89.4

81.8
81.8
84.5

91.3
90.9
92.2

87.2
86.9
88.3

75.7
76.4
77.6

73.3
74.8
75.3

86.3
86.0
87.4

81.7
82.0
83.6

Table 2: Labeled parsing performance (F1 score)
on both in-domain (id) and out-of-domain (ood)
test data. The last column shows the micro-
average over the three tasks. Bold font indicates
best performance without syntax. Underlines indi-
cate statistical signiﬁcance with Bonferroni (1936)
correction compared to the best baseline system.4

Empirical results. As our model uses no ex-
plicit syntactic information, the most comparable
models to ours are two state-of-the-art closed track
systems due to Du et al. (2015) and Almeida and
Martins (2015). Du et al. (2015) rely on graph-
tree transformation techniques proposed by Du
et al. (2014), and apply a voting ensemble to well-
studied tree-oriented parsers. Closely related to
ours is Almeida and Martins (2015), who used
rich, hand-engineered second-order features and
AD3 for inference.

Table 2 compares our basic model to both base-
line systems (labeled F1 score) on SemEval 2015
Task 18 test data. Scores of those systems are re-
peated from the ofﬁcial evaluation results. Our ba-
sic model signiﬁcantly outperforms the best pub-
lished results with a 1.1% absolute improvement
on the in-domain test set and 1.6% on the out-of-
domain test set.

4 Multitask SDP

We introduce two extensions to our single-task
model, both of which use training data for all
three formalisms to improve performance on each
formalism’s parsing task. We describe a ﬁrst-
order model, where representation functions are
enhanced by parameter sharing while inference
is kept separate for each task (
4.2). We then
§
introduce a model with cross-task higher-order
structures that uses joint inference across different
4.3). Both multitask models use AD3 for
tasks (
§
decoding, and are trained with the same margin-
based objective, as in our single-task model.

4.1 Problem Formulation

{

=

∈ T

We will use an additional superscript t
to
distinguish the three tasks (e.g., y(t), φ(t)), where
. Our task is now to pre-
DM, PAS, PSD
}
T
y(t)
t∈T for a given input sen-
dict three graphs
}
tence x. Multitask SDP can also be understood
as parsing x into a single uniﬁed multigraph y =
t∈T y(t). Similarly to Equations 1–2, we decom-
pose y’s score S(x, y) into a sum of local scores
(cid:83)
for local structures in y, and we seek a multigraph
ˆy that maximizes S(x, y).

{

4.2 Multitask SDP with Parameter Sharing

A common approach when using BiLSTMs for
multitask learning is to share the BiLSTM part of
the model across tasks, while training specialized
classiﬁers for each task (Søgaard and Goldberg,
2016). In this spirit, we let each task keep its own
specialized MLPs, and explore two variants of our
model that share parameters at the BiLSTM level.
The ﬁrst variant consists of a set of task-speciﬁc
BiLSTM encoders as well as a common one that
is shared across all tasks. We denote it FREDA.
FREDA uses a neural generalization of “frustrat-
ingly easy” domain adaptation (Daum´e III, 2007;
Kim et al., 2016), where one augments domain-
speciﬁc features with a shared set of features to
capture global patterns. Formally, let
t∈T
denote the three task-speciﬁc encoders. We intro-
duce another encoder
h that is shared across all
tasks. Then a new set of input functions
t∈T
(cid:101)
can be deﬁned as in Equations 3a–3c, for example:

φ(t)

h(t)

{

{

}

}

φ(t)(i

(cid:96)
→

j) = tanh

C

(t)
LA

h

(t)
i

; h

(t)
j ;

(8)

(cid:0)

hi;
(cid:2)

hj

+ b

(t)
LA

.

(cid:101)

(cid:3)
(cid:1)
The predicate and unlabeled arc versions are anal-
remain
ogous. The output representations
task-speciﬁc, and the score is still the inner prod-
uct between the input representation and the out-
put representation.

ψ(t)
{

(cid:101)

}

The second variant, which we call SHARED,
uses only the shared encoder
h, and doesn’t use
h(t)
task-speciﬁc encoders
. It can be understood
as a special case of FREDA where the dimensions
of the task-speciﬁc encoders are 0.

(cid:101)

}

{

4.3 Multitask SDP with Cross-Task

Structures

In syntactic parsing, higher-order structures have
commonly been used to model interactions be-

tween multiple adjacent arcs in the same depen-
dency tree (Carreras, 2007; Smith and Eisner,
2008; Martins et al., 2009; Zhang et al., 2014,
inter alia). Llu´ıs et al. (2013), in contrast, used
second-order structures to jointly model syntactic
dependencies and semantic roles. Similarly, we
use higher-order structures across tasks instead of
within tasks.
In this work, we look at interac-
tions between arcs that share the same head and
modiﬁer.5 See Figures 2b and 2c for examples of
higher-order cross-task structures.

Higher-order structure scoring. Borrowing
from Lei et al. (2014), we introduce a low-rank
tensor scoring strategy that, given a higher-order
structure p, models interactions between the ﬁrst-
order structures (i.e., arcs) p is made up of. This
approach builds on and extends the parameter
sharing techniques in
It can either follow
4.2.
FREDA or SHARED to get the input representations
for ﬁrst-order structures.

§

We ﬁrst introduce basic tensor notation. The or-
der of a tensor is the number of its dimensions.
The outer product of two vectors forms a second-
order tensor (matrix) where [u
v]i,j = uivj. We
denote the inner product of two tensors of the
same dimensions by
, which ﬁrst takes their
·(cid:105)
element-wise product, then sums all the elements
in the resulting tensor.

,
(cid:104)·

⊗

p(t)

For example, let p be a labeled third-order struc-
ture, including one labeled arc from each of the
t∈T . Intuitively,
three different tasks: p =
s(p) should capture every pairwise interaction be-
tween the three input and three output representa-
tions of p. Formally, we want the score function
to include a parameter for each term in the outer
product of the representation vectors: s(p) =

{

}

W,

(cid:42)

φ(t)

p(t)

ψ(t)

p(t)

,

(9)

t∈T (cid:16)
(cid:79)

(cid:17)
where W is a sixth-order tensor of parameters.6

(cid:17)(cid:17)

(cid:16)

(cid:16)

(cid:43)

⊗

With typical dimensions of representation vec-
tors, this leads to an unreasonably large number of

5In the future we hope to model structures over larger mo-
tifs, both across and within tasks, to potentially capture when
an arc in one formalism corresponds to a path in another for-
malism, for example.

6This is, of course, not the only way to model interactions
between several representations. For instance, one could con-
catenate them and feed them into another MLP. Our prelim-
inary experiments in this direction suggested that it may be
less effective given a similar number of parameters, but we
did not run full experiments.

parameters. Following Lei et al. (2014), we upper-
bound the rank of W by r to limit the number of
parameters (r is a hyperparameter, decided empir-
ically). Using the fact that a tensor of rank at most
r can be decomposed into a sum of r rank-1 ten-
sors (Hitchcock, 1927), we reparameterize W to
enforce the low-rank constraint by construction:

r

W =

U

(t)
LA

V

(t)
LA

,
(cid:19)

j,:
(cid:105)

j,: ⊗
(cid:105)

(cid:104)

(10)

t∈T (cid:18)(cid:104)
j=1
(cid:79)
(cid:88)
(t)
(t)
LA, V
LA ∈

Rr×d are now our parame-
where U
]j,: denotes the jth row of a matrix. Substi-
ters. [
·
tuting this back into Equation 9 and rearranging,
the score function s(p) can then be rewritten as:

r

j=1
(cid:88)

t∈T (cid:104)
(cid:89)

U

(t)
LAφ(t)

p(t)

V

(t)
LAψ(t)

p(t)

j

(cid:17)(cid:105)

(cid:104)

(cid:16)

.

j

(cid:16)

(cid:17)(cid:105)

(11)
We refer readers to Kolda and Bader (2009) for
mathematical details.

For labeled higher-order structures our parame-

V

U
{

(t)
LA}

ters consist of the set of six matrices,

(t)
LA} ∪
. These parameters are shared between
{
second-order and third-order labeled structures.
Labeled second-order structures are scored as
Equation 11, but with the product extending over
only the two relevant tasks. Concretely, only four
of the representation functions are used rather than
all six, along with the four corresponding ma-
. Unlabeled cross-
trices from
V
task structures are scored analogously, reusing the
same representations, but with a separate set of pa-
rameter matrices

(t)
UA} ∪ {
Note that we are not doing tensor factorization;
(t)
(t)
(t)
we are learning U
UA di-
LA, U
LA, V
rectly, and W is never explicitly instantiated.

(t)
.
UA}
(t)
UA, and V

(t)
LA} ∪ {

(t)
LA}

U
{

U

V

{

Inference and learning. Given a sentence, we
use AD3 to jointly decode all three formalisms.7
The training objective used for learning is the sum
of the losses for individual tasks.

4.4

Implementation Details

Each input token is mapped to a concatenation of
three real vectors: a pre-trained word vector; a
randomly-initialized word vector; and a randomly-
initialized POS tag vector.8 All three are updated

7Joint inference comes at a cost; our third-order model is
able to decode roughly 5.2 sentences (i.e., 15.5 task-speciﬁc
graphs) per second on a single Xeon E5-2690 2.60GHz CPU.
8There are minor differences in the part-of-speech data
provided with the three formalisms. For the basic models, we

Hyperparameter

Pre-trained word embedding dimension
Randomly-initialized word embedding dimension
POS tag embedding dimension
Dimensions of representations φ and ψ
MLP layers
BiLSTM layers
BiLSTM dimensions
Rank of tensor r
α for word dropout

Value

100
25
25
100
2
2
200
100
0.25

Table 3: Hyperparameters used in the experi-
ments.

during training. We use 100-dimensional GloVe
(Pennington et al., 2014) vectors trained over
Wikipedia and Gigaword as pre-trained word em-
beddings. To deal with out-of-vocabulary words,
we apply word dropout (Iyyer et al., 2015) and
randomly replace a word w with a special unk-
symbol with probability
1+#(w) , where #(w) is
the count of w in the training set.

α

Models are trained for up to 30 epochs with
Adam (Kingma and Ba, 2015), with β1 = β2 =
0.9, and initial learning rate η0 = 10−3. The
learning rate η is annealed at a rate of 0.5 ev-
ery 10 epochs (Dozat and Manning, 2017). We
apply early-stopping based on the labeled F1
score on the development set.9 We set
the
maximum number of iterations of AD3 to 500
and round decisions when it doesn’t converge.
We clip the (cid:96)2 norm of gradients to 1 (Graves,
2013; Sutskever et al., 2014), and we do not
use mini-batches. Randomly initialized parame-
ters are sampled from a uniform distribution over
, where dr and
−
dc are the number of the rows and columns in the
(cid:2)
matrix, respectively. An (cid:96)2 penalty of λ = 10−6 is
applied to all weights. Other hyperparameters are
summarized in Table 3.

6/(dr + dc),

6/(dr + dc)

(cid:112)

(cid:112)

(cid:3)

We use the same pruner as Martins and Almeida
(2014), where a ﬁrst-order feature-rich unlabeled
pruning model is trained for each task, and arcs
with posterior probability below 10−4 are dis-
carded. We further prune labeled structures that
appear less than 30 times in the training set.
In
the development set, about 10% of the arcs remain
after pruning, with a recall of around 99%.

use the POS tags provided with the respective dataset; for the
multitask models, we use the (automatic) POS tags provided
with DM.

9Micro-averaged labeled F1 for the multitask models.

4.5 Experiments

Experimental settings. We compare four multi-
task variants to the basic model, as well as the two
baseline systems introduced in

3.4.
§

•

•

•

•

SHARED1 is a ﬁrst-order model. It uses a sin-
gle shared BiLSTM encoder, and keeps the
inference separate for each task.
FREDA1 is a ﬁrst-order model based on “frus-
tratingly easy” parameter sharing. It uses a
shared encoder as well as task-speciﬁc ones.
The inference is kept separate for each task.
SHARED3 is a third-order model. It follows
SHARED1 and uses a single shared BiLSTM
encoder, but additionally employs cross-task
structures and inference.
FREDA3 is also a third-order model. It com-
bines FREDA1 and SHARED3 by using both
“frustratingly easy” parameter sharing and
cross-task structures and inference.

In addition, we also examine the effects of syn-
tax by comparing our models to the state-of-the-art
open track system (Almeida and Martins, 2015).10

Main results overview. Table 4a compares our
models to the best published results (labeled F1
score) on SemEval 2015 Task 18 in-domain test
set. Our basic model improves over all closed
track entries in all formalisms. It is even with the
best open track system for DM and PSD, but im-
proves on PAS and on average, without making
use of any syntax. Three of our four multitask
variants further improve over our basic model;
SHARED1’s differences are statistically insigniﬁ-
cant. Our best models (SHARED3, FREDA3) out-
perform the previous state-of-the-art closed track
system by 1.7% absolute F1, and the best open
track system by 0.9%, without the use of syntax.

We observe similar trends on the out-of-domain
test set (Table 4b), with the exception that, on
PSD, our best-performing model’s improvement
over the open-track system of Almeida and Mar-
tins (2015) is not statistically signiﬁcant.

The extent to which we might beneﬁt from syn-
tactic information remains unclear. With auto-
matically generated syntactic parses, Almeida and
Martins (2015) manage to obtain more than 1%
absolute improvements over their closed track en-

10Kanerva et al. (2015) was the winner of the gold track,
which overall saw higher performance than the closed and
open tracks. Since gold-standard syntactic analyses are not
available in most realistic scenarios, we do not include it in
this comparison.

(a) Labeled F1 score on the in-domain test set.

Du et al., 2015
A&M, 2015 (closed)
A&M, 2015 (open)†
BASIC

SHARED1
FREDA1

SHARED3
FREDA3

Du et al., 2015
A&M, 2015 (closed)
A&M, 2015 (open)†
BASIC

SHARED1
FREDA1

SHARED3
FREDA3

DM PAS PSD Avg.

89.1
88.2
89.4
89.4

89.7
90.0

90.3
90.4

81.8
81.8
83.8
84.5

84.4
84.9

85.3
85.3

91.3
90.9
91.7
92.2

91.9
92.3

92.5
92.7

87.2
86.9
87.6
88.3

88.1
88.3

88.4
89.0

75.7
76.4
77.6
77.6

77.8
78.1

78.5
78.5

73.3
74.8
76.2
75.3

75.4
75.8

76.1
76.4

86.3
86.0
87.1
87.4

87.4
87.7

88.0
88.0

81.7
82.0
83.3
83.6

83.5
83.9

84.1
84.4

DM PAS PSD Avg.

(b) Labeled F1 score on the out-of-domain test set.

†

Table 4: The last columns show the micro-average
denotes the use of syntac-
over the three tasks.
tic parses. Bold font indicates best performance
among all systems, and underlines indicate statis-
tical signiﬁcance with Bonferroni correction com-
pared to A&M, 2015 (open), the strongest baseline
system.

try, which is consistent with the extensive evalua-
tion by Zhang et al. (2016), but we leave the incor-
poration of syntactic trees to future work. Syntac-
tic parsing could be treated as yet another output
task, as explored in Llu´ıs et al. (2013) and in the
transition-based frameworks of Henderson et al.
(2013) and Swayamdipta et al. (2016).

Effects of structural overlap. We hypothesized
that the overlap between formalisms would enable
multitask learning to be effective; in this section
we investigate in more detail how structural over-
lap affected performance. By looking at undi-
rected overlap between unlabeled arcs, we dis-
cover that modeling only arcs in the same direc-
tion may have been a design mistake.

DM and PAS are more structurally similar to
each other than either is to PSD. Table 5 compares
the structural similarities between the three for-

Undirected

Directed

DM PAS

PSD

DM PAS

PSD

DM
-
PAS
70.0
PSD 57.4

67.2
-
56.3

56.8
54.9
-

-
66.9
26.4

64.2
-
29.6

26.1
26.1
-

Table 5: Pairwise structural similarities between
the three formalisms in unlabeled F1 score. Scores
from Oepen et al. (2015).

DM

PAS

PSD

UF

91.7
91.9

LF

90.4
90.8

UF

93.1
93.4

LF

91.6
92.0

UF

89.0
88.6

LF

79.8
80.4

FREDA1
FREDA3

Table 6: Unlabeled (UF ) and labeled (LF ) pars-
ing performance of FREDA1 and FREDA3 on the
development set of SemEval 2015 Task 18.

malisms in unlabeled F1 score (each formalism’s
gold-standard unlabeled graph is used as a predic-
tion of each other formalism’s gold-standard un-
labeled graph). All three formalisms have more
than 50% overlap when ignoring arcs’ directions,
but considering direction, PSD is clearly different;
PSD reverses the direction about half of the time
it shares an edge with another formalism. A con-
crete example can be found in Figure 1, where DM
and PAS both have an arc from “Last” to “week,”
while PSD has an arc from “week” to “Last.”

We can compare FREDA3 to FREDA1 to isolate
the effect of modeling higher-order structures. Ta-
ble 6 shows performance on the development data
in both unlabeled and labeled F1. We can see
that FREDA3’s unlabeled performance improves
on DM and PAS, but degrades on PSD. This sup-
ports our hypothesis, and suggests that in future
work, a more careful selection of structures to
model might lead to further improvements.

5 Related Work

We note two important strands of related work.

Graph-based parsing. Graph-based parsing
was originally invented to handle non-projective
syntax (McDonald et al., 2005; Koo et al., 2010;
inter alia), but has been
Martins et al., 2013,
adapted to semantic parsing (Flanigan et al.,
2014; Martins and Almeida, 2014; Thomson
et al., 2014; Kuhlmann, 2014, inter alia). Local
structure scoring was traditionally done with
linear models over hand-engineered features, but
lately, various forms of representation learning

have been explored to learn feature combinations
(Lei et al., 2014; Taub-Tabib et al., 2015; Pei et al.,
2015, inter alia). Our work is perhaps closest
to those who used BiLSTMs to encode inputs
(Kiperwasser and Goldberg, 2016; Kuncoro
et al., 2016; Wang and Chang, 2016; Dozat and
Manning, 2017; Ma and Hovy, 2016).

Multitask learning in NLP. There have been
many efforts in NLP to use joint learning to re-
place pipelines, motivated by concerns about cas-
cading errors. Collobert and Weston (2008) pro-
posed sharing the same word representation while
solving multiple NLP tasks. Zhang and Weiss
(2016) use a continuous stacking model for POS
tagging and parsing. Ammar et al. (2016) and Guo
et al. (2016) explored parameter sharing for multi-
lingual parsing. Johansson (2013) and Kshirsagar
et al. (2015) applied ideas from domain adapta-
tion to multitask learning. Successes in multitask
learning have been enabled by advances in repre-
sentation learning as well as earlier explorations of
parameter sharing (Ando and Zhang, 2005; Blitzer
et al., 2006; Daum´e III, 2007).

6 Conclusion

We showed two orthogonal ways to apply deep
multitask learning to graph-based parsing. The
ﬁrst shares parameters when encoding tokens in
the input with recurrent neural networks, and
the second introduces interactions between out-
put structures across formalisms. Without using
syntactic parsing,
these approaches outperform
even state-of-the-art semantic dependency pars-
ing systems that use syntax. Because our tech-
niques apply to labeled directed graphs in gen-
eral, they can easily be extended to incorporate
more formalisms, semantic or otherwise.
In fu-
ture work we hope to explore cross-task scor-
ing and inference for tasks where parallel an-
notations are not available. Our code is open-
source and available at https://github.
com/Noahs-ARK/NeurboParser.

Acknowledgements

We thank the Ark, Maxwell Forbes, Luheng He,
Kenton Lee, Julian Michael, and Jin-ge Yao for
their helpful comments on an earlier version of this
draft, and the anonymous reviewers for their valu-
able feedback. This work was supported by NSF
grant IIS-1562364 and DARPA grant FA8750-12-
2-0342 funded under the DEFT program.

References

Mariana S. C. Almeida and Andr´e F. T. Martins. 2015.
Lisbon: Evaluating TurboSemanticParser on multi-
ple languages and out-of-domain data. In Proc. of
SemEval.

Waleed Ammar, George Mulcaire, Miguel Ballesteros,
Chris Dyer, and Noah Smith. 2016. Many lan-
guages, one parser. TACL 4:431–444.

Rie Kubota Ando and Tong Zhang. 2005. A framework
for learning predictive structures from multiple tasks
and unlabeled data. JMLR 6:1817–1853.

Collin Baker, Michael Ellsworth, and Katrin Erk. 2007.
SemEval’07 task 19: Frame semantic structure ex-
traction. In Proc. of SemEval.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Grifﬁtt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract meaning representation
for sembanking. In Proc. of LAW VII & ID.

Yoshua Bengio, R`ejean Ducharme, Pascal Vincent, and
Christian Janvin. 2003. A neural probabilistic lan-
guage model. JMLR 3:1137–1155.

John Blitzer, Ryan McDonald, and Fernando Pereira.
2006. Domain adaptation with structural correspon-
dence learning. In Proc. of EMNLP.

Carlo E. Bonferroni. 1936. Teoria statistica delle classi
e calcolo delle probabilit`a. Pubblicazioni del R. Is-
tituto Superiore di Scienze Economiche e Commer-
ciali di Firenze 8:3–62.

Xavier Carreras. 2007. Experiments with a higher-
In Proc. of

order projective dependency parser.
CoNLL.

Rich Caruana. 1997. Multitask learning. Machine

Learning 28(1):41–75.

Kyunghyun Cho. 2015.
derstanding with
ArXiv:1511.07916.

Natural

distributed

language un-
representation.

Ronan Collobert and Jason Weston. 2008. A uniﬁed
architecture for natural language processing: Deep
neural networks with multitask learning. In Proc. of
ICML.

Ann Copestake and Dan Flickinger. 2000.

An
open source grammar development environment and
broad-coverage English grammar using HPSG.
In
Proc. of LREC.

Ann Copestake, Dan Flickinger, Ivan A. Sag, and Carl
Pollard. 2005. Minimal recursion semantics: An in-
troduction. Research on Language & Computation
3(4):281–332.

Hal Daum´e III. 2007. Frustratingly easy domain adap-

tation. In Proc. of ACL.

Marie-Catherine de Marneffe, Timothy Dozat, Na-
talia Silveira, Katri Haverinen, Filip Ginter, Joakim
Nivre, and Christopher D. Manning. 2014. Univer-
sal Stanford dependencies: A cross-linguistic typol-
ogy. In Proc. of LREC.

Timothy Dozat and Christopher D. Manning. 2017.
Deep biafﬁne attention for neural dependency pars-
ing. In Proc. of ICLR.

Yantao Du, Fan Zhang, Weiwei Sun, and Xiaojun Wan.
2014. Peking: Proﬁling syntactic tree parsing tech-
niques for semantic graph parsing. In Proc. of Se-
mEval.

Yantao Du, Fan Zhang, Xun Zhang, Weiwei Sun, and
Xiaojun Wan. 2015. Peking: Building semantic de-
In Proc. of
pendency graphs with a hybrid parser.
SemEval.

Nicholas FitzGerald, Oscar T¨ackstr¨om, Kuzman
Ganchev, and Dipanjan Das. 2015. Semantic role
In Proc. of
labeling with neural network factors.
EMNLP.

Jeffrey Flanigan, Sam Thomson, Jaime Carbonell,
Chris Dyer, and Noah A. Smith. 2014. A discrim-
inative graph-based parser for the abstract meaning
representation. In Proc. of ACL.

Daniel Flickinger, Yi Zhang, and Valia Kordoni. 2012.
DeepBank: A dynamically annotated treebank of the
Wall Street Journal. In Proc. of TLT.

Daniel Gildea and Daniel Jurafsky. 2002. Automatic
labeling of semantic roles. Computational Linguis-
tics 28(3):245–288.

Alex Graves. 2012. Supervised Sequence Labelling
with Recurrent Neural Networks, volume 385 of
Studies in Computational Intelligence. Springer.

Alex Graves. 2013. Generating sequences with recur-

rent neural networks. ArXiv 1308.0850.

Jiang Guo, Wanxiang Che, Haifeng Wang, and Ting
Liu. 2016. A universal framework for inductive
transfer parsing across multi-typed treebanks.
In
Proc. of COLING.

Jan Hajiˇc, Eva Hajiˇcov´a, Jarmila Panevov´a, Petr
Sgall, Ondˇrej Bojar, Silvie Cinkov´a, Eva Fuˇc´ıkov´a,
Marie Mikulov´a, Petr Pajas, Jan Popelka, Jiˇr´ı
Semeck´y, Jana ˇSindlerov´a, Jan ˇStˇep´anek, Josef
Toman, Zdeˇnka Ureˇsov´a, and Zdenˇek ˇZabokrtsk´y.
2012. Announcing Prague Czech-English depen-
dency treebank 2.0. In Proc. LREC.

James Henderson, Paola Merlo,

Ivan Titov, and
Gabriele Musillo. 2013. Multi-lingual joint pars-
ing of syntactic and semantic dependencies with a
latent variable model. Computational Linguistics
39(4):949–998.

Karl Moritz Hermann, Dipanjan Das, Jason Weston,
and Kuzman Ganchev. 2014. Semantic frame iden-
tiﬁcation with distributed word representations. In
Proc. of ACL.

Frank L. Hitchcock. 1927. The expression of a tensor
or a polyadic as a sum of products. Journal of Math-
ematical Physics 6(1):164–189.

Sepp Hochreiter and J¨urgen Schmidhuber. 1997.
Long Short-Term Memory. Neural Computation
9(8):1735–1780.

Mohit Iyyer, Varun Manjunatha, Jordan Boyd-Graber,
and Hal Daum´e III. 2015. Deep unordered compo-
sition rivals syntactic methods for text classiﬁcation.
In Proc. of ACL.

Richard Johansson. 2013. Training parsers on incom-

patible treebanks. In Proc. of NAACL.

Jenna Kanerva, Juhani Luotolahti, and Filip Ginter.
2015. Turku: Semantic dependency parsing as a se-
quence classiﬁcation. In Proc. of SemEval.

Young-Bum Kim, Karl Stratos, and Ruhi Sarikaya.
2016. Frustratingly easy neural domain adaptation.
In Proc. of COLING.

Tao Lei, Yu Xin, Yuan Zhang, Regina Barzilay, and
Tommi Jaakkola. 2014. Low-rank tensors for scor-
ing dependency structures. In Proc. of ACL.

Xavier Llu´ıs, Xavier Carreras, and Llu´ıs M`arquez.
2013. Joint arc-factored parsing of syntactic and se-
mantic dependencies. TACL 1:219–230.

Xuezhe Ma and Eduard Hovy. 2016. Neural prob-
abilistic model for non-projective MST parsing.
ArXiv 1701.00874.

Andr´e F. T. Martins and Mariana S. C. Almeida. 2014.
Priberam: A turbo semantic parser with second or-
der features. In Proc. of SemEval.

Andr´e F. T. Martins, Miguel B. Almeida, and Noah A.
Smith. 2013. Turning on the turbo: Fast third-order
non-projective turbo parsers. In Proc. of ACL.

Andr´e F. T. Martins, Noah Smith, and Eric Xing. 2009.
Concise integer linear programming formulations
for dependency parsing. In Proc. of ACL.

Andr´e F. T. Martins, Noah A. Smith, Pedro M. Q.
Aguiar, and M´ario A. T. Figueiredo. 2011. Dual de-
composition with many overlapping components. In
Proc. of EMNLP.

Diederik P. Kingma and Jimmy Ba. 2015. Adam:
In Proc. of

A method for stochastic optimization.
ICLR.

Ryan McDonald, Koby Crammer, and Fernando
Pereira. 2005. Online large-margin training of de-
pendency parsers. In Proc. of ACL.

Eliyahu Kiperwasser and Yoav Goldberg. 2016. Sim-
ple and accurate dependency parsing using bidirec-
tional LSTM feature representations. TACL 4:313–
327.

Tamara G. Kolda and Brett W. Bader. 2009. Ten-
sor decompositions and applications. SIAM Review
51(3):455–500.

Terry Koo, Alexander M. Rush, Michael Collins,
Tommi Jaakkola, and David Sontag. 2010. Dual
decomposition for parsing with non-projective head
automata. In Proc. of EMNLP.

Meghana Kshirsagar, Sam Thomson, Nathan Schnei-
der, Jaime Carbonell, Noah A. Smith, and Chris
Dyer. 2015. Frame-semantic role labeling with het-
erogeneous annotations. In Proc. of ACL.

Marco Kuhlmann. 2014. Link¨oping: Cubic-time graph
parsing with a simple scoring scheme. In Proc. of
SemEval.

Adhiguna Kuncoro, Miguel Ballesteros, Lingpeng
Kong, Chris Dyer, and Noah A. Smith. 2016. Dis-
tilling an ensemble of greedy dependency parsers
into one MST parser. In Proc. of EMNLP.

Tom Kwiatkowski, Eunsol Choi, Yoav Artzi, and
Luke S. Zettlemoyer. 2013.
Scaling semantic
parsers with on-the-ﬂy ontology matching. In Proc.
of EMNLP.

Yusuke Miyao. 2006. From linguistic theory to syntac-
tic analysis: Corpus-oriented grammar development
and feature forest model.

Andriy Mnih and Geoffrey Hinton. 2007. Three new
graphical models for statistical language modelling.
In Proc. of ICML.

Stephan Oepen, Marco Kuhlmann, Yusuke Miyao,
Daniel Zeman, Silvie Cinkov´a, Dan Flickinger, Jan
Hajiˇc, and Zdeˇnka Ureˇsov´a. 2015. SemEval 2015
task 18: Broad-coverage semantic dependency pars-
ing. In Proc. of SemEval.

Stephan Oepen, Marco Kuhlmann, Yusuke Miyao,
Daniel Zeman, Dan Flickinger, Jan Hajiˇc, Angelina
Ivanova, and Yi Zhang. 2014. SemEval 2014 task
8: Broad-coverage semantic dependency parsing. In
Proc. of SemEval.

Martha Palmer, Daniel Gildea, and Paul Kingsbury.
2005. The proposition bank: An annotated cor-
pus of semantic roles. Computational Linguistics
31(1):71–106.

Wenzhe Pei, Tao Ge, and Baobao Chang. 2015. An
effective neural network model for graph-based de-
pendency parsing. In Proc. of ACL.

Jeffrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. GloVe: Global vectors for
word representation. In Proc. of EMNLP.

Carl Pollard and Ivan A. Sag. 1994. Head-Driven
The University of

Phrase Structure Grammar.
Chicago Press.

Yuan Zhang and David Weiss. 2016.

Stack-
propagation: Improved representation learning for
syntax. In Proc. of ACL.

Mike Schuster and Kuldip K. Paliwal. 1997. Bidirec-
tional recurrent neural networks. IEEE Transactions
on Signal Processing 45(11):2673–2681.

David Smith and Jason Eisner. 2008. Dependency
parsing by belief propagation. In Proc. of EMNLP.

Anders Søgaard and Yoav Goldberg. 2016. Deep
multi-task learning with low level tasks supervised
at lower layers. In Proc. of ACL.

Vivek Srikumar and Christopher D Manning. 2014.
Learning distributed representations for structured
output prediction. In Proc. of NIPS.

Mihai Surdeanu, Richard Johansson, Adam Meyers,
Llu´ıs M`arquez, and Joakim Nivre. 2008.
The
CoNLL-2008 shared task on joint parsing of syntac-
tic and semantic dependencies. In Proc. of CoNLL.

Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. 2014.
Sequence to sequence learning with neural net-
works. In Proc. of NIPS.

Swabha Swayamdipta, Miguel Ballesteros, Chris Dyer,
and Noah A. Smith. 2016. Greedy, joint syntactic-
In Proc. of
semantic parsing with stack LSTMs.
CoNLL.

Ben Taskar, Carlos Guestrin, and Daphne Koller. 2004.
Max-margin Markov networks. In Advances in Neu-
ral Information Processing Systems 16.

Hillel Taub-Tabib, Yoav Goldberg, and Amir Glober-
son. 2015. Template kernels for dependency pars-
ing. In Proc. of NAACL.

Sam Thomson, Brendan O’Connor, Jeffrey Flani-
gan, David Bamman,
Jesse Dodge, Swabha
Swayamdipta, Nathan Schneider, Chris Dyer, and
Noah A. Smith. 2014. CMU: Arc-factored, discrim-
inative semantic dependency parsing. In Proc. of Se-
mEval.

Wenhui Wang and Baobao Chang. 2016. Graph-based
dependency parsing with bidirectional LSTM.
In
Proc. of ACL.

Naiwen Xue, Fei Xia, Fu-dong Chiou, and Martha
Palmer. 2005. The Penn Chinese TreeBank: Phrase
structure annotation of a large corpus. Natural Lan-
guage Engineering 11(2):207–238.

Xun Zhang, Yantao Du, Weiwei Sun, and Xiaojun
Wan. 2016. Transition-based parsing for deep de-
Computational Linguistics
pendency structures.
42(3):353–389.

Yuan Zhang, Tao Lei, Regina Barzilay, and Tommi S.
Jaakkola. 2014. Greed is good if randomized:
New inference for dependency parsing. In Proc. of
EMNLP.

Deep Multitask Learning for Semantic Dependency Parsing

Hao Peng∗

Sam Thomson† Noah A. Smith∗

∗Paul G. Allen School of Computer Science & Engineering, University of Washington, Seattle, WA, USA
†School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA
@cs.washington.edu, sthomson@cs.cmu.edu
hapeng,nasmith
}

{

7
1
0
2
 
r
p
A
 
5
2
 
 
]
L
C
.
s
c
[
 
 
2
v
5
5
8
6
0
.
4
0
7
1
:
v
i
X
r
a

Abstract

We present a deep neural architecture that
parses sentences into three semantic de-
pendency graph formalisms. By using ef-
ﬁcient, nearly arc-factored inference and
a bidirectional-LSTM composed with a
multi-layer perceptron, our base system is
able to signiﬁcantly improve the state of
the art for semantic dependency parsing,
without using hand-engineered features or
syntax. We then explore two multitask
learning approaches—one that shares pa-
rameters across formalisms, and one that
uses higher-order structures to predict the
graphs jointly. We ﬁnd that both ap-
proaches improve performance across for-
malisms on average, achieving a new state
of the art. Our code is open-source and
available at https://github.com/
Noahs-ARK/NeurboParser.

1

Introduction

Labeled directed graphs are a natural and ﬂexi-
ble representation for semantics (Copestake et al.,
2005; Baker et al., 2007; Surdeanu et al., 2008;
Banarescu et al., 2013, inter alia). Their generality
over trees, for instance, allows them to represent
relational semantics while handling phenomena
like coreference and coordination. Even syntactic
formalisms are moving toward graphs (de Marn-
effe et al., 2014). However, full semantic graphs
can be expensive to annotate, and efforts are frag-
mented across competing semantic theories, lead-
ing to a limited number of annotations in any one
formalism. This makes learning to parse more dif-
ﬁcult, especially for powerful but data-hungry ma-
chine learning techniques like neural networks.

In this work, we hypothesize that the overlap
among theories and their corresponding represen-

(a) DM

(b) PAS

(c) PSD

Figure 1: An example sentence annotated with the
three semantic formalisms of the broad-coverage
semantic dependency parsing shared tasks.

tations can be exploited using multitask learn-
ing (Caruana, 1997), allowing us to learn from
more data. We use the 2015 SemEval shared task
on Broad-Coverage Semantic Dependency Pars-
ing (SDP; Oepen et al., 2015) as our testbed.
The shared task provides an English-language cor-
pus with parallel annotations for three semantic
graph representations, described in
2. Though
§
the shared task was designed in part to encourage
comparison between the formalisms, we are the
ﬁrst to treat SDP as a multitask learning problem.
As a strong baseline, we introduce a new sys-
3).
tem that parses each formalism separately (
It uses a bidirectional-LSTM composed with a
multi-layer perceptron to score arcs and predi-
cates, and has efﬁcient, nearly arc-factored infer-
ence. Experiments show it signiﬁcantly improves
on state-of-the-art methods (
§

We then present two multitask extensions (

3.4).

§

4.2
§

DM

PAS

PSD

id

ood

id

ood

id

ood

# labels
% trees
% projective

59
2.3
2.9

47
9.7
8.8

42
1.2
1.6

41
2.4
3.5

74
91
42.2 51.4
41.9 54.4

Table 1: Graph statistics for in-domain (WSJ,
“id”) and out-of-domain (Brown corpus, “ood”)
data. Numbers taken from Oepen et al. (2015).

and
4.3), with a parameterization and factoriza-
§
tion that implicitly models the relationship be-
tween multiple formalisms. Experiments show
that both techniques improve over our basic
model, with an additional (but smaller) improve-
ment when they are combined (
4.5). Our analy-
§
sis shows that the improvement in unlabeled F1 is
greater for the two formalisms that are more struc-
turally similar, and suggests directions for future
work. Finally, we survey related work (
5), and
§
6).
summarize our contributions and ﬁndings (
§

2 Broad-Coverage Semantic Dependency

Parsing (SDP)

First deﬁned in a SemEval 2014 shared task
(Oepen et al., 2014), and then extended by Oepen
et al. (2015),
the broad-coverage semantic de-
pency parsing (SDP) task is centered around three
semantic formalisms whose annotations have been
converted into bilexical dependencies. See Fig-
ure 1 for an example. The formalisms come
from varied linguistic traditions, but all three aim
to capture predicate-argument relations between
content-bearing words in a sentence.

While at ﬁrst glance similar to syntactic de-
pendencies, semantic dependencies have distinct
goals and characteristics, more akin to semantic
role labeling (SRL; Gildea and Jurafsky, 2002) or
the abstract meaning representation (AMR; Ba-
narescu et al., 2013). They abstract over different
syntactic realizations of the same or similar mean-
ing (e.g., “She gave me the ball.” vs. “She gave
the ball to me.”). Conversely, they attempt to dis-
tinguish between different senses even when real-
ized in similar syntactic forms (e.g., “I baked in
the kitchen.” vs. “I baked in the sun.”).

Structurally, they are labeled directed graphs
whose vertices are tokens in the sentence. This
is in contrast to AMR whose vertices are ab-
stract concepts, with no explicit alignment to to-
kens, which makes parsing more difﬁcult (Flani-
gan et al., 2014). Their arc labels encode broadly-

applicable semantic relations rather than being tai-
lored to any speciﬁc downstream application or
ontology.1 They are not necessarily trees, because
a token may be an argument of more than one
predicate (e.g., in “John wants to eat,” John is
both the wanter and the would-be eater). Their
analyses may optionally leave out non–content-
bearing tokens, such as punctuation or the in-
ﬁnitival “to,” or prepositions that simply mark
the type of relation holding between other words.
But when restricted to content-bearing tokens (in-
cluding adjectives, adverbs, etc.), the subgraph
In this sense, SDP provides a
is connected.
whole-sentence analysis. This is in contrast to
PropBank-style SRL, which gives an analysis of
only verbal and nominal predicates (Palmer et al.,
2005). Semantic dependency graphs also tend to
have higher levels of nonprojectivity than syntac-
tic trees (Oepen et al., 2014). Sentences with
graphs containing cycles have been removed from
the dataset by the organizers, so all remaining
graphs are directed acyclic graphs. Table 1 sum-
marizes some of the dataset’s high-level statistics.

three formalisms.

Formalisms. Following the SemEval shared
tasks, we consider
The
DM (DELPH-IN MRS)
representation comes
from DeepBank (Flickinger et al., 2012), which
are manually-corrected parses from the LinGO
English Resource Grammar
(Copestake and
Flickinger, 2000). LinGO is a head-driven phrase
structure grammar (HPSG; Pollard and Sag, 1994)
with minimal
recursion semantics (Copestake
et al., 2005). The PAS (Predicate-Argument Struc-
tures) representation is extracted from the Enju
Treebank, which consists of automatic parses from
the Enju HPSG parser (Miyao, 2006). PAS an-
notations are also available for the Penn Chinese
Treebank (Xue et al., 2005). The PSD (Prague Se-
mantic Dependencies) representation is extracted
from the tectogrammatical layer of the Prague
Czech-English Dependency Treebank (Hajiˇc et al.,
2012). PSD annotations are also available for a
Czech translation of the WSJ Corpus. In this work,
we train and evaluate only on English annotations.
Of the three, PAS follows syntax most closely,
and prior work has found it the easiest to pre-
dict. PSD has the largest set of labels, and parsers

1This may make another disambiguation step necessary
to use these representations in a downstream task, but there
is evidence that modeling semantic composition separately
from grounding in any ontology is an effective way to achieve
broad coverage (Kwiatkowski et al., 2013).

(a) First-order.

(b) Second-order.

(c) Third-order.

Figure 2: Examples of local structures. We refer
to the number of arcs that a structure contains as
its order.

have signiﬁcantly lower performance on it (Oepen
et al., 2015).

3 Single-Task SDP

Here we introduce our basic model, in which train-
ing and prediction for each formalism is kept com-
pletely separate. We also lay out basic notation,
which will be reused for our multitask extensions.

3.1 Problem Formulation

The output of semantic dependency parsing is a
labeled directed graph (see Figure 1). Each arc
, indicating the
has a label from a predeﬁned set
semantic relation of the child to the head. Given
input sentence x, let
(x) be the set of possible
semantic graphs over x. The graph we seek maxi-
mizes a score function S:

L

Y

ˆy = arg max

S(x, y),

(1)

y∈Y(x)

We decompose S into a sum of local scores s for
local structures (or “parts”) p in the graph:

S(x, y) =

s(p).

(2)

p∈y
(cid:88)

For notational simplicity, we omit the dependence
of s on x. See Figure 2a for examples of local
structures. s is a parameterized function, whose
parameters (denoted Θ and suppressed here for
clarity) will be learned from the training data
(
3.3). Since we search over every possible la-
§
beled graph (i.e., considering each labeled arc for
each pair of words), our approach can be consid-
ered a graph-based (or all-pairs) method. The
models presented in this work all share this com-
mon graph-based approach, differing only in the
set of structures they score and in the parameter-
ization of the scoring function s. This approach
also underlies state-of-the-art approaches to SDP
(Martins and Almeida, 2014).

3.2 Basic Model

Our basic model is inspired by recent successes in
neural arc-factored graph-based dependency pars-
ing (Kiperwasser and Goldberg, 2016; Dozat and
Manning, 2017; Kuncoro et al., 2016). It borrows
heavily from the neural arc-scoring architectures
in those works, but decodes with a different algo-
rithm under slightly different constraints.

3.2.1 Basic Structures

Our basic model factors over three types of struc-
tures (p in Equation 2):

;

•

•

•

j;

→

→·

predicate, indicating a predicate word, de-
noted i
unlabeled arc, representing the existence of
an arc from a predicate to an argument, de-
noted i
labeled arc, an arc labeled with a semantic
role, denoted i

j.
Here i and j are word indices in a given sen-
tence, and (cid:96) indicates the arc label. This list corre-
sponds to the most basic structures used by Mar-
tins and Almeida (2014). Selecting an output y
corresponds precisely to selecting which instanti-
ations of these structures are included.

(cid:96)
→

To ensure the internal consistency of predic-
tions, the following constraints are enforced dur-
ing decoding:

if and only if there exists at least one j

•

•

j;

→

i
→·
such that i
If i
→
(cid:96)
such that i
→
there must not exist any i

j, then there must be exactly one label (cid:96)
j, then
j. Conversely, if not i

→

(cid:96)
→

j;

We also enforce a determinism constraint (Flani-
gan et al., 2014): certain labels must not appear on
more than one arc emanating from the same token.
The set of deterministic labels is decided based on
their appearance in the training set. Notably, we do
not enforce that the predicted graph is connected
or spanning. If not for the predicate and determin-
ism constraints, our model would be arc-factored,
and decoding could be done for each i, j pair in-
dependently. Our structures do overlap though,
and we employ AD3 (Martins et al., 2011) to ﬁnd
the highest-scoring internally consistent semantic
graph. AD3 is an approximate discrete optimiza-
tion algorithm based on dual decomposition.
It
can be used to decode factor graphs over discrete
variables when scored structures overlap, as is the
case here.

3.2.2 Basic Scoring

Similarly to Kiperwasser and Goldberg (2016),
our model learns representations of tokens in a
sentence using a bi-directional LSTM (BiLSTM).
Each different type of structure (predicate, unla-
beled arc, labeled arc) then shares these same BiL-
STM representations, feeding them into a multi-
layer perceptron (MLP) which is speciﬁc to the
structure type. We present the architecture slightly
differently from prior work, to make the transition
to the multitask scenario (
4) smoother. In our pre-
§
sentation, we separate the model into a function
φ that represents the input (corresponding to the
BiLSTM and the initial layers of the MLPs), and a
function ψ that represents the output (correspond-
ing to the ﬁnal layers of the MLPs), with the scores
given by their inner product.2

Distributed input representations. Long short-
term memory networks (LSTMs) are a variant
of recurrent neural networks (RNNs) designed
to alleviate the vanishing gradient problem in
RNNs (Hochreiter and Schmidhuber, 1997). A
bi-directional LSTM (BiLSTM) runs over the se-
quence in both directions (Schuster and Paliwal,
1997; Graves, 2012).

Given an input sentence x and its corresponding
part-of-speech tag sequence, each token is mapped
to a concatenation of its word embedding vector
and POS tag vector. Two LSTMs are then run
in opposite directions over the input vector se-
quence, outputting the concatenation of the two
hidden vectors at each position i: hi =
−→h i; ←−h i
(we omit hi’s dependence on x and its own pa-
(cid:3)
rameters). hi can be thought of as an encoder that
contextualizes each token conditioning on all of
its context, without any Markov assumption. h’s
parameters are learned jointly with the rest of the
model (
3.3); we refer the readers to Cho (2015)
for technical details.

§

(cid:2)

The input representation φ of a predicate struc-

ture depends on the representation of one word:

Figure 3: Illustration of the architecture of the ba-
sic model. i and j denote the indices of tokens in
the given sentence. The ﬁgure depicts single-layer
BiLSTM and MLPs, while in practice we use two
layers for both.

For unlabeled arc and labeled arc structures, it de-
pends on both the head and the modiﬁer (but not
the label, which is captured in the distributed out-
put representation):

φ(i

j) = tanh

CUA

hi; hj

+ bUA

,

φ(i

j) = tanh

(cid:0)

CLA

(cid:2)
hi; hj

(cid:3)

+ bLA

(cid:1)
.

(3b)

(3c)

→
(cid:96)
→

(cid:2)

(cid:3)

(cid:1)

(cid:0)

Distributed output representations. NLP re-
searchers have found that embedding discrete out-
put labels into a low dimensional real space is
an effective way to capture commonalities among
them (Srikumar and Manning, 2014; Hermann
et al., 2014; FitzGerald et al., 2015, inter alia).
In neural language models (Bengio et al., 2003;
Mnih and Hinton, 2007, inter alia) the weights of
the output layer could also be regarded as an out-
put embedding.

We associate each ﬁrst-order structure p with a
d-dimensional real vector ψ(p) which does not de-
pend on particular words in p. Predicates and un-
labeled arcs are each mapped to a single vector:

and each label gets a vector:

ψ(i

ψ(i

→·

) = ψpred,
j) = ψUA,

→

(4a)

(4b)

ψ(i

j) = ψLA((cid:96)).

(4c)

(cid:96)
→

φ(i

) = tanh

Cpredhi + bpred

.

(3a)

→·

Scoring. Finally, we use an inner product to
score ﬁrst-order structures:

(cid:0)

(cid:1)

2For clarity, we present single-layer BiLSTMs and MLPs,

while in practice we use two layers for both.

s(p) = φ(p)

ψ(p).

(5)

·

Figure 3 illustrates our basic model’s architecture.

3.3 Learning

The parameters of the model are learned using
a max-margin objective.
Informally, the goal is
to learn parameters for the score function so that
the gold parse is scored over every incorrect parse
with a margin proportional to the cost of the incor-
N
rect parse. More formally, let
i=1
be the training set consisting of N pairs of sen-
tence xi and its gold parse yi. Training is then the
following (cid:96)2-regularized empirical risk minimiza-
tion problem:

(xi, yi)

=

D

(cid:8)

(cid:9)

min
Θ

λ
2 (cid:107)

2 +
Θ
(cid:107)

1
N

N

L

xi, yi; Θ

,

(6)

i=1
(cid:88)

(cid:0)

(cid:1)

where Θ is all parameters in the model, and L is
the structured hinge loss:

(7)

L

xi, yi; Θ

= max
y∈Y(xi)

S

xi, y

+ c

y, yi

(cid:0)

(cid:1)

(cid:0)

(cid:8)

S

(cid:0)
.

(cid:1)(cid:9)

(cid:1)
xi, yi

(cid:0)
−
c is a weighted Hamming distance that trades off
between precision and recall (Taskar et al., 2004).
Following Martins and Almeida (2014), we en-
courage recall over precision by using the costs
0.6 for false negative arc predictions and 0.4 for
false positives.

(cid:1)

3.4 Experiments

We evaluate our basic model on the English
dataset from SemEval 2015 Task 18 closed track.3
We split as in previous work (Almeida and Mar-
tins, 2015; Du et al., 2015), resulting in 33,964
00–19 of the WSJ cor-
training sentences from
§
pus, 1,692 development sentences from
20, 1,410
§
sentences from
21 as in-domain test data, and
1,849 sentences sampled from the Brown Corpus
as out-of-domain test data.

§

The closed track differs from the open and gold
tracks in that it does not allow access to any
syntactic analyses.
In the open track, additional
machine generated syntactic parses are provided,
while the gold-track gives access to various gold-
standard syntactic analyses. Our model is evalu-
ated with closed track data; it does not have access
to any syntactic analyses during training or test.

We refer the readers to

4.4 for implementa-
§
tion details, including training procedures, hyper-
parameters, pruning techniques, etc..

3http://sdp.delph-in.net
4Paired bootstrap, p < 0.05 after Bonferroni correction.

Model

DM PAS PSD Avg.

id

ood

Du et al., 2015
A&M, 2015
BASIC

Du et al., 2015
A&M, 2015
BASIC

89.1
88.2
89.4

81.8
81.8
84.5

91.3
90.9
92.2

87.2
86.9
88.3

75.7
76.4
77.6

73.3
74.8
75.3

86.3
86.0
87.4

81.7
82.0
83.6

Table 2: Labeled parsing performance (F1 score)
on both in-domain (id) and out-of-domain (ood)
test data. The last column shows the micro-
average over the three tasks. Bold font indicates
best performance without syntax. Underlines indi-
cate statistical signiﬁcance with Bonferroni (1936)
correction compared to the best baseline system.4

Empirical results. As our model uses no ex-
plicit syntactic information, the most comparable
models to ours are two state-of-the-art closed track
systems due to Du et al. (2015) and Almeida and
Martins (2015). Du et al. (2015) rely on graph-
tree transformation techniques proposed by Du
et al. (2014), and apply a voting ensemble to well-
studied tree-oriented parsers. Closely related to
ours is Almeida and Martins (2015), who used
rich, hand-engineered second-order features and
AD3 for inference.

Table 2 compares our basic model to both base-
line systems (labeled F1 score) on SemEval 2015
Task 18 test data. Scores of those systems are re-
peated from the ofﬁcial evaluation results. Our ba-
sic model signiﬁcantly outperforms the best pub-
lished results with a 1.1% absolute improvement
on the in-domain test set and 1.6% on the out-of-
domain test set.

4 Multitask SDP

We introduce two extensions to our single-task
model, both of which use training data for all
three formalisms to improve performance on each
formalism’s parsing task. We describe a ﬁrst-
order model, where representation functions are
enhanced by parameter sharing while inference
is kept separate for each task (
4.2). We then
§
introduce a model with cross-task higher-order
structures that uses joint inference across different
4.3). Both multitask models use AD3 for
tasks (
§
decoding, and are trained with the same margin-
based objective, as in our single-task model.

4.1 Problem Formulation

{

=

∈ T

We will use an additional superscript t
to
distinguish the three tasks (e.g., y(t), φ(t)), where
. Our task is now to pre-
DM, PAS, PSD
}
T
y(t)
t∈T for a given input sen-
dict three graphs
}
tence x. Multitask SDP can also be understood
as parsing x into a single uniﬁed multigraph y =
t∈T y(t). Similarly to Equations 1–2, we decom-
pose y’s score S(x, y) into a sum of local scores
(cid:83)
for local structures in y, and we seek a multigraph
ˆy that maximizes S(x, y).

{

4.2 Multitask SDP with Parameter Sharing

A common approach when using BiLSTMs for
multitask learning is to share the BiLSTM part of
the model across tasks, while training specialized
classiﬁers for each task (Søgaard and Goldberg,
2016). In this spirit, we let each task keep its own
specialized MLPs, and explore two variants of our
model that share parameters at the BiLSTM level.
The ﬁrst variant consists of a set of task-speciﬁc
BiLSTM encoders as well as a common one that
is shared across all tasks. We denote it FREDA.
FREDA uses a neural generalization of “frustrat-
ingly easy” domain adaptation (Daum´e III, 2007;
Kim et al., 2016), where one augments domain-
speciﬁc features with a shared set of features to
capture global patterns. Formally, let
t∈T
denote the three task-speciﬁc encoders. We intro-
duce another encoder
h that is shared across all
tasks. Then a new set of input functions
t∈T
(cid:101)
can be deﬁned as in Equations 3a–3c, for example:

φ(t)

h(t)

{

{

}

}

φ(t)(i

(cid:96)
→

j) = tanh

C

(t)
LA

h

(t)
i

; h

(t)
j ;

(8)

(cid:0)

hi;
(cid:2)

hj

+ b

(t)
LA

.

(cid:101)

(cid:3)
(cid:1)
The predicate and unlabeled arc versions are anal-
remain
ogous. The output representations
task-speciﬁc, and the score is still the inner prod-
uct between the input representation and the out-
put representation.

ψ(t)
{

(cid:101)

}

The second variant, which we call SHARED,
uses only the shared encoder
h, and doesn’t use
h(t)
task-speciﬁc encoders
. It can be understood
as a special case of FREDA where the dimensions
of the task-speciﬁc encoders are 0.

(cid:101)

}

{

4.3 Multitask SDP with Cross-Task

Structures

In syntactic parsing, higher-order structures have
commonly been used to model interactions be-

tween multiple adjacent arcs in the same depen-
dency tree (Carreras, 2007; Smith and Eisner,
2008; Martins et al., 2009; Zhang et al., 2014,
inter alia). Llu´ıs et al. (2013), in contrast, used
second-order structures to jointly model syntactic
dependencies and semantic roles. Similarly, we
use higher-order structures across tasks instead of
within tasks.
In this work, we look at interac-
tions between arcs that share the same head and
modiﬁer.5 See Figures 2b and 2c for examples of
higher-order cross-task structures.

Higher-order structure scoring. Borrowing
from Lei et al. (2014), we introduce a low-rank
tensor scoring strategy that, given a higher-order
structure p, models interactions between the ﬁrst-
order structures (i.e., arcs) p is made up of. This
approach builds on and extends the parameter
sharing techniques in
It can either follow
4.2.
FREDA or SHARED to get the input representations
for ﬁrst-order structures.

§

We ﬁrst introduce basic tensor notation. The or-
der of a tensor is the number of its dimensions.
The outer product of two vectors forms a second-
order tensor (matrix) where [u
v]i,j = uivj. We
denote the inner product of two tensors of the
same dimensions by
, which ﬁrst takes their
·(cid:105)
element-wise product, then sums all the elements
in the resulting tensor.

,
(cid:104)·

⊗

p(t)

For example, let p be a labeled third-order struc-
ture, including one labeled arc from each of the
t∈T . Intuitively,
three different tasks: p =
s(p) should capture every pairwise interaction be-
tween the three input and three output representa-
tions of p. Formally, we want the score function
to include a parameter for each term in the outer
product of the representation vectors: s(p) =

{

}

W,

(cid:42)

φ(t)

p(t)

ψ(t)

p(t)

,

(9)

t∈T (cid:16)
(cid:79)

(cid:17)
where W is a sixth-order tensor of parameters.6

(cid:17)(cid:17)

(cid:16)

(cid:16)

(cid:43)

⊗

With typical dimensions of representation vec-
tors, this leads to an unreasonably large number of

5In the future we hope to model structures over larger mo-
tifs, both across and within tasks, to potentially capture when
an arc in one formalism corresponds to a path in another for-
malism, for example.

6This is, of course, not the only way to model interactions
between several representations. For instance, one could con-
catenate them and feed them into another MLP. Our prelim-
inary experiments in this direction suggested that it may be
less effective given a similar number of parameters, but we
did not run full experiments.

parameters. Following Lei et al. (2014), we upper-
bound the rank of W by r to limit the number of
parameters (r is a hyperparameter, decided empir-
ically). Using the fact that a tensor of rank at most
r can be decomposed into a sum of r rank-1 ten-
sors (Hitchcock, 1927), we reparameterize W to
enforce the low-rank constraint by construction:

r

W =

U

(t)
LA

V

(t)
LA

,
(cid:19)

j,:
(cid:105)

j,: ⊗
(cid:105)

(cid:104)

(10)

t∈T (cid:18)(cid:104)
j=1
(cid:79)
(cid:88)
(t)
(t)
LA, V
LA ∈

Rr×d are now our parame-
where U
]j,: denotes the jth row of a matrix. Substi-
ters. [
·
tuting this back into Equation 9 and rearranging,
the score function s(p) can then be rewritten as:

r

j=1
(cid:88)

t∈T (cid:104)
(cid:89)

U

(t)
LAφ(t)

p(t)

V

(t)
LAψ(t)

p(t)

j

(cid:17)(cid:105)

(cid:104)

(cid:16)

.

j

(cid:16)

(cid:17)(cid:105)

(11)
We refer readers to Kolda and Bader (2009) for
mathematical details.

For labeled higher-order structures our parame-

V

U
{

(t)
LA}

ters consist of the set of six matrices,

(t)
LA} ∪
. These parameters are shared between
{
second-order and third-order labeled structures.
Labeled second-order structures are scored as
Equation 11, but with the product extending over
only the two relevant tasks. Concretely, only four
of the representation functions are used rather than
all six, along with the four corresponding ma-
. Unlabeled cross-
trices from
V
task structures are scored analogously, reusing the
same representations, but with a separate set of pa-
rameter matrices

(t)
UA} ∪ {
Note that we are not doing tensor factorization;
(t)
(t)
(t)
we are learning U
UA di-
LA, U
LA, V
rectly, and W is never explicitly instantiated.

(t)
.
UA}
(t)
UA, and V

(t)
LA} ∪ {

(t)
LA}

U
{

U

V

{

Inference and learning. Given a sentence, we
use AD3 to jointly decode all three formalisms.7
The training objective used for learning is the sum
of the losses for individual tasks.

4.4

Implementation Details

Each input token is mapped to a concatenation of
three real vectors: a pre-trained word vector; a
randomly-initialized word vector; and a randomly-
initialized POS tag vector.8 All three are updated

7Joint inference comes at a cost; our third-order model is
able to decode roughly 5.2 sentences (i.e., 15.5 task-speciﬁc
graphs) per second on a single Xeon E5-2690 2.60GHz CPU.
8There are minor differences in the part-of-speech data
provided with the three formalisms. For the basic models, we

Hyperparameter

Pre-trained word embedding dimension
Randomly-initialized word embedding dimension
POS tag embedding dimension
Dimensions of representations φ and ψ
MLP layers
BiLSTM layers
BiLSTM dimensions
Rank of tensor r
α for word dropout

Value

100
25
25
100
2
2
200
100
0.25

Table 3: Hyperparameters used in the experi-
ments.

during training. We use 100-dimensional GloVe
(Pennington et al., 2014) vectors trained over
Wikipedia and Gigaword as pre-trained word em-
beddings. To deal with out-of-vocabulary words,
we apply word dropout (Iyyer et al., 2015) and
randomly replace a word w with a special unk-
symbol with probability
1+#(w) , where #(w) is
the count of w in the training set.

α

Models are trained for up to 30 epochs with
Adam (Kingma and Ba, 2015), with β1 = β2 =
0.9, and initial learning rate η0 = 10−3. The
learning rate η is annealed at a rate of 0.5 ev-
ery 10 epochs (Dozat and Manning, 2017). We
apply early-stopping based on the labeled F1
score on the development set.9 We set
the
maximum number of iterations of AD3 to 500
and round decisions when it doesn’t converge.
We clip the (cid:96)2 norm of gradients to 1 (Graves,
2013; Sutskever et al., 2014), and we do not
use mini-batches. Randomly initialized parame-
ters are sampled from a uniform distribution over
, where dr and
−
dc are the number of the rows and columns in the
(cid:2)
matrix, respectively. An (cid:96)2 penalty of λ = 10−6 is
applied to all weights. Other hyperparameters are
summarized in Table 3.

6/(dr + dc),

6/(dr + dc)

(cid:112)

(cid:112)

(cid:3)

We use the same pruner as Martins and Almeida
(2014), where a ﬁrst-order feature-rich unlabeled
pruning model is trained for each task, and arcs
with posterior probability below 10−4 are dis-
carded. We further prune labeled structures that
appear less than 30 times in the training set.
In
the development set, about 10% of the arcs remain
after pruning, with a recall of around 99%.

use the POS tags provided with the respective dataset; for the
multitask models, we use the (automatic) POS tags provided
with DM.

9Micro-averaged labeled F1 for the multitask models.

4.5 Experiments

Experimental settings. We compare four multi-
task variants to the basic model, as well as the two
baseline systems introduced in

3.4.
§

•

•

•

•

SHARED1 is a ﬁrst-order model. It uses a sin-
gle shared BiLSTM encoder, and keeps the
inference separate for each task.
FREDA1 is a ﬁrst-order model based on “frus-
tratingly easy” parameter sharing. It uses a
shared encoder as well as task-speciﬁc ones.
The inference is kept separate for each task.
SHARED3 is a third-order model. It follows
SHARED1 and uses a single shared BiLSTM
encoder, but additionally employs cross-task
structures and inference.
FREDA3 is also a third-order model. It com-
bines FREDA1 and SHARED3 by using both
“frustratingly easy” parameter sharing and
cross-task structures and inference.

In addition, we also examine the effects of syn-
tax by comparing our models to the state-of-the-art
open track system (Almeida and Martins, 2015).10

Main results overview. Table 4a compares our
models to the best published results (labeled F1
score) on SemEval 2015 Task 18 in-domain test
set. Our basic model improves over all closed
track entries in all formalisms. It is even with the
best open track system for DM and PSD, but im-
proves on PAS and on average, without making
use of any syntax. Three of our four multitask
variants further improve over our basic model;
SHARED1’s differences are statistically insigniﬁ-
cant. Our best models (SHARED3, FREDA3) out-
perform the previous state-of-the-art closed track
system by 1.7% absolute F1, and the best open
track system by 0.9%, without the use of syntax.

We observe similar trends on the out-of-domain
test set (Table 4b), with the exception that, on
PSD, our best-performing model’s improvement
over the open-track system of Almeida and Mar-
tins (2015) is not statistically signiﬁcant.

The extent to which we might beneﬁt from syn-
tactic information remains unclear. With auto-
matically generated syntactic parses, Almeida and
Martins (2015) manage to obtain more than 1%
absolute improvements over their closed track en-

10Kanerva et al. (2015) was the winner of the gold track,
which overall saw higher performance than the closed and
open tracks. Since gold-standard syntactic analyses are not
available in most realistic scenarios, we do not include it in
this comparison.

(a) Labeled F1 score on the in-domain test set.

Du et al., 2015
A&M, 2015 (closed)
A&M, 2015 (open)†
BASIC

SHARED1
FREDA1

SHARED3
FREDA3

Du et al., 2015
A&M, 2015 (closed)
A&M, 2015 (open)†
BASIC

SHARED1
FREDA1

SHARED3
FREDA3

DM PAS PSD Avg.

89.1
88.2
89.4
89.4

89.7
90.0

90.3
90.4

81.8
81.8
83.8
84.5

84.4
84.9

85.3
85.3

91.3
90.9
91.7
92.2

91.9
92.3

92.5
92.7

87.2
86.9
87.6
88.3

88.1
88.3

88.4
89.0

75.7
76.4
77.6
77.6

77.8
78.1

78.5
78.5

73.3
74.8
76.2
75.3

75.4
75.8

76.1
76.4

86.3
86.0
87.1
87.4

87.4
87.7

88.0
88.0

81.7
82.0
83.3
83.6

83.5
83.9

84.1
84.4

DM PAS PSD Avg.

(b) Labeled F1 score on the out-of-domain test set.

†

Table 4: The last columns show the micro-average
denotes the use of syntac-
over the three tasks.
tic parses. Bold font indicates best performance
among all systems, and underlines indicate statis-
tical signiﬁcance with Bonferroni correction com-
pared to A&M, 2015 (open), the strongest baseline
system.

try, which is consistent with the extensive evalua-
tion by Zhang et al. (2016), but we leave the incor-
poration of syntactic trees to future work. Syntac-
tic parsing could be treated as yet another output
task, as explored in Llu´ıs et al. (2013) and in the
transition-based frameworks of Henderson et al.
(2013) and Swayamdipta et al. (2016).

Effects of structural overlap. We hypothesized
that the overlap between formalisms would enable
multitask learning to be effective; in this section
we investigate in more detail how structural over-
lap affected performance. By looking at undi-
rected overlap between unlabeled arcs, we dis-
cover that modeling only arcs in the same direc-
tion may have been a design mistake.

DM and PAS are more structurally similar to
each other than either is to PSD. Table 5 compares
the structural similarities between the three for-

Undirected

Directed

DM PAS

PSD

DM PAS

PSD

DM
-
PAS
70.0
PSD 57.4

67.2
-
56.3

56.8
54.9
-

-
66.9
26.4

64.2
-
29.6

26.1
26.1
-

Table 5: Pairwise structural similarities between
the three formalisms in unlabeled F1 score. Scores
from Oepen et al. (2015).

DM

PAS

PSD

UF

91.7
91.9

LF

90.4
90.8

UF

93.1
93.4

LF

91.6
92.0

UF

89.0
88.6

LF

79.8
80.4

FREDA1
FREDA3

Table 6: Unlabeled (UF ) and labeled (LF ) pars-
ing performance of FREDA1 and FREDA3 on the
development set of SemEval 2015 Task 18.

malisms in unlabeled F1 score (each formalism’s
gold-standard unlabeled graph is used as a predic-
tion of each other formalism’s gold-standard un-
labeled graph). All three formalisms have more
than 50% overlap when ignoring arcs’ directions,
but considering direction, PSD is clearly different;
PSD reverses the direction about half of the time
it shares an edge with another formalism. A con-
crete example can be found in Figure 1, where DM
and PAS both have an arc from “Last” to “week,”
while PSD has an arc from “week” to “Last.”

We can compare FREDA3 to FREDA1 to isolate
the effect of modeling higher-order structures. Ta-
ble 6 shows performance on the development data
in both unlabeled and labeled F1. We can see
that FREDA3’s unlabeled performance improves
on DM and PAS, but degrades on PSD. This sup-
ports our hypothesis, and suggests that in future
work, a more careful selection of structures to
model might lead to further improvements.

5 Related Work

We note two important strands of related work.

Graph-based parsing. Graph-based parsing
was originally invented to handle non-projective
syntax (McDonald et al., 2005; Koo et al., 2010;
inter alia), but has been
Martins et al., 2013,
adapted to semantic parsing (Flanigan et al.,
2014; Martins and Almeida, 2014; Thomson
et al., 2014; Kuhlmann, 2014, inter alia). Local
structure scoring was traditionally done with
linear models over hand-engineered features, but
lately, various forms of representation learning

have been explored to learn feature combinations
(Lei et al., 2014; Taub-Tabib et al., 2015; Pei et al.,
2015, inter alia). Our work is perhaps closest
to those who used BiLSTMs to encode inputs
(Kiperwasser and Goldberg, 2016; Kuncoro
et al., 2016; Wang and Chang, 2016; Dozat and
Manning, 2017; Ma and Hovy, 2016).

Multitask learning in NLP. There have been
many efforts in NLP to use joint learning to re-
place pipelines, motivated by concerns about cas-
cading errors. Collobert and Weston (2008) pro-
posed sharing the same word representation while
solving multiple NLP tasks. Zhang and Weiss
(2016) use a continuous stacking model for POS
tagging and parsing. Ammar et al. (2016) and Guo
et al. (2016) explored parameter sharing for multi-
lingual parsing. Johansson (2013) and Kshirsagar
et al. (2015) applied ideas from domain adapta-
tion to multitask learning. Successes in multitask
learning have been enabled by advances in repre-
sentation learning as well as earlier explorations of
parameter sharing (Ando and Zhang, 2005; Blitzer
et al., 2006; Daum´e III, 2007).

6 Conclusion

We showed two orthogonal ways to apply deep
multitask learning to graph-based parsing. The
ﬁrst shares parameters when encoding tokens in
the input with recurrent neural networks, and
the second introduces interactions between out-
put structures across formalisms. Without using
syntactic parsing,
these approaches outperform
even state-of-the-art semantic dependency pars-
ing systems that use syntax. Because our tech-
niques apply to labeled directed graphs in gen-
eral, they can easily be extended to incorporate
more formalisms, semantic or otherwise.
In fu-
ture work we hope to explore cross-task scor-
ing and inference for tasks where parallel an-
notations are not available. Our code is open-
source and available at https://github.
com/Noahs-ARK/NeurboParser.

Acknowledgements

We thank the Ark, Maxwell Forbes, Luheng He,
Kenton Lee, Julian Michael, and Jin-ge Yao for
their helpful comments on an earlier version of this
draft, and the anonymous reviewers for their valu-
able feedback. This work was supported by NSF
grant IIS-1562364 and DARPA grant FA8750-12-
2-0342 funded under the DEFT program.

References

Mariana S. C. Almeida and Andr´e F. T. Martins. 2015.
Lisbon: Evaluating TurboSemanticParser on multi-
ple languages and out-of-domain data. In Proc. of
SemEval.

Waleed Ammar, George Mulcaire, Miguel Ballesteros,
Chris Dyer, and Noah Smith. 2016. Many lan-
guages, one parser. TACL 4:431–444.

Rie Kubota Ando and Tong Zhang. 2005. A framework
for learning predictive structures from multiple tasks
and unlabeled data. JMLR 6:1817–1853.

Collin Baker, Michael Ellsworth, and Katrin Erk. 2007.
SemEval’07 task 19: Frame semantic structure ex-
traction. In Proc. of SemEval.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Grifﬁtt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract meaning representation
for sembanking. In Proc. of LAW VII & ID.

Yoshua Bengio, R`ejean Ducharme, Pascal Vincent, and
Christian Janvin. 2003. A neural probabilistic lan-
guage model. JMLR 3:1137–1155.

John Blitzer, Ryan McDonald, and Fernando Pereira.
2006. Domain adaptation with structural correspon-
dence learning. In Proc. of EMNLP.

Carlo E. Bonferroni. 1936. Teoria statistica delle classi
e calcolo delle probabilit`a. Pubblicazioni del R. Is-
tituto Superiore di Scienze Economiche e Commer-
ciali di Firenze 8:3–62.

Xavier Carreras. 2007. Experiments with a higher-
In Proc. of

order projective dependency parser.
CoNLL.

Rich Caruana. 1997. Multitask learning. Machine

Learning 28(1):41–75.

Kyunghyun Cho. 2015.
derstanding with
ArXiv:1511.07916.

Natural

distributed

language un-
representation.

Ronan Collobert and Jason Weston. 2008. A uniﬁed
architecture for natural language processing: Deep
neural networks with multitask learning. In Proc. of
ICML.

Ann Copestake and Dan Flickinger. 2000.

An
open source grammar development environment and
broad-coverage English grammar using HPSG.
In
Proc. of LREC.

Ann Copestake, Dan Flickinger, Ivan A. Sag, and Carl
Pollard. 2005. Minimal recursion semantics: An in-
troduction. Research on Language & Computation
3(4):281–332.

Hal Daum´e III. 2007. Frustratingly easy domain adap-

tation. In Proc. of ACL.

Marie-Catherine de Marneffe, Timothy Dozat, Na-
talia Silveira, Katri Haverinen, Filip Ginter, Joakim
Nivre, and Christopher D. Manning. 2014. Univer-
sal Stanford dependencies: A cross-linguistic typol-
ogy. In Proc. of LREC.

Timothy Dozat and Christopher D. Manning. 2017.
Deep biafﬁne attention for neural dependency pars-
ing. In Proc. of ICLR.

Yantao Du, Fan Zhang, Weiwei Sun, and Xiaojun Wan.
2014. Peking: Proﬁling syntactic tree parsing tech-
niques for semantic graph parsing. In Proc. of Se-
mEval.

Yantao Du, Fan Zhang, Xun Zhang, Weiwei Sun, and
Xiaojun Wan. 2015. Peking: Building semantic de-
In Proc. of
pendency graphs with a hybrid parser.
SemEval.

Nicholas FitzGerald, Oscar T¨ackstr¨om, Kuzman
Ganchev, and Dipanjan Das. 2015. Semantic role
In Proc. of
labeling with neural network factors.
EMNLP.

Jeffrey Flanigan, Sam Thomson, Jaime Carbonell,
Chris Dyer, and Noah A. Smith. 2014. A discrim-
inative graph-based parser for the abstract meaning
representation. In Proc. of ACL.

Daniel Flickinger, Yi Zhang, and Valia Kordoni. 2012.
DeepBank: A dynamically annotated treebank of the
Wall Street Journal. In Proc. of TLT.

Daniel Gildea and Daniel Jurafsky. 2002. Automatic
labeling of semantic roles. Computational Linguis-
tics 28(3):245–288.

Alex Graves. 2012. Supervised Sequence Labelling
with Recurrent Neural Networks, volume 385 of
Studies in Computational Intelligence. Springer.

Alex Graves. 2013. Generating sequences with recur-

rent neural networks. ArXiv 1308.0850.

Jiang Guo, Wanxiang Che, Haifeng Wang, and Ting
Liu. 2016. A universal framework for inductive
transfer parsing across multi-typed treebanks.
In
Proc. of COLING.

Jan Hajiˇc, Eva Hajiˇcov´a, Jarmila Panevov´a, Petr
Sgall, Ondˇrej Bojar, Silvie Cinkov´a, Eva Fuˇc´ıkov´a,
Marie Mikulov´a, Petr Pajas, Jan Popelka, Jiˇr´ı
Semeck´y, Jana ˇSindlerov´a, Jan ˇStˇep´anek, Josef
Toman, Zdeˇnka Ureˇsov´a, and Zdenˇek ˇZabokrtsk´y.
2012. Announcing Prague Czech-English depen-
dency treebank 2.0. In Proc. LREC.

James Henderson, Paola Merlo,

Ivan Titov, and
Gabriele Musillo. 2013. Multi-lingual joint pars-
ing of syntactic and semantic dependencies with a
latent variable model. Computational Linguistics
39(4):949–998.

Karl Moritz Hermann, Dipanjan Das, Jason Weston,
and Kuzman Ganchev. 2014. Semantic frame iden-
tiﬁcation with distributed word representations. In
Proc. of ACL.

Frank L. Hitchcock. 1927. The expression of a tensor
or a polyadic as a sum of products. Journal of Math-
ematical Physics 6(1):164–189.

Sepp Hochreiter and J¨urgen Schmidhuber. 1997.
Long Short-Term Memory. Neural Computation
9(8):1735–1780.

Mohit Iyyer, Varun Manjunatha, Jordan Boyd-Graber,
and Hal Daum´e III. 2015. Deep unordered compo-
sition rivals syntactic methods for text classiﬁcation.
In Proc. of ACL.

Richard Johansson. 2013. Training parsers on incom-

patible treebanks. In Proc. of NAACL.

Jenna Kanerva, Juhani Luotolahti, and Filip Ginter.
2015. Turku: Semantic dependency parsing as a se-
quence classiﬁcation. In Proc. of SemEval.

Young-Bum Kim, Karl Stratos, and Ruhi Sarikaya.
2016. Frustratingly easy neural domain adaptation.
In Proc. of COLING.

Tao Lei, Yu Xin, Yuan Zhang, Regina Barzilay, and
Tommi Jaakkola. 2014. Low-rank tensors for scor-
ing dependency structures. In Proc. of ACL.

Xavier Llu´ıs, Xavier Carreras, and Llu´ıs M`arquez.
2013. Joint arc-factored parsing of syntactic and se-
mantic dependencies. TACL 1:219–230.

Xuezhe Ma and Eduard Hovy. 2016. Neural prob-
abilistic model for non-projective MST parsing.
ArXiv 1701.00874.

Andr´e F. T. Martins and Mariana S. C. Almeida. 2014.
Priberam: A turbo semantic parser with second or-
der features. In Proc. of SemEval.

Andr´e F. T. Martins, Miguel B. Almeida, and Noah A.
Smith. 2013. Turning on the turbo: Fast third-order
non-projective turbo parsers. In Proc. of ACL.

Andr´e F. T. Martins, Noah Smith, and Eric Xing. 2009.
Concise integer linear programming formulations
for dependency parsing. In Proc. of ACL.

Andr´e F. T. Martins, Noah A. Smith, Pedro M. Q.
Aguiar, and M´ario A. T. Figueiredo. 2011. Dual de-
composition with many overlapping components. In
Proc. of EMNLP.

Diederik P. Kingma and Jimmy Ba. 2015. Adam:
In Proc. of

A method for stochastic optimization.
ICLR.

Ryan McDonald, Koby Crammer, and Fernando
Pereira. 2005. Online large-margin training of de-
pendency parsers. In Proc. of ACL.

Eliyahu Kiperwasser and Yoav Goldberg. 2016. Sim-
ple and accurate dependency parsing using bidirec-
tional LSTM feature representations. TACL 4:313–
327.

Tamara G. Kolda and Brett W. Bader. 2009. Ten-
sor decompositions and applications. SIAM Review
51(3):455–500.

Terry Koo, Alexander M. Rush, Michael Collins,
Tommi Jaakkola, and David Sontag. 2010. Dual
decomposition for parsing with non-projective head
automata. In Proc. of EMNLP.

Meghana Kshirsagar, Sam Thomson, Nathan Schnei-
der, Jaime Carbonell, Noah A. Smith, and Chris
Dyer. 2015. Frame-semantic role labeling with het-
erogeneous annotations. In Proc. of ACL.

Marco Kuhlmann. 2014. Link¨oping: Cubic-time graph
parsing with a simple scoring scheme. In Proc. of
SemEval.

Adhiguna Kuncoro, Miguel Ballesteros, Lingpeng
Kong, Chris Dyer, and Noah A. Smith. 2016. Dis-
tilling an ensemble of greedy dependency parsers
into one MST parser. In Proc. of EMNLP.

Tom Kwiatkowski, Eunsol Choi, Yoav Artzi, and
Luke S. Zettlemoyer. 2013.
Scaling semantic
parsers with on-the-ﬂy ontology matching. In Proc.
of EMNLP.

Yusuke Miyao. 2006. From linguistic theory to syntac-
tic analysis: Corpus-oriented grammar development
and feature forest model.

Andriy Mnih and Geoffrey Hinton. 2007. Three new
graphical models for statistical language modelling.
In Proc. of ICML.

Stephan Oepen, Marco Kuhlmann, Yusuke Miyao,
Daniel Zeman, Silvie Cinkov´a, Dan Flickinger, Jan
Hajiˇc, and Zdeˇnka Ureˇsov´a. 2015. SemEval 2015
task 18: Broad-coverage semantic dependency pars-
ing. In Proc. of SemEval.

Stephan Oepen, Marco Kuhlmann, Yusuke Miyao,
Daniel Zeman, Dan Flickinger, Jan Hajiˇc, Angelina
Ivanova, and Yi Zhang. 2014. SemEval 2014 task
8: Broad-coverage semantic dependency parsing. In
Proc. of SemEval.

Martha Palmer, Daniel Gildea, and Paul Kingsbury.
2005. The proposition bank: An annotated cor-
pus of semantic roles. Computational Linguistics
31(1):71–106.

Wenzhe Pei, Tao Ge, and Baobao Chang. 2015. An
effective neural network model for graph-based de-
pendency parsing. In Proc. of ACL.

Jeffrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. GloVe: Global vectors for
word representation. In Proc. of EMNLP.

Carl Pollard and Ivan A. Sag. 1994. Head-Driven
The University of

Phrase Structure Grammar.
Chicago Press.

Yuan Zhang and David Weiss. 2016.

Stack-
propagation: Improved representation learning for
syntax. In Proc. of ACL.

Mike Schuster and Kuldip K. Paliwal. 1997. Bidirec-
tional recurrent neural networks. IEEE Transactions
on Signal Processing 45(11):2673–2681.

David Smith and Jason Eisner. 2008. Dependency
parsing by belief propagation. In Proc. of EMNLP.

Anders Søgaard and Yoav Goldberg. 2016. Deep
multi-task learning with low level tasks supervised
at lower layers. In Proc. of ACL.

Vivek Srikumar and Christopher D Manning. 2014.
Learning distributed representations for structured
output prediction. In Proc. of NIPS.

Mihai Surdeanu, Richard Johansson, Adam Meyers,
Llu´ıs M`arquez, and Joakim Nivre. 2008.
The
CoNLL-2008 shared task on joint parsing of syntac-
tic and semantic dependencies. In Proc. of CoNLL.

Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. 2014.
Sequence to sequence learning with neural net-
works. In Proc. of NIPS.

Swabha Swayamdipta, Miguel Ballesteros, Chris Dyer,
and Noah A. Smith. 2016. Greedy, joint syntactic-
In Proc. of
semantic parsing with stack LSTMs.
CoNLL.

Ben Taskar, Carlos Guestrin, and Daphne Koller. 2004.
Max-margin Markov networks. In Advances in Neu-
ral Information Processing Systems 16.

Hillel Taub-Tabib, Yoav Goldberg, and Amir Glober-
son. 2015. Template kernels for dependency pars-
ing. In Proc. of NAACL.

Sam Thomson, Brendan O’Connor, Jeffrey Flani-
gan, David Bamman,
Jesse Dodge, Swabha
Swayamdipta, Nathan Schneider, Chris Dyer, and
Noah A. Smith. 2014. CMU: Arc-factored, discrim-
inative semantic dependency parsing. In Proc. of Se-
mEval.

Wenhui Wang and Baobao Chang. 2016. Graph-based
dependency parsing with bidirectional LSTM.
In
Proc. of ACL.

Naiwen Xue, Fei Xia, Fu-dong Chiou, and Martha
Palmer. 2005. The Penn Chinese TreeBank: Phrase
structure annotation of a large corpus. Natural Lan-
guage Engineering 11(2):207–238.

Xun Zhang, Yantao Du, Weiwei Sun, and Xiaojun
Wan. 2016. Transition-based parsing for deep de-
Computational Linguistics
pendency structures.
42(3):353–389.

Yuan Zhang, Tao Lei, Regina Barzilay, and Tommi S.
Jaakkola. 2014. Greed is good if randomized:
New inference for dependency parsing. In Proc. of
EMNLP.

Deep Multitask Learning for Semantic Dependency Parsing

Hao Peng∗

Sam Thomson† Noah A. Smith∗

∗Paul G. Allen School of Computer Science & Engineering, University of Washington, Seattle, WA, USA
†School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA
@cs.washington.edu, sthomson@cs.cmu.edu
hapeng,nasmith
}

{

7
1
0
2
 
r
p
A
 
5
2
 
 
]
L
C
.
s
c
[
 
 
2
v
5
5
8
6
0
.
4
0
7
1
:
v
i
X
r
a

Abstract

We present a deep neural architecture that
parses sentences into three semantic de-
pendency graph formalisms. By using ef-
ﬁcient, nearly arc-factored inference and
a bidirectional-LSTM composed with a
multi-layer perceptron, our base system is
able to signiﬁcantly improve the state of
the art for semantic dependency parsing,
without using hand-engineered features or
syntax. We then explore two multitask
learning approaches—one that shares pa-
rameters across formalisms, and one that
uses higher-order structures to predict the
graphs jointly. We ﬁnd that both ap-
proaches improve performance across for-
malisms on average, achieving a new state
of the art. Our code is open-source and
available at https://github.com/
Noahs-ARK/NeurboParser.

1

Introduction

Labeled directed graphs are a natural and ﬂexi-
ble representation for semantics (Copestake et al.,
2005; Baker et al., 2007; Surdeanu et al., 2008;
Banarescu et al., 2013, inter alia). Their generality
over trees, for instance, allows them to represent
relational semantics while handling phenomena
like coreference and coordination. Even syntactic
formalisms are moving toward graphs (de Marn-
effe et al., 2014). However, full semantic graphs
can be expensive to annotate, and efforts are frag-
mented across competing semantic theories, lead-
ing to a limited number of annotations in any one
formalism. This makes learning to parse more dif-
ﬁcult, especially for powerful but data-hungry ma-
chine learning techniques like neural networks.

In this work, we hypothesize that the overlap
among theories and their corresponding represen-

(a) DM

(b) PAS

(c) PSD

Figure 1: An example sentence annotated with the
three semantic formalisms of the broad-coverage
semantic dependency parsing shared tasks.

tations can be exploited using multitask learn-
ing (Caruana, 1997), allowing us to learn from
more data. We use the 2015 SemEval shared task
on Broad-Coverage Semantic Dependency Pars-
ing (SDP; Oepen et al., 2015) as our testbed.
The shared task provides an English-language cor-
pus with parallel annotations for three semantic
graph representations, described in
2. Though
§
the shared task was designed in part to encourage
comparison between the formalisms, we are the
ﬁrst to treat SDP as a multitask learning problem.
As a strong baseline, we introduce a new sys-
3).
tem that parses each formalism separately (
It uses a bidirectional-LSTM composed with a
multi-layer perceptron to score arcs and predi-
cates, and has efﬁcient, nearly arc-factored infer-
ence. Experiments show it signiﬁcantly improves
on state-of-the-art methods (
§

We then present two multitask extensions (

3.4).

§

4.2
§

DM

PAS

PSD

id

ood

id

ood

id

ood

# labels
% trees
% projective

59
2.3
2.9

47
9.7
8.8

42
1.2
1.6

41
2.4
3.5

74
91
42.2 51.4
41.9 54.4

Table 1: Graph statistics for in-domain (WSJ,
“id”) and out-of-domain (Brown corpus, “ood”)
data. Numbers taken from Oepen et al. (2015).

and
4.3), with a parameterization and factoriza-
§
tion that implicitly models the relationship be-
tween multiple formalisms. Experiments show
that both techniques improve over our basic
model, with an additional (but smaller) improve-
ment when they are combined (
4.5). Our analy-
§
sis shows that the improvement in unlabeled F1 is
greater for the two formalisms that are more struc-
turally similar, and suggests directions for future
work. Finally, we survey related work (
5), and
§
6).
summarize our contributions and ﬁndings (
§

2 Broad-Coverage Semantic Dependency

Parsing (SDP)

First deﬁned in a SemEval 2014 shared task
(Oepen et al., 2014), and then extended by Oepen
et al. (2015),
the broad-coverage semantic de-
pency parsing (SDP) task is centered around three
semantic formalisms whose annotations have been
converted into bilexical dependencies. See Fig-
ure 1 for an example. The formalisms come
from varied linguistic traditions, but all three aim
to capture predicate-argument relations between
content-bearing words in a sentence.

While at ﬁrst glance similar to syntactic de-
pendencies, semantic dependencies have distinct
goals and characteristics, more akin to semantic
role labeling (SRL; Gildea and Jurafsky, 2002) or
the abstract meaning representation (AMR; Ba-
narescu et al., 2013). They abstract over different
syntactic realizations of the same or similar mean-
ing (e.g., “She gave me the ball.” vs. “She gave
the ball to me.”). Conversely, they attempt to dis-
tinguish between different senses even when real-
ized in similar syntactic forms (e.g., “I baked in
the kitchen.” vs. “I baked in the sun.”).

Structurally, they are labeled directed graphs
whose vertices are tokens in the sentence. This
is in contrast to AMR whose vertices are ab-
stract concepts, with no explicit alignment to to-
kens, which makes parsing more difﬁcult (Flani-
gan et al., 2014). Their arc labels encode broadly-

applicable semantic relations rather than being tai-
lored to any speciﬁc downstream application or
ontology.1 They are not necessarily trees, because
a token may be an argument of more than one
predicate (e.g., in “John wants to eat,” John is
both the wanter and the would-be eater). Their
analyses may optionally leave out non–content-
bearing tokens, such as punctuation or the in-
ﬁnitival “to,” or prepositions that simply mark
the type of relation holding between other words.
But when restricted to content-bearing tokens (in-
cluding adjectives, adverbs, etc.), the subgraph
In this sense, SDP provides a
is connected.
whole-sentence analysis. This is in contrast to
PropBank-style SRL, which gives an analysis of
only verbal and nominal predicates (Palmer et al.,
2005). Semantic dependency graphs also tend to
have higher levels of nonprojectivity than syntac-
tic trees (Oepen et al., 2014). Sentences with
graphs containing cycles have been removed from
the dataset by the organizers, so all remaining
graphs are directed acyclic graphs. Table 1 sum-
marizes some of the dataset’s high-level statistics.

three formalisms.

Formalisms. Following the SemEval shared
tasks, we consider
The
DM (DELPH-IN MRS)
representation comes
from DeepBank (Flickinger et al., 2012), which
are manually-corrected parses from the LinGO
English Resource Grammar
(Copestake and
Flickinger, 2000). LinGO is a head-driven phrase
structure grammar (HPSG; Pollard and Sag, 1994)
with minimal
recursion semantics (Copestake
et al., 2005). The PAS (Predicate-Argument Struc-
tures) representation is extracted from the Enju
Treebank, which consists of automatic parses from
the Enju HPSG parser (Miyao, 2006). PAS an-
notations are also available for the Penn Chinese
Treebank (Xue et al., 2005). The PSD (Prague Se-
mantic Dependencies) representation is extracted
from the tectogrammatical layer of the Prague
Czech-English Dependency Treebank (Hajiˇc et al.,
2012). PSD annotations are also available for a
Czech translation of the WSJ Corpus. In this work,
we train and evaluate only on English annotations.
Of the three, PAS follows syntax most closely,
and prior work has found it the easiest to pre-
dict. PSD has the largest set of labels, and parsers

1This may make another disambiguation step necessary
to use these representations in a downstream task, but there
is evidence that modeling semantic composition separately
from grounding in any ontology is an effective way to achieve
broad coverage (Kwiatkowski et al., 2013).

(a) First-order.

(b) Second-order.

(c) Third-order.

Figure 2: Examples of local structures. We refer
to the number of arcs that a structure contains as
its order.

have signiﬁcantly lower performance on it (Oepen
et al., 2015).

3 Single-Task SDP

Here we introduce our basic model, in which train-
ing and prediction for each formalism is kept com-
pletely separate. We also lay out basic notation,
which will be reused for our multitask extensions.

3.1 Problem Formulation

The output of semantic dependency parsing is a
labeled directed graph (see Figure 1). Each arc
, indicating the
has a label from a predeﬁned set
semantic relation of the child to the head. Given
input sentence x, let
(x) be the set of possible
semantic graphs over x. The graph we seek maxi-
mizes a score function S:

L

Y

ˆy = arg max

S(x, y),

(1)

y∈Y(x)

We decompose S into a sum of local scores s for
local structures (or “parts”) p in the graph:

S(x, y) =

s(p).

(2)

p∈y
(cid:88)

For notational simplicity, we omit the dependence
of s on x. See Figure 2a for examples of local
structures. s is a parameterized function, whose
parameters (denoted Θ and suppressed here for
clarity) will be learned from the training data
(
3.3). Since we search over every possible la-
§
beled graph (i.e., considering each labeled arc for
each pair of words), our approach can be consid-
ered a graph-based (or all-pairs) method. The
models presented in this work all share this com-
mon graph-based approach, differing only in the
set of structures they score and in the parameter-
ization of the scoring function s. This approach
also underlies state-of-the-art approaches to SDP
(Martins and Almeida, 2014).

3.2 Basic Model

Our basic model is inspired by recent successes in
neural arc-factored graph-based dependency pars-
ing (Kiperwasser and Goldberg, 2016; Dozat and
Manning, 2017; Kuncoro et al., 2016). It borrows
heavily from the neural arc-scoring architectures
in those works, but decodes with a different algo-
rithm under slightly different constraints.

3.2.1 Basic Structures

Our basic model factors over three types of struc-
tures (p in Equation 2):

;

•

•

•

j;

→

→·

predicate, indicating a predicate word, de-
noted i
unlabeled arc, representing the existence of
an arc from a predicate to an argument, de-
noted i
labeled arc, an arc labeled with a semantic
role, denoted i

j.
Here i and j are word indices in a given sen-
tence, and (cid:96) indicates the arc label. This list corre-
sponds to the most basic structures used by Mar-
tins and Almeida (2014). Selecting an output y
corresponds precisely to selecting which instanti-
ations of these structures are included.

(cid:96)
→

To ensure the internal consistency of predic-
tions, the following constraints are enforced dur-
ing decoding:

if and only if there exists at least one j

•

•

j;

→

i
→·
such that i
If i
→
(cid:96)
such that i
→
there must not exist any i

j, then there must be exactly one label (cid:96)
j, then
j. Conversely, if not i

→

(cid:96)
→

j;

We also enforce a determinism constraint (Flani-
gan et al., 2014): certain labels must not appear on
more than one arc emanating from the same token.
The set of deterministic labels is decided based on
their appearance in the training set. Notably, we do
not enforce that the predicted graph is connected
or spanning. If not for the predicate and determin-
ism constraints, our model would be arc-factored,
and decoding could be done for each i, j pair in-
dependently. Our structures do overlap though,
and we employ AD3 (Martins et al., 2011) to ﬁnd
the highest-scoring internally consistent semantic
graph. AD3 is an approximate discrete optimiza-
tion algorithm based on dual decomposition.
It
can be used to decode factor graphs over discrete
variables when scored structures overlap, as is the
case here.

3.2.2 Basic Scoring

Similarly to Kiperwasser and Goldberg (2016),
our model learns representations of tokens in a
sentence using a bi-directional LSTM (BiLSTM).
Each different type of structure (predicate, unla-
beled arc, labeled arc) then shares these same BiL-
STM representations, feeding them into a multi-
layer perceptron (MLP) which is speciﬁc to the
structure type. We present the architecture slightly
differently from prior work, to make the transition
to the multitask scenario (
4) smoother. In our pre-
§
sentation, we separate the model into a function
φ that represents the input (corresponding to the
BiLSTM and the initial layers of the MLPs), and a
function ψ that represents the output (correspond-
ing to the ﬁnal layers of the MLPs), with the scores
given by their inner product.2

Distributed input representations. Long short-
term memory networks (LSTMs) are a variant
of recurrent neural networks (RNNs) designed
to alleviate the vanishing gradient problem in
RNNs (Hochreiter and Schmidhuber, 1997). A
bi-directional LSTM (BiLSTM) runs over the se-
quence in both directions (Schuster and Paliwal,
1997; Graves, 2012).

Given an input sentence x and its corresponding
part-of-speech tag sequence, each token is mapped
to a concatenation of its word embedding vector
and POS tag vector. Two LSTMs are then run
in opposite directions over the input vector se-
quence, outputting the concatenation of the two
hidden vectors at each position i: hi =
−→h i; ←−h i
(we omit hi’s dependence on x and its own pa-
(cid:3)
rameters). hi can be thought of as an encoder that
contextualizes each token conditioning on all of
its context, without any Markov assumption. h’s
parameters are learned jointly with the rest of the
model (
3.3); we refer the readers to Cho (2015)
for technical details.

§

(cid:2)

The input representation φ of a predicate struc-

ture depends on the representation of one word:

Figure 3: Illustration of the architecture of the ba-
sic model. i and j denote the indices of tokens in
the given sentence. The ﬁgure depicts single-layer
BiLSTM and MLPs, while in practice we use two
layers for both.

For unlabeled arc and labeled arc structures, it de-
pends on both the head and the modiﬁer (but not
the label, which is captured in the distributed out-
put representation):

φ(i

j) = tanh

CUA

hi; hj

+ bUA

,

φ(i

j) = tanh

(cid:0)

CLA

(cid:2)
hi; hj

(cid:3)

+ bLA

(cid:1)
.

(3b)

(3c)

→
(cid:96)
→

(cid:2)

(cid:3)

(cid:1)

(cid:0)

Distributed output representations. NLP re-
searchers have found that embedding discrete out-
put labels into a low dimensional real space is
an effective way to capture commonalities among
them (Srikumar and Manning, 2014; Hermann
et al., 2014; FitzGerald et al., 2015, inter alia).
In neural language models (Bengio et al., 2003;
Mnih and Hinton, 2007, inter alia) the weights of
the output layer could also be regarded as an out-
put embedding.

We associate each ﬁrst-order structure p with a
d-dimensional real vector ψ(p) which does not de-
pend on particular words in p. Predicates and un-
labeled arcs are each mapped to a single vector:

and each label gets a vector:

ψ(i

ψ(i

→·

) = ψpred,
j) = ψUA,

→

(4a)

(4b)

ψ(i

j) = ψLA((cid:96)).

(4c)

(cid:96)
→

φ(i

) = tanh

Cpredhi + bpred

.

(3a)

→·

Scoring. Finally, we use an inner product to
score ﬁrst-order structures:

(cid:0)

(cid:1)

2For clarity, we present single-layer BiLSTMs and MLPs,

while in practice we use two layers for both.

s(p) = φ(p)

ψ(p).

(5)

·

Figure 3 illustrates our basic model’s architecture.

3.3 Learning

The parameters of the model are learned using
a max-margin objective.
Informally, the goal is
to learn parameters for the score function so that
the gold parse is scored over every incorrect parse
with a margin proportional to the cost of the incor-
N
rect parse. More formally, let
i=1
be the training set consisting of N pairs of sen-
tence xi and its gold parse yi. Training is then the
following (cid:96)2-regularized empirical risk minimiza-
tion problem:

(xi, yi)

=

D

(cid:8)

(cid:9)

min
Θ

λ
2 (cid:107)

2 +
Θ
(cid:107)

1
N

N

L

xi, yi; Θ

,

(6)

i=1
(cid:88)

(cid:0)

(cid:1)

where Θ is all parameters in the model, and L is
the structured hinge loss:

(7)

L

xi, yi; Θ

= max
y∈Y(xi)

S

xi, y

+ c

y, yi

(cid:1)

(cid:0)

(cid:0)

(cid:8)

S

(cid:0)
.

(cid:1)(cid:9)

(cid:1)
xi, yi

(cid:0)
−
c is a weighted Hamming distance that trades off
between precision and recall (Taskar et al., 2004).
Following Martins and Almeida (2014), we en-
courage recall over precision by using the costs
0.6 for false negative arc predictions and 0.4 for
false positives.

(cid:1)

3.4 Experiments

We evaluate our basic model on the English
dataset from SemEval 2015 Task 18 closed track.3
We split as in previous work (Almeida and Mar-
tins, 2015; Du et al., 2015), resulting in 33,964
00–19 of the WSJ cor-
training sentences from
§
pus, 1,692 development sentences from
20, 1,410
§
sentences from
21 as in-domain test data, and
1,849 sentences sampled from the Brown Corpus
as out-of-domain test data.

§

The closed track differs from the open and gold
tracks in that it does not allow access to any
syntactic analyses.
In the open track, additional
machine generated syntactic parses are provided,
while the gold-track gives access to various gold-
standard syntactic analyses. Our model is evalu-
ated with closed track data; it does not have access
to any syntactic analyses during training or test.

We refer the readers to

4.4 for implementa-
§
tion details, including training procedures, hyper-
parameters, pruning techniques, etc..

3http://sdp.delph-in.net
4Paired bootstrap, p < 0.05 after Bonferroni correction.

Model

DM PAS PSD Avg.

id

ood

Du et al., 2015
A&M, 2015
BASIC

Du et al., 2015
A&M, 2015
BASIC

89.1
88.2
89.4

81.8
81.8
84.5

91.3
90.9
92.2

87.2
86.9
88.3

75.7
76.4
77.6

73.3
74.8
75.3

86.3
86.0
87.4

81.7
82.0
83.6

Table 2: Labeled parsing performance (F1 score)
on both in-domain (id) and out-of-domain (ood)
test data. The last column shows the micro-
average over the three tasks. Bold font indicates
best performance without syntax. Underlines indi-
cate statistical signiﬁcance with Bonferroni (1936)
correction compared to the best baseline system.4

Empirical results. As our model uses no ex-
plicit syntactic information, the most comparable
models to ours are two state-of-the-art closed track
systems due to Du et al. (2015) and Almeida and
Martins (2015). Du et al. (2015) rely on graph-
tree transformation techniques proposed by Du
et al. (2014), and apply a voting ensemble to well-
studied tree-oriented parsers. Closely related to
ours is Almeida and Martins (2015), who used
rich, hand-engineered second-order features and
AD3 for inference.

Table 2 compares our basic model to both base-
line systems (labeled F1 score) on SemEval 2015
Task 18 test data. Scores of those systems are re-
peated from the ofﬁcial evaluation results. Our ba-
sic model signiﬁcantly outperforms the best pub-
lished results with a 1.1% absolute improvement
on the in-domain test set and 1.6% on the out-of-
domain test set.

4 Multitask SDP

We introduce two extensions to our single-task
model, both of which use training data for all
three formalisms to improve performance on each
formalism’s parsing task. We describe a ﬁrst-
order model, where representation functions are
enhanced by parameter sharing while inference
is kept separate for each task (
4.2). We then
§
introduce a model with cross-task higher-order
structures that uses joint inference across different
4.3). Both multitask models use AD3 for
tasks (
§
decoding, and are trained with the same margin-
based objective, as in our single-task model.

4.1 Problem Formulation

{

=

∈ T

We will use an additional superscript t
to
distinguish the three tasks (e.g., y(t), φ(t)), where
. Our task is now to pre-
DM, PAS, PSD
}
T
y(t)
t∈T for a given input sen-
dict three graphs
}
tence x. Multitask SDP can also be understood
as parsing x into a single uniﬁed multigraph y =
t∈T y(t). Similarly to Equations 1–2, we decom-
pose y’s score S(x, y) into a sum of local scores
(cid:83)
for local structures in y, and we seek a multigraph
ˆy that maximizes S(x, y).

{

4.2 Multitask SDP with Parameter Sharing

A common approach when using BiLSTMs for
multitask learning is to share the BiLSTM part of
the model across tasks, while training specialized
classiﬁers for each task (Søgaard and Goldberg,
2016). In this spirit, we let each task keep its own
specialized MLPs, and explore two variants of our
model that share parameters at the BiLSTM level.
The ﬁrst variant consists of a set of task-speciﬁc
BiLSTM encoders as well as a common one that
is shared across all tasks. We denote it FREDA.
FREDA uses a neural generalization of “frustrat-
ingly easy” domain adaptation (Daum´e III, 2007;
Kim et al., 2016), where one augments domain-
speciﬁc features with a shared set of features to
capture global patterns. Formally, let
t∈T
denote the three task-speciﬁc encoders. We intro-
duce another encoder
h that is shared across all
tasks. Then a new set of input functions
t∈T
(cid:101)
can be deﬁned as in Equations 3a–3c, for example:

φ(t)

h(t)

{

{

}

}

φ(t)(i

(cid:96)
→

j) = tanh

C

(t)
LA

h

(t)
i

; h

(t)
j ;

(8)

(cid:0)

hi;
(cid:2)

hj

+ b

(t)
LA

.

(cid:101)

(cid:3)
(cid:1)
The predicate and unlabeled arc versions are anal-
remain
ogous. The output representations
task-speciﬁc, and the score is still the inner prod-
uct between the input representation and the out-
put representation.

ψ(t)
{

(cid:101)

}

The second variant, which we call SHARED,
uses only the shared encoder
h, and doesn’t use
h(t)
task-speciﬁc encoders
. It can be understood
as a special case of FREDA where the dimensions
of the task-speciﬁc encoders are 0.

(cid:101)

}

{

4.3 Multitask SDP with Cross-Task

Structures

In syntactic parsing, higher-order structures have
commonly been used to model interactions be-

tween multiple adjacent arcs in the same depen-
dency tree (Carreras, 2007; Smith and Eisner,
2008; Martins et al., 2009; Zhang et al., 2014,
inter alia). Llu´ıs et al. (2013), in contrast, used
second-order structures to jointly model syntactic
dependencies and semantic roles. Similarly, we
use higher-order structures across tasks instead of
within tasks.
In this work, we look at interac-
tions between arcs that share the same head and
modiﬁer.5 See Figures 2b and 2c for examples of
higher-order cross-task structures.

Higher-order structure scoring. Borrowing
from Lei et al. (2014), we introduce a low-rank
tensor scoring strategy that, given a higher-order
structure p, models interactions between the ﬁrst-
order structures (i.e., arcs) p is made up of. This
approach builds on and extends the parameter
sharing techniques in
It can either follow
4.2.
FREDA or SHARED to get the input representations
for ﬁrst-order structures.

§

We ﬁrst introduce basic tensor notation. The or-
der of a tensor is the number of its dimensions.
The outer product of two vectors forms a second-
order tensor (matrix) where [u
v]i,j = uivj. We
denote the inner product of two tensors of the
same dimensions by
, which ﬁrst takes their
·(cid:105)
element-wise product, then sums all the elements
in the resulting tensor.

,
(cid:104)·

⊗

p(t)

For example, let p be a labeled third-order struc-
ture, including one labeled arc from each of the
t∈T . Intuitively,
three different tasks: p =
s(p) should capture every pairwise interaction be-
tween the three input and three output representa-
tions of p. Formally, we want the score function
to include a parameter for each term in the outer
product of the representation vectors: s(p) =

{

}

W,

(cid:42)

φ(t)

p(t)

ψ(t)

p(t)

,

(9)

t∈T (cid:16)
(cid:79)

(cid:17)
where W is a sixth-order tensor of parameters.6

(cid:17)(cid:17)

(cid:16)

(cid:16)

(cid:43)

⊗

With typical dimensions of representation vec-
tors, this leads to an unreasonably large number of

5In the future we hope to model structures over larger mo-
tifs, both across and within tasks, to potentially capture when
an arc in one formalism corresponds to a path in another for-
malism, for example.

6This is, of course, not the only way to model interactions
between several representations. For instance, one could con-
catenate them and feed them into another MLP. Our prelim-
inary experiments in this direction suggested that it may be
less effective given a similar number of parameters, but we
did not run full experiments.

parameters. Following Lei et al. (2014), we upper-
bound the rank of W by r to limit the number of
parameters (r is a hyperparameter, decided empir-
ically). Using the fact that a tensor of rank at most
r can be decomposed into a sum of r rank-1 ten-
sors (Hitchcock, 1927), we reparameterize W to
enforce the low-rank constraint by construction:

r

W =

U

(t)
LA

V

(t)
LA

,
(cid:19)

j,:
(cid:105)

j,: ⊗
(cid:105)

(cid:104)

(10)

t∈T (cid:18)(cid:104)
j=1
(cid:79)
(cid:88)
(t)
(t)
LA, V
LA ∈

Rr×d are now our parame-
where U
]j,: denotes the jth row of a matrix. Substi-
ters. [
·
tuting this back into Equation 9 and rearranging,
the score function s(p) can then be rewritten as:

r

j=1
(cid:88)

t∈T (cid:104)
(cid:89)

U

(t)
LAφ(t)

p(t)

V

(t)
LAψ(t)

p(t)

j

(cid:17)(cid:105)

(cid:104)

(cid:16)

.

j

(cid:16)

(cid:17)(cid:105)

(11)
We refer readers to Kolda and Bader (2009) for
mathematical details.

For labeled higher-order structures our parame-

V

U
{

(t)
LA}

ters consist of the set of six matrices,

(t)
LA} ∪
. These parameters are shared between
{
second-order and third-order labeled structures.
Labeled second-order structures are scored as
Equation 11, but with the product extending over
only the two relevant tasks. Concretely, only four
of the representation functions are used rather than
all six, along with the four corresponding ma-
. Unlabeled cross-
trices from
V
task structures are scored analogously, reusing the
same representations, but with a separate set of pa-
rameter matrices

(t)
UA} ∪ {
Note that we are not doing tensor factorization;
(t)
(t)
(t)
we are learning U
UA di-
LA, U
LA, V
rectly, and W is never explicitly instantiated.

(t)
.
UA}
(t)
UA, and V

(t)
LA} ∪ {

(t)
LA}

U
{

U

V

{

Inference and learning. Given a sentence, we
use AD3 to jointly decode all three formalisms.7
The training objective used for learning is the sum
of the losses for individual tasks.

4.4

Implementation Details

Each input token is mapped to a concatenation of
three real vectors: a pre-trained word vector; a
randomly-initialized word vector; and a randomly-
initialized POS tag vector.8 All three are updated

7Joint inference comes at a cost; our third-order model is
able to decode roughly 5.2 sentences (i.e., 15.5 task-speciﬁc
graphs) per second on a single Xeon E5-2690 2.60GHz CPU.
8There are minor differences in the part-of-speech data
provided with the three formalisms. For the basic models, we

Hyperparameter

Pre-trained word embedding dimension
Randomly-initialized word embedding dimension
POS tag embedding dimension
Dimensions of representations φ and ψ
MLP layers
BiLSTM layers
BiLSTM dimensions
Rank of tensor r
α for word dropout

Value

100
25
25
100
2
2
200
100
0.25

Table 3: Hyperparameters used in the experi-
ments.

during training. We use 100-dimensional GloVe
(Pennington et al., 2014) vectors trained over
Wikipedia and Gigaword as pre-trained word em-
beddings. To deal with out-of-vocabulary words,
we apply word dropout (Iyyer et al., 2015) and
randomly replace a word w with a special unk-
symbol with probability
1+#(w) , where #(w) is
the count of w in the training set.

α

Models are trained for up to 30 epochs with
Adam (Kingma and Ba, 2015), with β1 = β2 =
0.9, and initial learning rate η0 = 10−3. The
learning rate η is annealed at a rate of 0.5 ev-
ery 10 epochs (Dozat and Manning, 2017). We
apply early-stopping based on the labeled F1
score on the development set.9 We set
the
maximum number of iterations of AD3 to 500
and round decisions when it doesn’t converge.
We clip the (cid:96)2 norm of gradients to 1 (Graves,
2013; Sutskever et al., 2014), and we do not
use mini-batches. Randomly initialized parame-
ters are sampled from a uniform distribution over
, where dr and
−
dc are the number of the rows and columns in the
(cid:2)
matrix, respectively. An (cid:96)2 penalty of λ = 10−6 is
applied to all weights. Other hyperparameters are
summarized in Table 3.

6/(dr + dc),

6/(dr + dc)

(cid:112)

(cid:112)

(cid:3)

We use the same pruner as Martins and Almeida
(2014), where a ﬁrst-order feature-rich unlabeled
pruning model is trained for each task, and arcs
with posterior probability below 10−4 are dis-
carded. We further prune labeled structures that
appear less than 30 times in the training set.
In
the development set, about 10% of the arcs remain
after pruning, with a recall of around 99%.

use the POS tags provided with the respective dataset; for the
multitask models, we use the (automatic) POS tags provided
with DM.

9Micro-averaged labeled F1 for the multitask models.

4.5 Experiments

Experimental settings. We compare four multi-
task variants to the basic model, as well as the two
baseline systems introduced in

3.4.
§

•

•

•

•

SHARED1 is a ﬁrst-order model. It uses a sin-
gle shared BiLSTM encoder, and keeps the
inference separate for each task.
FREDA1 is a ﬁrst-order model based on “frus-
tratingly easy” parameter sharing. It uses a
shared encoder as well as task-speciﬁc ones.
The inference is kept separate for each task.
SHARED3 is a third-order model. It follows
SHARED1 and uses a single shared BiLSTM
encoder, but additionally employs cross-task
structures and inference.
FREDA3 is also a third-order model. It com-
bines FREDA1 and SHARED3 by using both
“frustratingly easy” parameter sharing and
cross-task structures and inference.

In addition, we also examine the effects of syn-
tax by comparing our models to the state-of-the-art
open track system (Almeida and Martins, 2015).10

Main results overview. Table 4a compares our
models to the best published results (labeled F1
score) on SemEval 2015 Task 18 in-domain test
set. Our basic model improves over all closed
track entries in all formalisms. It is even with the
best open track system for DM and PSD, but im-
proves on PAS and on average, without making
use of any syntax. Three of our four multitask
variants further improve over our basic model;
SHARED1’s differences are statistically insigniﬁ-
cant. Our best models (SHARED3, FREDA3) out-
perform the previous state-of-the-art closed track
system by 1.7% absolute F1, and the best open
track system by 0.9%, without the use of syntax.

We observe similar trends on the out-of-domain
test set (Table 4b), with the exception that, on
PSD, our best-performing model’s improvement
over the open-track system of Almeida and Mar-
tins (2015) is not statistically signiﬁcant.

The extent to which we might beneﬁt from syn-
tactic information remains unclear. With auto-
matically generated syntactic parses, Almeida and
Martins (2015) manage to obtain more than 1%
absolute improvements over their closed track en-

10Kanerva et al. (2015) was the winner of the gold track,
which overall saw higher performance than the closed and
open tracks. Since gold-standard syntactic analyses are not
available in most realistic scenarios, we do not include it in
this comparison.

(a) Labeled F1 score on the in-domain test set.

Du et al., 2015
A&M, 2015 (closed)
A&M, 2015 (open)†
BASIC

SHARED1
FREDA1

SHARED3
FREDA3

Du et al., 2015
A&M, 2015 (closed)
A&M, 2015 (open)†
BASIC

SHARED1
FREDA1

SHARED3
FREDA3

DM PAS PSD Avg.

89.1
88.2
89.4
89.4

89.7
90.0

90.3
90.4

81.8
81.8
83.8
84.5

84.4
84.9

85.3
85.3

91.3
90.9
91.7
92.2

91.9
92.3

92.5
92.7

87.2
86.9
87.6
88.3

88.1
88.3

88.4
89.0

75.7
76.4
77.6
77.6

77.8
78.1

78.5
78.5

73.3
74.8
76.2
75.3

75.4
75.8

76.1
76.4

86.3
86.0
87.1
87.4

87.4
87.7

88.0
88.0

81.7
82.0
83.3
83.6

83.5
83.9

84.1
84.4

DM PAS PSD Avg.

(b) Labeled F1 score on the out-of-domain test set.

†

Table 4: The last columns show the micro-average
denotes the use of syntac-
over the three tasks.
tic parses. Bold font indicates best performance
among all systems, and underlines indicate statis-
tical signiﬁcance with Bonferroni correction com-
pared to A&M, 2015 (open), the strongest baseline
system.

try, which is consistent with the extensive evalua-
tion by Zhang et al. (2016), but we leave the incor-
poration of syntactic trees to future work. Syntac-
tic parsing could be treated as yet another output
task, as explored in Llu´ıs et al. (2013) and in the
transition-based frameworks of Henderson et al.
(2013) and Swayamdipta et al. (2016).

Effects of structural overlap. We hypothesized
that the overlap between formalisms would enable
multitask learning to be effective; in this section
we investigate in more detail how structural over-
lap affected performance. By looking at undi-
rected overlap between unlabeled arcs, we dis-
cover that modeling only arcs in the same direc-
tion may have been a design mistake.

DM and PAS are more structurally similar to
each other than either is to PSD. Table 5 compares
the structural similarities between the three for-

Undirected

Directed

DM PAS

PSD

DM PAS

PSD

DM
-
PAS
70.0
PSD 57.4

67.2
-
56.3

56.8
54.9
-

-
66.9
26.4

64.2
-
29.6

26.1
26.1
-

Table 5: Pairwise structural similarities between
the three formalisms in unlabeled F1 score. Scores
from Oepen et al. (2015).

DM

PAS

PSD

UF

91.7
91.9

LF

90.4
90.8

UF

93.1
93.4

LF

91.6
92.0

UF

89.0
88.6

LF

79.8
80.4

FREDA1
FREDA3

Table 6: Unlabeled (UF ) and labeled (LF ) pars-
ing performance of FREDA1 and FREDA3 on the
development set of SemEval 2015 Task 18.

malisms in unlabeled F1 score (each formalism’s
gold-standard unlabeled graph is used as a predic-
tion of each other formalism’s gold-standard un-
labeled graph). All three formalisms have more
than 50% overlap when ignoring arcs’ directions,
but considering direction, PSD is clearly different;
PSD reverses the direction about half of the time
it shares an edge with another formalism. A con-
crete example can be found in Figure 1, where DM
and PAS both have an arc from “Last” to “week,”
while PSD has an arc from “week” to “Last.”

We can compare FREDA3 to FREDA1 to isolate
the effect of modeling higher-order structures. Ta-
ble 6 shows performance on the development data
in both unlabeled and labeled F1. We can see
that FREDA3’s unlabeled performance improves
on DM and PAS, but degrades on PSD. This sup-
ports our hypothesis, and suggests that in future
work, a more careful selection of structures to
model might lead to further improvements.

5 Related Work

We note two important strands of related work.

Graph-based parsing. Graph-based parsing
was originally invented to handle non-projective
syntax (McDonald et al., 2005; Koo et al., 2010;
inter alia), but has been
Martins et al., 2013,
adapted to semantic parsing (Flanigan et al.,
2014; Martins and Almeida, 2014; Thomson
et al., 2014; Kuhlmann, 2014, inter alia). Local
structure scoring was traditionally done with
linear models over hand-engineered features, but
lately, various forms of representation learning

have been explored to learn feature combinations
(Lei et al., 2014; Taub-Tabib et al., 2015; Pei et al.,
2015, inter alia). Our work is perhaps closest
to those who used BiLSTMs to encode inputs
(Kiperwasser and Goldberg, 2016; Kuncoro
et al., 2016; Wang and Chang, 2016; Dozat and
Manning, 2017; Ma and Hovy, 2016).

Multitask learning in NLP. There have been
many efforts in NLP to use joint learning to re-
place pipelines, motivated by concerns about cas-
cading errors. Collobert and Weston (2008) pro-
posed sharing the same word representation while
solving multiple NLP tasks. Zhang and Weiss
(2016) use a continuous stacking model for POS
tagging and parsing. Ammar et al. (2016) and Guo
et al. (2016) explored parameter sharing for multi-
lingual parsing. Johansson (2013) and Kshirsagar
et al. (2015) applied ideas from domain adapta-
tion to multitask learning. Successes in multitask
learning have been enabled by advances in repre-
sentation learning as well as earlier explorations of
parameter sharing (Ando and Zhang, 2005; Blitzer
et al., 2006; Daum´e III, 2007).

6 Conclusion

We showed two orthogonal ways to apply deep
multitask learning to graph-based parsing. The
ﬁrst shares parameters when encoding tokens in
the input with recurrent neural networks, and
the second introduces interactions between out-
put structures across formalisms. Without using
syntactic parsing,
these approaches outperform
even state-of-the-art semantic dependency pars-
ing systems that use syntax. Because our tech-
niques apply to labeled directed graphs in gen-
eral, they can easily be extended to incorporate
more formalisms, semantic or otherwise.
In fu-
ture work we hope to explore cross-task scor-
ing and inference for tasks where parallel an-
notations are not available. Our code is open-
source and available at https://github.
com/Noahs-ARK/NeurboParser.

Acknowledgements

We thank the Ark, Maxwell Forbes, Luheng He,
Kenton Lee, Julian Michael, and Jin-ge Yao for
their helpful comments on an earlier version of this
draft, and the anonymous reviewers for their valu-
able feedback. This work was supported by NSF
grant IIS-1562364 and DARPA grant FA8750-12-
2-0342 funded under the DEFT program.

References

Mariana S. C. Almeida and Andr´e F. T. Martins. 2015.
Lisbon: Evaluating TurboSemanticParser on multi-
ple languages and out-of-domain data. In Proc. of
SemEval.

Waleed Ammar, George Mulcaire, Miguel Ballesteros,
Chris Dyer, and Noah Smith. 2016. Many lan-
guages, one parser. TACL 4:431–444.

Rie Kubota Ando and Tong Zhang. 2005. A framework
for learning predictive structures from multiple tasks
and unlabeled data. JMLR 6:1817–1853.

Collin Baker, Michael Ellsworth, and Katrin Erk. 2007.
SemEval’07 task 19: Frame semantic structure ex-
traction. In Proc. of SemEval.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Grifﬁtt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract meaning representation
for sembanking. In Proc. of LAW VII & ID.

Yoshua Bengio, R`ejean Ducharme, Pascal Vincent, and
Christian Janvin. 2003. A neural probabilistic lan-
guage model. JMLR 3:1137–1155.

John Blitzer, Ryan McDonald, and Fernando Pereira.
2006. Domain adaptation with structural correspon-
dence learning. In Proc. of EMNLP.

Carlo E. Bonferroni. 1936. Teoria statistica delle classi
e calcolo delle probabilit`a. Pubblicazioni del R. Is-
tituto Superiore di Scienze Economiche e Commer-
ciali di Firenze 8:3–62.

Xavier Carreras. 2007. Experiments with a higher-
In Proc. of

order projective dependency parser.
CoNLL.

Rich Caruana. 1997. Multitask learning. Machine

Learning 28(1):41–75.

Kyunghyun Cho. 2015.
derstanding with
ArXiv:1511.07916.

Natural

distributed

language un-
representation.

Ronan Collobert and Jason Weston. 2008. A uniﬁed
architecture for natural language processing: Deep
neural networks with multitask learning. In Proc. of
ICML.

Ann Copestake and Dan Flickinger. 2000.

An
open source grammar development environment and
broad-coverage English grammar using HPSG.
In
Proc. of LREC.

Ann Copestake, Dan Flickinger, Ivan A. Sag, and Carl
Pollard. 2005. Minimal recursion semantics: An in-
troduction. Research on Language & Computation
3(4):281–332.

Hal Daum´e III. 2007. Frustratingly easy domain adap-

tation. In Proc. of ACL.

Marie-Catherine de Marneffe, Timothy Dozat, Na-
talia Silveira, Katri Haverinen, Filip Ginter, Joakim
Nivre, and Christopher D. Manning. 2014. Univer-
sal Stanford dependencies: A cross-linguistic typol-
ogy. In Proc. of LREC.

Timothy Dozat and Christopher D. Manning. 2017.
Deep biafﬁne attention for neural dependency pars-
ing. In Proc. of ICLR.

Yantao Du, Fan Zhang, Weiwei Sun, and Xiaojun Wan.
2014. Peking: Proﬁling syntactic tree parsing tech-
niques for semantic graph parsing. In Proc. of Se-
mEval.

Yantao Du, Fan Zhang, Xun Zhang, Weiwei Sun, and
Xiaojun Wan. 2015. Peking: Building semantic de-
In Proc. of
pendency graphs with a hybrid parser.
SemEval.

Nicholas FitzGerald, Oscar T¨ackstr¨om, Kuzman
Ganchev, and Dipanjan Das. 2015. Semantic role
In Proc. of
labeling with neural network factors.
EMNLP.

Jeffrey Flanigan, Sam Thomson, Jaime Carbonell,
Chris Dyer, and Noah A. Smith. 2014. A discrim-
inative graph-based parser for the abstract meaning
representation. In Proc. of ACL.

Daniel Flickinger, Yi Zhang, and Valia Kordoni. 2012.
DeepBank: A dynamically annotated treebank of the
Wall Street Journal. In Proc. of TLT.

Daniel Gildea and Daniel Jurafsky. 2002. Automatic
labeling of semantic roles. Computational Linguis-
tics 28(3):245–288.

Alex Graves. 2012. Supervised Sequence Labelling
with Recurrent Neural Networks, volume 385 of
Studies in Computational Intelligence. Springer.

Alex Graves. 2013. Generating sequences with recur-

rent neural networks. ArXiv 1308.0850.

Jiang Guo, Wanxiang Che, Haifeng Wang, and Ting
Liu. 2016. A universal framework for inductive
transfer parsing across multi-typed treebanks.
In
Proc. of COLING.

Jan Hajiˇc, Eva Hajiˇcov´a, Jarmila Panevov´a, Petr
Sgall, Ondˇrej Bojar, Silvie Cinkov´a, Eva Fuˇc´ıkov´a,
Marie Mikulov´a, Petr Pajas, Jan Popelka, Jiˇr´ı
Semeck´y, Jana ˇSindlerov´a, Jan ˇStˇep´anek, Josef
Toman, Zdeˇnka Ureˇsov´a, and Zdenˇek ˇZabokrtsk´y.
2012. Announcing Prague Czech-English depen-
dency treebank 2.0. In Proc. LREC.

James Henderson, Paola Merlo,

Ivan Titov, and
Gabriele Musillo. 2013. Multi-lingual joint pars-
ing of syntactic and semantic dependencies with a
latent variable model. Computational Linguistics
39(4):949–998.

Karl Moritz Hermann, Dipanjan Das, Jason Weston,
and Kuzman Ganchev. 2014. Semantic frame iden-
tiﬁcation with distributed word representations. In
Proc. of ACL.

Frank L. Hitchcock. 1927. The expression of a tensor
or a polyadic as a sum of products. Journal of Math-
ematical Physics 6(1):164–189.

Sepp Hochreiter and J¨urgen Schmidhuber. 1997.
Long Short-Term Memory. Neural Computation
9(8):1735–1780.

Mohit Iyyer, Varun Manjunatha, Jordan Boyd-Graber,
and Hal Daum´e III. 2015. Deep unordered compo-
sition rivals syntactic methods for text classiﬁcation.
In Proc. of ACL.

Richard Johansson. 2013. Training parsers on incom-

patible treebanks. In Proc. of NAACL.

Jenna Kanerva, Juhani Luotolahti, and Filip Ginter.
2015. Turku: Semantic dependency parsing as a se-
quence classiﬁcation. In Proc. of SemEval.

Young-Bum Kim, Karl Stratos, and Ruhi Sarikaya.
2016. Frustratingly easy neural domain adaptation.
In Proc. of COLING.

Tao Lei, Yu Xin, Yuan Zhang, Regina Barzilay, and
Tommi Jaakkola. 2014. Low-rank tensors for scor-
ing dependency structures. In Proc. of ACL.

Xavier Llu´ıs, Xavier Carreras, and Llu´ıs M`arquez.
2013. Joint arc-factored parsing of syntactic and se-
mantic dependencies. TACL 1:219–230.

Xuezhe Ma and Eduard Hovy. 2016. Neural prob-
abilistic model for non-projective MST parsing.
ArXiv 1701.00874.

Andr´e F. T. Martins and Mariana S. C. Almeida. 2014.
Priberam: A turbo semantic parser with second or-
der features. In Proc. of SemEval.

Andr´e F. T. Martins, Miguel B. Almeida, and Noah A.
Smith. 2013. Turning on the turbo: Fast third-order
non-projective turbo parsers. In Proc. of ACL.

Andr´e F. T. Martins, Noah Smith, and Eric Xing. 2009.
Concise integer linear programming formulations
for dependency parsing. In Proc. of ACL.

Andr´e F. T. Martins, Noah A. Smith, Pedro M. Q.
Aguiar, and M´ario A. T. Figueiredo. 2011. Dual de-
composition with many overlapping components. In
Proc. of EMNLP.

Diederik P. Kingma and Jimmy Ba. 2015. Adam:
In Proc. of

A method for stochastic optimization.
ICLR.

Ryan McDonald, Koby Crammer, and Fernando
Pereira. 2005. Online large-margin training of de-
pendency parsers. In Proc. of ACL.

Eliyahu Kiperwasser and Yoav Goldberg. 2016. Sim-
ple and accurate dependency parsing using bidirec-
tional LSTM feature representations. TACL 4:313–
327.

Tamara G. Kolda and Brett W. Bader. 2009. Ten-
sor decompositions and applications. SIAM Review
51(3):455–500.

Terry Koo, Alexander M. Rush, Michael Collins,
Tommi Jaakkola, and David Sontag. 2010. Dual
decomposition for parsing with non-projective head
automata. In Proc. of EMNLP.

Meghana Kshirsagar, Sam Thomson, Nathan Schnei-
der, Jaime Carbonell, Noah A. Smith, and Chris
Dyer. 2015. Frame-semantic role labeling with het-
erogeneous annotations. In Proc. of ACL.

Marco Kuhlmann. 2014. Link¨oping: Cubic-time graph
parsing with a simple scoring scheme. In Proc. of
SemEval.

Adhiguna Kuncoro, Miguel Ballesteros, Lingpeng
Kong, Chris Dyer, and Noah A. Smith. 2016. Dis-
tilling an ensemble of greedy dependency parsers
into one MST parser. In Proc. of EMNLP.

Tom Kwiatkowski, Eunsol Choi, Yoav Artzi, and
Luke S. Zettlemoyer. 2013.
Scaling semantic
parsers with on-the-ﬂy ontology matching. In Proc.
of EMNLP.

Yusuke Miyao. 2006. From linguistic theory to syntac-
tic analysis: Corpus-oriented grammar development
and feature forest model.

Andriy Mnih and Geoffrey Hinton. 2007. Three new
graphical models for statistical language modelling.
In Proc. of ICML.

Stephan Oepen, Marco Kuhlmann, Yusuke Miyao,
Daniel Zeman, Silvie Cinkov´a, Dan Flickinger, Jan
Hajiˇc, and Zdeˇnka Ureˇsov´a. 2015. SemEval 2015
task 18: Broad-coverage semantic dependency pars-
ing. In Proc. of SemEval.

Stephan Oepen, Marco Kuhlmann, Yusuke Miyao,
Daniel Zeman, Dan Flickinger, Jan Hajiˇc, Angelina
Ivanova, and Yi Zhang. 2014. SemEval 2014 task
8: Broad-coverage semantic dependency parsing. In
Proc. of SemEval.

Martha Palmer, Daniel Gildea, and Paul Kingsbury.
2005. The proposition bank: An annotated cor-
pus of semantic roles. Computational Linguistics
31(1):71–106.

Wenzhe Pei, Tao Ge, and Baobao Chang. 2015. An
effective neural network model for graph-based de-
pendency parsing. In Proc. of ACL.

Jeffrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. GloVe: Global vectors for
word representation. In Proc. of EMNLP.

Carl Pollard and Ivan A. Sag. 1994. Head-Driven
The University of

Phrase Structure Grammar.
Chicago Press.

Yuan Zhang and David Weiss. 2016.

Stack-
propagation: Improved representation learning for
syntax. In Proc. of ACL.

Mike Schuster and Kuldip K. Paliwal. 1997. Bidirec-
tional recurrent neural networks. IEEE Transactions
on Signal Processing 45(11):2673–2681.

David Smith and Jason Eisner. 2008. Dependency
parsing by belief propagation. In Proc. of EMNLP.

Anders Søgaard and Yoav Goldberg. 2016. Deep
multi-task learning with low level tasks supervised
at lower layers. In Proc. of ACL.

Vivek Srikumar and Christopher D Manning. 2014.
Learning distributed representations for structured
output prediction. In Proc. of NIPS.

Mihai Surdeanu, Richard Johansson, Adam Meyers,
Llu´ıs M`arquez, and Joakim Nivre. 2008.
The
CoNLL-2008 shared task on joint parsing of syntac-
tic and semantic dependencies. In Proc. of CoNLL.

Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. 2014.
Sequence to sequence learning with neural net-
works. In Proc. of NIPS.

Swabha Swayamdipta, Miguel Ballesteros, Chris Dyer,
and Noah A. Smith. 2016. Greedy, joint syntactic-
In Proc. of
semantic parsing with stack LSTMs.
CoNLL.

Ben Taskar, Carlos Guestrin, and Daphne Koller. 2004.
Max-margin Markov networks. In Advances in Neu-
ral Information Processing Systems 16.

Hillel Taub-Tabib, Yoav Goldberg, and Amir Glober-
son. 2015. Template kernels for dependency pars-
ing. In Proc. of NAACL.

Sam Thomson, Brendan O’Connor, Jeffrey Flani-
gan, David Bamman,
Jesse Dodge, Swabha
Swayamdipta, Nathan Schneider, Chris Dyer, and
Noah A. Smith. 2014. CMU: Arc-factored, discrim-
inative semantic dependency parsing. In Proc. of Se-
mEval.

Wenhui Wang and Baobao Chang. 2016. Graph-based
dependency parsing with bidirectional LSTM.
In
Proc. of ACL.

Naiwen Xue, Fei Xia, Fu-dong Chiou, and Martha
Palmer. 2005. The Penn Chinese TreeBank: Phrase
structure annotation of a large corpus. Natural Lan-
guage Engineering 11(2):207–238.

Xun Zhang, Yantao Du, Weiwei Sun, and Xiaojun
Wan. 2016. Transition-based parsing for deep de-
Computational Linguistics
pendency structures.
42(3):353–389.

Yuan Zhang, Tao Lei, Regina Barzilay, and Tommi S.
Jaakkola. 2014. Greed is good if randomized:
New inference for dependency parsing. In Proc. of
EMNLP.

