Graph-to-Sequence Learning using Gated Graph Neural Networks

Daniel Beck†

Trevor Cohn†

Gholamreza Haffari‡
†School of Computing and Information Systems
University of Melbourne, Australia
{d.beck,t.cohn}@unimelb.edu.au
‡Faculty of Information Technology
Monash University, Australia
gholamreza.haffari@monash.edu

Abstract

Many NLP applications can be framed
as a graph-to-sequence learning problem.
Previous work proposing neural architec-
tures on this setting obtained promising
results compared to grammar-based ap-
proaches but still rely on linearisation
heuristics and/or standard recurrent net-
works to achieve the best performance.
In this work, we propose a new model
that encodes the full structural informa-
tion contained in the graph. Our ar-
chitecture couples the recently proposed
Gated Graph Neural Networks with an in-
put transformation that allows nodes and
edges to have their own hidden represen-
tations, while tackling the parameter ex-
plosion problem present in previous work.
Experimental results show that our model
outperforms strong baselines in generation
from AMR graphs and syntax-based neu-
ral machine translation.

1

Introduction

Graph structures are ubiquitous in representations
In particular, many whole-
of natural language.
sentence semantic frameworks employ directed
acyclic graphs as the underlying formalism, while
most tree-based syntactic representations can also
be seen as graphs. A range of NLP applications
can be framed as the process of transducing a
graph structure into a sequence. For instance, lan-
guage generation may involve realising a semantic
graph into a surface form and syntactic machine
translation involves transforming a tree-annotated
source sentence to its translation.

Previous work in this setting rely on grammar-
based approaches such as tree transducers (Flani-
gan et al., 2016) and hyperedge replacement gram-

mars (Jones et al., 2012). A key limitation of
these approaches is that alignments between graph
nodes and surface tokens are required. These
alignments are usually automatically generated
so they can propagate errors when building the
grammar. More recent approaches transform the
graph into a linearised form and use off-the-shelf
methods such as phrase-based machine translation
(Pourdamghani et al., 2016) or neural sequence-
to-sequence (henceforth, s2s) models (Konstas
et al., 2017). Such approaches ignore the full
graph structure, discarding key information.

In this work we propose a model for graph-to-
sequence (henceforth, g2s) learning that lever-
ages recent advances in neural encoder-decoder
architectures. Speciﬁcally, we employ an encoder
based on Gated Graph Neural Networks (Li et al.,
2016, GGNNs), which can incorporate the full
graph structure without loss of information. Such
networks represent edge information as label-wise
parameters, which can be problematic even for
small sized label vocabularies (in the order of hun-
dreds). To address this limitation, we also intro-
duce a graph transformation that changes edges to
additional nodes, solving the parameter explosion
problem. This also ensures that edges have graph-
speciﬁc hidden vectors, which gives more infor-
mation to the attention and decoding modules in
the network.

We benchmark our model

in two graph-to-
sequence problems, generation from Abstract
Meaning Representations (AMRs) and Neural
Machine Translation (NMT) with source depen-
dency information. Our approach outperforms
strong s2s baselines in both tasks without relying
on standard RNN encoders, in contrast with pre-
vious work. In particular, for NMT we show that
we avoid the need for RNNs by adding sequen-
tial edges between contiguous words in the depen-
dency tree. This illustrates the generality of our

8
1
0
2
 
n
u
J
 
6
2
 
 
]
L
C
.
s
c
[
 
 
1
v
5
3
8
9
0
.
6
0
8
1
:
v
i
X
r
a

want-01

A

R

G

1

0
G
R
A

boy

A R G 1

believe-01

A

R

G

0

girl

the AMR graph representing the sentence “The boy wants the girl to believe him.”.
Figure 1: Left:
Right: Our proposed architecture using the same AMR graph as input and the surface form as output.
The ﬁrst layer is a concatenation of node and positional embeddings, using distance from the root node
as the position. The GGNN encoder updates the embeddings using edge-wise parameters, represented by
different colors (in this example, ARG0 and ARG1). The encoder also add corresponding reverse edges
(dotted arrows) and self edges for each node (dashed arrows). All parameters are shared between layers.
Attention and decoder components are similar to standard s2s models. This is a pictorial representation:
in our experiments the graphs are transformed before being used as inputs (see §3).

approach: linguistic biases can be added to the in-
puts by simple graph transformations, without the
need for changes to the model architecture.

2 Neural Graph-to-Sequence Model

Our proposed architecture is shown in Figure 1,
with an example AMR graph and its transforma-
tion into its surface form. Compared to standard
s2s models, the main difference is in the encoder,
where we employ a GGNN to build a graph repre-
sentation. In the following we explain the compo-
nents of this architecture in detail.1

2.1 Gated Graph Neural Networks

Early approaches for recurrent networks on graphs
(Gori et al., 2005; Scarselli et al., 2009) assume
a ﬁxed point representation of the parameters and
learn using contraction maps. Li et al. (2016) ar-
gues that this restricts the capacity of the model
and makes it harder to learn long distance rela-
tions between nodes. To tackle these issues, they
propose Gated Graph Neural Networks, which ex-
tend these architectures with gating mechanisms

in a similar fashion to Gated Recurrent Units (Cho
et al., 2014). This allows the network to be learnt
via modern backpropagation procedures.

In following, we formally deﬁne the version of
GGNNs we employ in this study. Assume a di-
rected graph G = {V, E, LV , LE }, where V is a
set of nodes (v, (cid:96)v), E is a set of edges (vi, vj, (cid:96)e)
and LV and LE are respectively vocabularies for
nodes and edges, from which node and edge la-
bels ((cid:96)v and (cid:96)e) are deﬁned. Given an input graph
with nodes mapped to embeddings X, a GGNN is
deﬁned as

Wr

(cid:96)eh(t−1)
u

+ br
(cid:96)e

h0

v = xv
(cid:32)

rt
v = σ

cr
v

(cid:88)

u∈Nv

(cid:88)

u∈Nv

(cid:88)

(cid:32)

(cid:32)

zt
v = σ

cz
v

Wz

(cid:96)eh(t−1)
u

+ bz
(cid:96)e

(cid:101)ht
v = ρ

cv

W(cid:96)e

u (cid:12) h(t−1)
rt
u

+ b(cid:96)e

(cid:16)

(cid:33)

v = (1 − zt
ht

u∈Nv
v) (cid:12) h(i−1)
v

+ zt

v (cid:12) (cid:101)ht
v

(cid:33)

(cid:33)

(cid:17)

1Our implementation uses MXNet (Chen et al., 2015) and
is based on the Sockeye toolkit (Hieber et al., 2017). Code
is available at github.com/beckdaniel/acl2018_
graph2seq.

where e = (u, v, (cid:96)e) is the edge between nodes u
and v, N (v) is the set of neighbour nodes for v, ρ
is a non-linear function, σ is the sigmoid function

and cv = cz
constants.
Our

v = cr

v = |Nv|−1 are normalisation

formulation differs from the original
GGNNs from Li et al. (2016) in some aspects:
1) we add bias vectors for the hidden state, re-
set gate and update gate computations; 2) label-
speciﬁc matrices do not share any components; 3)
reset gates are applied to all hidden states before
any computation and 4) we add normalisation con-
stants. These modiﬁcations were applied based on
preliminary experiments and ease of implementa-
tion.

An alternative to GGNNs is the model from
Marcheggiani and Titov (2017), which add edge
label information to Graph Convolutional Net-
works (GCNs). According to Li et al. (2016),
the main difference between GCNs and GGNNs
is analogous to the difference between convolu-
tional and recurrent networks. More speciﬁcally,
GGNNs can be seen as multi-layered GCNs where
layer-wise parameters are tied and gating mecha-
nisms are added. A large number of layers can
propagate node information between longer dis-
tances in the graph and, unlike GCNs, GGNNs
can have an arbitrary number of layers without in-
creasing the number of parameters. Nevertheless,
our architecture borrows ideas from GCNs as well,
such as normalising factors.

2.2 Using GGNNs in attentional
encoder-decoder models

In s2s models, inputs are sequences of tokens
where each token is represented by an embedding
vector. The encoder then transforms these vec-
tors into hidden states by incorporating context,
usually through a recurrent or a convolutional net-
work. These are fed into an attention mechanism,
generating a single context vector that informs de-
cisions in the decoder.

Our model follows a similar structure, where the
encoder is a GGNN that receives node embeddings
as inputs and generates node hidden states as out-
puts, using the graph structure as context. This
is shown in the example of Figure 1, where we
have 4 hidden vectors, one per node in the AMR
graph. The attention and decoder components fol-
low similar standard s2s models, where we use a
bilinear attention mechanism (Luong et al., 2015)
and a 2-layered LSTM (Hochreiter and Schmid-
huber, 1997) as the decoder. Note, however, that
other decoders and attention mechanisms can be

easily employed instead. Bastings et al. (2017)
employs a similar idea for syntax-based NMT, but
using GCNs instead.

2.3 Bidirectionality and positional

embeddings

While our architecture can in theory be used with
general graphs, rooted directed acyclic graphs
(DAGs) are arguably the most common kind in
the problems we are addressing. This means that
node embedding information is propagated in a
top down manner. However, it is desirable to
have information ﬂow from the reverse direction
as well, in the same way RNN-based encoders
beneﬁt from right-to-left propagation (as in bidi-
rectional RNNs). Marcheggiani and Titov (2017)
and Bastings et al. (2017) achieve this by adding
reverse edges to the graph, as well as self-loops
edges for each node. These extra edges have spe-
ciﬁc labels, hence their own parameters in the net-
work.

In this work, we also follow this procedure to
ensure information is evenly propagated in the
graph. However, this raises another limitation: be-
cause the graph becomes essentially undirected,
the encoder is now unaware of any intrinsic hier-
Inspired by Gehring
archy present in the input.
et al. (2017) and Vaswani et al. (2017), we tackle
this problem by adding positional embeddings to
every node. These embeddings are indexed by in-
teger values representing the minimum distance
from the root node and are learned as model pa-
rameters.2 This kind of positional embedding is
restricted to rooted DAGs: for general graphs, dif-
ferent notions of distance could be employed.

3 Levi Graph Transformation

The g2s model proposed in §2 has two key deﬁ-
ciencies. First, GGNNs have three linear transfor-
mations per edge type. This means that the num-
ber of parameters can explode: AMR, for instance,
has around 100 different predicates, which corre-
spond to edge labels. Previous work deal with this
problem by explicitly grouping edge labels into a
single one (Marcheggiani and Titov, 2017; Bast-
ings et al., 2017) but this is not an ideal solution
since it incurs in loss of information.

2Vaswani et al. (2017) also proposed ﬁxed positional em-
beddings based on sine and cosine wavelengths. Preliminary
experiments showed that this approach did not work in our
case: we speculate this is because wavelengths are more suit-
able to sequential inputs.

want-01

believe-01

want-01

believe-01

boy

girl

boy

girl

ARG1

ARG0

ARG1

ARG0

ARG1

ARG0

ARG1

ARG0

the AMR graph from Figure 1
Figure 2: Top:
transformed into its corresponding Levi graph.
Bottom: Levi graph with added reverse and self
edges (colors represent different edge labels).

The second deﬁciency is that edge label in-
formation is encoded in the form of GGNN pa-
rameters in the network. This means that each
label will have the same “representation” across
all graphs. However, the latent information in
edges can depend on the content in which they
appear in a graph.
Ideally, edges should have
instance-speciﬁc hidden states, in the same way
as nodes, and these should also inform decisions
made in the decoder through the attention mod-
ule. For instance, in the AMR graph shown in Fig-
ure 1, the ARG1 predicate between want-01 and
believe-01 can be interpreted as the prepo-
sition “to” in the surface form, while the ARG1
predicate connecting believe-01 and boy is
realised as a pronoun. Notice that edge hidden
vectors are already present in s2s networks that
use linearised graphs: we would like our architec-
ture to also have this beneﬁt.

Instead of modifying the architecture, we pro-
pose to transform the input graph into its equiv-
alent Levi graph (Levi, 1942; Gross and Yellen,
2004, p. 765). Given a graph G = {V, E, LV , LE },

a Levi graph3 is deﬁned as G = {V (cid:48), E (cid:48), LV (cid:48), LE (cid:48)},
where V (cid:48) = V ∪ E, LV (cid:48) = LV ∪ LE and LE (cid:48) = ∅.
The new edge set E (cid:48) contains a edge for every
(node, edge) pair that is present in the original
graph. By deﬁnition, the Levi graph is bipartite.

Intuitively, transforming a graph into its Levi
graph equivalent turns edges into additional nodes.
While simple in theory, this transformation ad-
dresses both modelling deﬁciencies mentioned
above in an elegant way. Since the Levi graph
has no labelled edges there is no risk of parame-
ter explosion: original edge labels are represented
as embeddings, in the same way as nodes. Further-
more, the encoder now naturally generates hidden
states for original edges as well.

In practice, we follow the procedure in §2.3
and add reverse and self-loop edges to the Levi
graph, so the practical edge label vocabulary is
LE (cid:48) = {default, reverse, self}. This still keeps
the parameter space modest since we have only
three labels. Figure 2 shows the transformation
steps in detail, applied to the AMR graph shown
in Figure 1. Notice that the transformed graphs
are the ones fed into our architecture: we show the
original graph in Figure 1 for simplicity.

It is important to note that this transformation
can be applied to any graph and therefore is inde-
pendent of the model architecture. We speculate
this can be beneﬁcial in other kinds of graph-based
encoder such as GCNs and leave further investiga-
tion to future work.

4 Generation from AMR Graphs

Our ﬁrst g2s benchmark is language genera-
tion from AMR, a semantic formalism that repre-
sents sentences as rooted DAGs (Banarescu et al.,
2013). Because AMR abstracts away from syntax,
graphs do not have gold-standard alignment infor-
mation, so generation is not a trivial task. There-
fore, we hypothesize that our proposed model is
ideal for this problem.

4.1 Experimental setup

Data and preprocessing We use the latest AMR
corpus release (LDC2017T10) with the default
split of 36521/1368/1371 instances for training,

3Formally, a Levi graph is deﬁned over any incidence
structure, which is a general concept usually considered in
a geometrical context. Graphs are an example of incidence
structures but so are points and lines in the Euclidean space,
for instance.

development and test sets. Each graph is prepro-
cessed using a procedure similar to what is per-
formed by Konstas et al. (2017), which includes
entity simpliﬁcation and anonymisation. This pre-
processing is done before transforming the graph
into its Levi graph equivalent. For the s2s base-
lines, we also add scope markers as in Konstas
et al. (2017). We detail these procedures in the
Appendix.

Models Our baselines are attentional s2s mod-
els which take linearised graphs as inputs. The
architecture is similar to the one used in Konstas
et al. (2017) for AMR generation, where the en-
coder is a BiLSTM followed by a unidirectional
LSTM. All dimensionalities are ﬁxed to 512.

For the g2s models, we ﬁx the number of layers
in the GGNN encoder to 8, as this gave the best
results on the development set. Dimensionalities
are also ﬁxed at 512 except for the GGNN encoder
which uses 576. This is to ensure all models have
a comparable number of parameters and therefore
similar capacity.

Training for all models uses Adam (Kingma and
Ba, 2015) with 0.0003 initial learning rate and 16
as the batch size.4 To regularise our models we
perform early stopping on the dev set based on
perplexity and apply 0.5 dropout (Srivastava et al.,
2014) on the source embeddings. We detail addi-
tional model and training hyperparameters in the
Appendix.

Evaluation Following previous work, we eval-
uate our models using BLEU (Papineni et al.,
2001) and perform bootstrap resampling to check
since re-
statistical signiﬁcance.
cent work has questioned the effectiveness of
BLEU with bootstrap resampling (Graham et al.,
2014), we also report results using sentence-level
CHRF++ (Popovi´c, 2017), using the Wilcoxon
signed-rank test to check signiﬁcance. Evaluation
is case-insensitive for both metrics.

However,

Recent work has shown that evaluation in neu-
ral models can lead to wrong conclusions by
just changing the random seed (Reimers and
Gurevych, 2017). In an effort to make our con-
clusions more robust, we run each model 5 times
using different seeds. From each pool, we report

4Larger batch sizes hurt dev performance in our prelim-
inary experiments. There is evidence that small batches
can lead to better generalisation performance (Keskar et al.,
2017). While this can make training time slower, it was
doable in our case since the dataset is small.

BLEU CHRF++

#params

Single models
s2s
s2s (-s)
g2s

Ensembles
s2s
s2s (-s)
g2s

21.7
18.4
23.3

26.6
22.0
27.5

49.1
46.3
50.4

52.5
48.9
53.5

28.4M
28.4M
28.3M

142M
142M
141M

–

22.0

Previous work (early AMR treebank versions)
KIYCZ17
Previous work (as above + unlabelled data)
KIYCZ17
PKH16
SPZWG17
FDSC16

33.8
26.9
25.6
22.0

–
–
–
–

–
–
–
–

–

Table 1: Results for AMR generation on the test
set. All score differences between our models and
the corresponding baselines are signiﬁcantly dif-
ferent (p<0.05). “(-s)” means input without scope
marking. KIYCZ17, PKH16, SPZWG17 and
FDSC16 are respectively the results reported in
Konstas et al. (2017), Pourdamghani et al. (2016),
Song et al. (2017) and Flanigan et al. (2016).

results using the median model according to per-
formance on the dev set (simulating what is ex-
pected from a single run) and using an ensemble
of the 5 models.

Finally, we also report the number of parame-
ters used in each model. Since our encoder archi-
tectures are quite different, we try to match the
number of parameters between them by chang-
ing the dimensionality of the hidden layers (as ex-
plained above). We do this to minimise the effects
of model capacity as a confounder.

4.2 Results and analysis

Table 1 shows the results on the test set. For
the s2s models, we also report results without
the scope marking procedure of Konstas et al.
(2017). Our approach signiﬁcantly outperforms
the s2s baselines both with individual models and
ensembles, while using a comparable number of
parameters. In particular, we obtain these results
without relying on scoping heuristics.

On Figure 3 we show an example where our
model outperforms the baseline. The AMR graph
contains four reentrancies, predicates that refer-

Original AMR graph
(p / propose-01

:ARG0 (c / country

:wiki "Russia"
:name (n / name

:op1 "Russia"))

:ARG1 (c5 / cooperate-01

:ARG0 c
:ARG1 (a / and

:op1 (c2 / country

:wiki "India"
:name (n2 / name
:op1 "India"))
:op2 (c3 / country

:wiki "China"
:name (n3 / name

:op1 "China"))))
:purpose (i / increase-01

:ARG0 c5
:ARG1 (s / security)
:location (a2 / around

:op1 (c4 / country

:wiki "Afghanistan"
:name (n4 / name

:op1 "Afghanistan")))

:purpose (b / block-01

:ARG0 (a3 / and

:op1 c :op2 c2 :op3 c3

:ARG1 (s2 / supply-01
:ARG1 (d / drug)))))

Reference surface form
Russia proposes cooperation with India and China to in-
crease security around Afghanistan to block drug supplies.

s2s output (CHRF++ 61.8)
Russia proposed cooperation with India and China to in-
crease security around the Afghanistan to block security
around the Afghanistan , India and China.

g2s output (CHRF++ 78.2)
Russia proposed cooperation with India and China to in-
crease security around Afghanistan to block drug supplies.

Figure 3: Example showing overgeneration due to
reentrancies. Top: original AMR graph with key
reentrancies highlighted. Bottom: reference and
outputs generated by the s2s and g2s models,
highlighting the overgeneration phenomena.

ence previously deﬁned concepts in the graph. In
the s2s models including Konstas et al. (2017),
reentrant nodes are copied in the linearised form,
while this is not necessary for our g2s models.
We can see that the s2s prediction overgenerates
the “India and China” phrase. The g2s predic-
tion avoids overgeneration, and almost perfectly
matches the reference. While this is only a sin-
gle example, it provides evidence that retaining the
full graphical structure is beneﬁcial for this task,
which is corroborated by our quantitative results.

Table 1 also show BLEU scores reported in pre-
vious work. These results are not strictly com-
parable because they used different training set
versions and/or employ additional unlabelled cor-
pora; nonetheless some insights can be made. In
particular, our g2s ensemble performs better than
many previous models that combine a smaller
training set with a large unlabelled corpus. It is
also most informative to compare our s2s model
with Konstas et al. (2017), since this baseline is
very similar to theirs. We expected our single
model baseline to outperform theirs since we use
a larger training set but we obtained similar per-
formance. We speculate that better results could
be obtained by more careful tuning, but neverthe-
less we believe such tuning would also beneﬁt our
proposed g2s architecture.

The best results with unlabelled data are ob-
tained by Konstas et al. (2017) using Gigaword
sentences as additional data and a paired trained
procedure with an AMR parser. It is important to
note that this procedure is orthogonal to the in-
dividual models used for generation and parsing.
Therefore, we hypothesise that our model can also
beneﬁt from such techniques, an avenue that we
leave for future work.

5 Syntax-based Neural Machine

Translation

Our second evaluation is NMT, using as graphs
source language dependency syntax trees. We fo-
cus on a medium resource scenario where addi-
tional linguistic information tends to be more ben-
eﬁcial. Our experiments comprise two language
pairs: English-German and English-Czech.

5.1 Experimental setup

Data and preprocessing We employ the same
data and settings from Bastings et al. (2017),5
which use the News Commentary V11 corpora
from the WMT16 translation task.6 English text
is tokenised and parsed using SyntaxNet7 while
German and Czech texts are tokenised and split
into subwords using byte-pair encodings (Sen-
nrich et al., 2016, BPE) (8000 merge operations).

5We obtained the data from the original authors to ensure
results are comparable without any inﬂuence from prepro-
cessing steps.

6http://www.statmt.org/wmt16/

translation-task.html

7https://github.com/tensorflow/models/

tree/master/syntaxnet

We refer to Bastings et al. (2017) for further infor-
mation on the preprocessing steps.

Labelled dependency trees in the source side are
transformed into Levi graphs as a preprocessing
step. However, unlike AMR generation, in NMT
the inputs are originally surface forms that contain
important sequential information. This informa-
tion is lost when treating the input as dependency
trees, which might explain why Bastings et al.
(2017) obtain the best performance when using an
initial RNN layer in their encoder. To investigate
this phenomenon, we also perform experiments
adding sequential connections to each word in
the dependency tree, corresponding to their order
in the original surface form (henceforth, g2s+).
These connections are represented as edges with
speciﬁc left and right labels, which are added af-
ter the Levi graph transformation. Figure 4 shows
an example of an input graph for g2s+, with the
additional sequential edges connecting the words
(reverse and self edges are omitted for simplicity).

Models Our s2s and g2s models are almost
the same as in the AMR generation experiments
(§4.1). The only exception is the GGNN encoder
dimensionality, where we use 512 for the experi-
ments with dependency trees only and 448 when
the inputs have additional sequential connections.
As in the AMR generation setting, we do this to
ensure model capacity are comparable in the num-
ber of parameters. Another key difference is that
the s2s baselines do not use dependency trees:
they are trained on the sentences only.

In addition to neural models, we also report re-
sults for Phrase-Based Statistical MT (PB-SMT),
using Moses (Koehn et al., 2007). The PB-SMT
models are trained using the same data conditions
as s2s (no dependency trees) and use the standard
setup in Moses, except for the language model,
where we use a 5-gram LM trained on the target
side of the respective parallel corpus.8

Evaluation We report results in terms of BLEU
and CHRF++, using case-sensitive versions of both
metrics. Other settings are kept the same as in
the AMR generation experiments (§4.1). For PB-
SMT, we also report the median result of 5 runs,
obtained by tuning the model using MERT (Och
and Ney, 2002) 5 times.

8Note that target data is segmented using BPE, which is
not the usual setting for PB-SMT. We decided to keep the
segmentation to ensure data conditions are the same.

ROOT

punct

nsubj

det

expl

amod

prep

pobj

There is a deeper issue at stake .

There

is

a

deeper

issue

stake

at

.

ROOT

expl

nsubj

punct

det

amod

prep

pobj

Figure 4: Top: a sentence with its corresponding
dependency tree. Bottom:
the transformed tree
into a Levi graph with additional sequential con-
nections between words (dashed lines). The full
graph also contains reverse and self edges, which
are omitted in the ﬁgure.

5.2 Results and analysis

Table 2 shows the results on the respective test set
for both language pairs. The g2s models, which
do not account for sequential information, lag be-
hind our baselines. This is in line with the ﬁndings
of Bastings et al. (2017), who found that having a
BiRNN layer was key to obtain the best results.
However, the g2s+ models outperform the base-
lines in terms of BLEU scores under the same pa-
rameter budget, in both single model and ensem-
ble scenarios. This result show that it is possible to
incorporate sequential biases in our model without
relying on RNNs or any other modiﬁcation in the
architecture.

English-German

BLEU CHRF++ #params

Single models
PB-SMT
s2s
g2s
g2s+

Ensembles
s2s
g2s
g2s+

Single models
PB-SMT
s2s
g2s
g2s+

Ensembles
s2s
g2s
g2s+

12.8
15.5
15.2
16.7

19.0
17.7
19.6

8.6
8.9
8.7
9.8

11.3
10.4
11.7

43.2
40.8
41.4
42.4

44.1
43.5
45.1

36.4
33.8
32.3
33.3

36.4
34.7
35.9

Results from (Bastings et al., 2017)
BoW+GCN
BiRNN
BiRNN+GCN

–
–
–
English-Czech

12.2
14.9
16.1

BLEU CHRF++ #params

–
41.4M
40.8M
41.2M

207M
204M
206M

–
–
–

–
–
–

–
39.1M
38.4M
38.8M

195M
192M
194M

Results from (Bastings et al., 2017)
BoW+GCN
BiRNN
BiRNN+GCN

7.5
8.9
9.6

–
–
–

Table 2: Results for syntax-based NMT on the test
sets. All score differences between our models and
the corresponding baselines are signiﬁcantly dif-
ferent (p<0.05), including the negative CHRF++
result for En-Cs.

Interestingly, we found different trends when
analysing the CHRF++ numbers. In particular, this
metric favours the PB-SMT models for both lan-
guage pairs, while also showing improved perfor-
mance for s2s in En-Cs. CHRF++ has been shown
to better correlate with human judgments com-
pared to BLEU, both at system and sentence level
for both language pairs (Bojar et al., 2017), which
motivated our choice as an additional metric. We
leave further investigation of this phenomena for
future work.

We also show some of the results reported by
Bastings et al. (2017) in Table 2. Note that their
results were based on a different implementation,
which may explain some variation in performance.
Their BoW+GCN model is the most similar to
ours, as it uses only an embedding layer and a
GCN encoder. We can see that even our sim-
pler g2s model outperforms their results. A key
difference between their approach and ours is the
Levi graph transformation and the resulting hidden
vectors for edges. We believe their architecture
would also beneﬁt from our proposed transforma-
tion. In terms of baselines, s2s performs better
than their BiRNN model for En-De and compara-
bly for En-Cs, which corroborates that our base-
lines are strong ones. Finally, our g2s+ single
models outperform their BiRNN+GCN results, in
particular for En-De, which is further evidence
that RNNs are not necessary for obtaining the best
performance in this setting.

An important point about these experiments is
that we did not tune the architecture: we simply
employed the same model we used in the AMR
generation experiments, only adjusting the dimen-
sionality of the encoder to match the capacity of
the baselines. We speculate that even better re-
sults would be obtained by tuning the architecture
to this task. Nevertheless, we still obtained im-
proved performance over our baselines and previ-
ous work, underlining the generality of our archi-
tecture.

6 Related work

Graph-to-sequence modelling Early NLP ap-
proaches for this problem were based on Hy-
peredge Replacement Grammars (Drewes et al.,
1997, HRGs). These grammars assume the trans-
duction problem can be split into rules that map
portions of a graph to a set of tokens in the out-
put sequence. In particular, Chiang et al. (2013)
deﬁnes a parsing algorithm, followed by a com-
plexity analysis, while Jones et al. (2012) report
experiments on semantic-based machine transla-
tion using HRGs. HRGs were also used in pre-
vious work on AMR parsing (Peng et al., 2015).
The main drawback of these grammar-based ap-
proaches though is the need for alignments be-
tween graph nodes and surface tokens, which are
usually not available in gold-standard form.

Neural networks for graphs Recurrent net-
works on general graphs were ﬁrst proposed un-

der the name Graph Neural Networks (Gori et al.,
2005; Scarselli et al., 2009). Our work is based
on the architecture proposed by Li et al. (2016),
which add gating mechanisms. The main differ-
ence between their work and ours is that they fo-
cus on problems that concern the input graph it-
self such as node classiﬁcation or path ﬁnding
while we focus on generating strings. The main
alternative for neural-based graph representations
is Graph Convolutional Networks (Bruna et al.,
2014; Duvenaud et al., 2015; Kipf and Welling,
2017), which have been applied in a range of prob-
lems. In NLP, Marcheggiani and Titov (2017) use
a similar architecture for Semantic Role Labelling.
They use heuristics to mitigate the parameter ex-
plosion by grouping edge labels, while we keep
the original labels through our Levi graph trans-
formation. An interesting alternative is proposed
by Schlichtkrull et al. (2017), which uses tensor
factorisation to reduce the number of parameters.

Applications Early work on AMR generation
employs grammars and transducers (Flanigan
et al., 2016; Song et al., 2017). Linearisation ap-
proaches include (Pourdamghani et al., 2016) and
(Konstas et al., 2017), which showed that graph
simpliﬁcation and anonymisation are key to good
performance, a procedure we also employ in our
work. However, compared to our approach, lin-
earisation incurs in loss of information. MT has a
long history of previous work that aims at incor-
porating syntax (Wu, 1997; Yamada and Knight,
2001; Galley et al., 2004; Liu et al., 2006, inter
alia). This idea has also been investigated in the
context of NMT. Bastings et al. (2017) is the most
similar work to ours, and we benchmark against
their approach in our NMT experiments. Eriguchi
et al. (2016) also employs source syntax, but us-
ing constituency trees instead. Other approaches
have investigated the use of syntax in the target
language (Aharoni and Goldberg, 2017; Eriguchi
et al., 2017). Finally, Hashimoto and Tsuruoka
(2017) treats source syntax as a latent variable,
which can be pretrained using annotated data.

7 Discussion and Conclusion

We proposed a novel encoder-decoder architec-
ture for graph-to-sequence learning, outperform-
ing baselines in two NLP tasks:
generation
from AMR graphs and syntax-based NMT. Our
approach addresses shortcomings from previous
work, including loss of information from lineari-

sation and parameter explosion. In particular, we
showed how graph transformations can solve is-
sues with graph-based networks without chang-
ing the underlying architecture. This is the case
of the proposed Levi graph transformation, which
ensures the decoder can attend to edges as well
as nodes, but also to the sequential connections
added to the dependency trees in the case of NMT.
Overall, because our architecture can work with
general graphs, it is straightforward to add linguis-
tic biases in the form of extra node and/or edge
information. We believe this is an interesting re-
search direction in terms of applications.

Our architecture nevertheless has two major
limitations. The ﬁrst one is that GGNNs have a
ﬁxed number of layers, even though graphs can
vary in size in terms of number of nodes and
edges. A better approach would be to allow the
encoder to have a dynamic number of layers, pos-
sibly based on the diameter (longest path) in the
input graph. The second limitation comes from
the Levi graph transformation: because edge la-
bels are represented as nodes they end up shar-
ing the vocabulary and therefore, the same seman-
tic space. This is not ideal, as nodes and edges
are different entities. An interesting alternative is
Weave Module Networks (Kearnes et al., 2016),
which explicitly decouples node and edge repre-
sentations without incurring in parameter explo-
sion. Incorporating both ideas to our architecture
is an research direction we plan for future work.

Acknowledgements

This work was supported by the Australian Re-
search Council (DP160102686). The research
reported in this paper was partly conducted at
the 2017 Frederick Jelinek Memorial Summer
Workshop on Speech and Language Technolo-
gies, hosted at Carnegie Mellon University and
sponsored by Johns Hopkins University with un-
restricted gifts from Amazon, Apple, Facebook,
Google, and Microsoft. The authors would also
like to thank Joost Bastings for sharing the data
from his paper’s experiments.

References

Roee Aharoni and Yoav Goldberg. 2017. Towards
String-to-Tree Neural Machine Translation. In Pro-
ceedings of ACL. pages 132–140.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Grifﬁtt, Ulf Hermjakob, Kevin

Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract Meaning Representation
for Sembanking. In Proceedings of the 7th Linguis-
tic Annotation Workshop and Interoperability with
Discourse. pages 178–186.

Joost Bastings,

Ivan Titov, Wilker Aziz, Diego
Marcheggiani, and Khalil Sima’an. 2017. Graph
Convolutional Encoders for Syntax-aware Neural
In Proceedings of EMNLP.
Machine Translation.
pages 1947–1957.

Ondej Bojar, Yvette Graham, and Amir Kamran. 2017.
Results of the WMT17 Metrics Shared Task. In Pro-
ceedings of WMT. volume 2, pages 293–301.

Joan Bruna, Wojciech Zaremba, Arthur Szlam, and
Yann LeCun. 2014. Spectral Networks and Locally
Connected Networks on Graphs. In Proceedings of
ICLR. page 14.

Tianqi Chen, Mu Li, Yutian Li, Min Lin, Naiyan Wang,
Minjie Wang, Tianjun Xiao, Bing Xu, Chiyuan
Zhang, and Zheng Zhang. 2015. MXNet: A Flexible
and Efﬁcient Machine Learning Library for Hetero-
geneous Distributed Systems. In Proceedings of the
Workshop on Machine Learning Systems. pages 1–6.

David Chiang,

Jacob Andreas, Daniel Bauer,
Karl Moritz Hermann, Bevan Jones, and Kevin
Parsing Graphs with Hyperedge
Knight. 2013.
In Proceedings of ACL.
Replacement Grammars.
pages 924–932.

Kyunghyun Cho, Bart van Merrienboer, Caglar Gul-
cehre, Dzmitry Bahdanau, Fethi Bougares, Hol-
ger Schwenk, and Yoshua Bengio. 2014. Learn-
ing Phrase Representations using RNN Encoder-
Decoder for Statistical Machine Translation. In Pro-
ceedings of EMNLP. pages 1724–1734.

Frank Drewes, Hans J¨org Kreowski, and Annegret Ha-
bel. 1997. Hyperedge Replacement Graph Gram-
mars. Handbook of Graph Grammars and Comput-
ing by Graph Transformation .

David Duvenaud, Dougal Maclaurin, Jorge Aguilera-
Iparraguirre, Rafael G´omez-Bombarelli, Timothy
Hirzel, Al´an Aspuru-Guzik, and Ryan P Adams.
2015.
Convolutional Networks on Graphs for
Learning Molecular Fingerprints. In Proceedings of
NIPS. pages 2215–2223.

Akiko Eriguchi, Kazuma Hashimoto, and Yoshimasa
Tsuruoka. 2016. Tree-to-Sequence Attentional Neu-
ral Machine Translation. In Proceedings of ACL.

Akiko Eriguchi, Yoshimasa Tsuruoka, and Kyunghyun
Cho. 2017. Learning to Parse and Translate Im-
proves Neural Machine Translation. In Proceedings
of ACL.

Jeffrey Flanigan, Chris Dyer, Noah A. Smith, and
Jaime Carbonell. 2016. Generation from Abstract
Meaning Representation using Tree Transducers. In
Proceedings of NAACL. pages 731–739.

Jeffrey Flanigan, Sam Thomson, Jaime Carbonell,
Chris Dyer, and Noah a Smith. 2014. A Discrimi-
native Graph-Based Parser for the Abstract Meaning
Representation. In Proceedings of ACL.

Michel Galley, Mark Hopkins, Kevin Knight, and
Daniel Marcu. 2004. What’s in a translation rule?
In Proceedings of NAACL. pages 273–280.

Jonas Gehring, Michael Auli, David Grangier, Denis
Yarats, and Yann N. Dauphin. 2017. Convolutional
Sequence to Sequence Learning. arXiv preprint .

Xavier Glorot and Yoshua Bengio. 2010. Understand-
ing the Difﬁculty of Training Deep Feedforward
Neural Networks. In Proceedings of AISTATS. vol-
ume 9, pages 249–256.

Marco Gori, Gabriele Monfardini,

and Franco
Scarselli. 2005. A New Model for Learning in
In Proceedings of IJCNN. vol-
Graph Domains.
ume 2, pages 729–734.

Yvette Graham, Nitika Mathur, and Timothy Baldwin.
2014. Randomized Signiﬁcance Tests in Machine
In Proceedings of WMT. pages 266–
Translation.
274.

Jonathan Gross and Jay Yellen, editors. 2004. Hand-

book of Graph Theory. CRC Press.

Kazuma Hashimoto and Yoshimasa Tsuruoka. 2017.
Neural Machine Translation with Source-Side La-
In Proceedings of EMNLP.
tent Graph Parsing.
pages 125–135.

Felix Hieber, Tobias Domhan, Michael Denkowski,
David Vilar, Artem Sokolov, Ann Clifton, and Matt
Post. 2017. Sockeye: A Toolkit for Neural Machine
Translation. arXiv preprint pages 1–18.

Sepp Hochreiter and J¨urgen Schmidhuber. 1997.
Long Short-Term Memory. Neural Computation
9(8):1735–1780.

Bevan

Jones,

Jacob Andreas, Daniel Bauer,
Karl Moritz Hermann, and Kevin Knight. 2012.
Semantics-Based Machine Translation with Hyper-
In Proceedings of
edge Replacement Grammars.
COLING. pages 1359–1376.

Steven Kearnes, Kevin McCloskey, Marc Berndl, Vi-
jay Pande, and Patrick Riley. 2016. Molecu-
lar Graph Convolutions: Moving Beyond Finger-
prints. Journal of Computer-Aided Molecular De-
sign 30(8):595–608.

Nitish Shirish Keskar, Dheevatsa Mudigere, Jorge No-
cedal, Mikhail Smelyanskiy, and Ping Tak Peter
Tang. 2017. On Large-Batch Training for Deep
Learning: Generalization Gap and Sharp Minima.
In Proceedings of ICLR. pages 1–16.

Diederik P. Kingma and Jimmy Ba. 2015. Adam: A
In Proceed-

Method for Stochastic Optimization.
ings of ICLR. pages 1–15.

Thomas N. Kipf and Max Welling. 2017.

Semi-
Supervised Classiﬁcation with Graph Convolutional
Networks. In Proceedings of ICLR.

Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris
Callison-Burch, Marcello Federico, Nicola Bertoldi,
Brooke Cowan, Wade Shen, Christine Moran,
Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra
Constantin, and Evan Herbst. 2007. Moses: Open
source toolkit for statistical machine translation. In
Proceedings of ACL Demo Session. pages 177–180.

Ioannis Konstas, Srinivasan Iyer, Mark Yatskar, Yejin
Choi, and Luke Zettlemoyer. 2017. Neural AMR:
Sequence-to-Sequence Models for Parsing and Gen-
eration. In Proceedings of ACL. pages 146–157.

Friedrich Wilhelm Levi. 1942. Finite Geometrical Sys-

tems.

Yujia Li, Daniel Tarlow, Marc Brockschmidt, and
Richard Zemel. 2016. Gated Graph Sequence Neu-
ral Networks. In Proceedings of ICLR. 1, pages 1–
20.

Yang Liu, Qun Liu, and Shouxun Lin. 2006. Tree-
to-string alignment template for statistical machine
translation. In Proceedings of the 21st International
Conference on Computational Linguistics and the
44th annual meeting of the ACL - ACL ’06. pages
609–616.

Minh-Thang Luong, Hieu Pham, and Christopher D.
Manning. 2015. Effective Approaches to Attention-
based Neural Machine Translation. In Proceedings
of EMNLP. pages 1412–1421.

Diego Marcheggiani and Ivan Titov. 2017. Encod-
ing Sentences with Graph Convolutional Networks
In Proceedings of
for Semantic Role Labeling.
EMNLP.

Franz Josef Och and Hermann Ney. 2002. Dis-
criminative training and maximum entropy mod-
In Proceed-
els for statistical machine translation.
ings of the 40th Annual Meeting on Association
for Computational Linguistics - ACL ’02. page 295.
https://doi.org/10.3115/1073083.1073133.

Kishore Papineni, Salim Roukos, Todd Ward, and Wei-
Jing Zhu. 2001. Bleu: a method for automatic eval-
In Proceedings of
uation of machine translation.
ACL. pages 311–318.

Xiaochang Peng, Linfeng Song, and Daniel Gildea.
2015. A Synchronous Hyperedge Replacement
Grammar based approach for AMR parsing. In Pro-
ceedings of CoNLL. pages 32–41.

Maja Popovi´c. 2017. chrF ++: words helping character
n-grams. In Proceedings of WMT. pages 612–618.

Nima Pourdamghani, Yang Gao, Ulf Hermjakob, and
Kevin Knight. 2014. Aligning English Strings with
In Pro-
Abstract Meaning Representation Graphs.
ceedings of EMNLP. pages 425–429.

Nima Pourdamghani, Kevin Knight, and Ulf Herm-
jakob. 2016. Generating English from Abstract
Meaning Representations. In Proceedings of INLG.
volume 0, pages 21–25.

Nils Reimers and Iryna Gurevych. 2017. Reporting
Score Distributions Makes a Difference: Perfor-
mance Study of LSTM-networks for Sequence Tag-
ging. In Proceedings of EMNLP. pages 338–348.

Franco Scarselli, Marco Gori, Ah Ching Tsoi, and
Gabriele Monfardini. 2009. The Graph Neural Net-
IEEE Transactions on Neural Net-
work Model.
works 20(1):61–80.

Michael Schlichtkrull, Thomas N. Kipf, Peter Bloem,
Rianne van den Berg, Ivan Titov, and Max Welling.
2017. Modeling Relational Data with Graph Convo-
lutional Networks pages 1–12.

Rico Sennrich, Barry Haddow, and Alexandra Birch.
2016. Neural Machine Translation of Rare Words
with Subword Units. In Proceedings of ACL. pages
1715–1725.

Linfeng Song, Xiaochang Peng, Yue Zhang, Zhiguo
Wang, and Daniel Gildea. 2017. AMR-to-text Gen-
eration with Synchronous Node Replacement Gram-
mar. In Proceedings of ACL. pages 7–13.

Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky,
Ilya Sutskever, and Ruslan Salakhutdinov. 2014.
Dropout: A Simple Way to Prevent Neural Networks
from Overﬁtting. Journal of Machine Learning Re-
search 15:1929–1958.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob
Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz
Kaiser, and Illia Polosukhin. 2017. Attention Is All
You Need. In Proceedings of NIPS.

Dekai Wu. 1997. Stochastic inversion transduction
grammars and bilingual parsing of parallel corpora.
Computational Linguistics 23(3):377–403.

Kenji Yamada and Kevin Knight. 2001. A Syntax-
based Statistical Translation Model. In Proceedings
of ACL. pages 523–530.

A Simpliﬁcation and Anonymisation for

AMR graphs

The procedure for graph simpliﬁcation and
anonymisation is similar to what is done by (Kon-
stas et al., 2017). The main difference is that
we use the alignments provided by the original
LDC version of the AMR corpus, while they
use a combination of the JAMR aligner (Flani-
gan et al., 2014) and the unsupervised aligner of
(Pourdamghani et al., 2014). This preprocessing
is done before transforming the graph into its bi-
partite equivalent.

Simpliﬁcation: we

remove

informa-
instance,
tion from the concepts.
believe-01 becomes believe. We also
remove any subgraphs related to wikiﬁcation
(the ones starting the predicate :wiki).

sense
For

Entity anonymisation: all

subgraphs

starting
with the predicate :name are anonymised.
The predicate contains one of the AMR
entity names as the source node, such as
country or *-quantity.
These are
replaced by a single anonymised node,
containing the original entity concept plus an
index. At training time, we use the alignment
information to ﬁnd the corresponding entity
in the surface form and replace all aligned
tokens with the same concept name. At
test time, we extract a map that maps the
anonymised entity to all concept names in
in depth-ﬁrst order. After
the subgraph,
prediction, if there is an anonymised token in
the surface form it is replaced using that map
(as long as the predicted token is present in
the map).

Enitity clustering: entities are also clustered into
four coarse-grained types in both graph and
surface form. For instance country 0 be-
comes loc 0. We use the list obtained from
the open source implementation of (Konstas
et al., 2017) for that.

Date anonymisation: if

there

training time,
anonymised

a
is
date-entity concept,
all underlying
concepts are also anonymised, using sep-
arate tokens for day, month and year.
the surface form is
At
also
align-
following
ment, but we additionally split days and
months into day name, day number,
month name and month number. At test
time, we render the day/month according
to the predicted anonymised token in the
surface form and the recorded map.

the

B Model Hyperparameters

Our implementation is based on the Sockeye
toolkit for Neural Machine Translation (Hieber
et al., 2017). Besides the speciﬁc hyperparameter
values mentioned in the paper, all other hyperpa-
rameters are set to the default values in Sockeye.
We detail them here for completeness:

B.1 Vocabulary

• For AMR, we set the minimum frequency to
2 in both source nodes and target surface to-
kens. For NMT, we also use 2 as the mini-
mum frequency in the source but use 1 in the
target since we use BPE tokens.

B.2 Model

• The baseline encoder use a BiLSTM fol-
lowed by a unidirectional LSTM. The de-
coder in all models use a 2-layer LSTM.

• The attention module uses a bilinear scoring
function (general as in (Luong et al., 2015)).

• The max sequence length during training is
200 for AMR. In NMT, we use 100 for the
s2s baselines and 200 for the g2s models.
This is because we do not use dependency
trees in the baseline so it naturally has half
of the tokens.

• All dimensionalities are ﬁxed to 512, which
is similar to what is used by (Konstas et al.,
2017). The only exceptions are the GGNN
hidden state dimensionality in the g2s mod-
els. We use 576 for the g2s models used in
the AMR experiments and 448 for the g2s+
models used in the NMT experiments. As
pointed out in the main paper, we change
GGNN dimensionalities in order to have a
similar parameter budget compared to the
s2s baselines.

B.3 Training

These options apply for both s2s baselines and
g2s g2s+ models.

• We use 16 as the batch size. This is a lower
number than most previous work we com-
pare with: we choose this because we ob-
tained better results in the AMR dev set.
This is in line with recent evidence showing
that smaller batch sizes lead to better gener-
alisation performance (Keskar et al., 2017).
The drawback is that smaller batches makes
training time slower. However, this was not
a problem in our experiments due to the
medium size of the datasets.

• Bucketing is used to speed up training: we

use 10 as the bucket size.

• Models are trained using cross-entropy as the

loss.

• We save parameter checkpoints at every full

epoch on the training set.

• We use early stopping by perplexity on the
dev set with patience 8 (training stops if dev
perplexity do not improve for 8 checkpoints).

• A maximum of 30 epochs/checkpoints is
used. All our models stopped training before
reaching this limit.

• We use 0.5 dropout on the input embeddings,

before they are fed to the encoder.

• Weigths are initalised using Xavier initialisa-
tion (Glorot and Bengio, 2010), with except
of forget biases in the LSTMs which are ini-
tialised by 0.

• We use Adam (Kingma and Ba, 2015) as the
optimiser with 0.0003 as the initial learning
rate.

• Learning

rate
dev perplexity does not
epochs/checkpoints.

is

halved

every

time
improve for 3

• Gradient clipping is set to 1.0.

B.4 Decoding

beam size.

• We use beam search to decode, using 5 as the

• Ensembles are created by averaging log prob-
abilities at every step (linear in Sockeye). At-
tention scores are averaged over the 5 models
at every step.

• For AMR only, we replace <unk> tokens in
the prediction with the node with the highest
attention score at that step, in the same way
described by (Konstas et al., 2017). This is
done before deanonymisation.

Graph-to-Sequence Learning using Gated Graph Neural Networks

Daniel Beck†

Trevor Cohn†

Gholamreza Haffari‡
†School of Computing and Information Systems
University of Melbourne, Australia
{d.beck,t.cohn}@unimelb.edu.au
‡Faculty of Information Technology
Monash University, Australia
gholamreza.haffari@monash.edu

Abstract

Many NLP applications can be framed
as a graph-to-sequence learning problem.
Previous work proposing neural architec-
tures on this setting obtained promising
results compared to grammar-based ap-
proaches but still rely on linearisation
heuristics and/or standard recurrent net-
works to achieve the best performance.
In this work, we propose a new model
that encodes the full structural informa-
tion contained in the graph. Our ar-
chitecture couples the recently proposed
Gated Graph Neural Networks with an in-
put transformation that allows nodes and
edges to have their own hidden represen-
tations, while tackling the parameter ex-
plosion problem present in previous work.
Experimental results show that our model
outperforms strong baselines in generation
from AMR graphs and syntax-based neu-
ral machine translation.

1

Introduction

Graph structures are ubiquitous in representations
In particular, many whole-
of natural language.
sentence semantic frameworks employ directed
acyclic graphs as the underlying formalism, while
most tree-based syntactic representations can also
be seen as graphs. A range of NLP applications
can be framed as the process of transducing a
graph structure into a sequence. For instance, lan-
guage generation may involve realising a semantic
graph into a surface form and syntactic machine
translation involves transforming a tree-annotated
source sentence to its translation.

Previous work in this setting rely on grammar-
based approaches such as tree transducers (Flani-
gan et al., 2016) and hyperedge replacement gram-

mars (Jones et al., 2012). A key limitation of
these approaches is that alignments between graph
nodes and surface tokens are required. These
alignments are usually automatically generated
so they can propagate errors when building the
grammar. More recent approaches transform the
graph into a linearised form and use off-the-shelf
methods such as phrase-based machine translation
(Pourdamghani et al., 2016) or neural sequence-
to-sequence (henceforth, s2s) models (Konstas
et al., 2017). Such approaches ignore the full
graph structure, discarding key information.

In this work we propose a model for graph-to-
sequence (henceforth, g2s) learning that lever-
ages recent advances in neural encoder-decoder
architectures. Speciﬁcally, we employ an encoder
based on Gated Graph Neural Networks (Li et al.,
2016, GGNNs), which can incorporate the full
graph structure without loss of information. Such
networks represent edge information as label-wise
parameters, which can be problematic even for
small sized label vocabularies (in the order of hun-
dreds). To address this limitation, we also intro-
duce a graph transformation that changes edges to
additional nodes, solving the parameter explosion
problem. This also ensures that edges have graph-
speciﬁc hidden vectors, which gives more infor-
mation to the attention and decoding modules in
the network.

We benchmark our model

in two graph-to-
sequence problems, generation from Abstract
Meaning Representations (AMRs) and Neural
Machine Translation (NMT) with source depen-
dency information. Our approach outperforms
strong s2s baselines in both tasks without relying
on standard RNN encoders, in contrast with pre-
vious work. In particular, for NMT we show that
we avoid the need for RNNs by adding sequen-
tial edges between contiguous words in the depen-
dency tree. This illustrates the generality of our

8
1
0
2
 
n
u
J
 
6
2
 
 
]
L
C
.
s
c
[
 
 
1
v
5
3
8
9
0
.
6
0
8
1
:
v
i
X
r
a

want-01

A

R

G

1

0
G
R
A

boy

A R G 1

believe-01

A

R

G

0

girl

the AMR graph representing the sentence “The boy wants the girl to believe him.”.
Figure 1: Left:
Right: Our proposed architecture using the same AMR graph as input and the surface form as output.
The ﬁrst layer is a concatenation of node and positional embeddings, using distance from the root node
as the position. The GGNN encoder updates the embeddings using edge-wise parameters, represented by
different colors (in this example, ARG0 and ARG1). The encoder also add corresponding reverse edges
(dotted arrows) and self edges for each node (dashed arrows). All parameters are shared between layers.
Attention and decoder components are similar to standard s2s models. This is a pictorial representation:
in our experiments the graphs are transformed before being used as inputs (see §3).

approach: linguistic biases can be added to the in-
puts by simple graph transformations, without the
need for changes to the model architecture.

2 Neural Graph-to-Sequence Model

Our proposed architecture is shown in Figure 1,
with an example AMR graph and its transforma-
tion into its surface form. Compared to standard
s2s models, the main difference is in the encoder,
where we employ a GGNN to build a graph repre-
sentation. In the following we explain the compo-
nents of this architecture in detail.1

2.1 Gated Graph Neural Networks

Early approaches for recurrent networks on graphs
(Gori et al., 2005; Scarselli et al., 2009) assume
a ﬁxed point representation of the parameters and
learn using contraction maps. Li et al. (2016) ar-
gues that this restricts the capacity of the model
and makes it harder to learn long distance rela-
tions between nodes. To tackle these issues, they
propose Gated Graph Neural Networks, which ex-
tend these architectures with gating mechanisms

in a similar fashion to Gated Recurrent Units (Cho
et al., 2014). This allows the network to be learnt
via modern backpropagation procedures.

In following, we formally deﬁne the version of
GGNNs we employ in this study. Assume a di-
rected graph G = {V, E, LV , LE }, where V is a
set of nodes (v, (cid:96)v), E is a set of edges (vi, vj, (cid:96)e)
and LV and LE are respectively vocabularies for
nodes and edges, from which node and edge la-
bels ((cid:96)v and (cid:96)e) are deﬁned. Given an input graph
with nodes mapped to embeddings X, a GGNN is
deﬁned as

Wr

(cid:96)eh(t−1)
u

+ br
(cid:96)e

h0

v = xv
(cid:32)

rt
v = σ

cr
v

(cid:88)

u∈Nv

(cid:88)

u∈Nv

(cid:88)

(cid:32)

(cid:32)

zt
v = σ

cz
v

Wz

(cid:96)eh(t−1)
u

+ bz
(cid:96)e

(cid:101)ht
v = ρ

cv

W(cid:96)e

u (cid:12) h(t−1)
rt
u

+ b(cid:96)e

(cid:16)

(cid:33)

v = (1 − zt
ht

u∈Nv
v) (cid:12) h(i−1)
v

+ zt

v (cid:12) (cid:101)ht
v

(cid:33)

(cid:33)

(cid:17)

1Our implementation uses MXNet (Chen et al., 2015) and
is based on the Sockeye toolkit (Hieber et al., 2017). Code
is available at github.com/beckdaniel/acl2018_
graph2seq.

where e = (u, v, (cid:96)e) is the edge between nodes u
and v, N (v) is the set of neighbour nodes for v, ρ
is a non-linear function, σ is the sigmoid function

and cv = cz
constants.
Our

v = cr

v = |Nv|−1 are normalisation

formulation differs from the original
GGNNs from Li et al. (2016) in some aspects:
1) we add bias vectors for the hidden state, re-
set gate and update gate computations; 2) label-
speciﬁc matrices do not share any components; 3)
reset gates are applied to all hidden states before
any computation and 4) we add normalisation con-
stants. These modiﬁcations were applied based on
preliminary experiments and ease of implementa-
tion.

An alternative to GGNNs is the model from
Marcheggiani and Titov (2017), which add edge
label information to Graph Convolutional Net-
works (GCNs). According to Li et al. (2016),
the main difference between GCNs and GGNNs
is analogous to the difference between convolu-
tional and recurrent networks. More speciﬁcally,
GGNNs can be seen as multi-layered GCNs where
layer-wise parameters are tied and gating mecha-
nisms are added. A large number of layers can
propagate node information between longer dis-
tances in the graph and, unlike GCNs, GGNNs
can have an arbitrary number of layers without in-
creasing the number of parameters. Nevertheless,
our architecture borrows ideas from GCNs as well,
such as normalising factors.

2.2 Using GGNNs in attentional
encoder-decoder models

In s2s models, inputs are sequences of tokens
where each token is represented by an embedding
vector. The encoder then transforms these vec-
tors into hidden states by incorporating context,
usually through a recurrent or a convolutional net-
work. These are fed into an attention mechanism,
generating a single context vector that informs de-
cisions in the decoder.

Our model follows a similar structure, where the
encoder is a GGNN that receives node embeddings
as inputs and generates node hidden states as out-
puts, using the graph structure as context. This
is shown in the example of Figure 1, where we
have 4 hidden vectors, one per node in the AMR
graph. The attention and decoder components fol-
low similar standard s2s models, where we use a
bilinear attention mechanism (Luong et al., 2015)
and a 2-layered LSTM (Hochreiter and Schmid-
huber, 1997) as the decoder. Note, however, that
other decoders and attention mechanisms can be

easily employed instead. Bastings et al. (2017)
employs a similar idea for syntax-based NMT, but
using GCNs instead.

2.3 Bidirectionality and positional

embeddings

While our architecture can in theory be used with
general graphs, rooted directed acyclic graphs
(DAGs) are arguably the most common kind in
the problems we are addressing. This means that
node embedding information is propagated in a
top down manner. However, it is desirable to
have information ﬂow from the reverse direction
as well, in the same way RNN-based encoders
beneﬁt from right-to-left propagation (as in bidi-
rectional RNNs). Marcheggiani and Titov (2017)
and Bastings et al. (2017) achieve this by adding
reverse edges to the graph, as well as self-loops
edges for each node. These extra edges have spe-
ciﬁc labels, hence their own parameters in the net-
work.

In this work, we also follow this procedure to
ensure information is evenly propagated in the
graph. However, this raises another limitation: be-
cause the graph becomes essentially undirected,
the encoder is now unaware of any intrinsic hier-
Inspired by Gehring
archy present in the input.
et al. (2017) and Vaswani et al. (2017), we tackle
this problem by adding positional embeddings to
every node. These embeddings are indexed by in-
teger values representing the minimum distance
from the root node and are learned as model pa-
rameters.2 This kind of positional embedding is
restricted to rooted DAGs: for general graphs, dif-
ferent notions of distance could be employed.

3 Levi Graph Transformation

The g2s model proposed in §2 has two key deﬁ-
ciencies. First, GGNNs have three linear transfor-
mations per edge type. This means that the num-
ber of parameters can explode: AMR, for instance,
has around 100 different predicates, which corre-
spond to edge labels. Previous work deal with this
problem by explicitly grouping edge labels into a
single one (Marcheggiani and Titov, 2017; Bast-
ings et al., 2017) but this is not an ideal solution
since it incurs in loss of information.

2Vaswani et al. (2017) also proposed ﬁxed positional em-
beddings based on sine and cosine wavelengths. Preliminary
experiments showed that this approach did not work in our
case: we speculate this is because wavelengths are more suit-
able to sequential inputs.

want-01

believe-01

want-01

believe-01

boy

girl

boy

girl

ARG1

ARG0

ARG1

ARG0

ARG1

ARG0

ARG1

ARG0

the AMR graph from Figure 1
Figure 2: Top:
transformed into its corresponding Levi graph.
Bottom: Levi graph with added reverse and self
edges (colors represent different edge labels).

The second deﬁciency is that edge label in-
formation is encoded in the form of GGNN pa-
rameters in the network. This means that each
label will have the same “representation” across
all graphs. However, the latent information in
edges can depend on the content in which they
appear in a graph.
Ideally, edges should have
instance-speciﬁc hidden states, in the same way
as nodes, and these should also inform decisions
made in the decoder through the attention mod-
ule. For instance, in the AMR graph shown in Fig-
ure 1, the ARG1 predicate between want-01 and
believe-01 can be interpreted as the prepo-
sition “to” in the surface form, while the ARG1
predicate connecting believe-01 and boy is
realised as a pronoun. Notice that edge hidden
vectors are already present in s2s networks that
use linearised graphs: we would like our architec-
ture to also have this beneﬁt.

Instead of modifying the architecture, we pro-
pose to transform the input graph into its equiv-
alent Levi graph (Levi, 1942; Gross and Yellen,
2004, p. 765). Given a graph G = {V, E, LV , LE },

a Levi graph3 is deﬁned as G = {V (cid:48), E (cid:48), LV (cid:48), LE (cid:48)},
where V (cid:48) = V ∪ E, LV (cid:48) = LV ∪ LE and LE (cid:48) = ∅.
The new edge set E (cid:48) contains a edge for every
(node, edge) pair that is present in the original
graph. By deﬁnition, the Levi graph is bipartite.

Intuitively, transforming a graph into its Levi
graph equivalent turns edges into additional nodes.
While simple in theory, this transformation ad-
dresses both modelling deﬁciencies mentioned
above in an elegant way. Since the Levi graph
has no labelled edges there is no risk of parame-
ter explosion: original edge labels are represented
as embeddings, in the same way as nodes. Further-
more, the encoder now naturally generates hidden
states for original edges as well.

In practice, we follow the procedure in §2.3
and add reverse and self-loop edges to the Levi
graph, so the practical edge label vocabulary is
LE (cid:48) = {default, reverse, self}. This still keeps
the parameter space modest since we have only
three labels. Figure 2 shows the transformation
steps in detail, applied to the AMR graph shown
in Figure 1. Notice that the transformed graphs
are the ones fed into our architecture: we show the
original graph in Figure 1 for simplicity.

It is important to note that this transformation
can be applied to any graph and therefore is inde-
pendent of the model architecture. We speculate
this can be beneﬁcial in other kinds of graph-based
encoder such as GCNs and leave further investiga-
tion to future work.

4 Generation from AMR Graphs

Our ﬁrst g2s benchmark is language genera-
tion from AMR, a semantic formalism that repre-
sents sentences as rooted DAGs (Banarescu et al.,
2013). Because AMR abstracts away from syntax,
graphs do not have gold-standard alignment infor-
mation, so generation is not a trivial task. There-
fore, we hypothesize that our proposed model is
ideal for this problem.

4.1 Experimental setup

Data and preprocessing We use the latest AMR
corpus release (LDC2017T10) with the default
split of 36521/1368/1371 instances for training,

3Formally, a Levi graph is deﬁned over any incidence
structure, which is a general concept usually considered in
a geometrical context. Graphs are an example of incidence
structures but so are points and lines in the Euclidean space,
for instance.

development and test sets. Each graph is prepro-
cessed using a procedure similar to what is per-
formed by Konstas et al. (2017), which includes
entity simpliﬁcation and anonymisation. This pre-
processing is done before transforming the graph
into its Levi graph equivalent. For the s2s base-
lines, we also add scope markers as in Konstas
et al. (2017). We detail these procedures in the
Appendix.

Models Our baselines are attentional s2s mod-
els which take linearised graphs as inputs. The
architecture is similar to the one used in Konstas
et al. (2017) for AMR generation, where the en-
coder is a BiLSTM followed by a unidirectional
LSTM. All dimensionalities are ﬁxed to 512.

For the g2s models, we ﬁx the number of layers
in the GGNN encoder to 8, as this gave the best
results on the development set. Dimensionalities
are also ﬁxed at 512 except for the GGNN encoder
which uses 576. This is to ensure all models have
a comparable number of parameters and therefore
similar capacity.

Training for all models uses Adam (Kingma and
Ba, 2015) with 0.0003 initial learning rate and 16
as the batch size.4 To regularise our models we
perform early stopping on the dev set based on
perplexity and apply 0.5 dropout (Srivastava et al.,
2014) on the source embeddings. We detail addi-
tional model and training hyperparameters in the
Appendix.

Evaluation Following previous work, we eval-
uate our models using BLEU (Papineni et al.,
2001) and perform bootstrap resampling to check
since re-
statistical signiﬁcance.
cent work has questioned the effectiveness of
BLEU with bootstrap resampling (Graham et al.,
2014), we also report results using sentence-level
CHRF++ (Popovi´c, 2017), using the Wilcoxon
signed-rank test to check signiﬁcance. Evaluation
is case-insensitive for both metrics.

However,

Recent work has shown that evaluation in neu-
ral models can lead to wrong conclusions by
just changing the random seed (Reimers and
Gurevych, 2017). In an effort to make our con-
clusions more robust, we run each model 5 times
using different seeds. From each pool, we report

4Larger batch sizes hurt dev performance in our prelim-
inary experiments. There is evidence that small batches
can lead to better generalisation performance (Keskar et al.,
2017). While this can make training time slower, it was
doable in our case since the dataset is small.

BLEU CHRF++

#params

Single models
s2s
s2s (-s)
g2s

Ensembles
s2s
s2s (-s)
g2s

21.7
18.4
23.3

26.6
22.0
27.5

49.1
46.3
50.4

52.5
48.9
53.5

28.4M
28.4M
28.3M

142M
142M
141M

–

22.0

Previous work (early AMR treebank versions)
KIYCZ17
Previous work (as above + unlabelled data)
KIYCZ17
PKH16
SPZWG17
FDSC16

33.8
26.9
25.6
22.0

–
–
–
–

–
–
–
–

–

Table 1: Results for AMR generation on the test
set. All score differences between our models and
the corresponding baselines are signiﬁcantly dif-
ferent (p<0.05). “(-s)” means input without scope
marking. KIYCZ17, PKH16, SPZWG17 and
FDSC16 are respectively the results reported in
Konstas et al. (2017), Pourdamghani et al. (2016),
Song et al. (2017) and Flanigan et al. (2016).

results using the median model according to per-
formance on the dev set (simulating what is ex-
pected from a single run) and using an ensemble
of the 5 models.

Finally, we also report the number of parame-
ters used in each model. Since our encoder archi-
tectures are quite different, we try to match the
number of parameters between them by chang-
ing the dimensionality of the hidden layers (as ex-
plained above). We do this to minimise the effects
of model capacity as a confounder.

4.2 Results and analysis

Table 1 shows the results on the test set. For
the s2s models, we also report results without
the scope marking procedure of Konstas et al.
(2017). Our approach signiﬁcantly outperforms
the s2s baselines both with individual models and
ensembles, while using a comparable number of
parameters. In particular, we obtain these results
without relying on scoping heuristics.

On Figure 3 we show an example where our
model outperforms the baseline. The AMR graph
contains four reentrancies, predicates that refer-

Original AMR graph
(p / propose-01

:ARG0 (c / country

:wiki "Russia"
:name (n / name

:op1 "Russia"))

:ARG1 (c5 / cooperate-01

:ARG0 c
:ARG1 (a / and

:op1 (c2 / country

:wiki "India"
:name (n2 / name
:op1 "India"))
:op2 (c3 / country

:wiki "China"
:name (n3 / name

:op1 "China"))))
:purpose (i / increase-01

:ARG0 c5
:ARG1 (s / security)
:location (a2 / around

:op1 (c4 / country

:wiki "Afghanistan"
:name (n4 / name

:op1 "Afghanistan")))

:purpose (b / block-01

:ARG0 (a3 / and

:op1 c :op2 c2 :op3 c3

:ARG1 (s2 / supply-01
:ARG1 (d / drug)))))

Reference surface form
Russia proposes cooperation with India and China to in-
crease security around Afghanistan to block drug supplies.

s2s output (CHRF++ 61.8)
Russia proposed cooperation with India and China to in-
crease security around the Afghanistan to block security
around the Afghanistan , India and China.

g2s output (CHRF++ 78.2)
Russia proposed cooperation with India and China to in-
crease security around Afghanistan to block drug supplies.

Figure 3: Example showing overgeneration due to
reentrancies. Top: original AMR graph with key
reentrancies highlighted. Bottom: reference and
outputs generated by the s2s and g2s models,
highlighting the overgeneration phenomena.

ence previously deﬁned concepts in the graph. In
the s2s models including Konstas et al. (2017),
reentrant nodes are copied in the linearised form,
while this is not necessary for our g2s models.
We can see that the s2s prediction overgenerates
the “India and China” phrase. The g2s predic-
tion avoids overgeneration, and almost perfectly
matches the reference. While this is only a sin-
gle example, it provides evidence that retaining the
full graphical structure is beneﬁcial for this task,
which is corroborated by our quantitative results.

Table 1 also show BLEU scores reported in pre-
vious work. These results are not strictly com-
parable because they used different training set
versions and/or employ additional unlabelled cor-
pora; nonetheless some insights can be made. In
particular, our g2s ensemble performs better than
many previous models that combine a smaller
training set with a large unlabelled corpus. It is
also most informative to compare our s2s model
with Konstas et al. (2017), since this baseline is
very similar to theirs. We expected our single
model baseline to outperform theirs since we use
a larger training set but we obtained similar per-
formance. We speculate that better results could
be obtained by more careful tuning, but neverthe-
less we believe such tuning would also beneﬁt our
proposed g2s architecture.

The best results with unlabelled data are ob-
tained by Konstas et al. (2017) using Gigaword
sentences as additional data and a paired trained
procedure with an AMR parser. It is important to
note that this procedure is orthogonal to the in-
dividual models used for generation and parsing.
Therefore, we hypothesise that our model can also
beneﬁt from such techniques, an avenue that we
leave for future work.

5 Syntax-based Neural Machine

Translation

Our second evaluation is NMT, using as graphs
source language dependency syntax trees. We fo-
cus on a medium resource scenario where addi-
tional linguistic information tends to be more ben-
eﬁcial. Our experiments comprise two language
pairs: English-German and English-Czech.

5.1 Experimental setup

Data and preprocessing We employ the same
data and settings from Bastings et al. (2017),5
which use the News Commentary V11 corpora
from the WMT16 translation task.6 English text
is tokenised and parsed using SyntaxNet7 while
German and Czech texts are tokenised and split
into subwords using byte-pair encodings (Sen-
nrich et al., 2016, BPE) (8000 merge operations).

5We obtained the data from the original authors to ensure
results are comparable without any inﬂuence from prepro-
cessing steps.

6http://www.statmt.org/wmt16/

translation-task.html

7https://github.com/tensorflow/models/

tree/master/syntaxnet

We refer to Bastings et al. (2017) for further infor-
mation on the preprocessing steps.

Labelled dependency trees in the source side are
transformed into Levi graphs as a preprocessing
step. However, unlike AMR generation, in NMT
the inputs are originally surface forms that contain
important sequential information. This informa-
tion is lost when treating the input as dependency
trees, which might explain why Bastings et al.
(2017) obtain the best performance when using an
initial RNN layer in their encoder. To investigate
this phenomenon, we also perform experiments
adding sequential connections to each word in
the dependency tree, corresponding to their order
in the original surface form (henceforth, g2s+).
These connections are represented as edges with
speciﬁc left and right labels, which are added af-
ter the Levi graph transformation. Figure 4 shows
an example of an input graph for g2s+, with the
additional sequential edges connecting the words
(reverse and self edges are omitted for simplicity).

Models Our s2s and g2s models are almost
the same as in the AMR generation experiments
(§4.1). The only exception is the GGNN encoder
dimensionality, where we use 512 for the experi-
ments with dependency trees only and 448 when
the inputs have additional sequential connections.
As in the AMR generation setting, we do this to
ensure model capacity are comparable in the num-
ber of parameters. Another key difference is that
the s2s baselines do not use dependency trees:
they are trained on the sentences only.

In addition to neural models, we also report re-
sults for Phrase-Based Statistical MT (PB-SMT),
using Moses (Koehn et al., 2007). The PB-SMT
models are trained using the same data conditions
as s2s (no dependency trees) and use the standard
setup in Moses, except for the language model,
where we use a 5-gram LM trained on the target
side of the respective parallel corpus.8

Evaluation We report results in terms of BLEU
and CHRF++, using case-sensitive versions of both
metrics. Other settings are kept the same as in
the AMR generation experiments (§4.1). For PB-
SMT, we also report the median result of 5 runs,
obtained by tuning the model using MERT (Och
and Ney, 2002) 5 times.

8Note that target data is segmented using BPE, which is
not the usual setting for PB-SMT. We decided to keep the
segmentation to ensure data conditions are the same.

ROOT

punct

nsubj

det

expl

amod

prep

pobj

There is a deeper issue at stake .

There

is

a

deeper

issue

stake

at

.

ROOT

expl

nsubj

punct

det

amod

prep

pobj

Figure 4: Top: a sentence with its corresponding
dependency tree. Bottom:
the transformed tree
into a Levi graph with additional sequential con-
nections between words (dashed lines). The full
graph also contains reverse and self edges, which
are omitted in the ﬁgure.

5.2 Results and analysis

Table 2 shows the results on the respective test set
for both language pairs. The g2s models, which
do not account for sequential information, lag be-
hind our baselines. This is in line with the ﬁndings
of Bastings et al. (2017), who found that having a
BiRNN layer was key to obtain the best results.
However, the g2s+ models outperform the base-
lines in terms of BLEU scores under the same pa-
rameter budget, in both single model and ensem-
ble scenarios. This result show that it is possible to
incorporate sequential biases in our model without
relying on RNNs or any other modiﬁcation in the
architecture.

English-German

BLEU CHRF++ #params

Single models
PB-SMT
s2s
g2s
g2s+

Ensembles
s2s
g2s
g2s+

Single models
PB-SMT
s2s
g2s
g2s+

Ensembles
s2s
g2s
g2s+

12.8
15.5
15.2
16.7

19.0
17.7
19.6

8.6
8.9
8.7
9.8

11.3
10.4
11.7

43.2
40.8
41.4
42.4

44.1
43.5
45.1

36.4
33.8
32.3
33.3

36.4
34.7
35.9

Results from (Bastings et al., 2017)
BoW+GCN
BiRNN
BiRNN+GCN

–
–
–
English-Czech

12.2
14.9
16.1

BLEU CHRF++ #params

–
41.4M
40.8M
41.2M

207M
204M
206M

–
–
–

–
–
–

–
39.1M
38.4M
38.8M

195M
192M
194M

Results from (Bastings et al., 2017)
BoW+GCN
BiRNN
BiRNN+GCN

7.5
8.9
9.6

–
–
–

Table 2: Results for syntax-based NMT on the test
sets. All score differences between our models and
the corresponding baselines are signiﬁcantly dif-
ferent (p<0.05), including the negative CHRF++
result for En-Cs.

Interestingly, we found different trends when
analysing the CHRF++ numbers. In particular, this
metric favours the PB-SMT models for both lan-
guage pairs, while also showing improved perfor-
mance for s2s in En-Cs. CHRF++ has been shown
to better correlate with human judgments com-
pared to BLEU, both at system and sentence level
for both language pairs (Bojar et al., 2017), which
motivated our choice as an additional metric. We
leave further investigation of this phenomena for
future work.

We also show some of the results reported by
Bastings et al. (2017) in Table 2. Note that their
results were based on a different implementation,
which may explain some variation in performance.
Their BoW+GCN model is the most similar to
ours, as it uses only an embedding layer and a
GCN encoder. We can see that even our sim-
pler g2s model outperforms their results. A key
difference between their approach and ours is the
Levi graph transformation and the resulting hidden
vectors for edges. We believe their architecture
would also beneﬁt from our proposed transforma-
tion. In terms of baselines, s2s performs better
than their BiRNN model for En-De and compara-
bly for En-Cs, which corroborates that our base-
lines are strong ones. Finally, our g2s+ single
models outperform their BiRNN+GCN results, in
particular for En-De, which is further evidence
that RNNs are not necessary for obtaining the best
performance in this setting.

An important point about these experiments is
that we did not tune the architecture: we simply
employed the same model we used in the AMR
generation experiments, only adjusting the dimen-
sionality of the encoder to match the capacity of
the baselines. We speculate that even better re-
sults would be obtained by tuning the architecture
to this task. Nevertheless, we still obtained im-
proved performance over our baselines and previ-
ous work, underlining the generality of our archi-
tecture.

6 Related work

Graph-to-sequence modelling Early NLP ap-
proaches for this problem were based on Hy-
peredge Replacement Grammars (Drewes et al.,
1997, HRGs). These grammars assume the trans-
duction problem can be split into rules that map
portions of a graph to a set of tokens in the out-
put sequence. In particular, Chiang et al. (2013)
deﬁnes a parsing algorithm, followed by a com-
plexity analysis, while Jones et al. (2012) report
experiments on semantic-based machine transla-
tion using HRGs. HRGs were also used in pre-
vious work on AMR parsing (Peng et al., 2015).
The main drawback of these grammar-based ap-
proaches though is the need for alignments be-
tween graph nodes and surface tokens, which are
usually not available in gold-standard form.

Neural networks for graphs Recurrent net-
works on general graphs were ﬁrst proposed un-

der the name Graph Neural Networks (Gori et al.,
2005; Scarselli et al., 2009). Our work is based
on the architecture proposed by Li et al. (2016),
which add gating mechanisms. The main differ-
ence between their work and ours is that they fo-
cus on problems that concern the input graph it-
self such as node classiﬁcation or path ﬁnding
while we focus on generating strings. The main
alternative for neural-based graph representations
is Graph Convolutional Networks (Bruna et al.,
2014; Duvenaud et al., 2015; Kipf and Welling,
2017), which have been applied in a range of prob-
lems. In NLP, Marcheggiani and Titov (2017) use
a similar architecture for Semantic Role Labelling.
They use heuristics to mitigate the parameter ex-
plosion by grouping edge labels, while we keep
the original labels through our Levi graph trans-
formation. An interesting alternative is proposed
by Schlichtkrull et al. (2017), which uses tensor
factorisation to reduce the number of parameters.

Applications Early work on AMR generation
employs grammars and transducers (Flanigan
et al., 2016; Song et al., 2017). Linearisation ap-
proaches include (Pourdamghani et al., 2016) and
(Konstas et al., 2017), which showed that graph
simpliﬁcation and anonymisation are key to good
performance, a procedure we also employ in our
work. However, compared to our approach, lin-
earisation incurs in loss of information. MT has a
long history of previous work that aims at incor-
porating syntax (Wu, 1997; Yamada and Knight,
2001; Galley et al., 2004; Liu et al., 2006, inter
alia). This idea has also been investigated in the
context of NMT. Bastings et al. (2017) is the most
similar work to ours, and we benchmark against
their approach in our NMT experiments. Eriguchi
et al. (2016) also employs source syntax, but us-
ing constituency trees instead. Other approaches
have investigated the use of syntax in the target
language (Aharoni and Goldberg, 2017; Eriguchi
et al., 2017). Finally, Hashimoto and Tsuruoka
(2017) treats source syntax as a latent variable,
which can be pretrained using annotated data.

7 Discussion and Conclusion

We proposed a novel encoder-decoder architec-
ture for graph-to-sequence learning, outperform-
ing baselines in two NLP tasks:
generation
from AMR graphs and syntax-based NMT. Our
approach addresses shortcomings from previous
work, including loss of information from lineari-

sation and parameter explosion. In particular, we
showed how graph transformations can solve is-
sues with graph-based networks without chang-
ing the underlying architecture. This is the case
of the proposed Levi graph transformation, which
ensures the decoder can attend to edges as well
as nodes, but also to the sequential connections
added to the dependency trees in the case of NMT.
Overall, because our architecture can work with
general graphs, it is straightforward to add linguis-
tic biases in the form of extra node and/or edge
information. We believe this is an interesting re-
search direction in terms of applications.

Our architecture nevertheless has two major
limitations. The ﬁrst one is that GGNNs have a
ﬁxed number of layers, even though graphs can
vary in size in terms of number of nodes and
edges. A better approach would be to allow the
encoder to have a dynamic number of layers, pos-
sibly based on the diameter (longest path) in the
input graph. The second limitation comes from
the Levi graph transformation: because edge la-
bels are represented as nodes they end up shar-
ing the vocabulary and therefore, the same seman-
tic space. This is not ideal, as nodes and edges
are different entities. An interesting alternative is
Weave Module Networks (Kearnes et al., 2016),
which explicitly decouples node and edge repre-
sentations without incurring in parameter explo-
sion. Incorporating both ideas to our architecture
is an research direction we plan for future work.

Acknowledgements

This work was supported by the Australian Re-
search Council (DP160102686). The research
reported in this paper was partly conducted at
the 2017 Frederick Jelinek Memorial Summer
Workshop on Speech and Language Technolo-
gies, hosted at Carnegie Mellon University and
sponsored by Johns Hopkins University with un-
restricted gifts from Amazon, Apple, Facebook,
Google, and Microsoft. The authors would also
like to thank Joost Bastings for sharing the data
from his paper’s experiments.

References

Roee Aharoni and Yoav Goldberg. 2017. Towards
String-to-Tree Neural Machine Translation. In Pro-
ceedings of ACL. pages 132–140.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Grifﬁtt, Ulf Hermjakob, Kevin

Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract Meaning Representation
for Sembanking. In Proceedings of the 7th Linguis-
tic Annotation Workshop and Interoperability with
Discourse. pages 178–186.

Joost Bastings,

Ivan Titov, Wilker Aziz, Diego
Marcheggiani, and Khalil Sima’an. 2017. Graph
Convolutional Encoders for Syntax-aware Neural
In Proceedings of EMNLP.
Machine Translation.
pages 1947–1957.

Ondej Bojar, Yvette Graham, and Amir Kamran. 2017.
Results of the WMT17 Metrics Shared Task. In Pro-
ceedings of WMT. volume 2, pages 293–301.

Joan Bruna, Wojciech Zaremba, Arthur Szlam, and
Yann LeCun. 2014. Spectral Networks and Locally
Connected Networks on Graphs. In Proceedings of
ICLR. page 14.

Tianqi Chen, Mu Li, Yutian Li, Min Lin, Naiyan Wang,
Minjie Wang, Tianjun Xiao, Bing Xu, Chiyuan
Zhang, and Zheng Zhang. 2015. MXNet: A Flexible
and Efﬁcient Machine Learning Library for Hetero-
geneous Distributed Systems. In Proceedings of the
Workshop on Machine Learning Systems. pages 1–6.

David Chiang,

Jacob Andreas, Daniel Bauer,
Karl Moritz Hermann, Bevan Jones, and Kevin
Parsing Graphs with Hyperedge
Knight. 2013.
In Proceedings of ACL.
Replacement Grammars.
pages 924–932.

Kyunghyun Cho, Bart van Merrienboer, Caglar Gul-
cehre, Dzmitry Bahdanau, Fethi Bougares, Hol-
ger Schwenk, and Yoshua Bengio. 2014. Learn-
ing Phrase Representations using RNN Encoder-
Decoder for Statistical Machine Translation. In Pro-
ceedings of EMNLP. pages 1724–1734.

Frank Drewes, Hans J¨org Kreowski, and Annegret Ha-
bel. 1997. Hyperedge Replacement Graph Gram-
mars. Handbook of Graph Grammars and Comput-
ing by Graph Transformation .

David Duvenaud, Dougal Maclaurin, Jorge Aguilera-
Iparraguirre, Rafael G´omez-Bombarelli, Timothy
Hirzel, Al´an Aspuru-Guzik, and Ryan P Adams.
2015.
Convolutional Networks on Graphs for
Learning Molecular Fingerprints. In Proceedings of
NIPS. pages 2215–2223.

Akiko Eriguchi, Kazuma Hashimoto, and Yoshimasa
Tsuruoka. 2016. Tree-to-Sequence Attentional Neu-
ral Machine Translation. In Proceedings of ACL.

Akiko Eriguchi, Yoshimasa Tsuruoka, and Kyunghyun
Cho. 2017. Learning to Parse and Translate Im-
proves Neural Machine Translation. In Proceedings
of ACL.

Jeffrey Flanigan, Chris Dyer, Noah A. Smith, and
Jaime Carbonell. 2016. Generation from Abstract
Meaning Representation using Tree Transducers. In
Proceedings of NAACL. pages 731–739.

Jeffrey Flanigan, Sam Thomson, Jaime Carbonell,
Chris Dyer, and Noah a Smith. 2014. A Discrimi-
native Graph-Based Parser for the Abstract Meaning
Representation. In Proceedings of ACL.

Michel Galley, Mark Hopkins, Kevin Knight, and
Daniel Marcu. 2004. What’s in a translation rule?
In Proceedings of NAACL. pages 273–280.

Jonas Gehring, Michael Auli, David Grangier, Denis
Yarats, and Yann N. Dauphin. 2017. Convolutional
Sequence to Sequence Learning. arXiv preprint .

Xavier Glorot and Yoshua Bengio. 2010. Understand-
ing the Difﬁculty of Training Deep Feedforward
Neural Networks. In Proceedings of AISTATS. vol-
ume 9, pages 249–256.

Marco Gori, Gabriele Monfardini,

and Franco
Scarselli. 2005. A New Model for Learning in
In Proceedings of IJCNN. vol-
Graph Domains.
ume 2, pages 729–734.

Yvette Graham, Nitika Mathur, and Timothy Baldwin.
2014. Randomized Signiﬁcance Tests in Machine
In Proceedings of WMT. pages 266–
Translation.
274.

Jonathan Gross and Jay Yellen, editors. 2004. Hand-

book of Graph Theory. CRC Press.

Kazuma Hashimoto and Yoshimasa Tsuruoka. 2017.
Neural Machine Translation with Source-Side La-
In Proceedings of EMNLP.
tent Graph Parsing.
pages 125–135.

Felix Hieber, Tobias Domhan, Michael Denkowski,
David Vilar, Artem Sokolov, Ann Clifton, and Matt
Post. 2017. Sockeye: A Toolkit for Neural Machine
Translation. arXiv preprint pages 1–18.

Sepp Hochreiter and J¨urgen Schmidhuber. 1997.
Long Short-Term Memory. Neural Computation
9(8):1735–1780.

Bevan

Jones,

Jacob Andreas, Daniel Bauer,
Karl Moritz Hermann, and Kevin Knight. 2012.
Semantics-Based Machine Translation with Hyper-
In Proceedings of
edge Replacement Grammars.
COLING. pages 1359–1376.

Steven Kearnes, Kevin McCloskey, Marc Berndl, Vi-
jay Pande, and Patrick Riley. 2016. Molecu-
lar Graph Convolutions: Moving Beyond Finger-
prints. Journal of Computer-Aided Molecular De-
sign 30(8):595–608.

Nitish Shirish Keskar, Dheevatsa Mudigere, Jorge No-
cedal, Mikhail Smelyanskiy, and Ping Tak Peter
Tang. 2017. On Large-Batch Training for Deep
Learning: Generalization Gap and Sharp Minima.
In Proceedings of ICLR. pages 1–16.

Diederik P. Kingma and Jimmy Ba. 2015. Adam: A
In Proceed-

Method for Stochastic Optimization.
ings of ICLR. pages 1–15.

Thomas N. Kipf and Max Welling. 2017.

Semi-
Supervised Classiﬁcation with Graph Convolutional
Networks. In Proceedings of ICLR.

Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris
Callison-Burch, Marcello Federico, Nicola Bertoldi,
Brooke Cowan, Wade Shen, Christine Moran,
Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra
Constantin, and Evan Herbst. 2007. Moses: Open
source toolkit for statistical machine translation. In
Proceedings of ACL Demo Session. pages 177–180.

Ioannis Konstas, Srinivasan Iyer, Mark Yatskar, Yejin
Choi, and Luke Zettlemoyer. 2017. Neural AMR:
Sequence-to-Sequence Models for Parsing and Gen-
eration. In Proceedings of ACL. pages 146–157.

Friedrich Wilhelm Levi. 1942. Finite Geometrical Sys-

tems.

Yujia Li, Daniel Tarlow, Marc Brockschmidt, and
Richard Zemel. 2016. Gated Graph Sequence Neu-
ral Networks. In Proceedings of ICLR. 1, pages 1–
20.

Yang Liu, Qun Liu, and Shouxun Lin. 2006. Tree-
to-string alignment template for statistical machine
translation. In Proceedings of the 21st International
Conference on Computational Linguistics and the
44th annual meeting of the ACL - ACL ’06. pages
609–616.

Minh-Thang Luong, Hieu Pham, and Christopher D.
Manning. 2015. Effective Approaches to Attention-
based Neural Machine Translation. In Proceedings
of EMNLP. pages 1412–1421.

Diego Marcheggiani and Ivan Titov. 2017. Encod-
ing Sentences with Graph Convolutional Networks
In Proceedings of
for Semantic Role Labeling.
EMNLP.

Franz Josef Och and Hermann Ney. 2002. Dis-
criminative training and maximum entropy mod-
In Proceed-
els for statistical machine translation.
ings of the 40th Annual Meeting on Association
for Computational Linguistics - ACL ’02. page 295.
https://doi.org/10.3115/1073083.1073133.

Kishore Papineni, Salim Roukos, Todd Ward, and Wei-
Jing Zhu. 2001. Bleu: a method for automatic eval-
In Proceedings of
uation of machine translation.
ACL. pages 311–318.

Xiaochang Peng, Linfeng Song, and Daniel Gildea.
2015. A Synchronous Hyperedge Replacement
Grammar based approach for AMR parsing. In Pro-
ceedings of CoNLL. pages 32–41.

Maja Popovi´c. 2017. chrF ++: words helping character
n-grams. In Proceedings of WMT. pages 612–618.

Nima Pourdamghani, Yang Gao, Ulf Hermjakob, and
Kevin Knight. 2014. Aligning English Strings with
In Pro-
Abstract Meaning Representation Graphs.
ceedings of EMNLP. pages 425–429.

Nima Pourdamghani, Kevin Knight, and Ulf Herm-
jakob. 2016. Generating English from Abstract
Meaning Representations. In Proceedings of INLG.
volume 0, pages 21–25.

Nils Reimers and Iryna Gurevych. 2017. Reporting
Score Distributions Makes a Difference: Perfor-
mance Study of LSTM-networks for Sequence Tag-
ging. In Proceedings of EMNLP. pages 338–348.

Franco Scarselli, Marco Gori, Ah Ching Tsoi, and
Gabriele Monfardini. 2009. The Graph Neural Net-
IEEE Transactions on Neural Net-
work Model.
works 20(1):61–80.

Michael Schlichtkrull, Thomas N. Kipf, Peter Bloem,
Rianne van den Berg, Ivan Titov, and Max Welling.
2017. Modeling Relational Data with Graph Convo-
lutional Networks pages 1–12.

Rico Sennrich, Barry Haddow, and Alexandra Birch.
2016. Neural Machine Translation of Rare Words
with Subword Units. In Proceedings of ACL. pages
1715–1725.

Linfeng Song, Xiaochang Peng, Yue Zhang, Zhiguo
Wang, and Daniel Gildea. 2017. AMR-to-text Gen-
eration with Synchronous Node Replacement Gram-
mar. In Proceedings of ACL. pages 7–13.

Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky,
Ilya Sutskever, and Ruslan Salakhutdinov. 2014.
Dropout: A Simple Way to Prevent Neural Networks
from Overﬁtting. Journal of Machine Learning Re-
search 15:1929–1958.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob
Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz
Kaiser, and Illia Polosukhin. 2017. Attention Is All
You Need. In Proceedings of NIPS.

Dekai Wu. 1997. Stochastic inversion transduction
grammars and bilingual parsing of parallel corpora.
Computational Linguistics 23(3):377–403.

Kenji Yamada and Kevin Knight. 2001. A Syntax-
based Statistical Translation Model. In Proceedings
of ACL. pages 523–530.

A Simpliﬁcation and Anonymisation for

AMR graphs

The procedure for graph simpliﬁcation and
anonymisation is similar to what is done by (Kon-
stas et al., 2017). The main difference is that
we use the alignments provided by the original
LDC version of the AMR corpus, while they
use a combination of the JAMR aligner (Flani-
gan et al., 2014) and the unsupervised aligner of
(Pourdamghani et al., 2014). This preprocessing
is done before transforming the graph into its bi-
partite equivalent.

Simpliﬁcation: we

remove

informa-
instance,
tion from the concepts.
believe-01 becomes believe. We also
remove any subgraphs related to wikiﬁcation
(the ones starting the predicate :wiki).

sense
For

Entity anonymisation: all

subgraphs

starting
with the predicate :name are anonymised.
The predicate contains one of the AMR
entity names as the source node, such as
country or *-quantity.
These are
replaced by a single anonymised node,
containing the original entity concept plus an
index. At training time, we use the alignment
information to ﬁnd the corresponding entity
in the surface form and replace all aligned
tokens with the same concept name. At
test time, we extract a map that maps the
anonymised entity to all concept names in
in depth-ﬁrst order. After
the subgraph,
prediction, if there is an anonymised token in
the surface form it is replaced using that map
(as long as the predicted token is present in
the map).

Enitity clustering: entities are also clustered into
four coarse-grained types in both graph and
surface form. For instance country 0 be-
comes loc 0. We use the list obtained from
the open source implementation of (Konstas
et al., 2017) for that.

Date anonymisation: if

there

training time,
anonymised

a
is
date-entity concept,
all underlying
concepts are also anonymised, using sep-
arate tokens for day, month and year.
the surface form is
At
also
align-
following
ment, but we additionally split days and
months into day name, day number,
month name and month number. At test
time, we render the day/month according
to the predicted anonymised token in the
surface form and the recorded map.

the

B Model Hyperparameters

Our implementation is based on the Sockeye
toolkit for Neural Machine Translation (Hieber
et al., 2017). Besides the speciﬁc hyperparameter
values mentioned in the paper, all other hyperpa-
rameters are set to the default values in Sockeye.
We detail them here for completeness:

B.1 Vocabulary

• For AMR, we set the minimum frequency to
2 in both source nodes and target surface to-
kens. For NMT, we also use 2 as the mini-
mum frequency in the source but use 1 in the
target since we use BPE tokens.

B.2 Model

• The baseline encoder use a BiLSTM fol-
lowed by a unidirectional LSTM. The de-
coder in all models use a 2-layer LSTM.

• The attention module uses a bilinear scoring
function (general as in (Luong et al., 2015)).

• The max sequence length during training is
200 for AMR. In NMT, we use 100 for the
s2s baselines and 200 for the g2s models.
This is because we do not use dependency
trees in the baseline so it naturally has half
of the tokens.

• All dimensionalities are ﬁxed to 512, which
is similar to what is used by (Konstas et al.,
2017). The only exceptions are the GGNN
hidden state dimensionality in the g2s mod-
els. We use 576 for the g2s models used in
the AMR experiments and 448 for the g2s+
models used in the NMT experiments. As
pointed out in the main paper, we change
GGNN dimensionalities in order to have a
similar parameter budget compared to the
s2s baselines.

B.3 Training

These options apply for both s2s baselines and
g2s g2s+ models.

• We use 16 as the batch size. This is a lower
number than most previous work we com-
pare with: we choose this because we ob-
tained better results in the AMR dev set.
This is in line with recent evidence showing
that smaller batch sizes lead to better gener-
alisation performance (Keskar et al., 2017).
The drawback is that smaller batches makes
training time slower. However, this was not
a problem in our experiments due to the
medium size of the datasets.

• Bucketing is used to speed up training: we

use 10 as the bucket size.

• Models are trained using cross-entropy as the

loss.

• We save parameter checkpoints at every full

epoch on the training set.

• We use early stopping by perplexity on the
dev set with patience 8 (training stops if dev
perplexity do not improve for 8 checkpoints).

• A maximum of 30 epochs/checkpoints is
used. All our models stopped training before
reaching this limit.

• We use 0.5 dropout on the input embeddings,

before they are fed to the encoder.

• Weigths are initalised using Xavier initialisa-
tion (Glorot and Bengio, 2010), with except
of forget biases in the LSTMs which are ini-
tialised by 0.

• We use Adam (Kingma and Ba, 2015) as the
optimiser with 0.0003 as the initial learning
rate.

• Learning

rate
dev perplexity does not
epochs/checkpoints.

is

halved

every

time
improve for 3

• Gradient clipping is set to 1.0.

B.4 Decoding

beam size.

• We use beam search to decode, using 5 as the

• Ensembles are created by averaging log prob-
abilities at every step (linear in Sockeye). At-
tention scores are averaged over the 5 models
at every step.

• For AMR only, we replace <unk> tokens in
the prediction with the node with the highest
attention score at that step, in the same way
described by (Konstas et al., 2017). This is
done before deanonymisation.

