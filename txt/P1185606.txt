8
1
0
2
 
r
a

M
 
2
1
 
 
]

V
C
.
s
c
[
 
 
4
v
0
7
3
0
0
.
2
1
6
1
:
v
i
X
r
a

Improved Image Captioning via Policy Gradient optimization of SPIDEr

Siqi Liu∗1, Zhenhai Zhu2, Ning Ye2, Sergio Guadarrama2, and Kevin Murphy2

siqi.liu@cs.ox.ac.uk
{zhenhai,nye,sguada,kpmurphy}@google.com
1Department of Computer Science, University of Oxford
2Google

Abstract

Current image captioning methods are usually trained via
(penalized) maximum likelihood estimation. However, the
log-likelihood score of a caption does not correlate well with
human assessments of quality. Standard syntactic evaluation
metrics, such as BLEU, METEOR and ROUGE, are also not
well correlated. The newer SPICE and CIDEr metrics are
better correlated, but have traditionally been hard to optimize
for. In this paper, we show how to use a policy gradient (PG)
method to directly optimize a linear combination of SPICE
and CIDEr (a combination we call SPIDEr): the SPICE score
ensures our captions are semantically faithful to the image,
while CIDEr score ensures our captions are syntactically
ﬂuent. The PG method we propose improves on the prior
MIXER approach, by using Monte Carlo rollouts instead of
mixing MLE training with PG. We show empirically that our
algorithm leads to easier optimization and improved results
compared to MIXER. Finally, we show that using our PG
method we can optimize any of the metrics, including the
proposed SPIDEr metric which results in image captions that
are strongly preferred by human raters compared to captions
generated by the same model but trained to optimize MLE
or the COCO metrics.

1

Introduction

Image captioning is the task of describing the visual
content of an image using one or more sentences.
This has many applications,
including text-based image
retrieval, accessibility for blind users [25], and human-robot
interaction [6].

Most methods for solving this task require training a
statistical model on a dataset of (image, caption) pairs. The
model is usually trained to maximize the log likelihood of
the training set. After training, these models are usually

∗The major part of this work was done while Siqi Liu was an intern at

Google.

evaluated by computing a variety of different metrics on
a test set, such as COCO [12]. Standard metrics from
the machine translation community include BLEU [14],
METEOR [3], and ROUGE [11]. More recently,
the
CIDEr metric [20] was proposed, speciﬁcally for the image
captioning task. We shall call the combination of these four
metrics “BCMR”, for short. Unfortunately, none of these
metrics correlate strongly with human measures of caption
quality. In fact, humans score lower on these metrics than
the methods that won the COCO 2015 challenge, despite the
fact that humans are still much better at this task.

These results motivated Anderson et al. [1] to propose
Rather than directly comparing a
the SPICE metric.
generated sentence to a set of reference sentences in terms
of syntactic agreement, SPICE ﬁrst parses each of the
reference sentences, and then uses them to derive an abstract
scene graph representation. The generated sentence is then
also parsed, and compared to the graph;
this allows for
a comparison of the semantic similarity, without paying
attention to syntactic factors (modulo the requirement that
the generated sentence be parseable). [1] showed that SPICE
is the only existing metric that has a strong correlation with
human ratings, and ranks human captions above algorithms
submitted to the COCO benchmark.
is natural

to directly
this is tricky, since it is not
optimize SPICE. However,
a differentiable objective.
In this paper, we show that it
is possible to use policy gradient (PG) methods [17] to
optimize such objectives. The idea of using PG to optimize
non differentiable objectives for image captioning was ﬁrst
proposed in the MIXER paper [15]. However, they only used
it to optimize BLEU-4, which is not correlated with human
quality. Furthermore, when we tried to use their method to
optimize other metrics, such as CIDEr or SPICE, we got
poor results, since their method (which involves an intricate
incremental schedule which mixes from MLE training to full
PG training) is not very robust and require careful tunning.

Given this result,

to want

it

In this paper, we propose an improvement to MIXER,
that uses Monte Carlo rollouts to get a better estimate of the

1

Under review as a conference paper at ICCV 2017

value function, and avoids the need to “mix in” the MLE
objective. We show that this leads to faster convergence,
and is signiﬁcantly more robust to choice of learning rates
and other hyper-parameters. We then show that we can use
our new PG method to optimize the BCMR metrics, thus
achieving state of the art results on the COCO leaderboard,
despite using a very simple baseline model.

However, being on top of the COCO leaderboard is not
our ultimate goal, since we know that the COCO metrics
(based on BCMR) are only weakly correlated with human
judgement [1]. So we decided to optimize SPICE with our
algorithm. Unfortunately, optimizing SPICE produced long
repetitive sentences which are not good results, based either
on BMCR COCO metrics, or as judged by humans.

The reason optimizing SPICE gives poor captions is that
SPICE ignores syntactic quality (see examples in Table 2)
More generally, we argue that a good image captioning
metric should satisfy two criteria:
(1) captions that are
considered good by humans should achieve high scores; and
(2) captions that achieve high scores should be considered
good by humans.
SPICE satisﬁes criterion 1, but not
criterion 2. We therefore propose a new metric, which is
a linear combination of SPICE and CIDEr; we call this new
metric SPIDEr. This metric automatically satisﬁes criterion
1, since both SPICE and CIDEr do. Also, when we optimize
for SPIDEr, we show that the captions are judged by humans
to be signiﬁcantly better than the ones generated by training
the same model using any of the other metrics. This shows
that SPIDEr satisﬁes criterion 2 to a much greater degree
than existing metrics.

In summary, we make the following contributions in this
paper: (1) we identify criteria for a good image captioning
metric, and proposed a new metric, SPIDEr, which meets
both criteria; (2) we propose a new policy gradient method
that can optimize arbitrary captioning metrics, and which is
much faster and more stable than previous PG methods; (3)
we show that using our new PG method to optimize existing
BCMR metrics leads to state of the art results on COCO;
(4) we show that using our new PG method to optimize our
new SPIDEr metric results in much better human scores than
optimizing for other metrics.

2 Related work

There is an extensive body of work on image captioning (see
e.g., [5] for a recent review). Below we summarize some of
the most relevant works.

2.1 Models

Most methods make use an encoder-decoder style neural
network, where the encoder is a convolutional neural
network (CNN), and the decoder a recurrent neural network

(RNN). In this work, we use the encoder-decoder proposed
in [22], known as “Show and Tell” (ST).

Numerous extensions to the basic encoder-decoder
framework have been proposed. One line of work (e.g., the
“Show, Attend and Tell” model of [26], and the “Review
Network” model of [27]), leverages attention, which lets the
decoder focus on speciﬁc parts of the input image when
generating a word. Another line of work enriches the
image encoding beyond just using a CNN that was trained
for image classiﬁcation. For example, [24, 28] use image
taggers, [21] use object detectors, and [19] use face detection
and landmark recognition. We stress that these extensions
are orthogonal to the ideas in this paper.

2.2 Metrics and objective functions

Most prior work uses maximum likelihood estimation
(MLE) for training. That is, the model parameters θ are
trained to maximize

L(θ) =

log p(yn|xn, θ)

1
N

1
N

=

N
(cid:88)

n=1

N
(cid:88)

Tn(cid:88)

n=1

t=1

log p(yn

t |yn

1:t−1, xn, θ)

where xn is the n’th image, yn = (yn

) is the
ground truth caption of the n’th image and N is the total
number of labelled examples.

1 , . . . , yn
Tn

One problem with the MLE objective is that at training
time, each prediction is conditioned on the previously
observed words from the ground truth. At test time, however,
the model will be fed with its own predictions,
leading
to quickly accumulating errors during inference, so the
model will likely diverge from desired trajectories. This
discrepancy is known as “exposure bias” [4]. One solution
to exposure bias is “scheduled sampling” [4], although this
method has been shown to be statistically inconsistent [9].

An alternative to maximizing likelihood is to try to
maximize some other objective that is more closely related
to the true metric of interest. This can be done using a policy
gradient (PG) method [17] such as REINFORCE [23], by
treating the score of a candidate sentence as analogous to a
reward signal in a reinforcement learning setting. In such a
framework, the RNN decoder acts like a stochastic policy,
where choosing an action corresponds to generating the next
word.

[15] use a modiﬁed form of REINFORCE to optimize the
BLEU score for image captioning. We explain this approach
in more detail in Section 2.3, since it is closely related to our
method. [8] used REINFORCE to optimize sequence level
reward such that generated captions are class discriminative.
However, this is a different task than the one we consider.

Under review as a conference paper at ICCV 2017

More recently, there have been a variety of other papers
on optimizing sequence level objective functions (see e.g.,
[13, 30, 2, 16]), but mostly in the context of machine
translation.

2.3 MIXER

The most closely related work is the “MIXER” paper [15].
They also use the REINFORCE method, combined with a
baseline reward estimator. However, they implicitly assume
each intermediate action (word) in a partial sequence has
the same reward as the sequence-level reward, which is not
true in general. To compensate for this, they introduce a
form of training that mixes together the MLE objective and
the REINFORCE objective. Speciﬁcally, they evaluate the
ﬁrst M words using log-likelihood, and the remaining words
using REINFORCE; they gradually decrease M from the
maximum sentence length down to 0.

We have found that MIXER is very sensitive to the form
of the annealing schedule, as well as other hyper-parameters,
such as the learning rate or gradient scaling of the baseline
estimator. We therefore propose a more robust alternative,
in which we replace the constant reward assumption with an
estimate of future rewards based on Monte Carlo rollouts (a
similar idea is used in [30] for GAN training). In Section 4,
we show that this change signiﬁcantly improves convergence
speed, as well as training stability. This lets us easily
optimize a variety of different metrics, including our new
metric, SPIDEr.

3 Methods

In this section, we explain our approach in more detail. First
we discuss the policy gradient method, which can be used
to robustly optimize any kind of reward function. Next we
discuss which reward function to use. Finally, we discuss the
model itself, which is a standard CNN-RNN.

3.1 Training using policy gradient

At time step t, we pick a discrete action, which corresponds
to choosing a word gt ∈ V, using a stochastic policy or
generator πθ(gt|st, x), where st = g1:t−1 is the sequence of
words chosen so far, x is the image and θ are the parameters
of the model. Note that in our case the state transition
function is deterministic: we simply append the word chosen
at time t to get st+1 = st; gt (u; v is the concatenation of the
strings u and v).

When we reach the end of the sequence (i.e., once the
generator emits the end-of-sentence marker), we get a reward
of R(g1:T |xn, yn), which is the score for producing caption
g1:T given image xn and ground truth caption (or set of

Figure 1: The value of each action is estimated as the
average rewards received by its K rollout sequences (i.e.
K = 3). Solid arrows indicate the sequence of actions being
evaluated. The tokens in green and yellow are respectively
BOS (beginning of sequence) and EOS (end of sequence)
tokens. Sequences in blue are rollout sequences sampled
from partial sequences. Note that rollout sequences do not
always have the same length, as they are separately sampled
from a stochastic policy.

reinforcement

captions) yn. This reward can be any function, such as
BCMR or SPICE.
In typical

learning setting, an agent
receives rewards at each intermediate step while future
rewards are discounted to balance short-term and long-term
In our case, however, the agent receive zero reward
gain.
during intermediate steps, observing a reward only at the
end. To mitigate the lack of intermediate reward signal,
we propose to estimate the value of intermediate states
(partial sequence), via Monte-Carlo rollouts. This translate
into signiﬁcantly more robust credit assignment and efﬁcient
gradient estimation, as we show in Section 4. We deﬁne the
value function of a partial sequence as its expected future
reward:

Vθ(g1:t|xn, yn) = Egt+1:T [R(g1:t; gt+1:T |xn, yn)]

(1)

where the expectation is w.r.t. gt+1:T ∼ πθ(·|g1:t, xn).

Our goal is to maximize the average reward starting from

the initial (empty) state s0 deﬁned as:

J(θ) =

Vθ(s0|xn, yn)

(2)

1
N

N
(cid:88)

n=1

where N is the number of examples in the training set. We
now discuss how to optimize Eqn. (2). For simplicity, we
will consider a single example n, so we will drop the xn and
yn notation. To compute the gradient of J(θ), we can use
the policy gradient theorem from [17]. In the special case of
deterministic transition functions, this theorem simpliﬁes as

Under review as a conference paper at ICCV 2017

shown below (see [2]for a proof):

∇θVθ(s0) = Eg1:T

∇θπθ(gt|g1:t−1)Qθ(g1:t−1, gt)





T
(cid:88)

(cid:88)

t=1

gt∈V

(3)
where we deﬁne the Q function for a state-action pair as
follows:

Qθ(g1:t−1, gt) = Egt+1:T [R(g1:t−1; gt; gt+1:T )]

(4)

We can approximate the gradient of the value function with
M sample paths, gm
1:T ∼ πθ, generated from our policy. This
gives

∇θVθ(s0) ≈

Egt

(cid:2)∇θ log πθ(gt|gm

1:t−1)

M
(cid:88)

T
(cid:88)

1
M

t=1

m=1
×Qθ(gm

1:t−1, gt)(cid:3)

(5)

where the expectation is w.r.t. gt ∼ πθ(gt|gm
we have exploited the fact that

1:t−1), and where

∇θπθ(a|s) = πθ(a|s)

= πθ(a|s)∇θ log πθ(a|s)

∇θπθ(a|s)
πθ(a|s)

If we use M = 1, we can additionally replace the Egt with
the value in the sample path, gm
t , as in REINFORCE. In our
experiment, we used M = 1 and we subsequently drop the
superscript m in the rest of this paper for notational clarity.
The only remaining question is how to estimate the
function Q(st, gt). For this, we will follow [30] and use
In particular, we ﬁrst sample K
Monte Carlo rollouts.
continuations of the sequence st; gt to get gk
t+1:T . Then we
compute the average

Q(g1:t−1, gt) ≈

R(g1:t−1; gt; gk

t+1:T )

(6)

1
K

K
(cid:88)

k=1

We estimate how good a particular word choice gt is by
averaging over all complete sequences sampled according
to the current policy, conditioned on the partial sequence
g1:t−1 sampled from the current policy so far. This process
is illustrated in Figure 1. If we are in a terminal state, we
deﬁne Q(g1:T , EOS) = R(g1:T ).

The above gradient estimator is an unbiased but high
variance estimator. One way to reduce its variance is to
estimate the expected baseline reward Egt[Q(g1:t−1, gt)]
using a parametric function; we will denote this baseline
as Bφ(g1:t−1). We then subtract
this baseline from
Qθ(g1:t−1, gt) to get the following estimate for the gradient
(using M = 1 sample paths):





where st = g1:t−1. Subtracting the baseline does not
affect the validity of the estimated gradient, but reduces its
variance. Here, we simply refer to prior work ([31], [23]) for
a full derivation of this property.

We train the parameters φ of the baseline estimator to

minimize the following loss:

Lφ =

EstEgt(Qθ(st, gt) − Bφ(st))2

(8)

(cid:88)

t

In our experiments, the baseline estimator is an MLP which
takes as input the hidden state of the RNN at step t. To
avoid creating a feedback loop, we do not back-propagate
gradients through the hidden state from this loss.

In language generation settings, a major challenge facing
PG methods is the large action space. This is the case in
our task, where the action space corresponds to the entire
vocabulary of 8,855 symbols. To help “warm start” the
training, we pre-train the RNN decoder (stochastic policy)
using MLE training, before switching to PG training. This
prevents the agent from performing random walks through
exponentially many possible paths at the beginning of the
training.

The overall algorithm is summarized in Algorithm 1.
Note that the Monte Carlo rollouts only require a forward
pass through the RNN, which is much more efﬁcient than the
forward-backward pass needed for the CNN. Additionally
the rollouts can be also be done in parallel for multiple
sentences. Consequently, PG training is only about twice
as slow as MLE training (in wall time).

Algorithm 1: PG training algorithm
1 Input: D = {(xn, yn) : n = 1 : N } ;
2 Train πθ(g1:T |x) using MLE on D ;
3 Train Bφ using MC estimates of Qθ on a small subset

of D;

4 for each epoch do
5

for example (xn, yn) do

6

7

8

9

10

11

12

13

Generate sequence g1:T ∼ πθ(·|xn) ;
for t = 1 : T do

Compute Q(g1:t−1, gt) for gt with K
Monte Carlo rollouts, using (6);
Compute estimated baseline Bφ(g1:t−1);

Compute Gθ = ∇θVθ(s0) using (7);
Compute Gφ = ∇φLφ;
SGD update of θ using Gθ;
SGD update of φ using Gφ;

T
(cid:88)

(cid:88)

t=1

gt

∇θVθ(s0) ≈

[πθ(gt|st)∇θ log πθ(gt|st)

3.2 Reward functions for the policy gradient

× (Qθ(st, gt) − Bφ(st))]

(7)

We can use our PG method to optimize many different
reward functions. Common choices include BLEU, CIDEr,

Under review as a conference paper at ICCV 2017

Figure 2: Model architecture of Show and Tell
image
captioning system [22]. The tokens in green and yellow are
respectively BOS (beginning of sequence) and EOS (end of
sequence) tokens. At testing time, output from previous time
step gt−1 is used as input in lieu of yt−1.

METEOR and ROUGE. Code for all of these metrics is
available as part of the COCO evaluation toolkit.1 We
decided to use a weighted combination of all of these. Since
these metrics are not on the same scale, we chose in our
experiments the set of weights such that all metrics have
approximately the same magnitude. More precisely, we
choose the following weighted combination: 0.5*BLEU-1
+ 0.5*BLEU-2 + 1.0*BLEU-3 + 1.0*BLEU-4 + 1.0*CIDEr
+ 5.0*METEOR + 2.0*ROUGE. Optimizing this weighted
combination of BCMR gives state-of-the-art results on the
COCO test set, as we discuss in Section 4.2.

One problem with the BCMR metrics is that individually
they are not well correlated with human judgment [1].
We therefore also tried optimizing the recently introduced
SPICE metric [1], which better reﬂects human estimates of
quality. We use the open source release of the SPICE code2
to evaluate the metric.

Interestingly, we have found that just optimizing SPICE
tended to result in captions which are very detailed, but
which often had many repeated phrases, as we show in
Section 4.
This is because SPICE measures semantic
similarity (in terms of a scene graph) between sets of
sentences, but does not pay attention to syntactical factors
(modulo the requirement that the generated sentence be
parseable). We therefore combined SPICE with the CIDEr
metric (considered the best of the standard automatic metrics
for COCO), a combination we call SPIDEr for short. Based
on initial experiments, we decided to use an equal weighting
for both.

3.3 Encoder-decoder architecture

We use a CNN-RNN architecture similar to the one proposed
in the original Show-Tell paper [22]. A high-level diagram
is shown in Figure 2. Each symbol in the vocabulary is

1 https://github.com/tylin/coco-caption.
2 https://github.com/peteanderson80/SPICE.

embedded as a 512 dimensional dense word embedding
vector, whose values are initialized randomly.

as

The

encoder

CNN is

implemented

an
Inception-V3 [18] network pretrained on ImageNet3.The
RNN decoder is a one-layer LSTM with a state size of
512 units, initialized randomly. Each image is encoded by
Inception-V3 as a dense feature vector of dimension 2, 048
which is then projected to 512 dimension with a linear layer
and used as the initial state of RNN decoder.

At training time, we always feed in the ground truth
symbol to the RNN decoder; at inference time we use just
greedy decoding, where the sampled output is fed to the
RNN as the next input symbol.

4 Results

4.1 Experimental protocol

We report results obtained by different methods on the
COCO dataset. This has 82,081 training images, and 40,137
validation images, each with at least 5 ground truth captions.
Following standard practice for methods that evaluate on
the COCO test server, we hold out a small subset of 1,665
validation images for hyper-parameter tuning, and use the
remaining combined training and validation set for training.
We preprocess the text data by lower casing, and
replacing words which occur less than 4 times in the 82k
training set with UNK; this results in a vocabulary size of
8,855 (identical to the one used in [22]). At training time,
we keep all captions to their maximum lengths. At testing
time, the generated sequences are truncated to 30 symbols in
all experiments.

We use the Show-Tell model from [22] for all methods.
We “pre-train” this model with MLE, and then optionally
“ﬁne tune” it with other methods, as we discuss below.

4.2 Automatic
metrics

evaluation

using BCMR

In this section, we quantitatively evaluate various methods
using the standard BCMR metrics on the COCO test set.
Since the ground truth is not available for the test set,
we submitted our results to the COCO online evaluation
server4 on Nov 2016. Table 1 shows the results of the
top 5 methods (at the time of submission) on the ofﬁcial
C-5 leaderboard, along with the results of our experiments.
In particular, we tried training the Show-Tell model with
the following methods: MLE, PG-BLEU-4, PG-CIDEr,

3We used the open-source implementation available at: https:

//github.com/tensorflow/models/blob/master/slim/
nets/inception_v3.py

4mscoco.org/dataset/#captions-leaderboard

Under review as a conference paper at ICCV 2017

Submissions

CIDEr-D Meteor ROUGE-L BLEU-1 BLEU-2 BLEU-3 BLEU-4

MSM@MSRA [28]
Review Net [27]
ATT [29]
Google [22]
Berkeley LRCN [7]

MLE
PG-BLEU-4
PG-CIDEr

MIXER-BCMR
MIXER-BCMR-A
PG-BCMR
PG-SPIDEr

0.984
0.965
0.943
0.943
0.921

0.947
0.966
0.995

0.924
0.991
1.013
1.000

0.256
0.256
0.250
0.254
0.247

0.251
0.249
0.249

0.245
0.258
0.257
0.251

0.542
0.533
0.535
0.530
0.528

0.531
0.550
0.548

0.532
0.545
0.55
0.544

0.739
0.720
0.731
0.713
0.718

0.724
0.737
0.737

0.729
0.747
0.754
0.743

0.575
0.550
0.565
0.542
0.548

0.552
0.587
0.581

0.559
0.579
0.591
0.578

0.436
0.414
0.424
0.407
0.409

0.405
0.455
0.442

0.415
0.431
0.445
0.433

0.330
0.313
0.316
0.309
0.306

0.294
0.346
0.333

0.306
0.317
0.332
0.322

Table 1: Automatic evaluation on the ofﬁcial COCO C-5 test split, as of November 2016. Methods below the line are
contributions from this paper.

PG-BCMR, PG-SPIDEr (with equal weight on SPICE and
on CIDEr), and MIXER.

Our MLE method gets similar results to the scheduled
sampling method of [22]. Not surprisingly, PG-BCMR
signiﬁcantly outperforms MLE training, since it directly
optimizes for BCMR. Similarly, PG-BCMR outperforms
PG-SPIDEr. We also showed that PG-BLEU-4 and
PG-CIDEr speciﬁcally improves on the metric optimized
for, compared to MLE baseline. In particular, PG-BLEU-4
successfully achieved the highest score on BLEU metrics,
while largely neglected others.
This demonstrates the
general applicability of our optimization method to target
any speciﬁc metric of interests. However, as shown below
optimizing for the current COCO metrics does not translate
into better captions.

We also see that our PG-BCMR method signiﬁcantly
outperforms all the top 5 methods, even the ones which use
more sophisticated models, such as those based on attention
(Montreal/Toronto, ATT, Review Net), those that use more
complex decoders (Berkeley LRCN), and those that use
high-level visual attributes (MSM@MSRA, ATT).

Our PG-BCMR method also outperforms the MIXER

algorithm; we discuss this in more detail in Section 4.4.

4.3 Human evaluation

Table 2 shows some example captions generated by 6
different methods: MLE, PG-SPICE, MIXER-BCMR,
MIXER-BCMR-A, PG-BCMR, and PG-SPIDEr. We see
that PG-SPICE tends to generate ungrammatical sentences,
with a lot of repeated phrases. This is because SPICE
measures how well the scene graph induced by a sentence
matches the ground truth scene graph, but is relatively
insensitive to syntactic quality. However, when we combine

Figure 3: Results of human evaluation on 492 images
randomly sampled from the COCO test set. We report
the difference in percentage of “not bad” captions for each
method compared to baseline 38% of MLE model.

SPICE with CIDEr, we get much better results. We therefore
ignore pure SPICE in the rest of this paper.

We also see that PG-SPIDEr tends to generate more
reasonable captions that PG-BCMR, even though it did
worse on the COCO metrics. Also, both methods seem to be
better than MLE. (See for example the third row in Table 2.)
To quantify this, we turn to a user study. In particular,
we use a crowd sourcing platform, using raters who have
prior experience with evaluating image captioning and other
computer vision models. We showed each image-caption
pair to 3 different raters, and asked them to evaluate it on
a 4 point scale, depending on whether the caption is “bad”,
“okay”, “good” or “excellent”.5 We then take the majority

5 The deﬁnitions of these terms, which we gave to raters, is as follows.

Under review as a conference paper at ICCV 2017

Images

Ground Truth Captions

Generated Captions

1. a red and yellow ﬁre truck and some buildings
2. An overhead view shows a ﬁre engine in the

3. A red and yellow ﬁre truck with ladders on top
4. A ﬁretruck is parked in the street in between

• MLE: a red and white bus is driving down the street
• PG-SPICE: a red double decker bus on a city street on a
street with a bus on the street with a bus on the street
in front of a bus on

• MIXER-BCMR: a yellow bus driving down a city street .
• MIXER-BCMR-A: a red ﬁre truck driving down a city

5. A ﬁre truck (ladder truck) drives down a street

street .

street.

stop lights.

in the city.

• PG-BCMR: a red bus driving down a city street .
• PG-SPIDEr: a red ﬁre truck is on a city street.

1. A woman walking on a city street in a red coat.
2. A group of people that are standing on the side

3. A woman in a red jacket crossing the street
4. a street light some people and a woman wearing

.

5. A blonde woman in a red coat crosses the street

street .

of a street.

a red jacket

with her friend.

• MLE: a woman walking down a street while holding an

umbrella .

• PG-SPICE: a group of people walking down a street with
a man on a street holding a trafﬁc light and a trafﬁc
light on a city street with a city street

• MIXER-BCMR: a group of people walking down a street

• MIXER-BCMR-A: a group of people walking down a

• PG-BCMR: a group of people walking down a city street .
• PG-SPIDEr: a group of people walking down a street with

a trafﬁc light .

1. A group of people converse in an ofﬁce setting.
2. A group of people playing a game with remote

3. Four young people have crowded into a small

controllers.

ofﬁce.

a room.

5. a group of people standing next to each other
with some of them holding video game
controllers

4. A group of people standing next to each other in

room .

• MLE: a group of people standing around a living room .
• PG-SPICE: a group of people in a room with a man in a
chair holding a nintendo wii remote in a living room
with a man in a chair holding a

• MIXER-BCMR: a group of people standing in a living

• MIXER-BCMR-A: a group of people standing in a living

room playing a video game .

• PG-BCMR: a group of people standing in a room .
• PG-SPIDEr: a group of people playing a video game in a

living room .

1. A man looking through a book on top of a table.
2. A man sitting on a bed looking at a book
3. a man is ﬂipping through a book on a bed
4. A man sitting on a bed ﬂipping through pages of

5. A man in a black jacket is ﬂipping through a

a book.

large book.

• MLE: a man sitting in front of a laptop computer .
• PG-SPICE: a man sitting in front of a book and a laptop on
a table with a laptop computer on top of a table with a
laptop computer on top of

• MIXER-BCMR: a man sitting in a chair with a book .
• MIXER-BCMR-A: a man sitting at a table with a book .
• PG-BCMR: a man sitting in front of a book .
• PG-SPIDEr: a man sitting at a table with a book .

Table 2: Example captions from different models on COCO hold-out validation images.

Under review as a conference paper at ICCV 2017

p-value(X >Y)
PG-SPIDEr
PG-BCMR

PG-BCMR MLE
<0.001
0.003

0.014
-

Table 3: p-values derived from a pairwise sign test applied
to human ratings on 492 images from COCO test set.
Statistically signiﬁcant comparisons (at the 0.05 level) are
shown in bold. X and Y correspond to rows and columns
respectively.

vote to get the ﬁnal rating. If no majority is found, the rating
is considered unknown, and this image is excluded from the
analysis.

Since current captioning systems are far from perfect,
our main goal is to develop a captioning system that does
not make “embarrassing” errors, we focus on measuring the
fraction of captions that are classiﬁed as “not bad”, which
we interpret as the union of “okay”, “good” and “excellent”.
As “quality control”, we ﬁrst evaluated 505 ground truth
captions from the COCO validation set. Humans said that
87% of these captions were “not bad”. Some of the 13%
of ground truth captions that were labeled “bad” do indeed
contain errors6, due to the fact that COCO captions were
generated by AMT workers who are not perfect. On the other
hand, some captions seem reasonable to us, but did not meet
the strict quality criteria our raters were looking for. In any
case, 87% is an approximate upper bound on performance
we can hope to achieve on the COCO test set.

We then randomly sampled 492 images from the test
set (for which we do not have access to the ground truth
captions), and generated captions from all of them using our
3 systems, and sent them for human evaluation. Figure 3
shows the fraction of captions that are “not bad” compared
to the MLE baseline of 38%. We draw the following
conclusions:

• All methods are far below the human ceiling of 87%.
• All PG methods outperform MLE training by a signiﬁcant
margin (see Table 3 for pairwise p-value analysis). This
is because the PG methods optimize metrics that are
much more closely related to caption quality than the
likelihood score.

Excellent: “The caption correctly, speciﬁcally and completely describes
the foreground/main objects/events/theme of the image.” Good: “The
caption correctly and speciﬁcally describes most of the foreground/main
objects/events/theme of the image, but has minor mistakes in some
minor aspects.” Okay: “The caption correctly describes some of the
foreground/main objects/events/theme of the image, but is not speciﬁc to
the image and has minor mistakes in some minor aspects.” Bad: “The
caption misses the foreground/main objects/events/theme of the image or
the caption contains obviously hallucinated objects/activities/relationships.”
6 For example, some captions contain repeated words, e.g., “this is an
image image of a modern kitchen”. Others contain typos, e.g., “a blue and
white truck with pants in it’s ﬂat bed”. And some do not make semantic
sense, e.g., “A crowd of people parked near a double decker bus”.

the

• PG-SPIDEr outperforms PG-BCMR by a 4% margin,
despite
fact
PG-BCMR outperforms
that
This is
PG-SPIDEr on all
the COCO metrics.
because SPIDEr captures both ﬂuency and semantic
properties of the caption, both of which human raters
are told to pay attention to, whereas BCMR is a more
syntactic measure.

4.4 Comparison with MIXER

We now compare our method with [15] in more detail. When
using MLE training, they get a BLEU-4 score of 0.278, and
when they used MIXER to optimize BLEU-4, they get 0.292,
which is about 0.1 better.
(They do not report any other
results besides BLEU-4.) Note, however, that their numbers
are not comparable to the numbers in Table 1, since they are
evaluated on 5000 images from the COCO validation set, and
not the ofﬁcial test server.

In order to do a fair comparison with our work (and other
publications), we reimplemented their algorithm. When we
used their train/test split7, and used our implementation of
MIXER to optimize BLEU-4, we were able to reproduce
their BLEU-4 result. We then used MIXER to optimize
BCMR, using the standard train/test split. Once again, we
see that the BLEU-4 score is about 0.1 better than MLE,
but the other metrics are sometimes worse, whereas our PG
method was signiﬁcantly better than MLE across all metrics.
Upon digging into their open source code8, we noticed
that they used a different optimization algorithm: we use
Adam [10], whereas they used vanilla stochastic gradient
descent with a hard-coded learning rate decay. When we
reran MIXER-BCMR with Adam (a combination we call
MIXER-BCMR-A) with well tuned parameters, we saw
signiﬁcantly improved results, which come closer to our best
results obtained with PG-BCMR in almost all metrics (and
even slightly beating us in Meteor).

However, the ﬁnal results are not the entire story. We have
found that MIXER is much slower to converge, and much
less stable during training, than our PG-Rollout method.
This is illustrated in Figure 4, where we plot the BCMR
metrics on the validation set for three methods: PG-BCMR
(blue), MIXER-BCMR-A (red), MIXER-BCMR (green).
We show the best of 10 runs for MIXER, and a single run
for PG. (Repeated runs of PG give similar performance.)

We see that MIXER-BCMR with vanilla SGD does
poorly. Using Adam helps a lot, but performance is still very
unstable; in particular, we had to try the method 10 times,
with different learning rates and gradient multipliers for the
baseline estimator, to get their best result shown in Figure 4.
Note that the plateau in MIXER’s performance curve for
the ﬁrst 500k steps is because MIXER starts with just MLE

7 We thank Marc’Aurelio Ranzato for sharing their code and data split.
8 https://github.com/facebookresearch/MIXER

Under review as a conference paper at ICCV 2017

(a) BLEU-4

(b) ROUGE-L

(c) CIDEr

(d) METEOR

Performance of PG-BCMR (blue-triangle),
Figure 4:
MIXER-BCMR-A (red-dashed)
and MIXER-BCMR
(green-solid) on the validation set during the ﬁrst 1 million
gradient steps.

training; no progress is made during this time, since we
initialize the models with a model that was already trained
with MLE. At the 500k epoch, MIXER uses MLE for the
ﬁrst 6 words in the caption, and REINFORCE for the rest.
At the 600k epoch, MIXER switches to REINFORCE for the
entire sequence. Over time, the baseline estimator is learned,
and this can compensate for the inaccurate estimate of future
rewards. Hence eventually, MIXER-BCMR-A can catch up
with our PG-Rollout method.

5 Conclusion

In this paper, we have proposed a robust and efﬁcient policy
gradient method, and successfully applied it to optimize a
variety of captioning metrics. By optimizing the standard
COCO metrics, we show that we can achieve state of the
art results, according to the leaderboard. However, we
also show that these metrics do not correlate well with
human judgement. We therefore also proposed a new
metric, SPIDEr, and show that optimizing this with our new
algorithm produces qualitatively superior results, as judged
by human raters.

References

[1] P. Anderson, B. Fernando, M. Johnson, and S. Gould. Spice:
Semantic propositional image caption evaluation. In ECCV,
2016. 1, 2, 5

[2] D. Bahdanau, P. Brakel, K. Xu, A. Goyal, R. Lowe, J. Pineau,
A. Courville, and Y. Bengio. An Actor-Critic algorithm for
sequence prediction. Arxiv, 24 July 2016. 3, 12

[3] S. Banerjee and A. Lavie. METEOR: An automatic metric
for MT evaluation with improved correlation with human
judgments.
In ACL Workshop on MT, volume 29, pages
65–72, 2005. 1

[4] S. Bengio, O. Vinyals, N. Jaitly, and N. Shazeer. Scheduled
sampling for sequence prediction with recurrent neural
networks. In NIPS, 2015. 2

[5] R. Bernardi, R. Cakici, D. Elliott, A. Erdem, E. Erdem,
N. Ikizler-Cinbis, F. Keller, A. Muscat, and B. Plank.
Automatic description generation from images: A survey of
models, datasets, and evaluation measures. J. of AI Research,
55:409–442, 2016. 2

[6] A. Das, S. Kottur, K. Gupta, A. Singh, D. Yadav, J. M.
Moura, D. Parikh, and D. Batra. Visual dialog. arXiv preprint
arXiv:1611.08669, 2016. 1

[7] J. Donahue,

L. Anne Hendricks,

S. Guadarrama,
M. Rohrbach, S. Venugopalan, K. Saenko, and T. Darrell.
for visual
Long-term recurrent convolutional networks
recognition and description. In CVPR, 2015. 6

[8] L. A. Hendricks, Z. Akata, M. Rohrbach, J. Donahue,
B. Schiele, and T. Darrell. Generating visual explanations.
ECCV, 2016. 2

[9] F. Husz´ar.

How (not) to train your generative model:
Scheduled sampling, likelihood, adversary? Arxiv, 16 Nov.
2015. 2

[10] D. Kingma and J. Ba. Adam: A method for stochastic

optimization. In ICLR, 2015. 8

[11] C.-Y. Lin and E. Hovy. Automatic evaluation of summaries
In NAACL, pages

using n-gram co-occurrence statistics.
71–78, 2003. 1

[12] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona,
D. Ramanan, P. Doll´ar, and C. Lawrence Zitnick. Microsoft
COCO: Common objects in context. In ECCV, 1 May 2014.
1

[13] M. Norouzi, S. Bengio, Z. Chen, N. Jaitly, M. Schuster,
Y. Wu, and D. Schuurmans. Reward augmented maximum
likelihood for neural structured prediction. In NIPS, 2016. 3
[14] K. Papineni, S. Roukos, T. Ward, and W.-J. Zhu. BLEU: A
method for automatic evaluation of machine translation.
In
Proc. ACL, pages 311–318, 2002. 1

[15] M. Ranzato, S. Chopra, M. Auli, and W. Zaremba. Sequence
level training with recurrent neural networks. Arxiv, 2015. 1,
2, 3, 8

[16] S. Shen, Y. Cheng, Z. He, W. He, H. Wu, M. Sun, and Y. Liu.
In
Minimum risk training for neural machine translation.
Proc. ACL, 2016. 3

[17] R. S. Sutton, D. Mc Allester, S. Singh, and Y. Mansour. Policy
gradient methods for reinforcement learning with function
approximation. In NIPS, 1999. 1, 2, 3

[18] C. Szegedy, V. Vanhoucke, S. Ioffe, J. Shlens, and Z. Wojna.
Rethinking the inception architecture for computer vision.
arXiv preprint arXiv:1512.00567, 2015. 5

[19] K. Tran, X. He, L. Zhang, J. Sun, C. Carapcea, C. Thrasher,
C. Buehler, and C. Sienkiewicz. Rich image captioning in the
wild. In CVPR, 2016. 2

Under review as a conference paper at ICCV 2017

[20] R. Vedantam, C. Lawrence Zitnick, and D. Parikh. Cider:
In CVPR,

Consensus-based image description evaluation.
pages 4566–4575, 2015. 1

[21] S. Venugopalan, L. A. Hendricks, M. Rohrbach, R. Mooney,
T. Darrell, and K. Saenko. Captioning images with diverse
objects. Arxiv, 24 June 2016. 2

[22] O. Vinyals, A. Toshev, S. Bengio, and D. Erhan. Show and
tell: A neural image caption generator. In CVPR, 2015. 2, 5,
6

[23] R. J. Williams.

Simple statistical gradient-following
algorithms for connectionist reinforcement learning. Machine
Learning J., 8(3-4):229–256, 1 May 1992. 2, 4, 12

[24] Q. Wu, C. Shen, A. van den Hengel, L. Liu, and A. Dick.
What value high level concepts in vision to language
problems? In CVPR, 2016. 2

[25] S. Wu, J. Wieland, O. Farivar, and J. Schiller. Automatic
alt-text: Computer-generated image descriptions for blind
users on a social network service. In Proceedings of the 2017
ACM Conference on Computer Supported Cooperative Work
and Social Computing, pages 1180–1192. ACM, 25 Feb.
2017. 1
[26] K. Xu,

J. Ba, R. Kiros, K. Cho, A. Courville,
R. Salakhutdinov, R. Zemel, and Y. Bengio.
Show,
attend and tell: Neural image caption generation with visual
attention. In ICML, 2015. 2

[27] Z. Yang, Y. Yuan, Y. Wu, R. Salakhutdinov, and W. W. Cohen.
Review networks for caption generation. In NIPS, 2016. 2, 6
[28] T. Yao, Y. Pan, Y. Li, Z. Qiu, and T. Mei. Boosting image
captioning with attributes. In OpenReview, 2016. 2, 6

[29] Q. You, H.

Jin, Z. Wang, C. Fang,
Image captioning with semantic attention.
arXiv:1603.03925, 2016. 6

and J. Luo.
arXiv preprint

[30] L. Yu, W. Zhang, J. Wang, and Y. Yu. SeqGAN: Sequence
generative adversarial nets with policy gradient. Arxiv,
18 Sept. 2016. 3, 4

[31] W. Zaremba and I. Sutskever. Reinforcement learning neural
turing machines-revised. arXiv preprint arXiv:1505.00521,
2015. 4, 12

Under review as a conference paper at ICCV 2017

A Full derivation of policy gradient

we have

Given an image xn and the ground-truth captions yn
associated with xn, the reward for a generated caption ¯g =
g1:T = {g1, g2, ..., gT } is deﬁned as

R(¯g|xn, yn) =

r(gt|g1:(t−1), xn, yn),

(9)

T
(cid:88)

t=1

where r(gt|g1:(t−1), xn, yn) is the incremental reward for
word gt, given previously generated words g1:(t−1) and
(xn, yn). We deﬁne

r(g1|g1:0, xn, yn) = r(g1|xn, yn)

(10)

for notation consistency. Caption ¯g is generated by sampling
one word at each time step from the given vocabulary
V using the conditional probability or policy πθ(¯g|xn)
parameterized by θ. Here θ is the set of weights in the
CNN-RNN neural network covered in section 3.3. The
expected reward for the captions generated by following the
policy πθ(¯g|xn) is

Vθ(xn) = E¯g[R(¯g|xn, yn)] =

πθ(¯g|xn)R(¯g|xn, yn).

(cid:88)

¯g

∇θ log(πθ(¯g|xn)) =

∇θ log(πθ(gt|g1:(t−1), xn)).

T
(cid:88)

t=1

(17)

(18)

Similar to equation (10), we deﬁne

πθ(g1|g1:0, xn) = πθ(g1|xn).

(15) and (17)

Equations
forward
sequence-level Monte Carlo sampling algorithm. But we
will show next that this can be further improved.

suggest a straight

Taking the derivative on both sides of the equation (16)

leads to

∇θπθ(¯g|xn) = ∇θπθ(g1|xn)

πθ(gt|g1:(t−1), xn)

T
(cid:89)

t=2

T
(cid:89)

t=3

+ πθ(g1|xn)∇θπθ(g2|g1, xn)

πθ(gt|g1:(t−1), xn)

+ . . .

T −1
(cid:89)

+

t=1

T
(cid:88)

t=1

πθ(gt|g1:(t−1), xn)∇θπθ(gT |g1:(T −1), xn)

=

πθ(g1:(t−1)|xn)∇θπθ(gt|g1:(t−1), xn)

The goal is to maximize the objective function

× πθ(gt+1:T |g1:t, xn),

J(θ) =

Vθ(xn)

1
N

N
(cid:88)

n=1

where the ﬁrst equality is due to simple calculus rules, and
the second equality is due to the chain rule in equation (16).
Here we deﬁne

(11)

(12)

where N is the number of images in a given training data set.
In this paper we use the gradient-based methods to ﬁnd
the optimal solution θ∗. In view of equation (11), to compute
the gradient

∇θJ(θ) =

∇θVθ(xn),

(13)

1
N

N
(cid:88)

n=1

we just need to focus on the term

∇θVθ(xn) =

∇θπθ(¯g|xn)R(¯g|xn, yn)

(14)

(cid:88)

¯g

(cid:88)

=

¯g

πθ(¯g|xn)∇θ log(πθ(¯g|xn))R(¯g|xn, yn)

= E¯g[∇θ log(πθ(¯g|xn))R(¯g|xn, yn)].

(15)

In view of the chain rule applied to the joint conditional
probability

πθ(g1:0|xn) = 1.
πθ(g(T +1):T |g1:T , xn) = 1.

for notation consistency in equation (19).

To simplify the notation and unless confusion arises, we
will drop the conditional terms (·|xn, yn) and (·|xn) in the
following derivation.

Substituting equation (19)

into equation (14) and

changing the order of summation, we obtain

∇θVθ(xn) =

πθ(g1:(t−1))

∇θπθ(gt|g1:(t−1))

T
(cid:88)

(cid:88)

t=1

g1:(t−1)

(cid:88)

gt

πθ(gt+1:T |g1:t)R(¯g)

=

Eg1:(t−1) [Egt[∇θ log(πθ(gt|g1:(t−1)))Eg(t+1):T [R(¯g)]]].

(cid:88)

×

g(t+1):T

T
(cid:88)

t=1

πθ(¯g|xn) =

πθ(gt|g1:(t−1), xn),

(16)

T
(cid:89)

t=1

Note that In view of equation (9), we can partition the reward
R(¯g) in equation (22) into two parts

R(¯g) = R(g1:(t−1)) + R(g1:(t−1), gt:T ),

(23)

(19)

(20)

(21)

(22)

Egt [∇θ log(πθ(gt|g1:(t−1)))Eg(t+1):T [R(g1:(t−1))]]
= R(g1:(t−1))Egt[∇θ log(πθ(gt|g1:(t−1)))Eg(t+1):T [1]]

Since the second term is

variance problem due to very high dimensionality of the
sample space. For example, the vocabulary of the COCO
If we set caption length
data set is about nine thousand.
T = 30, then the discrete sample space has 900030 grid
points. One commonly used solution is to subtract a constant
from Qθ(g1:(t−1), gt) in equation (27). The inner summation
in equation (27) now becomes

Egt[∇θ log(πθ(gt|g1:(t−1)))(Qθ(g1:(t−1), gt) − B)]. (29)

Egt[∇θ log(πθ(gt|g1:(t−1)))B] = ∇θEgt[B] = 0,

(30)

(25)

this manipulation does not theorectically change the gradient
in equation (27). Prior work in [31, 23] show that

B = Egt[Qθ(g1:(t−1), gt)]

(31)

is effective in reducing the variance due to small sample
size.

Under review as a conference paper at ICCV 2017

where

R(g1:(t−1), gt:T ) =

r(gi|g1:(i−1)).

(24)

T
(cid:88)

i=t

Here we want to show that the contribution of R(g1:(t−1))
to the summation in equation (22) is zero. Speciﬁcally, the
inner summation for R(g1:(t−1)) becomes

= R(g1:(t−1))

[∇θπθ(gt|g1:(t−1))]

(cid:88)

gt

= R(g1:(t−1))∇θEgt[1] = 0,

where the ﬁrst equality is due to the fact that R(g1:(t−1)) is
independent of gt and g(t+1):T , the second equality is due
to the deﬁnition of expectation, and the third equality is due
to the exchange of sum and derivative. The contribution of
R(g1:(t−1), gt:T ) to the summation in equation (22) can be
simpliﬁed as well. Speciﬁcally, the inner most summation
becomes

Qθ(g1:(t−1), gt) = Eg(t+1):T [R(g1:(t−1), gt:T )]
= Eg(t+1):T [r(gt|g1:(t−1)) + R(g1:t, g(t+1):T )]
= r(gt|g1:(t−1))Eg(t+1):T [1] + Eg(t+1):T [R(g1:t, g(t+1):T )]
= r(gt|g1:(t−1)) + Eg(t+1):T [R(g1:t, g(t+1):T )],
(26)

where the second equality is due to the deﬁnition in
equation (24), and the third equality is due to the fact that
r(gt|g1:(t−1)) is independent of g(t+1):T . Hence equation
(22) becomes

∇θVθ(xn) =

Eg1:(t−1) [Egt[∇θ log(πθ(gt|g1:(t−1)))

T
(cid:88)

t=1

× Qθ(g1:(t−1), gt)]]

T
(cid:88)

t=1

T
(cid:88)

(cid:88)

t=1

gt∈V

=

Eg1:T [Egt[∇θ log(πθ(gt|g1:(t−1)))Qθ(g1:(t−1), gt)]]

= Eg1:T [

[∇θπθ(gt|g1:(t−1))Qθ(g1:(t−1), gt)]],

(27)

(28)

where the second equality is due to the fact that the term
Egt [∇θ log(πθ(gt|g1:(t−1)))Qθ(g1:(t−1), gt)] is independent
of gt:T . Equation (28) is also shown in [2].

B Variance reduction

The Monte Carlo sampling used to compute the expectation
in equations (26) and (27) typically suffers from high

8
1
0
2
 
r
a

M
 
2
1
 
 
]

V
C
.
s
c
[
 
 
4
v
0
7
3
0
0
.
2
1
6
1
:
v
i
X
r
a

Improved Image Captioning via Policy Gradient optimization of SPIDEr

Siqi Liu∗1, Zhenhai Zhu2, Ning Ye2, Sergio Guadarrama2, and Kevin Murphy2

siqi.liu@cs.ox.ac.uk
{zhenhai,nye,sguada,kpmurphy}@google.com
1Department of Computer Science, University of Oxford
2Google

Abstract

Current image captioning methods are usually trained via
(penalized) maximum likelihood estimation. However, the
log-likelihood score of a caption does not correlate well with
human assessments of quality. Standard syntactic evaluation
metrics, such as BLEU, METEOR and ROUGE, are also not
well correlated. The newer SPICE and CIDEr metrics are
better correlated, but have traditionally been hard to optimize
for. In this paper, we show how to use a policy gradient (PG)
method to directly optimize a linear combination of SPICE
and CIDEr (a combination we call SPIDEr): the SPICE score
ensures our captions are semantically faithful to the image,
while CIDEr score ensures our captions are syntactically
ﬂuent. The PG method we propose improves on the prior
MIXER approach, by using Monte Carlo rollouts instead of
mixing MLE training with PG. We show empirically that our
algorithm leads to easier optimization and improved results
compared to MIXER. Finally, we show that using our PG
method we can optimize any of the metrics, including the
proposed SPIDEr metric which results in image captions that
are strongly preferred by human raters compared to captions
generated by the same model but trained to optimize MLE
or the COCO metrics.

1

Introduction

Image captioning is the task of describing the visual
content of an image using one or more sentences.
This has many applications,
including text-based image
retrieval, accessibility for blind users [25], and human-robot
interaction [6].

Most methods for solving this task require training a
statistical model on a dataset of (image, caption) pairs. The
model is usually trained to maximize the log likelihood of
the training set. After training, these models are usually

∗The major part of this work was done while Siqi Liu was an intern at

Google.

evaluated by computing a variety of different metrics on
a test set, such as COCO [12]. Standard metrics from
the machine translation community include BLEU [14],
METEOR [3], and ROUGE [11]. More recently,
the
CIDEr metric [20] was proposed, speciﬁcally for the image
captioning task. We shall call the combination of these four
metrics “BCMR”, for short. Unfortunately, none of these
metrics correlate strongly with human measures of caption
quality. In fact, humans score lower on these metrics than
the methods that won the COCO 2015 challenge, despite the
fact that humans are still much better at this task.

These results motivated Anderson et al. [1] to propose
Rather than directly comparing a
the SPICE metric.
generated sentence to a set of reference sentences in terms
of syntactic agreement, SPICE ﬁrst parses each of the
reference sentences, and then uses them to derive an abstract
scene graph representation. The generated sentence is then
also parsed, and compared to the graph;
this allows for
a comparison of the semantic similarity, without paying
attention to syntactic factors (modulo the requirement that
the generated sentence be parseable). [1] showed that SPICE
is the only existing metric that has a strong correlation with
human ratings, and ranks human captions above algorithms
submitted to the COCO benchmark.
is natural

to directly
this is tricky, since it is not
optimize SPICE. However,
a differentiable objective.
In this paper, we show that it
is possible to use policy gradient (PG) methods [17] to
optimize such objectives. The idea of using PG to optimize
non differentiable objectives for image captioning was ﬁrst
proposed in the MIXER paper [15]. However, they only used
it to optimize BLEU-4, which is not correlated with human
quality. Furthermore, when we tried to use their method to
optimize other metrics, such as CIDEr or SPICE, we got
poor results, since their method (which involves an intricate
incremental schedule which mixes from MLE training to full
PG training) is not very robust and require careful tunning.

Given this result,

to want

it

In this paper, we propose an improvement to MIXER,
that uses Monte Carlo rollouts to get a better estimate of the

1

Under review as a conference paper at ICCV 2017

value function, and avoids the need to “mix in” the MLE
objective. We show that this leads to faster convergence,
and is signiﬁcantly more robust to choice of learning rates
and other hyper-parameters. We then show that we can use
our new PG method to optimize the BCMR metrics, thus
achieving state of the art results on the COCO leaderboard,
despite using a very simple baseline model.

However, being on top of the COCO leaderboard is not
our ultimate goal, since we know that the COCO metrics
(based on BCMR) are only weakly correlated with human
judgement [1]. So we decided to optimize SPICE with our
algorithm. Unfortunately, optimizing SPICE produced long
repetitive sentences which are not good results, based either
on BMCR COCO metrics, or as judged by humans.

The reason optimizing SPICE gives poor captions is that
SPICE ignores syntactic quality (see examples in Table 2)
More generally, we argue that a good image captioning
metric should satisfy two criteria:
(1) captions that are
considered good by humans should achieve high scores; and
(2) captions that achieve high scores should be considered
good by humans.
SPICE satisﬁes criterion 1, but not
criterion 2. We therefore propose a new metric, which is
a linear combination of SPICE and CIDEr; we call this new
metric SPIDEr. This metric automatically satisﬁes criterion
1, since both SPICE and CIDEr do. Also, when we optimize
for SPIDEr, we show that the captions are judged by humans
to be signiﬁcantly better than the ones generated by training
the same model using any of the other metrics. This shows
that SPIDEr satisﬁes criterion 2 to a much greater degree
than existing metrics.

In summary, we make the following contributions in this
paper: (1) we identify criteria for a good image captioning
metric, and proposed a new metric, SPIDEr, which meets
both criteria; (2) we propose a new policy gradient method
that can optimize arbitrary captioning metrics, and which is
much faster and more stable than previous PG methods; (3)
we show that using our new PG method to optimize existing
BCMR metrics leads to state of the art results on COCO;
(4) we show that using our new PG method to optimize our
new SPIDEr metric results in much better human scores than
optimizing for other metrics.

2 Related work

There is an extensive body of work on image captioning (see
e.g., [5] for a recent review). Below we summarize some of
the most relevant works.

2.1 Models

Most methods make use an encoder-decoder style neural
network, where the encoder is a convolutional neural
network (CNN), and the decoder a recurrent neural network

(RNN). In this work, we use the encoder-decoder proposed
in [22], known as “Show and Tell” (ST).

Numerous extensions to the basic encoder-decoder
framework have been proposed. One line of work (e.g., the
“Show, Attend and Tell” model of [26], and the “Review
Network” model of [27]), leverages attention, which lets the
decoder focus on speciﬁc parts of the input image when
generating a word. Another line of work enriches the
image encoding beyond just using a CNN that was trained
for image classiﬁcation. For example, [24, 28] use image
taggers, [21] use object detectors, and [19] use face detection
and landmark recognition. We stress that these extensions
are orthogonal to the ideas in this paper.

2.2 Metrics and objective functions

Most prior work uses maximum likelihood estimation
(MLE) for training. That is, the model parameters θ are
trained to maximize

L(θ) =

log p(yn|xn, θ)

1
N

1
N

=

N
(cid:88)

n=1

N
(cid:88)

Tn(cid:88)

n=1

t=1

log p(yn

t |yn

1:t−1, xn, θ)

where xn is the n’th image, yn = (yn

) is the
ground truth caption of the n’th image and N is the total
number of labelled examples.

1 , . . . , yn
Tn

One problem with the MLE objective is that at training
time, each prediction is conditioned on the previously
observed words from the ground truth. At test time, however,
the model will be fed with its own predictions,
leading
to quickly accumulating errors during inference, so the
model will likely diverge from desired trajectories. This
discrepancy is known as “exposure bias” [4]. One solution
to exposure bias is “scheduled sampling” [4], although this
method has been shown to be statistically inconsistent [9].

An alternative to maximizing likelihood is to try to
maximize some other objective that is more closely related
to the true metric of interest. This can be done using a policy
gradient (PG) method [17] such as REINFORCE [23], by
treating the score of a candidate sentence as analogous to a
reward signal in a reinforcement learning setting. In such a
framework, the RNN decoder acts like a stochastic policy,
where choosing an action corresponds to generating the next
word.

[15] use a modiﬁed form of REINFORCE to optimize the
BLEU score for image captioning. We explain this approach
in more detail in Section 2.3, since it is closely related to our
method. [8] used REINFORCE to optimize sequence level
reward such that generated captions are class discriminative.
However, this is a different task than the one we consider.

Under review as a conference paper at ICCV 2017

More recently, there have been a variety of other papers
on optimizing sequence level objective functions (see e.g.,
[13, 30, 2, 16]), but mostly in the context of machine
translation.

2.3 MIXER

The most closely related work is the “MIXER” paper [15].
They also use the REINFORCE method, combined with a
baseline reward estimator. However, they implicitly assume
each intermediate action (word) in a partial sequence has
the same reward as the sequence-level reward, which is not
true in general. To compensate for this, they introduce a
form of training that mixes together the MLE objective and
the REINFORCE objective. Speciﬁcally, they evaluate the
ﬁrst M words using log-likelihood, and the remaining words
using REINFORCE; they gradually decrease M from the
maximum sentence length down to 0.

We have found that MIXER is very sensitive to the form
of the annealing schedule, as well as other hyper-parameters,
such as the learning rate or gradient scaling of the baseline
estimator. We therefore propose a more robust alternative,
in which we replace the constant reward assumption with an
estimate of future rewards based on Monte Carlo rollouts (a
similar idea is used in [30] for GAN training). In Section 4,
we show that this change signiﬁcantly improves convergence
speed, as well as training stability. This lets us easily
optimize a variety of different metrics, including our new
metric, SPIDEr.

3 Methods

In this section, we explain our approach in more detail. First
we discuss the policy gradient method, which can be used
to robustly optimize any kind of reward function. Next we
discuss which reward function to use. Finally, we discuss the
model itself, which is a standard CNN-RNN.

3.1 Training using policy gradient

At time step t, we pick a discrete action, which corresponds
to choosing a word gt ∈ V, using a stochastic policy or
generator πθ(gt|st, x), where st = g1:t−1 is the sequence of
words chosen so far, x is the image and θ are the parameters
of the model. Note that in our case the state transition
function is deterministic: we simply append the word chosen
at time t to get st+1 = st; gt (u; v is the concatenation of the
strings u and v).

When we reach the end of the sequence (i.e., once the
generator emits the end-of-sentence marker), we get a reward
of R(g1:T |xn, yn), which is the score for producing caption
g1:T given image xn and ground truth caption (or set of

Figure 1: The value of each action is estimated as the
average rewards received by its K rollout sequences (i.e.
K = 3). Solid arrows indicate the sequence of actions being
evaluated. The tokens in green and yellow are respectively
BOS (beginning of sequence) and EOS (end of sequence)
tokens. Sequences in blue are rollout sequences sampled
from partial sequences. Note that rollout sequences do not
always have the same length, as they are separately sampled
from a stochastic policy.

reinforcement

captions) yn. This reward can be any function, such as
BCMR or SPICE.
In typical

learning setting, an agent
receives rewards at each intermediate step while future
rewards are discounted to balance short-term and long-term
In our case, however, the agent receive zero reward
gain.
during intermediate steps, observing a reward only at the
end. To mitigate the lack of intermediate reward signal,
we propose to estimate the value of intermediate states
(partial sequence), via Monte-Carlo rollouts. This translate
into signiﬁcantly more robust credit assignment and efﬁcient
gradient estimation, as we show in Section 4. We deﬁne the
value function of a partial sequence as its expected future
reward:

Vθ(g1:t|xn, yn) = Egt+1:T [R(g1:t; gt+1:T |xn, yn)]

(1)

where the expectation is w.r.t. gt+1:T ∼ πθ(·|g1:t, xn).

Our goal is to maximize the average reward starting from

the initial (empty) state s0 deﬁned as:

J(θ) =

Vθ(s0|xn, yn)

(2)

1
N

N
(cid:88)

n=1

where N is the number of examples in the training set. We
now discuss how to optimize Eqn. (2). For simplicity, we
will consider a single example n, so we will drop the xn and
yn notation. To compute the gradient of J(θ), we can use
the policy gradient theorem from [17]. In the special case of
deterministic transition functions, this theorem simpliﬁes as

Under review as a conference paper at ICCV 2017

shown below (see [2]for a proof):

∇θVθ(s0) = Eg1:T

∇θπθ(gt|g1:t−1)Qθ(g1:t−1, gt)





T
(cid:88)

(cid:88)

t=1

gt∈V

(3)
where we deﬁne the Q function for a state-action pair as
follows:

Qθ(g1:t−1, gt) = Egt+1:T [R(g1:t−1; gt; gt+1:T )]

(4)

We can approximate the gradient of the value function with
M sample paths, gm
1:T ∼ πθ, generated from our policy. This
gives

∇θVθ(s0) ≈

Egt

(cid:2)∇θ log πθ(gt|gm

1:t−1)

M
(cid:88)

T
(cid:88)

1
M

t=1

m=1
×Qθ(gm

1:t−1, gt)(cid:3)

(5)

where the expectation is w.r.t. gt ∼ πθ(gt|gm
we have exploited the fact that

1:t−1), and where

∇θπθ(a|s) = πθ(a|s)

= πθ(a|s)∇θ log πθ(a|s)

∇θπθ(a|s)
πθ(a|s)

If we use M = 1, we can additionally replace the Egt with
the value in the sample path, gm
t , as in REINFORCE. In our
experiment, we used M = 1 and we subsequently drop the
superscript m in the rest of this paper for notational clarity.
The only remaining question is how to estimate the
function Q(st, gt). For this, we will follow [30] and use
In particular, we ﬁrst sample K
Monte Carlo rollouts.
continuations of the sequence st; gt to get gk
t+1:T . Then we
compute the average

Q(g1:t−1, gt) ≈

R(g1:t−1; gt; gk

t+1:T )

(6)

1
K

K
(cid:88)

k=1

We estimate how good a particular word choice gt is by
averaging over all complete sequences sampled according
to the current policy, conditioned on the partial sequence
g1:t−1 sampled from the current policy so far. This process
is illustrated in Figure 1. If we are in a terminal state, we
deﬁne Q(g1:T , EOS) = R(g1:T ).

The above gradient estimator is an unbiased but high
variance estimator. One way to reduce its variance is to
estimate the expected baseline reward Egt[Q(g1:t−1, gt)]
using a parametric function; we will denote this baseline
as Bφ(g1:t−1). We then subtract
this baseline from
Qθ(g1:t−1, gt) to get the following estimate for the gradient
(using M = 1 sample paths):





where st = g1:t−1. Subtracting the baseline does not
affect the validity of the estimated gradient, but reduces its
variance. Here, we simply refer to prior work ([31], [23]) for
a full derivation of this property.

We train the parameters φ of the baseline estimator to

minimize the following loss:

Lφ =

EstEgt(Qθ(st, gt) − Bφ(st))2

(8)

(cid:88)

t

In our experiments, the baseline estimator is an MLP which
takes as input the hidden state of the RNN at step t. To
avoid creating a feedback loop, we do not back-propagate
gradients through the hidden state from this loss.

In language generation settings, a major challenge facing
PG methods is the large action space. This is the case in
our task, where the action space corresponds to the entire
vocabulary of 8,855 symbols. To help “warm start” the
training, we pre-train the RNN decoder (stochastic policy)
using MLE training, before switching to PG training. This
prevents the agent from performing random walks through
exponentially many possible paths at the beginning of the
training.

The overall algorithm is summarized in Algorithm 1.
Note that the Monte Carlo rollouts only require a forward
pass through the RNN, which is much more efﬁcient than the
forward-backward pass needed for the CNN. Additionally
the rollouts can be also be done in parallel for multiple
sentences. Consequently, PG training is only about twice
as slow as MLE training (in wall time).

Algorithm 1: PG training algorithm
1 Input: D = {(xn, yn) : n = 1 : N } ;
2 Train πθ(g1:T |x) using MLE on D ;
3 Train Bφ using MC estimates of Qθ on a small subset

of D;

4 for each epoch do
5

for example (xn, yn) do

6

7

8

9

10

11

12

13

Generate sequence g1:T ∼ πθ(·|xn) ;
for t = 1 : T do

Compute Q(g1:t−1, gt) for gt with K
Monte Carlo rollouts, using (6);
Compute estimated baseline Bφ(g1:t−1);

Compute Gθ = ∇θVθ(s0) using (7);
Compute Gφ = ∇φLφ;
SGD update of θ using Gθ;
SGD update of φ using Gφ;

T
(cid:88)

(cid:88)

t=1

gt

∇θVθ(s0) ≈

[πθ(gt|st)∇θ log πθ(gt|st)

3.2 Reward functions for the policy gradient

× (Qθ(st, gt) − Bφ(st))]

(7)

We can use our PG method to optimize many different
reward functions. Common choices include BLEU, CIDEr,

Under review as a conference paper at ICCV 2017

Figure 2: Model architecture of Show and Tell
image
captioning system [22]. The tokens in green and yellow are
respectively BOS (beginning of sequence) and EOS (end of
sequence) tokens. At testing time, output from previous time
step gt−1 is used as input in lieu of yt−1.

METEOR and ROUGE. Code for all of these metrics is
available as part of the COCO evaluation toolkit.1 We
decided to use a weighted combination of all of these. Since
these metrics are not on the same scale, we chose in our
experiments the set of weights such that all metrics have
approximately the same magnitude. More precisely, we
choose the following weighted combination: 0.5*BLEU-1
+ 0.5*BLEU-2 + 1.0*BLEU-3 + 1.0*BLEU-4 + 1.0*CIDEr
+ 5.0*METEOR + 2.0*ROUGE. Optimizing this weighted
combination of BCMR gives state-of-the-art results on the
COCO test set, as we discuss in Section 4.2.

One problem with the BCMR metrics is that individually
they are not well correlated with human judgment [1].
We therefore also tried optimizing the recently introduced
SPICE metric [1], which better reﬂects human estimates of
quality. We use the open source release of the SPICE code2
to evaluate the metric.

Interestingly, we have found that just optimizing SPICE
tended to result in captions which are very detailed, but
which often had many repeated phrases, as we show in
Section 4.
This is because SPICE measures semantic
similarity (in terms of a scene graph) between sets of
sentences, but does not pay attention to syntactical factors
(modulo the requirement that the generated sentence be
parseable). We therefore combined SPICE with the CIDEr
metric (considered the best of the standard automatic metrics
for COCO), a combination we call SPIDEr for short. Based
on initial experiments, we decided to use an equal weighting
for both.

3.3 Encoder-decoder architecture

We use a CNN-RNN architecture similar to the one proposed
in the original Show-Tell paper [22]. A high-level diagram
is shown in Figure 2. Each symbol in the vocabulary is

1 https://github.com/tylin/coco-caption.
2 https://github.com/peteanderson80/SPICE.

embedded as a 512 dimensional dense word embedding
vector, whose values are initialized randomly.

as

The

encoder

CNN is

implemented

an
Inception-V3 [18] network pretrained on ImageNet3.The
RNN decoder is a one-layer LSTM with a state size of
512 units, initialized randomly. Each image is encoded by
Inception-V3 as a dense feature vector of dimension 2, 048
which is then projected to 512 dimension with a linear layer
and used as the initial state of RNN decoder.

At training time, we always feed in the ground truth
symbol to the RNN decoder; at inference time we use just
greedy decoding, where the sampled output is fed to the
RNN as the next input symbol.

4 Results

4.1 Experimental protocol

We report results obtained by different methods on the
COCO dataset. This has 82,081 training images, and 40,137
validation images, each with at least 5 ground truth captions.
Following standard practice for methods that evaluate on
the COCO test server, we hold out a small subset of 1,665
validation images for hyper-parameter tuning, and use the
remaining combined training and validation set for training.
We preprocess the text data by lower casing, and
replacing words which occur less than 4 times in the 82k
training set with UNK; this results in a vocabulary size of
8,855 (identical to the one used in [22]). At training time,
we keep all captions to their maximum lengths. At testing
time, the generated sequences are truncated to 30 symbols in
all experiments.

We use the Show-Tell model from [22] for all methods.
We “pre-train” this model with MLE, and then optionally
“ﬁne tune” it with other methods, as we discuss below.

4.2 Automatic
metrics

evaluation

using BCMR

In this section, we quantitatively evaluate various methods
using the standard BCMR metrics on the COCO test set.
Since the ground truth is not available for the test set,
we submitted our results to the COCO online evaluation
server4 on Nov 2016. Table 1 shows the results of the
top 5 methods (at the time of submission) on the ofﬁcial
C-5 leaderboard, along with the results of our experiments.
In particular, we tried training the Show-Tell model with
the following methods: MLE, PG-BLEU-4, PG-CIDEr,

3We used the open-source implementation available at: https:

//github.com/tensorflow/models/blob/master/slim/
nets/inception_v3.py

4mscoco.org/dataset/#captions-leaderboard

Under review as a conference paper at ICCV 2017

Submissions

CIDEr-D Meteor ROUGE-L BLEU-1 BLEU-2 BLEU-3 BLEU-4

MSM@MSRA [28]
Review Net [27]
ATT [29]
Google [22]
Berkeley LRCN [7]

MLE
PG-BLEU-4
PG-CIDEr

MIXER-BCMR
MIXER-BCMR-A
PG-BCMR
PG-SPIDEr

0.984
0.965
0.943
0.943
0.921

0.947
0.966
0.995

0.924
0.991
1.013
1.000

0.256
0.256
0.250
0.254
0.247

0.251
0.249
0.249

0.245
0.258
0.257
0.251

0.542
0.533
0.535
0.530
0.528

0.531
0.550
0.548

0.532
0.545
0.55
0.544

0.739
0.720
0.731
0.713
0.718

0.724
0.737
0.737

0.729
0.747
0.754
0.743

0.575
0.550
0.565
0.542
0.548

0.552
0.587
0.581

0.559
0.579
0.591
0.578

0.436
0.414
0.424
0.407
0.409

0.405
0.455
0.442

0.415
0.431
0.445
0.433

0.330
0.313
0.316
0.309
0.306

0.294
0.346
0.333

0.306
0.317
0.332
0.322

Table 1: Automatic evaluation on the ofﬁcial COCO C-5 test split, as of November 2016. Methods below the line are
contributions from this paper.

PG-BCMR, PG-SPIDEr (with equal weight on SPICE and
on CIDEr), and MIXER.

Our MLE method gets similar results to the scheduled
sampling method of [22]. Not surprisingly, PG-BCMR
signiﬁcantly outperforms MLE training, since it directly
optimizes for BCMR. Similarly, PG-BCMR outperforms
PG-SPIDEr. We also showed that PG-BLEU-4 and
PG-CIDEr speciﬁcally improves on the metric optimized
for, compared to MLE baseline. In particular, PG-BLEU-4
successfully achieved the highest score on BLEU metrics,
while largely neglected others.
This demonstrates the
general applicability of our optimization method to target
any speciﬁc metric of interests. However, as shown below
optimizing for the current COCO metrics does not translate
into better captions.

We also see that our PG-BCMR method signiﬁcantly
outperforms all the top 5 methods, even the ones which use
more sophisticated models, such as those based on attention
(Montreal/Toronto, ATT, Review Net), those that use more
complex decoders (Berkeley LRCN), and those that use
high-level visual attributes (MSM@MSRA, ATT).

Our PG-BCMR method also outperforms the MIXER

algorithm; we discuss this in more detail in Section 4.4.

4.3 Human evaluation

Table 2 shows some example captions generated by 6
different methods: MLE, PG-SPICE, MIXER-BCMR,
MIXER-BCMR-A, PG-BCMR, and PG-SPIDEr. We see
that PG-SPICE tends to generate ungrammatical sentences,
with a lot of repeated phrases. This is because SPICE
measures how well the scene graph induced by a sentence
matches the ground truth scene graph, but is relatively
insensitive to syntactic quality. However, when we combine

Figure 3: Results of human evaluation on 492 images
randomly sampled from the COCO test set. We report
the difference in percentage of “not bad” captions for each
method compared to baseline 38% of MLE model.

SPICE with CIDEr, we get much better results. We therefore
ignore pure SPICE in the rest of this paper.

We also see that PG-SPIDEr tends to generate more
reasonable captions that PG-BCMR, even though it did
worse on the COCO metrics. Also, both methods seem to be
better than MLE. (See for example the third row in Table 2.)
To quantify this, we turn to a user study. In particular,
we use a crowd sourcing platform, using raters who have
prior experience with evaluating image captioning and other
computer vision models. We showed each image-caption
pair to 3 different raters, and asked them to evaluate it on
a 4 point scale, depending on whether the caption is “bad”,
“okay”, “good” or “excellent”.5 We then take the majority

5 The deﬁnitions of these terms, which we gave to raters, is as follows.

Under review as a conference paper at ICCV 2017

Images

Ground Truth Captions

Generated Captions

1. a red and yellow ﬁre truck and some buildings
2. An overhead view shows a ﬁre engine in the

3. A red and yellow ﬁre truck with ladders on top
4. A ﬁretruck is parked in the street in between

• MLE: a red and white bus is driving down the street
• PG-SPICE: a red double decker bus on a city street on a
street with a bus on the street with a bus on the street
in front of a bus on

• MIXER-BCMR: a yellow bus driving down a city street .
• MIXER-BCMR-A: a red ﬁre truck driving down a city

5. A ﬁre truck (ladder truck) drives down a street

street .

street.

stop lights.

in the city.

• PG-BCMR: a red bus driving down a city street .
• PG-SPIDEr: a red ﬁre truck is on a city street.

1. A woman walking on a city street in a red coat.
2. A group of people that are standing on the side

3. A woman in a red jacket crossing the street
4. a street light some people and a woman wearing

.

5. A blonde woman in a red coat crosses the street

street .

of a street.

a red jacket

with her friend.

• MLE: a woman walking down a street while holding an

umbrella .

• PG-SPICE: a group of people walking down a street with
a man on a street holding a trafﬁc light and a trafﬁc
light on a city street with a city street

• MIXER-BCMR: a group of people walking down a street

• MIXER-BCMR-A: a group of people walking down a

• PG-BCMR: a group of people walking down a city street .
• PG-SPIDEr: a group of people walking down a street with

a trafﬁc light .

1. A group of people converse in an ofﬁce setting.
2. A group of people playing a game with remote

3. Four young people have crowded into a small

controllers.

ofﬁce.

a room.

5. a group of people standing next to each other
with some of them holding video game
controllers

4. A group of people standing next to each other in

room .

• MLE: a group of people standing around a living room .
• PG-SPICE: a group of people in a room with a man in a
chair holding a nintendo wii remote in a living room
with a man in a chair holding a

• MIXER-BCMR: a group of people standing in a living

• MIXER-BCMR-A: a group of people standing in a living

room playing a video game .

• PG-BCMR: a group of people standing in a room .
• PG-SPIDEr: a group of people playing a video game in a

living room .

1. A man looking through a book on top of a table.
2. A man sitting on a bed looking at a book
3. a man is ﬂipping through a book on a bed
4. A man sitting on a bed ﬂipping through pages of

5. A man in a black jacket is ﬂipping through a

a book.

large book.

• MLE: a man sitting in front of a laptop computer .
• PG-SPICE: a man sitting in front of a book and a laptop on
a table with a laptop computer on top of a table with a
laptop computer on top of

• MIXER-BCMR: a man sitting in a chair with a book .
• MIXER-BCMR-A: a man sitting at a table with a book .
• PG-BCMR: a man sitting in front of a book .
• PG-SPIDEr: a man sitting at a table with a book .

Table 2: Example captions from different models on COCO hold-out validation images.

Under review as a conference paper at ICCV 2017

p-value(X >Y)
PG-SPIDEr
PG-BCMR

PG-BCMR MLE
<0.001
0.003

0.014
-

Table 3: p-values derived from a pairwise sign test applied
to human ratings on 492 images from COCO test set.
Statistically signiﬁcant comparisons (at the 0.05 level) are
shown in bold. X and Y correspond to rows and columns
respectively.

vote to get the ﬁnal rating. If no majority is found, the rating
is considered unknown, and this image is excluded from the
analysis.

Since current captioning systems are far from perfect,
our main goal is to develop a captioning system that does
not make “embarrassing” errors, we focus on measuring the
fraction of captions that are classiﬁed as “not bad”, which
we interpret as the union of “okay”, “good” and “excellent”.
As “quality control”, we ﬁrst evaluated 505 ground truth
captions from the COCO validation set. Humans said that
87% of these captions were “not bad”. Some of the 13%
of ground truth captions that were labeled “bad” do indeed
contain errors6, due to the fact that COCO captions were
generated by AMT workers who are not perfect. On the other
hand, some captions seem reasonable to us, but did not meet
the strict quality criteria our raters were looking for. In any
case, 87% is an approximate upper bound on performance
we can hope to achieve on the COCO test set.

We then randomly sampled 492 images from the test
set (for which we do not have access to the ground truth
captions), and generated captions from all of them using our
3 systems, and sent them for human evaluation. Figure 3
shows the fraction of captions that are “not bad” compared
to the MLE baseline of 38%. We draw the following
conclusions:

• All methods are far below the human ceiling of 87%.
• All PG methods outperform MLE training by a signiﬁcant
margin (see Table 3 for pairwise p-value analysis). This
is because the PG methods optimize metrics that are
much more closely related to caption quality than the
likelihood score.

Excellent: “The caption correctly, speciﬁcally and completely describes
the foreground/main objects/events/theme of the image.” Good: “The
caption correctly and speciﬁcally describes most of the foreground/main
objects/events/theme of the image, but has minor mistakes in some
minor aspects.” Okay: “The caption correctly describes some of the
foreground/main objects/events/theme of the image, but is not speciﬁc to
the image and has minor mistakes in some minor aspects.” Bad: “The
caption misses the foreground/main objects/events/theme of the image or
the caption contains obviously hallucinated objects/activities/relationships.”
6 For example, some captions contain repeated words, e.g., “this is an
image image of a modern kitchen”. Others contain typos, e.g., “a blue and
white truck with pants in it’s ﬂat bed”. And some do not make semantic
sense, e.g., “A crowd of people parked near a double decker bus”.

the

• PG-SPIDEr outperforms PG-BCMR by a 4% margin,
despite
fact
PG-BCMR outperforms
that
This is
PG-SPIDEr on all
the COCO metrics.
because SPIDEr captures both ﬂuency and semantic
properties of the caption, both of which human raters
are told to pay attention to, whereas BCMR is a more
syntactic measure.

4.4 Comparison with MIXER

We now compare our method with [15] in more detail. When
using MLE training, they get a BLEU-4 score of 0.278, and
when they used MIXER to optimize BLEU-4, they get 0.292,
which is about 0.1 better.
(They do not report any other
results besides BLEU-4.) Note, however, that their numbers
are not comparable to the numbers in Table 1, since they are
evaluated on 5000 images from the COCO validation set, and
not the ofﬁcial test server.

In order to do a fair comparison with our work (and other
publications), we reimplemented their algorithm. When we
used their train/test split7, and used our implementation of
MIXER to optimize BLEU-4, we were able to reproduce
their BLEU-4 result. We then used MIXER to optimize
BCMR, using the standard train/test split. Once again, we
see that the BLEU-4 score is about 0.1 better than MLE,
but the other metrics are sometimes worse, whereas our PG
method was signiﬁcantly better than MLE across all metrics.
Upon digging into their open source code8, we noticed
that they used a different optimization algorithm: we use
Adam [10], whereas they used vanilla stochastic gradient
descent with a hard-coded learning rate decay. When we
reran MIXER-BCMR with Adam (a combination we call
MIXER-BCMR-A) with well tuned parameters, we saw
signiﬁcantly improved results, which come closer to our best
results obtained with PG-BCMR in almost all metrics (and
even slightly beating us in Meteor).

However, the ﬁnal results are not the entire story. We have
found that MIXER is much slower to converge, and much
less stable during training, than our PG-Rollout method.
This is illustrated in Figure 4, where we plot the BCMR
metrics on the validation set for three methods: PG-BCMR
(blue), MIXER-BCMR-A (red), MIXER-BCMR (green).
We show the best of 10 runs for MIXER, and a single run
for PG. (Repeated runs of PG give similar performance.)

We see that MIXER-BCMR with vanilla SGD does
poorly. Using Adam helps a lot, but performance is still very
unstable; in particular, we had to try the method 10 times,
with different learning rates and gradient multipliers for the
baseline estimator, to get their best result shown in Figure 4.
Note that the plateau in MIXER’s performance curve for
the ﬁrst 500k steps is because MIXER starts with just MLE

7 We thank Marc’Aurelio Ranzato for sharing their code and data split.
8 https://github.com/facebookresearch/MIXER

Under review as a conference paper at ICCV 2017

(a) BLEU-4

(b) ROUGE-L

(c) CIDEr

(d) METEOR

Performance of PG-BCMR (blue-triangle),
Figure 4:
MIXER-BCMR-A (red-dashed)
and MIXER-BCMR
(green-solid) on the validation set during the ﬁrst 1 million
gradient steps.

training; no progress is made during this time, since we
initialize the models with a model that was already trained
with MLE. At the 500k epoch, MIXER uses MLE for the
ﬁrst 6 words in the caption, and REINFORCE for the rest.
At the 600k epoch, MIXER switches to REINFORCE for the
entire sequence. Over time, the baseline estimator is learned,
and this can compensate for the inaccurate estimate of future
rewards. Hence eventually, MIXER-BCMR-A can catch up
with our PG-Rollout method.

5 Conclusion

In this paper, we have proposed a robust and efﬁcient policy
gradient method, and successfully applied it to optimize a
variety of captioning metrics. By optimizing the standard
COCO metrics, we show that we can achieve state of the
art results, according to the leaderboard. However, we
also show that these metrics do not correlate well with
human judgement. We therefore also proposed a new
metric, SPIDEr, and show that optimizing this with our new
algorithm produces qualitatively superior results, as judged
by human raters.

References

[1] P. Anderson, B. Fernando, M. Johnson, and S. Gould. Spice:
Semantic propositional image caption evaluation. In ECCV,
2016. 1, 2, 5

[2] D. Bahdanau, P. Brakel, K. Xu, A. Goyal, R. Lowe, J. Pineau,
A. Courville, and Y. Bengio. An Actor-Critic algorithm for
sequence prediction. Arxiv, 24 July 2016. 3, 12

[3] S. Banerjee and A. Lavie. METEOR: An automatic metric
for MT evaluation with improved correlation with human
judgments.
In ACL Workshop on MT, volume 29, pages
65–72, 2005. 1

[4] S. Bengio, O. Vinyals, N. Jaitly, and N. Shazeer. Scheduled
sampling for sequence prediction with recurrent neural
networks. In NIPS, 2015. 2

[5] R. Bernardi, R. Cakici, D. Elliott, A. Erdem, E. Erdem,
N. Ikizler-Cinbis, F. Keller, A. Muscat, and B. Plank.
Automatic description generation from images: A survey of
models, datasets, and evaluation measures. J. of AI Research,
55:409–442, 2016. 2

[6] A. Das, S. Kottur, K. Gupta, A. Singh, D. Yadav, J. M.
Moura, D. Parikh, and D. Batra. Visual dialog. arXiv preprint
arXiv:1611.08669, 2016. 1

[7] J. Donahue,

L. Anne Hendricks,

S. Guadarrama,
M. Rohrbach, S. Venugopalan, K. Saenko, and T. Darrell.
for visual
Long-term recurrent convolutional networks
recognition and description. In CVPR, 2015. 6

[8] L. A. Hendricks, Z. Akata, M. Rohrbach, J. Donahue,
B. Schiele, and T. Darrell. Generating visual explanations.
ECCV, 2016. 2

[9] F. Husz´ar.

How (not) to train your generative model:
Scheduled sampling, likelihood, adversary? Arxiv, 16 Nov.
2015. 2

[10] D. Kingma and J. Ba. Adam: A method for stochastic

optimization. In ICLR, 2015. 8

[11] C.-Y. Lin and E. Hovy. Automatic evaluation of summaries
In NAACL, pages

using n-gram co-occurrence statistics.
71–78, 2003. 1

[12] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona,
D. Ramanan, P. Doll´ar, and C. Lawrence Zitnick. Microsoft
COCO: Common objects in context. In ECCV, 1 May 2014.
1

[13] M. Norouzi, S. Bengio, Z. Chen, N. Jaitly, M. Schuster,
Y. Wu, and D. Schuurmans. Reward augmented maximum
likelihood for neural structured prediction. In NIPS, 2016. 3
[14] K. Papineni, S. Roukos, T. Ward, and W.-J. Zhu. BLEU: A
method for automatic evaluation of machine translation.
In
Proc. ACL, pages 311–318, 2002. 1

[15] M. Ranzato, S. Chopra, M. Auli, and W. Zaremba. Sequence
level training with recurrent neural networks. Arxiv, 2015. 1,
2, 3, 8

[16] S. Shen, Y. Cheng, Z. He, W. He, H. Wu, M. Sun, and Y. Liu.
In
Minimum risk training for neural machine translation.
Proc. ACL, 2016. 3

[17] R. S. Sutton, D. Mc Allester, S. Singh, and Y. Mansour. Policy
gradient methods for reinforcement learning with function
approximation. In NIPS, 1999. 1, 2, 3

[18] C. Szegedy, V. Vanhoucke, S. Ioffe, J. Shlens, and Z. Wojna.
Rethinking the inception architecture for computer vision.
arXiv preprint arXiv:1512.00567, 2015. 5

[19] K. Tran, X. He, L. Zhang, J. Sun, C. Carapcea, C. Thrasher,
C. Buehler, and C. Sienkiewicz. Rich image captioning in the
wild. In CVPR, 2016. 2

Under review as a conference paper at ICCV 2017

[20] R. Vedantam, C. Lawrence Zitnick, and D. Parikh. Cider:
In CVPR,

Consensus-based image description evaluation.
pages 4566–4575, 2015. 1

[21] S. Venugopalan, L. A. Hendricks, M. Rohrbach, R. Mooney,
T. Darrell, and K. Saenko. Captioning images with diverse
objects. Arxiv, 24 June 2016. 2

[22] O. Vinyals, A. Toshev, S. Bengio, and D. Erhan. Show and
tell: A neural image caption generator. In CVPR, 2015. 2, 5,
6

[23] R. J. Williams.

Simple statistical gradient-following
algorithms for connectionist reinforcement learning. Machine
Learning J., 8(3-4):229–256, 1 May 1992. 2, 4, 12

[24] Q. Wu, C. Shen, A. van den Hengel, L. Liu, and A. Dick.
What value high level concepts in vision to language
problems? In CVPR, 2016. 2

[25] S. Wu, J. Wieland, O. Farivar, and J. Schiller. Automatic
alt-text: Computer-generated image descriptions for blind
users on a social network service. In Proceedings of the 2017
ACM Conference on Computer Supported Cooperative Work
and Social Computing, pages 1180–1192. ACM, 25 Feb.
2017. 1
[26] K. Xu,

J. Ba, R. Kiros, K. Cho, A. Courville,
R. Salakhutdinov, R. Zemel, and Y. Bengio.
Show,
attend and tell: Neural image caption generation with visual
attention. In ICML, 2015. 2

[27] Z. Yang, Y. Yuan, Y. Wu, R. Salakhutdinov, and W. W. Cohen.
Review networks for caption generation. In NIPS, 2016. 2, 6
[28] T. Yao, Y. Pan, Y. Li, Z. Qiu, and T. Mei. Boosting image
captioning with attributes. In OpenReview, 2016. 2, 6

[29] Q. You, H.

Jin, Z. Wang, C. Fang,
Image captioning with semantic attention.
arXiv:1603.03925, 2016. 6

and J. Luo.
arXiv preprint

[30] L. Yu, W. Zhang, J. Wang, and Y. Yu. SeqGAN: Sequence
generative adversarial nets with policy gradient. Arxiv,
18 Sept. 2016. 3, 4

[31] W. Zaremba and I. Sutskever. Reinforcement learning neural
turing machines-revised. arXiv preprint arXiv:1505.00521,
2015. 4, 12

Under review as a conference paper at ICCV 2017

A Full derivation of policy gradient

we have

Given an image xn and the ground-truth captions yn
associated with xn, the reward for a generated caption ¯g =
g1:T = {g1, g2, ..., gT } is deﬁned as

R(¯g|xn, yn) =

r(gt|g1:(t−1), xn, yn),

(9)

T
(cid:88)

t=1

where r(gt|g1:(t−1), xn, yn) is the incremental reward for
word gt, given previously generated words g1:(t−1) and
(xn, yn). We deﬁne

r(g1|g1:0, xn, yn) = r(g1|xn, yn)

(10)

for notation consistency. Caption ¯g is generated by sampling
one word at each time step from the given vocabulary
V using the conditional probability or policy πθ(¯g|xn)
parameterized by θ. Here θ is the set of weights in the
CNN-RNN neural network covered in section 3.3. The
expected reward for the captions generated by following the
policy πθ(¯g|xn) is

Vθ(xn) = E¯g[R(¯g|xn, yn)] =

πθ(¯g|xn)R(¯g|xn, yn).

(cid:88)

¯g

∇θ log(πθ(¯g|xn)) =

∇θ log(πθ(gt|g1:(t−1), xn)).

T
(cid:88)

t=1

(17)

(18)

Similar to equation (10), we deﬁne

πθ(g1|g1:0, xn) = πθ(g1|xn).

(15) and (17)

Equations
forward
sequence-level Monte Carlo sampling algorithm. But we
will show next that this can be further improved.

suggest a straight

Taking the derivative on both sides of the equation (16)

leads to

∇θπθ(¯g|xn) = ∇θπθ(g1|xn)

πθ(gt|g1:(t−1), xn)

T
(cid:89)

t=2

T
(cid:89)

t=3

+ πθ(g1|xn)∇θπθ(g2|g1, xn)

πθ(gt|g1:(t−1), xn)

+ . . .

T −1
(cid:89)

+

t=1

T
(cid:88)

t=1

πθ(gt|g1:(t−1), xn)∇θπθ(gT |g1:(T −1), xn)

=

πθ(g1:(t−1)|xn)∇θπθ(gt|g1:(t−1), xn)

The goal is to maximize the objective function

× πθ(gt+1:T |g1:t, xn),

J(θ) =

Vθ(xn)

1
N

N
(cid:88)

n=1

where the ﬁrst equality is due to simple calculus rules, and
the second equality is due to the chain rule in equation (16).
Here we deﬁne

(11)

(12)

where N is the number of images in a given training data set.
In this paper we use the gradient-based methods to ﬁnd
the optimal solution θ∗. In view of equation (11), to compute
the gradient

∇θJ(θ) =

∇θVθ(xn),

(13)

1
N

N
(cid:88)

n=1

we just need to focus on the term

∇θVθ(xn) =

∇θπθ(¯g|xn)R(¯g|xn, yn)

(14)

(cid:88)

¯g

(cid:88)

=

¯g

πθ(¯g|xn)∇θ log(πθ(¯g|xn))R(¯g|xn, yn)

= E¯g[∇θ log(πθ(¯g|xn))R(¯g|xn, yn)].

(15)

In view of the chain rule applied to the joint conditional
probability

πθ(g1:0|xn) = 1.
πθ(g(T +1):T |g1:T , xn) = 1.

for notation consistency in equation (19).

To simplify the notation and unless confusion arises, we
will drop the conditional terms (·|xn, yn) and (·|xn) in the
following derivation.

Substituting equation (19)

into equation (14) and

changing the order of summation, we obtain

∇θVθ(xn) =

πθ(g1:(t−1))

∇θπθ(gt|g1:(t−1))

T
(cid:88)

(cid:88)

t=1

g1:(t−1)

(cid:88)

gt

πθ(gt+1:T |g1:t)R(¯g)

=

Eg1:(t−1) [Egt[∇θ log(πθ(gt|g1:(t−1)))Eg(t+1):T [R(¯g)]]].

(cid:88)

×

g(t+1):T

T
(cid:88)

t=1

πθ(¯g|xn) =

πθ(gt|g1:(t−1), xn),

(16)

T
(cid:89)

t=1

Note that In view of equation (9), we can partition the reward
R(¯g) in equation (22) into two parts

R(¯g) = R(g1:(t−1)) + R(g1:(t−1), gt:T ),

(23)

(19)

(20)

(21)

(22)

Egt [∇θ log(πθ(gt|g1:(t−1)))Eg(t+1):T [R(g1:(t−1))]]
= R(g1:(t−1))Egt[∇θ log(πθ(gt|g1:(t−1)))Eg(t+1):T [1]]

Since the second term is

variance problem due to very high dimensionality of the
sample space. For example, the vocabulary of the COCO
If we set caption length
data set is about nine thousand.
T = 30, then the discrete sample space has 900030 grid
points. One commonly used solution is to subtract a constant
from Qθ(g1:(t−1), gt) in equation (27). The inner summation
in equation (27) now becomes

Egt[∇θ log(πθ(gt|g1:(t−1)))(Qθ(g1:(t−1), gt) − B)]. (29)

Egt[∇θ log(πθ(gt|g1:(t−1)))B] = ∇θEgt[B] = 0,

(30)

(25)

this manipulation does not theorectically change the gradient
in equation (27). Prior work in [31, 23] show that

B = Egt[Qθ(g1:(t−1), gt)]

(31)

is effective in reducing the variance due to small sample
size.

Under review as a conference paper at ICCV 2017

where

R(g1:(t−1), gt:T ) =

r(gi|g1:(i−1)).

(24)

T
(cid:88)

i=t

Here we want to show that the contribution of R(g1:(t−1))
to the summation in equation (22) is zero. Speciﬁcally, the
inner summation for R(g1:(t−1)) becomes

= R(g1:(t−1))

[∇θπθ(gt|g1:(t−1))]

(cid:88)

gt

= R(g1:(t−1))∇θEgt[1] = 0,

where the ﬁrst equality is due to the fact that R(g1:(t−1)) is
independent of gt and g(t+1):T , the second equality is due
to the deﬁnition of expectation, and the third equality is due
to the exchange of sum and derivative. The contribution of
R(g1:(t−1), gt:T ) to the summation in equation (22) can be
simpliﬁed as well. Speciﬁcally, the inner most summation
becomes

Qθ(g1:(t−1), gt) = Eg(t+1):T [R(g1:(t−1), gt:T )]
= Eg(t+1):T [r(gt|g1:(t−1)) + R(g1:t, g(t+1):T )]
= r(gt|g1:(t−1))Eg(t+1):T [1] + Eg(t+1):T [R(g1:t, g(t+1):T )]
= r(gt|g1:(t−1)) + Eg(t+1):T [R(g1:t, g(t+1):T )],
(26)

where the second equality is due to the deﬁnition in
equation (24), and the third equality is due to the fact that
r(gt|g1:(t−1)) is independent of g(t+1):T . Hence equation
(22) becomes

∇θVθ(xn) =

Eg1:(t−1) [Egt[∇θ log(πθ(gt|g1:(t−1)))

T
(cid:88)

t=1

× Qθ(g1:(t−1), gt)]]

T
(cid:88)

t=1

T
(cid:88)

(cid:88)

t=1

gt∈V

=

Eg1:T [Egt[∇θ log(πθ(gt|g1:(t−1)))Qθ(g1:(t−1), gt)]]

= Eg1:T [

[∇θπθ(gt|g1:(t−1))Qθ(g1:(t−1), gt)]],

(27)

(28)

where the second equality is due to the fact that the term
Egt [∇θ log(πθ(gt|g1:(t−1)))Qθ(g1:(t−1), gt)] is independent
of gt:T . Equation (28) is also shown in [2].

B Variance reduction

The Monte Carlo sampling used to compute the expectation
in equations (26) and (27) typically suffers from high

8
1
0
2
 
r
a

M
 
2
1
 
 
]

V
C
.
s
c
[
 
 
4
v
0
7
3
0
0
.
2
1
6
1
:
v
i
X
r
a

Improved Image Captioning via Policy Gradient optimization of SPIDEr

Siqi Liu∗1, Zhenhai Zhu2, Ning Ye2, Sergio Guadarrama2, and Kevin Murphy2

siqi.liu@cs.ox.ac.uk
{zhenhai,nye,sguada,kpmurphy}@google.com
1Department of Computer Science, University of Oxford
2Google

Abstract

Current image captioning methods are usually trained via
(penalized) maximum likelihood estimation. However, the
log-likelihood score of a caption does not correlate well with
human assessments of quality. Standard syntactic evaluation
metrics, such as BLEU, METEOR and ROUGE, are also not
well correlated. The newer SPICE and CIDEr metrics are
better correlated, but have traditionally been hard to optimize
for. In this paper, we show how to use a policy gradient (PG)
method to directly optimize a linear combination of SPICE
and CIDEr (a combination we call SPIDEr): the SPICE score
ensures our captions are semantically faithful to the image,
while CIDEr score ensures our captions are syntactically
ﬂuent. The PG method we propose improves on the prior
MIXER approach, by using Monte Carlo rollouts instead of
mixing MLE training with PG. We show empirically that our
algorithm leads to easier optimization and improved results
compared to MIXER. Finally, we show that using our PG
method we can optimize any of the metrics, including the
proposed SPIDEr metric which results in image captions that
are strongly preferred by human raters compared to captions
generated by the same model but trained to optimize MLE
or the COCO metrics.

1

Introduction

Image captioning is the task of describing the visual
content of an image using one or more sentences.
This has many applications,
including text-based image
retrieval, accessibility for blind users [25], and human-robot
interaction [6].

Most methods for solving this task require training a
statistical model on a dataset of (image, caption) pairs. The
model is usually trained to maximize the log likelihood of
the training set. After training, these models are usually

∗The major part of this work was done while Siqi Liu was an intern at

Google.

evaluated by computing a variety of different metrics on
a test set, such as COCO [12]. Standard metrics from
the machine translation community include BLEU [14],
METEOR [3], and ROUGE [11]. More recently,
the
CIDEr metric [20] was proposed, speciﬁcally for the image
captioning task. We shall call the combination of these four
metrics “BCMR”, for short. Unfortunately, none of these
metrics correlate strongly with human measures of caption
quality. In fact, humans score lower on these metrics than
the methods that won the COCO 2015 challenge, despite the
fact that humans are still much better at this task.

These results motivated Anderson et al. [1] to propose
Rather than directly comparing a
the SPICE metric.
generated sentence to a set of reference sentences in terms
of syntactic agreement, SPICE ﬁrst parses each of the
reference sentences, and then uses them to derive an abstract
scene graph representation. The generated sentence is then
also parsed, and compared to the graph;
this allows for
a comparison of the semantic similarity, without paying
attention to syntactic factors (modulo the requirement that
the generated sentence be parseable). [1] showed that SPICE
is the only existing metric that has a strong correlation with
human ratings, and ranks human captions above algorithms
submitted to the COCO benchmark.
is natural

to directly
this is tricky, since it is not
optimize SPICE. However,
a differentiable objective.
In this paper, we show that it
is possible to use policy gradient (PG) methods [17] to
optimize such objectives. The idea of using PG to optimize
non differentiable objectives for image captioning was ﬁrst
proposed in the MIXER paper [15]. However, they only used
it to optimize BLEU-4, which is not correlated with human
quality. Furthermore, when we tried to use their method to
optimize other metrics, such as CIDEr or SPICE, we got
poor results, since their method (which involves an intricate
incremental schedule which mixes from MLE training to full
PG training) is not very robust and require careful tunning.

Given this result,

to want

it

In this paper, we propose an improvement to MIXER,
that uses Monte Carlo rollouts to get a better estimate of the

1

Under review as a conference paper at ICCV 2017

value function, and avoids the need to “mix in” the MLE
objective. We show that this leads to faster convergence,
and is signiﬁcantly more robust to choice of learning rates
and other hyper-parameters. We then show that we can use
our new PG method to optimize the BCMR metrics, thus
achieving state of the art results on the COCO leaderboard,
despite using a very simple baseline model.

However, being on top of the COCO leaderboard is not
our ultimate goal, since we know that the COCO metrics
(based on BCMR) are only weakly correlated with human
judgement [1]. So we decided to optimize SPICE with our
algorithm. Unfortunately, optimizing SPICE produced long
repetitive sentences which are not good results, based either
on BMCR COCO metrics, or as judged by humans.

The reason optimizing SPICE gives poor captions is that
SPICE ignores syntactic quality (see examples in Table 2)
More generally, we argue that a good image captioning
metric should satisfy two criteria:
(1) captions that are
considered good by humans should achieve high scores; and
(2) captions that achieve high scores should be considered
good by humans.
SPICE satisﬁes criterion 1, but not
criterion 2. We therefore propose a new metric, which is
a linear combination of SPICE and CIDEr; we call this new
metric SPIDEr. This metric automatically satisﬁes criterion
1, since both SPICE and CIDEr do. Also, when we optimize
for SPIDEr, we show that the captions are judged by humans
to be signiﬁcantly better than the ones generated by training
the same model using any of the other metrics. This shows
that SPIDEr satisﬁes criterion 2 to a much greater degree
than existing metrics.

In summary, we make the following contributions in this
paper: (1) we identify criteria for a good image captioning
metric, and proposed a new metric, SPIDEr, which meets
both criteria; (2) we propose a new policy gradient method
that can optimize arbitrary captioning metrics, and which is
much faster and more stable than previous PG methods; (3)
we show that using our new PG method to optimize existing
BCMR metrics leads to state of the art results on COCO;
(4) we show that using our new PG method to optimize our
new SPIDEr metric results in much better human scores than
optimizing for other metrics.

2 Related work

There is an extensive body of work on image captioning (see
e.g., [5] for a recent review). Below we summarize some of
the most relevant works.

2.1 Models

Most methods make use an encoder-decoder style neural
network, where the encoder is a convolutional neural
network (CNN), and the decoder a recurrent neural network

(RNN). In this work, we use the encoder-decoder proposed
in [22], known as “Show and Tell” (ST).

Numerous extensions to the basic encoder-decoder
framework have been proposed. One line of work (e.g., the
“Show, Attend and Tell” model of [26], and the “Review
Network” model of [27]), leverages attention, which lets the
decoder focus on speciﬁc parts of the input image when
generating a word. Another line of work enriches the
image encoding beyond just using a CNN that was trained
for image classiﬁcation. For example, [24, 28] use image
taggers, [21] use object detectors, and [19] use face detection
and landmark recognition. We stress that these extensions
are orthogonal to the ideas in this paper.

2.2 Metrics and objective functions

Most prior work uses maximum likelihood estimation
(MLE) for training. That is, the model parameters θ are
trained to maximize

L(θ) =

log p(yn|xn, θ)

1
N

1
N

=

N
(cid:88)

n=1

N
(cid:88)

Tn(cid:88)

n=1

t=1

log p(yn

t |yn

1:t−1, xn, θ)

where xn is the n’th image, yn = (yn

) is the
ground truth caption of the n’th image and N is the total
number of labelled examples.

1 , . . . , yn
Tn

One problem with the MLE objective is that at training
time, each prediction is conditioned on the previously
observed words from the ground truth. At test time, however,
the model will be fed with its own predictions,
leading
to quickly accumulating errors during inference, so the
model will likely diverge from desired trajectories. This
discrepancy is known as “exposure bias” [4]. One solution
to exposure bias is “scheduled sampling” [4], although this
method has been shown to be statistically inconsistent [9].

An alternative to maximizing likelihood is to try to
maximize some other objective that is more closely related
to the true metric of interest. This can be done using a policy
gradient (PG) method [17] such as REINFORCE [23], by
treating the score of a candidate sentence as analogous to a
reward signal in a reinforcement learning setting. In such a
framework, the RNN decoder acts like a stochastic policy,
where choosing an action corresponds to generating the next
word.

[15] use a modiﬁed form of REINFORCE to optimize the
BLEU score for image captioning. We explain this approach
in more detail in Section 2.3, since it is closely related to our
method. [8] used REINFORCE to optimize sequence level
reward such that generated captions are class discriminative.
However, this is a different task than the one we consider.

Under review as a conference paper at ICCV 2017

More recently, there have been a variety of other papers
on optimizing sequence level objective functions (see e.g.,
[13, 30, 2, 16]), but mostly in the context of machine
translation.

2.3 MIXER

The most closely related work is the “MIXER” paper [15].
They also use the REINFORCE method, combined with a
baseline reward estimator. However, they implicitly assume
each intermediate action (word) in a partial sequence has
the same reward as the sequence-level reward, which is not
true in general. To compensate for this, they introduce a
form of training that mixes together the MLE objective and
the REINFORCE objective. Speciﬁcally, they evaluate the
ﬁrst M words using log-likelihood, and the remaining words
using REINFORCE; they gradually decrease M from the
maximum sentence length down to 0.

We have found that MIXER is very sensitive to the form
of the annealing schedule, as well as other hyper-parameters,
such as the learning rate or gradient scaling of the baseline
estimator. We therefore propose a more robust alternative,
in which we replace the constant reward assumption with an
estimate of future rewards based on Monte Carlo rollouts (a
similar idea is used in [30] for GAN training). In Section 4,
we show that this change signiﬁcantly improves convergence
speed, as well as training stability. This lets us easily
optimize a variety of different metrics, including our new
metric, SPIDEr.

3 Methods

In this section, we explain our approach in more detail. First
we discuss the policy gradient method, which can be used
to robustly optimize any kind of reward function. Next we
discuss which reward function to use. Finally, we discuss the
model itself, which is a standard CNN-RNN.

3.1 Training using policy gradient

At time step t, we pick a discrete action, which corresponds
to choosing a word gt ∈ V, using a stochastic policy or
generator πθ(gt|st, x), where st = g1:t−1 is the sequence of
words chosen so far, x is the image and θ are the parameters
of the model. Note that in our case the state transition
function is deterministic: we simply append the word chosen
at time t to get st+1 = st; gt (u; v is the concatenation of the
strings u and v).

When we reach the end of the sequence (i.e., once the
generator emits the end-of-sentence marker), we get a reward
of R(g1:T |xn, yn), which is the score for producing caption
g1:T given image xn and ground truth caption (or set of

Figure 1: The value of each action is estimated as the
average rewards received by its K rollout sequences (i.e.
K = 3). Solid arrows indicate the sequence of actions being
evaluated. The tokens in green and yellow are respectively
BOS (beginning of sequence) and EOS (end of sequence)
tokens. Sequences in blue are rollout sequences sampled
from partial sequences. Note that rollout sequences do not
always have the same length, as they are separately sampled
from a stochastic policy.

reinforcement

captions) yn. This reward can be any function, such as
BCMR or SPICE.
In typical

learning setting, an agent
receives rewards at each intermediate step while future
rewards are discounted to balance short-term and long-term
In our case, however, the agent receive zero reward
gain.
during intermediate steps, observing a reward only at the
end. To mitigate the lack of intermediate reward signal,
we propose to estimate the value of intermediate states
(partial sequence), via Monte-Carlo rollouts. This translate
into signiﬁcantly more robust credit assignment and efﬁcient
gradient estimation, as we show in Section 4. We deﬁne the
value function of a partial sequence as its expected future
reward:

Vθ(g1:t|xn, yn) = Egt+1:T [R(g1:t; gt+1:T |xn, yn)]

(1)

where the expectation is w.r.t. gt+1:T ∼ πθ(·|g1:t, xn).

Our goal is to maximize the average reward starting from

the initial (empty) state s0 deﬁned as:

J(θ) =

Vθ(s0|xn, yn)

(2)

1
N

N
(cid:88)

n=1

where N is the number of examples in the training set. We
now discuss how to optimize Eqn. (2). For simplicity, we
will consider a single example n, so we will drop the xn and
yn notation. To compute the gradient of J(θ), we can use
the policy gradient theorem from [17]. In the special case of
deterministic transition functions, this theorem simpliﬁes as

Under review as a conference paper at ICCV 2017

shown below (see [2]for a proof):

∇θVθ(s0) = Eg1:T

∇θπθ(gt|g1:t−1)Qθ(g1:t−1, gt)





T
(cid:88)

(cid:88)

t=1

gt∈V

(3)
where we deﬁne the Q function for a state-action pair as
follows:

Qθ(g1:t−1, gt) = Egt+1:T [R(g1:t−1; gt; gt+1:T )]

(4)

We can approximate the gradient of the value function with
M sample paths, gm
1:T ∼ πθ, generated from our policy. This
gives

∇θVθ(s0) ≈

Egt

(cid:2)∇θ log πθ(gt|gm

1:t−1)

M
(cid:88)

T
(cid:88)

1
M

t=1

m=1
×Qθ(gm

1:t−1, gt)(cid:3)

(5)

where the expectation is w.r.t. gt ∼ πθ(gt|gm
we have exploited the fact that

1:t−1), and where

∇θπθ(a|s) = πθ(a|s)

= πθ(a|s)∇θ log πθ(a|s)

∇θπθ(a|s)
πθ(a|s)

If we use M = 1, we can additionally replace the Egt with
the value in the sample path, gm
t , as in REINFORCE. In our
experiment, we used M = 1 and we subsequently drop the
superscript m in the rest of this paper for notational clarity.
The only remaining question is how to estimate the
function Q(st, gt). For this, we will follow [30] and use
In particular, we ﬁrst sample K
Monte Carlo rollouts.
continuations of the sequence st; gt to get gk
t+1:T . Then we
compute the average

Q(g1:t−1, gt) ≈

R(g1:t−1; gt; gk

t+1:T )

(6)

1
K

K
(cid:88)

k=1

We estimate how good a particular word choice gt is by
averaging over all complete sequences sampled according
to the current policy, conditioned on the partial sequence
g1:t−1 sampled from the current policy so far. This process
is illustrated in Figure 1. If we are in a terminal state, we
deﬁne Q(g1:T , EOS) = R(g1:T ).

The above gradient estimator is an unbiased but high
variance estimator. One way to reduce its variance is to
estimate the expected baseline reward Egt[Q(g1:t−1, gt)]
using a parametric function; we will denote this baseline
as Bφ(g1:t−1). We then subtract
this baseline from
Qθ(g1:t−1, gt) to get the following estimate for the gradient
(using M = 1 sample paths):





where st = g1:t−1. Subtracting the baseline does not
affect the validity of the estimated gradient, but reduces its
variance. Here, we simply refer to prior work ([31], [23]) for
a full derivation of this property.

We train the parameters φ of the baseline estimator to

minimize the following loss:

Lφ =

EstEgt(Qθ(st, gt) − Bφ(st))2

(8)

(cid:88)

t

In our experiments, the baseline estimator is an MLP which
takes as input the hidden state of the RNN at step t. To
avoid creating a feedback loop, we do not back-propagate
gradients through the hidden state from this loss.

In language generation settings, a major challenge facing
PG methods is the large action space. This is the case in
our task, where the action space corresponds to the entire
vocabulary of 8,855 symbols. To help “warm start” the
training, we pre-train the RNN decoder (stochastic policy)
using MLE training, before switching to PG training. This
prevents the agent from performing random walks through
exponentially many possible paths at the beginning of the
training.

The overall algorithm is summarized in Algorithm 1.
Note that the Monte Carlo rollouts only require a forward
pass through the RNN, which is much more efﬁcient than the
forward-backward pass needed for the CNN. Additionally
the rollouts can be also be done in parallel for multiple
sentences. Consequently, PG training is only about twice
as slow as MLE training (in wall time).

Algorithm 1: PG training algorithm
1 Input: D = {(xn, yn) : n = 1 : N } ;
2 Train πθ(g1:T |x) using MLE on D ;
3 Train Bφ using MC estimates of Qθ on a small subset

of D;

4 for each epoch do
5

for example (xn, yn) do

6

7

8

9

10

11

12

13

Generate sequence g1:T ∼ πθ(·|xn) ;
for t = 1 : T do

Compute Q(g1:t−1, gt) for gt with K
Monte Carlo rollouts, using (6);
Compute estimated baseline Bφ(g1:t−1);

Compute Gθ = ∇θVθ(s0) using (7);
Compute Gφ = ∇φLφ;
SGD update of θ using Gθ;
SGD update of φ using Gφ;

T
(cid:88)

(cid:88)

t=1

gt

∇θVθ(s0) ≈

[πθ(gt|st)∇θ log πθ(gt|st)

3.2 Reward functions for the policy gradient

× (Qθ(st, gt) − Bφ(st))]

(7)

We can use our PG method to optimize many different
reward functions. Common choices include BLEU, CIDEr,

Under review as a conference paper at ICCV 2017

Figure 2: Model architecture of Show and Tell
image
captioning system [22]. The tokens in green and yellow are
respectively BOS (beginning of sequence) and EOS (end of
sequence) tokens. At testing time, output from previous time
step gt−1 is used as input in lieu of yt−1.

METEOR and ROUGE. Code for all of these metrics is
available as part of the COCO evaluation toolkit.1 We
decided to use a weighted combination of all of these. Since
these metrics are not on the same scale, we chose in our
experiments the set of weights such that all metrics have
approximately the same magnitude. More precisely, we
choose the following weighted combination: 0.5*BLEU-1
+ 0.5*BLEU-2 + 1.0*BLEU-3 + 1.0*BLEU-4 + 1.0*CIDEr
+ 5.0*METEOR + 2.0*ROUGE. Optimizing this weighted
combination of BCMR gives state-of-the-art results on the
COCO test set, as we discuss in Section 4.2.

One problem with the BCMR metrics is that individually
they are not well correlated with human judgment [1].
We therefore also tried optimizing the recently introduced
SPICE metric [1], which better reﬂects human estimates of
quality. We use the open source release of the SPICE code2
to evaluate the metric.

Interestingly, we have found that just optimizing SPICE
tended to result in captions which are very detailed, but
which often had many repeated phrases, as we show in
Section 4.
This is because SPICE measures semantic
similarity (in terms of a scene graph) between sets of
sentences, but does not pay attention to syntactical factors
(modulo the requirement that the generated sentence be
parseable). We therefore combined SPICE with the CIDEr
metric (considered the best of the standard automatic metrics
for COCO), a combination we call SPIDEr for short. Based
on initial experiments, we decided to use an equal weighting
for both.

3.3 Encoder-decoder architecture

We use a CNN-RNN architecture similar to the one proposed
in the original Show-Tell paper [22]. A high-level diagram
is shown in Figure 2. Each symbol in the vocabulary is

1 https://github.com/tylin/coco-caption.
2 https://github.com/peteanderson80/SPICE.

embedded as a 512 dimensional dense word embedding
vector, whose values are initialized randomly.

as

The

encoder

CNN is

implemented

an
Inception-V3 [18] network pretrained on ImageNet3.The
RNN decoder is a one-layer LSTM with a state size of
512 units, initialized randomly. Each image is encoded by
Inception-V3 as a dense feature vector of dimension 2, 048
which is then projected to 512 dimension with a linear layer
and used as the initial state of RNN decoder.

At training time, we always feed in the ground truth
symbol to the RNN decoder; at inference time we use just
greedy decoding, where the sampled output is fed to the
RNN as the next input symbol.

4 Results

4.1 Experimental protocol

We report results obtained by different methods on the
COCO dataset. This has 82,081 training images, and 40,137
validation images, each with at least 5 ground truth captions.
Following standard practice for methods that evaluate on
the COCO test server, we hold out a small subset of 1,665
validation images for hyper-parameter tuning, and use the
remaining combined training and validation set for training.
We preprocess the text data by lower casing, and
replacing words which occur less than 4 times in the 82k
training set with UNK; this results in a vocabulary size of
8,855 (identical to the one used in [22]). At training time,
we keep all captions to their maximum lengths. At testing
time, the generated sequences are truncated to 30 symbols in
all experiments.

We use the Show-Tell model from [22] for all methods.
We “pre-train” this model with MLE, and then optionally
“ﬁne tune” it with other methods, as we discuss below.

4.2 Automatic
metrics

evaluation

using BCMR

In this section, we quantitatively evaluate various methods
using the standard BCMR metrics on the COCO test set.
Since the ground truth is not available for the test set,
we submitted our results to the COCO online evaluation
server4 on Nov 2016. Table 1 shows the results of the
top 5 methods (at the time of submission) on the ofﬁcial
C-5 leaderboard, along with the results of our experiments.
In particular, we tried training the Show-Tell model with
the following methods: MLE, PG-BLEU-4, PG-CIDEr,

3We used the open-source implementation available at: https:

//github.com/tensorflow/models/blob/master/slim/
nets/inception_v3.py

4mscoco.org/dataset/#captions-leaderboard

Under review as a conference paper at ICCV 2017

Submissions

CIDEr-D Meteor ROUGE-L BLEU-1 BLEU-2 BLEU-3 BLEU-4

MSM@MSRA [28]
Review Net [27]
ATT [29]
Google [22]
Berkeley LRCN [7]

MLE
PG-BLEU-4
PG-CIDEr

MIXER-BCMR
MIXER-BCMR-A
PG-BCMR
PG-SPIDEr

0.984
0.965
0.943
0.943
0.921

0.947
0.966
0.995

0.924
0.991
1.013
1.000

0.256
0.256
0.250
0.254
0.247

0.251
0.249
0.249

0.245
0.258
0.257
0.251

0.542
0.533
0.535
0.530
0.528

0.531
0.550
0.548

0.532
0.545
0.55
0.544

0.739
0.720
0.731
0.713
0.718

0.724
0.737
0.737

0.729
0.747
0.754
0.743

0.575
0.550
0.565
0.542
0.548

0.552
0.587
0.581

0.559
0.579
0.591
0.578

0.436
0.414
0.424
0.407
0.409

0.405
0.455
0.442

0.415
0.431
0.445
0.433

0.330
0.313
0.316
0.309
0.306

0.294
0.346
0.333

0.306
0.317
0.332
0.322

Table 1: Automatic evaluation on the ofﬁcial COCO C-5 test split, as of November 2016. Methods below the line are
contributions from this paper.

PG-BCMR, PG-SPIDEr (with equal weight on SPICE and
on CIDEr), and MIXER.

Our MLE method gets similar results to the scheduled
sampling method of [22]. Not surprisingly, PG-BCMR
signiﬁcantly outperforms MLE training, since it directly
optimizes for BCMR. Similarly, PG-BCMR outperforms
PG-SPIDEr. We also showed that PG-BLEU-4 and
PG-CIDEr speciﬁcally improves on the metric optimized
for, compared to MLE baseline. In particular, PG-BLEU-4
successfully achieved the highest score on BLEU metrics,
while largely neglected others.
This demonstrates the
general applicability of our optimization method to target
any speciﬁc metric of interests. However, as shown below
optimizing for the current COCO metrics does not translate
into better captions.

We also see that our PG-BCMR method signiﬁcantly
outperforms all the top 5 methods, even the ones which use
more sophisticated models, such as those based on attention
(Montreal/Toronto, ATT, Review Net), those that use more
complex decoders (Berkeley LRCN), and those that use
high-level visual attributes (MSM@MSRA, ATT).

Our PG-BCMR method also outperforms the MIXER

algorithm; we discuss this in more detail in Section 4.4.

4.3 Human evaluation

Table 2 shows some example captions generated by 6
different methods: MLE, PG-SPICE, MIXER-BCMR,
MIXER-BCMR-A, PG-BCMR, and PG-SPIDEr. We see
that PG-SPICE tends to generate ungrammatical sentences,
with a lot of repeated phrases. This is because SPICE
measures how well the scene graph induced by a sentence
matches the ground truth scene graph, but is relatively
insensitive to syntactic quality. However, when we combine

Figure 3: Results of human evaluation on 492 images
randomly sampled from the COCO test set. We report
the difference in percentage of “not bad” captions for each
method compared to baseline 38% of MLE model.

SPICE with CIDEr, we get much better results. We therefore
ignore pure SPICE in the rest of this paper.

We also see that PG-SPIDEr tends to generate more
reasonable captions that PG-BCMR, even though it did
worse on the COCO metrics. Also, both methods seem to be
better than MLE. (See for example the third row in Table 2.)
To quantify this, we turn to a user study. In particular,
we use a crowd sourcing platform, using raters who have
prior experience with evaluating image captioning and other
computer vision models. We showed each image-caption
pair to 3 different raters, and asked them to evaluate it on
a 4 point scale, depending on whether the caption is “bad”,
“okay”, “good” or “excellent”.5 We then take the majority

5 The deﬁnitions of these terms, which we gave to raters, is as follows.

Under review as a conference paper at ICCV 2017

Images

Ground Truth Captions

Generated Captions

1. a red and yellow ﬁre truck and some buildings
2. An overhead view shows a ﬁre engine in the

3. A red and yellow ﬁre truck with ladders on top
4. A ﬁretruck is parked in the street in between

• MLE: a red and white bus is driving down the street
• PG-SPICE: a red double decker bus on a city street on a
street with a bus on the street with a bus on the street
in front of a bus on

• MIXER-BCMR: a yellow bus driving down a city street .
• MIXER-BCMR-A: a red ﬁre truck driving down a city

5. A ﬁre truck (ladder truck) drives down a street

street .

street.

stop lights.

in the city.

• PG-BCMR: a red bus driving down a city street .
• PG-SPIDEr: a red ﬁre truck is on a city street.

1. A woman walking on a city street in a red coat.
2. A group of people that are standing on the side

3. A woman in a red jacket crossing the street
4. a street light some people and a woman wearing

.

5. A blonde woman in a red coat crosses the street

street .

of a street.

a red jacket

with her friend.

• MLE: a woman walking down a street while holding an

umbrella .

• PG-SPICE: a group of people walking down a street with
a man on a street holding a trafﬁc light and a trafﬁc
light on a city street with a city street

• MIXER-BCMR: a group of people walking down a street

• MIXER-BCMR-A: a group of people walking down a

• PG-BCMR: a group of people walking down a city street .
• PG-SPIDEr: a group of people walking down a street with

a trafﬁc light .

1. A group of people converse in an ofﬁce setting.
2. A group of people playing a game with remote

3. Four young people have crowded into a small

controllers.

ofﬁce.

a room.

5. a group of people standing next to each other
with some of them holding video game
controllers

4. A group of people standing next to each other in

room .

• MLE: a group of people standing around a living room .
• PG-SPICE: a group of people in a room with a man in a
chair holding a nintendo wii remote in a living room
with a man in a chair holding a

• MIXER-BCMR: a group of people standing in a living

• MIXER-BCMR-A: a group of people standing in a living

room playing a video game .

• PG-BCMR: a group of people standing in a room .
• PG-SPIDEr: a group of people playing a video game in a

living room .

1. A man looking through a book on top of a table.
2. A man sitting on a bed looking at a book
3. a man is ﬂipping through a book on a bed
4. A man sitting on a bed ﬂipping through pages of

5. A man in a black jacket is ﬂipping through a

a book.

large book.

• MLE: a man sitting in front of a laptop computer .
• PG-SPICE: a man sitting in front of a book and a laptop on
a table with a laptop computer on top of a table with a
laptop computer on top of

• MIXER-BCMR: a man sitting in a chair with a book .
• MIXER-BCMR-A: a man sitting at a table with a book .
• PG-BCMR: a man sitting in front of a book .
• PG-SPIDEr: a man sitting at a table with a book .

Table 2: Example captions from different models on COCO hold-out validation images.

Under review as a conference paper at ICCV 2017

p-value(X >Y)
PG-SPIDEr
PG-BCMR

PG-BCMR MLE
<0.001
0.003

0.014
-

Table 3: p-values derived from a pairwise sign test applied
to human ratings on 492 images from COCO test set.
Statistically signiﬁcant comparisons (at the 0.05 level) are
shown in bold. X and Y correspond to rows and columns
respectively.

vote to get the ﬁnal rating. If no majority is found, the rating
is considered unknown, and this image is excluded from the
analysis.

Since current captioning systems are far from perfect,
our main goal is to develop a captioning system that does
not make “embarrassing” errors, we focus on measuring the
fraction of captions that are classiﬁed as “not bad”, which
we interpret as the union of “okay”, “good” and “excellent”.
As “quality control”, we ﬁrst evaluated 505 ground truth
captions from the COCO validation set. Humans said that
87% of these captions were “not bad”. Some of the 13%
of ground truth captions that were labeled “bad” do indeed
contain errors6, due to the fact that COCO captions were
generated by AMT workers who are not perfect. On the other
hand, some captions seem reasonable to us, but did not meet
the strict quality criteria our raters were looking for. In any
case, 87% is an approximate upper bound on performance
we can hope to achieve on the COCO test set.

We then randomly sampled 492 images from the test
set (for which we do not have access to the ground truth
captions), and generated captions from all of them using our
3 systems, and sent them for human evaluation. Figure 3
shows the fraction of captions that are “not bad” compared
to the MLE baseline of 38%. We draw the following
conclusions:

• All methods are far below the human ceiling of 87%.
• All PG methods outperform MLE training by a signiﬁcant
margin (see Table 3 for pairwise p-value analysis). This
is because the PG methods optimize metrics that are
much more closely related to caption quality than the
likelihood score.

Excellent: “The caption correctly, speciﬁcally and completely describes
the foreground/main objects/events/theme of the image.” Good: “The
caption correctly and speciﬁcally describes most of the foreground/main
objects/events/theme of the image, but has minor mistakes in some
minor aspects.” Okay: “The caption correctly describes some of the
foreground/main objects/events/theme of the image, but is not speciﬁc to
the image and has minor mistakes in some minor aspects.” Bad: “The
caption misses the foreground/main objects/events/theme of the image or
the caption contains obviously hallucinated objects/activities/relationships.”
6 For example, some captions contain repeated words, e.g., “this is an
image image of a modern kitchen”. Others contain typos, e.g., “a blue and
white truck with pants in it’s ﬂat bed”. And some do not make semantic
sense, e.g., “A crowd of people parked near a double decker bus”.

the

• PG-SPIDEr outperforms PG-BCMR by a 4% margin,
despite
fact
PG-BCMR outperforms
that
This is
PG-SPIDEr on all
the COCO metrics.
because SPIDEr captures both ﬂuency and semantic
properties of the caption, both of which human raters
are told to pay attention to, whereas BCMR is a more
syntactic measure.

4.4 Comparison with MIXER

We now compare our method with [15] in more detail. When
using MLE training, they get a BLEU-4 score of 0.278, and
when they used MIXER to optimize BLEU-4, they get 0.292,
which is about 0.1 better.
(They do not report any other
results besides BLEU-4.) Note, however, that their numbers
are not comparable to the numbers in Table 1, since they are
evaluated on 5000 images from the COCO validation set, and
not the ofﬁcial test server.

In order to do a fair comparison with our work (and other
publications), we reimplemented their algorithm. When we
used their train/test split7, and used our implementation of
MIXER to optimize BLEU-4, we were able to reproduce
their BLEU-4 result. We then used MIXER to optimize
BCMR, using the standard train/test split. Once again, we
see that the BLEU-4 score is about 0.1 better than MLE,
but the other metrics are sometimes worse, whereas our PG
method was signiﬁcantly better than MLE across all metrics.
Upon digging into their open source code8, we noticed
that they used a different optimization algorithm: we use
Adam [10], whereas they used vanilla stochastic gradient
descent with a hard-coded learning rate decay. When we
reran MIXER-BCMR with Adam (a combination we call
MIXER-BCMR-A) with well tuned parameters, we saw
signiﬁcantly improved results, which come closer to our best
results obtained with PG-BCMR in almost all metrics (and
even slightly beating us in Meteor).

However, the ﬁnal results are not the entire story. We have
found that MIXER is much slower to converge, and much
less stable during training, than our PG-Rollout method.
This is illustrated in Figure 4, where we plot the BCMR
metrics on the validation set for three methods: PG-BCMR
(blue), MIXER-BCMR-A (red), MIXER-BCMR (green).
We show the best of 10 runs for MIXER, and a single run
for PG. (Repeated runs of PG give similar performance.)

We see that MIXER-BCMR with vanilla SGD does
poorly. Using Adam helps a lot, but performance is still very
unstable; in particular, we had to try the method 10 times,
with different learning rates and gradient multipliers for the
baseline estimator, to get their best result shown in Figure 4.
Note that the plateau in MIXER’s performance curve for
the ﬁrst 500k steps is because MIXER starts with just MLE

7 We thank Marc’Aurelio Ranzato for sharing their code and data split.
8 https://github.com/facebookresearch/MIXER

Under review as a conference paper at ICCV 2017

(a) BLEU-4

(b) ROUGE-L

(c) CIDEr

(d) METEOR

Performance of PG-BCMR (blue-triangle),
Figure 4:
MIXER-BCMR-A (red-dashed)
and MIXER-BCMR
(green-solid) on the validation set during the ﬁrst 1 million
gradient steps.

training; no progress is made during this time, since we
initialize the models with a model that was already trained
with MLE. At the 500k epoch, MIXER uses MLE for the
ﬁrst 6 words in the caption, and REINFORCE for the rest.
At the 600k epoch, MIXER switches to REINFORCE for the
entire sequence. Over time, the baseline estimator is learned,
and this can compensate for the inaccurate estimate of future
rewards. Hence eventually, MIXER-BCMR-A can catch up
with our PG-Rollout method.

5 Conclusion

In this paper, we have proposed a robust and efﬁcient policy
gradient method, and successfully applied it to optimize a
variety of captioning metrics. By optimizing the standard
COCO metrics, we show that we can achieve state of the
art results, according to the leaderboard. However, we
also show that these metrics do not correlate well with
human judgement. We therefore also proposed a new
metric, SPIDEr, and show that optimizing this with our new
algorithm produces qualitatively superior results, as judged
by human raters.

References

[1] P. Anderson, B. Fernando, M. Johnson, and S. Gould. Spice:
Semantic propositional image caption evaluation. In ECCV,
2016. 1, 2, 5

[2] D. Bahdanau, P. Brakel, K. Xu, A. Goyal, R. Lowe, J. Pineau,
A. Courville, and Y. Bengio. An Actor-Critic algorithm for
sequence prediction. Arxiv, 24 July 2016. 3, 12

[3] S. Banerjee and A. Lavie. METEOR: An automatic metric
for MT evaluation with improved correlation with human
judgments.
In ACL Workshop on MT, volume 29, pages
65–72, 2005. 1

[4] S. Bengio, O. Vinyals, N. Jaitly, and N. Shazeer. Scheduled
sampling for sequence prediction with recurrent neural
networks. In NIPS, 2015. 2

[5] R. Bernardi, R. Cakici, D. Elliott, A. Erdem, E. Erdem,
N. Ikizler-Cinbis, F. Keller, A. Muscat, and B. Plank.
Automatic description generation from images: A survey of
models, datasets, and evaluation measures. J. of AI Research,
55:409–442, 2016. 2

[6] A. Das, S. Kottur, K. Gupta, A. Singh, D. Yadav, J. M.
Moura, D. Parikh, and D. Batra. Visual dialog. arXiv preprint
arXiv:1611.08669, 2016. 1

[7] J. Donahue,

L. Anne Hendricks,

S. Guadarrama,
M. Rohrbach, S. Venugopalan, K. Saenko, and T. Darrell.
for visual
Long-term recurrent convolutional networks
recognition and description. In CVPR, 2015. 6

[8] L. A. Hendricks, Z. Akata, M. Rohrbach, J. Donahue,
B. Schiele, and T. Darrell. Generating visual explanations.
ECCV, 2016. 2

[9] F. Husz´ar.

How (not) to train your generative model:
Scheduled sampling, likelihood, adversary? Arxiv, 16 Nov.
2015. 2

[10] D. Kingma and J. Ba. Adam: A method for stochastic

optimization. In ICLR, 2015. 8

[11] C.-Y. Lin and E. Hovy. Automatic evaluation of summaries
In NAACL, pages

using n-gram co-occurrence statistics.
71–78, 2003. 1

[12] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona,
D. Ramanan, P. Doll´ar, and C. Lawrence Zitnick. Microsoft
COCO: Common objects in context. In ECCV, 1 May 2014.
1

[13] M. Norouzi, S. Bengio, Z. Chen, N. Jaitly, M. Schuster,
Y. Wu, and D. Schuurmans. Reward augmented maximum
likelihood for neural structured prediction. In NIPS, 2016. 3
[14] K. Papineni, S. Roukos, T. Ward, and W.-J. Zhu. BLEU: A
method for automatic evaluation of machine translation.
In
Proc. ACL, pages 311–318, 2002. 1

[15] M. Ranzato, S. Chopra, M. Auli, and W. Zaremba. Sequence
level training with recurrent neural networks. Arxiv, 2015. 1,
2, 3, 8

[16] S. Shen, Y. Cheng, Z. He, W. He, H. Wu, M. Sun, and Y. Liu.
In
Minimum risk training for neural machine translation.
Proc. ACL, 2016. 3

[17] R. S. Sutton, D. Mc Allester, S. Singh, and Y. Mansour. Policy
gradient methods for reinforcement learning with function
approximation. In NIPS, 1999. 1, 2, 3

[18] C. Szegedy, V. Vanhoucke, S. Ioffe, J. Shlens, and Z. Wojna.
Rethinking the inception architecture for computer vision.
arXiv preprint arXiv:1512.00567, 2015. 5

[19] K. Tran, X. He, L. Zhang, J. Sun, C. Carapcea, C. Thrasher,
C. Buehler, and C. Sienkiewicz. Rich image captioning in the
wild. In CVPR, 2016. 2

Under review as a conference paper at ICCV 2017

[20] R. Vedantam, C. Lawrence Zitnick, and D. Parikh. Cider:
In CVPR,

Consensus-based image description evaluation.
pages 4566–4575, 2015. 1

[21] S. Venugopalan, L. A. Hendricks, M. Rohrbach, R. Mooney,
T. Darrell, and K. Saenko. Captioning images with diverse
objects. Arxiv, 24 June 2016. 2

[22] O. Vinyals, A. Toshev, S. Bengio, and D. Erhan. Show and
tell: A neural image caption generator. In CVPR, 2015. 2, 5,
6

[23] R. J. Williams.

Simple statistical gradient-following
algorithms for connectionist reinforcement learning. Machine
Learning J., 8(3-4):229–256, 1 May 1992. 2, 4, 12

[24] Q. Wu, C. Shen, A. van den Hengel, L. Liu, and A. Dick.
What value high level concepts in vision to language
problems? In CVPR, 2016. 2

[25] S. Wu, J. Wieland, O. Farivar, and J. Schiller. Automatic
alt-text: Computer-generated image descriptions for blind
users on a social network service. In Proceedings of the 2017
ACM Conference on Computer Supported Cooperative Work
and Social Computing, pages 1180–1192. ACM, 25 Feb.
2017. 1
[26] K. Xu,

J. Ba, R. Kiros, K. Cho, A. Courville,
R. Salakhutdinov, R. Zemel, and Y. Bengio.
Show,
attend and tell: Neural image caption generation with visual
attention. In ICML, 2015. 2

[27] Z. Yang, Y. Yuan, Y. Wu, R. Salakhutdinov, and W. W. Cohen.
Review networks for caption generation. In NIPS, 2016. 2, 6
[28] T. Yao, Y. Pan, Y. Li, Z. Qiu, and T. Mei. Boosting image
captioning with attributes. In OpenReview, 2016. 2, 6

[29] Q. You, H.

Jin, Z. Wang, C. Fang,
Image captioning with semantic attention.
arXiv:1603.03925, 2016. 6

and J. Luo.
arXiv preprint

[30] L. Yu, W. Zhang, J. Wang, and Y. Yu. SeqGAN: Sequence
generative adversarial nets with policy gradient. Arxiv,
18 Sept. 2016. 3, 4

[31] W. Zaremba and I. Sutskever. Reinforcement learning neural
turing machines-revised. arXiv preprint arXiv:1505.00521,
2015. 4, 12

Under review as a conference paper at ICCV 2017

A Full derivation of policy gradient

we have

Given an image xn and the ground-truth captions yn
associated with xn, the reward for a generated caption ¯g =
g1:T = {g1, g2, ..., gT } is deﬁned as

R(¯g|xn, yn) =

r(gt|g1:(t−1), xn, yn),

(9)

T
(cid:88)

t=1

where r(gt|g1:(t−1), xn, yn) is the incremental reward for
word gt, given previously generated words g1:(t−1) and
(xn, yn). We deﬁne

r(g1|g1:0, xn, yn) = r(g1|xn, yn)

(10)

for notation consistency. Caption ¯g is generated by sampling
one word at each time step from the given vocabulary
V using the conditional probability or policy πθ(¯g|xn)
parameterized by θ. Here θ is the set of weights in the
CNN-RNN neural network covered in section 3.3. The
expected reward for the captions generated by following the
policy πθ(¯g|xn) is

Vθ(xn) = E¯g[R(¯g|xn, yn)] =

πθ(¯g|xn)R(¯g|xn, yn).

(cid:88)

¯g

∇θ log(πθ(¯g|xn)) =

∇θ log(πθ(gt|g1:(t−1), xn)).

T
(cid:88)

t=1

(17)

(18)

Similar to equation (10), we deﬁne

πθ(g1|g1:0, xn) = πθ(g1|xn).

(15) and (17)

Equations
forward
sequence-level Monte Carlo sampling algorithm. But we
will show next that this can be further improved.

suggest a straight

Taking the derivative on both sides of the equation (16)

leads to

∇θπθ(¯g|xn) = ∇θπθ(g1|xn)

πθ(gt|g1:(t−1), xn)

T
(cid:89)

t=2

T
(cid:89)

t=3

+ πθ(g1|xn)∇θπθ(g2|g1, xn)

πθ(gt|g1:(t−1), xn)

+ . . .

T −1
(cid:89)

+

t=1

T
(cid:88)

t=1

πθ(gt|g1:(t−1), xn)∇θπθ(gT |g1:(T −1), xn)

=

πθ(g1:(t−1)|xn)∇θπθ(gt|g1:(t−1), xn)

The goal is to maximize the objective function

× πθ(gt+1:T |g1:t, xn),

J(θ) =

Vθ(xn)

1
N

N
(cid:88)

n=1

where the ﬁrst equality is due to simple calculus rules, and
the second equality is due to the chain rule in equation (16).
Here we deﬁne

(11)

(12)

where N is the number of images in a given training data set.
In this paper we use the gradient-based methods to ﬁnd
the optimal solution θ∗. In view of equation (11), to compute
the gradient

∇θJ(θ) =

∇θVθ(xn),

(13)

1
N

N
(cid:88)

n=1

we just need to focus on the term

∇θVθ(xn) =

∇θπθ(¯g|xn)R(¯g|xn, yn)

(14)

(cid:88)

¯g

(cid:88)

=

¯g

πθ(¯g|xn)∇θ log(πθ(¯g|xn))R(¯g|xn, yn)

= E¯g[∇θ log(πθ(¯g|xn))R(¯g|xn, yn)].

(15)

In view of the chain rule applied to the joint conditional
probability

πθ(g1:0|xn) = 1.
πθ(g(T +1):T |g1:T , xn) = 1.

for notation consistency in equation (19).

To simplify the notation and unless confusion arises, we
will drop the conditional terms (·|xn, yn) and (·|xn) in the
following derivation.

Substituting equation (19)

into equation (14) and

changing the order of summation, we obtain

∇θVθ(xn) =

πθ(g1:(t−1))

∇θπθ(gt|g1:(t−1))

T
(cid:88)

(cid:88)

t=1

g1:(t−1)

(cid:88)

gt

πθ(gt+1:T |g1:t)R(¯g)

=

Eg1:(t−1) [Egt[∇θ log(πθ(gt|g1:(t−1)))Eg(t+1):T [R(¯g)]]].

(cid:88)

×

g(t+1):T

T
(cid:88)

t=1

πθ(¯g|xn) =

πθ(gt|g1:(t−1), xn),

(16)

T
(cid:89)

t=1

Note that In view of equation (9), we can partition the reward
R(¯g) in equation (22) into two parts

R(¯g) = R(g1:(t−1)) + R(g1:(t−1), gt:T ),

(23)

(19)

(20)

(21)

(22)

Egt [∇θ log(πθ(gt|g1:(t−1)))Eg(t+1):T [R(g1:(t−1))]]
= R(g1:(t−1))Egt[∇θ log(πθ(gt|g1:(t−1)))Eg(t+1):T [1]]

Since the second term is

variance problem due to very high dimensionality of the
sample space. For example, the vocabulary of the COCO
If we set caption length
data set is about nine thousand.
T = 30, then the discrete sample space has 900030 grid
points. One commonly used solution is to subtract a constant
from Qθ(g1:(t−1), gt) in equation (27). The inner summation
in equation (27) now becomes

Egt[∇θ log(πθ(gt|g1:(t−1)))(Qθ(g1:(t−1), gt) − B)]. (29)

Egt[∇θ log(πθ(gt|g1:(t−1)))B] = ∇θEgt[B] = 0,

(30)

(25)

this manipulation does not theorectically change the gradient
in equation (27). Prior work in [31, 23] show that

B = Egt[Qθ(g1:(t−1), gt)]

(31)

is effective in reducing the variance due to small sample
size.

Under review as a conference paper at ICCV 2017

where

R(g1:(t−1), gt:T ) =

r(gi|g1:(i−1)).

(24)

T
(cid:88)

i=t

Here we want to show that the contribution of R(g1:(t−1))
to the summation in equation (22) is zero. Speciﬁcally, the
inner summation for R(g1:(t−1)) becomes

= R(g1:(t−1))

[∇θπθ(gt|g1:(t−1))]

(cid:88)

gt

= R(g1:(t−1))∇θEgt[1] = 0,

where the ﬁrst equality is due to the fact that R(g1:(t−1)) is
independent of gt and g(t+1):T , the second equality is due
to the deﬁnition of expectation, and the third equality is due
to the exchange of sum and derivative. The contribution of
R(g1:(t−1), gt:T ) to the summation in equation (22) can be
simpliﬁed as well. Speciﬁcally, the inner most summation
becomes

Qθ(g1:(t−1), gt) = Eg(t+1):T [R(g1:(t−1), gt:T )]
= Eg(t+1):T [r(gt|g1:(t−1)) + R(g1:t, g(t+1):T )]
= r(gt|g1:(t−1))Eg(t+1):T [1] + Eg(t+1):T [R(g1:t, g(t+1):T )]
= r(gt|g1:(t−1)) + Eg(t+1):T [R(g1:t, g(t+1):T )],
(26)

where the second equality is due to the deﬁnition in
equation (24), and the third equality is due to the fact that
r(gt|g1:(t−1)) is independent of g(t+1):T . Hence equation
(22) becomes

∇θVθ(xn) =

Eg1:(t−1) [Egt[∇θ log(πθ(gt|g1:(t−1)))

T
(cid:88)

t=1

× Qθ(g1:(t−1), gt)]]

T
(cid:88)

t=1

T
(cid:88)

(cid:88)

t=1

gt∈V

=

Eg1:T [Egt[∇θ log(πθ(gt|g1:(t−1)))Qθ(g1:(t−1), gt)]]

= Eg1:T [

[∇θπθ(gt|g1:(t−1))Qθ(g1:(t−1), gt)]],

(27)

(28)

where the second equality is due to the fact that the term
Egt [∇θ log(πθ(gt|g1:(t−1)))Qθ(g1:(t−1), gt)] is independent
of gt:T . Equation (28) is also shown in [2].

B Variance reduction

The Monte Carlo sampling used to compute the expectation
in equations (26) and (27) typically suffers from high

