7
1
0
2
 
g
u
A
 
2
 
 
]
L
C
.
s
c
[
 
 
1
v
1
8
7
0
0
.
8
0
7
1
:
v
i
X
r
a

Dynamic Entity Representations in Neural Language Models

Yangfeng Ji∗ Chenhao Tan∗ Sebastian Martschat† Yejin Choi∗ Noah A. Smith∗
∗Paul G. Allen School of Computer Science & Engineering, University of Washington
†Department of Computational Linguistics, Heidelberg University
{yangfeng,chenhao,yejin,nasmith}@cs.washington.edu
martschat@cl.uni-heidelberg.de

Abstract

Understanding a long document requires
tracking how entities are introduced and
evolve over time. We present a new type of
language model, ENTITYNLM, that can
explicitly model entities, dynamically up-
date their representations, and contextu-
ally generate their mentions. Our model is
generative and ﬂexible; it can model an ar-
bitrary number of entities in context while
generating each entity mention at an arbi-
trary length.
In addition, it can be used
for several different tasks such as language
modeling, coreference resolution, and en-
tity prediction. Experimental results with
all these tasks demonstrate that our model
consistently outperforms strong baselines
and prior work.

1 Introduction

Understanding a narrative requires keeping track
of its participants over a long-term context. As a
story unfolds, the information a reader associates
with each character in a story increases, and ex-
pectations about what will happen next change ac-
cordingly. At present, models of natural language
do not explicitly track entities; indeed, in today’s
language models, entities are no more than the
words used to mention them.

In this paper, we endow a generative language
model with the ability to build up a dynamic rep-
resentation of each entity mentioned in the text.
Our language model deﬁnes a probability distribu-
tion over the whole text, with a distinct generative
story for entity mentions. It explicitly groups those
mentions that corefer and associates with each en-
tity a continuous representation that is updated by
every contextualized mention of the entity, and
that in turn affects the text that follows.

[John]1 wanted to go to [the coffee shop]2 in
[downtown Copenhagen]3. [He]1 was told that
[it]2 sold [the best beans]4.

Figure 1: ENTITYNLM explicitly tracks entities
in a text, including coreferring relationships be-
tween entities like [John]1 and [He]1. As a lan-
guage model, it is designed to predict that a coref-
erent of [the coffee shop]2 is likely to follow “told
that,” that the referring expression will be “it”, and
that “sold the best beans” is likely to come next, by
using entity information encoded in the dynamic
distributed representation.

Because our model

Our method builds on recent advances in repre-
sentation learning, creating local probability dis-
tributions from neural networks.
It can be un-
derstood as a recurrent neural network language
model, augmented with random variables for en-
tity mentions that capture coreference, and with
dynamic representations of entities. We estimate
the model’s parameters from data that is annotated
with entity mentions and coreference.
is generative,

it can be
queried in different ways. Marginalizing every-
thing except the words, it can play the role of a lan-
guage model. In §5.1, we ﬁnd that it outperforms
both a strong n-gram language model and a strong
recurrent neural network language model on the
English test set of the CoNLL 2012 shared task
on coreference evaluation (Pradhan et al., 2012).
The model can also identify entity mentions and
In §5.2,
coreference relationships among them.
we show that it can easily be used to add a per-
formance boost to a strong coreference resolution
system, by reranking a list of k-best candidate out-
puts. On the CoNLL 2012 shared task test set, the
reranked outputs are signiﬁcantly better than the
original top choices from the same system. Fi-

nally, the model can perform entity cloze tasks.
As presented in §5.3, it achieves state-of-the-art
performance on the InScript corpus (Modi et al.,
2017).

2 Model

A language model deﬁnes a distribution over se-
quences of word tokens; let Xt denote the random
variable for the tth word in the sequence, xt de-
note the value of Xt and xt the distributed repre-
sentation (embedding) of this word. Our starting
point for language modeling is a recurrent neural
network (Mikolov et al., 2010), which deﬁnes

p(Xt | history) = softmax (Whht−1 + b)

ht−1 = LSTM(ht−2, xt−1)

(1)

(2)

the widely used recurrent

and b are parameters of
where Wh
the
(along with word embeddings xt),
model
func-
LSTM is
“long short-term memory”
tion known as
(Hochreiter and Schmidhuber, 1997), and ht
is
a LSTM hidden state encoding the history of the
sequence up to the tth word.

Great success has been reported for this model
(Zaremba et al., 2015), which posits nothing ex-
plicitly about the words appearing in the text se-
quence. Its generative story is simple: the value
of each Xt is randomly chosen conditioned on the
vector ht−1 encoding its history.

2.1 Additional random variables and
representations for entities

To introduce our model, we associate with each
word an additional set of random variables. At po-
sition t,

• Rt is a binary random variable that indi-
cates whether xt belongs to an entity men-
tion (Rt = 1) or not (Rt = 0). Though not
explored here, this is easily generalized to a
categorial variable for the type of the entity
(e.g., person, organization, etc.).

• Lt ∈ {1, . . . , ℓmax } is a categorical random
variable if Rt = 1, which indicates the num-
ber of remaining words in this mention, in-
cluding the current word (i.e., Lt = 1 for
ℓmax is a
the last word in any mention).
predeﬁned maximum length ﬁxed to be 25,
which is an empirical value derived from the
training corpora used in the experiments. If

Rt = 0, then Lt = 1. We denote the value of
Lt by ℓt.

• Et ∈ Et is the index of the entity referred to,
if Rt = 1. The set Et consists of {1, . . . , 1 +
maxt′<t et′ }, i.e., the indices of all previously
mentioned entities plus an additional value
for a new entity. Thus Et starts as {1} and
grows monotonically with t, allowing for an
arbitrary number of entities to be mentioned.
We denote the value of Et by et. If Rt = 0,
then Et is ﬁxed to a special value ø.

The values of these random variables for our run-
ning example are shown in Figure 2.

In addition to using symbolic variables to en-
code mentions and coreference relationships, we
maintain a vector representation of each entity that
evolves over time. For the ith entity, let ei,t be
its representation at time t. These vectors are
different from word vectors (xt), in that they are
not parameters of the model. They are similar to
history representations (ht), in that they are de-
rived through parameterized functions of the ran-
dom variables’ values, which we will describe in
the next subsections.

2.2 Generative story

The generative story for the word (and other
variables) at timestep t is as follows; forward-
referenced equations are in the detailed discussion
that follows.

1. If ℓt−1 = 1 (i.e., xt is not continuing an

already-started entity mention):

• Choose rt (Equation 3).
• If rt = 0, set ℓt = 1 and et = ø; then go

to step 3. Otherwise:

– If there is no embedding for the
new candidate entity with index
1 + maxt′<t et′, create one follow-
ing §2.4.

– Select the entity et from {1, . . . , 1 +

maxt′<t et′ } (Equation 4).

– Set ecurrent = eet,t−1, which is
the entity embedding of et before
timestep t.

– Select the length of the mention, ℓt

(Equation 5).

2. Otherwise,

• Set ℓt = ℓt−1 − 1, rt = rt−1, et = et−1.

X1:12:
R1:12:
E1:12:
L1:12:

1
1
1

John wanted

0
ø
1

to
0
ø
1

go
0
ø
1
X13:22: He was
R13:22:
0
E13:22:
ø
L13:22:
1

1
1
1

in
0
ø
1

to
0
ø
1
told
0
ø
1

the
1
2
3
that
0
ø
1

coffee
1
2
2
it
1
2
1

shop
1
2
1
sold
0
ø
1

the
1
4
3

downtown
1
3
2
beans
1
4
1

best
1
4
2

.
.
ø
0

Copenhagen
1
3
1

.
0
ø
1

Figure 2: The random variable values in ENTITYNLM for the running example in Figure 1.

3. Sample xt from the word distribution given
the LSTM hidden state ht−1 and the current
(or most recent) entity embedding ecurrent
(Equation 6). (If rt = 0, then ecurrent still
represents the most recently mentioned en-
tity.)

4. Advance the RNN, i.e., feed it the word vec-

tor xt to compute ht (Equation 2).

5. If rt = 1, update eet,t using eet,t−1 and ht,
then set ecurrent = eet,t. Details of the entity
updating are given in §2.4.

6. For every entity eι ∈ Et \ {et}, set eι,t =
eι,t−1 (i.e., no changes to other entities’ rep-
resentations).

Note that at any given time step t, ecurrent will al-
ways contain the most recent vector representation
of the most recently mentioned entity.

A generative model with a similar hierarchical
structure was used by Haghighi and Klein (2010)
for coreference resolution. Our approach differs
in two important ways.
First, our model de-
ﬁnes a joint distribution over all of the text, not
just the entity mentions. Second, we use repre-
sentation learning rather than Bayesian nonpara-
metrics, allowing natural integration with the lan-
guage model.

2.3 Probability distributions

The generative story above referenced several
parametric distributions deﬁned based on vector
representations of histories and entities. These are
deﬁned as follows.
For r ∈ {0, 1},

p(Rt = r | ht−1) ∝ exp(h⊤

t−1

Wrr),

(3)

where r is the parameterized embedding associ-
ated with r, which paves the way for exploring en-
tity type representations in future work; Wr is a

parameter matrix for the bilinear score for ht−1
and r.

To give the possibility of predicting a new en-
tity, we need an entity embedding beforehand
with index (1 + maxt′<t et′ ), which is randomly
sampled from Equation 7. Then, for every e ∈
{1, . . . , 1 + maxt′<t et′}:

p(Et = e | Rt = 1, ht−1)

∝ exp(h⊤

t−1

Wentity ee,t−1 + w⊤
dist

f (e)),

(4)

where ee,t−1 is the embedding of entity e at time
step t−1 and Wentity is the weight matrix for pre-
dicting entities using their continuous representa-
tions. The score above is normalized over values
{1, . . . , 1 + maxt′<t et′}. f (e) represents a vector
of distance features associated with e and the men-
tions of the existing entities. Hence two informa-
tion sources are used to predict the next entity: (i)
contextual information ht−1, and (ii) distance fea-
tures f (e) from the current mention to the closest
mention from each previously mentioned entity.
f (e) = 0 if e is a new entity. This term can also
be extended to include other surface-form features
for coreference resolution (Martschat and Strube,
2015; Clark and Manning, 2016b).

For the chosen entity et from Equation 4, the
distribution over its mention length is drawn ac-
cording to

p(Lt = ℓ | ht−1, eet,t−1)

∝ exp(W⊤

length,ℓ[ht−1; eet,t−1]),

(5)

where eet,t−1 is the most recent embedding of the
entity et, not updated with ht. The intuition is that
eet,t−1 will help contextual information ht−1 to
select the residual length of entity et. Wlength
is the weight matrix for length prediction, with
ℓmax = 25 rows.

Finally, the probability of a word x as the next
token is jointly modeled by ht−1 and the vector
representation of the most recently mentioned en-

tity ecurrent :

p(Xt = x | ht−1, ecurrent )

∝ CFSM(ht−1 + Weecurrent ),

(6)

the dimensionality of ecurrent .

where We is a transformation matrix to ad-
just
CFSM is
a class factorized softmax function (Goodman,
2001; Baltescu and Blunsom, 2015). It uses a two-
step prediction with predeﬁned word classes in-
stead of direct prediction on the whole vocabulary,
and reduces the time complexity to the log of vo-
cabulary size.

2.4 Dynamic entity representations

Before predicting the entity at step t, we need an
embedding for the new candidate entity with index
e′ = 1 + maxt′<t et′ if it does not exist. The new
embedding is generated randomly, according to a
normal distribution, then projected onto the unit
ball:

u ∼ N (r1, σ2I);
u
kuk2

,

ee′,t−1 =

(7)

where σ = 0.01. The time step t − 1 in ee′,t−1
means the current embedding contains no infor-
mation from step t, although it will be updated
once we have ht and if Et = e′. r1 is the pa-
rameterized embedding for Rt = 1, which will be
jointly optimized with other parameters and is ex-
pected to encode some generic information about
entities. All the initial entity embeddings are cen-
tered on the mean r1, which is used in Equation 3
to determine whether the next token belongs to an
entity mention. Another choice would be to ini-
tialize with a zero vector, although our preliminary
experiments showed this did not work as well as
random initialization in Equation 7.

Assume Rt = 1 and Et = et, which means xt
is part of a mention of entity et. Then, we need
to update eet,t−1 based on the new information we
have from ht. The new embedding eet,t is a con-
vex combination of the old embedding (eet,t−1)
and current LSTM hidden state (ht) with the in-
terpolation (δt) determined dynamically based on
a bilinear function:

Wδeet,t−1);

δt = σ(h⊤
t
u = δteet,t−1 + (1 − δt)ht;
,

eet,t =

u
kuk2

(8)

This updating scheme will be used to update et in
each of all the following ℓt steps. The projection in
the last step keeps the magnitude of the entity em-
bedding ﬁxed, avoiding numeric overﬂow. A simi-
lar updating scheme has been used by Henaff et al.
(2016) for the “memory blocks” in their recurrent
entity network models. The difference is that their
model updates all memory blocks in each time
step. Instead, our updating scheme in Equation 8
only applies to the selected entity et at time step t.

2.5 Training objective

The model is trained to maximize the log of the
joint probability of R, E, L, and X:
ℓ(θ) = log P (R, E, L, X; θ)

log P (Rt, Et, Lt, Xt; θ),

(9)

= X
t

where θ is the collection of all the parameters
in this model. Based on the formulation in §2.3,
Equation 9 can be decomposed as the sum of con-
ditional log-probabilities of each random variable
at each time step.

This objective requires the training data anno-
tated as in Figure 2. We do not assume that these
variables are observed at test time.

3 Implementation Details

is

and

2017)

available

implemented with DyNet
at

Our model
(Neubig et al.,
https://github.com/jiyfeng/entitynlm.
We use AdaGrad (Duchi et al., 2011) with learn-
ing rate λ = 0.1 and ADAM (Kingma and Ba,
learning rate λ = 0.001
2014) with default
as the candidate optimizers of our model. For
the parameters, we use the initialization
all
by Glorot and Bengio
tricks
(2010).
To avoid overﬁtting, we also em-
ploy dropout (Srivastava et al., 2014) with the
candidate rates as {0.2, 0.5}.

recommended

In addition,

there are two tunable hyperpa-
rameters of ENTITYNLM: the size of word em-
beddings and the dimension of LSTM hidden
states. For both of them, we consider the values
{32, 48, 64, 128, 256}. We also experiment with
the option to either use the pretrained GloVe word
embeddings (Pennington et al., 2014) or randomly
initialized word embeddings (then updated during
training). For all experiments, the best conﬁgura-
tion of hyperparameters and optimizers is selected
based on the objective value on the development
data.

4 Evaluation Tasks and Datasets

We evaluate our model in diverse use scenarios:
(i) language modeling, (ii) coreference resolution,
and (iii) entity prediction. The evaluation on lan-
guage modeling shows how the internal entity rep-
resentation, when marginalized out, can improve
the perplexity of language models. The evaluation
on coreference resolution experiment shows how
our new language model can improve a compet-
itive coreference resolution system. Finally, we
employ an entity cloze task to demonstrate the
generative performance of our model in predicting
the next entity given the previous context.

We use two datasets for the three evaluation
tasks. For language modeling and coreference
resolution, we use the English benchmark data
from the CoNLL 2012 shared task on corefer-
ence resolution (Pradhan et al., 2012). We employ
the standard training/development/test split, which
includes 2,802/343/348 documents with roughly
1M/150K/150K tokens, respectively. We follow
the coreference annotation in the CoNLL dataset
to extract entities and ignore the singleton men-
tions in texts.

For entity prediction, we employ the InScript
corpus created by Modi et al. (2017). It consists of
10 scenarios, including grocery shopping, taking a
ﬂight, etc.
It includes 910 crowdsourced simple
narrative texts in total and 18 stories were ignored
due to labeling problems (Modi et al., 2017). On
average, each story has 12.4 sentences, 24.9 en-
tities and 217.2 tokens. Each entity mention is
labeled with its entity index. We use the same
training/development/test split as in (Modi et al.,
2017), which includes 619, 91, 182 texts, respec-
tively.

Data preprocessing

For the CoNLL dataset, we lowercase all tokens
and remove any token that only contains a punctu-
ation symbol unless it is in an entity mention. We
also replace numbers in the documents with the
special token NUM and low-frequency word types
with UNK. The vocabulary size of the CoNLL data
after preprocessing is 10K. For entity mention ex-
traction, in the CoNLL dataset, one entity men-
tion could be embedded in another. For embed-
ded mentions, only the enclosing entity mention
is kept. We use the same preprocessed data for
both language modeling and coreference resolu-
tion evaluation.

For the InScript corpus, we apply similar data
preprocessing to lowercase all tokens, and we re-
place low-frequency word types with UNK. The
vocabulary size after preprocessing is 1K.

5 Experiments

In this section, we present the experimental results
on the three evaluation tasks.

5.1 Language modeling

Task description. The goal of language model-
ing is to compute the marginal probability:

P (X) = X
R,E,L

P (X, R, E, L).

(10)

However, due to the long-range dependency in
recurrent neural networks,
the search space of
R, E, L during inference grows exponentially.
We thus use importance sampling to approxi-
mate the marginal distribution of X. Speciﬁ-
cally, with the samples from a proposal distri-
bution Q(R, E, L|X), the approximated marginal
probability is deﬁned as

P (X) = X
R,E,L

P (X, R, E, L)

Q(R, E, L | X)

= X
R,E,L

P (X, R, E, L)
Q(R, E, L | X)

≈

1
N X

{r(i),e(i),ℓ(i)}∼Q

P (r(i), e(i), ℓ(i), x)
Q(r(i), e(i), ℓ(i) | x)

(11)

A similar idea of using importance sampling for
language modeling evaluation has been used by
Dyer et al. (2016).

For language modeling evaluation, we train our
model on the training set from the CoNLL 2012
dataset with coreference annotation. On the test
data, we treat coreference structure as latent vari-
ables and use importance sampling to approximate
the marginal distribution of X. For each docu-
ment, the model randomly draws N = 100 sam-
ples from the proposal distribution, discussed next.

Proposal distribution. For implementation of
Q, we use a discriminative variant of ENTI-
TYNLM by taking the current word xt for predict-
ing the entity-related variables in the same time
step. Speciﬁcally, in the generative story described
in §2.2, we delete step 3 (words are not gener-
ated, but rather conditioned upon), move step 4

Perplexity

5.2 Coreference reranking

Model

1. 5-gram LM
2. RNNLM
3. ENTITYNLM

138.37
134.79
131.64

Table 1: Language modeling evaluation on the test
sets of the English section in the CoNLL 2012
shared task. As mentioned in §4, the vocabulary
size is 10K. ENTITYNLM does not require any
coreference annotation on the test data.

before step 1, and replace ht−1 with ht in the
steps for predicting entity type Rt, entity Et and
mention length Lt. This model variant provides a
conditional probability Q(Rt, Et, Lt | Xt) at each
timestep.

Baselines. We compare the language modeling
performance with two competitive baselines: 5-
gram language model
implemented in KenLM
(Heaﬁeld et al., 2013) and RNNLM with LSTM
units implemented in DyNet (Neubig et al., 2017).
For RNNLM, we use the same hyperparameters
described in §3 and grid search on the develop-
ment data to ﬁnd the best conﬁguration.

T
T P

Results. The results of ENTITYNLM and the
baselines on both development and test data are
reported in Table 1. For ENTITYNLM, we use the
value of 2− 1
t=1 log P (Xt,Rt,Et,Lt) on the devel-
opment set with coreference annotation to select
the best model conﬁguration and report the best
number. On the test data, we are able to calcu-
late perplexity by marginalizing all other random
variables using Equation 11. To compute the per-
plexity numbers on the test data, our model only
takes account of log probabilities on word predic-
tion. The difference is that coreference informa-
tion is only used for training ENTITYNLM and
not for test. All three models reported in Table 1
share the same vocabulary, therefore the numbers
on the test data are directly comparable. As shown
in Table 1, ENTITYNLM outperforms both the 5-
gram language model and the RNNLM on the test
data. Better performance of ENTITYNLM on lan-
guage modeling can be expected, if we also use the
marginalization method deﬁned in Equation 11 on
the development data to select the best conﬁgura-
tion. However, we plan to use the same experi-
mental setup for all experiments, instead of cus-
tomizing our model for each individual task.

Task description. We show how ENTITYLM,
which allows an efﬁcient computation of the
probability P (R, E, L, X),
can be used as
to improve a com-
a coreference reranker
petitive coreference resolution system due to
Martschat and Strube (2015). This task is analo-
gous to the reranking approach used in machine
translation (Shen et al., 2004). The speciﬁc for-
mulation is as follows:

arg

max
{r(i),e(i),l(i)}∈K

P (r(i), e(i), l(i), x)

(12)

where K is the k-best list for a given document.
In our experiments, k = 100. To the best of our
knowledge, the problem of obtaining k-best out-
puts of a coreference resolution system has not
been studied before.

Approximate k-best decoding. We rerank the
output of a system that predicts an antecedent for
each mention by relying on pairwise scores for
mention pairs. This is the dominant approach
for coreference resolution (Martschat and Strube,
2015; Clark and Manning, 2016a). The predic-
tions induce an antecedent tree, which represents
antecedent decisions for all mentions in the doc-
ument. Coreference chains are obtained by tran-
sitive closure over the antecedent decisions en-
coded in the tree. A mention also can have an
empty mention as antecedent, which denotes that
the mention is non-anaphoric.

For extending Martschat and Strube’s greedy
decoding approach to k-best inference, we can-
not simply take the k highest scoring trees ac-
cording to the sum of edge scores, because dif-
ferent trees may represent the same coreference
chain.
Instead, we use an heuristic that creates
an approximate k-best list on candidate antecedent
trees. The idea is to generate trees from the orig-
inal system output by considering suboptimal an-
tecedent choices that lead to different coreference
chains. For each mention pair (mj, mi), we com-
pute the difference of its score to the score of the
optimal antecedent choice for mj. We then sort
pairs in ascending order according to this differ-
ence and iterate through the list of pairs. For each
pair (mj, mi), we create a tree tj,i by replacing
the antecedent of mj in the original system output
with mi. If this yields a tree that encodes differ-
ent coreference chains from all chains encoded by
trees in the k-best list, we add ti,j to the k-best list.

In the case that we cannot generate a given num-
ber of trees (particularly for a short document with
a large k), we pad the list with the last item added
to the list.

evaluation,

measures. For
we
employ
(Pradhan et al., 2014).

Evaluation
coreference
the
resolution
It
CoNLL scorer
evalua-
used
computes
tion measures MUC (Vilain et al.,
1995),
B3 (Bagga and Baldwin, 1998), and CEAFe (Luo,
2005). We report the F1 score of each evaluation
measure and their average as the CoNLL score.

commonly

three

employed CORT1
Competing systems. We
(Martschat and Strube, 2015) as our baseline
coreference resolution system. Here, we com-
pare with the original
(one best) outputs of
CORT’s latent ranking model, which is the best-
performing model implemented in CORT. We
consider two rerankers based on ENTITYNLM.
The ﬁrst reranking method only uses the log
probability for ENTITYNLM to sort the candidate
list (Equation 12). The second method uses a
linear combination of both log probabilities from
ENTITYNLM and the scores from CORT, where
the coefﬁcients were found via grid search with
the CoNLL score on the development set.

Results. The reranked results on the CoNLL
2012 test set are reported in Table 2. The numbers
of the baseline are higher than the results reported
in Martschat and Strube (2015) since the feature
set of CORT was subsequently extended. Lines 2
and 3 in Table 2 present the reranked best results.
As shown in this table, both reranked results give
more than 1% of CoNLL score improvement on
the test set over CORT, which are signiﬁcant based
on an approximate randomization test2.

Additional experiments also found that increas-
ing k from 100 to 500 had a minor effect. That is
because the diversity of each k-best list is limited
by (i) the number of entity mentions in the docu-
ment, (ii) the performance of the baseline corefer-
ence resolution system, and possibly (iii) the ap-
proximate nature of our k-best inference proce-
dure. We suspect that a stronger baseline system
(such as that of Clark and Manning, 2016a) could
give greater improvements, if it can be adapted to
provide k-best lists. Future work might incorpo-

1https://github.com/smartschat/cort, we

used version 0.2.4.5.

2https://github.com/smartschat/art

[I]1 was about to ride [my]1 [bicycle]2 to the
[park]3 one day when [I]1 noticed that the front
[tire]4 was ﬂat . [I]1 realized that [I]1 would
have to repair [it]4 .
[I]1 went into [my]1
[garage]5 to get some [tools]5 . The ﬁrst thing
[I]1 did was remove the xxxx

Figure 3: A short story on bicycles from the
InScript corpus (Modi et al., 2017). The entity
prediction task requires predicting xxxx given
the preceding text either by choosing a previously
mentioned entity or deciding that this is a “new en-
tity”. In this example, the ground-truth prediction
is [tire]4. For training, ENTITYNLM attempts to
predict every entity. While, for testing, it predicts
a maximum of 30 entities after the ﬁrst three sen-
tences, which is consistent with the experimental
setup suggested by Modi et al. (2017).

rate the techniques embedded in such systems into
ENTITYNLM.

5.3 Entity prediction

Task description. Based on Modi et al. (2017),
we introduce a novel entity prediction task that
tries to predict the next entity given the preced-
ing text. For a given text as in Figure 3, this task
makes a forward prediction based on only the left
context. This is different from coreference reso-
lution, where both left and right contexts from a
It is
given entity mention are used in decoding.
also different from language modeling, since this
task only requires predicting entities. Since EN-
TITYNLM is generative, it can be directly applied
to this task. To predict entities in test data, Rt is
always given and ENTITYNLM only needs to pre-
dict Et when Rt = 1.

Baselines and human prediction. We intro-
duce two baselines in this task: (i) the always-new
baseline that always predicts “new entity”; (ii) a
linear classiﬁcation model using shallow features
from Modi et al. (2017), including the recency of
an entity’s last mention and the frequency. We also
compare with the model proposed by Modi et al.
(2017). Their work assumes that the model has
prior knowledge of all the participant types, which
are speciﬁc to each scenario and ﬁne-grained, e.g.,
rider in the bicycle narrative, and predicts partic-
ipant types for new entities. This assumption is
unrealistic for pure generative models like ours.
Therefore, we remove this assumption and adapt

Model

CoNLL

1. Baseline: CORT’s one best
2. Rerank: ENTITYNLM
3. Rerank: ENTITYNLM + CORT

62.93
64.00
64.04

MUC
P

77.15
77.90
77.93

R

68.67
69.45
69.49

F1

72.66
73.44
73.47

B3
P

66.00
66.84
67.08

R

54.92
56.12
55.99

F1

59.95
61.01
61.04

CEAFe
P

R

60.07
61.73
61.76

52.76
53.90
53.98

F1

56.18
57.55
57.61

Table 2: Coreference resolution scores on the CoNLL 2012 test set. CORT is the best-performing model
of Martschat and Strube (2015) with greedy decoding.

1. Baseline: always-new
2. Baseline: shallow features
3. Modi et al. (2017)
4. ENTITYNLM
5. Human prediction

Accuracy (%)

31.08
45.34
62.65
74.23
77.35

Table 3: Entity prediction accuracy on the test set
of the InScript corpus.

their prediction results to our formulation by map-
ping all the predicted entities that have not been
mentioned to “new entity”. We also compare to
the adapted human prediction used in the In-
Script corpus. For each entity slot, Modi et al.
(2017) acquired 20 human predictions, and the
majority vote was selected. More details about
human predictions are discussed in (Modi et al.,
2017).

Results. Table 3 shows the prediction accura-
cies. ENTITYNLM (line 4) signiﬁcantly outper-
forms both baselines (line 1 and 2) and prior work
(line 3) (p ≪ 0.01, paired t-test). The compari-
son between line 4 and 5 shows our model is even
close to the human prediction performance.

6 Related Work

Rich-context language models. The originally
proposed recurrent neural network language mod-
els only capture information within sentences.
To extend the capacity of RNNLMs, various re-
searchers have incorporated information beyond
sentence boundaries.
Previous work focuses
on contextual
information from previous sen-
tences (Ji et al., 2016a) or discourse relations be-
tween adjacent sentences (Ji et al., 2016b), show-
ing improvements to language modeling and re-
lated tasks like coherence evaluation and discourse
relation prediction.
In this work, ENTITYNLM
adds explicit entity information to the language
model, which is another way of adding a memory
network for language modeling. Unlike the work

by Tran et al. (2016), where memory blocks are
used to store general contextual information for
language modeling, ENTITYNLM assigns each
memory block speciﬁcally to only one entity.

Entity-related models. Two recent approaches
to modeling entities in text are closely related
to our model. The ﬁrst is the “reference-aware”
language models proposed by Yang et al. (2016),
where the referred entities are from either a pre-
deﬁned item list, an external database, or the con-
text from the same document. Yang et al. (2016)
present three models, one for each case. For mod-
eling a document with entities, they use corefer-
ence links to recover entity clusters, though they
only model entity mentions as containing a single
word (an inappropriate assumption, in our view).
Their entity updating method takes the latest hid-
den state (similar to ht when Rt = 1 in our model)
as the new representation of the current entity; no
long-term history of the entity is maintained, just
the current local context.
In addition, their lan-
guage model evaluation assumes that entity infor-
mation is provided at test time (Yang, personal
communication), which makes a direct compari-
son with our model impossible. Our entity updat-
ing scheme is similar to the “dynamic memory”
method used by Henaff et al. (2016). Our entity
representations are dynamically allocated and up-
dated only when an entity appears up, while the
EntNet from Henaff et al. (2016) does not model
entities and their relationships explicitly. In their
model, entity memory blocks are pre-allocated
and updated simultaneously in each timestep. So
there is no dedicated memory block for every en-
tity and no distinction between entity mentions
and non-mention words. As a consequence, it is
not clear how to use their model for coreference
reranking and entity prediction.

Coreference resolution. The hierarchical struc-
ture of our entity generation model is inspired by
Haghighi and Klein (2010). They implemented
this idea as a probabillistic graphical model with

the distance-dependent Chinese Restaurant Pro-
cess (Pitman, 1995) for entity assignment, while
our model is built on a recurrent neural network
architecture. The reranking method considered in
our coreference resolution evaluation could also
be extended with samples from additional corefer-
ence resolution systems, to produce more variety
(Ng, 2005). The beneﬁt of such a system comes,
we believe, from the explicit tracking of each en-
tity throughout the text, providing entity-speciﬁc
representations. In previous work, such informa-
tion has been added as features (Luo et al., 2004;
Bj¨orkelund and Kuhn, 2014) or by computing
distributed entity representations (Wiseman et al.,
2016; Clark and Manning, 2016b). Our approach
complements these previous methods.

Entity prediction. The entity prediction task
discussed in §5.3 is based on work by Modi et al.
The main difference is that we do
(2017).
not assume that all entities belong to a previ-
ously known set of entity types speciﬁed for
each narrative scenario.
This task is also
closely related to the “narrative cloze” task of
Chambers and Jurafsky (2008) and the “story
cloze test” of Mostafazadeh et al. (2016). Those
studies aim to understand relationships between
events, while our task focuses on predicting up-
coming entity mentions.

7 Conclusion

We have presented a neural language model, EN-
TITYNLM, that deﬁnes a distribution over texts
and the mentioned entities. It provides vector rep-
resentations for the entities and updates them dy-
namically in context. The dynamic representations
are further used to help generate speciﬁc entity
mentions and the following text. This model out-
performs strong baselines and prior work on three
tasks: language modeling, coreference resolution,
and entity prediction.

Acknowledgments

We thank anonymous reviewers for the helpful
feedback on this work. We also thank the members
of Noah’s ARK and XLab at University of Wash-
ington for their valuable comments, particularly
Eunsol Choi for pointing out the InScript corpus.
This research was supported in part by a Univer-
sity of Washington Innovation Award, Samsung
GRO, NSF grant IIS-1524371, the DARPA CwC

program through ARO (W911NF-15-1-0543), and
gifts by Google and Facebook.

References

Amit Bagga and Breck Baldwin. 1998. Algorithms for
scoring coreference chains. In LREC Workshop on
Linguistic Coreference.

Paul Baltescu and Phil Blunsom. 2015. Pragmatic neu-
ral language modelling in machine translation.
In
NAACL.

Anders Bj¨orkelund and Jonas Kuhn. 2014. Learn-
ing structured perceptrons for coreference resolution
with latent antecedents and non-local features.
In
ACL.

Nathanael Chambers and Daniel Jurafsky. 2008. Un-
supervised Learning of Narrative Event Chains. In
ACL.

Kevin Clark and Christopher D. Manning. 2016a.
Deep reinforcement learning for mention-ranking
coreference models. In EMNLP.

Kevin Clark and Christopher D. Manning. 2016b. Im-
proving coreference resolution by learning entity-
level distributed representations. In ACL.

John Duchi, Elad Hazan, and Yoram Singer. 2011.
Adaptive subgradient methods for online learning
Journal of Machine
and stochastic optimization.
Learning Research, 12:2121–2159.

Chris Dyer, Adhiguna Kuncoro, Miguel Ballesteros,
and Noah A. Smith. 2016. Recurrent neural network
grammars. In EMNLP.

Xavier Glorot and Yoshua Bengio. 2010. Understand-
ing the difﬁculty of training deep feedforward neural
networks. In AISTATS, pages 249–256.

Joshua Goodman. 2001. Classes for fast maximum en-

tropy training. In ICASSP.

Aria Haghighi and Dan Klein. 2010. Coreference res-
olution in a modular, entity-centered model.
In
NAACL.

Kenneth Heaﬁeld,

Ivan Pouzyrevsky, Jonathan H.
Clark, and Philipp Koehn. 2013. Scalable modiﬁed
Kneser-Ney language model estimation. In ACL.

Mikael Henaff, Jason Weston, Arthur Szlam, An-
toine Bordes, and Yann LeCun. 2016.
Track-
ing the world state with recurrent entity networks.
arXiv:1612.03969.

Sepp Hochreiter and J¨urgen Schmidhuber. 1997.
Long short-term memory. Neural Computation,
9(8):1735–1780.

Yangfeng Ji, Trevor Cohn, Lingpeng Kong, Chris Dyer,
and Jacob Eisenstein. 2016a. Document context lan-
guage models. In ICLR (workshop track).

Libin Shen, Anoop Sarkar, and Franz Josef Och. 2004.
Discriminative reranking for machine translation. In
NAACL.

Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky,
Ilya Sutskever, and Ruslan Salakhutdinov. 2014.
Dropout: A simple way to prevent neural networks
from overﬁtting. Journal of Machine Learning Re-
search, 15(1):1929–1958.

Ke Tran, Arianna Bisazza, and Christof Monz. 2016.
Recurrent memory networks for language modeling.
In NAACL-HLT.

Marc Vilain, John Burger, John Aberdeen, Dennis Con-
nolly, and Lynette Hirschman. 1995. A model-
theoretic coreference scoring scheme. In MUC.

Sam Wiseman, Alexander M. Rush, and Stuart M.
Shieber. 2016. Learning global features for coref-
erence resolution. In NAACL.

Zichao Yang, Phil Blunsom, Chris Dyer, and Wang
Ling. 2016. Reference-aware language models.
arXiv:1611.01628.

Wojciech Zaremba, Ilya Sutskever, and Oriol Vinyals.
Recurrent neural network regularization.

2015.
ICLR.

Yangfeng Ji, Gholamreza Haffari, and Jacob Eisen-
stein. 2016b. A latent variable recurrent neural
network for discourse-driven language models.
In
NAACL-HLT.

Diederik Kingma and Jimmy Ba. 2014.
for

stochastic

Adam:
optimization.

method
A
arXiv:1412.6980.

Xiaoqiang Luo. 2005. On coreference resolution per-

formance metrics. In HLT-EMNLP.

Xiaoqiang Luo, Abe Ittycheriah, Hongyan Jing, Nanda
Kambhatla, and Salim Roukos. 2004. A mention-
synchronous coreference resolution algorithm based
on the Bell tree. In ACL.

Sebastian Martschat and Michael Strube. 2015. La-
tent structures for coreference resolution. Transac-
tions of the Association for Computational Linguis-
tics, 3:405–418.

Tomas Mikolov, Martin Karaﬁ´at, Lukas Burget, Jan
Cernock`y, and Sanjeev Khudanpur. 2010. Recur-
rent neural network based language model. In IN-
TERSPEECH.

Ashutosh Modi, Ivan Titov, Vera Demberg, Asad Say-
eed, and Manfred Pinkal. 2017. Modeling seman-
tic expectation: Using script knowledge for referent
prediction. Transactions of the Association of Com-
putational Linguistics, 5:31–44.

Nasrin Mostafazadeh, Nathanael Chambers, Xiaodong
He, Devi Parikh, Dhruv Batra, Lucy Vanderwende,
Pushmeet Kohli, and James Allen. 2016. A corpus
and evaluation framework for deeper understanding
of commonsense stories. In NAACL.

Graham Neubig, Chris Dyer, Yoav Goldberg, Austin
Matthews, Waleed Ammar, Antonios Anastasopou-
los, Miguel Ballesteros, David Chiang, Daniel
Clothiaux, Trevor Cohn, et al. 2017. Dynet: The
dynamic neural network toolkit. arXiv:1701.03980.

Vincent Ng. 2005. Machine learning for coreference
resolution: From local classiﬁcation to global rank-
ing. In ACL.

Jeffrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. Glove: Global vectors for
word representation. In EMNLP.

Jim Pitman. 1995. Exchangeable and partially ex-
changeable random partitions. Probability Theory
and Related Fields, 102(2):145–158.

Sameer Pradhan, Xiaoqiang Luo, Marta Recasens, Ed-
uard Hovy, Vincent Ng, and Michael Strube. 2014.
Scoring coreference partitions of predicted men-
tions: A reference implementation. In ACL.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Olga Uryupina, and Yuchen Zhang. 2012. CoNLL-
2012 shared task: Modeling multilingual unre-
In EMNLP-
stricted coreference in OntoNotes.
CoNLL.

7
1
0
2
 
g
u
A
 
2
 
 
]
L
C
.
s
c
[
 
 
1
v
1
8
7
0
0
.
8
0
7
1
:
v
i
X
r
a

Dynamic Entity Representations in Neural Language Models

Yangfeng Ji∗ Chenhao Tan∗ Sebastian Martschat† Yejin Choi∗ Noah A. Smith∗
∗Paul G. Allen School of Computer Science & Engineering, University of Washington
†Department of Computational Linguistics, Heidelberg University
{yangfeng,chenhao,yejin,nasmith}@cs.washington.edu
martschat@cl.uni-heidelberg.de

Abstract

Understanding a long document requires
tracking how entities are introduced and
evolve over time. We present a new type of
language model, ENTITYNLM, that can
explicitly model entities, dynamically up-
date their representations, and contextu-
ally generate their mentions. Our model is
generative and ﬂexible; it can model an ar-
bitrary number of entities in context while
generating each entity mention at an arbi-
trary length.
In addition, it can be used
for several different tasks such as language
modeling, coreference resolution, and en-
tity prediction. Experimental results with
all these tasks demonstrate that our model
consistently outperforms strong baselines
and prior work.

1 Introduction

Understanding a narrative requires keeping track
of its participants over a long-term context. As a
story unfolds, the information a reader associates
with each character in a story increases, and ex-
pectations about what will happen next change ac-
cordingly. At present, models of natural language
do not explicitly track entities; indeed, in today’s
language models, entities are no more than the
words used to mention them.

In this paper, we endow a generative language
model with the ability to build up a dynamic rep-
resentation of each entity mentioned in the text.
Our language model deﬁnes a probability distribu-
tion over the whole text, with a distinct generative
story for entity mentions. It explicitly groups those
mentions that corefer and associates with each en-
tity a continuous representation that is updated by
every contextualized mention of the entity, and
that in turn affects the text that follows.

[John]1 wanted to go to [the coffee shop]2 in
[downtown Copenhagen]3. [He]1 was told that
[it]2 sold [the best beans]4.

Figure 1: ENTITYNLM explicitly tracks entities
in a text, including coreferring relationships be-
tween entities like [John]1 and [He]1. As a lan-
guage model, it is designed to predict that a coref-
erent of [the coffee shop]2 is likely to follow “told
that,” that the referring expression will be “it”, and
that “sold the best beans” is likely to come next, by
using entity information encoded in the dynamic
distributed representation.

Because our model

Our method builds on recent advances in repre-
sentation learning, creating local probability dis-
tributions from neural networks.
It can be un-
derstood as a recurrent neural network language
model, augmented with random variables for en-
tity mentions that capture coreference, and with
dynamic representations of entities. We estimate
the model’s parameters from data that is annotated
with entity mentions and coreference.
is generative,

it can be
queried in different ways. Marginalizing every-
thing except the words, it can play the role of a lan-
guage model. In §5.1, we ﬁnd that it outperforms
both a strong n-gram language model and a strong
recurrent neural network language model on the
English test set of the CoNLL 2012 shared task
on coreference evaluation (Pradhan et al., 2012).
The model can also identify entity mentions and
In §5.2,
coreference relationships among them.
we show that it can easily be used to add a per-
formance boost to a strong coreference resolution
system, by reranking a list of k-best candidate out-
puts. On the CoNLL 2012 shared task test set, the
reranked outputs are signiﬁcantly better than the
original top choices from the same system. Fi-

nally, the model can perform entity cloze tasks.
As presented in §5.3, it achieves state-of-the-art
performance on the InScript corpus (Modi et al.,
2017).

2 Model

A language model deﬁnes a distribution over se-
quences of word tokens; let Xt denote the random
variable for the tth word in the sequence, xt de-
note the value of Xt and xt the distributed repre-
sentation (embedding) of this word. Our starting
point for language modeling is a recurrent neural
network (Mikolov et al., 2010), which deﬁnes

p(Xt | history) = softmax (Whht−1 + b)

ht−1 = LSTM(ht−2, xt−1)

(1)

(2)

the widely used recurrent

and b are parameters of
where Wh
the
(along with word embeddings xt),
model
func-
LSTM is
“long short-term memory”
tion known as
(Hochreiter and Schmidhuber, 1997), and ht
is
a LSTM hidden state encoding the history of the
sequence up to the tth word.

Great success has been reported for this model
(Zaremba et al., 2015), which posits nothing ex-
plicitly about the words appearing in the text se-
quence. Its generative story is simple: the value
of each Xt is randomly chosen conditioned on the
vector ht−1 encoding its history.

2.1 Additional random variables and
representations for entities

To introduce our model, we associate with each
word an additional set of random variables. At po-
sition t,

• Rt is a binary random variable that indi-
cates whether xt belongs to an entity men-
tion (Rt = 1) or not (Rt = 0). Though not
explored here, this is easily generalized to a
categorial variable for the type of the entity
(e.g., person, organization, etc.).

• Lt ∈ {1, . . . , ℓmax } is a categorical random
variable if Rt = 1, which indicates the num-
ber of remaining words in this mention, in-
cluding the current word (i.e., Lt = 1 for
ℓmax is a
the last word in any mention).
predeﬁned maximum length ﬁxed to be 25,
which is an empirical value derived from the
training corpora used in the experiments. If

Rt = 0, then Lt = 1. We denote the value of
Lt by ℓt.

• Et ∈ Et is the index of the entity referred to,
if Rt = 1. The set Et consists of {1, . . . , 1 +
maxt′<t et′ }, i.e., the indices of all previously
mentioned entities plus an additional value
for a new entity. Thus Et starts as {1} and
grows monotonically with t, allowing for an
arbitrary number of entities to be mentioned.
We denote the value of Et by et. If Rt = 0,
then Et is ﬁxed to a special value ø.

The values of these random variables for our run-
ning example are shown in Figure 2.

In addition to using symbolic variables to en-
code mentions and coreference relationships, we
maintain a vector representation of each entity that
evolves over time. For the ith entity, let ei,t be
its representation at time t. These vectors are
different from word vectors (xt), in that they are
not parameters of the model. They are similar to
history representations (ht), in that they are de-
rived through parameterized functions of the ran-
dom variables’ values, which we will describe in
the next subsections.

2.2 Generative story

The generative story for the word (and other
variables) at timestep t is as follows; forward-
referenced equations are in the detailed discussion
that follows.

1. If ℓt−1 = 1 (i.e., xt is not continuing an

already-started entity mention):

• Choose rt (Equation 3).
• If rt = 0, set ℓt = 1 and et = ø; then go

to step 3. Otherwise:

– If there is no embedding for the
new candidate entity with index
1 + maxt′<t et′, create one follow-
ing §2.4.

– Select the entity et from {1, . . . , 1 +

maxt′<t et′ } (Equation 4).

– Set ecurrent = eet,t−1, which is
the entity embedding of et before
timestep t.

– Select the length of the mention, ℓt

(Equation 5).

2. Otherwise,

• Set ℓt = ℓt−1 − 1, rt = rt−1, et = et−1.

X1:12:
R1:12:
E1:12:
L1:12:

1
1
1

John wanted

0
ø
1

to
0
ø
1

go
0
ø
1
X13:22: He was
R13:22:
0
E13:22:
ø
L13:22:
1

1
1
1

in
0
ø
1

to
0
ø
1
told
0
ø
1

the
1
2
3
that
0
ø
1

coffee
1
2
2
it
1
2
1

shop
1
2
1
sold
0
ø
1

the
1
4
3

downtown
1
3
2
beans
1
4
1

best
1
4
2

.
.
ø
0

Copenhagen
1
3
1

.
0
ø
1

Figure 2: The random variable values in ENTITYNLM for the running example in Figure 1.

3. Sample xt from the word distribution given
the LSTM hidden state ht−1 and the current
(or most recent) entity embedding ecurrent
(Equation 6). (If rt = 0, then ecurrent still
represents the most recently mentioned en-
tity.)

4. Advance the RNN, i.e., feed it the word vec-

tor xt to compute ht (Equation 2).

5. If rt = 1, update eet,t using eet,t−1 and ht,
then set ecurrent = eet,t. Details of the entity
updating are given in §2.4.

6. For every entity eι ∈ Et \ {et}, set eι,t =
eι,t−1 (i.e., no changes to other entities’ rep-
resentations).

Note that at any given time step t, ecurrent will al-
ways contain the most recent vector representation
of the most recently mentioned entity.

A generative model with a similar hierarchical
structure was used by Haghighi and Klein (2010)
for coreference resolution. Our approach differs
in two important ways.
First, our model de-
ﬁnes a joint distribution over all of the text, not
just the entity mentions. Second, we use repre-
sentation learning rather than Bayesian nonpara-
metrics, allowing natural integration with the lan-
guage model.

2.3 Probability distributions

The generative story above referenced several
parametric distributions deﬁned based on vector
representations of histories and entities. These are
deﬁned as follows.
For r ∈ {0, 1},

p(Rt = r | ht−1) ∝ exp(h⊤

t−1

Wrr),

(3)

where r is the parameterized embedding associ-
ated with r, which paves the way for exploring en-
tity type representations in future work; Wr is a

parameter matrix for the bilinear score for ht−1
and r.

To give the possibility of predicting a new en-
tity, we need an entity embedding beforehand
with index (1 + maxt′<t et′ ), which is randomly
sampled from Equation 7. Then, for every e ∈
{1, . . . , 1 + maxt′<t et′}:

p(Et = e | Rt = 1, ht−1)

∝ exp(h⊤

t−1

Wentity ee,t−1 + w⊤
dist

f (e)),

(4)

where ee,t−1 is the embedding of entity e at time
step t−1 and Wentity is the weight matrix for pre-
dicting entities using their continuous representa-
tions. The score above is normalized over values
{1, . . . , 1 + maxt′<t et′}. f (e) represents a vector
of distance features associated with e and the men-
tions of the existing entities. Hence two informa-
tion sources are used to predict the next entity: (i)
contextual information ht−1, and (ii) distance fea-
tures f (e) from the current mention to the closest
mention from each previously mentioned entity.
f (e) = 0 if e is a new entity. This term can also
be extended to include other surface-form features
for coreference resolution (Martschat and Strube,
2015; Clark and Manning, 2016b).

For the chosen entity et from Equation 4, the
distribution over its mention length is drawn ac-
cording to

p(Lt = ℓ | ht−1, eet,t−1)

∝ exp(W⊤

length,ℓ[ht−1; eet,t−1]),

(5)

where eet,t−1 is the most recent embedding of the
entity et, not updated with ht. The intuition is that
eet,t−1 will help contextual information ht−1 to
select the residual length of entity et. Wlength
is the weight matrix for length prediction, with
ℓmax = 25 rows.

Finally, the probability of a word x as the next
token is jointly modeled by ht−1 and the vector
representation of the most recently mentioned en-

tity ecurrent :

p(Xt = x | ht−1, ecurrent )

∝ CFSM(ht−1 + Weecurrent ),

(6)

the dimensionality of ecurrent .

where We is a transformation matrix to ad-
just
CFSM is
a class factorized softmax function (Goodman,
2001; Baltescu and Blunsom, 2015). It uses a two-
step prediction with predeﬁned word classes in-
stead of direct prediction on the whole vocabulary,
and reduces the time complexity to the log of vo-
cabulary size.

2.4 Dynamic entity representations

Before predicting the entity at step t, we need an
embedding for the new candidate entity with index
e′ = 1 + maxt′<t et′ if it does not exist. The new
embedding is generated randomly, according to a
normal distribution, then projected onto the unit
ball:

u ∼ N (r1, σ2I);
u
kuk2

,

ee′,t−1 =

(7)

where σ = 0.01. The time step t − 1 in ee′,t−1
means the current embedding contains no infor-
mation from step t, although it will be updated
once we have ht and if Et = e′. r1 is the pa-
rameterized embedding for Rt = 1, which will be
jointly optimized with other parameters and is ex-
pected to encode some generic information about
entities. All the initial entity embeddings are cen-
tered on the mean r1, which is used in Equation 3
to determine whether the next token belongs to an
entity mention. Another choice would be to ini-
tialize with a zero vector, although our preliminary
experiments showed this did not work as well as
random initialization in Equation 7.

Assume Rt = 1 and Et = et, which means xt
is part of a mention of entity et. Then, we need
to update eet,t−1 based on the new information we
have from ht. The new embedding eet,t is a con-
vex combination of the old embedding (eet,t−1)
and current LSTM hidden state (ht) with the in-
terpolation (δt) determined dynamically based on
a bilinear function:

Wδeet,t−1);

δt = σ(h⊤
t
u = δteet,t−1 + (1 − δt)ht;
,

eet,t =

u
kuk2

(8)

This updating scheme will be used to update et in
each of all the following ℓt steps. The projection in
the last step keeps the magnitude of the entity em-
bedding ﬁxed, avoiding numeric overﬂow. A simi-
lar updating scheme has been used by Henaff et al.
(2016) for the “memory blocks” in their recurrent
entity network models. The difference is that their
model updates all memory blocks in each time
step. Instead, our updating scheme in Equation 8
only applies to the selected entity et at time step t.

2.5 Training objective

The model is trained to maximize the log of the
joint probability of R, E, L, and X:
ℓ(θ) = log P (R, E, L, X; θ)

log P (Rt, Et, Lt, Xt; θ),

(9)

= X
t

where θ is the collection of all the parameters
in this model. Based on the formulation in §2.3,
Equation 9 can be decomposed as the sum of con-
ditional log-probabilities of each random variable
at each time step.

This objective requires the training data anno-
tated as in Figure 2. We do not assume that these
variables are observed at test time.

3 Implementation Details

is

and

2017)

available

implemented with DyNet
at

Our model
(Neubig et al.,
https://github.com/jiyfeng/entitynlm.
We use AdaGrad (Duchi et al., 2011) with learn-
ing rate λ = 0.1 and ADAM (Kingma and Ba,
learning rate λ = 0.001
2014) with default
as the candidate optimizers of our model. For
the parameters, we use the initialization
all
by Glorot and Bengio
tricks
(2010).
To avoid overﬁtting, we also em-
ploy dropout (Srivastava et al., 2014) with the
candidate rates as {0.2, 0.5}.

recommended

In addition,

there are two tunable hyperpa-
rameters of ENTITYNLM: the size of word em-
beddings and the dimension of LSTM hidden
states. For both of them, we consider the values
{32, 48, 64, 128, 256}. We also experiment with
the option to either use the pretrained GloVe word
embeddings (Pennington et al., 2014) or randomly
initialized word embeddings (then updated during
training). For all experiments, the best conﬁgura-
tion of hyperparameters and optimizers is selected
based on the objective value on the development
data.

4 Evaluation Tasks and Datasets

We evaluate our model in diverse use scenarios:
(i) language modeling, (ii) coreference resolution,
and (iii) entity prediction. The evaluation on lan-
guage modeling shows how the internal entity rep-
resentation, when marginalized out, can improve
the perplexity of language models. The evaluation
on coreference resolution experiment shows how
our new language model can improve a compet-
itive coreference resolution system. Finally, we
employ an entity cloze task to demonstrate the
generative performance of our model in predicting
the next entity given the previous context.

We use two datasets for the three evaluation
tasks. For language modeling and coreference
resolution, we use the English benchmark data
from the CoNLL 2012 shared task on corefer-
ence resolution (Pradhan et al., 2012). We employ
the standard training/development/test split, which
includes 2,802/343/348 documents with roughly
1M/150K/150K tokens, respectively. We follow
the coreference annotation in the CoNLL dataset
to extract entities and ignore the singleton men-
tions in texts.

For entity prediction, we employ the InScript
corpus created by Modi et al. (2017). It consists of
10 scenarios, including grocery shopping, taking a
ﬂight, etc.
It includes 910 crowdsourced simple
narrative texts in total and 18 stories were ignored
due to labeling problems (Modi et al., 2017). On
average, each story has 12.4 sentences, 24.9 en-
tities and 217.2 tokens. Each entity mention is
labeled with its entity index. We use the same
training/development/test split as in (Modi et al.,
2017), which includes 619, 91, 182 texts, respec-
tively.

Data preprocessing

For the CoNLL dataset, we lowercase all tokens
and remove any token that only contains a punctu-
ation symbol unless it is in an entity mention. We
also replace numbers in the documents with the
special token NUM and low-frequency word types
with UNK. The vocabulary size of the CoNLL data
after preprocessing is 10K. For entity mention ex-
traction, in the CoNLL dataset, one entity men-
tion could be embedded in another. For embed-
ded mentions, only the enclosing entity mention
is kept. We use the same preprocessed data for
both language modeling and coreference resolu-
tion evaluation.

For the InScript corpus, we apply similar data
preprocessing to lowercase all tokens, and we re-
place low-frequency word types with UNK. The
vocabulary size after preprocessing is 1K.

5 Experiments

In this section, we present the experimental results
on the three evaluation tasks.

5.1 Language modeling

Task description. The goal of language model-
ing is to compute the marginal probability:

P (X) = X
R,E,L

P (X, R, E, L).

(10)

However, due to the long-range dependency in
recurrent neural networks,
the search space of
R, E, L during inference grows exponentially.
We thus use importance sampling to approxi-
mate the marginal distribution of X. Speciﬁ-
cally, with the samples from a proposal distri-
bution Q(R, E, L|X), the approximated marginal
probability is deﬁned as

P (X) = X
R,E,L

P (X, R, E, L)

Q(R, E, L | X)

= X
R,E,L

P (X, R, E, L)
Q(R, E, L | X)

≈

1
N X

{r(i),e(i),ℓ(i)}∼Q

P (r(i), e(i), ℓ(i), x)
Q(r(i), e(i), ℓ(i) | x)

(11)

A similar idea of using importance sampling for
language modeling evaluation has been used by
Dyer et al. (2016).

For language modeling evaluation, we train our
model on the training set from the CoNLL 2012
dataset with coreference annotation. On the test
data, we treat coreference structure as latent vari-
ables and use importance sampling to approximate
the marginal distribution of X. For each docu-
ment, the model randomly draws N = 100 sam-
ples from the proposal distribution, discussed next.

Proposal distribution. For implementation of
Q, we use a discriminative variant of ENTI-
TYNLM by taking the current word xt for predict-
ing the entity-related variables in the same time
step. Speciﬁcally, in the generative story described
in §2.2, we delete step 3 (words are not gener-
ated, but rather conditioned upon), move step 4

Perplexity

5.2 Coreference reranking

Model

1. 5-gram LM
2. RNNLM
3. ENTITYNLM

138.37
134.79
131.64

Table 1: Language modeling evaluation on the test
sets of the English section in the CoNLL 2012
shared task. As mentioned in §4, the vocabulary
size is 10K. ENTITYNLM does not require any
coreference annotation on the test data.

before step 1, and replace ht−1 with ht in the
steps for predicting entity type Rt, entity Et and
mention length Lt. This model variant provides a
conditional probability Q(Rt, Et, Lt | Xt) at each
timestep.

Baselines. We compare the language modeling
performance with two competitive baselines: 5-
gram language model
implemented in KenLM
(Heaﬁeld et al., 2013) and RNNLM with LSTM
units implemented in DyNet (Neubig et al., 2017).
For RNNLM, we use the same hyperparameters
described in §3 and grid search on the develop-
ment data to ﬁnd the best conﬁguration.

T
T P

Results. The results of ENTITYNLM and the
baselines on both development and test data are
reported in Table 1. For ENTITYNLM, we use the
value of 2− 1
t=1 log P (Xt,Rt,Et,Lt) on the devel-
opment set with coreference annotation to select
the best model conﬁguration and report the best
number. On the test data, we are able to calcu-
late perplexity by marginalizing all other random
variables using Equation 11. To compute the per-
plexity numbers on the test data, our model only
takes account of log probabilities on word predic-
tion. The difference is that coreference informa-
tion is only used for training ENTITYNLM and
not for test. All three models reported in Table 1
share the same vocabulary, therefore the numbers
on the test data are directly comparable. As shown
in Table 1, ENTITYNLM outperforms both the 5-
gram language model and the RNNLM on the test
data. Better performance of ENTITYNLM on lan-
guage modeling can be expected, if we also use the
marginalization method deﬁned in Equation 11 on
the development data to select the best conﬁgura-
tion. However, we plan to use the same experi-
mental setup for all experiments, instead of cus-
tomizing our model for each individual task.

Task description. We show how ENTITYLM,
which allows an efﬁcient computation of the
probability P (R, E, L, X),
can be used as
to improve a com-
a coreference reranker
petitive coreference resolution system due to
Martschat and Strube (2015). This task is analo-
gous to the reranking approach used in machine
translation (Shen et al., 2004). The speciﬁc for-
mulation is as follows:

arg

max
{r(i),e(i),l(i)}∈K

P (r(i), e(i), l(i), x)

(12)

where K is the k-best list for a given document.
In our experiments, k = 100. To the best of our
knowledge, the problem of obtaining k-best out-
puts of a coreference resolution system has not
been studied before.

Approximate k-best decoding. We rerank the
output of a system that predicts an antecedent for
each mention by relying on pairwise scores for
mention pairs. This is the dominant approach
for coreference resolution (Martschat and Strube,
2015; Clark and Manning, 2016a). The predic-
tions induce an antecedent tree, which represents
antecedent decisions for all mentions in the doc-
ument. Coreference chains are obtained by tran-
sitive closure over the antecedent decisions en-
coded in the tree. A mention also can have an
empty mention as antecedent, which denotes that
the mention is non-anaphoric.

For extending Martschat and Strube’s greedy
decoding approach to k-best inference, we can-
not simply take the k highest scoring trees ac-
cording to the sum of edge scores, because dif-
ferent trees may represent the same coreference
chain.
Instead, we use an heuristic that creates
an approximate k-best list on candidate antecedent
trees. The idea is to generate trees from the orig-
inal system output by considering suboptimal an-
tecedent choices that lead to different coreference
chains. For each mention pair (mj, mi), we com-
pute the difference of its score to the score of the
optimal antecedent choice for mj. We then sort
pairs in ascending order according to this differ-
ence and iterate through the list of pairs. For each
pair (mj, mi), we create a tree tj,i by replacing
the antecedent of mj in the original system output
with mi. If this yields a tree that encodes differ-
ent coreference chains from all chains encoded by
trees in the k-best list, we add ti,j to the k-best list.

In the case that we cannot generate a given num-
ber of trees (particularly for a short document with
a large k), we pad the list with the last item added
to the list.

evaluation,

measures. For
we
employ
(Pradhan et al., 2014).

Evaluation
coreference
the
resolution
It
CoNLL scorer
evalua-
used
computes
tion measures MUC (Vilain et al.,
1995),
B3 (Bagga and Baldwin, 1998), and CEAFe (Luo,
2005). We report the F1 score of each evaluation
measure and their average as the CoNLL score.

commonly

three

employed CORT1
Competing systems. We
(Martschat and Strube, 2015) as our baseline
coreference resolution system. Here, we com-
pare with the original
(one best) outputs of
CORT’s latent ranking model, which is the best-
performing model implemented in CORT. We
consider two rerankers based on ENTITYNLM.
The ﬁrst reranking method only uses the log
probability for ENTITYNLM to sort the candidate
list (Equation 12). The second method uses a
linear combination of both log probabilities from
ENTITYNLM and the scores from CORT, where
the coefﬁcients were found via grid search with
the CoNLL score on the development set.

Results. The reranked results on the CoNLL
2012 test set are reported in Table 2. The numbers
of the baseline are higher than the results reported
in Martschat and Strube (2015) since the feature
set of CORT was subsequently extended. Lines 2
and 3 in Table 2 present the reranked best results.
As shown in this table, both reranked results give
more than 1% of CoNLL score improvement on
the test set over CORT, which are signiﬁcant based
on an approximate randomization test2.

Additional experiments also found that increas-
ing k from 100 to 500 had a minor effect. That is
because the diversity of each k-best list is limited
by (i) the number of entity mentions in the docu-
ment, (ii) the performance of the baseline corefer-
ence resolution system, and possibly (iii) the ap-
proximate nature of our k-best inference proce-
dure. We suspect that a stronger baseline system
(such as that of Clark and Manning, 2016a) could
give greater improvements, if it can be adapted to
provide k-best lists. Future work might incorpo-

1https://github.com/smartschat/cort, we

used version 0.2.4.5.

2https://github.com/smartschat/art

[I]1 was about to ride [my]1 [bicycle]2 to the
[park]3 one day when [I]1 noticed that the front
[tire]4 was ﬂat . [I]1 realized that [I]1 would
have to repair [it]4 .
[I]1 went into [my]1
[garage]5 to get some [tools]5 . The ﬁrst thing
[I]1 did was remove the xxxx

Figure 3: A short story on bicycles from the
InScript corpus (Modi et al., 2017). The entity
prediction task requires predicting xxxx given
the preceding text either by choosing a previously
mentioned entity or deciding that this is a “new en-
tity”. In this example, the ground-truth prediction
is [tire]4. For training, ENTITYNLM attempts to
predict every entity. While, for testing, it predicts
a maximum of 30 entities after the ﬁrst three sen-
tences, which is consistent with the experimental
setup suggested by Modi et al. (2017).

rate the techniques embedded in such systems into
ENTITYNLM.

5.3 Entity prediction

Task description. Based on Modi et al. (2017),
we introduce a novel entity prediction task that
tries to predict the next entity given the preced-
ing text. For a given text as in Figure 3, this task
makes a forward prediction based on only the left
context. This is different from coreference reso-
lution, where both left and right contexts from a
It is
given entity mention are used in decoding.
also different from language modeling, since this
task only requires predicting entities. Since EN-
TITYNLM is generative, it can be directly applied
to this task. To predict entities in test data, Rt is
always given and ENTITYNLM only needs to pre-
dict Et when Rt = 1.

Baselines and human prediction. We intro-
duce two baselines in this task: (i) the always-new
baseline that always predicts “new entity”; (ii) a
linear classiﬁcation model using shallow features
from Modi et al. (2017), including the recency of
an entity’s last mention and the frequency. We also
compare with the model proposed by Modi et al.
(2017). Their work assumes that the model has
prior knowledge of all the participant types, which
are speciﬁc to each scenario and ﬁne-grained, e.g.,
rider in the bicycle narrative, and predicts partic-
ipant types for new entities. This assumption is
unrealistic for pure generative models like ours.
Therefore, we remove this assumption and adapt

Model

CoNLL

1. Baseline: CORT’s one best
2. Rerank: ENTITYNLM
3. Rerank: ENTITYNLM + CORT

62.93
64.00
64.04

MUC
P

77.15
77.90
77.93

R

68.67
69.45
69.49

F1

72.66
73.44
73.47

B3
P

66.00
66.84
67.08

R

54.92
56.12
55.99

F1

59.95
61.01
61.04

CEAFe
P

R

60.07
61.73
61.76

52.76
53.90
53.98

F1

56.18
57.55
57.61

Table 2: Coreference resolution scores on the CoNLL 2012 test set. CORT is the best-performing model
of Martschat and Strube (2015) with greedy decoding.

1. Baseline: always-new
2. Baseline: shallow features
3. Modi et al. (2017)
4. ENTITYNLM
5. Human prediction

Accuracy (%)

31.08
45.34
62.65
74.23
77.35

Table 3: Entity prediction accuracy on the test set
of the InScript corpus.

their prediction results to our formulation by map-
ping all the predicted entities that have not been
mentioned to “new entity”. We also compare to
the adapted human prediction used in the In-
Script corpus. For each entity slot, Modi et al.
(2017) acquired 20 human predictions, and the
majority vote was selected. More details about
human predictions are discussed in (Modi et al.,
2017).

Results. Table 3 shows the prediction accura-
cies. ENTITYNLM (line 4) signiﬁcantly outper-
forms both baselines (line 1 and 2) and prior work
(line 3) (p ≪ 0.01, paired t-test). The compari-
son between line 4 and 5 shows our model is even
close to the human prediction performance.

6 Related Work

Rich-context language models. The originally
proposed recurrent neural network language mod-
els only capture information within sentences.
To extend the capacity of RNNLMs, various re-
searchers have incorporated information beyond
sentence boundaries.
Previous work focuses
on contextual
information from previous sen-
tences (Ji et al., 2016a) or discourse relations be-
tween adjacent sentences (Ji et al., 2016b), show-
ing improvements to language modeling and re-
lated tasks like coherence evaluation and discourse
relation prediction.
In this work, ENTITYNLM
adds explicit entity information to the language
model, which is another way of adding a memory
network for language modeling. Unlike the work

by Tran et al. (2016), where memory blocks are
used to store general contextual information for
language modeling, ENTITYNLM assigns each
memory block speciﬁcally to only one entity.

Entity-related models. Two recent approaches
to modeling entities in text are closely related
to our model. The ﬁrst is the “reference-aware”
language models proposed by Yang et al. (2016),
where the referred entities are from either a pre-
deﬁned item list, an external database, or the con-
text from the same document. Yang et al. (2016)
present three models, one for each case. For mod-
eling a document with entities, they use corefer-
ence links to recover entity clusters, though they
only model entity mentions as containing a single
word (an inappropriate assumption, in our view).
Their entity updating method takes the latest hid-
den state (similar to ht when Rt = 1 in our model)
as the new representation of the current entity; no
long-term history of the entity is maintained, just
the current local context.
In addition, their lan-
guage model evaluation assumes that entity infor-
mation is provided at test time (Yang, personal
communication), which makes a direct compari-
son with our model impossible. Our entity updat-
ing scheme is similar to the “dynamic memory”
method used by Henaff et al. (2016). Our entity
representations are dynamically allocated and up-
dated only when an entity appears up, while the
EntNet from Henaff et al. (2016) does not model
entities and their relationships explicitly. In their
model, entity memory blocks are pre-allocated
and updated simultaneously in each timestep. So
there is no dedicated memory block for every en-
tity and no distinction between entity mentions
and non-mention words. As a consequence, it is
not clear how to use their model for coreference
reranking and entity prediction.

Coreference resolution. The hierarchical struc-
ture of our entity generation model is inspired by
Haghighi and Klein (2010). They implemented
this idea as a probabillistic graphical model with

the distance-dependent Chinese Restaurant Pro-
cess (Pitman, 1995) for entity assignment, while
our model is built on a recurrent neural network
architecture. The reranking method considered in
our coreference resolution evaluation could also
be extended with samples from additional corefer-
ence resolution systems, to produce more variety
(Ng, 2005). The beneﬁt of such a system comes,
we believe, from the explicit tracking of each en-
tity throughout the text, providing entity-speciﬁc
representations. In previous work, such informa-
tion has been added as features (Luo et al., 2004;
Bj¨orkelund and Kuhn, 2014) or by computing
distributed entity representations (Wiseman et al.,
2016; Clark and Manning, 2016b). Our approach
complements these previous methods.

Entity prediction. The entity prediction task
discussed in §5.3 is based on work by Modi et al.
The main difference is that we do
(2017).
not assume that all entities belong to a previ-
ously known set of entity types speciﬁed for
each narrative scenario.
This task is also
closely related to the “narrative cloze” task of
Chambers and Jurafsky (2008) and the “story
cloze test” of Mostafazadeh et al. (2016). Those
studies aim to understand relationships between
events, while our task focuses on predicting up-
coming entity mentions.

7 Conclusion

We have presented a neural language model, EN-
TITYNLM, that deﬁnes a distribution over texts
and the mentioned entities. It provides vector rep-
resentations for the entities and updates them dy-
namically in context. The dynamic representations
are further used to help generate speciﬁc entity
mentions and the following text. This model out-
performs strong baselines and prior work on three
tasks: language modeling, coreference resolution,
and entity prediction.

Acknowledgments

We thank anonymous reviewers for the helpful
feedback on this work. We also thank the members
of Noah’s ARK and XLab at University of Wash-
ington for their valuable comments, particularly
Eunsol Choi for pointing out the InScript corpus.
This research was supported in part by a Univer-
sity of Washington Innovation Award, Samsung
GRO, NSF grant IIS-1524371, the DARPA CwC

program through ARO (W911NF-15-1-0543), and
gifts by Google and Facebook.

References

Amit Bagga and Breck Baldwin. 1998. Algorithms for
scoring coreference chains. In LREC Workshop on
Linguistic Coreference.

Paul Baltescu and Phil Blunsom. 2015. Pragmatic neu-
ral language modelling in machine translation.
In
NAACL.

Anders Bj¨orkelund and Jonas Kuhn. 2014. Learn-
ing structured perceptrons for coreference resolution
with latent antecedents and non-local features.
In
ACL.

Nathanael Chambers and Daniel Jurafsky. 2008. Un-
supervised Learning of Narrative Event Chains. In
ACL.

Kevin Clark and Christopher D. Manning. 2016a.
Deep reinforcement learning for mention-ranking
coreference models. In EMNLP.

Kevin Clark and Christopher D. Manning. 2016b. Im-
proving coreference resolution by learning entity-
level distributed representations. In ACL.

John Duchi, Elad Hazan, and Yoram Singer. 2011.
Adaptive subgradient methods for online learning
Journal of Machine
and stochastic optimization.
Learning Research, 12:2121–2159.

Chris Dyer, Adhiguna Kuncoro, Miguel Ballesteros,
and Noah A. Smith. 2016. Recurrent neural network
grammars. In EMNLP.

Xavier Glorot and Yoshua Bengio. 2010. Understand-
ing the difﬁculty of training deep feedforward neural
networks. In AISTATS, pages 249–256.

Joshua Goodman. 2001. Classes for fast maximum en-

tropy training. In ICASSP.

Aria Haghighi and Dan Klein. 2010. Coreference res-
olution in a modular, entity-centered model.
In
NAACL.

Kenneth Heaﬁeld,

Ivan Pouzyrevsky, Jonathan H.
Clark, and Philipp Koehn. 2013. Scalable modiﬁed
Kneser-Ney language model estimation. In ACL.

Mikael Henaff, Jason Weston, Arthur Szlam, An-
toine Bordes, and Yann LeCun. 2016.
Track-
ing the world state with recurrent entity networks.
arXiv:1612.03969.

Sepp Hochreiter and J¨urgen Schmidhuber. 1997.
Long short-term memory. Neural Computation,
9(8):1735–1780.

Yangfeng Ji, Trevor Cohn, Lingpeng Kong, Chris Dyer,
and Jacob Eisenstein. 2016a. Document context lan-
guage models. In ICLR (workshop track).

Libin Shen, Anoop Sarkar, and Franz Josef Och. 2004.
Discriminative reranking for machine translation. In
NAACL.

Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky,
Ilya Sutskever, and Ruslan Salakhutdinov. 2014.
Dropout: A simple way to prevent neural networks
from overﬁtting. Journal of Machine Learning Re-
search, 15(1):1929–1958.

Ke Tran, Arianna Bisazza, and Christof Monz. 2016.
Recurrent memory networks for language modeling.
In NAACL-HLT.

Marc Vilain, John Burger, John Aberdeen, Dennis Con-
nolly, and Lynette Hirschman. 1995. A model-
theoretic coreference scoring scheme. In MUC.

Sam Wiseman, Alexander M. Rush, and Stuart M.
Shieber. 2016. Learning global features for coref-
erence resolution. In NAACL.

Zichao Yang, Phil Blunsom, Chris Dyer, and Wang
Ling. 2016. Reference-aware language models.
arXiv:1611.01628.

Wojciech Zaremba, Ilya Sutskever, and Oriol Vinyals.
Recurrent neural network regularization.

2015.
ICLR.

Yangfeng Ji, Gholamreza Haffari, and Jacob Eisen-
stein. 2016b. A latent variable recurrent neural
network for discourse-driven language models.
In
NAACL-HLT.

Diederik Kingma and Jimmy Ba. 2014.
for

stochastic

Adam:
optimization.

method
A
arXiv:1412.6980.

Xiaoqiang Luo. 2005. On coreference resolution per-

formance metrics. In HLT-EMNLP.

Xiaoqiang Luo, Abe Ittycheriah, Hongyan Jing, Nanda
Kambhatla, and Salim Roukos. 2004. A mention-
synchronous coreference resolution algorithm based
on the Bell tree. In ACL.

Sebastian Martschat and Michael Strube. 2015. La-
tent structures for coreference resolution. Transac-
tions of the Association for Computational Linguis-
tics, 3:405–418.

Tomas Mikolov, Martin Karaﬁ´at, Lukas Burget, Jan
Cernock`y, and Sanjeev Khudanpur. 2010. Recur-
rent neural network based language model. In IN-
TERSPEECH.

Ashutosh Modi, Ivan Titov, Vera Demberg, Asad Say-
eed, and Manfred Pinkal. 2017. Modeling seman-
tic expectation: Using script knowledge for referent
prediction. Transactions of the Association of Com-
putational Linguistics, 5:31–44.

Nasrin Mostafazadeh, Nathanael Chambers, Xiaodong
He, Devi Parikh, Dhruv Batra, Lucy Vanderwende,
Pushmeet Kohli, and James Allen. 2016. A corpus
and evaluation framework for deeper understanding
of commonsense stories. In NAACL.

Graham Neubig, Chris Dyer, Yoav Goldberg, Austin
Matthews, Waleed Ammar, Antonios Anastasopou-
los, Miguel Ballesteros, David Chiang, Daniel
Clothiaux, Trevor Cohn, et al. 2017. Dynet: The
dynamic neural network toolkit. arXiv:1701.03980.

Vincent Ng. 2005. Machine learning for coreference
resolution: From local classiﬁcation to global rank-
ing. In ACL.

Jeffrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. Glove: Global vectors for
word representation. In EMNLP.

Jim Pitman. 1995. Exchangeable and partially ex-
changeable random partitions. Probability Theory
and Related Fields, 102(2):145–158.

Sameer Pradhan, Xiaoqiang Luo, Marta Recasens, Ed-
uard Hovy, Vincent Ng, and Michael Strube. 2014.
Scoring coreference partitions of predicted men-
tions: A reference implementation. In ACL.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Olga Uryupina, and Yuchen Zhang. 2012. CoNLL-
2012 shared task: Modeling multilingual unre-
In EMNLP-
stricted coreference in OntoNotes.
CoNLL.

7
1
0
2
 
g
u
A
 
2
 
 
]
L
C
.
s
c
[
 
 
1
v
1
8
7
0
0
.
8
0
7
1
:
v
i
X
r
a

Dynamic Entity Representations in Neural Language Models

Yangfeng Ji∗ Chenhao Tan∗ Sebastian Martschat† Yejin Choi∗ Noah A. Smith∗
∗Paul G. Allen School of Computer Science & Engineering, University of Washington
†Department of Computational Linguistics, Heidelberg University
{yangfeng,chenhao,yejin,nasmith}@cs.washington.edu
martschat@cl.uni-heidelberg.de

Abstract

Understanding a long document requires
tracking how entities are introduced and
evolve over time. We present a new type of
language model, ENTITYNLM, that can
explicitly model entities, dynamically up-
date their representations, and contextu-
ally generate their mentions. Our model is
generative and ﬂexible; it can model an ar-
bitrary number of entities in context while
generating each entity mention at an arbi-
trary length.
In addition, it can be used
for several different tasks such as language
modeling, coreference resolution, and en-
tity prediction. Experimental results with
all these tasks demonstrate that our model
consistently outperforms strong baselines
and prior work.

1 Introduction

Understanding a narrative requires keeping track
of its participants over a long-term context. As a
story unfolds, the information a reader associates
with each character in a story increases, and ex-
pectations about what will happen next change ac-
cordingly. At present, models of natural language
do not explicitly track entities; indeed, in today’s
language models, entities are no more than the
words used to mention them.

In this paper, we endow a generative language
model with the ability to build up a dynamic rep-
resentation of each entity mentioned in the text.
Our language model deﬁnes a probability distribu-
tion over the whole text, with a distinct generative
story for entity mentions. It explicitly groups those
mentions that corefer and associates with each en-
tity a continuous representation that is updated by
every contextualized mention of the entity, and
that in turn affects the text that follows.

[John]1 wanted to go to [the coffee shop]2 in
[downtown Copenhagen]3. [He]1 was told that
[it]2 sold [the best beans]4.

Figure 1: ENTITYNLM explicitly tracks entities
in a text, including coreferring relationships be-
tween entities like [John]1 and [He]1. As a lan-
guage model, it is designed to predict that a coref-
erent of [the coffee shop]2 is likely to follow “told
that,” that the referring expression will be “it”, and
that “sold the best beans” is likely to come next, by
using entity information encoded in the dynamic
distributed representation.

Because our model

Our method builds on recent advances in repre-
sentation learning, creating local probability dis-
tributions from neural networks.
It can be un-
derstood as a recurrent neural network language
model, augmented with random variables for en-
tity mentions that capture coreference, and with
dynamic representations of entities. We estimate
the model’s parameters from data that is annotated
with entity mentions and coreference.
is generative,

it can be
queried in different ways. Marginalizing every-
thing except the words, it can play the role of a lan-
guage model. In §5.1, we ﬁnd that it outperforms
both a strong n-gram language model and a strong
recurrent neural network language model on the
English test set of the CoNLL 2012 shared task
on coreference evaluation (Pradhan et al., 2012).
The model can also identify entity mentions and
In §5.2,
coreference relationships among them.
we show that it can easily be used to add a per-
formance boost to a strong coreference resolution
system, by reranking a list of k-best candidate out-
puts. On the CoNLL 2012 shared task test set, the
reranked outputs are signiﬁcantly better than the
original top choices from the same system. Fi-

nally, the model can perform entity cloze tasks.
As presented in §5.3, it achieves state-of-the-art
performance on the InScript corpus (Modi et al.,
2017).

2 Model

A language model deﬁnes a distribution over se-
quences of word tokens; let Xt denote the random
variable for the tth word in the sequence, xt de-
note the value of Xt and xt the distributed repre-
sentation (embedding) of this word. Our starting
point for language modeling is a recurrent neural
network (Mikolov et al., 2010), which deﬁnes

p(Xt | history) = softmax (Whht−1 + b)

ht−1 = LSTM(ht−2, xt−1)

(1)

(2)

the widely used recurrent

and b are parameters of
where Wh
the
(along with word embeddings xt),
model
func-
LSTM is
“long short-term memory”
tion known as
(Hochreiter and Schmidhuber, 1997), and ht
is
a LSTM hidden state encoding the history of the
sequence up to the tth word.

Great success has been reported for this model
(Zaremba et al., 2015), which posits nothing ex-
plicitly about the words appearing in the text se-
quence. Its generative story is simple: the value
of each Xt is randomly chosen conditioned on the
vector ht−1 encoding its history.

2.1 Additional random variables and
representations for entities

To introduce our model, we associate with each
word an additional set of random variables. At po-
sition t,

• Rt is a binary random variable that indi-
cates whether xt belongs to an entity men-
tion (Rt = 1) or not (Rt = 0). Though not
explored here, this is easily generalized to a
categorial variable for the type of the entity
(e.g., person, organization, etc.).

• Lt ∈ {1, . . . , ℓmax } is a categorical random
variable if Rt = 1, which indicates the num-
ber of remaining words in this mention, in-
cluding the current word (i.e., Lt = 1 for
ℓmax is a
the last word in any mention).
predeﬁned maximum length ﬁxed to be 25,
which is an empirical value derived from the
training corpora used in the experiments. If

Rt = 0, then Lt = 1. We denote the value of
Lt by ℓt.

• Et ∈ Et is the index of the entity referred to,
if Rt = 1. The set Et consists of {1, . . . , 1 +
maxt′<t et′ }, i.e., the indices of all previously
mentioned entities plus an additional value
for a new entity. Thus Et starts as {1} and
grows monotonically with t, allowing for an
arbitrary number of entities to be mentioned.
We denote the value of Et by et. If Rt = 0,
then Et is ﬁxed to a special value ø.

The values of these random variables for our run-
ning example are shown in Figure 2.

In addition to using symbolic variables to en-
code mentions and coreference relationships, we
maintain a vector representation of each entity that
evolves over time. For the ith entity, let ei,t be
its representation at time t. These vectors are
different from word vectors (xt), in that they are
not parameters of the model. They are similar to
history representations (ht), in that they are de-
rived through parameterized functions of the ran-
dom variables’ values, which we will describe in
the next subsections.

2.2 Generative story

The generative story for the word (and other
variables) at timestep t is as follows; forward-
referenced equations are in the detailed discussion
that follows.

1. If ℓt−1 = 1 (i.e., xt is not continuing an

already-started entity mention):

• Choose rt (Equation 3).
• If rt = 0, set ℓt = 1 and et = ø; then go

to step 3. Otherwise:

– If there is no embedding for the
new candidate entity with index
1 + maxt′<t et′, create one follow-
ing §2.4.

– Select the entity et from {1, . . . , 1 +

maxt′<t et′ } (Equation 4).

– Set ecurrent = eet,t−1, which is
the entity embedding of et before
timestep t.

– Select the length of the mention, ℓt

(Equation 5).

2. Otherwise,

• Set ℓt = ℓt−1 − 1, rt = rt−1, et = et−1.

X1:12:
R1:12:
E1:12:
L1:12:

1
1
1

John wanted

0
ø
1

to
0
ø
1

go
0
ø
1
X13:22: He was
R13:22:
0
E13:22:
ø
L13:22:
1

1
1
1

in
0
ø
1

to
0
ø
1
told
0
ø
1

the
1
2
3
that
0
ø
1

coffee
1
2
2
it
1
2
1

shop
1
2
1
sold
0
ø
1

the
1
4
3

downtown
1
3
2
beans
1
4
1

best
1
4
2

.
.
ø
0

Copenhagen
1
3
1

.
0
ø
1

Figure 2: The random variable values in ENTITYNLM for the running example in Figure 1.

3. Sample xt from the word distribution given
the LSTM hidden state ht−1 and the current
(or most recent) entity embedding ecurrent
(Equation 6). (If rt = 0, then ecurrent still
represents the most recently mentioned en-
tity.)

4. Advance the RNN, i.e., feed it the word vec-

tor xt to compute ht (Equation 2).

5. If rt = 1, update eet,t using eet,t−1 and ht,
then set ecurrent = eet,t. Details of the entity
updating are given in §2.4.

6. For every entity eι ∈ Et \ {et}, set eι,t =
eι,t−1 (i.e., no changes to other entities’ rep-
resentations).

Note that at any given time step t, ecurrent will al-
ways contain the most recent vector representation
of the most recently mentioned entity.

A generative model with a similar hierarchical
structure was used by Haghighi and Klein (2010)
for coreference resolution. Our approach differs
in two important ways.
First, our model de-
ﬁnes a joint distribution over all of the text, not
just the entity mentions. Second, we use repre-
sentation learning rather than Bayesian nonpara-
metrics, allowing natural integration with the lan-
guage model.

2.3 Probability distributions

The generative story above referenced several
parametric distributions deﬁned based on vector
representations of histories and entities. These are
deﬁned as follows.
For r ∈ {0, 1},

p(Rt = r | ht−1) ∝ exp(h⊤

t−1

Wrr),

(3)

where r is the parameterized embedding associ-
ated with r, which paves the way for exploring en-
tity type representations in future work; Wr is a

parameter matrix for the bilinear score for ht−1
and r.

To give the possibility of predicting a new en-
tity, we need an entity embedding beforehand
with index (1 + maxt′<t et′ ), which is randomly
sampled from Equation 7. Then, for every e ∈
{1, . . . , 1 + maxt′<t et′}:

p(Et = e | Rt = 1, ht−1)

∝ exp(h⊤

t−1

Wentity ee,t−1 + w⊤
dist

f (e)),

(4)

where ee,t−1 is the embedding of entity e at time
step t−1 and Wentity is the weight matrix for pre-
dicting entities using their continuous representa-
tions. The score above is normalized over values
{1, . . . , 1 + maxt′<t et′}. f (e) represents a vector
of distance features associated with e and the men-
tions of the existing entities. Hence two informa-
tion sources are used to predict the next entity: (i)
contextual information ht−1, and (ii) distance fea-
tures f (e) from the current mention to the closest
mention from each previously mentioned entity.
f (e) = 0 if e is a new entity. This term can also
be extended to include other surface-form features
for coreference resolution (Martschat and Strube,
2015; Clark and Manning, 2016b).

For the chosen entity et from Equation 4, the
distribution over its mention length is drawn ac-
cording to

p(Lt = ℓ | ht−1, eet,t−1)

∝ exp(W⊤

length,ℓ[ht−1; eet,t−1]),

(5)

where eet,t−1 is the most recent embedding of the
entity et, not updated with ht. The intuition is that
eet,t−1 will help contextual information ht−1 to
select the residual length of entity et. Wlength
is the weight matrix for length prediction, with
ℓmax = 25 rows.

Finally, the probability of a word x as the next
token is jointly modeled by ht−1 and the vector
representation of the most recently mentioned en-

tity ecurrent :

p(Xt = x | ht−1, ecurrent )

∝ CFSM(ht−1 + Weecurrent ),

(6)

the dimensionality of ecurrent .

where We is a transformation matrix to ad-
just
CFSM is
a class factorized softmax function (Goodman,
2001; Baltescu and Blunsom, 2015). It uses a two-
step prediction with predeﬁned word classes in-
stead of direct prediction on the whole vocabulary,
and reduces the time complexity to the log of vo-
cabulary size.

2.4 Dynamic entity representations

Before predicting the entity at step t, we need an
embedding for the new candidate entity with index
e′ = 1 + maxt′<t et′ if it does not exist. The new
embedding is generated randomly, according to a
normal distribution, then projected onto the unit
ball:

u ∼ N (r1, σ2I);
u
kuk2

,

ee′,t−1 =

(7)

where σ = 0.01. The time step t − 1 in ee′,t−1
means the current embedding contains no infor-
mation from step t, although it will be updated
once we have ht and if Et = e′. r1 is the pa-
rameterized embedding for Rt = 1, which will be
jointly optimized with other parameters and is ex-
pected to encode some generic information about
entities. All the initial entity embeddings are cen-
tered on the mean r1, which is used in Equation 3
to determine whether the next token belongs to an
entity mention. Another choice would be to ini-
tialize with a zero vector, although our preliminary
experiments showed this did not work as well as
random initialization in Equation 7.

Assume Rt = 1 and Et = et, which means xt
is part of a mention of entity et. Then, we need
to update eet,t−1 based on the new information we
have from ht. The new embedding eet,t is a con-
vex combination of the old embedding (eet,t−1)
and current LSTM hidden state (ht) with the in-
terpolation (δt) determined dynamically based on
a bilinear function:

Wδeet,t−1);

δt = σ(h⊤
t
u = δteet,t−1 + (1 − δt)ht;
,

eet,t =

u
kuk2

(8)

This updating scheme will be used to update et in
each of all the following ℓt steps. The projection in
the last step keeps the magnitude of the entity em-
bedding ﬁxed, avoiding numeric overﬂow. A simi-
lar updating scheme has been used by Henaff et al.
(2016) for the “memory blocks” in their recurrent
entity network models. The difference is that their
model updates all memory blocks in each time
step. Instead, our updating scheme in Equation 8
only applies to the selected entity et at time step t.

2.5 Training objective

The model is trained to maximize the log of the
joint probability of R, E, L, and X:
ℓ(θ) = log P (R, E, L, X; θ)

log P (Rt, Et, Lt, Xt; θ),

(9)

= X
t

where θ is the collection of all the parameters
in this model. Based on the formulation in §2.3,
Equation 9 can be decomposed as the sum of con-
ditional log-probabilities of each random variable
at each time step.

This objective requires the training data anno-
tated as in Figure 2. We do not assume that these
variables are observed at test time.

3 Implementation Details

is

and

2017)

available

implemented with DyNet
at

Our model
(Neubig et al.,
https://github.com/jiyfeng/entitynlm.
We use AdaGrad (Duchi et al., 2011) with learn-
ing rate λ = 0.1 and ADAM (Kingma and Ba,
learning rate λ = 0.001
2014) with default
as the candidate optimizers of our model. For
the parameters, we use the initialization
all
by Glorot and Bengio
tricks
(2010).
To avoid overﬁtting, we also em-
ploy dropout (Srivastava et al., 2014) with the
candidate rates as {0.2, 0.5}.

recommended

In addition,

there are two tunable hyperpa-
rameters of ENTITYNLM: the size of word em-
beddings and the dimension of LSTM hidden
states. For both of them, we consider the values
{32, 48, 64, 128, 256}. We also experiment with
the option to either use the pretrained GloVe word
embeddings (Pennington et al., 2014) or randomly
initialized word embeddings (then updated during
training). For all experiments, the best conﬁgura-
tion of hyperparameters and optimizers is selected
based on the objective value on the development
data.

4 Evaluation Tasks and Datasets

We evaluate our model in diverse use scenarios:
(i) language modeling, (ii) coreference resolution,
and (iii) entity prediction. The evaluation on lan-
guage modeling shows how the internal entity rep-
resentation, when marginalized out, can improve
the perplexity of language models. The evaluation
on coreference resolution experiment shows how
our new language model can improve a compet-
itive coreference resolution system. Finally, we
employ an entity cloze task to demonstrate the
generative performance of our model in predicting
the next entity given the previous context.

We use two datasets for the three evaluation
tasks. For language modeling and coreference
resolution, we use the English benchmark data
from the CoNLL 2012 shared task on corefer-
ence resolution (Pradhan et al., 2012). We employ
the standard training/development/test split, which
includes 2,802/343/348 documents with roughly
1M/150K/150K tokens, respectively. We follow
the coreference annotation in the CoNLL dataset
to extract entities and ignore the singleton men-
tions in texts.

For entity prediction, we employ the InScript
corpus created by Modi et al. (2017). It consists of
10 scenarios, including grocery shopping, taking a
ﬂight, etc.
It includes 910 crowdsourced simple
narrative texts in total and 18 stories were ignored
due to labeling problems (Modi et al., 2017). On
average, each story has 12.4 sentences, 24.9 en-
tities and 217.2 tokens. Each entity mention is
labeled with its entity index. We use the same
training/development/test split as in (Modi et al.,
2017), which includes 619, 91, 182 texts, respec-
tively.

Data preprocessing

For the CoNLL dataset, we lowercase all tokens
and remove any token that only contains a punctu-
ation symbol unless it is in an entity mention. We
also replace numbers in the documents with the
special token NUM and low-frequency word types
with UNK. The vocabulary size of the CoNLL data
after preprocessing is 10K. For entity mention ex-
traction, in the CoNLL dataset, one entity men-
tion could be embedded in another. For embed-
ded mentions, only the enclosing entity mention
is kept. We use the same preprocessed data for
both language modeling and coreference resolu-
tion evaluation.

For the InScript corpus, we apply similar data
preprocessing to lowercase all tokens, and we re-
place low-frequency word types with UNK. The
vocabulary size after preprocessing is 1K.

5 Experiments

In this section, we present the experimental results
on the three evaluation tasks.

5.1 Language modeling

Task description. The goal of language model-
ing is to compute the marginal probability:

P (X) = X
R,E,L

P (X, R, E, L).

(10)

However, due to the long-range dependency in
recurrent neural networks,
the search space of
R, E, L during inference grows exponentially.
We thus use importance sampling to approxi-
mate the marginal distribution of X. Speciﬁ-
cally, with the samples from a proposal distri-
bution Q(R, E, L|X), the approximated marginal
probability is deﬁned as

P (X) = X
R,E,L

P (X, R, E, L)

Q(R, E, L | X)

= X
R,E,L

P (X, R, E, L)
Q(R, E, L | X)

≈

1
N X

{r(i),e(i),ℓ(i)}∼Q

P (r(i), e(i), ℓ(i), x)
Q(r(i), e(i), ℓ(i) | x)

(11)

A similar idea of using importance sampling for
language modeling evaluation has been used by
Dyer et al. (2016).

For language modeling evaluation, we train our
model on the training set from the CoNLL 2012
dataset with coreference annotation. On the test
data, we treat coreference structure as latent vari-
ables and use importance sampling to approximate
the marginal distribution of X. For each docu-
ment, the model randomly draws N = 100 sam-
ples from the proposal distribution, discussed next.

Proposal distribution. For implementation of
Q, we use a discriminative variant of ENTI-
TYNLM by taking the current word xt for predict-
ing the entity-related variables in the same time
step. Speciﬁcally, in the generative story described
in §2.2, we delete step 3 (words are not gener-
ated, but rather conditioned upon), move step 4

Perplexity

5.2 Coreference reranking

Model

1. 5-gram LM
2. RNNLM
3. ENTITYNLM

138.37
134.79
131.64

Table 1: Language modeling evaluation on the test
sets of the English section in the CoNLL 2012
shared task. As mentioned in §4, the vocabulary
size is 10K. ENTITYNLM does not require any
coreference annotation on the test data.

before step 1, and replace ht−1 with ht in the
steps for predicting entity type Rt, entity Et and
mention length Lt. This model variant provides a
conditional probability Q(Rt, Et, Lt | Xt) at each
timestep.

Baselines. We compare the language modeling
performance with two competitive baselines: 5-
gram language model
implemented in KenLM
(Heaﬁeld et al., 2013) and RNNLM with LSTM
units implemented in DyNet (Neubig et al., 2017).
For RNNLM, we use the same hyperparameters
described in §3 and grid search on the develop-
ment data to ﬁnd the best conﬁguration.

T
T P

Results. The results of ENTITYNLM and the
baselines on both development and test data are
reported in Table 1. For ENTITYNLM, we use the
value of 2− 1
t=1 log P (Xt,Rt,Et,Lt) on the devel-
opment set with coreference annotation to select
the best model conﬁguration and report the best
number. On the test data, we are able to calcu-
late perplexity by marginalizing all other random
variables using Equation 11. To compute the per-
plexity numbers on the test data, our model only
takes account of log probabilities on word predic-
tion. The difference is that coreference informa-
tion is only used for training ENTITYNLM and
not for test. All three models reported in Table 1
share the same vocabulary, therefore the numbers
on the test data are directly comparable. As shown
in Table 1, ENTITYNLM outperforms both the 5-
gram language model and the RNNLM on the test
data. Better performance of ENTITYNLM on lan-
guage modeling can be expected, if we also use the
marginalization method deﬁned in Equation 11 on
the development data to select the best conﬁgura-
tion. However, we plan to use the same experi-
mental setup for all experiments, instead of cus-
tomizing our model for each individual task.

Task description. We show how ENTITYLM,
which allows an efﬁcient computation of the
probability P (R, E, L, X),
can be used as
to improve a com-
a coreference reranker
petitive coreference resolution system due to
Martschat and Strube (2015). This task is analo-
gous to the reranking approach used in machine
translation (Shen et al., 2004). The speciﬁc for-
mulation is as follows:

arg

max
{r(i),e(i),l(i)}∈K

P (r(i), e(i), l(i), x)

(12)

where K is the k-best list for a given document.
In our experiments, k = 100. To the best of our
knowledge, the problem of obtaining k-best out-
puts of a coreference resolution system has not
been studied before.

Approximate k-best decoding. We rerank the
output of a system that predicts an antecedent for
each mention by relying on pairwise scores for
mention pairs. This is the dominant approach
for coreference resolution (Martschat and Strube,
2015; Clark and Manning, 2016a). The predic-
tions induce an antecedent tree, which represents
antecedent decisions for all mentions in the doc-
ument. Coreference chains are obtained by tran-
sitive closure over the antecedent decisions en-
coded in the tree. A mention also can have an
empty mention as antecedent, which denotes that
the mention is non-anaphoric.

For extending Martschat and Strube’s greedy
decoding approach to k-best inference, we can-
not simply take the k highest scoring trees ac-
cording to the sum of edge scores, because dif-
ferent trees may represent the same coreference
chain.
Instead, we use an heuristic that creates
an approximate k-best list on candidate antecedent
trees. The idea is to generate trees from the orig-
inal system output by considering suboptimal an-
tecedent choices that lead to different coreference
chains. For each mention pair (mj, mi), we com-
pute the difference of its score to the score of the
optimal antecedent choice for mj. We then sort
pairs in ascending order according to this differ-
ence and iterate through the list of pairs. For each
pair (mj, mi), we create a tree tj,i by replacing
the antecedent of mj in the original system output
with mi. If this yields a tree that encodes differ-
ent coreference chains from all chains encoded by
trees in the k-best list, we add ti,j to the k-best list.

In the case that we cannot generate a given num-
ber of trees (particularly for a short document with
a large k), we pad the list with the last item added
to the list.

evaluation,

measures. For
we
employ
(Pradhan et al., 2014).

Evaluation
coreference
the
resolution
It
CoNLL scorer
evalua-
used
computes
tion measures MUC (Vilain et al.,
1995),
B3 (Bagga and Baldwin, 1998), and CEAFe (Luo,
2005). We report the F1 score of each evaluation
measure and their average as the CoNLL score.

commonly

three

employed CORT1
Competing systems. We
(Martschat and Strube, 2015) as our baseline
coreference resolution system. Here, we com-
pare with the original
(one best) outputs of
CORT’s latent ranking model, which is the best-
performing model implemented in CORT. We
consider two rerankers based on ENTITYNLM.
The ﬁrst reranking method only uses the log
probability for ENTITYNLM to sort the candidate
list (Equation 12). The second method uses a
linear combination of both log probabilities from
ENTITYNLM and the scores from CORT, where
the coefﬁcients were found via grid search with
the CoNLL score on the development set.

Results. The reranked results on the CoNLL
2012 test set are reported in Table 2. The numbers
of the baseline are higher than the results reported
in Martschat and Strube (2015) since the feature
set of CORT was subsequently extended. Lines 2
and 3 in Table 2 present the reranked best results.
As shown in this table, both reranked results give
more than 1% of CoNLL score improvement on
the test set over CORT, which are signiﬁcant based
on an approximate randomization test2.

Additional experiments also found that increas-
ing k from 100 to 500 had a minor effect. That is
because the diversity of each k-best list is limited
by (i) the number of entity mentions in the docu-
ment, (ii) the performance of the baseline corefer-
ence resolution system, and possibly (iii) the ap-
proximate nature of our k-best inference proce-
dure. We suspect that a stronger baseline system
(such as that of Clark and Manning, 2016a) could
give greater improvements, if it can be adapted to
provide k-best lists. Future work might incorpo-

1https://github.com/smartschat/cort, we

used version 0.2.4.5.

2https://github.com/smartschat/art

[I]1 was about to ride [my]1 [bicycle]2 to the
[park]3 one day when [I]1 noticed that the front
[tire]4 was ﬂat . [I]1 realized that [I]1 would
have to repair [it]4 .
[I]1 went into [my]1
[garage]5 to get some [tools]5 . The ﬁrst thing
[I]1 did was remove the xxxx

Figure 3: A short story on bicycles from the
InScript corpus (Modi et al., 2017). The entity
prediction task requires predicting xxxx given
the preceding text either by choosing a previously
mentioned entity or deciding that this is a “new en-
tity”. In this example, the ground-truth prediction
is [tire]4. For training, ENTITYNLM attempts to
predict every entity. While, for testing, it predicts
a maximum of 30 entities after the ﬁrst three sen-
tences, which is consistent with the experimental
setup suggested by Modi et al. (2017).

rate the techniques embedded in such systems into
ENTITYNLM.

5.3 Entity prediction

Task description. Based on Modi et al. (2017),
we introduce a novel entity prediction task that
tries to predict the next entity given the preced-
ing text. For a given text as in Figure 3, this task
makes a forward prediction based on only the left
context. This is different from coreference reso-
lution, where both left and right contexts from a
It is
given entity mention are used in decoding.
also different from language modeling, since this
task only requires predicting entities. Since EN-
TITYNLM is generative, it can be directly applied
to this task. To predict entities in test data, Rt is
always given and ENTITYNLM only needs to pre-
dict Et when Rt = 1.

Baselines and human prediction. We intro-
duce two baselines in this task: (i) the always-new
baseline that always predicts “new entity”; (ii) a
linear classiﬁcation model using shallow features
from Modi et al. (2017), including the recency of
an entity’s last mention and the frequency. We also
compare with the model proposed by Modi et al.
(2017). Their work assumes that the model has
prior knowledge of all the participant types, which
are speciﬁc to each scenario and ﬁne-grained, e.g.,
rider in the bicycle narrative, and predicts partic-
ipant types for new entities. This assumption is
unrealistic for pure generative models like ours.
Therefore, we remove this assumption and adapt

Model

CoNLL

1. Baseline: CORT’s one best
2. Rerank: ENTITYNLM
3. Rerank: ENTITYNLM + CORT

62.93
64.00
64.04

MUC
P

77.15
77.90
77.93

R

68.67
69.45
69.49

F1

72.66
73.44
73.47

B3
P

66.00
66.84
67.08

R

54.92
56.12
55.99

F1

59.95
61.01
61.04

CEAFe
P

R

60.07
61.73
61.76

52.76
53.90
53.98

F1

56.18
57.55
57.61

Table 2: Coreference resolution scores on the CoNLL 2012 test set. CORT is the best-performing model
of Martschat and Strube (2015) with greedy decoding.

1. Baseline: always-new
2. Baseline: shallow features
3. Modi et al. (2017)
4. ENTITYNLM
5. Human prediction

Accuracy (%)

31.08
45.34
62.65
74.23
77.35

Table 3: Entity prediction accuracy on the test set
of the InScript corpus.

their prediction results to our formulation by map-
ping all the predicted entities that have not been
mentioned to “new entity”. We also compare to
the adapted human prediction used in the In-
Script corpus. For each entity slot, Modi et al.
(2017) acquired 20 human predictions, and the
majority vote was selected. More details about
human predictions are discussed in (Modi et al.,
2017).

Results. Table 3 shows the prediction accura-
cies. ENTITYNLM (line 4) signiﬁcantly outper-
forms both baselines (line 1 and 2) and prior work
(line 3) (p ≪ 0.01, paired t-test). The compari-
son between line 4 and 5 shows our model is even
close to the human prediction performance.

6 Related Work

Rich-context language models. The originally
proposed recurrent neural network language mod-
els only capture information within sentences.
To extend the capacity of RNNLMs, various re-
searchers have incorporated information beyond
sentence boundaries.
Previous work focuses
on contextual
information from previous sen-
tences (Ji et al., 2016a) or discourse relations be-
tween adjacent sentences (Ji et al., 2016b), show-
ing improvements to language modeling and re-
lated tasks like coherence evaluation and discourse
relation prediction.
In this work, ENTITYNLM
adds explicit entity information to the language
model, which is another way of adding a memory
network for language modeling. Unlike the work

by Tran et al. (2016), where memory blocks are
used to store general contextual information for
language modeling, ENTITYNLM assigns each
memory block speciﬁcally to only one entity.

Entity-related models. Two recent approaches
to modeling entities in text are closely related
to our model. The ﬁrst is the “reference-aware”
language models proposed by Yang et al. (2016),
where the referred entities are from either a pre-
deﬁned item list, an external database, or the con-
text from the same document. Yang et al. (2016)
present three models, one for each case. For mod-
eling a document with entities, they use corefer-
ence links to recover entity clusters, though they
only model entity mentions as containing a single
word (an inappropriate assumption, in our view).
Their entity updating method takes the latest hid-
den state (similar to ht when Rt = 1 in our model)
as the new representation of the current entity; no
long-term history of the entity is maintained, just
the current local context.
In addition, their lan-
guage model evaluation assumes that entity infor-
mation is provided at test time (Yang, personal
communication), which makes a direct compari-
son with our model impossible. Our entity updat-
ing scheme is similar to the “dynamic memory”
method used by Henaff et al. (2016). Our entity
representations are dynamically allocated and up-
dated only when an entity appears up, while the
EntNet from Henaff et al. (2016) does not model
entities and their relationships explicitly. In their
model, entity memory blocks are pre-allocated
and updated simultaneously in each timestep. So
there is no dedicated memory block for every en-
tity and no distinction between entity mentions
and non-mention words. As a consequence, it is
not clear how to use their model for coreference
reranking and entity prediction.

Coreference resolution. The hierarchical struc-
ture of our entity generation model is inspired by
Haghighi and Klein (2010). They implemented
this idea as a probabillistic graphical model with

the distance-dependent Chinese Restaurant Pro-
cess (Pitman, 1995) for entity assignment, while
our model is built on a recurrent neural network
architecture. The reranking method considered in
our coreference resolution evaluation could also
be extended with samples from additional corefer-
ence resolution systems, to produce more variety
(Ng, 2005). The beneﬁt of such a system comes,
we believe, from the explicit tracking of each en-
tity throughout the text, providing entity-speciﬁc
representations. In previous work, such informa-
tion has been added as features (Luo et al., 2004;
Bj¨orkelund and Kuhn, 2014) or by computing
distributed entity representations (Wiseman et al.,
2016; Clark and Manning, 2016b). Our approach
complements these previous methods.

Entity prediction. The entity prediction task
discussed in §5.3 is based on work by Modi et al.
The main difference is that we do
(2017).
not assume that all entities belong to a previ-
ously known set of entity types speciﬁed for
each narrative scenario.
This task is also
closely related to the “narrative cloze” task of
Chambers and Jurafsky (2008) and the “story
cloze test” of Mostafazadeh et al. (2016). Those
studies aim to understand relationships between
events, while our task focuses on predicting up-
coming entity mentions.

7 Conclusion

We have presented a neural language model, EN-
TITYNLM, that deﬁnes a distribution over texts
and the mentioned entities. It provides vector rep-
resentations for the entities and updates them dy-
namically in context. The dynamic representations
are further used to help generate speciﬁc entity
mentions and the following text. This model out-
performs strong baselines and prior work on three
tasks: language modeling, coreference resolution,
and entity prediction.

Acknowledgments

We thank anonymous reviewers for the helpful
feedback on this work. We also thank the members
of Noah’s ARK and XLab at University of Wash-
ington for their valuable comments, particularly
Eunsol Choi for pointing out the InScript corpus.
This research was supported in part by a Univer-
sity of Washington Innovation Award, Samsung
GRO, NSF grant IIS-1524371, the DARPA CwC

program through ARO (W911NF-15-1-0543), and
gifts by Google and Facebook.

References

Amit Bagga and Breck Baldwin. 1998. Algorithms for
scoring coreference chains. In LREC Workshop on
Linguistic Coreference.

Paul Baltescu and Phil Blunsom. 2015. Pragmatic neu-
ral language modelling in machine translation.
In
NAACL.

Anders Bj¨orkelund and Jonas Kuhn. 2014. Learn-
ing structured perceptrons for coreference resolution
with latent antecedents and non-local features.
In
ACL.

Nathanael Chambers and Daniel Jurafsky. 2008. Un-
supervised Learning of Narrative Event Chains. In
ACL.

Kevin Clark and Christopher D. Manning. 2016a.
Deep reinforcement learning for mention-ranking
coreference models. In EMNLP.

Kevin Clark and Christopher D. Manning. 2016b. Im-
proving coreference resolution by learning entity-
level distributed representations. In ACL.

John Duchi, Elad Hazan, and Yoram Singer. 2011.
Adaptive subgradient methods for online learning
Journal of Machine
and stochastic optimization.
Learning Research, 12:2121–2159.

Chris Dyer, Adhiguna Kuncoro, Miguel Ballesteros,
and Noah A. Smith. 2016. Recurrent neural network
grammars. In EMNLP.

Xavier Glorot and Yoshua Bengio. 2010. Understand-
ing the difﬁculty of training deep feedforward neural
networks. In AISTATS, pages 249–256.

Joshua Goodman. 2001. Classes for fast maximum en-

tropy training. In ICASSP.

Aria Haghighi and Dan Klein. 2010. Coreference res-
olution in a modular, entity-centered model.
In
NAACL.

Kenneth Heaﬁeld,

Ivan Pouzyrevsky, Jonathan H.
Clark, and Philipp Koehn. 2013. Scalable modiﬁed
Kneser-Ney language model estimation. In ACL.

Mikael Henaff, Jason Weston, Arthur Szlam, An-
toine Bordes, and Yann LeCun. 2016.
Track-
ing the world state with recurrent entity networks.
arXiv:1612.03969.

Sepp Hochreiter and J¨urgen Schmidhuber. 1997.
Long short-term memory. Neural Computation,
9(8):1735–1780.

Yangfeng Ji, Trevor Cohn, Lingpeng Kong, Chris Dyer,
and Jacob Eisenstein. 2016a. Document context lan-
guage models. In ICLR (workshop track).

Libin Shen, Anoop Sarkar, and Franz Josef Och. 2004.
Discriminative reranking for machine translation. In
NAACL.

Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky,
Ilya Sutskever, and Ruslan Salakhutdinov. 2014.
Dropout: A simple way to prevent neural networks
from overﬁtting. Journal of Machine Learning Re-
search, 15(1):1929–1958.

Ke Tran, Arianna Bisazza, and Christof Monz. 2016.
Recurrent memory networks for language modeling.
In NAACL-HLT.

Marc Vilain, John Burger, John Aberdeen, Dennis Con-
nolly, and Lynette Hirschman. 1995. A model-
theoretic coreference scoring scheme. In MUC.

Sam Wiseman, Alexander M. Rush, and Stuart M.
Shieber. 2016. Learning global features for coref-
erence resolution. In NAACL.

Zichao Yang, Phil Blunsom, Chris Dyer, and Wang
Ling. 2016. Reference-aware language models.
arXiv:1611.01628.

Wojciech Zaremba, Ilya Sutskever, and Oriol Vinyals.
Recurrent neural network regularization.

2015.
ICLR.

Yangfeng Ji, Gholamreza Haffari, and Jacob Eisen-
stein. 2016b. A latent variable recurrent neural
network for discourse-driven language models.
In
NAACL-HLT.

Diederik Kingma and Jimmy Ba. 2014.
for

stochastic

Adam:
optimization.

method
A
arXiv:1412.6980.

Xiaoqiang Luo. 2005. On coreference resolution per-

formance metrics. In HLT-EMNLP.

Xiaoqiang Luo, Abe Ittycheriah, Hongyan Jing, Nanda
Kambhatla, and Salim Roukos. 2004. A mention-
synchronous coreference resolution algorithm based
on the Bell tree. In ACL.

Sebastian Martschat and Michael Strube. 2015. La-
tent structures for coreference resolution. Transac-
tions of the Association for Computational Linguis-
tics, 3:405–418.

Tomas Mikolov, Martin Karaﬁ´at, Lukas Burget, Jan
Cernock`y, and Sanjeev Khudanpur. 2010. Recur-
rent neural network based language model. In IN-
TERSPEECH.

Ashutosh Modi, Ivan Titov, Vera Demberg, Asad Say-
eed, and Manfred Pinkal. 2017. Modeling seman-
tic expectation: Using script knowledge for referent
prediction. Transactions of the Association of Com-
putational Linguistics, 5:31–44.

Nasrin Mostafazadeh, Nathanael Chambers, Xiaodong
He, Devi Parikh, Dhruv Batra, Lucy Vanderwende,
Pushmeet Kohli, and James Allen. 2016. A corpus
and evaluation framework for deeper understanding
of commonsense stories. In NAACL.

Graham Neubig, Chris Dyer, Yoav Goldberg, Austin
Matthews, Waleed Ammar, Antonios Anastasopou-
los, Miguel Ballesteros, David Chiang, Daniel
Clothiaux, Trevor Cohn, et al. 2017. Dynet: The
dynamic neural network toolkit. arXiv:1701.03980.

Vincent Ng. 2005. Machine learning for coreference
resolution: From local classiﬁcation to global rank-
ing. In ACL.

Jeffrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. Glove: Global vectors for
word representation. In EMNLP.

Jim Pitman. 1995. Exchangeable and partially ex-
changeable random partitions. Probability Theory
and Related Fields, 102(2):145–158.

Sameer Pradhan, Xiaoqiang Luo, Marta Recasens, Ed-
uard Hovy, Vincent Ng, and Michael Strube. 2014.
Scoring coreference partitions of predicted men-
tions: A reference implementation. In ACL.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Olga Uryupina, and Yuchen Zhang. 2012. CoNLL-
2012 shared task: Modeling multilingual unre-
In EMNLP-
stricted coreference in OntoNotes.
CoNLL.

7
1
0
2
 
g
u
A
 
2
 
 
]
L
C
.
s
c
[
 
 
1
v
1
8
7
0
0
.
8
0
7
1
:
v
i
X
r
a

Dynamic Entity Representations in Neural Language Models

Yangfeng Ji∗ Chenhao Tan∗ Sebastian Martschat† Yejin Choi∗ Noah A. Smith∗
∗Paul G. Allen School of Computer Science & Engineering, University of Washington
†Department of Computational Linguistics, Heidelberg University
{yangfeng,chenhao,yejin,nasmith}@cs.washington.edu
martschat@cl.uni-heidelberg.de

Abstract

Understanding a long document requires
tracking how entities are introduced and
evolve over time. We present a new type of
language model, ENTITYNLM, that can
explicitly model entities, dynamically up-
date their representations, and contextu-
ally generate their mentions. Our model is
generative and ﬂexible; it can model an ar-
bitrary number of entities in context while
generating each entity mention at an arbi-
trary length.
In addition, it can be used
for several different tasks such as language
modeling, coreference resolution, and en-
tity prediction. Experimental results with
all these tasks demonstrate that our model
consistently outperforms strong baselines
and prior work.

1 Introduction

Understanding a narrative requires keeping track
of its participants over a long-term context. As a
story unfolds, the information a reader associates
with each character in a story increases, and ex-
pectations about what will happen next change ac-
cordingly. At present, models of natural language
do not explicitly track entities; indeed, in today’s
language models, entities are no more than the
words used to mention them.

In this paper, we endow a generative language
model with the ability to build up a dynamic rep-
resentation of each entity mentioned in the text.
Our language model deﬁnes a probability distribu-
tion over the whole text, with a distinct generative
story for entity mentions. It explicitly groups those
mentions that corefer and associates with each en-
tity a continuous representation that is updated by
every contextualized mention of the entity, and
that in turn affects the text that follows.

[John]1 wanted to go to [the coffee shop]2 in
[downtown Copenhagen]3. [He]1 was told that
[it]2 sold [the best beans]4.

Figure 1: ENTITYNLM explicitly tracks entities
in a text, including coreferring relationships be-
tween entities like [John]1 and [He]1. As a lan-
guage model, it is designed to predict that a coref-
erent of [the coffee shop]2 is likely to follow “told
that,” that the referring expression will be “it”, and
that “sold the best beans” is likely to come next, by
using entity information encoded in the dynamic
distributed representation.

Because our model

Our method builds on recent advances in repre-
sentation learning, creating local probability dis-
tributions from neural networks.
It can be un-
derstood as a recurrent neural network language
model, augmented with random variables for en-
tity mentions that capture coreference, and with
dynamic representations of entities. We estimate
the model’s parameters from data that is annotated
with entity mentions and coreference.
is generative,

it can be
queried in different ways. Marginalizing every-
thing except the words, it can play the role of a lan-
guage model. In §5.1, we ﬁnd that it outperforms
both a strong n-gram language model and a strong
recurrent neural network language model on the
English test set of the CoNLL 2012 shared task
on coreference evaluation (Pradhan et al., 2012).
The model can also identify entity mentions and
In §5.2,
coreference relationships among them.
we show that it can easily be used to add a per-
formance boost to a strong coreference resolution
system, by reranking a list of k-best candidate out-
puts. On the CoNLL 2012 shared task test set, the
reranked outputs are signiﬁcantly better than the
original top choices from the same system. Fi-

nally, the model can perform entity cloze tasks.
As presented in §5.3, it achieves state-of-the-art
performance on the InScript corpus (Modi et al.,
2017).

2 Model

A language model deﬁnes a distribution over se-
quences of word tokens; let Xt denote the random
variable for the tth word in the sequence, xt de-
note the value of Xt and xt the distributed repre-
sentation (embedding) of this word. Our starting
point for language modeling is a recurrent neural
network (Mikolov et al., 2010), which deﬁnes

p(Xt | history) = softmax (Whht−1 + b)

ht−1 = LSTM(ht−2, xt−1)

(1)

(2)

the widely used recurrent

and b are parameters of
where Wh
the
(along with word embeddings xt),
model
func-
LSTM is
“long short-term memory”
tion known as
(Hochreiter and Schmidhuber, 1997), and ht
is
a LSTM hidden state encoding the history of the
sequence up to the tth word.

Great success has been reported for this model
(Zaremba et al., 2015), which posits nothing ex-
plicitly about the words appearing in the text se-
quence. Its generative story is simple: the value
of each Xt is randomly chosen conditioned on the
vector ht−1 encoding its history.

2.1 Additional random variables and
representations for entities

To introduce our model, we associate with each
word an additional set of random variables. At po-
sition t,

• Rt is a binary random variable that indi-
cates whether xt belongs to an entity men-
tion (Rt = 1) or not (Rt = 0). Though not
explored here, this is easily generalized to a
categorial variable for the type of the entity
(e.g., person, organization, etc.).

• Lt ∈ {1, . . . , ℓmax } is a categorical random
variable if Rt = 1, which indicates the num-
ber of remaining words in this mention, in-
cluding the current word (i.e., Lt = 1 for
ℓmax is a
the last word in any mention).
predeﬁned maximum length ﬁxed to be 25,
which is an empirical value derived from the
training corpora used in the experiments. If

Rt = 0, then Lt = 1. We denote the value of
Lt by ℓt.

• Et ∈ Et is the index of the entity referred to,
if Rt = 1. The set Et consists of {1, . . . , 1 +
maxt′<t et′ }, i.e., the indices of all previously
mentioned entities plus an additional value
for a new entity. Thus Et starts as {1} and
grows monotonically with t, allowing for an
arbitrary number of entities to be mentioned.
We denote the value of Et by et. If Rt = 0,
then Et is ﬁxed to a special value ø.

The values of these random variables for our run-
ning example are shown in Figure 2.

In addition to using symbolic variables to en-
code mentions and coreference relationships, we
maintain a vector representation of each entity that
evolves over time. For the ith entity, let ei,t be
its representation at time t. These vectors are
different from word vectors (xt), in that they are
not parameters of the model. They are similar to
history representations (ht), in that they are de-
rived through parameterized functions of the ran-
dom variables’ values, which we will describe in
the next subsections.

2.2 Generative story

The generative story for the word (and other
variables) at timestep t is as follows; forward-
referenced equations are in the detailed discussion
that follows.

1. If ℓt−1 = 1 (i.e., xt is not continuing an

already-started entity mention):

• Choose rt (Equation 3).
• If rt = 0, set ℓt = 1 and et = ø; then go

to step 3. Otherwise:

– If there is no embedding for the
new candidate entity with index
1 + maxt′<t et′, create one follow-
ing §2.4.

– Select the entity et from {1, . . . , 1 +

maxt′<t et′ } (Equation 4).

– Set ecurrent = eet,t−1, which is
the entity embedding of et before
timestep t.

– Select the length of the mention, ℓt

(Equation 5).

2. Otherwise,

• Set ℓt = ℓt−1 − 1, rt = rt−1, et = et−1.

X1:12:
R1:12:
E1:12:
L1:12:

1
1
1

John wanted

0
ø
1

to
0
ø
1

go
0
ø
1
X13:22: He was
R13:22:
0
E13:22:
ø
L13:22:
1

1
1
1

in
0
ø
1

to
0
ø
1
told
0
ø
1

the
1
2
3
that
0
ø
1

coffee
1
2
2
it
1
2
1

shop
1
2
1
sold
0
ø
1

the
1
4
3

downtown
1
3
2
beans
1
4
1

best
1
4
2

.
.
ø
0

Copenhagen
1
3
1

.
0
ø
1

Figure 2: The random variable values in ENTITYNLM for the running example in Figure 1.

3. Sample xt from the word distribution given
the LSTM hidden state ht−1 and the current
(or most recent) entity embedding ecurrent
(Equation 6). (If rt = 0, then ecurrent still
represents the most recently mentioned en-
tity.)

4. Advance the RNN, i.e., feed it the word vec-

tor xt to compute ht (Equation 2).

5. If rt = 1, update eet,t using eet,t−1 and ht,
then set ecurrent = eet,t. Details of the entity
updating are given in §2.4.

6. For every entity eι ∈ Et \ {et}, set eι,t =
eι,t−1 (i.e., no changes to other entities’ rep-
resentations).

Note that at any given time step t, ecurrent will al-
ways contain the most recent vector representation
of the most recently mentioned entity.

A generative model with a similar hierarchical
structure was used by Haghighi and Klein (2010)
for coreference resolution. Our approach differs
in two important ways.
First, our model de-
ﬁnes a joint distribution over all of the text, not
just the entity mentions. Second, we use repre-
sentation learning rather than Bayesian nonpara-
metrics, allowing natural integration with the lan-
guage model.

2.3 Probability distributions

The generative story above referenced several
parametric distributions deﬁned based on vector
representations of histories and entities. These are
deﬁned as follows.
For r ∈ {0, 1},

p(Rt = r | ht−1) ∝ exp(h⊤

t−1

Wrr),

(3)

where r is the parameterized embedding associ-
ated with r, which paves the way for exploring en-
tity type representations in future work; Wr is a

parameter matrix for the bilinear score for ht−1
and r.

To give the possibility of predicting a new en-
tity, we need an entity embedding beforehand
with index (1 + maxt′<t et′ ), which is randomly
sampled from Equation 7. Then, for every e ∈
{1, . . . , 1 + maxt′<t et′}:

p(Et = e | Rt = 1, ht−1)

∝ exp(h⊤

t−1

Wentity ee,t−1 + w⊤
dist

f (e)),

(4)

where ee,t−1 is the embedding of entity e at time
step t−1 and Wentity is the weight matrix for pre-
dicting entities using their continuous representa-
tions. The score above is normalized over values
{1, . . . , 1 + maxt′<t et′}. f (e) represents a vector
of distance features associated with e and the men-
tions of the existing entities. Hence two informa-
tion sources are used to predict the next entity: (i)
contextual information ht−1, and (ii) distance fea-
tures f (e) from the current mention to the closest
mention from each previously mentioned entity.
f (e) = 0 if e is a new entity. This term can also
be extended to include other surface-form features
for coreference resolution (Martschat and Strube,
2015; Clark and Manning, 2016b).

For the chosen entity et from Equation 4, the
distribution over its mention length is drawn ac-
cording to

p(Lt = ℓ | ht−1, eet,t−1)

∝ exp(W⊤

length,ℓ[ht−1; eet,t−1]),

(5)

where eet,t−1 is the most recent embedding of the
entity et, not updated with ht. The intuition is that
eet,t−1 will help contextual information ht−1 to
select the residual length of entity et. Wlength
is the weight matrix for length prediction, with
ℓmax = 25 rows.

Finally, the probability of a word x as the next
token is jointly modeled by ht−1 and the vector
representation of the most recently mentioned en-

tity ecurrent :

p(Xt = x | ht−1, ecurrent )

∝ CFSM(ht−1 + Weecurrent ),

(6)

the dimensionality of ecurrent .

where We is a transformation matrix to ad-
just
CFSM is
a class factorized softmax function (Goodman,
2001; Baltescu and Blunsom, 2015). It uses a two-
step prediction with predeﬁned word classes in-
stead of direct prediction on the whole vocabulary,
and reduces the time complexity to the log of vo-
cabulary size.

2.4 Dynamic entity representations

Before predicting the entity at step t, we need an
embedding for the new candidate entity with index
e′ = 1 + maxt′<t et′ if it does not exist. The new
embedding is generated randomly, according to a
normal distribution, then projected onto the unit
ball:

u ∼ N (r1, σ2I);
u
kuk2

,

ee′,t−1 =

(7)

where σ = 0.01. The time step t − 1 in ee′,t−1
means the current embedding contains no infor-
mation from step t, although it will be updated
once we have ht and if Et = e′. r1 is the pa-
rameterized embedding for Rt = 1, which will be
jointly optimized with other parameters and is ex-
pected to encode some generic information about
entities. All the initial entity embeddings are cen-
tered on the mean r1, which is used in Equation 3
to determine whether the next token belongs to an
entity mention. Another choice would be to ini-
tialize with a zero vector, although our preliminary
experiments showed this did not work as well as
random initialization in Equation 7.

Assume Rt = 1 and Et = et, which means xt
is part of a mention of entity et. Then, we need
to update eet,t−1 based on the new information we
have from ht. The new embedding eet,t is a con-
vex combination of the old embedding (eet,t−1)
and current LSTM hidden state (ht) with the in-
terpolation (δt) determined dynamically based on
a bilinear function:

Wδeet,t−1);

δt = σ(h⊤
t
u = δteet,t−1 + (1 − δt)ht;
,

eet,t =

u
kuk2

(8)

This updating scheme will be used to update et in
each of all the following ℓt steps. The projection in
the last step keeps the magnitude of the entity em-
bedding ﬁxed, avoiding numeric overﬂow. A simi-
lar updating scheme has been used by Henaff et al.
(2016) for the “memory blocks” in their recurrent
entity network models. The difference is that their
model updates all memory blocks in each time
step. Instead, our updating scheme in Equation 8
only applies to the selected entity et at time step t.

2.5 Training objective

The model is trained to maximize the log of the
joint probability of R, E, L, and X:
ℓ(θ) = log P (R, E, L, X; θ)

log P (Rt, Et, Lt, Xt; θ),

(9)

= X
t

where θ is the collection of all the parameters
in this model. Based on the formulation in §2.3,
Equation 9 can be decomposed as the sum of con-
ditional log-probabilities of each random variable
at each time step.

This objective requires the training data anno-
tated as in Figure 2. We do not assume that these
variables are observed at test time.

3 Implementation Details

is

and

2017)

available

implemented with DyNet
at

Our model
(Neubig et al.,
https://github.com/jiyfeng/entitynlm.
We use AdaGrad (Duchi et al., 2011) with learn-
ing rate λ = 0.1 and ADAM (Kingma and Ba,
learning rate λ = 0.001
2014) with default
as the candidate optimizers of our model. For
the parameters, we use the initialization
all
by Glorot and Bengio
tricks
(2010).
To avoid overﬁtting, we also em-
ploy dropout (Srivastava et al., 2014) with the
candidate rates as {0.2, 0.5}.

recommended

In addition,

there are two tunable hyperpa-
rameters of ENTITYNLM: the size of word em-
beddings and the dimension of LSTM hidden
states. For both of them, we consider the values
{32, 48, 64, 128, 256}. We also experiment with
the option to either use the pretrained GloVe word
embeddings (Pennington et al., 2014) or randomly
initialized word embeddings (then updated during
training). For all experiments, the best conﬁgura-
tion of hyperparameters and optimizers is selected
based on the objective value on the development
data.

4 Evaluation Tasks and Datasets

We evaluate our model in diverse use scenarios:
(i) language modeling, (ii) coreference resolution,
and (iii) entity prediction. The evaluation on lan-
guage modeling shows how the internal entity rep-
resentation, when marginalized out, can improve
the perplexity of language models. The evaluation
on coreference resolution experiment shows how
our new language model can improve a compet-
itive coreference resolution system. Finally, we
employ an entity cloze task to demonstrate the
generative performance of our model in predicting
the next entity given the previous context.

We use two datasets for the three evaluation
tasks. For language modeling and coreference
resolution, we use the English benchmark data
from the CoNLL 2012 shared task on corefer-
ence resolution (Pradhan et al., 2012). We employ
the standard training/development/test split, which
includes 2,802/343/348 documents with roughly
1M/150K/150K tokens, respectively. We follow
the coreference annotation in the CoNLL dataset
to extract entities and ignore the singleton men-
tions in texts.

For entity prediction, we employ the InScript
corpus created by Modi et al. (2017). It consists of
10 scenarios, including grocery shopping, taking a
ﬂight, etc.
It includes 910 crowdsourced simple
narrative texts in total and 18 stories were ignored
due to labeling problems (Modi et al., 2017). On
average, each story has 12.4 sentences, 24.9 en-
tities and 217.2 tokens. Each entity mention is
labeled with its entity index. We use the same
training/development/test split as in (Modi et al.,
2017), which includes 619, 91, 182 texts, respec-
tively.

Data preprocessing

For the CoNLL dataset, we lowercase all tokens
and remove any token that only contains a punctu-
ation symbol unless it is in an entity mention. We
also replace numbers in the documents with the
special token NUM and low-frequency word types
with UNK. The vocabulary size of the CoNLL data
after preprocessing is 10K. For entity mention ex-
traction, in the CoNLL dataset, one entity men-
tion could be embedded in another. For embed-
ded mentions, only the enclosing entity mention
is kept. We use the same preprocessed data for
both language modeling and coreference resolu-
tion evaluation.

For the InScript corpus, we apply similar data
preprocessing to lowercase all tokens, and we re-
place low-frequency word types with UNK. The
vocabulary size after preprocessing is 1K.

5 Experiments

In this section, we present the experimental results
on the three evaluation tasks.

5.1 Language modeling

Task description. The goal of language model-
ing is to compute the marginal probability:

P (X) = X
R,E,L

P (X, R, E, L).

(10)

However, due to the long-range dependency in
recurrent neural networks,
the search space of
R, E, L during inference grows exponentially.
We thus use importance sampling to approxi-
mate the marginal distribution of X. Speciﬁ-
cally, with the samples from a proposal distri-
bution Q(R, E, L|X), the approximated marginal
probability is deﬁned as

P (X) = X
R,E,L

P (X, R, E, L)

Q(R, E, L | X)

= X
R,E,L

P (X, R, E, L)
Q(R, E, L | X)

≈

1
N X

{r(i),e(i),ℓ(i)}∼Q

P (r(i), e(i), ℓ(i), x)
Q(r(i), e(i), ℓ(i) | x)

(11)

A similar idea of using importance sampling for
language modeling evaluation has been used by
Dyer et al. (2016).

For language modeling evaluation, we train our
model on the training set from the CoNLL 2012
dataset with coreference annotation. On the test
data, we treat coreference structure as latent vari-
ables and use importance sampling to approximate
the marginal distribution of X. For each docu-
ment, the model randomly draws N = 100 sam-
ples from the proposal distribution, discussed next.

Proposal distribution. For implementation of
Q, we use a discriminative variant of ENTI-
TYNLM by taking the current word xt for predict-
ing the entity-related variables in the same time
step. Speciﬁcally, in the generative story described
in §2.2, we delete step 3 (words are not gener-
ated, but rather conditioned upon), move step 4

Perplexity

5.2 Coreference reranking

Model

1. 5-gram LM
2. RNNLM
3. ENTITYNLM

138.37
134.79
131.64

Table 1: Language modeling evaluation on the test
sets of the English section in the CoNLL 2012
shared task. As mentioned in §4, the vocabulary
size is 10K. ENTITYNLM does not require any
coreference annotation on the test data.

before step 1, and replace ht−1 with ht in the
steps for predicting entity type Rt, entity Et and
mention length Lt. This model variant provides a
conditional probability Q(Rt, Et, Lt | Xt) at each
timestep.

Baselines. We compare the language modeling
performance with two competitive baselines: 5-
gram language model
implemented in KenLM
(Heaﬁeld et al., 2013) and RNNLM with LSTM
units implemented in DyNet (Neubig et al., 2017).
For RNNLM, we use the same hyperparameters
described in §3 and grid search on the develop-
ment data to ﬁnd the best conﬁguration.

T
T P

Results. The results of ENTITYNLM and the
baselines on both development and test data are
reported in Table 1. For ENTITYNLM, we use the
value of 2− 1
t=1 log P (Xt,Rt,Et,Lt) on the devel-
opment set with coreference annotation to select
the best model conﬁguration and report the best
number. On the test data, we are able to calcu-
late perplexity by marginalizing all other random
variables using Equation 11. To compute the per-
plexity numbers on the test data, our model only
takes account of log probabilities on word predic-
tion. The difference is that coreference informa-
tion is only used for training ENTITYNLM and
not for test. All three models reported in Table 1
share the same vocabulary, therefore the numbers
on the test data are directly comparable. As shown
in Table 1, ENTITYNLM outperforms both the 5-
gram language model and the RNNLM on the test
data. Better performance of ENTITYNLM on lan-
guage modeling can be expected, if we also use the
marginalization method deﬁned in Equation 11 on
the development data to select the best conﬁgura-
tion. However, we plan to use the same experi-
mental setup for all experiments, instead of cus-
tomizing our model for each individual task.

Task description. We show how ENTITYLM,
which allows an efﬁcient computation of the
probability P (R, E, L, X),
can be used as
to improve a com-
a coreference reranker
petitive coreference resolution system due to
Martschat and Strube (2015). This task is analo-
gous to the reranking approach used in machine
translation (Shen et al., 2004). The speciﬁc for-
mulation is as follows:

arg

max
{r(i),e(i),l(i)}∈K

P (r(i), e(i), l(i), x)

(12)

where K is the k-best list for a given document.
In our experiments, k = 100. To the best of our
knowledge, the problem of obtaining k-best out-
puts of a coreference resolution system has not
been studied before.

Approximate k-best decoding. We rerank the
output of a system that predicts an antecedent for
each mention by relying on pairwise scores for
mention pairs. This is the dominant approach
for coreference resolution (Martschat and Strube,
2015; Clark and Manning, 2016a). The predic-
tions induce an antecedent tree, which represents
antecedent decisions for all mentions in the doc-
ument. Coreference chains are obtained by tran-
sitive closure over the antecedent decisions en-
coded in the tree. A mention also can have an
empty mention as antecedent, which denotes that
the mention is non-anaphoric.

For extending Martschat and Strube’s greedy
decoding approach to k-best inference, we can-
not simply take the k highest scoring trees ac-
cording to the sum of edge scores, because dif-
ferent trees may represent the same coreference
chain.
Instead, we use an heuristic that creates
an approximate k-best list on candidate antecedent
trees. The idea is to generate trees from the orig-
inal system output by considering suboptimal an-
tecedent choices that lead to different coreference
chains. For each mention pair (mj, mi), we com-
pute the difference of its score to the score of the
optimal antecedent choice for mj. We then sort
pairs in ascending order according to this differ-
ence and iterate through the list of pairs. For each
pair (mj, mi), we create a tree tj,i by replacing
the antecedent of mj in the original system output
with mi. If this yields a tree that encodes differ-
ent coreference chains from all chains encoded by
trees in the k-best list, we add ti,j to the k-best list.

In the case that we cannot generate a given num-
ber of trees (particularly for a short document with
a large k), we pad the list with the last item added
to the list.

evaluation,

measures. For
we
employ
(Pradhan et al., 2014).

Evaluation
coreference
the
resolution
It
CoNLL scorer
evalua-
used
computes
tion measures MUC (Vilain et al.,
1995),
B3 (Bagga and Baldwin, 1998), and CEAFe (Luo,
2005). We report the F1 score of each evaluation
measure and their average as the CoNLL score.

commonly

three

employed CORT1
Competing systems. We
(Martschat and Strube, 2015) as our baseline
coreference resolution system. Here, we com-
pare with the original
(one best) outputs of
CORT’s latent ranking model, which is the best-
performing model implemented in CORT. We
consider two rerankers based on ENTITYNLM.
The ﬁrst reranking method only uses the log
probability for ENTITYNLM to sort the candidate
list (Equation 12). The second method uses a
linear combination of both log probabilities from
ENTITYNLM and the scores from CORT, where
the coefﬁcients were found via grid search with
the CoNLL score on the development set.

Results. The reranked results on the CoNLL
2012 test set are reported in Table 2. The numbers
of the baseline are higher than the results reported
in Martschat and Strube (2015) since the feature
set of CORT was subsequently extended. Lines 2
and 3 in Table 2 present the reranked best results.
As shown in this table, both reranked results give
more than 1% of CoNLL score improvement on
the test set over CORT, which are signiﬁcant based
on an approximate randomization test2.

Additional experiments also found that increas-
ing k from 100 to 500 had a minor effect. That is
because the diversity of each k-best list is limited
by (i) the number of entity mentions in the docu-
ment, (ii) the performance of the baseline corefer-
ence resolution system, and possibly (iii) the ap-
proximate nature of our k-best inference proce-
dure. We suspect that a stronger baseline system
(such as that of Clark and Manning, 2016a) could
give greater improvements, if it can be adapted to
provide k-best lists. Future work might incorpo-

1https://github.com/smartschat/cort, we

used version 0.2.4.5.

2https://github.com/smartschat/art

[I]1 was about to ride [my]1 [bicycle]2 to the
[park]3 one day when [I]1 noticed that the front
[tire]4 was ﬂat . [I]1 realized that [I]1 would
have to repair [it]4 .
[I]1 went into [my]1
[garage]5 to get some [tools]5 . The ﬁrst thing
[I]1 did was remove the xxxx

Figure 3: A short story on bicycles from the
InScript corpus (Modi et al., 2017). The entity
prediction task requires predicting xxxx given
the preceding text either by choosing a previously
mentioned entity or deciding that this is a “new en-
tity”. In this example, the ground-truth prediction
is [tire]4. For training, ENTITYNLM attempts to
predict every entity. While, for testing, it predicts
a maximum of 30 entities after the ﬁrst three sen-
tences, which is consistent with the experimental
setup suggested by Modi et al. (2017).

rate the techniques embedded in such systems into
ENTITYNLM.

5.3 Entity prediction

Task description. Based on Modi et al. (2017),
we introduce a novel entity prediction task that
tries to predict the next entity given the preced-
ing text. For a given text as in Figure 3, this task
makes a forward prediction based on only the left
context. This is different from coreference reso-
lution, where both left and right contexts from a
It is
given entity mention are used in decoding.
also different from language modeling, since this
task only requires predicting entities. Since EN-
TITYNLM is generative, it can be directly applied
to this task. To predict entities in test data, Rt is
always given and ENTITYNLM only needs to pre-
dict Et when Rt = 1.

Baselines and human prediction. We intro-
duce two baselines in this task: (i) the always-new
baseline that always predicts “new entity”; (ii) a
linear classiﬁcation model using shallow features
from Modi et al. (2017), including the recency of
an entity’s last mention and the frequency. We also
compare with the model proposed by Modi et al.
(2017). Their work assumes that the model has
prior knowledge of all the participant types, which
are speciﬁc to each scenario and ﬁne-grained, e.g.,
rider in the bicycle narrative, and predicts partic-
ipant types for new entities. This assumption is
unrealistic for pure generative models like ours.
Therefore, we remove this assumption and adapt

Model

CoNLL

1. Baseline: CORT’s one best
2. Rerank: ENTITYNLM
3. Rerank: ENTITYNLM + CORT

62.93
64.00
64.04

MUC
P

77.15
77.90
77.93

R

68.67
69.45
69.49

F1

72.66
73.44
73.47

B3
P

66.00
66.84
67.08

R

54.92
56.12
55.99

F1

59.95
61.01
61.04

CEAFe
P

R

60.07
61.73
61.76

52.76
53.90
53.98

F1

56.18
57.55
57.61

Table 2: Coreference resolution scores on the CoNLL 2012 test set. CORT is the best-performing model
of Martschat and Strube (2015) with greedy decoding.

1. Baseline: always-new
2. Baseline: shallow features
3. Modi et al. (2017)
4. ENTITYNLM
5. Human prediction

Accuracy (%)

31.08
45.34
62.65
74.23
77.35

Table 3: Entity prediction accuracy on the test set
of the InScript corpus.

their prediction results to our formulation by map-
ping all the predicted entities that have not been
mentioned to “new entity”. We also compare to
the adapted human prediction used in the In-
Script corpus. For each entity slot, Modi et al.
(2017) acquired 20 human predictions, and the
majority vote was selected. More details about
human predictions are discussed in (Modi et al.,
2017).

Results. Table 3 shows the prediction accura-
cies. ENTITYNLM (line 4) signiﬁcantly outper-
forms both baselines (line 1 and 2) and prior work
(line 3) (p ≪ 0.01, paired t-test). The compari-
son between line 4 and 5 shows our model is even
close to the human prediction performance.

6 Related Work

Rich-context language models. The originally
proposed recurrent neural network language mod-
els only capture information within sentences.
To extend the capacity of RNNLMs, various re-
searchers have incorporated information beyond
sentence boundaries.
Previous work focuses
on contextual
information from previous sen-
tences (Ji et al., 2016a) or discourse relations be-
tween adjacent sentences (Ji et al., 2016b), show-
ing improvements to language modeling and re-
lated tasks like coherence evaluation and discourse
relation prediction.
In this work, ENTITYNLM
adds explicit entity information to the language
model, which is another way of adding a memory
network for language modeling. Unlike the work

by Tran et al. (2016), where memory blocks are
used to store general contextual information for
language modeling, ENTITYNLM assigns each
memory block speciﬁcally to only one entity.

Entity-related models. Two recent approaches
to modeling entities in text are closely related
to our model. The ﬁrst is the “reference-aware”
language models proposed by Yang et al. (2016),
where the referred entities are from either a pre-
deﬁned item list, an external database, or the con-
text from the same document. Yang et al. (2016)
present three models, one for each case. For mod-
eling a document with entities, they use corefer-
ence links to recover entity clusters, though they
only model entity mentions as containing a single
word (an inappropriate assumption, in our view).
Their entity updating method takes the latest hid-
den state (similar to ht when Rt = 1 in our model)
as the new representation of the current entity; no
long-term history of the entity is maintained, just
the current local context.
In addition, their lan-
guage model evaluation assumes that entity infor-
mation is provided at test time (Yang, personal
communication), which makes a direct compari-
son with our model impossible. Our entity updat-
ing scheme is similar to the “dynamic memory”
method used by Henaff et al. (2016). Our entity
representations are dynamically allocated and up-
dated only when an entity appears up, while the
EntNet from Henaff et al. (2016) does not model
entities and their relationships explicitly. In their
model, entity memory blocks are pre-allocated
and updated simultaneously in each timestep. So
there is no dedicated memory block for every en-
tity and no distinction between entity mentions
and non-mention words. As a consequence, it is
not clear how to use their model for coreference
reranking and entity prediction.

Coreference resolution. The hierarchical struc-
ture of our entity generation model is inspired by
Haghighi and Klein (2010). They implemented
this idea as a probabillistic graphical model with

the distance-dependent Chinese Restaurant Pro-
cess (Pitman, 1995) for entity assignment, while
our model is built on a recurrent neural network
architecture. The reranking method considered in
our coreference resolution evaluation could also
be extended with samples from additional corefer-
ence resolution systems, to produce more variety
(Ng, 2005). The beneﬁt of such a system comes,
we believe, from the explicit tracking of each en-
tity throughout the text, providing entity-speciﬁc
representations. In previous work, such informa-
tion has been added as features (Luo et al., 2004;
Bj¨orkelund and Kuhn, 2014) or by computing
distributed entity representations (Wiseman et al.,
2016; Clark and Manning, 2016b). Our approach
complements these previous methods.

Entity prediction. The entity prediction task
discussed in §5.3 is based on work by Modi et al.
The main difference is that we do
(2017).
not assume that all entities belong to a previ-
ously known set of entity types speciﬁed for
each narrative scenario.
This task is also
closely related to the “narrative cloze” task of
Chambers and Jurafsky (2008) and the “story
cloze test” of Mostafazadeh et al. (2016). Those
studies aim to understand relationships between
events, while our task focuses on predicting up-
coming entity mentions.

7 Conclusion

We have presented a neural language model, EN-
TITYNLM, that deﬁnes a distribution over texts
and the mentioned entities. It provides vector rep-
resentations for the entities and updates them dy-
namically in context. The dynamic representations
are further used to help generate speciﬁc entity
mentions and the following text. This model out-
performs strong baselines and prior work on three
tasks: language modeling, coreference resolution,
and entity prediction.

Acknowledgments

We thank anonymous reviewers for the helpful
feedback on this work. We also thank the members
of Noah’s ARK and XLab at University of Wash-
ington for their valuable comments, particularly
Eunsol Choi for pointing out the InScript corpus.
This research was supported in part by a Univer-
sity of Washington Innovation Award, Samsung
GRO, NSF grant IIS-1524371, the DARPA CwC

program through ARO (W911NF-15-1-0543), and
gifts by Google and Facebook.

References

Amit Bagga and Breck Baldwin. 1998. Algorithms for
scoring coreference chains. In LREC Workshop on
Linguistic Coreference.

Paul Baltescu and Phil Blunsom. 2015. Pragmatic neu-
ral language modelling in machine translation.
In
NAACL.

Anders Bj¨orkelund and Jonas Kuhn. 2014. Learn-
ing structured perceptrons for coreference resolution
with latent antecedents and non-local features.
In
ACL.

Nathanael Chambers and Daniel Jurafsky. 2008. Un-
supervised Learning of Narrative Event Chains. In
ACL.

Kevin Clark and Christopher D. Manning. 2016a.
Deep reinforcement learning for mention-ranking
coreference models. In EMNLP.

Kevin Clark and Christopher D. Manning. 2016b. Im-
proving coreference resolution by learning entity-
level distributed representations. In ACL.

John Duchi, Elad Hazan, and Yoram Singer. 2011.
Adaptive subgradient methods for online learning
Journal of Machine
and stochastic optimization.
Learning Research, 12:2121–2159.

Chris Dyer, Adhiguna Kuncoro, Miguel Ballesteros,
and Noah A. Smith. 2016. Recurrent neural network
grammars. In EMNLP.

Xavier Glorot and Yoshua Bengio. 2010. Understand-
ing the difﬁculty of training deep feedforward neural
networks. In AISTATS, pages 249–256.

Joshua Goodman. 2001. Classes for fast maximum en-

tropy training. In ICASSP.

Aria Haghighi and Dan Klein. 2010. Coreference res-
olution in a modular, entity-centered model.
In
NAACL.

Kenneth Heaﬁeld,

Ivan Pouzyrevsky, Jonathan H.
Clark, and Philipp Koehn. 2013. Scalable modiﬁed
Kneser-Ney language model estimation. In ACL.

Mikael Henaff, Jason Weston, Arthur Szlam, An-
toine Bordes, and Yann LeCun. 2016.
Track-
ing the world state with recurrent entity networks.
arXiv:1612.03969.

Sepp Hochreiter and J¨urgen Schmidhuber. 1997.
Long short-term memory. Neural Computation,
9(8):1735–1780.

Yangfeng Ji, Trevor Cohn, Lingpeng Kong, Chris Dyer,
and Jacob Eisenstein. 2016a. Document context lan-
guage models. In ICLR (workshop track).

Libin Shen, Anoop Sarkar, and Franz Josef Och. 2004.
Discriminative reranking for machine translation. In
NAACL.

Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky,
Ilya Sutskever, and Ruslan Salakhutdinov. 2014.
Dropout: A simple way to prevent neural networks
from overﬁtting. Journal of Machine Learning Re-
search, 15(1):1929–1958.

Ke Tran, Arianna Bisazza, and Christof Monz. 2016.
Recurrent memory networks for language modeling.
In NAACL-HLT.

Marc Vilain, John Burger, John Aberdeen, Dennis Con-
nolly, and Lynette Hirschman. 1995. A model-
theoretic coreference scoring scheme. In MUC.

Sam Wiseman, Alexander M. Rush, and Stuart M.
Shieber. 2016. Learning global features for coref-
erence resolution. In NAACL.

Zichao Yang, Phil Blunsom, Chris Dyer, and Wang
Ling. 2016. Reference-aware language models.
arXiv:1611.01628.

Wojciech Zaremba, Ilya Sutskever, and Oriol Vinyals.
Recurrent neural network regularization.

2015.
ICLR.

Yangfeng Ji, Gholamreza Haffari, and Jacob Eisen-
stein. 2016b. A latent variable recurrent neural
network for discourse-driven language models.
In
NAACL-HLT.

Diederik Kingma and Jimmy Ba. 2014.
for

stochastic

Adam:
optimization.

method
A
arXiv:1412.6980.

Xiaoqiang Luo. 2005. On coreference resolution per-

formance metrics. In HLT-EMNLP.

Xiaoqiang Luo, Abe Ittycheriah, Hongyan Jing, Nanda
Kambhatla, and Salim Roukos. 2004. A mention-
synchronous coreference resolution algorithm based
on the Bell tree. In ACL.

Sebastian Martschat and Michael Strube. 2015. La-
tent structures for coreference resolution. Transac-
tions of the Association for Computational Linguis-
tics, 3:405–418.

Tomas Mikolov, Martin Karaﬁ´at, Lukas Burget, Jan
Cernock`y, and Sanjeev Khudanpur. 2010. Recur-
rent neural network based language model. In IN-
TERSPEECH.

Ashutosh Modi, Ivan Titov, Vera Demberg, Asad Say-
eed, and Manfred Pinkal. 2017. Modeling seman-
tic expectation: Using script knowledge for referent
prediction. Transactions of the Association of Com-
putational Linguistics, 5:31–44.

Nasrin Mostafazadeh, Nathanael Chambers, Xiaodong
He, Devi Parikh, Dhruv Batra, Lucy Vanderwende,
Pushmeet Kohli, and James Allen. 2016. A corpus
and evaluation framework for deeper understanding
of commonsense stories. In NAACL.

Graham Neubig, Chris Dyer, Yoav Goldberg, Austin
Matthews, Waleed Ammar, Antonios Anastasopou-
los, Miguel Ballesteros, David Chiang, Daniel
Clothiaux, Trevor Cohn, et al. 2017. Dynet: The
dynamic neural network toolkit. arXiv:1701.03980.

Vincent Ng. 2005. Machine learning for coreference
resolution: From local classiﬁcation to global rank-
ing. In ACL.

Jeffrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. Glove: Global vectors for
word representation. In EMNLP.

Jim Pitman. 1995. Exchangeable and partially ex-
changeable random partitions. Probability Theory
and Related Fields, 102(2):145–158.

Sameer Pradhan, Xiaoqiang Luo, Marta Recasens, Ed-
uard Hovy, Vincent Ng, and Michael Strube. 2014.
Scoring coreference partitions of predicted men-
tions: A reference implementation. In ACL.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Olga Uryupina, and Yuchen Zhang. 2012. CoNLL-
2012 shared task: Modeling multilingual unre-
In EMNLP-
stricted coreference in OntoNotes.
CoNLL.

