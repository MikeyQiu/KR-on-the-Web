Recurrent Dropout without Memory Loss

Stanislau Semeniuta1 Aliaksei Severyn2 Erhardt Barth1
1Universit¨at zu L¨ubeck, Institut f¨ur Neuro- und Bioinformatik
{stas,barth}@inb.uni-luebeck.de
2Google Research
severyn@google.com

6
1
0
2
 
g
u
A
 
5
 
 
]
L
C
.
s
c
[
 
 
2
v
8
1
1
5
0
.
3
0
6
1
:
v
i
X
r
a

Abstract

This paper presents a novel approach to re-
current neural network (RNN) regulariza-
tion. Differently from the widely adopted
dropout method, which is applied to for-
ward connections of feed-forward archi-
tectures or RNNs, we propose to drop neu-
rons directly in recurrent connections in a
way that does not cause loss of long-term
memory. Our approach is as easy to imple-
ment and apply as the regular feed-forward
dropout and we demonstrate its effective-
ness for Long Short-Term Memory net-
work,
the most popular type of RNN
cells. Our experiments on NLP bench-
marks show consistent improvements even
when combined with conventional feed-
forward dropout.

1 Introduction

Recurrent Neural Networks, LSTMs in particular,
have recently become a popular tool among NLP
researchers for their superior ability to model and
learn from sequential data. These models have
shown state-of-the-art results on various public
benchmarks ranging from sentence classiﬁca-
Irsoy and Cardie, 2014;
tion (Wang et al., 2015;
Liu et al., 2015)
prob-
tagging
language mod-
lems
elling
Zhang et al., 2015),
(Zhang and Lapata, 2014)
text
and
prediction
tasks (Sutskever et al., 2014).

(Dyer et al., 2015)
(Kim et al., 2015;
generation

sequence-to-sequence

various
to

and

Having shown excellent ability to capture and
learn complex linguistic phenomena, RNN ar-
chitectures are prone to overﬁtting.
Among
the most widely used techniques to avoid over-
ﬁtting in neural networks is the dropout regu-
larization (Hinton et al., 2012). Since its intro-

together with the L2
duction it has become,
weight decay,
the standard method for neural
network regularization. While showing signif-
icant improvements when used in feed-forward
architectures, e.g., Convolutional Neural Net-
works (Krizhevsky et al., 2012), the application of
dropout in RNNs has been somewhat limited. In-
deed, so far dropout in RNNs has been applied
in the same fashion as in feed-forward architec-
tures:
it is typically injected in input-to-hidden
and hidden-to-output connections, i.e., along the
input axis, but not between the recurrent connec-
tions (time axis). Given that RNNs are mainly
used to model sequential data with the goal of cap-
turing short- and long-term interactions, it seems
natural to also regularize the recurrent weights.
This observation has led us and other researchers
(Moon et al., 2015; Gal, 2015) to the idea of ap-
to the recurrent connections in
plying dropout
RNNs.

In this paper we propose a novel recurrent
dropout
technique and demonstrate how our
method is superiour to other recurrent dropout
methods recently proposed in (Moon et al., 2015;
Gal, 2015). Additionally, we answer the follow-
ing questions which helps to understand how to
(i) how to apply
best apply recurrent dropout:
the dropout in recurrent connections of the LSTM
architecture in a way that prevents possible cor-
ruption of the long-term memory; (ii) what is
the relationship between our recurrent dropout
and the widely adopted dropout in input-to-hidden
and hidden-to-output connections; (iii) how the
dropout mask in RNNs should be sampled: once
per step or once per sequence. The latter question
of sampling the mask appears to be crucial in some
cases to make the recurrent dropout work and, to
the best of our knowledge, has received very little
attention in the literature. Our work is the ﬁrst one
to provide empirical evaluation of the differences

between these two sampling approaches.

Regarding empirical evaluation, we ﬁrst high-
light the problem of information loss in memory
cells of LSTMs when applying recurrent dropout.
We demonstrate that previous approaches of drop-
ping hidden state vectors cause loss of memory
while our proposed method to use dropout mask in
hidden state update vectors does not suffer from
this problem. We experiment on three widely
adopted NLP tasks: word- and character-level
Language Modeling and Named Entity Recog-
nition. The results demonstrate that our recur-
rent dropout helps to achieve better regulariza-
tion and yields improvements across all the tasks,
even when combined with the conventional feed-
forward dropout. Furthermore, we compare our
dropout scheme with the recently proposed alter-
native recurrent dropout methods and show that
our technique is superior in almost all cases.

2 Related Work

Neural Network models often suffer from overﬁt-
ting, especially when the number of network pa-
rameters is large and the amount of training data is
small. This has led to a lot of research directed to-
wards improving their generalization ability. Be-
low we primarily discuss some of the methods
aimed at improving regularization of RNNs.

Pham et al. (2013) and Zaremba et al. (2014)
have shown that LSTMs can be effectively regu-
larized by using dropout in forward connections.
While this already allows for effective regulariza-
tion of recurrent networks, it is intuitive that intro-
ducing dropout also in the hidden state may force
it to create more robust representations.
Indeed,
Moon et al. (2015) have extended the idea of drop-
ping neurons in forward direction and proposed to
drop cell states as well showing good results on
a Speech Recognition task. Bluche et al. (2015)
carry out a study to ﬁnd where dropout is most
effective, e.g. input-to-hidden or hidden-to-output
connections. The authors conclude that it is more
beneﬁcial to use it once in the correct spot, rather
than to put it everywhere. Bengio et al. (2015)
have proposed an algorithm called scheduled sam-
pling to improve performance of recurrent net-
works on sequence-to-sequence labeling tasks. A
disadvantage of this work is that the scheduled
sampling is speciﬁcally tailored to this kind of
tasks, what makes it impossible to use in, for ex-
ample, sequence-to-label tasks. Gal (2015) uses

insights from variational Bayesian inference to
that
propose a variant of LSTM with dropout
achieves consistent improvements over a baseline
architecture without dropout.

The main contribution of this paper is a new
recurrent dropout technique, which is most use-
ful in gated recurrent architectures such as LSTMs
and GRUs. We demonstrate that applying dropout
to arbitrary vectors in LSTM cells may lead to
loss of memory thus hindering the ability of the
network to encode long-term information.
In
other words, our technique allows for adding a
strong regularizer on the model weights respon-
sible for learning short and long-term dependen-
cies without affecting the ability to capture long-
term relationships, which are especially important
to model when dealing with natural language. Fi-
nally, we compare our method with alternative
recurrent dropout methods recently introduced
in (Moon et al., 2015; Gal, 2015) and demonstrate
that our method allows to achieve better results.

3 Recurrent Dropout

In this section we ﬁrst show how the idea
of feed-forward dropout (Hinton et al., 2012) can
be applied to recurrent connections in vanilla
RNNs. We then introduce our recurrent dropout
method speciﬁcally tailored for gated architec-
tures such as LSTMs and GRUs. We draw par-
allels and contrast our approach with alternative
techniques recently proposed
recurrent dropout
in (Moon et al., 2015; Gal, 2015) showing that our
method is favorable when considering potential
memory loss issues in long short-term architec-
tures.

3.1 Dropout in vanilla RNNs

Vanilla RNNs process the input sequences as fol-
lows:

ht = f (Wh[xt, ht−1] + bh),

(1)

where xt is the input at time step t; ht and ht−1
are hidden vectors that encode the current and
previous states of the network; Wh is parameter
matrix that models input-to-hidden and hidden-to-
hidden (recurrent) connections; b is a vector of
bias terms, and f is the activation function.

As RNNs model sequential data by a fully-
connected layer, dropout can be applied by simply
dropping the previous hidden state of a network.

Speciﬁcally, we modify Equation 1 in the follow-
ing way:

ht = f (Wh[xt, d(ht−1)] + bh),

(2)

where d is the dropout function deﬁned as follows:

d(x) =

mask ∗ x,
(1 − p)x

(

if train phase

otherwise,

(3)

where p is the dropout rate and mask is a vector,
sampled from the Bernoulli distribution with suc-
cess probability 1 − p.

3.2 Dropout in LSTM networks

Memory

Long
Short-Term
net-
(Hochreiter and Schmidhuber, 1997)
works
have introduced the concept of gated inputs in
RNNs, which effectively allow the network to
preserve its memory over a larger number of
time steps during both forward and backward
passes, thus alleviating the problem of vanishing
gradients (Bengio et al., 1994).
it is
expressed with the following equations:

Formally,

it
ft
ot
gt













= 

σ(Wi
σ(Wf
σ(Wo
f (Wg

xt, ht−1
xt, ht−1
xt, ht−1
xt, ht−1

(cid:2)
(cid:2)


(cid:2)

(cid:2)
ct = ft ∗ ct−1 + it ∗ gt

(cid:3)
(cid:3)
(cid:3)
(cid:3)

+ bi)
+ bf )
+ bo)
+ bg)







ht = ot ∗ f (ct),

(4)

(5)

(6)

where it, ft, ot are input, output and forget gates at
step t; gt is the vector of cell updates and ct is the
updated cell vector used to update the hidden state
ht; σ is the sigmoid function and ∗ is the element-
wise multiplication.

Gal (2015) proposes to drop the previous hid-
den state when computing values of gates and up-
dates of the current step, where he samples the
dropout mask once for every sequence:

it
ft
ot
gt





= 

σ(Wi
σ(Wf
σ(Wo
f (Wg

xt, d(ht−1)
xt, d(ht−1)
(cid:3)
xt, d(ht−1)
(cid:3)
xt, d(ht−1)
(cid:3)
(cid:3)

(cid:2)
(cid:2)
(cid:2)
(cid:2)

+ bi)
+ bf )
+ bo)
+ bg)












Moon et al. (2015) propose to apply dropout di-
rectly to the cell values and use per-sequence sam-
pling as well:







(7)

ct = d(ft ∗ ct−1 + it ∗ gt)

(8)

In contrast to dropout techniques proposed by
Gal (2015) and Moon et al. (2015), we propose to
apply dropout to the cell update vector gt as fol-
lows:

ct = ft ∗ ct−1 + it ∗ d(gt)

(9)

Different from methods of (Moon et al., 2015;
Gal, 2015), our approach does not require sam-
pling of the dropout masks once for every train-
ing sequence. On the contrary, as we will show in
Section 4, networks trained with a dropout mask
sampled per-step achieve results that are at least as
good and often better than per-sequence sampling.
Figure 1 shows differences between approaches to
dropout.

The approach of (Gal, 2015) differs from ours
in the overall strategy – they consider network’s
hidden state as input to subnetworks that com-
pute gate values and cell updates and the pur-
pose of dropout
is to regularize these subnet-
works. Our approach considers the architecture
as a whole with the hidden state as its key part
and regularize the whole network. The approach
of (Moon et al., 2015) on the other hand is seem-
ingly similar to ours. In Section 3.2 we argue that
our method is a more principled way to drop re-
current connections in gated architectures.

It should be noted that while being different, the
three discussed dropout schemes are not mutually
exclusive. It is in general possible to combine our
approach and the other two. We expect the merge
of our scheme and that of (Gal, 2015) to hold the
biggest potential. The relations between recurrent
dropout schemes are however out of scope of this
paper and we rather focus on studying the rela-
tionships of different dropout approaches with the
conventional forward dropout.
(GRU) networks are
Gated Recurrent Unit
recur-
a
rent network with hidden state protected by
gates (Cho et al., 2014). Different from LSTMs,
GRU networks use only two gates rt and zt to
update the cell’s hidden state ht:

recently introduced variant of

a

(cid:18)

=

zt
rt(cid:19)
gt = f (Wg

(cid:18)

σ(Wz
σ(Wr

xt, ht−1
xt, ht−1

+ bz)
+ br)

(10)

(cid:19)

+ bg)

(11)

(cid:2)
(cid:2)

(cid:3)
(cid:3)
xt, rt ∗ ht−1

(cid:2)

(cid:3)

ht-1

ct-1

o

*

g

i

*

f

*

+

ht

ct

ht-1

ct-1

o

*

g

i

*

f

*

+

ht

ct

ht-1

ct-1

o

*

g

i

*

f

*

+

ht

ct

(a) Moon et al., 2015

(b) Gal, 2015

(c) Ours

Figure 1: Illustration of the three types of dropout in recurrent connections of LSTM networks. Dashed
arrows refer to dropped connections. Input connections are omitted for clarity.

ht = (1 − zt) ∗ ht−1 + zt ∗ gt

(12)

Similarly to the LSTMs, we propoose to apply

dropout to the hidden state updates vector gt:

ht = (1 − zt) ∗ ht−1 + zt ∗ d(gt)

(13)

We found that an intuitive idea to drop pre-
vious hidden states directly, as proposed in
Moon et al. (2015), produces mixed results. We
have observed that it helps the network to gen-
eralize better when not coupled with the forward
dropout, but is usually no longer beneﬁcial when
used together with a regular forward dropout.

The problem is caused by the scaling of neu-
ron activations during inference. Consider the hid-
den state update rule in the test phase of an LSTM
network. For clarity, we assume every gate to be
equal to 1:

ht = (ht−1 + gt)p,

(14)

where gt are update vectors computed by Eq. 4
and p is the probability to not drop a neuron. As
ht−1 was, in turn, computed using the same rule,
we can rewrite this equation as:

ht = ((ht−2 + gt−1)p + gt)p

(15)

Recursively expanding h for every timestep re-
sults in the following equation:

ht = ((((h0 + g0)p + g1)p + ...)p + gt)p (16)

Pushing p inside parenthesis, Eq. 16 can be written
as:

ht = pt+1h0 +

pt−i+1gi

(17)

t

i=0
X

Since p is a value between zero and one, sum com-
ponents that are far away in the past are multi-
plied by a very low value and are effectively re-
moved from the summation. Thus, even though

the network is able to learn long-term dependen-
cies, it is not capable of exploiting them during
test phase. Note that our assumption of all gates
being equal to 1 helps the network to preserve hid-
den state, since in a real network gate values lie
within (0, 1) interval. In practice trained networks
tend to saturate gate values (Karpathy et al., 2015)
what makes gates to behave as binary switches.
The fact that Moon et al. (2015) have achieved an
improvement can be explained by the experimen-
tation domain. Le et al. (2015) have proposed a
simple yet effective way to initialize vanilla RNNs
and reported that they have achieved a good result
in the Speech Recognition domain while having
an effect similar to the one caused by Eq. 17. One
can reduce the inﬂuence of this effect by select-
ing a low dropout rate. This solution however is
partial, since it only increases the number of steps
required to completely forget past history and does
not remove the problem completely.

One important note is that the dropout function

from Eq. 3 can be implemented as:

d(x) =

mask ∗ x/p,
x

(

if train phase

otherwise

(18)

In this case the above argument holds as well, but
instead of observing exponentially decreasing hid-
den states during testing, we will observe expo-
nentially increasing values of hidden states during
training.

Our approach addresses the problem discussed
previously by dropping the update vectors g.
Since we drop only candidates, we do not scale
the hidden state directly. This allows for solving
the scaling issue, as Eq. 17 becomes:

ht = ph0 +

p gi = ph0 + p

gi

(19)

t

i=0
X

t

i=0
X

Moreover, since we only drop differences that are
added to the network’s hidden state at each time-
step, this dropout scheme allows us to use per-step

mask sampling while still being able to learn long-
term dependencies. Thus, our approach allows to
freely apply dropout in the recurrent connections
of a gated network without hindering its ability to
process long-term relationships.

We note that the discussed problem does not
affect vanilla RNNs because they overwrite their
hidden state at every timestep. Lastly, the ap-
proach of Gal (2015) is not affected by the issue
as well.

4 Experiments

First, we empirically demonstrate the issues linked
to memory loss when using various dropout
techniques
in recurrent nets (see Sec. 3.2).
For this purpose we experiment with training
LSTM networks on one of the synthetic tasks
from (Hochreiter and Schmidhuber, 1997), specif-
ically the Temporal Order task. We then validate
the effectiveness of our recurrent dropout when
applied to vanilla RNNs, LSTMs and GRUs on
three diverse public benchmarks: Language Mod-
elling, Named Entity Recognition, and Twitter
Sentiment classiﬁcation.

4.1 Synthetic Task

Data. In this task the input sequences are gener-
ated as follows: all but two elements in a sequence
are drawn randomly from {C, D} and the remain-
ing two symbols from {A, B}. Symbols from {A,
B} can appear at any position in the sequence.
The task is to classify a sequence into one of four
classes ({AA, AB, BA, BB}) based on the order
of the symbols. We generate data so that every se-
quence is split into three parts with the same size
and emit one meaningful symbol in ﬁrst and sec-
ond parts of a sequence. The prediction is taken
after the full sequence has been processed. We use
two modes in our experiments: Short with se-
quences of length 15 and Medium with sequences
of length 30.
Setup. We use LSTM with one layer that con-
tains 256 hidden units and recurrent dropout with
0.5 strength. Network is trained by SGD with a
learning rate of 0.1 for 5k epochs. The networks
are trained on 200 mini-batches with 32 sequences
and tested on 10k sequences.
Results.
Table 1 reports the results on the
Temporal Order task when recurrent dropout is
applied using our method and methods from
Us-
(Moon et al., 2015) and

(Gal, 2015).

ing dropout from (Moon et al., 2015) with per-
sequence sampling, networks are able to discover
the long-term dependency, but fail to use it on
the test set due to the scaling issue. Interestingly,
in Medium case results on the test set are worse
than random. Networks trained with per-step sam-
pling exhibit different behaviour: in Short case
they are capable of capturing the temporal de-
pendency and generalizing to the test set, but re-
quire 10-20 times more iterations to do so.
In
Medium case these networks do not ﬁt into the
allocated number of iterations. This suggests that
applying dropout to hidden states as suggested in
(Moon et al., 2015) corrupts memory cells hinder-
ing the long-term memory capacity of LSTMs.

In contrast, using our recurrent dropout meth-
ods, networks are able to solve the problem in all
cases. We have also ran the same experiments for
longer sequences, but found that the results are
equivalent to the Medium case. We also note that
the approach of (Gal, 2015) does not seem to ex-
hibit the memory loss problem.

4.2 Word Level Language Modeling

Data. Following Mikolov et al. (2011) we use
the Penn Treebank Corpus to train our Language
Modeling (LM) models. The dataset contains ap-
proximately 1 million words and comes with pre-
deﬁned training, validation and test splits, and a
vocabulary of 10k words.
In our LM experiments we use recur-
Setup.
rent networks with a single layer with 256 cells.
Network parameters were initialized uniformly in
[-0.05, 0.05]. For training, we use plain SGD
with batch size 32 with the maximum norm gradi-
ent clipping (Pascanu et al., 2013). Learning rate,
clipping threshold and number of Backpropaga-
tion Through Time (BPTT) steps were set to 1,
10 and 35 respectively. For the learning rate de-
cay we use the following strategy: if the valida-
tion error does not decrease after each epoch, we
divide the learning rate by 1.5. The aforemen-
tioned choices were largely guided by the work
of Mikolov et al. (2014). To ease reproducibility
of our results on the LM and synthetic tasks, we
have released the source code of our experiments1.
Results. Table 2 reports the results for LSTM
networks. We also present results when the
dropout is applied directly to hidden states as
in (Moon et al., 2015) and results of networks

1https://github.com/stas-semeniuta/drop-rnn

Sampling

Moon et al. (2015)
short sequences medium sequences
Test
Train

Train

Test

Gal (2015); Ours
short sequences medium sequences
Test
Train

Train

Test

per-step
per-sequence

100% 100% 25%
25% 100%
100%

25% 100% 100% 100%
<25% 100% 100% 100%

100%
100%

Table 1: Accuracies on the Temporal Order task.

Dropout rate

Sampling

Moon et al. (2015)
Test
Valid

Gal (2015)
Test

Valid

Ours

Valid

Test

0.0
0.25
0.5
0.25
0.5

0.0
0.25
0.5
0.25
0.5

–
per-step
per-step
per-sequence
per-sequence

–
per-step
per-step
per-sequence
per-sequence

130.0
113.0
124.0
121.0
137.7

94.1
113.5
140.6
105.7
125.4

125.2
108.7
116.5
113.0
126.2

89.5
105.8
130.1
99.9
117.4

130.0
119.8
118.3
120.5
125.2

94.1
92.9
98.6
94.5
98.4

125.2
114.2
112.5
114.0
117.9

89.5
88.4
92.5
89.7
92.5

130.0
106.1
102.8
106.3
103.2

94.1
91.6
100.6
92.4
107.8

125.2
100.0
98.0
100.7
96.8

89.5
87.0
95.5
87.6
101.8

Table 2: Perplexity scores of the LSTM network on word level Language Modeling task (lower is better).
Upper and lower parts of the table report results without and with forward dropout respectively. Networks
with forward dropout use 0.2 and 0.5 dropout rates in input and output connections respectively. Values
in bold show best results for each of the recurrent dropout schemes with and without forward dropout.

trained with the dropout scheme of (Gal, 2015).
We make the following observations: (i) our ap-
proach shows better results than the alternatives;
(ii) per-step mask sampling is better when drop-
ping hidden state directly; (iii) on this task our
method using per-step sampling seems to yield re-
sults similar to per-sequence sampling; (iv) in this
case forward dropout yields better results than any
of the three recurrent dropouts; and ﬁnally (v) both
our approach and that of (Gal, 2015) are effective
when combined with the forward dropout, though
ours is more effective.

We make the following observations: (i) drop-
ping hidden state updates yields better results than
dropping hidden states; (ii) per-step mask sam-
pling is better when dropping hidden state directly;
(iii) contrary to our expectations, when we apply
dropout to hidden state updates per-step sampling
seems to yield results similar to per-sequence sam-
pling; (iv) applying dropout to hidden state up-
dates rather than hidden states in some cases leads
to a perplexity decrease by more than 30 points;
and ﬁnally (v) our approach is effective even when

combined with the forward dropout – for LSTMs
we are able to bring down perplexity on the vali-
dation set from 130 to 91.6.

To demonstrate the effect of our approach on the
learning process, we also present learning curves
of LSTM networks trained with and without re-
current dropout (Fig. 2). Models trained using
our recurrent dropout scheme have slower con-
vergence than models without dropout and usu-
ally have larger training error and lower validation
errors. This behaviour is consistent with what is
expected from a regularizer and is similar to the
effect of the feed-forward dropout applied to non-
recurrent networks (Hinton et al., 2012).

4.3 Character Level Language Modeling

Data. We train our networks on the dataset de-
scribed in the previous section. It contains approx-
imately 6 million characters, and a vocabulary of
50 characters. We use the provided partitions train,
validation and test partitions.
Setup. We use networks with 1024 units to solve
the character level LM task. The characters are

Dropout rate

Sampling

Moon et al. (2015)
Valid

Test Valid

Gal (2015)
Test

Ours

Valid

Test

0.0
0.25
0.5
0.25
0.5

0.0
0.25
0.5
0.25
0.5

–
per-step
per-step
per-sequence
per-sequence

–
per-step
per-step
per-sequence
per-sequence

1.460
1.435
1.610
1.433
1.691

1.362
1.471
1.668
1.455
1.681

1.457
1.394
1.561
1.390
1.647

1.326
1.428
1.622
1.413
1.637

1.460
1.345
1.387
1.341
1.408

1.362
1.381
1.463
1.387
1.477

1.457
1.308
1.348
1.304
1.369

1.326
1.344
1.425
1.348
1.435

1.460
1.338
1.355
1.356
1.496

1.362
1.358
1.422
1.403
1.567

1.457
1.301
1.316
1.319
1.450

1.326
1.321
1.380
1.363
1.522

Table 3: Bit-per-character scores of the LSTM network on character level Language Modelling task
(lower is better). Upper and lower parts of the table report results without and with forward dropout re-
spectively. Networks with forward dropout use 0.2 and 0.5 dropout rates in input and output connections
respectively. Values in bold show best results for each of the recurrent dropout schemes with and without
forward dropout.

with dropout
without dropout

9

8

7

6

5

4

3
0

5000 10000 15000 20000 25000 30000

Figure 2: Learning curves of LSTM networks
when training without and with 0.25 per-step re-
current dropout. Solid and dashed lines show
training and validation errors respectively. Best
viewed in color.

embedded into 256 dimensional space before be-
ing processed by the LSTM. All parameters of
the networks are initialized uniformly in [-0.01,
0.01]. We train our networks on non-overlapping
sequences of 100 characters. The networks are
trained with the Adam (?) algorithm with initial
learning rate of 0.001 for 50 epochs. We decrease
the learning rate by 0.97 after every epoch starting
from epoch 10. To avoid exploding gradints, we
use MaxNorm gradient clipping with threshold set
to 10.
Results. Results of our experiments are given
in Table 3. Note that on this task regulariz-
ing only the recurrent connections is more ben-
eﬁcial than only the forward ones.
In particu-
lar, LSTM networks trained with our approach
and the approach of (Gal, 2015) yield a lower
bit-per-character (bpc) score than those trained
with forward dropout onlyWe attribute it to pro-
nounced long term dependencies.
In addition,
our approach is the only one that improves over
baseline LSTM with forward dropout. The over-
all best result is achieved by a network trained
with our dropout with 0.25 dropout rate and per-
step sampling, closely followed by network with
Gal (2015) dropout.

4.4 Named Entity Recognition

Data. To assess our recurrent Named Entity
Recognition (NER) taggers when using recurrent
dropout we use a public benchmark from CONLL

2003
(Tjong Kim Sang and De Meulder, 2003).
The dataset contains approximately 300k words
split into train, validation and test partitions. Each
word is labeled with either a named entity class
it belongs to, such as Location or Person, or
as being not named. The majority of words are
labeled as not named entities. The vocabulary size
is about 22k words.

Previous state-of-the-art NER systems
Setup.
have shown the importance of using word con-
text features around entities. Hence, we slightly
modify the architecture of our recurrent networks
to consume the context around the target word
by simply concatenating their embeddings. The
size of the context window is ﬁxed to 5 words
(the word to be labeled, two words before and
two words after). The recurrent
layer size is
1024 units. The network inputs include only word
embeddings (initialized with pretrained word2vec
embeddings (Mikolov et al., 2013) and kept static)
and capitalization features. For training we use the
RMSProp algorithm (Dauphin et al., 2015) with ρ
ﬁxed at 0.9 and a learning rate of 0.01 and mul-
tiply the learning rate by 0.99 after every epoch.
We also combine our recurrent dropout (with per-
sequence mask sampling) with the conventional
forward dropout with the rate 0.2 in input and 0.5
in output connections. Lastly, we found that us-
ing relu(x) = max(x, 0) nonlinearity resulted in
higher performance than tanh(x).

To speed up the training we use a length ex-
pansion approach described in (Ng et al., 2015),
where training is performed in two stages: (i) we
ﬁrst sample short 5-words input sequences with
their contexts and train for 25 epochs; (ii) we
ﬁne tune the network on input 15-words sequences
for 10 epochs. We found that further ﬁne tuning
on longer sequences yielded negligible improve-
ments. Such strategy allows us to signiﬁcantly
speed up the training when compared to training
from scratch on full-length input sentences. We
use full sentences for testing.

Results. F1 scores of our taggers are reported in
Table 4 when trained on short 5-word and longer
15-word input sequences. We note that the gap
between networks trained with and without our
dropout scheme is larger for networks trained on
shorter sequences. It suggests that dropout in re-
current connections might have an impact on how
well a network generalizes to sequences that are
longer than the ones used during training. The

Dropout rate RNN LSTM GRU

5 word long sequences
85.32
85.60
86.42
86.48

0.0
0.25

15 word long sequences
86.12
86.95

86.12
86.88

0.0
0.25

86.00
86.70

86.44
87.10

Table 4: F1 scores (higher is better) on NER task.

gain from using recurrent dropout is larger for
the LSTM network. We have experimented with
higher recurrent dropout rates, but found that it
led to excessive regularization.

4.5 Twitter Sentiment Analysis

We

sentiment

use Twitter

(Rosenthal et al., 2015).

cor-
Data.
from SemEval-2015 Task 10 (subtask
pus
B)
It contains 15k
labeled tweets split into training and validation
partitions. The total number of words is approx-
imately 330k and the vocabulary size is 22k.
The task consists of classifying a tweet into three
classes: positive, neutral, and negative.
Performance of a classiﬁer is measured by the av-
erage of F1 scores of positive and negative
classes. We evaluate our models on a number of
datasets that were used for benchmarking during
the last years.
Setup. We use recurrent networks in the standard
sequence labeling manner - we input words to a
network one by one and take the label at the last
step. Similarly to (Severyn and Moschitti, 2015),
we use 1 million of weakly labeled tweets to pre-
train our networks. We use networks composed of
500 neurons in all cases. Our models are trained
with the RMSProp algorithm with a learning rate
of 0.001. We use our recurrent dropout regular-
ization with per-step mask sampling. All the other
settings are equivalent to the ones used in the NER
task.
Results. The results of these experiments are pre-
sented in Table 5. Note that in this case our al-
gorithm decreases the performance of the vanilla
RNNs while this is not the case for LSTM and
GRU networks. This is due to the nature of the
problem: differently from LM and NER tasks,
a network needs to aggregate information over a
long sequence. Vanilla RNNs notoriously have
difﬁculties with this and our dropout scheme im-

Dropout rate Twitter13 LiveJournal14 Twitter15 Twitter14 SMS13 Sarcasm14

0
0.25

0
0.25

0
0.25

67.54
66.35

67.97
69.11

67.09
69.04

71.20
67.70

69.82
71.39

70.80
72.10

RNN

LSTM

GRU

59.35
59.91

57.84
61.35

59.07
60.34

68.90
67.76

67.95
68.08

67.02
69.65

64.51
64.46

61.47
65.45

67.11
65.73

53.58
48.74

53.49
53.80

51.01
54.77

Table 5: F1 scores (higher is better) on Sentiment Evaluation task

pairs their ability to remember even further. The
best result over most of the datasets is achieved
by the GRU network with recurrent dropout. The
only exception is the Twitter2015 dataset, where
the LSTM network shows better results.

5 Conclusions

This paper presents a novel recurrent dropout
method speciﬁcally tailored to the gated recurrent
neural networks. Our approach is easy to im-
plement and is even more effective when com-
bined with conventional forward dropout. We
have shown that for LSTMs and GRUs applying
dropout to arbitrary cell vectors results in subopti-
mal performance. We discuss in detail the cause of
this effect and propose a simple solution to over-
come it. The effectiveness of our approach is ver-
iﬁed on three different public NLP benchmarks.

Our ﬁndings along with our empirical results
allow us to answer the questions posed in Sec-
tion 1: i) while is straight-forward to use dropout
in vanilla RNNs due to their strong similarity with
the feed-forward architectures, its application to
LSTM networks is not so straightforward. We
demonstrate that recurrent dropout
is most ef-
fective when applied to hidden state update vec-
tors in LSTMs rather than to hidden states; (ii)
we observe an improvement in the network’s per-
formance when our recurrent dropout is coupled
with the standard forward dropout,
though the
extent of this improvement depends on the val-
ues of dropout rates; (iii) contrary to our expec-
tations, networks trained with per-step and per-
sequence mask sampling produce similar results
when using our recurrent dropout method, both
being better than the dropout scheme proposed by
Moon et al. (2015).

While our experimental results show that ap-
plying recurrent dropout method leads to signif-
icant improvements across various NLP bench-
marks (especially when combined with conven-
tional forward dropout), its beneﬁts for other tasks,
e.g., sequence-to-sequence prediction, or other do-
mains, e.g., Speech Recognition, remain unex-
plored. We leave it as our future work.

Acknowledgments

This project has received funding from the Eu-
ropean Union’s Framework Programme for Re-
search and Innovation HORIZON 2020 (2014-
2020) under the Marie Skodowska-Curie Agree-
ment No. 641805. Stanislau Semeniuta thanks
the support from Pattern Recognition Company
GmbH. We gratefully acknowledge the support of
NVIDIA Corporation with the donation of the Ti-
tan X GPU used for this research.

References

[Bengio et al.1994] Yoshua

Bengio,

Patrice
Simard, and Paolo Frasconi. 1994. Learning
long-term dependencies with gradient descent
is difﬁcult.
IEEE Transactions on Neural
Networks, 5(2):157–166.

[Bengio et al.2015] Samy Bengio, Oriol Vinyals,
Navdeep Jaitly, and Noam Shazeer.
2015.
Scheduled sampling for sequence prediction
with recurrent neural networks.
CoRR,
abs/1506.03099.

[Bluche et al.2015] Theodore Bluche, Christopher
Kermorvant, and J´erˆome Louradour.
2015.
Where to apply dropout in recurrent neural net-

works for handwriting recognition? In 13th In-
ternational Conference on Document Analysis
and Recognition, ICDAR 2015, Tunis, Tunisia,
August 23-26, 2015, pages 681–685.

[Cho et al.2014] KyungHyun Cho, Bart van Mer-
rienboer, Dzmitry Bahdanau, and Yoshua Ben-
gio. 2014. On the properties of neural ma-
chine translation: Encoder-decoder approaches.
CoRR, abs/1409.1259.

[Dauphin et al.2015] Yann N. Dauphin, Harm
de Vries, Junyoung Chung, and Yoshua Bengio.
2015. Rmsprop and equilibrated adaptive learn-
ing rates for non-convex optimization. CoRR,
abs/1502.04390.

[Dyer et al.2015] Chris Dyer, Miguel Ballesteros,
Wang Ling, Austin Matthews, and A. Noah
Smith.
2015. Transition-based dependency
parsing with stack long short-term memory. In
ACL, pages 334–343. Association for Compu-
tational Linguistics.

[Gal2015] Yarin Gal.

A theoretically
grounded application of dropout in recurrent
neural networks. arXiv:1512.05287.

2015.

[Hinton et al.2012] Geoffrey E. Hinton, Nitish Sri-
vastava, Alex Krizhevsky, Ilya Sutskever, and
Ruslan Salakhutdinov. 2012. Improving neural
networks by preventing co-adaptation of feature
detectors. CoRR, abs/1207.0580.

[Hochreiter and Schmidhuber1997] Sepp Hochre-
1997. Long
Neural Comput.,

iter and J¨urgen Schmidhuber.
short-term memory.
9(8):1735–1780, November.

[Irsoy and Cardie2014] Ozan Irsoy and Claire
Cardie. 2014. Opinion mining with deep re-
In Proceedings of
current neural networks.
the 2014 Conference on Empirical Methods in
Natural Language Processing (EMNLP), pages
720–728. Association for Computational Lin-
guistics.

[Karpathy et al.2015] Andrej Karpathy,

Justin
Johnson, and Fei-Fei Li. 2015. Visualizing
and understanding recurrent networks. CoRR,
abs/1506.02078.

[Kim et al.2015] Yoon Kim, Yacine

Jernite,
David Sontag, and Alexander M. Rush. 2015.
Character-aware
language models.
CoRR, abs/1508.06615.

neural

[Krizhevsky et al.2012] Alex Krizhevsky,
Ilya
2012.
Sutskever, and Geoffrey E. Hinton.
Imagenet classiﬁcation with deep convolutional
In F. Pereira, C.J.C. Burges,
neural networks.
editors,
L. Bottou, and K.Q. Weinberger,
Advances
Information Process-
ing Systems 25, pages 1097–1105. Curran
Associates, Inc.

in Neural

[Le et al.2015] Quoc V. Le, Navdeep Jaitly, and
Geoffrey E. Hinton. 2015. A simple way to
initialize recurrent networks of rectiﬁed linear
units. CoRR, abs/1504.00941.

[Liu et al.2015] Pengfei Liu, Xipeng Qiu, Xinchi
Chen, Shiyu Wu, and Xuanjing Huang. 2015.
Multi-timescale long short-term memory neu-
ral network for modelling sentences and docu-
ments. In ACL. Association for Computational
Linguistics.

[Mikolov et al.2011] T. Mikolov, S. Kombrink,
L. Burget, J.H. Cernocky, and Sanjeev Khudan-
pur. 2011. Extensions of recurrent neural net-
In Acoustics, Speech
work language model.
and Signal Processing (ICASSP), 2011 IEEE
International Conference on, pages 5528–5531,
May.

[Mikolov et al.2013] Tomas

Mikolov,

Ilya
Sutskever, Kai Chen, Greg S Corrado, and
Jeff Dean. 2013. Distributed representations of
words and phrases and their compositionality.
In C.J.C. Burges, L. Bottou, M. Welling,
Z. Ghahramani, and K.Q. Weinberger, editors,
Information Process-
Advances
ing Systems 26, pages 3111–3119. Curran
Associates, Inc.

in Neural

[Mikolov et al.2014] Tomas Mikolov, Armand
Joulin, Sumit Chopra, Micha¨el Mathieu, and
Marc’Aurelio Ranzato. 2014. Learning longer
memory in recurrent neural networks. CoRR,
abs/1412.7753.

[Moon et al.2015] Taesup Moon, Heeyoul Choi,
Hoshik Lee, and Inchul Song.
2015. Rn-
ndrop: A novel dropout for rnns in asr. Au-
tomatic Speech Recognition and Understanding
(ASRU).

[Ng et al.2015] Joe Yue-Hei Ng, Matthew J.
Hausknecht, Sudheendra Vijayanarasimhan,
and George
Oriol Vinyals, Rajat Monga,

2015.

Toderici.
Beyond short snippets:
Deep networks for video classiﬁcation. CoRR,
abs/1503.08909.

[Pascanu et al.2013] Razvan

Pascanu,

Tomas
Mikolov, and Yoshua Bengio. 2013. On the
difﬁculty of training recurrent neural networks.
In Proceedings of the 30th International Con-
ICML 2013,
ference on Machine Learning,
Atlanta, GA, USA, 16-21 June 2013, pages
1310–1318.

[Pham et al.2013] Vu Pham, Christopher Kermor-
vant, and J´erˆome Louradour. 2013. Dropout
improves recurrent neural networks for hand-
writing recognition. CoRR, abs/1312.4569.

[Rosenthal et al.2015] Sara Rosenthal,

Preslav
Nakov, Svetlana Kiritchenko, Saif Mohammad,
Alan Ritter, and Veselin Stoyanov.
2015.
Semeval-2015 task 10: Sentiment analysis in
twitter. In Proceedings of the 9th International
Workshop on Semantic Evaluation (SemEval
2015), pages 451–463, Denver, Colorado, June.
Association for Computational Linguistics.

[Severyn and Moschitti2015] Aliaksei

2015.

Severyn
Twitter
and Alessandro Moschitti.
sentiment analysis with deep convolutional
neural networks.
In Proceedings of the 38th
International ACM SIGIR Conference on
in Information
Research and Development
Retrieval, Santiago, Chile, August 9-13, 2015,
pages 959–962.

[Sutskever et al.2014] Ilya

Oriol
Vinyals, and Quoc V. Le. 2014. Sequence to

Sutskever,

sequence learning with neural networks.
NIPS, pages 3104–3112.

In

[Tjong Kim Sang and De Meulder2003] Erik

F.
Tjong Kim Sang and Fien De Meulder. 2003.
Introduction to the conll-2003 shared task:
Language-independent named entity recogni-
tion. In Proceedings of the Seventh Conference
on Natural Language Learning at HLT-NAACL
2003 - Volume 4, CONLL ’03, pages 142–
147, Stroudsburg, PA, USA. Association for
Computational Linguistics.

[Wang et al.2015] Xin Wang, Yuanchao Liu,
Chengjie SUN, Baoxun Wang, and Xiaolong
Wang. 2015. Predicting polarities of tweets
by composing word embeddings with long
short-term memory. In ACL, pages 1343–1353.
Association for Computational Linguistics.

[Zaremba et al.2014] Wojciech Zaremba,

Ilya
Sutskever, and Oriol Vinyals. 2014. Recur-
rent neural network regularization.
CoRR,
abs/1409.2329.

[Zhang and Lapata2014] Xingxing Zhang

and
2014. Chinese poetry gen-
Mirella Lapata.
eration with recurrent neural networks.
In
Proceedings of the 2014 Conference on Empir-
ical Methods in Natural Language Processing
(EMNLP), pages 670–680. Association for
Computational Linguistics.

[Zhang et al.2015] Xingxing Zhang, Liang Lu, and
Mirella Lapata. 2015. Tree recurrent neural
networks with application to language model-
ing. CoRR, abs/1511.00060.

Recurrent Dropout without Memory Loss

Stanislau Semeniuta1 Aliaksei Severyn2 Erhardt Barth1
1Universit¨at zu L¨ubeck, Institut f¨ur Neuro- und Bioinformatik
{stas,barth}@inb.uni-luebeck.de
2Google Research
severyn@google.com

6
1
0
2
 
g
u
A
 
5
 
 
]
L
C
.
s
c
[
 
 
2
v
8
1
1
5
0
.
3
0
6
1
:
v
i
X
r
a

Abstract

This paper presents a novel approach to re-
current neural network (RNN) regulariza-
tion. Differently from the widely adopted
dropout method, which is applied to for-
ward connections of feed-forward archi-
tectures or RNNs, we propose to drop neu-
rons directly in recurrent connections in a
way that does not cause loss of long-term
memory. Our approach is as easy to imple-
ment and apply as the regular feed-forward
dropout and we demonstrate its effective-
ness for Long Short-Term Memory net-
work,
the most popular type of RNN
cells. Our experiments on NLP bench-
marks show consistent improvements even
when combined with conventional feed-
forward dropout.

1 Introduction

Recurrent Neural Networks, LSTMs in particular,
have recently become a popular tool among NLP
researchers for their superior ability to model and
learn from sequential data. These models have
shown state-of-the-art results on various public
benchmarks ranging from sentence classiﬁca-
Irsoy and Cardie, 2014;
tion (Wang et al., 2015;
Liu et al., 2015)
prob-
tagging
language mod-
lems
elling
Zhang et al., 2015),
(Zhang and Lapata, 2014)
text
and
prediction
tasks (Sutskever et al., 2014).

(Dyer et al., 2015)
(Kim et al., 2015;
generation

sequence-to-sequence

various
to

and

Having shown excellent ability to capture and
learn complex linguistic phenomena, RNN ar-
chitectures are prone to overﬁtting.
Among
the most widely used techniques to avoid over-
ﬁtting in neural networks is the dropout regu-
larization (Hinton et al., 2012). Since its intro-

together with the L2
duction it has become,
weight decay,
the standard method for neural
network regularization. While showing signif-
icant improvements when used in feed-forward
architectures, e.g., Convolutional Neural Net-
works (Krizhevsky et al., 2012), the application of
dropout in RNNs has been somewhat limited. In-
deed, so far dropout in RNNs has been applied
in the same fashion as in feed-forward architec-
tures:
it is typically injected in input-to-hidden
and hidden-to-output connections, i.e., along the
input axis, but not between the recurrent connec-
tions (time axis). Given that RNNs are mainly
used to model sequential data with the goal of cap-
turing short- and long-term interactions, it seems
natural to also regularize the recurrent weights.
This observation has led us and other researchers
(Moon et al., 2015; Gal, 2015) to the idea of ap-
to the recurrent connections in
plying dropout
RNNs.

In this paper we propose a novel recurrent
dropout
technique and demonstrate how our
method is superiour to other recurrent dropout
methods recently proposed in (Moon et al., 2015;
Gal, 2015). Additionally, we answer the follow-
ing questions which helps to understand how to
(i) how to apply
best apply recurrent dropout:
the dropout in recurrent connections of the LSTM
architecture in a way that prevents possible cor-
ruption of the long-term memory; (ii) what is
the relationship between our recurrent dropout
and the widely adopted dropout in input-to-hidden
and hidden-to-output connections; (iii) how the
dropout mask in RNNs should be sampled: once
per step or once per sequence. The latter question
of sampling the mask appears to be crucial in some
cases to make the recurrent dropout work and, to
the best of our knowledge, has received very little
attention in the literature. Our work is the ﬁrst one
to provide empirical evaluation of the differences

between these two sampling approaches.

Regarding empirical evaluation, we ﬁrst high-
light the problem of information loss in memory
cells of LSTMs when applying recurrent dropout.
We demonstrate that previous approaches of drop-
ping hidden state vectors cause loss of memory
while our proposed method to use dropout mask in
hidden state update vectors does not suffer from
this problem. We experiment on three widely
adopted NLP tasks: word- and character-level
Language Modeling and Named Entity Recog-
nition. The results demonstrate that our recur-
rent dropout helps to achieve better regulariza-
tion and yields improvements across all the tasks,
even when combined with the conventional feed-
forward dropout. Furthermore, we compare our
dropout scheme with the recently proposed alter-
native recurrent dropout methods and show that
our technique is superior in almost all cases.

2 Related Work

Neural Network models often suffer from overﬁt-
ting, especially when the number of network pa-
rameters is large and the amount of training data is
small. This has led to a lot of research directed to-
wards improving their generalization ability. Be-
low we primarily discuss some of the methods
aimed at improving regularization of RNNs.

Pham et al. (2013) and Zaremba et al. (2014)
have shown that LSTMs can be effectively regu-
larized by using dropout in forward connections.
While this already allows for effective regulariza-
tion of recurrent networks, it is intuitive that intro-
ducing dropout also in the hidden state may force
it to create more robust representations.
Indeed,
Moon et al. (2015) have extended the idea of drop-
ping neurons in forward direction and proposed to
drop cell states as well showing good results on
a Speech Recognition task. Bluche et al. (2015)
carry out a study to ﬁnd where dropout is most
effective, e.g. input-to-hidden or hidden-to-output
connections. The authors conclude that it is more
beneﬁcial to use it once in the correct spot, rather
than to put it everywhere. Bengio et al. (2015)
have proposed an algorithm called scheduled sam-
pling to improve performance of recurrent net-
works on sequence-to-sequence labeling tasks. A
disadvantage of this work is that the scheduled
sampling is speciﬁcally tailored to this kind of
tasks, what makes it impossible to use in, for ex-
ample, sequence-to-label tasks. Gal (2015) uses

insights from variational Bayesian inference to
that
propose a variant of LSTM with dropout
achieves consistent improvements over a baseline
architecture without dropout.

The main contribution of this paper is a new
recurrent dropout technique, which is most use-
ful in gated recurrent architectures such as LSTMs
and GRUs. We demonstrate that applying dropout
to arbitrary vectors in LSTM cells may lead to
loss of memory thus hindering the ability of the
network to encode long-term information.
In
other words, our technique allows for adding a
strong regularizer on the model weights respon-
sible for learning short and long-term dependen-
cies without affecting the ability to capture long-
term relationships, which are especially important
to model when dealing with natural language. Fi-
nally, we compare our method with alternative
recurrent dropout methods recently introduced
in (Moon et al., 2015; Gal, 2015) and demonstrate
that our method allows to achieve better results.

3 Recurrent Dropout

In this section we ﬁrst show how the idea
of feed-forward dropout (Hinton et al., 2012) can
be applied to recurrent connections in vanilla
RNNs. We then introduce our recurrent dropout
method speciﬁcally tailored for gated architec-
tures such as LSTMs and GRUs. We draw par-
allels and contrast our approach with alternative
techniques recently proposed
recurrent dropout
in (Moon et al., 2015; Gal, 2015) showing that our
method is favorable when considering potential
memory loss issues in long short-term architec-
tures.

3.1 Dropout in vanilla RNNs

Vanilla RNNs process the input sequences as fol-
lows:

ht = f (Wh[xt, ht−1] + bh),

(1)

where xt is the input at time step t; ht and ht−1
are hidden vectors that encode the current and
previous states of the network; Wh is parameter
matrix that models input-to-hidden and hidden-to-
hidden (recurrent) connections; b is a vector of
bias terms, and f is the activation function.

As RNNs model sequential data by a fully-
connected layer, dropout can be applied by simply
dropping the previous hidden state of a network.

Speciﬁcally, we modify Equation 1 in the follow-
ing way:

ht = f (Wh[xt, d(ht−1)] + bh),

(2)

where d is the dropout function deﬁned as follows:

d(x) =

mask ∗ x,
(1 − p)x

(

if train phase

otherwise,

(3)

where p is the dropout rate and mask is a vector,
sampled from the Bernoulli distribution with suc-
cess probability 1 − p.

3.2 Dropout in LSTM networks

Memory

Long
Short-Term
net-
(Hochreiter and Schmidhuber, 1997)
works
have introduced the concept of gated inputs in
RNNs, which effectively allow the network to
preserve its memory over a larger number of
time steps during both forward and backward
passes, thus alleviating the problem of vanishing
gradients (Bengio et al., 1994).
it is
expressed with the following equations:

Formally,

it
ft
ot
gt













= 

σ(Wi
σ(Wf
σ(Wo
f (Wg

xt, ht−1
xt, ht−1
xt, ht−1
xt, ht−1

(cid:2)
(cid:2)


(cid:2)

(cid:2)
ct = ft ∗ ct−1 + it ∗ gt

(cid:3)
(cid:3)
(cid:3)
(cid:3)

+ bi)
+ bf )
+ bo)
+ bg)







ht = ot ∗ f (ct),

(4)

(5)

(6)

where it, ft, ot are input, output and forget gates at
step t; gt is the vector of cell updates and ct is the
updated cell vector used to update the hidden state
ht; σ is the sigmoid function and ∗ is the element-
wise multiplication.

Gal (2015) proposes to drop the previous hid-
den state when computing values of gates and up-
dates of the current step, where he samples the
dropout mask once for every sequence:

it
ft
ot
gt





= 

σ(Wi
σ(Wf
σ(Wo
f (Wg

xt, d(ht−1)
xt, d(ht−1)
(cid:3)
xt, d(ht−1)
(cid:3)
xt, d(ht−1)
(cid:3)
(cid:3)

(cid:2)
(cid:2)
(cid:2)
(cid:2)

+ bi)
+ bf )
+ bo)
+ bg)












Moon et al. (2015) propose to apply dropout di-
rectly to the cell values and use per-sequence sam-
pling as well:







(7)

ct = d(ft ∗ ct−1 + it ∗ gt)

(8)

In contrast to dropout techniques proposed by
Gal (2015) and Moon et al. (2015), we propose to
apply dropout to the cell update vector gt as fol-
lows:

ct = ft ∗ ct−1 + it ∗ d(gt)

(9)

Different from methods of (Moon et al., 2015;
Gal, 2015), our approach does not require sam-
pling of the dropout masks once for every train-
ing sequence. On the contrary, as we will show in
Section 4, networks trained with a dropout mask
sampled per-step achieve results that are at least as
good and often better than per-sequence sampling.
Figure 1 shows differences between approaches to
dropout.

The approach of (Gal, 2015) differs from ours
in the overall strategy – they consider network’s
hidden state as input to subnetworks that com-
pute gate values and cell updates and the pur-
pose of dropout
is to regularize these subnet-
works. Our approach considers the architecture
as a whole with the hidden state as its key part
and regularize the whole network. The approach
of (Moon et al., 2015) on the other hand is seem-
ingly similar to ours. In Section 3.2 we argue that
our method is a more principled way to drop re-
current connections in gated architectures.

It should be noted that while being different, the
three discussed dropout schemes are not mutually
exclusive. It is in general possible to combine our
approach and the other two. We expect the merge
of our scheme and that of (Gal, 2015) to hold the
biggest potential. The relations between recurrent
dropout schemes are however out of scope of this
paper and we rather focus on studying the rela-
tionships of different dropout approaches with the
conventional forward dropout.
(GRU) networks are
Gated Recurrent Unit
recur-
a
rent network with hidden state protected by
gates (Cho et al., 2014). Different from LSTMs,
GRU networks use only two gates rt and zt to
update the cell’s hidden state ht:

recently introduced variant of

a

(cid:18)

=

zt
rt(cid:19)
gt = f (Wg

(cid:18)

σ(Wz
σ(Wr

xt, ht−1
xt, ht−1

+ bz)
+ br)

(10)

(cid:19)

+ bg)

(11)

(cid:2)
(cid:2)

(cid:3)
(cid:3)
xt, rt ∗ ht−1

(cid:2)

(cid:3)

ht-1

ct-1

o

*

g

i

*

f

*

+

ht

ct

ht-1

ct-1

o

*

g

i

*

f

*

+

ht

ct

ht-1

ct-1

o

*

g

i

*

f

*

+

ht

ct

(a) Moon et al., 2015

(b) Gal, 2015

(c) Ours

Figure 1: Illustration of the three types of dropout in recurrent connections of LSTM networks. Dashed
arrows refer to dropped connections. Input connections are omitted for clarity.

ht = (1 − zt) ∗ ht−1 + zt ∗ gt

(12)

Similarly to the LSTMs, we propoose to apply

dropout to the hidden state updates vector gt:

ht = (1 − zt) ∗ ht−1 + zt ∗ d(gt)

(13)

We found that an intuitive idea to drop pre-
vious hidden states directly, as proposed in
Moon et al. (2015), produces mixed results. We
have observed that it helps the network to gen-
eralize better when not coupled with the forward
dropout, but is usually no longer beneﬁcial when
used together with a regular forward dropout.

The problem is caused by the scaling of neu-
ron activations during inference. Consider the hid-
den state update rule in the test phase of an LSTM
network. For clarity, we assume every gate to be
equal to 1:

ht = (ht−1 + gt)p,

(14)

where gt are update vectors computed by Eq. 4
and p is the probability to not drop a neuron. As
ht−1 was, in turn, computed using the same rule,
we can rewrite this equation as:

ht = ((ht−2 + gt−1)p + gt)p

(15)

Recursively expanding h for every timestep re-
sults in the following equation:

ht = ((((h0 + g0)p + g1)p + ...)p + gt)p (16)

Pushing p inside parenthesis, Eq. 16 can be written
as:

ht = pt+1h0 +

pt−i+1gi

(17)

t

i=0
X

Since p is a value between zero and one, sum com-
ponents that are far away in the past are multi-
plied by a very low value and are effectively re-
moved from the summation. Thus, even though

the network is able to learn long-term dependen-
cies, it is not capable of exploiting them during
test phase. Note that our assumption of all gates
being equal to 1 helps the network to preserve hid-
den state, since in a real network gate values lie
within (0, 1) interval. In practice trained networks
tend to saturate gate values (Karpathy et al., 2015)
what makes gates to behave as binary switches.
The fact that Moon et al. (2015) have achieved an
improvement can be explained by the experimen-
tation domain. Le et al. (2015) have proposed a
simple yet effective way to initialize vanilla RNNs
and reported that they have achieved a good result
in the Speech Recognition domain while having
an effect similar to the one caused by Eq. 17. One
can reduce the inﬂuence of this effect by select-
ing a low dropout rate. This solution however is
partial, since it only increases the number of steps
required to completely forget past history and does
not remove the problem completely.

One important note is that the dropout function

from Eq. 3 can be implemented as:

d(x) =

mask ∗ x/p,
x

(

if train phase

otherwise

(18)

In this case the above argument holds as well, but
instead of observing exponentially decreasing hid-
den states during testing, we will observe expo-
nentially increasing values of hidden states during
training.

Our approach addresses the problem discussed
previously by dropping the update vectors g.
Since we drop only candidates, we do not scale
the hidden state directly. This allows for solving
the scaling issue, as Eq. 17 becomes:

ht = ph0 +

p gi = ph0 + p

gi

(19)

t

i=0
X

t

i=0
X

Moreover, since we only drop differences that are
added to the network’s hidden state at each time-
step, this dropout scheme allows us to use per-step

mask sampling while still being able to learn long-
term dependencies. Thus, our approach allows to
freely apply dropout in the recurrent connections
of a gated network without hindering its ability to
process long-term relationships.

We note that the discussed problem does not
affect vanilla RNNs because they overwrite their
hidden state at every timestep. Lastly, the ap-
proach of Gal (2015) is not affected by the issue
as well.

4 Experiments

First, we empirically demonstrate the issues linked
to memory loss when using various dropout
techniques
in recurrent nets (see Sec. 3.2).
For this purpose we experiment with training
LSTM networks on one of the synthetic tasks
from (Hochreiter and Schmidhuber, 1997), specif-
ically the Temporal Order task. We then validate
the effectiveness of our recurrent dropout when
applied to vanilla RNNs, LSTMs and GRUs on
three diverse public benchmarks: Language Mod-
elling, Named Entity Recognition, and Twitter
Sentiment classiﬁcation.

4.1 Synthetic Task

Data. In this task the input sequences are gener-
ated as follows: all but two elements in a sequence
are drawn randomly from {C, D} and the remain-
ing two symbols from {A, B}. Symbols from {A,
B} can appear at any position in the sequence.
The task is to classify a sequence into one of four
classes ({AA, AB, BA, BB}) based on the order
of the symbols. We generate data so that every se-
quence is split into three parts with the same size
and emit one meaningful symbol in ﬁrst and sec-
ond parts of a sequence. The prediction is taken
after the full sequence has been processed. We use
two modes in our experiments: Short with se-
quences of length 15 and Medium with sequences
of length 30.
Setup. We use LSTM with one layer that con-
tains 256 hidden units and recurrent dropout with
0.5 strength. Network is trained by SGD with a
learning rate of 0.1 for 5k epochs. The networks
are trained on 200 mini-batches with 32 sequences
and tested on 10k sequences.
Results.
Table 1 reports the results on the
Temporal Order task when recurrent dropout is
applied using our method and methods from
Us-
(Moon et al., 2015) and

(Gal, 2015).

ing dropout from (Moon et al., 2015) with per-
sequence sampling, networks are able to discover
the long-term dependency, but fail to use it on
the test set due to the scaling issue. Interestingly,
in Medium case results on the test set are worse
than random. Networks trained with per-step sam-
pling exhibit different behaviour: in Short case
they are capable of capturing the temporal de-
pendency and generalizing to the test set, but re-
quire 10-20 times more iterations to do so.
In
Medium case these networks do not ﬁt into the
allocated number of iterations. This suggests that
applying dropout to hidden states as suggested in
(Moon et al., 2015) corrupts memory cells hinder-
ing the long-term memory capacity of LSTMs.

In contrast, using our recurrent dropout meth-
ods, networks are able to solve the problem in all
cases. We have also ran the same experiments for
longer sequences, but found that the results are
equivalent to the Medium case. We also note that
the approach of (Gal, 2015) does not seem to ex-
hibit the memory loss problem.

4.2 Word Level Language Modeling

Data. Following Mikolov et al. (2011) we use
the Penn Treebank Corpus to train our Language
Modeling (LM) models. The dataset contains ap-
proximately 1 million words and comes with pre-
deﬁned training, validation and test splits, and a
vocabulary of 10k words.
In our LM experiments we use recur-
Setup.
rent networks with a single layer with 256 cells.
Network parameters were initialized uniformly in
[-0.05, 0.05]. For training, we use plain SGD
with batch size 32 with the maximum norm gradi-
ent clipping (Pascanu et al., 2013). Learning rate,
clipping threshold and number of Backpropaga-
tion Through Time (BPTT) steps were set to 1,
10 and 35 respectively. For the learning rate de-
cay we use the following strategy: if the valida-
tion error does not decrease after each epoch, we
divide the learning rate by 1.5. The aforemen-
tioned choices were largely guided by the work
of Mikolov et al. (2014). To ease reproducibility
of our results on the LM and synthetic tasks, we
have released the source code of our experiments1.
Results. Table 2 reports the results for LSTM
networks. We also present results when the
dropout is applied directly to hidden states as
in (Moon et al., 2015) and results of networks

1https://github.com/stas-semeniuta/drop-rnn

Sampling

Moon et al. (2015)
short sequences medium sequences
Test
Train

Train

Test

Gal (2015); Ours
short sequences medium sequences
Test
Train

Train

Test

per-step
per-sequence

100% 100% 25%
25% 100%
100%

25% 100% 100% 100%
<25% 100% 100% 100%

100%
100%

Table 1: Accuracies on the Temporal Order task.

Dropout rate

Sampling

Moon et al. (2015)
Test
Valid

Gal (2015)
Test

Valid

Ours

Valid

Test

0.0
0.25
0.5
0.25
0.5

0.0
0.25
0.5
0.25
0.5

–
per-step
per-step
per-sequence
per-sequence

–
per-step
per-step
per-sequence
per-sequence

130.0
113.0
124.0
121.0
137.7

94.1
113.5
140.6
105.7
125.4

125.2
108.7
116.5
113.0
126.2

89.5
105.8
130.1
99.9
117.4

130.0
119.8
118.3
120.5
125.2

94.1
92.9
98.6
94.5
98.4

125.2
114.2
112.5
114.0
117.9

89.5
88.4
92.5
89.7
92.5

130.0
106.1
102.8
106.3
103.2

94.1
91.6
100.6
92.4
107.8

125.2
100.0
98.0
100.7
96.8

89.5
87.0
95.5
87.6
101.8

Table 2: Perplexity scores of the LSTM network on word level Language Modeling task (lower is better).
Upper and lower parts of the table report results without and with forward dropout respectively. Networks
with forward dropout use 0.2 and 0.5 dropout rates in input and output connections respectively. Values
in bold show best results for each of the recurrent dropout schemes with and without forward dropout.

trained with the dropout scheme of (Gal, 2015).
We make the following observations: (i) our ap-
proach shows better results than the alternatives;
(ii) per-step mask sampling is better when drop-
ping hidden state directly; (iii) on this task our
method using per-step sampling seems to yield re-
sults similar to per-sequence sampling; (iv) in this
case forward dropout yields better results than any
of the three recurrent dropouts; and ﬁnally (v) both
our approach and that of (Gal, 2015) are effective
when combined with the forward dropout, though
ours is more effective.

We make the following observations: (i) drop-
ping hidden state updates yields better results than
dropping hidden states; (ii) per-step mask sam-
pling is better when dropping hidden state directly;
(iii) contrary to our expectations, when we apply
dropout to hidden state updates per-step sampling
seems to yield results similar to per-sequence sam-
pling; (iv) applying dropout to hidden state up-
dates rather than hidden states in some cases leads
to a perplexity decrease by more than 30 points;
and ﬁnally (v) our approach is effective even when

combined with the forward dropout – for LSTMs
we are able to bring down perplexity on the vali-
dation set from 130 to 91.6.

To demonstrate the effect of our approach on the
learning process, we also present learning curves
of LSTM networks trained with and without re-
current dropout (Fig. 2). Models trained using
our recurrent dropout scheme have slower con-
vergence than models without dropout and usu-
ally have larger training error and lower validation
errors. This behaviour is consistent with what is
expected from a regularizer and is similar to the
effect of the feed-forward dropout applied to non-
recurrent networks (Hinton et al., 2012).

4.3 Character Level Language Modeling

Data. We train our networks on the dataset de-
scribed in the previous section. It contains approx-
imately 6 million characters, and a vocabulary of
50 characters. We use the provided partitions train,
validation and test partitions.
Setup. We use networks with 1024 units to solve
the character level LM task. The characters are

Dropout rate

Sampling

Moon et al. (2015)
Valid

Test Valid

Gal (2015)
Test

Ours

Valid

Test

0.0
0.25
0.5
0.25
0.5

0.0
0.25
0.5
0.25
0.5

–
per-step
per-step
per-sequence
per-sequence

–
per-step
per-step
per-sequence
per-sequence

1.460
1.435
1.610
1.433
1.691

1.362
1.471
1.668
1.455
1.681

1.457
1.394
1.561
1.390
1.647

1.326
1.428
1.622
1.413
1.637

1.460
1.345
1.387
1.341
1.408

1.362
1.381
1.463
1.387
1.477

1.457
1.308
1.348
1.304
1.369

1.326
1.344
1.425
1.348
1.435

1.460
1.338
1.355
1.356
1.496

1.362
1.358
1.422
1.403
1.567

1.457
1.301
1.316
1.319
1.450

1.326
1.321
1.380
1.363
1.522

Table 3: Bit-per-character scores of the LSTM network on character level Language Modelling task
(lower is better). Upper and lower parts of the table report results without and with forward dropout re-
spectively. Networks with forward dropout use 0.2 and 0.5 dropout rates in input and output connections
respectively. Values in bold show best results for each of the recurrent dropout schemes with and without
forward dropout.

with dropout
without dropout

9

8

7

6

5

4

3
0

5000 10000 15000 20000 25000 30000

Figure 2: Learning curves of LSTM networks
when training without and with 0.25 per-step re-
current dropout. Solid and dashed lines show
training and validation errors respectively. Best
viewed in color.

embedded into 256 dimensional space before be-
ing processed by the LSTM. All parameters of
the networks are initialized uniformly in [-0.01,
0.01]. We train our networks on non-overlapping
sequences of 100 characters. The networks are
trained with the Adam (?) algorithm with initial
learning rate of 0.001 for 50 epochs. We decrease
the learning rate by 0.97 after every epoch starting
from epoch 10. To avoid exploding gradints, we
use MaxNorm gradient clipping with threshold set
to 10.
Results. Results of our experiments are given
in Table 3. Note that on this task regulariz-
ing only the recurrent connections is more ben-
eﬁcial than only the forward ones.
In particu-
lar, LSTM networks trained with our approach
and the approach of (Gal, 2015) yield a lower
bit-per-character (bpc) score than those trained
with forward dropout onlyWe attribute it to pro-
nounced long term dependencies.
In addition,
our approach is the only one that improves over
baseline LSTM with forward dropout. The over-
all best result is achieved by a network trained
with our dropout with 0.25 dropout rate and per-
step sampling, closely followed by network with
Gal (2015) dropout.

4.4 Named Entity Recognition

Data. To assess our recurrent Named Entity
Recognition (NER) taggers when using recurrent
dropout we use a public benchmark from CONLL

2003
(Tjong Kim Sang and De Meulder, 2003).
The dataset contains approximately 300k words
split into train, validation and test partitions. Each
word is labeled with either a named entity class
it belongs to, such as Location or Person, or
as being not named. The majority of words are
labeled as not named entities. The vocabulary size
is about 22k words.

Previous state-of-the-art NER systems
Setup.
have shown the importance of using word con-
text features around entities. Hence, we slightly
modify the architecture of our recurrent networks
to consume the context around the target word
by simply concatenating their embeddings. The
size of the context window is ﬁxed to 5 words
(the word to be labeled, two words before and
two words after). The recurrent
layer size is
1024 units. The network inputs include only word
embeddings (initialized with pretrained word2vec
embeddings (Mikolov et al., 2013) and kept static)
and capitalization features. For training we use the
RMSProp algorithm (Dauphin et al., 2015) with ρ
ﬁxed at 0.9 and a learning rate of 0.01 and mul-
tiply the learning rate by 0.99 after every epoch.
We also combine our recurrent dropout (with per-
sequence mask sampling) with the conventional
forward dropout with the rate 0.2 in input and 0.5
in output connections. Lastly, we found that us-
ing relu(x) = max(x, 0) nonlinearity resulted in
higher performance than tanh(x).

To speed up the training we use a length ex-
pansion approach described in (Ng et al., 2015),
where training is performed in two stages: (i) we
ﬁrst sample short 5-words input sequences with
their contexts and train for 25 epochs; (ii) we
ﬁne tune the network on input 15-words sequences
for 10 epochs. We found that further ﬁne tuning
on longer sequences yielded negligible improve-
ments. Such strategy allows us to signiﬁcantly
speed up the training when compared to training
from scratch on full-length input sentences. We
use full sentences for testing.

Results. F1 scores of our taggers are reported in
Table 4 when trained on short 5-word and longer
15-word input sequences. We note that the gap
between networks trained with and without our
dropout scheme is larger for networks trained on
shorter sequences. It suggests that dropout in re-
current connections might have an impact on how
well a network generalizes to sequences that are
longer than the ones used during training. The

Dropout rate RNN LSTM GRU

5 word long sequences
85.32
85.60
86.42
86.48

0.0
0.25

15 word long sequences
86.12
86.95

86.12
86.88

0.0
0.25

86.00
86.70

86.44
87.10

Table 4: F1 scores (higher is better) on NER task.

gain from using recurrent dropout is larger for
the LSTM network. We have experimented with
higher recurrent dropout rates, but found that it
led to excessive regularization.

4.5 Twitter Sentiment Analysis

We

sentiment

use Twitter

(Rosenthal et al., 2015).

cor-
Data.
from SemEval-2015 Task 10 (subtask
pus
B)
It contains 15k
labeled tweets split into training and validation
partitions. The total number of words is approx-
imately 330k and the vocabulary size is 22k.
The task consists of classifying a tweet into three
classes: positive, neutral, and negative.
Performance of a classiﬁer is measured by the av-
erage of F1 scores of positive and negative
classes. We evaluate our models on a number of
datasets that were used for benchmarking during
the last years.
Setup. We use recurrent networks in the standard
sequence labeling manner - we input words to a
network one by one and take the label at the last
step. Similarly to (Severyn and Moschitti, 2015),
we use 1 million of weakly labeled tweets to pre-
train our networks. We use networks composed of
500 neurons in all cases. Our models are trained
with the RMSProp algorithm with a learning rate
of 0.001. We use our recurrent dropout regular-
ization with per-step mask sampling. All the other
settings are equivalent to the ones used in the NER
task.
Results. The results of these experiments are pre-
sented in Table 5. Note that in this case our al-
gorithm decreases the performance of the vanilla
RNNs while this is not the case for LSTM and
GRU networks. This is due to the nature of the
problem: differently from LM and NER tasks,
a network needs to aggregate information over a
long sequence. Vanilla RNNs notoriously have
difﬁculties with this and our dropout scheme im-

Dropout rate Twitter13 LiveJournal14 Twitter15 Twitter14 SMS13 Sarcasm14

0
0.25

0
0.25

0
0.25

67.54
66.35

67.97
69.11

67.09
69.04

71.20
67.70

69.82
71.39

70.80
72.10

RNN

LSTM

GRU

59.35
59.91

57.84
61.35

59.07
60.34

68.90
67.76

67.95
68.08

67.02
69.65

64.51
64.46

61.47
65.45

67.11
65.73

53.58
48.74

53.49
53.80

51.01
54.77

Table 5: F1 scores (higher is better) on Sentiment Evaluation task

pairs their ability to remember even further. The
best result over most of the datasets is achieved
by the GRU network with recurrent dropout. The
only exception is the Twitter2015 dataset, where
the LSTM network shows better results.

5 Conclusions

This paper presents a novel recurrent dropout
method speciﬁcally tailored to the gated recurrent
neural networks. Our approach is easy to im-
plement and is even more effective when com-
bined with conventional forward dropout. We
have shown that for LSTMs and GRUs applying
dropout to arbitrary cell vectors results in subopti-
mal performance. We discuss in detail the cause of
this effect and propose a simple solution to over-
come it. The effectiveness of our approach is ver-
iﬁed on three different public NLP benchmarks.

Our ﬁndings along with our empirical results
allow us to answer the questions posed in Sec-
tion 1: i) while is straight-forward to use dropout
in vanilla RNNs due to their strong similarity with
the feed-forward architectures, its application to
LSTM networks is not so straightforward. We
demonstrate that recurrent dropout
is most ef-
fective when applied to hidden state update vec-
tors in LSTMs rather than to hidden states; (ii)
we observe an improvement in the network’s per-
formance when our recurrent dropout is coupled
with the standard forward dropout,
though the
extent of this improvement depends on the val-
ues of dropout rates; (iii) contrary to our expec-
tations, networks trained with per-step and per-
sequence mask sampling produce similar results
when using our recurrent dropout method, both
being better than the dropout scheme proposed by
Moon et al. (2015).

While our experimental results show that ap-
plying recurrent dropout method leads to signif-
icant improvements across various NLP bench-
marks (especially when combined with conven-
tional forward dropout), its beneﬁts for other tasks,
e.g., sequence-to-sequence prediction, or other do-
mains, e.g., Speech Recognition, remain unex-
plored. We leave it as our future work.

Acknowledgments

This project has received funding from the Eu-
ropean Union’s Framework Programme for Re-
search and Innovation HORIZON 2020 (2014-
2020) under the Marie Skodowska-Curie Agree-
ment No. 641805. Stanislau Semeniuta thanks
the support from Pattern Recognition Company
GmbH. We gratefully acknowledge the support of
NVIDIA Corporation with the donation of the Ti-
tan X GPU used for this research.

References

[Bengio et al.1994] Yoshua

Bengio,

Patrice
Simard, and Paolo Frasconi. 1994. Learning
long-term dependencies with gradient descent
is difﬁcult.
IEEE Transactions on Neural
Networks, 5(2):157–166.

[Bengio et al.2015] Samy Bengio, Oriol Vinyals,
Navdeep Jaitly, and Noam Shazeer.
2015.
Scheduled sampling for sequence prediction
with recurrent neural networks.
CoRR,
abs/1506.03099.

[Bluche et al.2015] Theodore Bluche, Christopher
Kermorvant, and J´erˆome Louradour.
2015.
Where to apply dropout in recurrent neural net-

works for handwriting recognition? In 13th In-
ternational Conference on Document Analysis
and Recognition, ICDAR 2015, Tunis, Tunisia,
August 23-26, 2015, pages 681–685.

[Cho et al.2014] KyungHyun Cho, Bart van Mer-
rienboer, Dzmitry Bahdanau, and Yoshua Ben-
gio. 2014. On the properties of neural ma-
chine translation: Encoder-decoder approaches.
CoRR, abs/1409.1259.

[Dauphin et al.2015] Yann N. Dauphin, Harm
de Vries, Junyoung Chung, and Yoshua Bengio.
2015. Rmsprop and equilibrated adaptive learn-
ing rates for non-convex optimization. CoRR,
abs/1502.04390.

[Dyer et al.2015] Chris Dyer, Miguel Ballesteros,
Wang Ling, Austin Matthews, and A. Noah
Smith.
2015. Transition-based dependency
parsing with stack long short-term memory. In
ACL, pages 334–343. Association for Compu-
tational Linguistics.

[Gal2015] Yarin Gal.

A theoretically
grounded application of dropout in recurrent
neural networks. arXiv:1512.05287.

2015.

[Hinton et al.2012] Geoffrey E. Hinton, Nitish Sri-
vastava, Alex Krizhevsky, Ilya Sutskever, and
Ruslan Salakhutdinov. 2012. Improving neural
networks by preventing co-adaptation of feature
detectors. CoRR, abs/1207.0580.

[Hochreiter and Schmidhuber1997] Sepp Hochre-
1997. Long
Neural Comput.,

iter and J¨urgen Schmidhuber.
short-term memory.
9(8):1735–1780, November.

[Irsoy and Cardie2014] Ozan Irsoy and Claire
Cardie. 2014. Opinion mining with deep re-
In Proceedings of
current neural networks.
the 2014 Conference on Empirical Methods in
Natural Language Processing (EMNLP), pages
720–728. Association for Computational Lin-
guistics.

[Karpathy et al.2015] Andrej Karpathy,

Justin
Johnson, and Fei-Fei Li. 2015. Visualizing
and understanding recurrent networks. CoRR,
abs/1506.02078.

[Kim et al.2015] Yoon Kim, Yacine

Jernite,
David Sontag, and Alexander M. Rush. 2015.
Character-aware
language models.
CoRR, abs/1508.06615.

neural

[Krizhevsky et al.2012] Alex Krizhevsky,
Ilya
2012.
Sutskever, and Geoffrey E. Hinton.
Imagenet classiﬁcation with deep convolutional
In F. Pereira, C.J.C. Burges,
neural networks.
editors,
L. Bottou, and K.Q. Weinberger,
Advances
Information Process-
ing Systems 25, pages 1097–1105. Curran
Associates, Inc.

in Neural

[Le et al.2015] Quoc V. Le, Navdeep Jaitly, and
Geoffrey E. Hinton. 2015. A simple way to
initialize recurrent networks of rectiﬁed linear
units. CoRR, abs/1504.00941.

[Liu et al.2015] Pengfei Liu, Xipeng Qiu, Xinchi
Chen, Shiyu Wu, and Xuanjing Huang. 2015.
Multi-timescale long short-term memory neu-
ral network for modelling sentences and docu-
ments. In ACL. Association for Computational
Linguistics.

[Mikolov et al.2011] T. Mikolov, S. Kombrink,
L. Burget, J.H. Cernocky, and Sanjeev Khudan-
pur. 2011. Extensions of recurrent neural net-
In Acoustics, Speech
work language model.
and Signal Processing (ICASSP), 2011 IEEE
International Conference on, pages 5528–5531,
May.

[Mikolov et al.2013] Tomas

Mikolov,

Ilya
Sutskever, Kai Chen, Greg S Corrado, and
Jeff Dean. 2013. Distributed representations of
words and phrases and their compositionality.
In C.J.C. Burges, L. Bottou, M. Welling,
Z. Ghahramani, and K.Q. Weinberger, editors,
Information Process-
Advances
ing Systems 26, pages 3111–3119. Curran
Associates, Inc.

in Neural

[Mikolov et al.2014] Tomas Mikolov, Armand
Joulin, Sumit Chopra, Micha¨el Mathieu, and
Marc’Aurelio Ranzato. 2014. Learning longer
memory in recurrent neural networks. CoRR,
abs/1412.7753.

[Moon et al.2015] Taesup Moon, Heeyoul Choi,
Hoshik Lee, and Inchul Song.
2015. Rn-
ndrop: A novel dropout for rnns in asr. Au-
tomatic Speech Recognition and Understanding
(ASRU).

[Ng et al.2015] Joe Yue-Hei Ng, Matthew J.
Hausknecht, Sudheendra Vijayanarasimhan,
and George
Oriol Vinyals, Rajat Monga,

2015.

Toderici.
Beyond short snippets:
Deep networks for video classiﬁcation. CoRR,
abs/1503.08909.

[Pascanu et al.2013] Razvan

Pascanu,

Tomas
Mikolov, and Yoshua Bengio. 2013. On the
difﬁculty of training recurrent neural networks.
In Proceedings of the 30th International Con-
ICML 2013,
ference on Machine Learning,
Atlanta, GA, USA, 16-21 June 2013, pages
1310–1318.

[Pham et al.2013] Vu Pham, Christopher Kermor-
vant, and J´erˆome Louradour. 2013. Dropout
improves recurrent neural networks for hand-
writing recognition. CoRR, abs/1312.4569.

[Rosenthal et al.2015] Sara Rosenthal,

Preslav
Nakov, Svetlana Kiritchenko, Saif Mohammad,
Alan Ritter, and Veselin Stoyanov.
2015.
Semeval-2015 task 10: Sentiment analysis in
twitter. In Proceedings of the 9th International
Workshop on Semantic Evaluation (SemEval
2015), pages 451–463, Denver, Colorado, June.
Association for Computational Linguistics.

[Severyn and Moschitti2015] Aliaksei

2015.

Severyn
Twitter
and Alessandro Moschitti.
sentiment analysis with deep convolutional
neural networks.
In Proceedings of the 38th
International ACM SIGIR Conference on
in Information
Research and Development
Retrieval, Santiago, Chile, August 9-13, 2015,
pages 959–962.

[Sutskever et al.2014] Ilya

Oriol
Vinyals, and Quoc V. Le. 2014. Sequence to

Sutskever,

sequence learning with neural networks.
NIPS, pages 3104–3112.

In

[Tjong Kim Sang and De Meulder2003] Erik

F.
Tjong Kim Sang and Fien De Meulder. 2003.
Introduction to the conll-2003 shared task:
Language-independent named entity recogni-
tion. In Proceedings of the Seventh Conference
on Natural Language Learning at HLT-NAACL
2003 - Volume 4, CONLL ’03, pages 142–
147, Stroudsburg, PA, USA. Association for
Computational Linguistics.

[Wang et al.2015] Xin Wang, Yuanchao Liu,
Chengjie SUN, Baoxun Wang, and Xiaolong
Wang. 2015. Predicting polarities of tweets
by composing word embeddings with long
short-term memory. In ACL, pages 1343–1353.
Association for Computational Linguistics.

[Zaremba et al.2014] Wojciech Zaremba,

Ilya
Sutskever, and Oriol Vinyals. 2014. Recur-
rent neural network regularization.
CoRR,
abs/1409.2329.

[Zhang and Lapata2014] Xingxing Zhang

and
2014. Chinese poetry gen-
Mirella Lapata.
eration with recurrent neural networks.
In
Proceedings of the 2014 Conference on Empir-
ical Methods in Natural Language Processing
(EMNLP), pages 670–680. Association for
Computational Linguistics.

[Zhang et al.2015] Xingxing Zhang, Liang Lu, and
Mirella Lapata. 2015. Tree recurrent neural
networks with application to language model-
ing. CoRR, abs/1511.00060.

