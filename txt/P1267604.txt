Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Kyle E. Helfrich * 1 Devin Willmott * 1 Qiang Ye 1

Abstract

8
1
0
2
 
n
u
J
 
9
1
 
 
]
L
M

.
t
a
t
s
[
 
 
3
v
0
2
5
9
0
.
7
0
7
1
:
v
i
X
r
a

Recurrent Neural Networks (RNNs) are designed
to handle sequential data but suffer from vanish-
ing or exploding gradients. Recent work on Uni-
tary Recurrent Neural Networks (uRNNs) have
been used to address this issue and in some cases,
exceed the capabilities of Long Short-Term Mem-
ory networks (LSTMs). We propose a simpler
and novel update scheme to maintain orthogonal
recurrent weight matrices without using complex
valued matrices. This is done by parametrizing
with a skew-symmetric matrix using the Cayley
transform; such a parametrization is unable to rep-
resent matrices with negative one eigenvalues, but
this limitation is overcome by scaling the recur-
rent weight matrix by a diagonal matrix consisting
of ones and negative ones. The proposed training
scheme involves a straightforward gradient calcu-
lation and update step. In several experiments, the
proposed scaled Cayley orthogonal recurrent neu-
ral network (scoRNN) achieves superior results
with fewer trainable parameters than other unitary
RNNs.

1. Introduction

Deep neural networks have been used to solve numerical
problems of varying complexity. RNNs have parameters
that are reused at each time step of a sequential data point
and have achieved state of the art performance on many se-
quential learning tasks. Nearly all optimization algorithms
for neural networks involve some variant of gradient descent.
One major obstacle to training RNNs with gradient descent
is due to vanishing or exploding gradients, as described in
Bengio et al. (1993) and Pascanu et al. (2013). This prob-
lem refers to the tendency of gradients to grow or decay
exponentially in size, resulting in gradient descent steps that
are too small to be effective or so large that the network

*Equal contribution 1Department of Mathematics, Univer-
sity of Kentucky, Lexington, Kentucky, USA. Correspondence
to: Kyle Helfrich <kyle.helfrich@uky.edu>, Devin Willmott
<devin.willmott@uky.edu>.

Proceedings of the 35 th International Conference on Machine
Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018
by the author(s).

oversteps the local minimum. This issue signiﬁcantly di-
minishes RNNs’ ability to learn time-based dependencies,
particularly in problems with long input sequences.

A variety of architectures have been introduced to overcome
this difﬁculty. The current preferred RNN architectures are
those that introduce gating mechanisms to control when in-
formation is retained or discarded, such as LSTMs (Hochre-
iter & Schmidhuber, 1997) and GRUs (Cho et al., 2014),
at the cost of additional trainable parameters. More re-
cently, the unitary evolution RNN (uRNN) (Arjovsky et al.,
2016) uses a parametrization that forces the recurrent weight
matrix to remain unitary throughout training, and exhibits
superior performance to LSTMs on a variety of testing prob-
lems. For clarity, we follow the convention of Wisdom et al.
(2016) and refer to this network as the restricted-capacity
uRNN.

Since the introduction of uRNNs, orthogonal and unitary
RNN schemes have increased in both popularity and com-
plexity. Wisdom et al. (2016) use a multiplicative update
method detailed in Tagare (2011) and Wen & Yin (2013)
to expand uRNNs’ capacity to include all unitary matrices.
These networks are referred to as full-capacity uRNNs. Jing
et al. (2016) and Mhammedi et al. (2017) parametrize the
space of unitary/orthogonal matrices with Givens rotations
and Householder reﬂections, respectively, but typically opti-
mize over a subset of this space by restricting the number of
parameters. Another complex parametrization has also been
explored in Hyland & Gunnar (2017). There is also work
using unitary matrices in GRUs (i.e. in GORU of Jing et al.
(2017)) or near-unitary matrices in RNNs by restricting the
singular values of the recurrent matrix to an interval around
1 (see Vorontsov et al. (2017)). For other work in addressing
the vanishing and exploding gradient problem, see Henaff
et al. (2017) and Le et al. (2015).

In this paper, we consider RNNs with a recurrent weight
matrix taken from the set of all orthogonal matrices. To
construct the orthogonal weight matrix, we parametrize
it with a skew-symmetric matrix through a scaled Cayley
transform. This scaling allows us to avoid the singularity
issue occurring for −1 eigenvalues that may arise in the
standard Cayley transform. By tuning this scaling matrix,
the network can reach an appropriate orthogonal matrix
using a relatively simple gradient descent update step. The
resulting method achieves superior performance on various
sequential data tasks.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

The method we present in this paper works entirely with real
matrices, and as such, our results deal only with orthogonal
and skew-symmetric matrices. However, the method and all
related theory remain valid for unitary and skew-Hermitian
matrices in the complex case. The experimental results in
this paper indicate that state of the art performance can be
achieved without using complex matrices to optimize along
the Stiefel manifold.

2. Background

2.1. Recurrent Neural Networks

A recurrent neural network (RNN) is a function with input
parameters U ∈ Rn×m, recurrent parameters W ∈ Rn×n,
recurrent bias b ∈ Rn, output parameters V ∈ Rp×n, and
output bias c ∈ Rp where m is the data input size, n is the
number of hidden units, and p is the output data size. From
an input sequence x = (x1, x2, ..., xT ) where xi ∈ Rm, the
RNN returns an output sequence y = (y1, y2, ..., yT ) where
each yi ∈ Rp is given recursively by

ht = σ (U xt + W ht−1 + b)
yt = V ht + c

where h = (h0, . . . , hT −1), hi ∈ Rn is the hidden layer
state at time i and σ(·) is the activation function, which is
often a pointwise nonlinearity such as a hyperbolic tangent
function or rectiﬁed linear unit (Nair & Hinton, 2010).

2.2. Unitary RNNs

A real matrix W is orthogonal if it satisﬁes W T W = I. The
complex analog of orthogonal matrices are unitary matrices,
which satisfy W ∗W = I, where ∗ denotes the conjugate
transpose. Orthogonal and unitary matrices have the desir-
able property that (cid:107)W x(cid:107)2 = (cid:107)x(cid:107)2 for any vector x. This
property motivates the use of orthogonal or unitary matrices
in RNNs to avoid vanishing and exploding gradients, as
detailed in Arjovsky et al. (2016).

Arjovsky et al. (2016) follow the framework of the previous
section for their restricted-capacity uRNN, but introduce a
parametrization of the recurrent matrix W using a product
of simpler matrices. This parameterization is given by a
product consisting of diagonal matrices with complex norm
1, complex Householder reﬂection matrices, discrete Fourier
transform matrices, and a ﬁxed permutation matrix with the
resulting product being unitary. The Efﬁcient Unitary RNN
(EURNN) by Jing et al. (2016) and orthogonal RNN (oRNN)
by Mhammedi et al. (2017) parametrize in a similar manner
with products of Givens rotation matrices and Householder
reﬂection matrices, respectively. This can also be seen in
the parametrization through matrix exponentials in Hyland
& Gunnar (2017), which does not appear to perform as well
as the restricted-capacity uRNN.

Wisdom et al. (2016) note that this representation has only
7n parameters, which is insufﬁcient to represent all unitary
matrices for n > 7.
In response, they present the full-
capacity uRNN, which uses a multiplicative update step that
is able to reach all unitary matrices of order n.

The full-capacity uRNN aims to construct a unitary ma-
trix W (k+1) from W (k) by moving along a curve on the
Stiefel manifold {W ∈ Cn×n | W ∗W = I}. For the
network optimization, it is necessary to use a curve that is
in a descent direction of the cost function L := L(W ). In
Tagare (2011), Wen & Yin (2013), Wisdom et al. (2016), and
Vorontsov et al. (2017), a descent direction is constructed
as B(k)W (k), which is a representation of the derivative
operator DL(W (k)) in the tangent space of the Stiefel man-
ifold at W (k). Then, with B(k)W (k) deﬁning the direction
of a descent curve, an update along the Stiefel manifold is
obtained using the Cayley transform as

(cid:18)

(cid:19)−1 (cid:18)

(cid:19)

W (k+1) =

I +

B(k)

I −

B(k)

W (k)

(1)

λ
2

λ
2

where λ is the learning rate.

3. Scaled Cayley Orthogonal RNN

3.1. Cayley Transform

The Cayley transform gives a representation of orthogonal
matrices without −1 eigenvalues using skew-symmetric
matrices (i.e., matrices where AT = −A):

W = (I + A)−1 (I − A) , A = (I + W )−1 (I − W ) .

This bijection parametrizes the set of orthogonal matri-
ces without −1 eigenvalues with skew-symmetric matrices.
This direct and simple parametrization is attractive from a
machine learning perspective because it is closed under addi-
tion: the sum or difference of two skew-symmetric matrices
is also skew-symmetric, so we can use gradient descent
algorithms like RMSprop (Tieleman & Hinton, 2012) or
Adam (Kingma & Ba, 2014) to train parameters.

However, this parametrization cannot represent orthogonal
matrices with −1 eigenvalues, since in this case I +W is not
invertible. Theoretically, we can still represent matrices with
eigenvalues that are arbitrarily close to −1; however, it can
require large entries of A. For example, a 2x2 orthogonal
matrix W with eigenvalues ≈ −0.99999 ± 0.00447i and its
parametrization A by the Cayley transform is given below,
where α = 0.99999.

(cid:20)

W =

√

−α
1 − α2

(cid:21)

√

−

1 − α2
−α

(cid:20)

, A ≈

0
−447.212

447.212
0

(cid:21)

Gradient descent algorithms will learn this A matrix very
slowly, if at all. This difﬁculty can be overcome through a

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

suitable diagonal scaling according to results from Kahan
(2006).

Theorem 3.1 Every orthogonal matrix W can be expressed
as

W = (I + A)−1(I − A)D

where A = [aij] is real-valued, skew-symmetric with
|aij| ≤ 1, and D is diagonal with all nonzero entries equal
to ±1.

We call the transform in Theorem 3.1 the scaled Cayley
transform. Then, with an appropriate choice of D, the
scaled Cayley transform can reach any orthogonal matrix
including those with −1 eigenvalues. Further, it ensures that
the skew-symmetric matrix A that generates the orthogonal
matrix will be bounded.

Our proposed network, the scaled Cayley orthogonal recur-
rent neural network (scoRNN), is based on this theorem.
We parametrize the recurrent weight matrix W through a
skew-symmetric matrix A, which results in n(n−1)
trainable
weights. The recurrent matrix W is formed by the scaled
Cayley transform: W = (I + A)−1(I − A)D. The scoRNN
then operates identically to the set of equations given in Sec-
tion 2.1, but during training we update the skew-symmetric
matrix A using gradient descent, while D is ﬁxed through-
out the training process. The number of −1s on the diagonal
of D, which we call ρ, is considered a hyperparameter in
this work and is manually chosen based on the task.

2

3.2. Update Scheme

To update the recurrent parameter matrix A as described
in Section 3.1, we must ﬁnd the gradients of A by back-
propagating through the Cayley transform. The following
theorem describes these gradients. A proof is given in the
supplemental material.
Theorem 3.2 Let L = L(W ) : Rn×n → R be some differ-
entiable loss function for an RNN with the recurrent weight
matrix W . Let W = W (A) := (I + A)−1 (I − A) D
where A ∈ Rn×n is skew-symmetric and D ∈ Rn×n is
a ﬁxed diagonal matrix consisting of -1 and 1 entries. Then
the gradient of L = L(W (A)) with respect to A is

A(k+1) = A(k) − λ

∂L(W (A(k)))
∂A
I + A(k+1)(cid:17)−1 (cid:16)

(cid:16)

I − A(k+1)(cid:17)

D

W (k+1) =

The skew-symmetry of ∂L
symmetric and, in turn, W (k+1) will be orthogonal.

∂A ensures that A(k+1) will be skew-

The orthogonality of the recurrent matrix is maintained
to the order of machine precision, see section 5.5.1. The
scoRNN also maintains stable hidden state gradients in the
sense that the gradient norm does not change signiﬁcantly
in time, see section 5.5.2 for experimental results. This is
achieved with small overhead computational costs over the
standard RNN, see section 5.5.3 for experimental results
concerning computational efﬁciency.

The scoRNN, full-capacity uRNN, EURNN, and oRNN
models all have the theoretical capacity to optimize over
all orthogonal or unitary recurrent matrices, but their opti-
mization schemes are different. The full-capacity uRNN
performs a multiplicative update that moves W along the
tangent space of the Stiefel manifold, which is shown to
be a descent direction. The scoRNN, the EURNN, and
the oRNN use three different representations of orthogonal
matrices. The euRNN and oRNN express an orthogonal
matrix as a long product of simple orthogonal matrices
(Givens rotations and Householder reﬂections resp.) while
the scoRNN uses a single rational transformation. They all
use the steepest descent with respect to their correspond-
ing parametrizations. Here, different parametrizations have
different nonlinearities and hence different optimization
difﬁculties. We note that EURNN and oRNN are usually im-
plemented in a reduced capacity setting that uses a truncated
product. In our testing, it appears that increasing capacity
in EURNN and oRNN may not improve their performance.

Similar to the EURNN and oRNN, scoRNN may also be
implemented by restricting the A matrix to a banded skew-
symmetric matrix with bandwidth (cid:96) to reduce the number
of trainable parameters. Although this may work well for
particular tasks, such a modiﬁcation introduces an additional
hyperparameter and reduces representational capacity for
the recurrent weight matrix without any reduction in the
dimension of the hidden state.

∂L
∂A

= V T − V

(2)

4. Other Architecture Details

where V := (I + A)−T ∂L
∂W
(cid:105)

Rn×n, and ∂L

∂W =

(cid:104) ∂L
∂Wi,j

∈ Rn×n.

(cid:0)D + W T (cid:1), ∂L

∂A =

(cid:105)

(cid:104) ∂L
∂Ai,j

∈

At each training step of scoRNN, we ﬁrst use the standard
backpropagation algorithm to compute ∂L
∂W and then use
Theorem 3.2 to compute ∂L
∂A . We then update A with gradi-
ent descent (or a related optimization method), and recon-
struct W as follows:

The basic architecture of scoRNN is very similar to the
standard RNN as presented in Section 2.1. From a network
layer perspective, one can think of the application of the
recurrent weight in a three layer process. Let ht ∈ Rn be
the current state of the scoRNN at a particular time step, t.
We then pass ht through the following layers:
• Layer 1: ht → Dht =: h(1)
• Layer 2: h(1)

t → (I − A) h(1)

t =: h(2)

t

t

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

• Layer 3: h(2)

t → (I + A)−1 h(2)

t =: h(3)

t

5. Experiments

Note that the above scheme is the same as taking ht → W ht
as discussed previously.

4.1. MODRELU Activation Function

The modReLU function was ﬁrst implemented by Ar-
jovsky et al. (2016) to handle complex valued functions
and weights. Unlike previous methods, our method only
uses real-valued functions and weights. Nevertheless, we
have found that the modReLU function in the real case
also performed better than other activation functions. The
function is deﬁned as

σmodReLU(z) =

σReLU (|z| + b)

5.1. Copying Problem

z
|z|
(cid:40) z

=

|z| (|z| + b)
0

if |z| + b ≥ 0
if |z| + b < 0

In the following experiments, we compare the scoRNN
against LSTM and several other orthogonal and unitary
RNN models. Code for these experiments is available at
https://github.com/SpartinStuff/scoRNN.
For each experiment, we found optimal hyperparameters
for scoRNN using a grid search. For other models, we used
the best hyperparameter settings as reported for the same
testing problems, when applicable, or performed a grid
search to ﬁnd hyperparameters. For the LSTM, the forget
gate bias was tuned over the integers −4 to 4 with it set to
1.0 unless otherwise noted.

This experiment follows descriptions found in Jing et al.
(2016), Arjovsky et al. (2016), and Wisdom et al. (2016),
and tests an RNN’s ability to reproduce a sequence seen
many timesteps earlier. In the problem setup, there are 10
input classes, which we denote using the digits 0-9, with 0
being used as a ’blank’ class and 9 being used as a ’marker’
class. The RNN receives an input sequence of length T +20.
This sequence consists of entirely zeros, except for the ﬁrst
ten elements, which are uniformly sampled from classes
1-8, and a 9 placed ten timesteps from the end. The goal
for the machine is to output zeros until it sees a 9, at which
point it should output the ten elements from the beginning
of the input sequence. Thus, information must propagate
from the beginning to the end of the sequence for a machine
to successfully learn this task, making it critical to avoid
vanishing/exploding gradients.

A baseline strategy with which to compare machine perfor-
mance is that of outputting 0 until the machine sees a 9,
and then outputting 10 elements randomly sampled from
classes 1-8. The expected cross-entropy for such a strategy
is 10 log (8)
T +20 . In practice, it is common to see gated RNNs
such as LSTMs converge to this local minimum.

We use hyperparameters and hidden unit sizes as reported in
experiments in Arjovsky et al. (2016), Wisdom et al. (2016),
and Jing et al. (2016). This results in an LSTM with n = 68,
a restricted-capacity uRNN with n = 470, a full-capacity
uRNN with n = 128, and a tunable EURNN with n = 512
and capacity L = 2. As indicated in Mhammedi et al.
(2017), we were unable to obtain satisfactory performance
for the oRNN on this task. To match the ≈ 22k trainable
parameters in the LSTM and uRNNs, we use a scoRNN
with n = 190. We found the best performance with the
scoRNN came from ρ = n/2, which gives an initial W
with eigenvalues distributed uniformly on the unit circle.

Figure 1 compares each model’s performance for T = 1000
and T = 2000, with the baseline cross-entropy given as
a dashed line. In both cases, cross entropy for the LSTM,

where b is a trainable bias. In the real case, this simpliﬁes to
sign(z)σReLU(|z|+b). To implement this activation function
in scoRNN, we replace the computation of ht in Section 2.1
with

zt = U xt + W ht−1
ht = σmodReLU(zt)

We believe that the improved performance of the modReLU
over other activation functions, such as ReLU, is because it
admits both positive and negative activation values, which
appears to be important for the state transition in orthogonal
RNNs. This is similar to the hyperbolic tangent function but
does not have vanishing gradient issues.

4.2. Initialization

Modifying the initialization of our parameter matrices, in
particular our recurrent parameter matrix A, had an effect
on performance. The most effective initialization method
we found uses a technique inspired by Henaff et al. (2017).
We initialize all of the entries of A to be 0 except for 2x2
blocks along the diagonal, which are given as

B1






A =

. . .




 where Bj =

(cid:20) 0
−sj

(cid:21)

sj
0

B(cid:98)n/2(cid:99)

(cid:113) 1−cos (tj )

2

1+cos (tj ) and tj is sampled uniformly from
with sj =
(cid:2)0, π
(cid:3). The Cayley transform of this A will have eigen-
values equal to ±eitj for each j, which will be distributed
uniformly along the right unit half-circle. Multiplication
by the scaling matrix D will reﬂect ρ of these eigenvalues
across the imaginary axis. We use this method to initialize
scoRNN’s A matrix in all experiments listed in section 5.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Figure 1. Cross entropy of each machine on the copying problem with T = 1000 (left) and T = 2000 (right).

restricted-capacity uRNN, and EURNN remains at the base-
line or does not entirely converge over the entire experi-
ment. For the T = 1000 test, the full-capacity uRNN and
scoRNN converge immediately to zero entropy solutions,
with the full-capacity uRNN converging slightly faster. For
T = 2000, the full-capacity uRNN remains at the base-
line for several thousand iterations, but is eventually able to
ﬁnd a correct solution. In contrast, the scoRNN error has a
smooth convergence that bypasses the baseline, but does so
more slowly than the full-capacity uRNN.

uRNN. We tested both the tunable-style EURNN and FFT-
style EURNN with n = 512, and found better results from
the tunable-style (≈ 3k parameters) for sequence lengths
T = 200 and T = 400, and from the FFT-style (≈ 7k pa-
rameters) for sequence length T = 750. The best hyperpa-
rameters for the oRNN were in accordance with Mhammedi
et al. (2017) which was n = 128 with 16 reﬂections with
a learning rate of 0.01, ≈2.6k parameters. We found that
performance decreased when matching the number of reﬂec-
tions to the hidden size to increase the number of parameters.

5.2. Adding Problem

We examined a variation of the adding problem as proposed
by Arjovsky et al. (2016) which is based on the work of
Hochreiter & Schmidhuber (1997). This variation involves
passing two sequences concurrently into the RNN, each of
length T . The ﬁrst sequence is a sequence of digits sam-
pled uniformly with values ranging in a half-open interval,
U[0, 1). The second sequence is a marker sequence con-
sisting of all zeros except for two entries that are marked
by one. The ﬁrst 1 is located uniformly within the interval
[1, T
2 ) of the sequence and the second 1 is located uniformly
within the interval [ T
2 , T ) of the sequence. The label for
each pair of sequences is the sum of the two entries that
are marked by one, which forces the machine to identify
relevant information in the ﬁrst sequence among noise. As
the sequence length increases, it becomes more crucial to
avoid vanishing/exploding gradients. Naively predicting
one regardless of the sequence gives an expected mean
squared error (MSE) of approximately 0.167. This will be
considered as the baseline.

The number of hidden units for the LSTM, scoRNN and
uRNNs were adjusted so that each had approximately 15k
trainable parameters. This results in n = 170 for the
scoRNN, n = 60 for the LSTM, n = 120 for the Full-
Capacity uRNN, and n = 950 for the restricted-capacity

Figure 2. Test set MSE for each machine on the adding problem
with sequence lengths of T = 200 (top), T = 400 (middle), and
T = 750 (bottom).

The test set MSE results for sequence lengths T = 200,
T = 400, and T = 750 can be found in Figure 2. A training
set size of 100,000 and a testing set size of 10,000 were
used for each sequence length. For each case, the networks
start at or near the baseline MSE, except for the EURNN
for T = 750, and drop towards zero after a few epochs.
As the sequence length increases, the number of epochs

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

before the drop increases. We found the best settings for
the scoRNN were ρ = n/2 for T = 200 and ρ = 7n/10 for
T = 400 and T = 750. The forget bias for the LSTM was 2
for sequence length 200, 4 for sequence length 400, and 0
for sequence length 750. As can be seen, the LSTM error
drops precipitously across the board. Although the oRNN
begins to drop below the baseline before scoRNN, it has a
much more irregular descent curve, and jumps back to the
baseline after several epochs.

5.3. Pixel-by-Pixel MNIST

We ran two experiments based around classifying samples
from the well-known MNIST dataset (LeCun et al.). Follow-
ing the implementation of Le et al. (2015), each pixel of the
image is fed into the RNN sequentially, resulting in a single
pixel sequence length of 784. In the ﬁrst experiment, which
we refer to as unpermuted MNIST, pixels are arranged in
the sequence row-by-row. In the second, which we call
permuted MNIST, a ﬁxed permutation is applied to training
and testing sequences.

All scoRNN machines were trained with the RMSprop opti-
mization algorithm. Input and output weights used a learn-
ing rate of 10−3, while the recurrent parameters used a
learning rate of 10−4 (for n = 170) or 10−5 (for n = 360
and n = 512). For unpermuted MNIST, we found ρ to be
optimal at n/10, while the best value of ρ for permuted
MNIST was n/2. We suspect that the difference of these
two values comes from the different types of dependencies
in each: unpermuted MNIST has mostly local dependencies,
while permuted MNIST requires learning many long-term
dependencies, which appear to be more easily modeled
when the diagonal of D has a higher proportion of −1s.

Each experiment used a training set of 55,000 images and a
test set of 10,000 testing images. Each machine was trained
for 70 epochs, and test set accuracy, the percentage of test
images classiﬁed correctly, was evaluated at the conclusion
of each epoch. Figure 3 shows test set accuracy over time,
and the best performance over all epochs by each machine
is given in Table 1.

In both experiments, the 170 hidden unit scoRNN gives sim-
ilar performance to both of the 512 hidden unit uRNNs using
a much smaller hidden dimension and, in the case of the
full-capacity uRNN, an order of magnitude fewer parame-
ters. Matching the number of parameters (≈ 69k), the 2170
restricted-capacity uRNN performance was comparable to
the 360 hidden unit scoRNN for unpermuted MNIST, but
performed worse for permuted MNIST, and required a much
larger hidden size and a signiﬁcantly longer run time, see
5.5.3. As in experiments presented in Arjovsky et al. (2016)
and Wisdom et al. (2016), orthogonal and unitary RNNs
are unable to outperform the LSTM in the unpermuted case.
However, the 512 hidden unit scoRNN outperforms all other

Table 1. Results for unpermuted and permuted pixel-by-pixel
MNIST experiments. Evaluation accuracies are based on the best
test accuracy at the end of every epoch. Asterisks indicate reported
results from (Jing et al., 2016) and (Mhammedi et al., 2017).

PERMUTED

MODEL

N

#

MNIST MNIST

170 ≈ 16K
360 ≈ 69K
512 ≈ 137K
128 ≈ 68K
256 ≈ 270K
512 ≈ 1, 058K

SCORNN
SCORNN
SCORNN
LSTM
LSTM
LSTM
RESTRICTED URNN 512 ≈ 16K
RESTRICTED URNN 2170 ≈ 69K
116 ≈ 16K
FULL URNN
512 ≈ 270K
FULL URNN
≈ 9K
512
EURNN
256 ≈ 11K
ORNN

PARAMS TEST ACC. TEST ACC.
0.973
0.983
0.985
0.987
0.989
0.985
0.976
0.984
0.947
0.974
-
0.972∗

0.943
0.962
0.966
0.920
0.929
0.920
0.945
0.953
0.925
0.947
0.937∗
-

unitary RNNs. On permuted MNIST, the 512 hidden unit
scoRNN achieves a test-set accuracy of 96.6%, outperform-
ing all other machines. We believe this is a state of the art
result.

5.4. TIMIT Speech Dataset

To see how the models performed on audio data, speech pre-
diction was performed on the TIMIT dataset (Garofolo et al.,
1993), a collection of real-world speech recordings. Exclud-
ing the dialect SA sentences and using only the core test
set, the dataset consisted of 3,696 training and 192 testing
audio ﬁles. Similar to experiments in Wisdom et al. (2016),
audio ﬁles were downsampled to 8kHz and a short-time
Fourier transform (STFT) was applied with a Hann win-
dow of 256 samples and a window hop of 128 samples (16
milliseconds). The result is a set of frames, each with 129
complex-valued Fourier amplitudes. The log-magnitude of
these amplitudes is used as the input data for the machines.
For each model, the hidden layer sizes were adjusted such
that each model had approximately equal numbers of train-
able parameters. For scoRNN, we used the Adam optimizer
with learning rate 10−3 to train input and output parameters,
and RMSprop with a learning rate of 10−3 (for n = 224) or
10−4 (for n = 322, 425) to train the recurrent weight matrix.
The number of negative eigenvalues used was ρ = n/10.
The LSTM forget gate bias was initialized to -4.

The loss function used for training was the mean squared er-
ror (MSE) between the predicted and actual log-magnitudes
of the next time frame over the entire sequence. Table
2 contains the MSE on validation and testing sets, which
shows that all scoRNN models achieve a smaller MSE than

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Figure 3. Test accuracy for unpermuted and permuted MNIST over time. All scoRNN models and the best performing LSTM, restriced
capacity uRNN, and full-capacity uRNN are shown.

Due to the accumulation of rounding errors over a large
number of repeated matrix multiplications, the recurrent
weight may not remain unitary throughout training. To in-
vestigate this, we ran the scoRNN and full-capacity uRNN
with equal hidden unit sizes of n = 512 on the unpermuted
MNIST experiment and checked for loss of orthogonality
at each epoch. The results of this experiment are shown in
Figure 4. As can be seen, the recurrent weight matrix for
the full-capacity uRNN becomes less unitary over time, but
the orthogonality recurrent weight matrix for scoRNN is not
affected by roundoff errors.

This can become particularly apparent when performing op-
erations using a graphics processing unit (GPU) which have
a much lower machine precision than a standard computer
processing unit (CPU).

Table 2. Results for the TIMIT speech dataset. Evaluation based
on MSE and various audio metrics

N

MODEL

#
PARAMS
≈ 83K
224
SCORNN
322 ≈ 135K
SCORNN
425 ≈ 200K
SCORNN
≈ 83K
84
LSTM
120 ≈ 135K
LSTM
158 ≈ 200K
LSTM
≈ 83K
REST. URNN 158
REST. URNN 256 ≈ 135K
REST. URNN 378 ≈ 200K
≈ 83K
128
FULL URNN
192 ≈ 135K
FULL URNN
256 ≈ 200K
FULL URNN

VALID.
MSE
9.26
8.48
7.97
15.42
13.93
13.66
15.57
15.90
16.00
15.07
15.10
14.96

EVAL.
MSE
8.50
7.82
7.36
14.30
12.95
12.62
18.51
15.31
15.15
14.58
14.50
14.69

all LSTM and unitary RNN models. Similar to Wisdom
et al. (2016), we reconstructed audio ﬁles using the pre-
dicted log-magnitudes from each machine and evaluated
them on several audio metrics. We found that the scoRNN
predictions achieved better scores on the signal-to-noise
ratio metric SegSNR (Brookes et al., 1997), but performed
slightly worse than the full-capacity uRNN predictions on
STOI (Taal et al., 2011) and PESQ (Rix et al., 2001), both
metrics used to measure human intelligibility and perception.

5.5. Further Analysis

5.5.1. LOSS OF ORTHOGONALITY

(cid:1) for the full-capacity
Figure 4. Unitary scores (cid:0)(cid:107)W ∗W − I(cid:107)F
uRNN recurrent weight matrix and orthogonality scores
(cid:13)W T W − I(cid:13)
(cid:0)(cid:13)
(cid:1)for the scoRNN recurrent weight matrix using
(cid:13)F
a GPU on the pixel-by-pixel MNIST experiment.

In the scoRNN architecture, the recurrent weight matrix is
parameterized with a skew-symmetric matrix through the
Cayley transform. This ensures the computed recurrent
weight matrix in ﬂoating point arithmetic is orthogonal to
the order of machine precision after each update step. Un-
like scoRNN, the full-capacity uRNN maintains a unitary
recurrent weight matrix by a multiplicative update scheme.

5.5.2. VANISHING GRADIENTS

As discussed in Arjovsky et al. (2016),
the vanish-
ing/exploding gradient problem is caused by rapid growth
or decay of the gradient of the hidden state ∂L
as we move
∂ht
earlier in the sequence (that is, as t decreases). To see if
vanishing/exploding gradients affect the scoRNN model, we
examined hidden state gradients in the scoRNN and LSTM

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

models on the adding problem experiment (see section 5.2)
with sequence length T = 500.

The norms of these gradients are shown at two different
points in time during training in Figure 5. As can be seen,
LSTM gradient norms decrease steadily as we move away
from the end of the sequence. The right half of Figure 5
shows that this vanishing effect is exacerbated by training
after 300 iterations.

In contrast, scoRNN gradients decay by less than an order
of magnitude at the beginning of training, remaining near
10−2 for all timesteps. Even after 300 iterations of training,
scoRNN hidden state gradients decay only slightly, from
10−3 at t = 500 to 10−4 at t = 0. This allows information
to easily propagate from beginning of the sequence to end.

Table 3. Timing results for the unpermuted MNIST dataset.

# params Minutes Per Epoch

n
Model
116
RNN
170
scoRNN
512
Rest. uRNN
116
Full uRNN
128
LSTM
scoRNN
360
Rest. uRNN 2,170
360
RNN
512
scoRNN
360
Full uRNN
512
RNN
256
LSTM
512
Full uRNN
512
LSTM

≈ 16k
≈ 16k
≈ 16k
≈ 16k
≈ 68k
≈ 69k
≈ 69k
≈ 137k
≈ 137k
≈ 137k
≈ 270k
≈ 270k
≈ 270k
≈ 1, 058k

2.3
5.3
8.2
10.8
5.0
7.4
50.1
2.3
11.2
25.8
2.4
5.2
27.9
5.6

The RNN and LSTM models were fastest, and hidden sizes
largely did not affect time taken per epoch; we suspect
this is because these models were built in to Tensorﬂow.
The LSTMs are of similar speed to the n = 170 scoRNN,
while they are approximately twice as fast as the n = 512
scoRNN. Matching the number of hidden parameters, the
scoRNN model with n = 170 is approximately 1.5 times
faster than the restricted-capacity uRNN with n = 512,
and twice as fast as the full-capacity uRNN with n = 116.
This relationship can also be seen in the scoRNN and full-
capacity uRNN models with ≈ 137k parameters, where the
scoRNN takes 11.2 minutes per epoch as compared to 25.8
minutes for the full-capacity uRNN.

6. Conclusion

There has been recent promising work with RNN architec-
tures using unitary and orthogonal recurrent weight ma-
trices to address the vanishing/exploding gradient prob-
lem. The unitary/orthogonal RNNs are typically imple-
mented with complex valued matrices or in restricted capac-
ity. The scoRNN developed in this paper uses real valued
orthogonal recurrent weight matrices with a simpler im-
plementation scheme, with the representational capacity to
reach all orthogonal matrices through the Cayley transform
parametrization. The resulting model’s additive update step
with respect to this parametrization maintains the orthog-
onality of the recurrent weight matrix in the presence of
roundoff errors. Results from our experiments show that
scoRNN is among the top performers in all tests with a
smooth and stable convergence curve. This superior perfor-
mance is achieved, in some cases, with a smaller hidden
state dimension than other models.

Figure 5. Gradient norms (cid:107) ∂L
(cid:107) for scoRNN and LSTM models
∂ht
during training on the adding problem. The x-axis shows different
values of t. The left plot shows gradients at the beginning of
training, and the right shows gradients after 300 training iterations.

5.5.3. COMPLEXITY AND SPEED

The scoRNN architecture is similar in complexity and mem-
ory usage to a standard RNN except for the additional mem-
ory requirement of storing the n(n − 1)/2 entries of the
skew-symmetric matrix A and the additional complexity of
forming the recurrent weight matrix W from A with the
scaled Cayley transform. We note that the recurrent weight
matrix is generated from the skew-symmetric A matrix only
once per training iteration; this O(n3) computational cost
is comparable to one training iteration of a standard RNN,
which is O(BT n2) where T is the length of the sequences
and B is the mini-batch size, when BT is comparable to n.

To experimentally quantify potential differences between
scoRNN and other models, the real run-time for the unper-
muted MNIST experiment were recorded and are included
in Table 3. All models were run on the same machine, which
has an Intel Core i5-7400 processor and an nVidia GeForce
GTX 1080 GPU. The scoRNN and LSTM models were run
in Tensorﬂow, while the full and restricted capacity uRNNs
were run using code provided in Wisdom et al. (2016).

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Acknowledgements

This research was supported in part by NSF Grants DMS-
1317424 and DMS-1620082.

References

Arjovsky, M., Shah, A., and Bengio, Y. Unitary evolution
recurrent neural networks. In Proceedings of the 33rd
International Conference on Machine Learning (ICML
2016), volume 48, pp. 1120–1128, New York, NY, 2016.
JMLR.

Bengio, Y., Frasconi, P., and Simard, P. The problem of
learning long-term dependencies in recurrent networks.
In Proceedings of 1993 IEEE International Conference
on Neural Networks (ICNN ’93), pp. 1183–1195, San
Francisco, CA, 1993. IEEE Press.

Brookes, M. et al. Voicebox: Speech processing toolbox for
matlab. Software, available [Mar. 2011] from www. ee. ic.
ac. uk/hp/staff/dmb/voicebox/voicebox. html, 47, 1997.

Cho, K., van Merrienboer, B., Bahdanau, D., and Ben-
gio, Y. On the properties of neural machine transla-
tion: Encoder-decoder approaches, 2014. URL https:
//arxiv.org/abs/1409.1259.

Garofolo, J., Lamel, L., Fisher, W., Fiscus, J., Pallett, D.,
Dahlgren, N., and Zue, V. Timit acoustic-phonetic contin-
uous speech corpus ldc93s1. Technical report, Philadel-
phia: Linguistic Data Consortium, Philadelphia, PA,
1993.

Henaff, M., Szlam, A., and LeCun, Y. Recurrent orthogonal
In Proceedings of
networks and long-memory tasks.
the 33rd International Conference on Machine Learning
(ICML 2017), volume 48, New York, NY, 2017. JMLR:
W&CP.

Hochreiter, S. and Schmidhuber, J. Long short-term memory.

Neural Computation, 9(8):1735–1780, 1997.

Hyland, S. L. and Gunnar, R. Learning unitary operators
with help from u(n). In Proceedings of the 31st AAAI Con-
ference on Artiﬁcial Intelligence (AAI 2017), pp. 2050–
2058, San Francisco, CA, 2017.

Jing, L., Shen, Y., Dubˇcek, T., Peurifoy, J., Skirlo, S.,
Tegmark, M., and Soljaˇci´c, M. Tunable efﬁcient uni-
tary neural networks (eunn) and their application to rnn,
2016.

Jing, L., G¨ulc¸ehre, C., Peurifoy, J., Shen, Y., Tegmark, M.,
Soljaˇci´c, M., and Bengio, Y. Gated orthogonal recurrent
units: On learning to forget. 2017. URL https://
arxiv.org/abs/1706.02761.

Kahan, W. Is there a small skew cayley transform with zero
diagonal? Linear algebra and its applications, 417(2-3):
335–341, 2006.

Kingma, D. and Ba, J. Adam: A method for stochastic
optimization. arXiv preprint arXiv:1412.6980, 2014.

Le, Q. V., Jaitly, N., and Hinton, G. E. A simple way to
initialize recurrent networks of rectiﬁed linear units, 2015.
URL https://arxiv.org/abs/1504.00941.

LeCun, Y., Cortes, C., and Burges, C. J. C. The mnist
database. URL http://yann.lecun.com/exdb/
mnist/.

Mhammedi, Z., Hellicar, A., Rahman, A., and Bailey, J.
Efﬁcient orthogonal parameterisation of recurrent neural
networks using householder reﬂections. In Proceedings of
the 34th International Conference on Machine Learning
(ICML 2017), Sydney, Australia, 2017. PMLR: 70.

Nair, V. and Hinton, G. E. Rectiﬁed linear units improve
In 27th International
restricted boltzmann machines.
Conference on Machine Learning (ICML 2010), Haifa,
Israel, 2010.

Pascanu, R., Mikolov, T., and Bengio, Y. On the difﬁculty of
training recurrent neural networks. In 30th International
Conference on Machine Learning (ICML 2013), Atlanta,
GA, 2013.

Rix, A. W., Beerends, J. G., Hollier, M. P., and Hekstra,
A. P. Perceptual evaluation of speech quality (pesq)-a
new method for speech quality assessment of telephone
networks and codecs. In Acoustics, Speech, and Signal
Processing, 2001. Proceedings.(ICASSP’01). 2001 IEEE
International Conference on, volume 2, pp. 749–752.
IEEE, 2001.

Taal, C. H., Hendriks, R. C., Heusdens, R., and Jensen,
J. An algorithm for intelligibility prediction of time–
frequency weighted noisy speech. IEEE Transactions on
Audio, Speech, and Language Processing, 19(7):2125–
2136, 2011.

Tagare, H. D. Notes on optimization on stiefel manifolds.

Technical report, Yale University, 2011.

Tieleman, T. and Hinton, G. Lecture 6.5-rmsprop: Divide
the gradient by a running average of its recent magnitude.
COURSERA: Neural networks for machine learning, 4
(2):26–31, 2012.

Vorontsov, E., Trabelsi, C., Kadoury, S., and Pal, C. On
orthogonality and learning recurrent networks with long
term dependencies, 2017.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Wen, Z. and Yin, W. A feasible method for optimization
with orthogonality constraints. In Mathematical Program-
ming, volume 142(1-2), pp. 397–434. 2013.

Wisdom, S., Powers, T., Hershey, J., Roux, J. L., and Atlas,
L. Full-capacity unitary recurrent neural networks. In
Lee, D. D., Sugiyama, M., Luxburg, U. V., Guyon, I., and
Garnett, R. (eds.), Advances in Neural Information Pro-
cessing Systems 29, pp. 4880–4888. Curran Associates,
Inc., 2016.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

∂L
∂Ai,j

= − tr

(cid:19)T

(cid:35)
(I + A)−1 (Ei,j − Ej,i + Ei,jZ − Ej,iZ)

Supplemental Material: Proof of Theorem 3.2

For completeness, we restate and prove Theorem 3.2.
Theorem 3.2 Let L = L(W ) : Rn×n → R be some differ-
entiable loss function for an RNN with the recurrent weight
matrix W . Let W = W (A) := (I + A)−1 (I − A) D
where A ∈ Rn×n is skew-symmetric and D ∈ Rn×n is
a ﬁxed diagonal matrix consisting of -1 and 1 entries. Then
the gradient of L = L(W (A)) with respect to A is

∂L
∂A

= V T − V

(3)

where V := (I + A)−T ∂L
∂W
(cid:105)

Rn×n, and ∂L

∂W =

(cid:104) ∂L
∂Wi,j

∈ Rn×n

(cid:0)D + W T (cid:1), ∂L

∂A =

(cid:105)

(cid:104) ∂L
∂Ai,j

∈

Proof: Let Z := (I + A)−1(I − A). We consider the
(i, j) entry of ∂L
∂A . Taking the derivative with respect to Ai,j
where i (cid:54)= j we obtain:

∂L
∂Ai,j

=

n
(cid:88)

k,l=1

∂L
∂Wk,l

∂Wk,l
∂Ai,j

=

= tr

(cid:34)(cid:18) ∂L
∂W

D

(cid:19)T ∂Z
∂Ai,j

n
(cid:88)

k,l=1
(cid:35)

∂L
∂Wk,l

Dl,l

∂Zk,l
∂Ai,j

Using the identity (I + A) Z = I − A and taking the deriva-
tive with respect to Ai,j to both sides we obtain:

∂Z
∂Ai,j

+

∂A
∂Ai,j

Z + A

= −

∂Z
∂Ai,j

∂A
∂Ai,j

and rearranging we get:

∂Z
∂Ai,j

= − (I + A)−1

(cid:18) ∂A
∂Ai,j

+

∂A
∂Ai,j

Z

(cid:19)

Let Ei,j denote the matrix whose (i, j) entry is 1 with
all others being 0. Since A is skew-symmetric, we have
= Ei,j − Ej,i. Combining everything, we have:

∂A
∂Ai,j

= − tr

(I + A)−1Ei,j

D

D

(cid:19)T

(cid:19)T

(cid:19)T

(cid:19)T

D

D

D

(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W

(cid:32)(cid:18) ∂L

∂W

+ tr

− tr

+ tr

= −

(I + A)−1Ej,i

(I + A)−1Ei,jZ

(I + A)−1Ej,iZ

(cid:19)T

D

(I + A)−1

(cid:33)T 


(cid:35)

(cid:35)

(cid:35)

(cid:35)

i,j

(cid:34)(cid:18) ∂L
∂W

+

(cid:19)T

D

(cid:35)

(I + A)−1


(cid:32)(cid:18) ∂L

∂W

−

(cid:19)T

D

i,j
(cid:33)T

(I + A)−1

Z T





i,j

(cid:34)

+

Z

(cid:19)T

(cid:18) ∂L
∂W

D

(cid:35)

(I + A)−1

i,j

(cid:35)

(I + A)−1

i,j

(cid:33)T

(I + A)−1

(cid:0)I + Z T (cid:1)

=

(I + Z)

(cid:19)T

(cid:18) ∂L
∂W

D


(cid:32)(cid:18) ∂L

∂W

(cid:19)T

D

(cid:34)

−

(cid:34)

=

(D + W )

(I + A)−1

(cid:19)T

(cid:18) ∂L
∂W

−

(cid:20)
(I + A)−T ∂L
∂W

(cid:0)D + W T (cid:1)

(cid:35)

i,j

(cid:21)

i,j





i,j

Using the above formulation,
− ∂L
∂Aj,i
by the deﬁnition of V we get the desired result. (cid:4)

=
∂A is a skew-symmetric matrix. Finally,

= 0 and ∂L
∂Ai,j

so that ∂L

∂L
∂Aj,j

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Kyle E. Helfrich * 1 Devin Willmott * 1 Qiang Ye 1

Abstract

8
1
0
2
 
n
u
J
 
9
1
 
 
]
L
M

.
t
a
t
s
[
 
 
3
v
0
2
5
9
0
.
7
0
7
1
:
v
i
X
r
a

Recurrent Neural Networks (RNNs) are designed
to handle sequential data but suffer from vanish-
ing or exploding gradients. Recent work on Uni-
tary Recurrent Neural Networks (uRNNs) have
been used to address this issue and in some cases,
exceed the capabilities of Long Short-Term Mem-
ory networks (LSTMs). We propose a simpler
and novel update scheme to maintain orthogonal
recurrent weight matrices without using complex
valued matrices. This is done by parametrizing
with a skew-symmetric matrix using the Cayley
transform; such a parametrization is unable to rep-
resent matrices with negative one eigenvalues, but
this limitation is overcome by scaling the recur-
rent weight matrix by a diagonal matrix consisting
of ones and negative ones. The proposed training
scheme involves a straightforward gradient calcu-
lation and update step. In several experiments, the
proposed scaled Cayley orthogonal recurrent neu-
ral network (scoRNN) achieves superior results
with fewer trainable parameters than other unitary
RNNs.

1. Introduction

Deep neural networks have been used to solve numerical
problems of varying complexity. RNNs have parameters
that are reused at each time step of a sequential data point
and have achieved state of the art performance on many se-
quential learning tasks. Nearly all optimization algorithms
for neural networks involve some variant of gradient descent.
One major obstacle to training RNNs with gradient descent
is due to vanishing or exploding gradients, as described in
Bengio et al. (1993) and Pascanu et al. (2013). This prob-
lem refers to the tendency of gradients to grow or decay
exponentially in size, resulting in gradient descent steps that
are too small to be effective or so large that the network

*Equal contribution 1Department of Mathematics, Univer-
sity of Kentucky, Lexington, Kentucky, USA. Correspondence
to: Kyle Helfrich <kyle.helfrich@uky.edu>, Devin Willmott
<devin.willmott@uky.edu>.

Proceedings of the 35 th International Conference on Machine
Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018
by the author(s).

oversteps the local minimum. This issue signiﬁcantly di-
minishes RNNs’ ability to learn time-based dependencies,
particularly in problems with long input sequences.

A variety of architectures have been introduced to overcome
this difﬁculty. The current preferred RNN architectures are
those that introduce gating mechanisms to control when in-
formation is retained or discarded, such as LSTMs (Hochre-
iter & Schmidhuber, 1997) and GRUs (Cho et al., 2014),
at the cost of additional trainable parameters. More re-
cently, the unitary evolution RNN (uRNN) (Arjovsky et al.,
2016) uses a parametrization that forces the recurrent weight
matrix to remain unitary throughout training, and exhibits
superior performance to LSTMs on a variety of testing prob-
lems. For clarity, we follow the convention of Wisdom et al.
(2016) and refer to this network as the restricted-capacity
uRNN.

Since the introduction of uRNNs, orthogonal and unitary
RNN schemes have increased in both popularity and com-
plexity. Wisdom et al. (2016) use a multiplicative update
method detailed in Tagare (2011) and Wen & Yin (2013)
to expand uRNNs’ capacity to include all unitary matrices.
These networks are referred to as full-capacity uRNNs. Jing
et al. (2016) and Mhammedi et al. (2017) parametrize the
space of unitary/orthogonal matrices with Givens rotations
and Householder reﬂections, respectively, but typically opti-
mize over a subset of this space by restricting the number of
parameters. Another complex parametrization has also been
explored in Hyland & Gunnar (2017). There is also work
using unitary matrices in GRUs (i.e. in GORU of Jing et al.
(2017)) or near-unitary matrices in RNNs by restricting the
singular values of the recurrent matrix to an interval around
1 (see Vorontsov et al. (2017)). For other work in addressing
the vanishing and exploding gradient problem, see Henaff
et al. (2017) and Le et al. (2015).

In this paper, we consider RNNs with a recurrent weight
matrix taken from the set of all orthogonal matrices. To
construct the orthogonal weight matrix, we parametrize
it with a skew-symmetric matrix through a scaled Cayley
transform. This scaling allows us to avoid the singularity
issue occurring for −1 eigenvalues that may arise in the
standard Cayley transform. By tuning this scaling matrix,
the network can reach an appropriate orthogonal matrix
using a relatively simple gradient descent update step. The
resulting method achieves superior performance on various
sequential data tasks.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

The method we present in this paper works entirely with real
matrices, and as such, our results deal only with orthogonal
and skew-symmetric matrices. However, the method and all
related theory remain valid for unitary and skew-Hermitian
matrices in the complex case. The experimental results in
this paper indicate that state of the art performance can be
achieved without using complex matrices to optimize along
the Stiefel manifold.

2. Background

2.1. Recurrent Neural Networks

A recurrent neural network (RNN) is a function with input
parameters U ∈ Rn×m, recurrent parameters W ∈ Rn×n,
recurrent bias b ∈ Rn, output parameters V ∈ Rp×n, and
output bias c ∈ Rp where m is the data input size, n is the
number of hidden units, and p is the output data size. From
an input sequence x = (x1, x2, ..., xT ) where xi ∈ Rm, the
RNN returns an output sequence y = (y1, y2, ..., yT ) where
each yi ∈ Rp is given recursively by

ht = σ (U xt + W ht−1 + b)
yt = V ht + c

where h = (h0, . . . , hT −1), hi ∈ Rn is the hidden layer
state at time i and σ(·) is the activation function, which is
often a pointwise nonlinearity such as a hyperbolic tangent
function or rectiﬁed linear unit (Nair & Hinton, 2010).

2.2. Unitary RNNs

A real matrix W is orthogonal if it satisﬁes W T W = I. The
complex analog of orthogonal matrices are unitary matrices,
which satisfy W ∗W = I, where ∗ denotes the conjugate
transpose. Orthogonal and unitary matrices have the desir-
able property that (cid:107)W x(cid:107)2 = (cid:107)x(cid:107)2 for any vector x. This
property motivates the use of orthogonal or unitary matrices
in RNNs to avoid vanishing and exploding gradients, as
detailed in Arjovsky et al. (2016).

Arjovsky et al. (2016) follow the framework of the previous
section for their restricted-capacity uRNN, but introduce a
parametrization of the recurrent matrix W using a product
of simpler matrices. This parameterization is given by a
product consisting of diagonal matrices with complex norm
1, complex Householder reﬂection matrices, discrete Fourier
transform matrices, and a ﬁxed permutation matrix with the
resulting product being unitary. The Efﬁcient Unitary RNN
(EURNN) by Jing et al. (2016) and orthogonal RNN (oRNN)
by Mhammedi et al. (2017) parametrize in a similar manner
with products of Givens rotation matrices and Householder
reﬂection matrices, respectively. This can also be seen in
the parametrization through matrix exponentials in Hyland
& Gunnar (2017), which does not appear to perform as well
as the restricted-capacity uRNN.

Wisdom et al. (2016) note that this representation has only
7n parameters, which is insufﬁcient to represent all unitary
matrices for n > 7.
In response, they present the full-
capacity uRNN, which uses a multiplicative update step that
is able to reach all unitary matrices of order n.

The full-capacity uRNN aims to construct a unitary ma-
trix W (k+1) from W (k) by moving along a curve on the
Stiefel manifold {W ∈ Cn×n | W ∗W = I}. For the
network optimization, it is necessary to use a curve that is
in a descent direction of the cost function L := L(W ). In
Tagare (2011), Wen & Yin (2013), Wisdom et al. (2016), and
Vorontsov et al. (2017), a descent direction is constructed
as B(k)W (k), which is a representation of the derivative
operator DL(W (k)) in the tangent space of the Stiefel man-
ifold at W (k). Then, with B(k)W (k) deﬁning the direction
of a descent curve, an update along the Stiefel manifold is
obtained using the Cayley transform as

(cid:18)

(cid:19)−1 (cid:18)

(cid:19)

W (k+1) =

I +

B(k)

I −

B(k)

W (k)

(1)

λ
2

λ
2

where λ is the learning rate.

3. Scaled Cayley Orthogonal RNN

3.1. Cayley Transform

The Cayley transform gives a representation of orthogonal
matrices without −1 eigenvalues using skew-symmetric
matrices (i.e., matrices where AT = −A):

W = (I + A)−1 (I − A) , A = (I + W )−1 (I − W ) .

This bijection parametrizes the set of orthogonal matri-
ces without −1 eigenvalues with skew-symmetric matrices.
This direct and simple parametrization is attractive from a
machine learning perspective because it is closed under addi-
tion: the sum or difference of two skew-symmetric matrices
is also skew-symmetric, so we can use gradient descent
algorithms like RMSprop (Tieleman & Hinton, 2012) or
Adam (Kingma & Ba, 2014) to train parameters.

However, this parametrization cannot represent orthogonal
matrices with −1 eigenvalues, since in this case I +W is not
invertible. Theoretically, we can still represent matrices with
eigenvalues that are arbitrarily close to −1; however, it can
require large entries of A. For example, a 2x2 orthogonal
matrix W with eigenvalues ≈ −0.99999 ± 0.00447i and its
parametrization A by the Cayley transform is given below,
where α = 0.99999.

(cid:20)

W =

√

−α
1 − α2

(cid:21)

√

−

1 − α2
−α

(cid:20)

, A ≈

0
−447.212

447.212
0

(cid:21)

Gradient descent algorithms will learn this A matrix very
slowly, if at all. This difﬁculty can be overcome through a

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

suitable diagonal scaling according to results from Kahan
(2006).

Theorem 3.1 Every orthogonal matrix W can be expressed
as

W = (I + A)−1(I − A)D

where A = [aij] is real-valued, skew-symmetric with
|aij| ≤ 1, and D is diagonal with all nonzero entries equal
to ±1.

We call the transform in Theorem 3.1 the scaled Cayley
transform. Then, with an appropriate choice of D, the
scaled Cayley transform can reach any orthogonal matrix
including those with −1 eigenvalues. Further, it ensures that
the skew-symmetric matrix A that generates the orthogonal
matrix will be bounded.

Our proposed network, the scaled Cayley orthogonal recur-
rent neural network (scoRNN), is based on this theorem.
We parametrize the recurrent weight matrix W through a
skew-symmetric matrix A, which results in n(n−1)
trainable
weights. The recurrent matrix W is formed by the scaled
Cayley transform: W = (I + A)−1(I − A)D. The scoRNN
then operates identically to the set of equations given in Sec-
tion 2.1, but during training we update the skew-symmetric
matrix A using gradient descent, while D is ﬁxed through-
out the training process. The number of −1s on the diagonal
of D, which we call ρ, is considered a hyperparameter in
this work and is manually chosen based on the task.

2

3.2. Update Scheme

To update the recurrent parameter matrix A as described
in Section 3.1, we must ﬁnd the gradients of A by back-
propagating through the Cayley transform. The following
theorem describes these gradients. A proof is given in the
supplemental material.
Theorem 3.2 Let L = L(W ) : Rn×n → R be some differ-
entiable loss function for an RNN with the recurrent weight
matrix W . Let W = W (A) := (I + A)−1 (I − A) D
where A ∈ Rn×n is skew-symmetric and D ∈ Rn×n is
a ﬁxed diagonal matrix consisting of -1 and 1 entries. Then
the gradient of L = L(W (A)) with respect to A is

A(k+1) = A(k) − λ

∂L(W (A(k)))
∂A
I + A(k+1)(cid:17)−1 (cid:16)

(cid:16)

I − A(k+1)(cid:17)

D

W (k+1) =

The skew-symmetry of ∂L
symmetric and, in turn, W (k+1) will be orthogonal.

∂A ensures that A(k+1) will be skew-

The orthogonality of the recurrent matrix is maintained
to the order of machine precision, see section 5.5.1. The
scoRNN also maintains stable hidden state gradients in the
sense that the gradient norm does not change signiﬁcantly
in time, see section 5.5.2 for experimental results. This is
achieved with small overhead computational costs over the
standard RNN, see section 5.5.3 for experimental results
concerning computational efﬁciency.

The scoRNN, full-capacity uRNN, EURNN, and oRNN
models all have the theoretical capacity to optimize over
all orthogonal or unitary recurrent matrices, but their opti-
mization schemes are different. The full-capacity uRNN
performs a multiplicative update that moves W along the
tangent space of the Stiefel manifold, which is shown to
be a descent direction. The scoRNN, the EURNN, and
the oRNN use three different representations of orthogonal
matrices. The euRNN and oRNN express an orthogonal
matrix as a long product of simple orthogonal matrices
(Givens rotations and Householder reﬂections resp.) while
the scoRNN uses a single rational transformation. They all
use the steepest descent with respect to their correspond-
ing parametrizations. Here, different parametrizations have
different nonlinearities and hence different optimization
difﬁculties. We note that EURNN and oRNN are usually im-
plemented in a reduced capacity setting that uses a truncated
product. In our testing, it appears that increasing capacity
in EURNN and oRNN may not improve their performance.

Similar to the EURNN and oRNN, scoRNN may also be
implemented by restricting the A matrix to a banded skew-
symmetric matrix with bandwidth (cid:96) to reduce the number
of trainable parameters. Although this may work well for
particular tasks, such a modiﬁcation introduces an additional
hyperparameter and reduces representational capacity for
the recurrent weight matrix without any reduction in the
dimension of the hidden state.

∂L
∂A

= V T − V

(2)

4. Other Architecture Details

where V := (I + A)−T ∂L
∂W
(cid:105)

Rn×n, and ∂L

∂W =

(cid:104) ∂L
∂Wi,j

∈ Rn×n.

(cid:0)D + W T (cid:1), ∂L

∂A =

(cid:105)

(cid:104) ∂L
∂Ai,j

∈

At each training step of scoRNN, we ﬁrst use the standard
backpropagation algorithm to compute ∂L
∂W and then use
Theorem 3.2 to compute ∂L
∂A . We then update A with gradi-
ent descent (or a related optimization method), and recon-
struct W as follows:

The basic architecture of scoRNN is very similar to the
standard RNN as presented in Section 2.1. From a network
layer perspective, one can think of the application of the
recurrent weight in a three layer process. Let ht ∈ Rn be
the current state of the scoRNN at a particular time step, t.
We then pass ht through the following layers:
• Layer 1: ht → Dht =: h(1)
• Layer 2: h(1)

t → (I − A) h(1)

t =: h(2)

t

t

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

• Layer 3: h(2)

t → (I + A)−1 h(2)

t =: h(3)

t

5. Experiments

Note that the above scheme is the same as taking ht → W ht
as discussed previously.

4.1. MODRELU Activation Function

The modReLU function was ﬁrst implemented by Ar-
jovsky et al. (2016) to handle complex valued functions
and weights. Unlike previous methods, our method only
uses real-valued functions and weights. Nevertheless, we
have found that the modReLU function in the real case
also performed better than other activation functions. The
function is deﬁned as

σmodReLU(z) =

σReLU (|z| + b)

5.1. Copying Problem

z
|z|
(cid:40) z

=

|z| (|z| + b)
0

if |z| + b ≥ 0
if |z| + b < 0

In the following experiments, we compare the scoRNN
against LSTM and several other orthogonal and unitary
RNN models. Code for these experiments is available at
https://github.com/SpartinStuff/scoRNN.
For each experiment, we found optimal hyperparameters
for scoRNN using a grid search. For other models, we used
the best hyperparameter settings as reported for the same
testing problems, when applicable, or performed a grid
search to ﬁnd hyperparameters. For the LSTM, the forget
gate bias was tuned over the integers −4 to 4 with it set to
1.0 unless otherwise noted.

This experiment follows descriptions found in Jing et al.
(2016), Arjovsky et al. (2016), and Wisdom et al. (2016),
and tests an RNN’s ability to reproduce a sequence seen
many timesteps earlier. In the problem setup, there are 10
input classes, which we denote using the digits 0-9, with 0
being used as a ’blank’ class and 9 being used as a ’marker’
class. The RNN receives an input sequence of length T +20.
This sequence consists of entirely zeros, except for the ﬁrst
ten elements, which are uniformly sampled from classes
1-8, and a 9 placed ten timesteps from the end. The goal
for the machine is to output zeros until it sees a 9, at which
point it should output the ten elements from the beginning
of the input sequence. Thus, information must propagate
from the beginning to the end of the sequence for a machine
to successfully learn this task, making it critical to avoid
vanishing/exploding gradients.

A baseline strategy with which to compare machine perfor-
mance is that of outputting 0 until the machine sees a 9,
and then outputting 10 elements randomly sampled from
classes 1-8. The expected cross-entropy for such a strategy
is 10 log (8)
T +20 . In practice, it is common to see gated RNNs
such as LSTMs converge to this local minimum.

We use hyperparameters and hidden unit sizes as reported in
experiments in Arjovsky et al. (2016), Wisdom et al. (2016),
and Jing et al. (2016). This results in an LSTM with n = 68,
a restricted-capacity uRNN with n = 470, a full-capacity
uRNN with n = 128, and a tunable EURNN with n = 512
and capacity L = 2. As indicated in Mhammedi et al.
(2017), we were unable to obtain satisfactory performance
for the oRNN on this task. To match the ≈ 22k trainable
parameters in the LSTM and uRNNs, we use a scoRNN
with n = 190. We found the best performance with the
scoRNN came from ρ = n/2, which gives an initial W
with eigenvalues distributed uniformly on the unit circle.

Figure 1 compares each model’s performance for T = 1000
and T = 2000, with the baseline cross-entropy given as
a dashed line. In both cases, cross entropy for the LSTM,

where b is a trainable bias. In the real case, this simpliﬁes to
sign(z)σReLU(|z|+b). To implement this activation function
in scoRNN, we replace the computation of ht in Section 2.1
with

zt = U xt + W ht−1
ht = σmodReLU(zt)

We believe that the improved performance of the modReLU
over other activation functions, such as ReLU, is because it
admits both positive and negative activation values, which
appears to be important for the state transition in orthogonal
RNNs. This is similar to the hyperbolic tangent function but
does not have vanishing gradient issues.

4.2. Initialization

Modifying the initialization of our parameter matrices, in
particular our recurrent parameter matrix A, had an effect
on performance. The most effective initialization method
we found uses a technique inspired by Henaff et al. (2017).
We initialize all of the entries of A to be 0 except for 2x2
blocks along the diagonal, which are given as

B1






A =

. . .




 where Bj =

(cid:20) 0
−sj

(cid:21)

sj
0

B(cid:98)n/2(cid:99)

(cid:113) 1−cos (tj )

2

1+cos (tj ) and tj is sampled uniformly from
with sj =
(cid:2)0, π
(cid:3). The Cayley transform of this A will have eigen-
values equal to ±eitj for each j, which will be distributed
uniformly along the right unit half-circle. Multiplication
by the scaling matrix D will reﬂect ρ of these eigenvalues
across the imaginary axis. We use this method to initialize
scoRNN’s A matrix in all experiments listed in section 5.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Figure 1. Cross entropy of each machine on the copying problem with T = 1000 (left) and T = 2000 (right).

restricted-capacity uRNN, and EURNN remains at the base-
line or does not entirely converge over the entire experi-
ment. For the T = 1000 test, the full-capacity uRNN and
scoRNN converge immediately to zero entropy solutions,
with the full-capacity uRNN converging slightly faster. For
T = 2000, the full-capacity uRNN remains at the base-
line for several thousand iterations, but is eventually able to
ﬁnd a correct solution. In contrast, the scoRNN error has a
smooth convergence that bypasses the baseline, but does so
more slowly than the full-capacity uRNN.

uRNN. We tested both the tunable-style EURNN and FFT-
style EURNN with n = 512, and found better results from
the tunable-style (≈ 3k parameters) for sequence lengths
T = 200 and T = 400, and from the FFT-style (≈ 7k pa-
rameters) for sequence length T = 750. The best hyperpa-
rameters for the oRNN were in accordance with Mhammedi
et al. (2017) which was n = 128 with 16 reﬂections with
a learning rate of 0.01, ≈2.6k parameters. We found that
performance decreased when matching the number of reﬂec-
tions to the hidden size to increase the number of parameters.

5.2. Adding Problem

We examined a variation of the adding problem as proposed
by Arjovsky et al. (2016) which is based on the work of
Hochreiter & Schmidhuber (1997). This variation involves
passing two sequences concurrently into the RNN, each of
length T . The ﬁrst sequence is a sequence of digits sam-
pled uniformly with values ranging in a half-open interval,
U[0, 1). The second sequence is a marker sequence con-
sisting of all zeros except for two entries that are marked
by one. The ﬁrst 1 is located uniformly within the interval
[1, T
2 ) of the sequence and the second 1 is located uniformly
within the interval [ T
2 , T ) of the sequence. The label for
each pair of sequences is the sum of the two entries that
are marked by one, which forces the machine to identify
relevant information in the ﬁrst sequence among noise. As
the sequence length increases, it becomes more crucial to
avoid vanishing/exploding gradients. Naively predicting
one regardless of the sequence gives an expected mean
squared error (MSE) of approximately 0.167. This will be
considered as the baseline.

The number of hidden units for the LSTM, scoRNN and
uRNNs were adjusted so that each had approximately 15k
trainable parameters. This results in n = 170 for the
scoRNN, n = 60 for the LSTM, n = 120 for the Full-
Capacity uRNN, and n = 950 for the restricted-capacity

Figure 2. Test set MSE for each machine on the adding problem
with sequence lengths of T = 200 (top), T = 400 (middle), and
T = 750 (bottom).

The test set MSE results for sequence lengths T = 200,
T = 400, and T = 750 can be found in Figure 2. A training
set size of 100,000 and a testing set size of 10,000 were
used for each sequence length. For each case, the networks
start at or near the baseline MSE, except for the EURNN
for T = 750, and drop towards zero after a few epochs.
As the sequence length increases, the number of epochs

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

before the drop increases. We found the best settings for
the scoRNN were ρ = n/2 for T = 200 and ρ = 7n/10 for
T = 400 and T = 750. The forget bias for the LSTM was 2
for sequence length 200, 4 for sequence length 400, and 0
for sequence length 750. As can be seen, the LSTM error
drops precipitously across the board. Although the oRNN
begins to drop below the baseline before scoRNN, it has a
much more irregular descent curve, and jumps back to the
baseline after several epochs.

5.3. Pixel-by-Pixel MNIST

We ran two experiments based around classifying samples
from the well-known MNIST dataset (LeCun et al.). Follow-
ing the implementation of Le et al. (2015), each pixel of the
image is fed into the RNN sequentially, resulting in a single
pixel sequence length of 784. In the ﬁrst experiment, which
we refer to as unpermuted MNIST, pixels are arranged in
the sequence row-by-row. In the second, which we call
permuted MNIST, a ﬁxed permutation is applied to training
and testing sequences.

All scoRNN machines were trained with the RMSprop opti-
mization algorithm. Input and output weights used a learn-
ing rate of 10−3, while the recurrent parameters used a
learning rate of 10−4 (for n = 170) or 10−5 (for n = 360
and n = 512). For unpermuted MNIST, we found ρ to be
optimal at n/10, while the best value of ρ for permuted
MNIST was n/2. We suspect that the difference of these
two values comes from the different types of dependencies
in each: unpermuted MNIST has mostly local dependencies,
while permuted MNIST requires learning many long-term
dependencies, which appear to be more easily modeled
when the diagonal of D has a higher proportion of −1s.

Each experiment used a training set of 55,000 images and a
test set of 10,000 testing images. Each machine was trained
for 70 epochs, and test set accuracy, the percentage of test
images classiﬁed correctly, was evaluated at the conclusion
of each epoch. Figure 3 shows test set accuracy over time,
and the best performance over all epochs by each machine
is given in Table 1.

In both experiments, the 170 hidden unit scoRNN gives sim-
ilar performance to both of the 512 hidden unit uRNNs using
a much smaller hidden dimension and, in the case of the
full-capacity uRNN, an order of magnitude fewer parame-
ters. Matching the number of parameters (≈ 69k), the 2170
restricted-capacity uRNN performance was comparable to
the 360 hidden unit scoRNN for unpermuted MNIST, but
performed worse for permuted MNIST, and required a much
larger hidden size and a signiﬁcantly longer run time, see
5.5.3. As in experiments presented in Arjovsky et al. (2016)
and Wisdom et al. (2016), orthogonal and unitary RNNs
are unable to outperform the LSTM in the unpermuted case.
However, the 512 hidden unit scoRNN outperforms all other

Table 1. Results for unpermuted and permuted pixel-by-pixel
MNIST experiments. Evaluation accuracies are based on the best
test accuracy at the end of every epoch. Asterisks indicate reported
results from (Jing et al., 2016) and (Mhammedi et al., 2017).

PERMUTED

MODEL

N

#

MNIST MNIST

170 ≈ 16K
360 ≈ 69K
512 ≈ 137K
128 ≈ 68K
256 ≈ 270K
512 ≈ 1, 058K

SCORNN
SCORNN
SCORNN
LSTM
LSTM
LSTM
RESTRICTED URNN 512 ≈ 16K
RESTRICTED URNN 2170 ≈ 69K
116 ≈ 16K
FULL URNN
512 ≈ 270K
FULL URNN
≈ 9K
512
EURNN
256 ≈ 11K
ORNN

PARAMS TEST ACC. TEST ACC.
0.973
0.983
0.985
0.987
0.989
0.985
0.976
0.984
0.947
0.974
-
0.972∗

0.943
0.962
0.966
0.920
0.929
0.920
0.945
0.953
0.925
0.947
0.937∗
-

unitary RNNs. On permuted MNIST, the 512 hidden unit
scoRNN achieves a test-set accuracy of 96.6%, outperform-
ing all other machines. We believe this is a state of the art
result.

5.4. TIMIT Speech Dataset

To see how the models performed on audio data, speech pre-
diction was performed on the TIMIT dataset (Garofolo et al.,
1993), a collection of real-world speech recordings. Exclud-
ing the dialect SA sentences and using only the core test
set, the dataset consisted of 3,696 training and 192 testing
audio ﬁles. Similar to experiments in Wisdom et al. (2016),
audio ﬁles were downsampled to 8kHz and a short-time
Fourier transform (STFT) was applied with a Hann win-
dow of 256 samples and a window hop of 128 samples (16
milliseconds). The result is a set of frames, each with 129
complex-valued Fourier amplitudes. The log-magnitude of
these amplitudes is used as the input data for the machines.
For each model, the hidden layer sizes were adjusted such
that each model had approximately equal numbers of train-
able parameters. For scoRNN, we used the Adam optimizer
with learning rate 10−3 to train input and output parameters,
and RMSprop with a learning rate of 10−3 (for n = 224) or
10−4 (for n = 322, 425) to train the recurrent weight matrix.
The number of negative eigenvalues used was ρ = n/10.
The LSTM forget gate bias was initialized to -4.

The loss function used for training was the mean squared er-
ror (MSE) between the predicted and actual log-magnitudes
of the next time frame over the entire sequence. Table
2 contains the MSE on validation and testing sets, which
shows that all scoRNN models achieve a smaller MSE than

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Figure 3. Test accuracy for unpermuted and permuted MNIST over time. All scoRNN models and the best performing LSTM, restriced
capacity uRNN, and full-capacity uRNN are shown.

Due to the accumulation of rounding errors over a large
number of repeated matrix multiplications, the recurrent
weight may not remain unitary throughout training. To in-
vestigate this, we ran the scoRNN and full-capacity uRNN
with equal hidden unit sizes of n = 512 on the unpermuted
MNIST experiment and checked for loss of orthogonality
at each epoch. The results of this experiment are shown in
Figure 4. As can be seen, the recurrent weight matrix for
the full-capacity uRNN becomes less unitary over time, but
the orthogonality recurrent weight matrix for scoRNN is not
affected by roundoff errors.

This can become particularly apparent when performing op-
erations using a graphics processing unit (GPU) which have
a much lower machine precision than a standard computer
processing unit (CPU).

Table 2. Results for the TIMIT speech dataset. Evaluation based
on MSE and various audio metrics

N

MODEL

#
PARAMS
≈ 83K
224
SCORNN
322 ≈ 135K
SCORNN
425 ≈ 200K
SCORNN
≈ 83K
84
LSTM
120 ≈ 135K
LSTM
158 ≈ 200K
LSTM
≈ 83K
REST. URNN 158
REST. URNN 256 ≈ 135K
REST. URNN 378 ≈ 200K
≈ 83K
128
FULL URNN
192 ≈ 135K
FULL URNN
256 ≈ 200K
FULL URNN

VALID.
MSE
9.26
8.48
7.97
15.42
13.93
13.66
15.57
15.90
16.00
15.07
15.10
14.96

EVAL.
MSE
8.50
7.82
7.36
14.30
12.95
12.62
18.51
15.31
15.15
14.58
14.50
14.69

all LSTM and unitary RNN models. Similar to Wisdom
et al. (2016), we reconstructed audio ﬁles using the pre-
dicted log-magnitudes from each machine and evaluated
them on several audio metrics. We found that the scoRNN
predictions achieved better scores on the signal-to-noise
ratio metric SegSNR (Brookes et al., 1997), but performed
slightly worse than the full-capacity uRNN predictions on
STOI (Taal et al., 2011) and PESQ (Rix et al., 2001), both
metrics used to measure human intelligibility and perception.

5.5. Further Analysis

5.5.1. LOSS OF ORTHOGONALITY

(cid:1) for the full-capacity
Figure 4. Unitary scores (cid:0)(cid:107)W ∗W − I(cid:107)F
uRNN recurrent weight matrix and orthogonality scores
(cid:13)W T W − I(cid:13)
(cid:0)(cid:13)
(cid:1)for the scoRNN recurrent weight matrix using
(cid:13)F
a GPU on the pixel-by-pixel MNIST experiment.

In the scoRNN architecture, the recurrent weight matrix is
parameterized with a skew-symmetric matrix through the
Cayley transform. This ensures the computed recurrent
weight matrix in ﬂoating point arithmetic is orthogonal to
the order of machine precision after each update step. Un-
like scoRNN, the full-capacity uRNN maintains a unitary
recurrent weight matrix by a multiplicative update scheme.

5.5.2. VANISHING GRADIENTS

As discussed in Arjovsky et al. (2016),
the vanish-
ing/exploding gradient problem is caused by rapid growth
or decay of the gradient of the hidden state ∂L
as we move
∂ht
earlier in the sequence (that is, as t decreases). To see if
vanishing/exploding gradients affect the scoRNN model, we
examined hidden state gradients in the scoRNN and LSTM

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

models on the adding problem experiment (see section 5.2)
with sequence length T = 500.

The norms of these gradients are shown at two different
points in time during training in Figure 5. As can be seen,
LSTM gradient norms decrease steadily as we move away
from the end of the sequence. The right half of Figure 5
shows that this vanishing effect is exacerbated by training
after 300 iterations.

In contrast, scoRNN gradients decay by less than an order
of magnitude at the beginning of training, remaining near
10−2 for all timesteps. Even after 300 iterations of training,
scoRNN hidden state gradients decay only slightly, from
10−3 at t = 500 to 10−4 at t = 0. This allows information
to easily propagate from beginning of the sequence to end.

Table 3. Timing results for the unpermuted MNIST dataset.

# params Minutes Per Epoch

n
Model
116
RNN
170
scoRNN
512
Rest. uRNN
116
Full uRNN
128
LSTM
scoRNN
360
Rest. uRNN 2,170
360
RNN
512
scoRNN
360
Full uRNN
512
RNN
256
LSTM
512
Full uRNN
512
LSTM

≈ 16k
≈ 16k
≈ 16k
≈ 16k
≈ 68k
≈ 69k
≈ 69k
≈ 137k
≈ 137k
≈ 137k
≈ 270k
≈ 270k
≈ 270k
≈ 1, 058k

2.3
5.3
8.2
10.8
5.0
7.4
50.1
2.3
11.2
25.8
2.4
5.2
27.9
5.6

The RNN and LSTM models were fastest, and hidden sizes
largely did not affect time taken per epoch; we suspect
this is because these models were built in to Tensorﬂow.
The LSTMs are of similar speed to the n = 170 scoRNN,
while they are approximately twice as fast as the n = 512
scoRNN. Matching the number of hidden parameters, the
scoRNN model with n = 170 is approximately 1.5 times
faster than the restricted-capacity uRNN with n = 512,
and twice as fast as the full-capacity uRNN with n = 116.
This relationship can also be seen in the scoRNN and full-
capacity uRNN models with ≈ 137k parameters, where the
scoRNN takes 11.2 minutes per epoch as compared to 25.8
minutes for the full-capacity uRNN.

6. Conclusion

There has been recent promising work with RNN architec-
tures using unitary and orthogonal recurrent weight ma-
trices to address the vanishing/exploding gradient prob-
lem. The unitary/orthogonal RNNs are typically imple-
mented with complex valued matrices or in restricted capac-
ity. The scoRNN developed in this paper uses real valued
orthogonal recurrent weight matrices with a simpler im-
plementation scheme, with the representational capacity to
reach all orthogonal matrices through the Cayley transform
parametrization. The resulting model’s additive update step
with respect to this parametrization maintains the orthog-
onality of the recurrent weight matrix in the presence of
roundoff errors. Results from our experiments show that
scoRNN is among the top performers in all tests with a
smooth and stable convergence curve. This superior perfor-
mance is achieved, in some cases, with a smaller hidden
state dimension than other models.

Figure 5. Gradient norms (cid:107) ∂L
(cid:107) for scoRNN and LSTM models
∂ht
during training on the adding problem. The x-axis shows different
values of t. The left plot shows gradients at the beginning of
training, and the right shows gradients after 300 training iterations.

5.5.3. COMPLEXITY AND SPEED

The scoRNN architecture is similar in complexity and mem-
ory usage to a standard RNN except for the additional mem-
ory requirement of storing the n(n − 1)/2 entries of the
skew-symmetric matrix A and the additional complexity of
forming the recurrent weight matrix W from A with the
scaled Cayley transform. We note that the recurrent weight
matrix is generated from the skew-symmetric A matrix only
once per training iteration; this O(n3) computational cost
is comparable to one training iteration of a standard RNN,
which is O(BT n2) where T is the length of the sequences
and B is the mini-batch size, when BT is comparable to n.

To experimentally quantify potential differences between
scoRNN and other models, the real run-time for the unper-
muted MNIST experiment were recorded and are included
in Table 3. All models were run on the same machine, which
has an Intel Core i5-7400 processor and an nVidia GeForce
GTX 1080 GPU. The scoRNN and LSTM models were run
in Tensorﬂow, while the full and restricted capacity uRNNs
were run using code provided in Wisdom et al. (2016).

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Acknowledgements

This research was supported in part by NSF Grants DMS-
1317424 and DMS-1620082.

References

Arjovsky, M., Shah, A., and Bengio, Y. Unitary evolution
recurrent neural networks. In Proceedings of the 33rd
International Conference on Machine Learning (ICML
2016), volume 48, pp. 1120–1128, New York, NY, 2016.
JMLR.

Bengio, Y., Frasconi, P., and Simard, P. The problem of
learning long-term dependencies in recurrent networks.
In Proceedings of 1993 IEEE International Conference
on Neural Networks (ICNN ’93), pp. 1183–1195, San
Francisco, CA, 1993. IEEE Press.

Brookes, M. et al. Voicebox: Speech processing toolbox for
matlab. Software, available [Mar. 2011] from www. ee. ic.
ac. uk/hp/staff/dmb/voicebox/voicebox. html, 47, 1997.

Cho, K., van Merrienboer, B., Bahdanau, D., and Ben-
gio, Y. On the properties of neural machine transla-
tion: Encoder-decoder approaches, 2014. URL https:
//arxiv.org/abs/1409.1259.

Garofolo, J., Lamel, L., Fisher, W., Fiscus, J., Pallett, D.,
Dahlgren, N., and Zue, V. Timit acoustic-phonetic contin-
uous speech corpus ldc93s1. Technical report, Philadel-
phia: Linguistic Data Consortium, Philadelphia, PA,
1993.

Henaff, M., Szlam, A., and LeCun, Y. Recurrent orthogonal
In Proceedings of
networks and long-memory tasks.
the 33rd International Conference on Machine Learning
(ICML 2017), volume 48, New York, NY, 2017. JMLR:
W&CP.

Hochreiter, S. and Schmidhuber, J. Long short-term memory.

Neural Computation, 9(8):1735–1780, 1997.

Hyland, S. L. and Gunnar, R. Learning unitary operators
with help from u(n). In Proceedings of the 31st AAAI Con-
ference on Artiﬁcial Intelligence (AAI 2017), pp. 2050–
2058, San Francisco, CA, 2017.

Jing, L., Shen, Y., Dubˇcek, T., Peurifoy, J., Skirlo, S.,
Tegmark, M., and Soljaˇci´c, M. Tunable efﬁcient uni-
tary neural networks (eunn) and their application to rnn,
2016.

Jing, L., G¨ulc¸ehre, C., Peurifoy, J., Shen, Y., Tegmark, M.,
Soljaˇci´c, M., and Bengio, Y. Gated orthogonal recurrent
units: On learning to forget. 2017. URL https://
arxiv.org/abs/1706.02761.

Kahan, W. Is there a small skew cayley transform with zero
diagonal? Linear algebra and its applications, 417(2-3):
335–341, 2006.

Kingma, D. and Ba, J. Adam: A method for stochastic
optimization. arXiv preprint arXiv:1412.6980, 2014.

Le, Q. V., Jaitly, N., and Hinton, G. E. A simple way to
initialize recurrent networks of rectiﬁed linear units, 2015.
URL https://arxiv.org/abs/1504.00941.

LeCun, Y., Cortes, C., and Burges, C. J. C. The mnist
database. URL http://yann.lecun.com/exdb/
mnist/.

Mhammedi, Z., Hellicar, A., Rahman, A., and Bailey, J.
Efﬁcient orthogonal parameterisation of recurrent neural
networks using householder reﬂections. In Proceedings of
the 34th International Conference on Machine Learning
(ICML 2017), Sydney, Australia, 2017. PMLR: 70.

Nair, V. and Hinton, G. E. Rectiﬁed linear units improve
In 27th International
restricted boltzmann machines.
Conference on Machine Learning (ICML 2010), Haifa,
Israel, 2010.

Pascanu, R., Mikolov, T., and Bengio, Y. On the difﬁculty of
training recurrent neural networks. In 30th International
Conference on Machine Learning (ICML 2013), Atlanta,
GA, 2013.

Rix, A. W., Beerends, J. G., Hollier, M. P., and Hekstra,
A. P. Perceptual evaluation of speech quality (pesq)-a
new method for speech quality assessment of telephone
networks and codecs. In Acoustics, Speech, and Signal
Processing, 2001. Proceedings.(ICASSP’01). 2001 IEEE
International Conference on, volume 2, pp. 749–752.
IEEE, 2001.

Taal, C. H., Hendriks, R. C., Heusdens, R., and Jensen,
J. An algorithm for intelligibility prediction of time–
frequency weighted noisy speech. IEEE Transactions on
Audio, Speech, and Language Processing, 19(7):2125–
2136, 2011.

Tagare, H. D. Notes on optimization on stiefel manifolds.

Technical report, Yale University, 2011.

Tieleman, T. and Hinton, G. Lecture 6.5-rmsprop: Divide
the gradient by a running average of its recent magnitude.
COURSERA: Neural networks for machine learning, 4
(2):26–31, 2012.

Vorontsov, E., Trabelsi, C., Kadoury, S., and Pal, C. On
orthogonality and learning recurrent networks with long
term dependencies, 2017.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Wen, Z. and Yin, W. A feasible method for optimization
with orthogonality constraints. In Mathematical Program-
ming, volume 142(1-2), pp. 397–434. 2013.

Wisdom, S., Powers, T., Hershey, J., Roux, J. L., and Atlas,
L. Full-capacity unitary recurrent neural networks. In
Lee, D. D., Sugiyama, M., Luxburg, U. V., Guyon, I., and
Garnett, R. (eds.), Advances in Neural Information Pro-
cessing Systems 29, pp. 4880–4888. Curran Associates,
Inc., 2016.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

∂L
∂Ai,j

= − tr

(cid:19)T

(cid:35)
(I + A)−1 (Ei,j − Ej,i + Ei,jZ − Ej,iZ)

Supplemental Material: Proof of Theorem 3.2

For completeness, we restate and prove Theorem 3.2.
Theorem 3.2 Let L = L(W ) : Rn×n → R be some differ-
entiable loss function for an RNN with the recurrent weight
matrix W . Let W = W (A) := (I + A)−1 (I − A) D
where A ∈ Rn×n is skew-symmetric and D ∈ Rn×n is
a ﬁxed diagonal matrix consisting of -1 and 1 entries. Then
the gradient of L = L(W (A)) with respect to A is

∂L
∂A

= V T − V

(3)

where V := (I + A)−T ∂L
∂W
(cid:105)

Rn×n, and ∂L

∂W =

(cid:104) ∂L
∂Wi,j

∈ Rn×n

(cid:0)D + W T (cid:1), ∂L

∂A =

(cid:105)

(cid:104) ∂L
∂Ai,j

∈

Proof: Let Z := (I + A)−1(I − A). We consider the
(i, j) entry of ∂L
∂A . Taking the derivative with respect to Ai,j
where i (cid:54)= j we obtain:

∂L
∂Ai,j

=

n
(cid:88)

k,l=1

∂L
∂Wk,l

∂Wk,l
∂Ai,j

=

= tr

(cid:34)(cid:18) ∂L
∂W

D

(cid:19)T ∂Z
∂Ai,j

n
(cid:88)

k,l=1
(cid:35)

∂L
∂Wk,l

Dl,l

∂Zk,l
∂Ai,j

Using the identity (I + A) Z = I − A and taking the deriva-
tive with respect to Ai,j to both sides we obtain:

∂Z
∂Ai,j

+

∂A
∂Ai,j

Z + A

= −

∂Z
∂Ai,j

∂A
∂Ai,j

and rearranging we get:

∂Z
∂Ai,j

= − (I + A)−1

(cid:18) ∂A
∂Ai,j

+

∂A
∂Ai,j

Z

(cid:19)

Let Ei,j denote the matrix whose (i, j) entry is 1 with
all others being 0. Since A is skew-symmetric, we have
= Ei,j − Ej,i. Combining everything, we have:

∂A
∂Ai,j

= − tr

(I + A)−1Ei,j

D

D

(cid:19)T

(cid:19)T

(cid:19)T

(cid:19)T

D

D

D

(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W

(cid:32)(cid:18) ∂L

∂W

+ tr

− tr

+ tr

= −

(I + A)−1Ej,i

(I + A)−1Ei,jZ

(I + A)−1Ej,iZ

(cid:19)T

D

(I + A)−1

(cid:33)T 


(cid:35)

(cid:35)

(cid:35)

(cid:35)

i,j

(cid:34)(cid:18) ∂L
∂W

+

(cid:19)T

D

(cid:35)

(I + A)−1


(cid:32)(cid:18) ∂L

∂W

−

(cid:19)T

D

i,j
(cid:33)T

(I + A)−1

Z T





i,j

(cid:34)

+

Z

(cid:19)T

(cid:18) ∂L
∂W

D

(cid:35)

(I + A)−1

i,j

(cid:35)

(I + A)−1

i,j

(cid:33)T

(I + A)−1

(cid:0)I + Z T (cid:1)

=

(I + Z)

(cid:19)T

(cid:18) ∂L
∂W

D


(cid:32)(cid:18) ∂L

∂W

(cid:19)T

D

(cid:34)

−

(cid:34)

=

(D + W )

(I + A)−1

(cid:19)T

(cid:18) ∂L
∂W

−

(cid:20)
(I + A)−T ∂L
∂W

(cid:0)D + W T (cid:1)

(cid:35)

i,j

(cid:21)

i,j





i,j

Using the above formulation,
− ∂L
∂Aj,i
by the deﬁnition of V we get the desired result. (cid:4)

=
∂A is a skew-symmetric matrix. Finally,

= 0 and ∂L
∂Ai,j

so that ∂L

∂L
∂Aj,j

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Kyle E. Helfrich * 1 Devin Willmott * 1 Qiang Ye 1

Abstract

8
1
0
2
 
n
u
J
 
9
1
 
 
]
L
M

.
t
a
t
s
[
 
 
3
v
0
2
5
9
0
.
7
0
7
1
:
v
i
X
r
a

Recurrent Neural Networks (RNNs) are designed
to handle sequential data but suffer from vanish-
ing or exploding gradients. Recent work on Uni-
tary Recurrent Neural Networks (uRNNs) have
been used to address this issue and in some cases,
exceed the capabilities of Long Short-Term Mem-
ory networks (LSTMs). We propose a simpler
and novel update scheme to maintain orthogonal
recurrent weight matrices without using complex
valued matrices. This is done by parametrizing
with a skew-symmetric matrix using the Cayley
transform; such a parametrization is unable to rep-
resent matrices with negative one eigenvalues, but
this limitation is overcome by scaling the recur-
rent weight matrix by a diagonal matrix consisting
of ones and negative ones. The proposed training
scheme involves a straightforward gradient calcu-
lation and update step. In several experiments, the
proposed scaled Cayley orthogonal recurrent neu-
ral network (scoRNN) achieves superior results
with fewer trainable parameters than other unitary
RNNs.

1. Introduction

Deep neural networks have been used to solve numerical
problems of varying complexity. RNNs have parameters
that are reused at each time step of a sequential data point
and have achieved state of the art performance on many se-
quential learning tasks. Nearly all optimization algorithms
for neural networks involve some variant of gradient descent.
One major obstacle to training RNNs with gradient descent
is due to vanishing or exploding gradients, as described in
Bengio et al. (1993) and Pascanu et al. (2013). This prob-
lem refers to the tendency of gradients to grow or decay
exponentially in size, resulting in gradient descent steps that
are too small to be effective or so large that the network

*Equal contribution 1Department of Mathematics, Univer-
sity of Kentucky, Lexington, Kentucky, USA. Correspondence
to: Kyle Helfrich <kyle.helfrich@uky.edu>, Devin Willmott
<devin.willmott@uky.edu>.

Proceedings of the 35 th International Conference on Machine
Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018
by the author(s).

oversteps the local minimum. This issue signiﬁcantly di-
minishes RNNs’ ability to learn time-based dependencies,
particularly in problems with long input sequences.

A variety of architectures have been introduced to overcome
this difﬁculty. The current preferred RNN architectures are
those that introduce gating mechanisms to control when in-
formation is retained or discarded, such as LSTMs (Hochre-
iter & Schmidhuber, 1997) and GRUs (Cho et al., 2014),
at the cost of additional trainable parameters. More re-
cently, the unitary evolution RNN (uRNN) (Arjovsky et al.,
2016) uses a parametrization that forces the recurrent weight
matrix to remain unitary throughout training, and exhibits
superior performance to LSTMs on a variety of testing prob-
lems. For clarity, we follow the convention of Wisdom et al.
(2016) and refer to this network as the restricted-capacity
uRNN.

Since the introduction of uRNNs, orthogonal and unitary
RNN schemes have increased in both popularity and com-
plexity. Wisdom et al. (2016) use a multiplicative update
method detailed in Tagare (2011) and Wen & Yin (2013)
to expand uRNNs’ capacity to include all unitary matrices.
These networks are referred to as full-capacity uRNNs. Jing
et al. (2016) and Mhammedi et al. (2017) parametrize the
space of unitary/orthogonal matrices with Givens rotations
and Householder reﬂections, respectively, but typically opti-
mize over a subset of this space by restricting the number of
parameters. Another complex parametrization has also been
explored in Hyland & Gunnar (2017). There is also work
using unitary matrices in GRUs (i.e. in GORU of Jing et al.
(2017)) or near-unitary matrices in RNNs by restricting the
singular values of the recurrent matrix to an interval around
1 (see Vorontsov et al. (2017)). For other work in addressing
the vanishing and exploding gradient problem, see Henaff
et al. (2017) and Le et al. (2015).

In this paper, we consider RNNs with a recurrent weight
matrix taken from the set of all orthogonal matrices. To
construct the orthogonal weight matrix, we parametrize
it with a skew-symmetric matrix through a scaled Cayley
transform. This scaling allows us to avoid the singularity
issue occurring for −1 eigenvalues that may arise in the
standard Cayley transform. By tuning this scaling matrix,
the network can reach an appropriate orthogonal matrix
using a relatively simple gradient descent update step. The
resulting method achieves superior performance on various
sequential data tasks.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

The method we present in this paper works entirely with real
matrices, and as such, our results deal only with orthogonal
and skew-symmetric matrices. However, the method and all
related theory remain valid for unitary and skew-Hermitian
matrices in the complex case. The experimental results in
this paper indicate that state of the art performance can be
achieved without using complex matrices to optimize along
the Stiefel manifold.

2. Background

2.1. Recurrent Neural Networks

A recurrent neural network (RNN) is a function with input
parameters U ∈ Rn×m, recurrent parameters W ∈ Rn×n,
recurrent bias b ∈ Rn, output parameters V ∈ Rp×n, and
output bias c ∈ Rp where m is the data input size, n is the
number of hidden units, and p is the output data size. From
an input sequence x = (x1, x2, ..., xT ) where xi ∈ Rm, the
RNN returns an output sequence y = (y1, y2, ..., yT ) where
each yi ∈ Rp is given recursively by

ht = σ (U xt + W ht−1 + b)
yt = V ht + c

where h = (h0, . . . , hT −1), hi ∈ Rn is the hidden layer
state at time i and σ(·) is the activation function, which is
often a pointwise nonlinearity such as a hyperbolic tangent
function or rectiﬁed linear unit (Nair & Hinton, 2010).

2.2. Unitary RNNs

A real matrix W is orthogonal if it satisﬁes W T W = I. The
complex analog of orthogonal matrices are unitary matrices,
which satisfy W ∗W = I, where ∗ denotes the conjugate
transpose. Orthogonal and unitary matrices have the desir-
able property that (cid:107)W x(cid:107)2 = (cid:107)x(cid:107)2 for any vector x. This
property motivates the use of orthogonal or unitary matrices
in RNNs to avoid vanishing and exploding gradients, as
detailed in Arjovsky et al. (2016).

Arjovsky et al. (2016) follow the framework of the previous
section for their restricted-capacity uRNN, but introduce a
parametrization of the recurrent matrix W using a product
of simpler matrices. This parameterization is given by a
product consisting of diagonal matrices with complex norm
1, complex Householder reﬂection matrices, discrete Fourier
transform matrices, and a ﬁxed permutation matrix with the
resulting product being unitary. The Efﬁcient Unitary RNN
(EURNN) by Jing et al. (2016) and orthogonal RNN (oRNN)
by Mhammedi et al. (2017) parametrize in a similar manner
with products of Givens rotation matrices and Householder
reﬂection matrices, respectively. This can also be seen in
the parametrization through matrix exponentials in Hyland
& Gunnar (2017), which does not appear to perform as well
as the restricted-capacity uRNN.

Wisdom et al. (2016) note that this representation has only
7n parameters, which is insufﬁcient to represent all unitary
matrices for n > 7.
In response, they present the full-
capacity uRNN, which uses a multiplicative update step that
is able to reach all unitary matrices of order n.

The full-capacity uRNN aims to construct a unitary ma-
trix W (k+1) from W (k) by moving along a curve on the
Stiefel manifold {W ∈ Cn×n | W ∗W = I}. For the
network optimization, it is necessary to use a curve that is
in a descent direction of the cost function L := L(W ). In
Tagare (2011), Wen & Yin (2013), Wisdom et al. (2016), and
Vorontsov et al. (2017), a descent direction is constructed
as B(k)W (k), which is a representation of the derivative
operator DL(W (k)) in the tangent space of the Stiefel man-
ifold at W (k). Then, with B(k)W (k) deﬁning the direction
of a descent curve, an update along the Stiefel manifold is
obtained using the Cayley transform as

(cid:18)

(cid:19)−1 (cid:18)

(cid:19)

W (k+1) =

I +

B(k)

I −

B(k)

W (k)

(1)

λ
2

λ
2

where λ is the learning rate.

3. Scaled Cayley Orthogonal RNN

3.1. Cayley Transform

The Cayley transform gives a representation of orthogonal
matrices without −1 eigenvalues using skew-symmetric
matrices (i.e., matrices where AT = −A):

W = (I + A)−1 (I − A) , A = (I + W )−1 (I − W ) .

This bijection parametrizes the set of orthogonal matri-
ces without −1 eigenvalues with skew-symmetric matrices.
This direct and simple parametrization is attractive from a
machine learning perspective because it is closed under addi-
tion: the sum or difference of two skew-symmetric matrices
is also skew-symmetric, so we can use gradient descent
algorithms like RMSprop (Tieleman & Hinton, 2012) or
Adam (Kingma & Ba, 2014) to train parameters.

However, this parametrization cannot represent orthogonal
matrices with −1 eigenvalues, since in this case I +W is not
invertible. Theoretically, we can still represent matrices with
eigenvalues that are arbitrarily close to −1; however, it can
require large entries of A. For example, a 2x2 orthogonal
matrix W with eigenvalues ≈ −0.99999 ± 0.00447i and its
parametrization A by the Cayley transform is given below,
where α = 0.99999.

(cid:20)

W =

√

−α
1 − α2

(cid:21)

√

−

1 − α2
−α

(cid:20)

, A ≈

0
−447.212

447.212
0

(cid:21)

Gradient descent algorithms will learn this A matrix very
slowly, if at all. This difﬁculty can be overcome through a

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

suitable diagonal scaling according to results from Kahan
(2006).

Theorem 3.1 Every orthogonal matrix W can be expressed
as

W = (I + A)−1(I − A)D

where A = [aij] is real-valued, skew-symmetric with
|aij| ≤ 1, and D is diagonal with all nonzero entries equal
to ±1.

We call the transform in Theorem 3.1 the scaled Cayley
transform. Then, with an appropriate choice of D, the
scaled Cayley transform can reach any orthogonal matrix
including those with −1 eigenvalues. Further, it ensures that
the skew-symmetric matrix A that generates the orthogonal
matrix will be bounded.

Our proposed network, the scaled Cayley orthogonal recur-
rent neural network (scoRNN), is based on this theorem.
We parametrize the recurrent weight matrix W through a
skew-symmetric matrix A, which results in n(n−1)
trainable
weights. The recurrent matrix W is formed by the scaled
Cayley transform: W = (I + A)−1(I − A)D. The scoRNN
then operates identically to the set of equations given in Sec-
tion 2.1, but during training we update the skew-symmetric
matrix A using gradient descent, while D is ﬁxed through-
out the training process. The number of −1s on the diagonal
of D, which we call ρ, is considered a hyperparameter in
this work and is manually chosen based on the task.

2

3.2. Update Scheme

To update the recurrent parameter matrix A as described
in Section 3.1, we must ﬁnd the gradients of A by back-
propagating through the Cayley transform. The following
theorem describes these gradients. A proof is given in the
supplemental material.
Theorem 3.2 Let L = L(W ) : Rn×n → R be some differ-
entiable loss function for an RNN with the recurrent weight
matrix W . Let W = W (A) := (I + A)−1 (I − A) D
where A ∈ Rn×n is skew-symmetric and D ∈ Rn×n is
a ﬁxed diagonal matrix consisting of -1 and 1 entries. Then
the gradient of L = L(W (A)) with respect to A is

A(k+1) = A(k) − λ

∂L(W (A(k)))
∂A
I + A(k+1)(cid:17)−1 (cid:16)

(cid:16)

I − A(k+1)(cid:17)

D

W (k+1) =

The skew-symmetry of ∂L
symmetric and, in turn, W (k+1) will be orthogonal.

∂A ensures that A(k+1) will be skew-

The orthogonality of the recurrent matrix is maintained
to the order of machine precision, see section 5.5.1. The
scoRNN also maintains stable hidden state gradients in the
sense that the gradient norm does not change signiﬁcantly
in time, see section 5.5.2 for experimental results. This is
achieved with small overhead computational costs over the
standard RNN, see section 5.5.3 for experimental results
concerning computational efﬁciency.

The scoRNN, full-capacity uRNN, EURNN, and oRNN
models all have the theoretical capacity to optimize over
all orthogonal or unitary recurrent matrices, but their opti-
mization schemes are different. The full-capacity uRNN
performs a multiplicative update that moves W along the
tangent space of the Stiefel manifold, which is shown to
be a descent direction. The scoRNN, the EURNN, and
the oRNN use three different representations of orthogonal
matrices. The euRNN and oRNN express an orthogonal
matrix as a long product of simple orthogonal matrices
(Givens rotations and Householder reﬂections resp.) while
the scoRNN uses a single rational transformation. They all
use the steepest descent with respect to their correspond-
ing parametrizations. Here, different parametrizations have
different nonlinearities and hence different optimization
difﬁculties. We note that EURNN and oRNN are usually im-
plemented in a reduced capacity setting that uses a truncated
product. In our testing, it appears that increasing capacity
in EURNN and oRNN may not improve their performance.

Similar to the EURNN and oRNN, scoRNN may also be
implemented by restricting the A matrix to a banded skew-
symmetric matrix with bandwidth (cid:96) to reduce the number
of trainable parameters. Although this may work well for
particular tasks, such a modiﬁcation introduces an additional
hyperparameter and reduces representational capacity for
the recurrent weight matrix without any reduction in the
dimension of the hidden state.

∂L
∂A

= V T − V

(2)

4. Other Architecture Details

where V := (I + A)−T ∂L
∂W
(cid:105)

Rn×n, and ∂L

∂W =

(cid:104) ∂L
∂Wi,j

∈ Rn×n.

(cid:0)D + W T (cid:1), ∂L

∂A =

(cid:105)

(cid:104) ∂L
∂Ai,j

∈

At each training step of scoRNN, we ﬁrst use the standard
backpropagation algorithm to compute ∂L
∂W and then use
Theorem 3.2 to compute ∂L
∂A . We then update A with gradi-
ent descent (or a related optimization method), and recon-
struct W as follows:

The basic architecture of scoRNN is very similar to the
standard RNN as presented in Section 2.1. From a network
layer perspective, one can think of the application of the
recurrent weight in a three layer process. Let ht ∈ Rn be
the current state of the scoRNN at a particular time step, t.
We then pass ht through the following layers:
• Layer 1: ht → Dht =: h(1)
• Layer 2: h(1)

t → (I − A) h(1)

t =: h(2)

t

t

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

• Layer 3: h(2)

t → (I + A)−1 h(2)

t =: h(3)

t

5. Experiments

Note that the above scheme is the same as taking ht → W ht
as discussed previously.

4.1. MODRELU Activation Function

The modReLU function was ﬁrst implemented by Ar-
jovsky et al. (2016) to handle complex valued functions
and weights. Unlike previous methods, our method only
uses real-valued functions and weights. Nevertheless, we
have found that the modReLU function in the real case
also performed better than other activation functions. The
function is deﬁned as

σmodReLU(z) =

σReLU (|z| + b)

5.1. Copying Problem

z
|z|
(cid:40) z

=

|z| (|z| + b)
0

if |z| + b ≥ 0
if |z| + b < 0

In the following experiments, we compare the scoRNN
against LSTM and several other orthogonal and unitary
RNN models. Code for these experiments is available at
https://github.com/SpartinStuff/scoRNN.
For each experiment, we found optimal hyperparameters
for scoRNN using a grid search. For other models, we used
the best hyperparameter settings as reported for the same
testing problems, when applicable, or performed a grid
search to ﬁnd hyperparameters. For the LSTM, the forget
gate bias was tuned over the integers −4 to 4 with it set to
1.0 unless otherwise noted.

This experiment follows descriptions found in Jing et al.
(2016), Arjovsky et al. (2016), and Wisdom et al. (2016),
and tests an RNN’s ability to reproduce a sequence seen
many timesteps earlier. In the problem setup, there are 10
input classes, which we denote using the digits 0-9, with 0
being used as a ’blank’ class and 9 being used as a ’marker’
class. The RNN receives an input sequence of length T +20.
This sequence consists of entirely zeros, except for the ﬁrst
ten elements, which are uniformly sampled from classes
1-8, and a 9 placed ten timesteps from the end. The goal
for the machine is to output zeros until it sees a 9, at which
point it should output the ten elements from the beginning
of the input sequence. Thus, information must propagate
from the beginning to the end of the sequence for a machine
to successfully learn this task, making it critical to avoid
vanishing/exploding gradients.

A baseline strategy with which to compare machine perfor-
mance is that of outputting 0 until the machine sees a 9,
and then outputting 10 elements randomly sampled from
classes 1-8. The expected cross-entropy for such a strategy
is 10 log (8)
T +20 . In practice, it is common to see gated RNNs
such as LSTMs converge to this local minimum.

We use hyperparameters and hidden unit sizes as reported in
experiments in Arjovsky et al. (2016), Wisdom et al. (2016),
and Jing et al. (2016). This results in an LSTM with n = 68,
a restricted-capacity uRNN with n = 470, a full-capacity
uRNN with n = 128, and a tunable EURNN with n = 512
and capacity L = 2. As indicated in Mhammedi et al.
(2017), we were unable to obtain satisfactory performance
for the oRNN on this task. To match the ≈ 22k trainable
parameters in the LSTM and uRNNs, we use a scoRNN
with n = 190. We found the best performance with the
scoRNN came from ρ = n/2, which gives an initial W
with eigenvalues distributed uniformly on the unit circle.

Figure 1 compares each model’s performance for T = 1000
and T = 2000, with the baseline cross-entropy given as
a dashed line. In both cases, cross entropy for the LSTM,

where b is a trainable bias. In the real case, this simpliﬁes to
sign(z)σReLU(|z|+b). To implement this activation function
in scoRNN, we replace the computation of ht in Section 2.1
with

zt = U xt + W ht−1
ht = σmodReLU(zt)

We believe that the improved performance of the modReLU
over other activation functions, such as ReLU, is because it
admits both positive and negative activation values, which
appears to be important for the state transition in orthogonal
RNNs. This is similar to the hyperbolic tangent function but
does not have vanishing gradient issues.

4.2. Initialization

Modifying the initialization of our parameter matrices, in
particular our recurrent parameter matrix A, had an effect
on performance. The most effective initialization method
we found uses a technique inspired by Henaff et al. (2017).
We initialize all of the entries of A to be 0 except for 2x2
blocks along the diagonal, which are given as

B1






A =

. . .




 where Bj =

(cid:20) 0
−sj

(cid:21)

sj
0

B(cid:98)n/2(cid:99)

(cid:113) 1−cos (tj )

2

1+cos (tj ) and tj is sampled uniformly from
with sj =
(cid:2)0, π
(cid:3). The Cayley transform of this A will have eigen-
values equal to ±eitj for each j, which will be distributed
uniformly along the right unit half-circle. Multiplication
by the scaling matrix D will reﬂect ρ of these eigenvalues
across the imaginary axis. We use this method to initialize
scoRNN’s A matrix in all experiments listed in section 5.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Figure 1. Cross entropy of each machine on the copying problem with T = 1000 (left) and T = 2000 (right).

restricted-capacity uRNN, and EURNN remains at the base-
line or does not entirely converge over the entire experi-
ment. For the T = 1000 test, the full-capacity uRNN and
scoRNN converge immediately to zero entropy solutions,
with the full-capacity uRNN converging slightly faster. For
T = 2000, the full-capacity uRNN remains at the base-
line for several thousand iterations, but is eventually able to
ﬁnd a correct solution. In contrast, the scoRNN error has a
smooth convergence that bypasses the baseline, but does so
more slowly than the full-capacity uRNN.

uRNN. We tested both the tunable-style EURNN and FFT-
style EURNN with n = 512, and found better results from
the tunable-style (≈ 3k parameters) for sequence lengths
T = 200 and T = 400, and from the FFT-style (≈ 7k pa-
rameters) for sequence length T = 750. The best hyperpa-
rameters for the oRNN were in accordance with Mhammedi
et al. (2017) which was n = 128 with 16 reﬂections with
a learning rate of 0.01, ≈2.6k parameters. We found that
performance decreased when matching the number of reﬂec-
tions to the hidden size to increase the number of parameters.

5.2. Adding Problem

We examined a variation of the adding problem as proposed
by Arjovsky et al. (2016) which is based on the work of
Hochreiter & Schmidhuber (1997). This variation involves
passing two sequences concurrently into the RNN, each of
length T . The ﬁrst sequence is a sequence of digits sam-
pled uniformly with values ranging in a half-open interval,
U[0, 1). The second sequence is a marker sequence con-
sisting of all zeros except for two entries that are marked
by one. The ﬁrst 1 is located uniformly within the interval
[1, T
2 ) of the sequence and the second 1 is located uniformly
within the interval [ T
2 , T ) of the sequence. The label for
each pair of sequences is the sum of the two entries that
are marked by one, which forces the machine to identify
relevant information in the ﬁrst sequence among noise. As
the sequence length increases, it becomes more crucial to
avoid vanishing/exploding gradients. Naively predicting
one regardless of the sequence gives an expected mean
squared error (MSE) of approximately 0.167. This will be
considered as the baseline.

The number of hidden units for the LSTM, scoRNN and
uRNNs were adjusted so that each had approximately 15k
trainable parameters. This results in n = 170 for the
scoRNN, n = 60 for the LSTM, n = 120 for the Full-
Capacity uRNN, and n = 950 for the restricted-capacity

Figure 2. Test set MSE for each machine on the adding problem
with sequence lengths of T = 200 (top), T = 400 (middle), and
T = 750 (bottom).

The test set MSE results for sequence lengths T = 200,
T = 400, and T = 750 can be found in Figure 2. A training
set size of 100,000 and a testing set size of 10,000 were
used for each sequence length. For each case, the networks
start at or near the baseline MSE, except for the EURNN
for T = 750, and drop towards zero after a few epochs.
As the sequence length increases, the number of epochs

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

before the drop increases. We found the best settings for
the scoRNN were ρ = n/2 for T = 200 and ρ = 7n/10 for
T = 400 and T = 750. The forget bias for the LSTM was 2
for sequence length 200, 4 for sequence length 400, and 0
for sequence length 750. As can be seen, the LSTM error
drops precipitously across the board. Although the oRNN
begins to drop below the baseline before scoRNN, it has a
much more irregular descent curve, and jumps back to the
baseline after several epochs.

5.3. Pixel-by-Pixel MNIST

We ran two experiments based around classifying samples
from the well-known MNIST dataset (LeCun et al.). Follow-
ing the implementation of Le et al. (2015), each pixel of the
image is fed into the RNN sequentially, resulting in a single
pixel sequence length of 784. In the ﬁrst experiment, which
we refer to as unpermuted MNIST, pixels are arranged in
the sequence row-by-row. In the second, which we call
permuted MNIST, a ﬁxed permutation is applied to training
and testing sequences.

All scoRNN machines were trained with the RMSprop opti-
mization algorithm. Input and output weights used a learn-
ing rate of 10−3, while the recurrent parameters used a
learning rate of 10−4 (for n = 170) or 10−5 (for n = 360
and n = 512). For unpermuted MNIST, we found ρ to be
optimal at n/10, while the best value of ρ for permuted
MNIST was n/2. We suspect that the difference of these
two values comes from the different types of dependencies
in each: unpermuted MNIST has mostly local dependencies,
while permuted MNIST requires learning many long-term
dependencies, which appear to be more easily modeled
when the diagonal of D has a higher proportion of −1s.

Each experiment used a training set of 55,000 images and a
test set of 10,000 testing images. Each machine was trained
for 70 epochs, and test set accuracy, the percentage of test
images classiﬁed correctly, was evaluated at the conclusion
of each epoch. Figure 3 shows test set accuracy over time,
and the best performance over all epochs by each machine
is given in Table 1.

In both experiments, the 170 hidden unit scoRNN gives sim-
ilar performance to both of the 512 hidden unit uRNNs using
a much smaller hidden dimension and, in the case of the
full-capacity uRNN, an order of magnitude fewer parame-
ters. Matching the number of parameters (≈ 69k), the 2170
restricted-capacity uRNN performance was comparable to
the 360 hidden unit scoRNN for unpermuted MNIST, but
performed worse for permuted MNIST, and required a much
larger hidden size and a signiﬁcantly longer run time, see
5.5.3. As in experiments presented in Arjovsky et al. (2016)
and Wisdom et al. (2016), orthogonal and unitary RNNs
are unable to outperform the LSTM in the unpermuted case.
However, the 512 hidden unit scoRNN outperforms all other

Table 1. Results for unpermuted and permuted pixel-by-pixel
MNIST experiments. Evaluation accuracies are based on the best
test accuracy at the end of every epoch. Asterisks indicate reported
results from (Jing et al., 2016) and (Mhammedi et al., 2017).

PERMUTED

MODEL

N

#

MNIST MNIST

170 ≈ 16K
360 ≈ 69K
512 ≈ 137K
128 ≈ 68K
256 ≈ 270K
512 ≈ 1, 058K

SCORNN
SCORNN
SCORNN
LSTM
LSTM
LSTM
RESTRICTED URNN 512 ≈ 16K
RESTRICTED URNN 2170 ≈ 69K
116 ≈ 16K
FULL URNN
512 ≈ 270K
FULL URNN
≈ 9K
512
EURNN
256 ≈ 11K
ORNN

PARAMS TEST ACC. TEST ACC.
0.973
0.983
0.985
0.987
0.989
0.985
0.976
0.984
0.947
0.974
-
0.972∗

0.943
0.962
0.966
0.920
0.929
0.920
0.945
0.953
0.925
0.947
0.937∗
-

unitary RNNs. On permuted MNIST, the 512 hidden unit
scoRNN achieves a test-set accuracy of 96.6%, outperform-
ing all other machines. We believe this is a state of the art
result.

5.4. TIMIT Speech Dataset

To see how the models performed on audio data, speech pre-
diction was performed on the TIMIT dataset (Garofolo et al.,
1993), a collection of real-world speech recordings. Exclud-
ing the dialect SA sentences and using only the core test
set, the dataset consisted of 3,696 training and 192 testing
audio ﬁles. Similar to experiments in Wisdom et al. (2016),
audio ﬁles were downsampled to 8kHz and a short-time
Fourier transform (STFT) was applied with a Hann win-
dow of 256 samples and a window hop of 128 samples (16
milliseconds). The result is a set of frames, each with 129
complex-valued Fourier amplitudes. The log-magnitude of
these amplitudes is used as the input data for the machines.
For each model, the hidden layer sizes were adjusted such
that each model had approximately equal numbers of train-
able parameters. For scoRNN, we used the Adam optimizer
with learning rate 10−3 to train input and output parameters,
and RMSprop with a learning rate of 10−3 (for n = 224) or
10−4 (for n = 322, 425) to train the recurrent weight matrix.
The number of negative eigenvalues used was ρ = n/10.
The LSTM forget gate bias was initialized to -4.

The loss function used for training was the mean squared er-
ror (MSE) between the predicted and actual log-magnitudes
of the next time frame over the entire sequence. Table
2 contains the MSE on validation and testing sets, which
shows that all scoRNN models achieve a smaller MSE than

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Figure 3. Test accuracy for unpermuted and permuted MNIST over time. All scoRNN models and the best performing LSTM, restriced
capacity uRNN, and full-capacity uRNN are shown.

Due to the accumulation of rounding errors over a large
number of repeated matrix multiplications, the recurrent
weight may not remain unitary throughout training. To in-
vestigate this, we ran the scoRNN and full-capacity uRNN
with equal hidden unit sizes of n = 512 on the unpermuted
MNIST experiment and checked for loss of orthogonality
at each epoch. The results of this experiment are shown in
Figure 4. As can be seen, the recurrent weight matrix for
the full-capacity uRNN becomes less unitary over time, but
the orthogonality recurrent weight matrix for scoRNN is not
affected by roundoff errors.

This can become particularly apparent when performing op-
erations using a graphics processing unit (GPU) which have
a much lower machine precision than a standard computer
processing unit (CPU).

Table 2. Results for the TIMIT speech dataset. Evaluation based
on MSE and various audio metrics

N

MODEL

#
PARAMS
≈ 83K
224
SCORNN
322 ≈ 135K
SCORNN
425 ≈ 200K
SCORNN
≈ 83K
84
LSTM
120 ≈ 135K
LSTM
158 ≈ 200K
LSTM
≈ 83K
REST. URNN 158
REST. URNN 256 ≈ 135K
REST. URNN 378 ≈ 200K
≈ 83K
128
FULL URNN
192 ≈ 135K
FULL URNN
256 ≈ 200K
FULL URNN

VALID.
MSE
9.26
8.48
7.97
15.42
13.93
13.66
15.57
15.90
16.00
15.07
15.10
14.96

EVAL.
MSE
8.50
7.82
7.36
14.30
12.95
12.62
18.51
15.31
15.15
14.58
14.50
14.69

all LSTM and unitary RNN models. Similar to Wisdom
et al. (2016), we reconstructed audio ﬁles using the pre-
dicted log-magnitudes from each machine and evaluated
them on several audio metrics. We found that the scoRNN
predictions achieved better scores on the signal-to-noise
ratio metric SegSNR (Brookes et al., 1997), but performed
slightly worse than the full-capacity uRNN predictions on
STOI (Taal et al., 2011) and PESQ (Rix et al., 2001), both
metrics used to measure human intelligibility and perception.

5.5. Further Analysis

5.5.1. LOSS OF ORTHOGONALITY

(cid:1) for the full-capacity
Figure 4. Unitary scores (cid:0)(cid:107)W ∗W − I(cid:107)F
uRNN recurrent weight matrix and orthogonality scores
(cid:13)W T W − I(cid:13)
(cid:0)(cid:13)
(cid:1)for the scoRNN recurrent weight matrix using
(cid:13)F
a GPU on the pixel-by-pixel MNIST experiment.

In the scoRNN architecture, the recurrent weight matrix is
parameterized with a skew-symmetric matrix through the
Cayley transform. This ensures the computed recurrent
weight matrix in ﬂoating point arithmetic is orthogonal to
the order of machine precision after each update step. Un-
like scoRNN, the full-capacity uRNN maintains a unitary
recurrent weight matrix by a multiplicative update scheme.

5.5.2. VANISHING GRADIENTS

As discussed in Arjovsky et al. (2016),
the vanish-
ing/exploding gradient problem is caused by rapid growth
or decay of the gradient of the hidden state ∂L
as we move
∂ht
earlier in the sequence (that is, as t decreases). To see if
vanishing/exploding gradients affect the scoRNN model, we
examined hidden state gradients in the scoRNN and LSTM

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

models on the adding problem experiment (see section 5.2)
with sequence length T = 500.

The norms of these gradients are shown at two different
points in time during training in Figure 5. As can be seen,
LSTM gradient norms decrease steadily as we move away
from the end of the sequence. The right half of Figure 5
shows that this vanishing effect is exacerbated by training
after 300 iterations.

In contrast, scoRNN gradients decay by less than an order
of magnitude at the beginning of training, remaining near
10−2 for all timesteps. Even after 300 iterations of training,
scoRNN hidden state gradients decay only slightly, from
10−3 at t = 500 to 10−4 at t = 0. This allows information
to easily propagate from beginning of the sequence to end.

Table 3. Timing results for the unpermuted MNIST dataset.

# params Minutes Per Epoch

n
Model
116
RNN
170
scoRNN
512
Rest. uRNN
116
Full uRNN
128
LSTM
scoRNN
360
Rest. uRNN 2,170
360
RNN
512
scoRNN
360
Full uRNN
512
RNN
256
LSTM
512
Full uRNN
512
LSTM

≈ 16k
≈ 16k
≈ 16k
≈ 16k
≈ 68k
≈ 69k
≈ 69k
≈ 137k
≈ 137k
≈ 137k
≈ 270k
≈ 270k
≈ 270k
≈ 1, 058k

2.3
5.3
8.2
10.8
5.0
7.4
50.1
2.3
11.2
25.8
2.4
5.2
27.9
5.6

The RNN and LSTM models were fastest, and hidden sizes
largely did not affect time taken per epoch; we suspect
this is because these models were built in to Tensorﬂow.
The LSTMs are of similar speed to the n = 170 scoRNN,
while they are approximately twice as fast as the n = 512
scoRNN. Matching the number of hidden parameters, the
scoRNN model with n = 170 is approximately 1.5 times
faster than the restricted-capacity uRNN with n = 512,
and twice as fast as the full-capacity uRNN with n = 116.
This relationship can also be seen in the scoRNN and full-
capacity uRNN models with ≈ 137k parameters, where the
scoRNN takes 11.2 minutes per epoch as compared to 25.8
minutes for the full-capacity uRNN.

6. Conclusion

There has been recent promising work with RNN architec-
tures using unitary and orthogonal recurrent weight ma-
trices to address the vanishing/exploding gradient prob-
lem. The unitary/orthogonal RNNs are typically imple-
mented with complex valued matrices or in restricted capac-
ity. The scoRNN developed in this paper uses real valued
orthogonal recurrent weight matrices with a simpler im-
plementation scheme, with the representational capacity to
reach all orthogonal matrices through the Cayley transform
parametrization. The resulting model’s additive update step
with respect to this parametrization maintains the orthog-
onality of the recurrent weight matrix in the presence of
roundoff errors. Results from our experiments show that
scoRNN is among the top performers in all tests with a
smooth and stable convergence curve. This superior perfor-
mance is achieved, in some cases, with a smaller hidden
state dimension than other models.

Figure 5. Gradient norms (cid:107) ∂L
(cid:107) for scoRNN and LSTM models
∂ht
during training on the adding problem. The x-axis shows different
values of t. The left plot shows gradients at the beginning of
training, and the right shows gradients after 300 training iterations.

5.5.3. COMPLEXITY AND SPEED

The scoRNN architecture is similar in complexity and mem-
ory usage to a standard RNN except for the additional mem-
ory requirement of storing the n(n − 1)/2 entries of the
skew-symmetric matrix A and the additional complexity of
forming the recurrent weight matrix W from A with the
scaled Cayley transform. We note that the recurrent weight
matrix is generated from the skew-symmetric A matrix only
once per training iteration; this O(n3) computational cost
is comparable to one training iteration of a standard RNN,
which is O(BT n2) where T is the length of the sequences
and B is the mini-batch size, when BT is comparable to n.

To experimentally quantify potential differences between
scoRNN and other models, the real run-time for the unper-
muted MNIST experiment were recorded and are included
in Table 3. All models were run on the same machine, which
has an Intel Core i5-7400 processor and an nVidia GeForce
GTX 1080 GPU. The scoRNN and LSTM models were run
in Tensorﬂow, while the full and restricted capacity uRNNs
were run using code provided in Wisdom et al. (2016).

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Acknowledgements

This research was supported in part by NSF Grants DMS-
1317424 and DMS-1620082.

References

Arjovsky, M., Shah, A., and Bengio, Y. Unitary evolution
recurrent neural networks. In Proceedings of the 33rd
International Conference on Machine Learning (ICML
2016), volume 48, pp. 1120–1128, New York, NY, 2016.
JMLR.

Bengio, Y., Frasconi, P., and Simard, P. The problem of
learning long-term dependencies in recurrent networks.
In Proceedings of 1993 IEEE International Conference
on Neural Networks (ICNN ’93), pp. 1183–1195, San
Francisco, CA, 1993. IEEE Press.

Brookes, M. et al. Voicebox: Speech processing toolbox for
matlab. Software, available [Mar. 2011] from www. ee. ic.
ac. uk/hp/staff/dmb/voicebox/voicebox. html, 47, 1997.

Cho, K., van Merrienboer, B., Bahdanau, D., and Ben-
gio, Y. On the properties of neural machine transla-
tion: Encoder-decoder approaches, 2014. URL https:
//arxiv.org/abs/1409.1259.

Garofolo, J., Lamel, L., Fisher, W., Fiscus, J., Pallett, D.,
Dahlgren, N., and Zue, V. Timit acoustic-phonetic contin-
uous speech corpus ldc93s1. Technical report, Philadel-
phia: Linguistic Data Consortium, Philadelphia, PA,
1993.

Henaff, M., Szlam, A., and LeCun, Y. Recurrent orthogonal
In Proceedings of
networks and long-memory tasks.
the 33rd International Conference on Machine Learning
(ICML 2017), volume 48, New York, NY, 2017. JMLR:
W&CP.

Hochreiter, S. and Schmidhuber, J. Long short-term memory.

Neural Computation, 9(8):1735–1780, 1997.

Hyland, S. L. and Gunnar, R. Learning unitary operators
with help from u(n). In Proceedings of the 31st AAAI Con-
ference on Artiﬁcial Intelligence (AAI 2017), pp. 2050–
2058, San Francisco, CA, 2017.

Jing, L., Shen, Y., Dubˇcek, T., Peurifoy, J., Skirlo, S.,
Tegmark, M., and Soljaˇci´c, M. Tunable efﬁcient uni-
tary neural networks (eunn) and their application to rnn,
2016.

Jing, L., G¨ulc¸ehre, C., Peurifoy, J., Shen, Y., Tegmark, M.,
Soljaˇci´c, M., and Bengio, Y. Gated orthogonal recurrent
units: On learning to forget. 2017. URL https://
arxiv.org/abs/1706.02761.

Kahan, W. Is there a small skew cayley transform with zero
diagonal? Linear algebra and its applications, 417(2-3):
335–341, 2006.

Kingma, D. and Ba, J. Adam: A method for stochastic
optimization. arXiv preprint arXiv:1412.6980, 2014.

Le, Q. V., Jaitly, N., and Hinton, G. E. A simple way to
initialize recurrent networks of rectiﬁed linear units, 2015.
URL https://arxiv.org/abs/1504.00941.

LeCun, Y., Cortes, C., and Burges, C. J. C. The mnist
database. URL http://yann.lecun.com/exdb/
mnist/.

Mhammedi, Z., Hellicar, A., Rahman, A., and Bailey, J.
Efﬁcient orthogonal parameterisation of recurrent neural
networks using householder reﬂections. In Proceedings of
the 34th International Conference on Machine Learning
(ICML 2017), Sydney, Australia, 2017. PMLR: 70.

Nair, V. and Hinton, G. E. Rectiﬁed linear units improve
In 27th International
restricted boltzmann machines.
Conference on Machine Learning (ICML 2010), Haifa,
Israel, 2010.

Pascanu, R., Mikolov, T., and Bengio, Y. On the difﬁculty of
training recurrent neural networks. In 30th International
Conference on Machine Learning (ICML 2013), Atlanta,
GA, 2013.

Rix, A. W., Beerends, J. G., Hollier, M. P., and Hekstra,
A. P. Perceptual evaluation of speech quality (pesq)-a
new method for speech quality assessment of telephone
networks and codecs. In Acoustics, Speech, and Signal
Processing, 2001. Proceedings.(ICASSP’01). 2001 IEEE
International Conference on, volume 2, pp. 749–752.
IEEE, 2001.

Taal, C. H., Hendriks, R. C., Heusdens, R., and Jensen,
J. An algorithm for intelligibility prediction of time–
frequency weighted noisy speech. IEEE Transactions on
Audio, Speech, and Language Processing, 19(7):2125–
2136, 2011.

Tagare, H. D. Notes on optimization on stiefel manifolds.

Technical report, Yale University, 2011.

Tieleman, T. and Hinton, G. Lecture 6.5-rmsprop: Divide
the gradient by a running average of its recent magnitude.
COURSERA: Neural networks for machine learning, 4
(2):26–31, 2012.

Vorontsov, E., Trabelsi, C., Kadoury, S., and Pal, C. On
orthogonality and learning recurrent networks with long
term dependencies, 2017.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Wen, Z. and Yin, W. A feasible method for optimization
with orthogonality constraints. In Mathematical Program-
ming, volume 142(1-2), pp. 397–434. 2013.

Wisdom, S., Powers, T., Hershey, J., Roux, J. L., and Atlas,
L. Full-capacity unitary recurrent neural networks. In
Lee, D. D., Sugiyama, M., Luxburg, U. V., Guyon, I., and
Garnett, R. (eds.), Advances in Neural Information Pro-
cessing Systems 29, pp. 4880–4888. Curran Associates,
Inc., 2016.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

∂L
∂Ai,j

= − tr

(cid:19)T

(cid:35)
(I + A)−1 (Ei,j − Ej,i + Ei,jZ − Ej,iZ)

Supplemental Material: Proof of Theorem 3.2

For completeness, we restate and prove Theorem 3.2.
Theorem 3.2 Let L = L(W ) : Rn×n → R be some differ-
entiable loss function for an RNN with the recurrent weight
matrix W . Let W = W (A) := (I + A)−1 (I − A) D
where A ∈ Rn×n is skew-symmetric and D ∈ Rn×n is
a ﬁxed diagonal matrix consisting of -1 and 1 entries. Then
the gradient of L = L(W (A)) with respect to A is

∂L
∂A

= V T − V

(3)

where V := (I + A)−T ∂L
∂W
(cid:105)

Rn×n, and ∂L

∂W =

(cid:104) ∂L
∂Wi,j

∈ Rn×n

(cid:0)D + W T (cid:1), ∂L

∂A =

(cid:105)

(cid:104) ∂L
∂Ai,j

∈

Proof: Let Z := (I + A)−1(I − A). We consider the
(i, j) entry of ∂L
∂A . Taking the derivative with respect to Ai,j
where i (cid:54)= j we obtain:

∂L
∂Ai,j

=

n
(cid:88)

k,l=1

∂L
∂Wk,l

∂Wk,l
∂Ai,j

=

= tr

(cid:34)(cid:18) ∂L
∂W

D

(cid:19)T ∂Z
∂Ai,j

n
(cid:88)

k,l=1
(cid:35)

∂L
∂Wk,l

Dl,l

∂Zk,l
∂Ai,j

Using the identity (I + A) Z = I − A and taking the deriva-
tive with respect to Ai,j to both sides we obtain:

∂Z
∂Ai,j

+

∂A
∂Ai,j

Z + A

= −

∂Z
∂Ai,j

∂A
∂Ai,j

and rearranging we get:

∂Z
∂Ai,j

= − (I + A)−1

(cid:18) ∂A
∂Ai,j

+

∂A
∂Ai,j

Z

(cid:19)

Let Ei,j denote the matrix whose (i, j) entry is 1 with
all others being 0. Since A is skew-symmetric, we have
= Ei,j − Ej,i. Combining everything, we have:

∂A
∂Ai,j

= − tr

(I + A)−1Ei,j

D

D

(cid:19)T

(cid:19)T

(cid:19)T

(cid:19)T

D

D

D

(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W

(cid:32)(cid:18) ∂L

∂W

+ tr

− tr

+ tr

= −

(I + A)−1Ej,i

(I + A)−1Ei,jZ

(I + A)−1Ej,iZ

(cid:19)T

D

(I + A)−1

(cid:33)T 


(cid:35)

(cid:35)

(cid:35)

(cid:35)

i,j

(cid:34)(cid:18) ∂L
∂W

+

(cid:19)T

D

(cid:35)

(I + A)−1


(cid:32)(cid:18) ∂L

∂W

−

(cid:19)T

D

i,j
(cid:33)T

(I + A)−1

Z T





i,j

(cid:34)

+

Z

(cid:19)T

(cid:18) ∂L
∂W

D

(cid:35)

(I + A)−1

i,j

(cid:35)

(I + A)−1

i,j

(cid:33)T

(I + A)−1

(cid:0)I + Z T (cid:1)

=

(I + Z)

(cid:19)T

(cid:18) ∂L
∂W

D


(cid:32)(cid:18) ∂L

∂W

(cid:19)T

D

(cid:34)

−

(cid:34)

=

(D + W )

(I + A)−1

(cid:19)T

(cid:18) ∂L
∂W

−

(cid:20)
(I + A)−T ∂L
∂W

(cid:0)D + W T (cid:1)

(cid:35)

i,j

(cid:21)

i,j





i,j

Using the above formulation,
− ∂L
∂Aj,i
by the deﬁnition of V we get the desired result. (cid:4)

=
∂A is a skew-symmetric matrix. Finally,

= 0 and ∂L
∂Ai,j

so that ∂L

∂L
∂Aj,j

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Kyle E. Helfrich * 1 Devin Willmott * 1 Qiang Ye 1

Abstract

8
1
0
2
 
n
u
J
 
9
1
 
 
]
L
M

.
t
a
t
s
[
 
 
3
v
0
2
5
9
0
.
7
0
7
1
:
v
i
X
r
a

Recurrent Neural Networks (RNNs) are designed
to handle sequential data but suffer from vanish-
ing or exploding gradients. Recent work on Uni-
tary Recurrent Neural Networks (uRNNs) have
been used to address this issue and in some cases,
exceed the capabilities of Long Short-Term Mem-
ory networks (LSTMs). We propose a simpler
and novel update scheme to maintain orthogonal
recurrent weight matrices without using complex
valued matrices. This is done by parametrizing
with a skew-symmetric matrix using the Cayley
transform; such a parametrization is unable to rep-
resent matrices with negative one eigenvalues, but
this limitation is overcome by scaling the recur-
rent weight matrix by a diagonal matrix consisting
of ones and negative ones. The proposed training
scheme involves a straightforward gradient calcu-
lation and update step. In several experiments, the
proposed scaled Cayley orthogonal recurrent neu-
ral network (scoRNN) achieves superior results
with fewer trainable parameters than other unitary
RNNs.

1. Introduction

Deep neural networks have been used to solve numerical
problems of varying complexity. RNNs have parameters
that are reused at each time step of a sequential data point
and have achieved state of the art performance on many se-
quential learning tasks. Nearly all optimization algorithms
for neural networks involve some variant of gradient descent.
One major obstacle to training RNNs with gradient descent
is due to vanishing or exploding gradients, as described in
Bengio et al. (1993) and Pascanu et al. (2013). This prob-
lem refers to the tendency of gradients to grow or decay
exponentially in size, resulting in gradient descent steps that
are too small to be effective or so large that the network

*Equal contribution 1Department of Mathematics, Univer-
sity of Kentucky, Lexington, Kentucky, USA. Correspondence
to: Kyle Helfrich <kyle.helfrich@uky.edu>, Devin Willmott
<devin.willmott@uky.edu>.

Proceedings of the 35 th International Conference on Machine
Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018
by the author(s).

oversteps the local minimum. This issue signiﬁcantly di-
minishes RNNs’ ability to learn time-based dependencies,
particularly in problems with long input sequences.

A variety of architectures have been introduced to overcome
this difﬁculty. The current preferred RNN architectures are
those that introduce gating mechanisms to control when in-
formation is retained or discarded, such as LSTMs (Hochre-
iter & Schmidhuber, 1997) and GRUs (Cho et al., 2014),
at the cost of additional trainable parameters. More re-
cently, the unitary evolution RNN (uRNN) (Arjovsky et al.,
2016) uses a parametrization that forces the recurrent weight
matrix to remain unitary throughout training, and exhibits
superior performance to LSTMs on a variety of testing prob-
lems. For clarity, we follow the convention of Wisdom et al.
(2016) and refer to this network as the restricted-capacity
uRNN.

Since the introduction of uRNNs, orthogonal and unitary
RNN schemes have increased in both popularity and com-
plexity. Wisdom et al. (2016) use a multiplicative update
method detailed in Tagare (2011) and Wen & Yin (2013)
to expand uRNNs’ capacity to include all unitary matrices.
These networks are referred to as full-capacity uRNNs. Jing
et al. (2016) and Mhammedi et al. (2017) parametrize the
space of unitary/orthogonal matrices with Givens rotations
and Householder reﬂections, respectively, but typically opti-
mize over a subset of this space by restricting the number of
parameters. Another complex parametrization has also been
explored in Hyland & Gunnar (2017). There is also work
using unitary matrices in GRUs (i.e. in GORU of Jing et al.
(2017)) or near-unitary matrices in RNNs by restricting the
singular values of the recurrent matrix to an interval around
1 (see Vorontsov et al. (2017)). For other work in addressing
the vanishing and exploding gradient problem, see Henaff
et al. (2017) and Le et al. (2015).

In this paper, we consider RNNs with a recurrent weight
matrix taken from the set of all orthogonal matrices. To
construct the orthogonal weight matrix, we parametrize
it with a skew-symmetric matrix through a scaled Cayley
transform. This scaling allows us to avoid the singularity
issue occurring for −1 eigenvalues that may arise in the
standard Cayley transform. By tuning this scaling matrix,
the network can reach an appropriate orthogonal matrix
using a relatively simple gradient descent update step. The
resulting method achieves superior performance on various
sequential data tasks.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

The method we present in this paper works entirely with real
matrices, and as such, our results deal only with orthogonal
and skew-symmetric matrices. However, the method and all
related theory remain valid for unitary and skew-Hermitian
matrices in the complex case. The experimental results in
this paper indicate that state of the art performance can be
achieved without using complex matrices to optimize along
the Stiefel manifold.

2. Background

2.1. Recurrent Neural Networks

A recurrent neural network (RNN) is a function with input
parameters U ∈ Rn×m, recurrent parameters W ∈ Rn×n,
recurrent bias b ∈ Rn, output parameters V ∈ Rp×n, and
output bias c ∈ Rp where m is the data input size, n is the
number of hidden units, and p is the output data size. From
an input sequence x = (x1, x2, ..., xT ) where xi ∈ Rm, the
RNN returns an output sequence y = (y1, y2, ..., yT ) where
each yi ∈ Rp is given recursively by

ht = σ (U xt + W ht−1 + b)
yt = V ht + c

where h = (h0, . . . , hT −1), hi ∈ Rn is the hidden layer
state at time i and σ(·) is the activation function, which is
often a pointwise nonlinearity such as a hyperbolic tangent
function or rectiﬁed linear unit (Nair & Hinton, 2010).

2.2. Unitary RNNs

A real matrix W is orthogonal if it satisﬁes W T W = I. The
complex analog of orthogonal matrices are unitary matrices,
which satisfy W ∗W = I, where ∗ denotes the conjugate
transpose. Orthogonal and unitary matrices have the desir-
able property that (cid:107)W x(cid:107)2 = (cid:107)x(cid:107)2 for any vector x. This
property motivates the use of orthogonal or unitary matrices
in RNNs to avoid vanishing and exploding gradients, as
detailed in Arjovsky et al. (2016).

Arjovsky et al. (2016) follow the framework of the previous
section for their restricted-capacity uRNN, but introduce a
parametrization of the recurrent matrix W using a product
of simpler matrices. This parameterization is given by a
product consisting of diagonal matrices with complex norm
1, complex Householder reﬂection matrices, discrete Fourier
transform matrices, and a ﬁxed permutation matrix with the
resulting product being unitary. The Efﬁcient Unitary RNN
(EURNN) by Jing et al. (2016) and orthogonal RNN (oRNN)
by Mhammedi et al. (2017) parametrize in a similar manner
with products of Givens rotation matrices and Householder
reﬂection matrices, respectively. This can also be seen in
the parametrization through matrix exponentials in Hyland
& Gunnar (2017), which does not appear to perform as well
as the restricted-capacity uRNN.

Wisdom et al. (2016) note that this representation has only
7n parameters, which is insufﬁcient to represent all unitary
matrices for n > 7.
In response, they present the full-
capacity uRNN, which uses a multiplicative update step that
is able to reach all unitary matrices of order n.

The full-capacity uRNN aims to construct a unitary ma-
trix W (k+1) from W (k) by moving along a curve on the
Stiefel manifold {W ∈ Cn×n | W ∗W = I}. For the
network optimization, it is necessary to use a curve that is
in a descent direction of the cost function L := L(W ). In
Tagare (2011), Wen & Yin (2013), Wisdom et al. (2016), and
Vorontsov et al. (2017), a descent direction is constructed
as B(k)W (k), which is a representation of the derivative
operator DL(W (k)) in the tangent space of the Stiefel man-
ifold at W (k). Then, with B(k)W (k) deﬁning the direction
of a descent curve, an update along the Stiefel manifold is
obtained using the Cayley transform as

(cid:18)

(cid:19)−1 (cid:18)

(cid:19)

W (k+1) =

I +

B(k)

I −

B(k)

W (k)

(1)

λ
2

λ
2

where λ is the learning rate.

3. Scaled Cayley Orthogonal RNN

3.1. Cayley Transform

The Cayley transform gives a representation of orthogonal
matrices without −1 eigenvalues using skew-symmetric
matrices (i.e., matrices where AT = −A):

W = (I + A)−1 (I − A) , A = (I + W )−1 (I − W ) .

This bijection parametrizes the set of orthogonal matri-
ces without −1 eigenvalues with skew-symmetric matrices.
This direct and simple parametrization is attractive from a
machine learning perspective because it is closed under addi-
tion: the sum or difference of two skew-symmetric matrices
is also skew-symmetric, so we can use gradient descent
algorithms like RMSprop (Tieleman & Hinton, 2012) or
Adam (Kingma & Ba, 2014) to train parameters.

However, this parametrization cannot represent orthogonal
matrices with −1 eigenvalues, since in this case I +W is not
invertible. Theoretically, we can still represent matrices with
eigenvalues that are arbitrarily close to −1; however, it can
require large entries of A. For example, a 2x2 orthogonal
matrix W with eigenvalues ≈ −0.99999 ± 0.00447i and its
parametrization A by the Cayley transform is given below,
where α = 0.99999.

(cid:20)

W =

√

−α
1 − α2

(cid:21)

√

−

1 − α2
−α

(cid:20)

, A ≈

0
−447.212

447.212
0

(cid:21)

Gradient descent algorithms will learn this A matrix very
slowly, if at all. This difﬁculty can be overcome through a

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

suitable diagonal scaling according to results from Kahan
(2006).

Theorem 3.1 Every orthogonal matrix W can be expressed
as

W = (I + A)−1(I − A)D

where A = [aij] is real-valued, skew-symmetric with
|aij| ≤ 1, and D is diagonal with all nonzero entries equal
to ±1.

We call the transform in Theorem 3.1 the scaled Cayley
transform. Then, with an appropriate choice of D, the
scaled Cayley transform can reach any orthogonal matrix
including those with −1 eigenvalues. Further, it ensures that
the skew-symmetric matrix A that generates the orthogonal
matrix will be bounded.

Our proposed network, the scaled Cayley orthogonal recur-
rent neural network (scoRNN), is based on this theorem.
We parametrize the recurrent weight matrix W through a
skew-symmetric matrix A, which results in n(n−1)
trainable
weights. The recurrent matrix W is formed by the scaled
Cayley transform: W = (I + A)−1(I − A)D. The scoRNN
then operates identically to the set of equations given in Sec-
tion 2.1, but during training we update the skew-symmetric
matrix A using gradient descent, while D is ﬁxed through-
out the training process. The number of −1s on the diagonal
of D, which we call ρ, is considered a hyperparameter in
this work and is manually chosen based on the task.

2

3.2. Update Scheme

To update the recurrent parameter matrix A as described
in Section 3.1, we must ﬁnd the gradients of A by back-
propagating through the Cayley transform. The following
theorem describes these gradients. A proof is given in the
supplemental material.
Theorem 3.2 Let L = L(W ) : Rn×n → R be some differ-
entiable loss function for an RNN with the recurrent weight
matrix W . Let W = W (A) := (I + A)−1 (I − A) D
where A ∈ Rn×n is skew-symmetric and D ∈ Rn×n is
a ﬁxed diagonal matrix consisting of -1 and 1 entries. Then
the gradient of L = L(W (A)) with respect to A is

A(k+1) = A(k) − λ

∂L(W (A(k)))
∂A
I + A(k+1)(cid:17)−1 (cid:16)

(cid:16)

I − A(k+1)(cid:17)

D

W (k+1) =

The skew-symmetry of ∂L
symmetric and, in turn, W (k+1) will be orthogonal.

∂A ensures that A(k+1) will be skew-

The orthogonality of the recurrent matrix is maintained
to the order of machine precision, see section 5.5.1. The
scoRNN also maintains stable hidden state gradients in the
sense that the gradient norm does not change signiﬁcantly
in time, see section 5.5.2 for experimental results. This is
achieved with small overhead computational costs over the
standard RNN, see section 5.5.3 for experimental results
concerning computational efﬁciency.

The scoRNN, full-capacity uRNN, EURNN, and oRNN
models all have the theoretical capacity to optimize over
all orthogonal or unitary recurrent matrices, but their opti-
mization schemes are different. The full-capacity uRNN
performs a multiplicative update that moves W along the
tangent space of the Stiefel manifold, which is shown to
be a descent direction. The scoRNN, the EURNN, and
the oRNN use three different representations of orthogonal
matrices. The euRNN and oRNN express an orthogonal
matrix as a long product of simple orthogonal matrices
(Givens rotations and Householder reﬂections resp.) while
the scoRNN uses a single rational transformation. They all
use the steepest descent with respect to their correspond-
ing parametrizations. Here, different parametrizations have
different nonlinearities and hence different optimization
difﬁculties. We note that EURNN and oRNN are usually im-
plemented in a reduced capacity setting that uses a truncated
product. In our testing, it appears that increasing capacity
in EURNN and oRNN may not improve their performance.

Similar to the EURNN and oRNN, scoRNN may also be
implemented by restricting the A matrix to a banded skew-
symmetric matrix with bandwidth (cid:96) to reduce the number
of trainable parameters. Although this may work well for
particular tasks, such a modiﬁcation introduces an additional
hyperparameter and reduces representational capacity for
the recurrent weight matrix without any reduction in the
dimension of the hidden state.

∂L
∂A

= V T − V

(2)

4. Other Architecture Details

where V := (I + A)−T ∂L
∂W
(cid:105)

Rn×n, and ∂L

∂W =

(cid:104) ∂L
∂Wi,j

∈ Rn×n.

(cid:0)D + W T (cid:1), ∂L

∂A =

(cid:105)

(cid:104) ∂L
∂Ai,j

∈

At each training step of scoRNN, we ﬁrst use the standard
backpropagation algorithm to compute ∂L
∂W and then use
Theorem 3.2 to compute ∂L
∂A . We then update A with gradi-
ent descent (or a related optimization method), and recon-
struct W as follows:

The basic architecture of scoRNN is very similar to the
standard RNN as presented in Section 2.1. From a network
layer perspective, one can think of the application of the
recurrent weight in a three layer process. Let ht ∈ Rn be
the current state of the scoRNN at a particular time step, t.
We then pass ht through the following layers:
• Layer 1: ht → Dht =: h(1)
• Layer 2: h(1)

t → (I − A) h(1)

t =: h(2)

t

t

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

• Layer 3: h(2)

t → (I + A)−1 h(2)

t =: h(3)

t

5. Experiments

Note that the above scheme is the same as taking ht → W ht
as discussed previously.

4.1. MODRELU Activation Function

The modReLU function was ﬁrst implemented by Ar-
jovsky et al. (2016) to handle complex valued functions
and weights. Unlike previous methods, our method only
uses real-valued functions and weights. Nevertheless, we
have found that the modReLU function in the real case
also performed better than other activation functions. The
function is deﬁned as

σmodReLU(z) =

σReLU (|z| + b)

5.1. Copying Problem

z
|z|
(cid:40) z

=

|z| (|z| + b)
0

if |z| + b ≥ 0
if |z| + b < 0

In the following experiments, we compare the scoRNN
against LSTM and several other orthogonal and unitary
RNN models. Code for these experiments is available at
https://github.com/SpartinStuff/scoRNN.
For each experiment, we found optimal hyperparameters
for scoRNN using a grid search. For other models, we used
the best hyperparameter settings as reported for the same
testing problems, when applicable, or performed a grid
search to ﬁnd hyperparameters. For the LSTM, the forget
gate bias was tuned over the integers −4 to 4 with it set to
1.0 unless otherwise noted.

This experiment follows descriptions found in Jing et al.
(2016), Arjovsky et al. (2016), and Wisdom et al. (2016),
and tests an RNN’s ability to reproduce a sequence seen
many timesteps earlier. In the problem setup, there are 10
input classes, which we denote using the digits 0-9, with 0
being used as a ’blank’ class and 9 being used as a ’marker’
class. The RNN receives an input sequence of length T +20.
This sequence consists of entirely zeros, except for the ﬁrst
ten elements, which are uniformly sampled from classes
1-8, and a 9 placed ten timesteps from the end. The goal
for the machine is to output zeros until it sees a 9, at which
point it should output the ten elements from the beginning
of the input sequence. Thus, information must propagate
from the beginning to the end of the sequence for a machine
to successfully learn this task, making it critical to avoid
vanishing/exploding gradients.

A baseline strategy with which to compare machine perfor-
mance is that of outputting 0 until the machine sees a 9,
and then outputting 10 elements randomly sampled from
classes 1-8. The expected cross-entropy for such a strategy
is 10 log (8)
T +20 . In practice, it is common to see gated RNNs
such as LSTMs converge to this local minimum.

We use hyperparameters and hidden unit sizes as reported in
experiments in Arjovsky et al. (2016), Wisdom et al. (2016),
and Jing et al. (2016). This results in an LSTM with n = 68,
a restricted-capacity uRNN with n = 470, a full-capacity
uRNN with n = 128, and a tunable EURNN with n = 512
and capacity L = 2. As indicated in Mhammedi et al.
(2017), we were unable to obtain satisfactory performance
for the oRNN on this task. To match the ≈ 22k trainable
parameters in the LSTM and uRNNs, we use a scoRNN
with n = 190. We found the best performance with the
scoRNN came from ρ = n/2, which gives an initial W
with eigenvalues distributed uniformly on the unit circle.

Figure 1 compares each model’s performance for T = 1000
and T = 2000, with the baseline cross-entropy given as
a dashed line. In both cases, cross entropy for the LSTM,

where b is a trainable bias. In the real case, this simpliﬁes to
sign(z)σReLU(|z|+b). To implement this activation function
in scoRNN, we replace the computation of ht in Section 2.1
with

zt = U xt + W ht−1
ht = σmodReLU(zt)

We believe that the improved performance of the modReLU
over other activation functions, such as ReLU, is because it
admits both positive and negative activation values, which
appears to be important for the state transition in orthogonal
RNNs. This is similar to the hyperbolic tangent function but
does not have vanishing gradient issues.

4.2. Initialization

Modifying the initialization of our parameter matrices, in
particular our recurrent parameter matrix A, had an effect
on performance. The most effective initialization method
we found uses a technique inspired by Henaff et al. (2017).
We initialize all of the entries of A to be 0 except for 2x2
blocks along the diagonal, which are given as

B1






A =

. . .




 where Bj =

(cid:20) 0
−sj

(cid:21)

sj
0

B(cid:98)n/2(cid:99)

(cid:113) 1−cos (tj )

2

1+cos (tj ) and tj is sampled uniformly from
with sj =
(cid:2)0, π
(cid:3). The Cayley transform of this A will have eigen-
values equal to ±eitj for each j, which will be distributed
uniformly along the right unit half-circle. Multiplication
by the scaling matrix D will reﬂect ρ of these eigenvalues
across the imaginary axis. We use this method to initialize
scoRNN’s A matrix in all experiments listed in section 5.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Figure 1. Cross entropy of each machine on the copying problem with T = 1000 (left) and T = 2000 (right).

restricted-capacity uRNN, and EURNN remains at the base-
line or does not entirely converge over the entire experi-
ment. For the T = 1000 test, the full-capacity uRNN and
scoRNN converge immediately to zero entropy solutions,
with the full-capacity uRNN converging slightly faster. For
T = 2000, the full-capacity uRNN remains at the base-
line for several thousand iterations, but is eventually able to
ﬁnd a correct solution. In contrast, the scoRNN error has a
smooth convergence that bypasses the baseline, but does so
more slowly than the full-capacity uRNN.

uRNN. We tested both the tunable-style EURNN and FFT-
style EURNN with n = 512, and found better results from
the tunable-style (≈ 3k parameters) for sequence lengths
T = 200 and T = 400, and from the FFT-style (≈ 7k pa-
rameters) for sequence length T = 750. The best hyperpa-
rameters for the oRNN were in accordance with Mhammedi
et al. (2017) which was n = 128 with 16 reﬂections with
a learning rate of 0.01, ≈2.6k parameters. We found that
performance decreased when matching the number of reﬂec-
tions to the hidden size to increase the number of parameters.

5.2. Adding Problem

We examined a variation of the adding problem as proposed
by Arjovsky et al. (2016) which is based on the work of
Hochreiter & Schmidhuber (1997). This variation involves
passing two sequences concurrently into the RNN, each of
length T . The ﬁrst sequence is a sequence of digits sam-
pled uniformly with values ranging in a half-open interval,
U[0, 1). The second sequence is a marker sequence con-
sisting of all zeros except for two entries that are marked
by one. The ﬁrst 1 is located uniformly within the interval
[1, T
2 ) of the sequence and the second 1 is located uniformly
within the interval [ T
2 , T ) of the sequence. The label for
each pair of sequences is the sum of the two entries that
are marked by one, which forces the machine to identify
relevant information in the ﬁrst sequence among noise. As
the sequence length increases, it becomes more crucial to
avoid vanishing/exploding gradients. Naively predicting
one regardless of the sequence gives an expected mean
squared error (MSE) of approximately 0.167. This will be
considered as the baseline.

The number of hidden units for the LSTM, scoRNN and
uRNNs were adjusted so that each had approximately 15k
trainable parameters. This results in n = 170 for the
scoRNN, n = 60 for the LSTM, n = 120 for the Full-
Capacity uRNN, and n = 950 for the restricted-capacity

Figure 2. Test set MSE for each machine on the adding problem
with sequence lengths of T = 200 (top), T = 400 (middle), and
T = 750 (bottom).

The test set MSE results for sequence lengths T = 200,
T = 400, and T = 750 can be found in Figure 2. A training
set size of 100,000 and a testing set size of 10,000 were
used for each sequence length. For each case, the networks
start at or near the baseline MSE, except for the EURNN
for T = 750, and drop towards zero after a few epochs.
As the sequence length increases, the number of epochs

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

before the drop increases. We found the best settings for
the scoRNN were ρ = n/2 for T = 200 and ρ = 7n/10 for
T = 400 and T = 750. The forget bias for the LSTM was 2
for sequence length 200, 4 for sequence length 400, and 0
for sequence length 750. As can be seen, the LSTM error
drops precipitously across the board. Although the oRNN
begins to drop below the baseline before scoRNN, it has a
much more irregular descent curve, and jumps back to the
baseline after several epochs.

5.3. Pixel-by-Pixel MNIST

We ran two experiments based around classifying samples
from the well-known MNIST dataset (LeCun et al.). Follow-
ing the implementation of Le et al. (2015), each pixel of the
image is fed into the RNN sequentially, resulting in a single
pixel sequence length of 784. In the ﬁrst experiment, which
we refer to as unpermuted MNIST, pixels are arranged in
the sequence row-by-row. In the second, which we call
permuted MNIST, a ﬁxed permutation is applied to training
and testing sequences.

All scoRNN machines were trained with the RMSprop opti-
mization algorithm. Input and output weights used a learn-
ing rate of 10−3, while the recurrent parameters used a
learning rate of 10−4 (for n = 170) or 10−5 (for n = 360
and n = 512). For unpermuted MNIST, we found ρ to be
optimal at n/10, while the best value of ρ for permuted
MNIST was n/2. We suspect that the difference of these
two values comes from the different types of dependencies
in each: unpermuted MNIST has mostly local dependencies,
while permuted MNIST requires learning many long-term
dependencies, which appear to be more easily modeled
when the diagonal of D has a higher proportion of −1s.

Each experiment used a training set of 55,000 images and a
test set of 10,000 testing images. Each machine was trained
for 70 epochs, and test set accuracy, the percentage of test
images classiﬁed correctly, was evaluated at the conclusion
of each epoch. Figure 3 shows test set accuracy over time,
and the best performance over all epochs by each machine
is given in Table 1.

In both experiments, the 170 hidden unit scoRNN gives sim-
ilar performance to both of the 512 hidden unit uRNNs using
a much smaller hidden dimension and, in the case of the
full-capacity uRNN, an order of magnitude fewer parame-
ters. Matching the number of parameters (≈ 69k), the 2170
restricted-capacity uRNN performance was comparable to
the 360 hidden unit scoRNN for unpermuted MNIST, but
performed worse for permuted MNIST, and required a much
larger hidden size and a signiﬁcantly longer run time, see
5.5.3. As in experiments presented in Arjovsky et al. (2016)
and Wisdom et al. (2016), orthogonal and unitary RNNs
are unable to outperform the LSTM in the unpermuted case.
However, the 512 hidden unit scoRNN outperforms all other

Table 1. Results for unpermuted and permuted pixel-by-pixel
MNIST experiments. Evaluation accuracies are based on the best
test accuracy at the end of every epoch. Asterisks indicate reported
results from (Jing et al., 2016) and (Mhammedi et al., 2017).

PERMUTED

MODEL

N

#

MNIST MNIST

170 ≈ 16K
360 ≈ 69K
512 ≈ 137K
128 ≈ 68K
256 ≈ 270K
512 ≈ 1, 058K

SCORNN
SCORNN
SCORNN
LSTM
LSTM
LSTM
RESTRICTED URNN 512 ≈ 16K
RESTRICTED URNN 2170 ≈ 69K
116 ≈ 16K
FULL URNN
512 ≈ 270K
FULL URNN
≈ 9K
512
EURNN
256 ≈ 11K
ORNN

PARAMS TEST ACC. TEST ACC.
0.973
0.983
0.985
0.987
0.989
0.985
0.976
0.984
0.947
0.974
-
0.972∗

0.943
0.962
0.966
0.920
0.929
0.920
0.945
0.953
0.925
0.947
0.937∗
-

unitary RNNs. On permuted MNIST, the 512 hidden unit
scoRNN achieves a test-set accuracy of 96.6%, outperform-
ing all other machines. We believe this is a state of the art
result.

5.4. TIMIT Speech Dataset

To see how the models performed on audio data, speech pre-
diction was performed on the TIMIT dataset (Garofolo et al.,
1993), a collection of real-world speech recordings. Exclud-
ing the dialect SA sentences and using only the core test
set, the dataset consisted of 3,696 training and 192 testing
audio ﬁles. Similar to experiments in Wisdom et al. (2016),
audio ﬁles were downsampled to 8kHz and a short-time
Fourier transform (STFT) was applied with a Hann win-
dow of 256 samples and a window hop of 128 samples (16
milliseconds). The result is a set of frames, each with 129
complex-valued Fourier amplitudes. The log-magnitude of
these amplitudes is used as the input data for the machines.
For each model, the hidden layer sizes were adjusted such
that each model had approximately equal numbers of train-
able parameters. For scoRNN, we used the Adam optimizer
with learning rate 10−3 to train input and output parameters,
and RMSprop with a learning rate of 10−3 (for n = 224) or
10−4 (for n = 322, 425) to train the recurrent weight matrix.
The number of negative eigenvalues used was ρ = n/10.
The LSTM forget gate bias was initialized to -4.

The loss function used for training was the mean squared er-
ror (MSE) between the predicted and actual log-magnitudes
of the next time frame over the entire sequence. Table
2 contains the MSE on validation and testing sets, which
shows that all scoRNN models achieve a smaller MSE than

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Figure 3. Test accuracy for unpermuted and permuted MNIST over time. All scoRNN models and the best performing LSTM, restriced
capacity uRNN, and full-capacity uRNN are shown.

Due to the accumulation of rounding errors over a large
number of repeated matrix multiplications, the recurrent
weight may not remain unitary throughout training. To in-
vestigate this, we ran the scoRNN and full-capacity uRNN
with equal hidden unit sizes of n = 512 on the unpermuted
MNIST experiment and checked for loss of orthogonality
at each epoch. The results of this experiment are shown in
Figure 4. As can be seen, the recurrent weight matrix for
the full-capacity uRNN becomes less unitary over time, but
the orthogonality recurrent weight matrix for scoRNN is not
affected by roundoff errors.

This can become particularly apparent when performing op-
erations using a graphics processing unit (GPU) which have
a much lower machine precision than a standard computer
processing unit (CPU).

Table 2. Results for the TIMIT speech dataset. Evaluation based
on MSE and various audio metrics

N

MODEL

#
PARAMS
≈ 83K
224
SCORNN
322 ≈ 135K
SCORNN
425 ≈ 200K
SCORNN
≈ 83K
84
LSTM
120 ≈ 135K
LSTM
158 ≈ 200K
LSTM
≈ 83K
REST. URNN 158
REST. URNN 256 ≈ 135K
REST. URNN 378 ≈ 200K
≈ 83K
128
FULL URNN
192 ≈ 135K
FULL URNN
256 ≈ 200K
FULL URNN

VALID.
MSE
9.26
8.48
7.97
15.42
13.93
13.66
15.57
15.90
16.00
15.07
15.10
14.96

EVAL.
MSE
8.50
7.82
7.36
14.30
12.95
12.62
18.51
15.31
15.15
14.58
14.50
14.69

all LSTM and unitary RNN models. Similar to Wisdom
et al. (2016), we reconstructed audio ﬁles using the pre-
dicted log-magnitudes from each machine and evaluated
them on several audio metrics. We found that the scoRNN
predictions achieved better scores on the signal-to-noise
ratio metric SegSNR (Brookes et al., 1997), but performed
slightly worse than the full-capacity uRNN predictions on
STOI (Taal et al., 2011) and PESQ (Rix et al., 2001), both
metrics used to measure human intelligibility and perception.

5.5. Further Analysis

5.5.1. LOSS OF ORTHOGONALITY

(cid:1) for the full-capacity
Figure 4. Unitary scores (cid:0)(cid:107)W ∗W − I(cid:107)F
uRNN recurrent weight matrix and orthogonality scores
(cid:13)W T W − I(cid:13)
(cid:0)(cid:13)
(cid:1)for the scoRNN recurrent weight matrix using
(cid:13)F
a GPU on the pixel-by-pixel MNIST experiment.

In the scoRNN architecture, the recurrent weight matrix is
parameterized with a skew-symmetric matrix through the
Cayley transform. This ensures the computed recurrent
weight matrix in ﬂoating point arithmetic is orthogonal to
the order of machine precision after each update step. Un-
like scoRNN, the full-capacity uRNN maintains a unitary
recurrent weight matrix by a multiplicative update scheme.

5.5.2. VANISHING GRADIENTS

As discussed in Arjovsky et al. (2016),
the vanish-
ing/exploding gradient problem is caused by rapid growth
or decay of the gradient of the hidden state ∂L
as we move
∂ht
earlier in the sequence (that is, as t decreases). To see if
vanishing/exploding gradients affect the scoRNN model, we
examined hidden state gradients in the scoRNN and LSTM

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

models on the adding problem experiment (see section 5.2)
with sequence length T = 500.

The norms of these gradients are shown at two different
points in time during training in Figure 5. As can be seen,
LSTM gradient norms decrease steadily as we move away
from the end of the sequence. The right half of Figure 5
shows that this vanishing effect is exacerbated by training
after 300 iterations.

In contrast, scoRNN gradients decay by less than an order
of magnitude at the beginning of training, remaining near
10−2 for all timesteps. Even after 300 iterations of training,
scoRNN hidden state gradients decay only slightly, from
10−3 at t = 500 to 10−4 at t = 0. This allows information
to easily propagate from beginning of the sequence to end.

Table 3. Timing results for the unpermuted MNIST dataset.

# params Minutes Per Epoch

n
Model
116
RNN
170
scoRNN
512
Rest. uRNN
116
Full uRNN
128
LSTM
scoRNN
360
Rest. uRNN 2,170
360
RNN
512
scoRNN
360
Full uRNN
512
RNN
256
LSTM
512
Full uRNN
512
LSTM

≈ 16k
≈ 16k
≈ 16k
≈ 16k
≈ 68k
≈ 69k
≈ 69k
≈ 137k
≈ 137k
≈ 137k
≈ 270k
≈ 270k
≈ 270k
≈ 1, 058k

2.3
5.3
8.2
10.8
5.0
7.4
50.1
2.3
11.2
25.8
2.4
5.2
27.9
5.6

The RNN and LSTM models were fastest, and hidden sizes
largely did not affect time taken per epoch; we suspect
this is because these models were built in to Tensorﬂow.
The LSTMs are of similar speed to the n = 170 scoRNN,
while they are approximately twice as fast as the n = 512
scoRNN. Matching the number of hidden parameters, the
scoRNN model with n = 170 is approximately 1.5 times
faster than the restricted-capacity uRNN with n = 512,
and twice as fast as the full-capacity uRNN with n = 116.
This relationship can also be seen in the scoRNN and full-
capacity uRNN models with ≈ 137k parameters, where the
scoRNN takes 11.2 minutes per epoch as compared to 25.8
minutes for the full-capacity uRNN.

6. Conclusion

There has been recent promising work with RNN architec-
tures using unitary and orthogonal recurrent weight ma-
trices to address the vanishing/exploding gradient prob-
lem. The unitary/orthogonal RNNs are typically imple-
mented with complex valued matrices or in restricted capac-
ity. The scoRNN developed in this paper uses real valued
orthogonal recurrent weight matrices with a simpler im-
plementation scheme, with the representational capacity to
reach all orthogonal matrices through the Cayley transform
parametrization. The resulting model’s additive update step
with respect to this parametrization maintains the orthog-
onality of the recurrent weight matrix in the presence of
roundoff errors. Results from our experiments show that
scoRNN is among the top performers in all tests with a
smooth and stable convergence curve. This superior perfor-
mance is achieved, in some cases, with a smaller hidden
state dimension than other models.

Figure 5. Gradient norms (cid:107) ∂L
(cid:107) for scoRNN and LSTM models
∂ht
during training on the adding problem. The x-axis shows different
values of t. The left plot shows gradients at the beginning of
training, and the right shows gradients after 300 training iterations.

5.5.3. COMPLEXITY AND SPEED

The scoRNN architecture is similar in complexity and mem-
ory usage to a standard RNN except for the additional mem-
ory requirement of storing the n(n − 1)/2 entries of the
skew-symmetric matrix A and the additional complexity of
forming the recurrent weight matrix W from A with the
scaled Cayley transform. We note that the recurrent weight
matrix is generated from the skew-symmetric A matrix only
once per training iteration; this O(n3) computational cost
is comparable to one training iteration of a standard RNN,
which is O(BT n2) where T is the length of the sequences
and B is the mini-batch size, when BT is comparable to n.

To experimentally quantify potential differences between
scoRNN and other models, the real run-time for the unper-
muted MNIST experiment were recorded and are included
in Table 3. All models were run on the same machine, which
has an Intel Core i5-7400 processor and an nVidia GeForce
GTX 1080 GPU. The scoRNN and LSTM models were run
in Tensorﬂow, while the full and restricted capacity uRNNs
were run using code provided in Wisdom et al. (2016).

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Acknowledgements

This research was supported in part by NSF Grants DMS-
1317424 and DMS-1620082.

References

Arjovsky, M., Shah, A., and Bengio, Y. Unitary evolution
recurrent neural networks. In Proceedings of the 33rd
International Conference on Machine Learning (ICML
2016), volume 48, pp. 1120–1128, New York, NY, 2016.
JMLR.

Bengio, Y., Frasconi, P., and Simard, P. The problem of
learning long-term dependencies in recurrent networks.
In Proceedings of 1993 IEEE International Conference
on Neural Networks (ICNN ’93), pp. 1183–1195, San
Francisco, CA, 1993. IEEE Press.

Brookes, M. et al. Voicebox: Speech processing toolbox for
matlab. Software, available [Mar. 2011] from www. ee. ic.
ac. uk/hp/staff/dmb/voicebox/voicebox. html, 47, 1997.

Cho, K., van Merrienboer, B., Bahdanau, D., and Ben-
gio, Y. On the properties of neural machine transla-
tion: Encoder-decoder approaches, 2014. URL https:
//arxiv.org/abs/1409.1259.

Garofolo, J., Lamel, L., Fisher, W., Fiscus, J., Pallett, D.,
Dahlgren, N., and Zue, V. Timit acoustic-phonetic contin-
uous speech corpus ldc93s1. Technical report, Philadel-
phia: Linguistic Data Consortium, Philadelphia, PA,
1993.

Henaff, M., Szlam, A., and LeCun, Y. Recurrent orthogonal
In Proceedings of
networks and long-memory tasks.
the 33rd International Conference on Machine Learning
(ICML 2017), volume 48, New York, NY, 2017. JMLR:
W&CP.

Hochreiter, S. and Schmidhuber, J. Long short-term memory.

Neural Computation, 9(8):1735–1780, 1997.

Hyland, S. L. and Gunnar, R. Learning unitary operators
with help from u(n). In Proceedings of the 31st AAAI Con-
ference on Artiﬁcial Intelligence (AAI 2017), pp. 2050–
2058, San Francisco, CA, 2017.

Jing, L., Shen, Y., Dubˇcek, T., Peurifoy, J., Skirlo, S.,
Tegmark, M., and Soljaˇci´c, M. Tunable efﬁcient uni-
tary neural networks (eunn) and their application to rnn,
2016.

Jing, L., G¨ulc¸ehre, C., Peurifoy, J., Shen, Y., Tegmark, M.,
Soljaˇci´c, M., and Bengio, Y. Gated orthogonal recurrent
units: On learning to forget. 2017. URL https://
arxiv.org/abs/1706.02761.

Kahan, W. Is there a small skew cayley transform with zero
diagonal? Linear algebra and its applications, 417(2-3):
335–341, 2006.

Kingma, D. and Ba, J. Adam: A method for stochastic
optimization. arXiv preprint arXiv:1412.6980, 2014.

Le, Q. V., Jaitly, N., and Hinton, G. E. A simple way to
initialize recurrent networks of rectiﬁed linear units, 2015.
URL https://arxiv.org/abs/1504.00941.

LeCun, Y., Cortes, C., and Burges, C. J. C. The mnist
database. URL http://yann.lecun.com/exdb/
mnist/.

Mhammedi, Z., Hellicar, A., Rahman, A., and Bailey, J.
Efﬁcient orthogonal parameterisation of recurrent neural
networks using householder reﬂections. In Proceedings of
the 34th International Conference on Machine Learning
(ICML 2017), Sydney, Australia, 2017. PMLR: 70.

Nair, V. and Hinton, G. E. Rectiﬁed linear units improve
In 27th International
restricted boltzmann machines.
Conference on Machine Learning (ICML 2010), Haifa,
Israel, 2010.

Pascanu, R., Mikolov, T., and Bengio, Y. On the difﬁculty of
training recurrent neural networks. In 30th International
Conference on Machine Learning (ICML 2013), Atlanta,
GA, 2013.

Rix, A. W., Beerends, J. G., Hollier, M. P., and Hekstra,
A. P. Perceptual evaluation of speech quality (pesq)-a
new method for speech quality assessment of telephone
networks and codecs. In Acoustics, Speech, and Signal
Processing, 2001. Proceedings.(ICASSP’01). 2001 IEEE
International Conference on, volume 2, pp. 749–752.
IEEE, 2001.

Taal, C. H., Hendriks, R. C., Heusdens, R., and Jensen,
J. An algorithm for intelligibility prediction of time–
frequency weighted noisy speech. IEEE Transactions on
Audio, Speech, and Language Processing, 19(7):2125–
2136, 2011.

Tagare, H. D. Notes on optimization on stiefel manifolds.

Technical report, Yale University, 2011.

Tieleman, T. and Hinton, G. Lecture 6.5-rmsprop: Divide
the gradient by a running average of its recent magnitude.
COURSERA: Neural networks for machine learning, 4
(2):26–31, 2012.

Vorontsov, E., Trabelsi, C., Kadoury, S., and Pal, C. On
orthogonality and learning recurrent networks with long
term dependencies, 2017.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

Wen, Z. and Yin, W. A feasible method for optimization
with orthogonality constraints. In Mathematical Program-
ming, volume 142(1-2), pp. 397–434. 2013.

Wisdom, S., Powers, T., Hershey, J., Roux, J. L., and Atlas,
L. Full-capacity unitary recurrent neural networks. In
Lee, D. D., Sugiyama, M., Luxburg, U. V., Guyon, I., and
Garnett, R. (eds.), Advances in Neural Information Pro-
cessing Systems 29, pp. 4880–4888. Curran Associates,
Inc., 2016.

Orthogonal Recurrent Neural Networks with Scaled Cayley Transform

∂L
∂Ai,j

= − tr

(cid:19)T

(cid:35)
(I + A)−1 (Ei,j − Ej,i + Ei,jZ − Ej,iZ)

Supplemental Material: Proof of Theorem 3.2

For completeness, we restate and prove Theorem 3.2.
Theorem 3.2 Let L = L(W ) : Rn×n → R be some differ-
entiable loss function for an RNN with the recurrent weight
matrix W . Let W = W (A) := (I + A)−1 (I − A) D
where A ∈ Rn×n is skew-symmetric and D ∈ Rn×n is
a ﬁxed diagonal matrix consisting of -1 and 1 entries. Then
the gradient of L = L(W (A)) with respect to A is

∂L
∂A

= V T − V

(3)

where V := (I + A)−T ∂L
∂W
(cid:105)

Rn×n, and ∂L

∂W =

(cid:104) ∂L
∂Wi,j

∈ Rn×n

(cid:0)D + W T (cid:1), ∂L

∂A =

(cid:105)

(cid:104) ∂L
∂Ai,j

∈

Proof: Let Z := (I + A)−1(I − A). We consider the
(i, j) entry of ∂L
∂A . Taking the derivative with respect to Ai,j
where i (cid:54)= j we obtain:

∂L
∂Ai,j

=

n
(cid:88)

k,l=1

∂L
∂Wk,l

∂Wk,l
∂Ai,j

=

= tr

(cid:34)(cid:18) ∂L
∂W

D

(cid:19)T ∂Z
∂Ai,j

n
(cid:88)

k,l=1
(cid:35)

∂L
∂Wk,l

Dl,l

∂Zk,l
∂Ai,j

Using the identity (I + A) Z = I − A and taking the deriva-
tive with respect to Ai,j to both sides we obtain:

∂Z
∂Ai,j

+

∂A
∂Ai,j

Z + A

= −

∂Z
∂Ai,j

∂A
∂Ai,j

and rearranging we get:

∂Z
∂Ai,j

= − (I + A)−1

(cid:18) ∂A
∂Ai,j

+

∂A
∂Ai,j

Z

(cid:19)

Let Ei,j denote the matrix whose (i, j) entry is 1 with
all others being 0. Since A is skew-symmetric, we have
= Ei,j − Ej,i. Combining everything, we have:

∂A
∂Ai,j

= − tr

(I + A)−1Ei,j

D

D

(cid:19)T

(cid:19)T

(cid:19)T

(cid:19)T

D

D

D

(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W
(cid:34)(cid:18) ∂L
∂W

(cid:32)(cid:18) ∂L

∂W

+ tr

− tr

+ tr

= −

(I + A)−1Ej,i

(I + A)−1Ei,jZ

(I + A)−1Ej,iZ

(cid:19)T

D

(I + A)−1

(cid:33)T 


(cid:35)

(cid:35)

(cid:35)

(cid:35)

i,j

(cid:34)(cid:18) ∂L
∂W

+

(cid:19)T

D

(cid:35)

(I + A)−1


(cid:32)(cid:18) ∂L

∂W

−

(cid:19)T

D

i,j
(cid:33)T

(I + A)−1

Z T





i,j

(cid:34)

+

Z

(cid:19)T

(cid:18) ∂L
∂W

D

(cid:35)

(I + A)−1

i,j

(cid:35)

(I + A)−1

i,j

(cid:33)T

(I + A)−1

(cid:0)I + Z T (cid:1)

=

(I + Z)

(cid:19)T

(cid:18) ∂L
∂W

D


(cid:32)(cid:18) ∂L

∂W

(cid:19)T

D

(cid:34)

−

(cid:34)

=

(D + W )

(I + A)−1

(cid:19)T

(cid:18) ∂L
∂W

−

(cid:20)
(I + A)−T ∂L
∂W

(cid:0)D + W T (cid:1)

(cid:35)

i,j

(cid:21)

i,j





i,j

Using the above formulation,
− ∂L
∂Aj,i
by the deﬁnition of V we get the desired result. (cid:4)

=
∂A is a skew-symmetric matrix. Finally,

= 0 and ∂L
∂Ai,j

so that ∂L

∂L
∂Aj,j

