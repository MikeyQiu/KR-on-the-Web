Recombinator Networks: Learning Coarse-to-Fine Feature Aggregation

Sina Honari1, Jason Yosinski2, Pascal Vincent1,4, Christopher Pal3
1University of Montreal, 2Cornell University, 3Ecole Polytechnique of Montreal, 4CIFAR
1{honaris, vincentp}@iro.umontreal.ca, 2yosinski@cs.cornell.edu, 3christopher.pal@polymtl.ca

6
1
0
2
 
r
p
A
 
7
1
 
 
]

V
C
.
s
c
[
 
 
2
v
6
5
3
7
0
.
1
1
5
1
:
v
i
X
r
a

Abstract

Deep neural networks with alternating convolutional,
max-pooling and decimation layers are widely used in state
of the art architectures for computer vision. Max-pooling
purposefully discards precise spatial information in order
to create features that are more robust, and typically orga-
nized as lower resolution spatial feature maps. On some
tasks, such as whole-image classiﬁcation, max-pooling de-
rived features are well suited; however, for tasks requiring
precise localization, such as pixel level prediction and seg-
mentation, max-pooling destroys exactly the information re-
quired to perform well. Precise localization may be pre-
served by shallow convnets without pooling but at the ex-
pense of robustness. Can we have our max-pooled multi-
layered cake and eat it too? Several papers have proposed
summation and concatenation based methods for combin-
ing upsampled coarse, abstract features with ﬁner features
to produce robust pixel level predictions. Here we intro-
duce another model — dubbed Recombinator Networks —
where coarse features inform ﬁner features early in their
formation such that ﬁner features can make use of several
layers of computation in deciding how to use coarse fea-
tures. The model is trained once, end-to-end and performs
better than summation-based architectures, reducing the er-
ror from the previous state of the art on two facial keypoint
datasets, AFW and AFLW, by 30% and beating the current
state-of-the-art on 300W without using extra data. We im-
prove performance even further by adding a denoising pre-
diction model based on a novel convnet formulation.

1. Introduction

Recent progress in computer vision has been driven by
the use of large convolutional neural networks. Such net-
works beneﬁt from alternating convolution and pooling lay-
ers [16, 23, 22, 29, 24, 27, 42] where the pooling layers
serve to summarize small regions of the layer below. The
operations of convolution, followed by max-pooling, then
decimation cause features in subsequent layers of the net-
work to be increasingly translation invariant, more robust,
and to more coarsely summarize progressively larger re-

gions of the input image. As a result, features in the fourth
or ﬁfth convolutional layer serve as more robust detectors
of more global, but spatially imprecise high level patterns
like text or human faces [37]. In practice these properties
are critical for many visual tasks, and they have been par-
ticularly successful at enabling whole image classiﬁcation
[16, 29, 24]. However, for other types of vision tasks these
architectural elements are not as well suited. For example
on tasks requiring pixel-precise localization or labeling, fea-
tures arising from max-pooling and decimation operations
can only provide approximate localization, as in the pro-
cess of creating them, the network has already thrown out
precise spatial information by design. If we wish to gener-
ate features that preserve accurate localization, we may do
so using shallow networks without max-pooling, but shal-
low networks without pooling cannot learn robust, invariant
features. What we would like is to have our cake and eat
it too: to combine the best of both worlds, merging ﬁnely-
localized information from shallow, non-pooled networks
with robust, coarsely-localized features computed by deep,
pooled networks.

Several recently proposed approaches [17, 13, 31] ad-
dress this by adding or concatenating the features obtained
across multiple levels. We use this approach in our base-
line model termed SumNet for our task of interest: facial
keypoint localization. To the best of our knowledge this
is the ﬁrst time this general approach has been applied to
the problem of facial keypoint localization and even our
baseline is capable of yielding state of the art results. A
possible weakness of these approaches however is that all
detection paths, from coarsely to ﬁnely localized features,
only become aggregated at the very end of the feature pro-
cessing pipeline. As a thought experiment to illustrate this
approach’s weakness, imagine that we have a photo of a
boat ﬂoating in the ocean and would like to train a con-
vnet to predict with single pixel accuracy a keypoint cor-
responding to the tip of the boat’s bow. Coarsely local-
ized features1 could highlight the rough region of the bow
of the boat, and ﬁnely localized features could be tuned to

1From now on we use the shorthand ﬁne/coarse features to mean

ﬁnely/coarsely localized features.

1

Figure 1. (Left) Architecture of summation based coarse-ﬁne network (SumNet). C is a convolutional layer. P,C represents a pooling
layer followed by a convolutional layer. All convolutions are 3 × 3 and all poolings are 2 × 2. All convolutional layers are followed
by ReLU non-linearity except the last convolutional layer in each branch. U represents an upsampling layer. Each branch’s output is 5
feature maps of size 80 × 80. FCN/Hypercolumn models use this architecture. (Right) Architecture of the Recombinator Networks (RCN).
All convolutions are 3 × 3 and all poolings are 2 × 2. All upsamplings are by a factor of 2. K represents concatenation of two sets of
feature maps along the feature map dimension. All convolutional layers are followed by ReLU non-linearity except the one right before the
softmax. In the Recombinator Networks model with skip connections (not shown), each branch takes upsampled features not only from
one coarser branch, but from all coarser branches.

ﬁnd generic boat edges, but the ﬁne features must remain
generic, being forced to learn boat edge detectors for all
possible ocean and boat color combinations. This would be
difﬁcult, because boat and ocean pixels could take similar
colors and textures. Instead, we would like a way for the
coarse features which contain information about the global
scene structure (perhaps that the water is dark blue and the
boat is bright blue) to provide information to the ﬁne feature
detectors earlier in their processing pipeline. Without such
information, the ﬁne feature detectors would be unable to
tell which half of a light blue/dark blue edge was ocean and
which was boat. In the Recombinator Networks proposed
in this paper, the ﬁnely localized features are conditioned
on higher level more coarsely localized information. It re-
sults in a model which is deeper but – interestingly – trains
faster than the summation baseline and yields more precise
localization predictions. In summary, this work makes the
following contributions:

1. We propose a novel architecture — the Recombinator
Networks — for combining information over different
spatial localization resolutions (Section 3).

2. We show how a simple denoising model may be used

to enhance model predictions (Section 4).

3. We provide an in-depth empirical evaluation of a wide
variety of relevant architectural variants (Section 5.1).
4. We show state of the art performance on two widely
used and competitive evaluations for facial keypoint
localization (Section 5.2).

2. Related work

Keypoint localization methods: Our task of interest
is the well studied problem of facial keypoint localization
[44, 42, 38, 2, 33, 40, 6, 35, 7, 18, 45] illustrated in Fig-
ure 1. Precise facial keypoint localization is often an es-
sential preprocessing step for face recognition [1] and de-

tection [45]. Recent face veriﬁcation models like DeepFace
[30] and DeepID2 [27] also include keypoint localization
as the ﬁrst step. There have been many other approaches to
general keypoint localization, including active appearance
models [8, 43], constrained local models [10, 21, 11, 2], ac-
tive shape models [12], point distribution models [9], struc-
tured model prediction [3, 31], tree structured face mod-
els [45], group sparse learning based methods [39], shape
regularization models that combines multiple datasets [25],
feature voting based landmark localization [26, 36] and
convolutional neural networks based models [41, 28, 42].
Two other related models are [31], where a multi-resolution
model is proposed with dual coarse/ﬁne paths and tied ﬁl-
ters, and [28], which uses a cascaded architecture to reﬁne
predictions over several stages. Both of these latter mod-
els make hard decisions using coarse information halfway
through the model.

Approaches that combine features across multiple
levels: Several recent models — including the fully convo-
lutional networks (FCNs) in [17], the Hypercolumn model
[13], and the localization model of Tompson et al. [31] —
generate features or predictions at multiple resolutions, up-
sample the coarse features to the ﬁne resolution, and then
add or concatenate the features or predictions together. This
approach has generally worked well, improving on previ-
ous state of the art results in detection, segmentation, and
human-body pose estimation [13, 17, 31]. In this paper we
create a baseline model similar to these approaches that we
refer to as SumNet in which we use a network that aggre-
gates information from features across different levels in the
hierarchy of a conv-pool-decimate network using concate-
nation followed by a weighted sum over feature maps prior
to ﬁnal layer softmax predictions. Our goal in this paper is
to improve upon this architecture. Differences between the
Recombinator Networks and related architectures are sum-

2

marized in Table 5. U-Net [19] is another model that merges
features across multiple levels and has a very similar archi-
tecture to Recombinator Networks. The two models have
been developed independently and were designed for differ-
ent problems2. Note that none of these models use a learned
denoising post-processing as we do (see section 4).

3. Summation versus Recombinator Networks

In this section we describe our baseline SumNet model
based on a common architectural design where information
from different levels of granularity are merged just prior to
predictions being made. We contrast this with the Recom-
binator Networks architecture.

3.1. Summation based Networks

The SumNet architecture, shown in Figure 1(left), adds
to the usual bottom to top convolution and spatial pool-
ing, or “trunk”, a horizontal left-to-right “branch” at each
resolution level. While spatial pooling progressively re-
duces the resolution as we move “up” the network along
the trunk, the horizontal branches only contains full con-
volutions and element-wise non-linearities, with no spatial
pooling, so that they can preserve the spatial resolution at
that level while doing further processing. The output of
the ﬁnest resolution branch only goes through convolutional
layers. The ﬁnest resolution layers keep positional informa-
tion and use it to guide the coarser layers within the patch
that they cannot have any preference, while the coarser res-
olution layers help ﬁner layers to get rid of false positives.
The architecture then combines the rightmost low resolution
output of all horizontal branches, into a single high resolu-
tion prediction, by ﬁrst up-sampling3 them all to the model’s
input image resolution (80 × 80 for our experiments) and
then taking a weighted sum to yield the pre-softmax val-
ues. Finally, a softmax function is applied to yield the ﬁ-
nal location probability map for each keypoint. Formally,
given an input image x, deﬁne the trunk of the network as
a sequence of blocks of traditional groups of convolution,
pooling and decimation operations. Starting from the layer
yielding the coarsest scale feature maps we call the outputs
of R such blocks T (1), . . . , T (R). At each level r of the
trunk we have a horizontal branch that takes T (r) as its in-
put and consists of a sequence of convolutional layers with
no subsampling. The output of such a branch is a stack of
K feature maps, one for each of the K target keypoints, at
the same resolution as its input T (r), and we denote this
output as branch(T (r)).
It is then upsampled up[×F ] by
some factor F which returns the feature map to the original
resolution of the input image. Let these upsampled maps
be M (1)
is the score map given by

K where M (r)

1 , . . . , M (R)

k

2For keypoint localization, we apply the softmax spatially i.e. across
possible spatial locations, whereas for segmentation [13, 17, 19] it is ap-
plied across all possible classes for each pixel.

3Upsampling can be performed either by tiling values or by using bilin-
ear interpolation. We found bilinear interpolation degraded performance in
some cases, so we instead used the simpler tiling approach.

k

the rth branch to the kth keypoint (left eye, right eye, . . .).
Each such map M (r)
is a matrix of the same resolution as
the image fed as input (i.e. 80 × 80). The score ascribed
by branch r for keypoint k being at coordinate i, j is given
by M (r)
k,i,j. The ﬁnal probability map for the location Yk of
keypoint k is given by a softmax over all possible locations.
We can therefore write the model as

M (1) = up[×2R−1](branch(T (1)))
M (2) = up[×2R−2](branch(T (2)))
. . .
M (R) = branch(T (R))

P (Yk|X = x) = softmax

(cid:16) R
(cid:88)

r=1

αrkM (r)

k

(cid:17)

,

(1)

where αrk is a 2D matrix that gives a weight to every
pixel location i, j of keypoint k in branch r. The weighted
sum of features over all branches taken here is equivalent to
concatenating the features of all branches and multiplying
them in a set of weights, which results in one feature map
per keypoint. This architecture is trained globally using
gradient backpropagation to minimize the sum of negated
conditional log probabilities of all N training (input-image,
keypoint-locations) pairs, for all K keypoints (x(n), y(n)
k ),
with an additional regularization term for the weights ; i.e.
we search for network parameters W that minimize 4

L(W) =

− log P (Yk = y(n)

k |X = x(n)) + λ(cid:107)W(cid:107)2.

1
N

N
(cid:88)

K
(cid:88)

n=1

k=1

(2)

3.2. The Recombinator Networks

In the SumNet model, different branches can only com-
municate through the updates received from the output layer
and the features are merged linearly through summation. In
the Recombinator Networks (RCN) architecture, as shown
in Figure 1(right), instead of taking a weighted sum of the
upsampled feature maps in each branch and then passing
them to a softmax, the output of each branch is upsampled,
then concatenated with the next level branch with one de-
gree of ﬁner resolution. In contrast to the SumNet model,
each branch does not end in K feature maps. The infor-
mation stays in the form of a keypoint independent feature
map. It is only at the end of the Rth branch that feature
maps are converted into a per-keypoint scoring represen-
tation that has the same resolution as the input image, on
which a softmax is then applied. As a result of RCN’s dif-
ferent architecture, branches pass more information to each
other during training, such that convolutional layers in the
ﬁner branches get inputs from both coarse and ﬁne layers,
letting the network learn how to combine them non-linearly
to maximize the log likelihood of the keypoints given the

4 We also tried L2 distance cost between true and estimated keypoints
(as a regression problem) and got worse results. This may be due to the
fact that a softmax probability map can be multimodal , while L2 distance
implicitly corresponds to likelihood of a unimodal isotropic Gaussian.

3

input images. The whole network is trained end-to-end
by backprop. Following the previous conventions and by
deﬁning the concatenation operator on feature maps A, B
as concat(A, B), we can write the model as

M (cid:48)(1) = up[×2](branch(T (1)))
M (cid:48)(2) = up[×2](branch(concat(T (2), M (cid:48)(1))))
. . .
M (cid:48)(R) = branch(concat(T (R), M (cid:48)(R−1)))
P (Yk|X = x) = softmax(M (cid:48)(R)

).

k

(3)

skip

also
the

each branch are

explore RCN with
features of

connections,
We
concate-
where
nated with upsampled features of not only one-level
coarser branch,
coarser branches
the last branch computes M (cid:48)(R) =
and,
therefore,
branch(concat(T (R), M (cid:48)(R−1), M (cid:48)(R−2), . . . , M (cid:48)(1)).
In
practice, the information ﬂow between different branches
makes RCN converge faster and also perform better
compared to the SumNet model.

all previous

but

4. Denoising keypoint model

Convolutional networks are excellent edge detectors. If
there are few samples with occlusion in the training sets,
convnets have problem detecting occluded keypoints and
instead select nearby edges (see some samples in Figures
3, 5). Moreover, the convnet predictions, especially on
datasets with many keypoints, do not always correspond to
a plausible keypoint distribution and some keypoints jump
off the curve (e.g. on the face contour or eye-brows) irre-
spective of other keypoints’ position (see some samples in
Figure 7). This type of error can be addressed by using a
structured output predictor on top of the convnet, that takes
into account how likely the location of a keypoint is rel-
ative to other keypoints. Our approach is to train another
convolutional network that captures useful aspects of the
prior keypoint distribution (not conditioned on the image).
We train it to predict the position of a random subsets of
keypoints, given the position of the other keypoints. More
speciﬁcally, we train the convolutional network as a denois-
ing model, similar to the denoising auto-encoder [34] by
completely corrupting the location of a randomly chosen
subset of the keypoints and learning to accurately predict
their correct location given that of the other keypoints. This
network receives as input, not the image, but only keypoint
locations represented as one-hot 2D maps (one 2D map per
keypoint, with a 1 at the position of the keypoint and ze-
ros elsewhere). It is composed of convolutional layers with
large receptive ﬁelds (to get to see nearby keypoints), ReLU
nonlinearities and no subsampling (see Figure 2). The net-
work outputs probability maps for the location of all key-
points, however, its training criterion uses only prediction

errors of the corrupted ones. The cost being optimized sim-
ilar to Eq.(2) but includes only the corrupted keypoints.

Once, this denoising model is trained, the output of RCN
(the predicted most likely location in one-hot binary loca-
tion 2D map format) is fed to the denoising model. We
then simply sum the pre-softmax values of both RCN and
denoising models and pass them through a softmax to gen-
erate the ﬁnal output probability maps. The joint model is
depicted in Figure 2. The joint model combines the RCN’s
predicted conditional distribution for keypoint k given the
image P (Yk|X = x) with the denoising model’s distri-
bution of the location of that keypoint given other key-
points P (Yk|Y¬k), to yield an estimation of keypoint k’s
location given both image and other keypoint locations
P (Yk|Y¬k, X = x). The choice of convolutional networks
for the denoising model allows it to be easily combined with
RCN in a uniﬁed deep convolutional architecture.

5. Experimental setup and results

We evaluate our model5 on the following datasets with

evaluation protocols deﬁned by previous literature:

AFLW and AFW datasets: Similar to TCDCN [41], we
trained our models on the MTFL dataset,6 which we split
into 9,000 images for training and 1,000 for validation. We
evaluate our models on the same subsets of AFLW [15] and
AFW [45] used by [41], consisting of 2995 and 377 images,
respectively, each labeled with 5 facial keypoints.

300W dataset:

300W [20] standardizes multiple
datasets into one common dataset with 68 keypoints. The
training set is composed of 3148 images (337 AFW, 2000
Helen, and 811 LFPW). The test set is composed of 689
images (135 IBUG, 224 LFPW, and 330 Helen). The IBUG
is referred to as the challenging subset, and the union of
LFPW and Helen test sets is referred to as the common sub-
set. We shufﬂe the training set and split it into 90% train-set
(2834 images) and 10% valid-set (314 images).

One challenging issue in these datasets is that the test set
examples are signiﬁcantly different and more difﬁcult com-
pared to the training sets. In other words the train and test
set images are not from the same distribution. In particular,
the AFLW and AFW test sets contain many samples with
occlusion and more extreme rotation and expression cases
than the training set. The IBUG subset of 300W contains
more extreme pose and expressions than other subsets.

Error Metric: The euclidean distance between the true
and estimated landmark positions normalized by the dis-

5Our

code
https://github.com/SinaHonari/RCN

models

and

[14] and 5849 images from the web.

6MTFL consists of 10,000 training images: 4151 images from LFW

are

publicly

available

at

4

tance between the eyes (interocular distance) is used:

(cid:113)

N
(cid:88)

K
(cid:88)

(w(n)

k − ˜w(n)

error =

1
KN

n=1

k=1

k )2 + (h(n)
D(n)

k − ˜h(n)

k )2

,

(4)

where K is the number of keypoints, N is the total num-
ber of images, D(n) is the interocular distance in image n.
(w(n)
k ) represent the true and esti-
mated coordinates for keypoint k in image n, respectively.

k ) and ( ˜w(n)

k , h(n)

k , ˜h(n)

5.1. Evaluation on SumNet and RCN

We evaluate RCN on the 5-keypoint test sets. To avoid
overﬁtting and improve performance, we applied online
data augmentation to the 9,000 MTFL train set using ran-
dom scale, rotation, and translation jittering7. We prepro-
cessed images by making them gray-scale and applying lo-
cal contrast normalization 8. In Figure S1, we show a visu-
alization of the contribution of each branch of the SumNet
to the ﬁnal predictions: the coarsest layer provides robust
but blurry keypoint locations, while the ﬁnest layer gives
detailed face information but suffers from many false pos-
itives. However, the sum of branches in SumNet and the
ﬁnest branch in RCN make precise predictions.

Since the test sets contain more extreme occlusion and
lighting conditions compared to the train set, we applied a
preprocessing to the train set to bring it closer to the test set
distribution. In addition to the jittering, we found it helpful
to occlude images in the training set with randomly placed
black rectangles9 at each training iteration. This trick forced
the convnet models to use more global facial components to
localize the keypoints and not rely as much on the features
around the keypoints, which in turn, made it more robust
against occlusion and lighting contrast in the test set. Figure
3 shows the effects of this occlusion when used to train the
SumNet and RCN models on randomly drawn samples. The
samples show for most of the test set examples the models
do a good prediction. Figure 4 shows some hand-picked
examples from the test sets, to show extreme expression,
occlusion and contrast that are not captured in the random
samples of Figure 3. Figure 5 similarly uses some manually
selected examples to show the beneﬁts of using occlusion.
To evaluate how much each branch contributes to the
overall performance of the model, we trained models ex-
cluding some branches and report the results in Table 1. The
ﬁnest layer on its own does a poor job due to many false
positives, while the coarsest layer on its own does a reason-
able job, but still lacks high accuracy. One notable result

7We jittered data separately in each epoch, whose parameters were uni-
formly sampled in the following ranges (selected based on the validation
set performance): Translation and Scaling: [-10%, +10%] of face bound-
ing box size; Rotation: [-40, +40] degrees.

8RGB images performed worse in our experiments.
9Each image was occluded with one black (zeros) rectangle, whose size
was drawn uniformly in the range [20, 50] pixels. It’s location was drawn
uniformly over the entire image.

is that using only the coarsest and ﬁnest branches together
produces reasonable performance. However, the best per-
formance is achieved by using all branches, merging four
resolutions of coarse, medium, and ﬁne information. We

Mask
1, 0, 0, 0
0, 1, 0, 0
1, 1, 0, 0
0, 0, 1, 0
0, 0, 0, 1
0, 0, 1, 1
0, 1, 1, 1
1, 0, 0, 1
1, 1, 1, 1

SumNet

RCN

AFLW AFW AFLW AFW
10.89
10.54
11.87
11.28
9.44
9.47
15.91
16.14
48.61
45.39
13.53
13.90
7.95
7.91
7.27
6.91
6.43
6.44

10.63
11.43
9.65
16.35
47.97
14.14
8.22
7.51
6.78

10.61
11.56
9.31
15.78
46.87
12.67
7.62
6.79
6.37

Table 1. The performance of SumNet and RCN trained with masks
applied to different branches. A mask value of 1 indicates the
branch is included in the model and 0 indicates it is omitted (as a
percent; lower is better). In SumNet model mask 0 indicates no
contribution from that branch to the summation of all branches,
while in RCN, if a branch is omitted, the previous coarse branch
is upsampled to the following ﬁne branch. The mask numbers are
ordered from the coarsest branch to the ﬁnest branch.

also experimented with adding extra branches, getting to a
coarser resolution of 5 × 5 in the 5 branch model, 2 × 2
in the 6 branch model and 1 × 1 in the 7 branch model. In
each branch, the same number of convolutional layers with
the same kernel size is applied,10 and all new layers have
48 channels. The best performing model, as shown in Table
2, is RCN with 6 branches. Comparing RCN and SumNet
training, RCN converges faster. Using early stopping and
without occlusion pre-processing, RCN requires on average
200 epochs to converge (about 4 hours on a NVidia Tesla
K20 GPU), while SumNet needs on average more than 800
epochs (almost 14 hours). RCN’s error on both test sets
drops below 7% on average after only 15 epochs (about 20
minutes), while SumNet needs on average 110 epochs (al-
most 2 hours) to get to this error. Using occlusion prepro-
cessing increases these times slightly but results in lower
test error. At test time, a feedforward pass on a K20 GPU
takes 2.2ms for SumNet and 2.5ms for RCN per image in
Theano [4]. Table 2 shows occlusion pre-processing sig-
niﬁcantly helps boost the accuracy of RCN, while slightly
helping SumNet. We believe this is due to global informa-
tion ﬂow from coarser to ﬁner branches in RCN.

5.2. Comparison with other models

AFLW and AFW datasets: We ﬁrst re-implemented the
TCDCN model [41], which is the current state of the art

10A single exception is that when the 5 × 5 resolution map is reduced
to 2 × 2, we apply 3 × 3 pooling with stride 2 instead of the usual 2 × 2
pooling, to keep the resulting map left-right symmetric.

11SumNet and RCN models are trained using occlusion preprocessing.

5

Table 3. Facial landmark mean error normalized by interocular dis-
tance on AFW and AFLW sets (as a percent; lower is better).11

6. Conclusion

Model
SumNet (4 branch)
SumNet (5 branch)
SumNet (6 branch)
SumNet (5 branch - occlusion)
SumNet (6 branch - occlusion)
RCN (4 branch)
RCN (5 branch)
RCN (6 branch)
RCN (7 branch)
RCN (5 branch - occlusion)
RCN (6 branch - occlusion)
RCN (7 branch - occlusion)
RCN (6 branch - occlusion - skip)

AFLW AFW
6.78
6.53
6.48
6.34
6.33
6.43
6.05
5.98
6.12
5.44
5.36
5.55
5.56

6.44
6.42
6.34
6.29
6.27
6.37
6.11
6.00
6.17
5.65
5.60
5.76
5.63

Table 2. SumNet and RCN performance with different number of
branches, occlusion preprocessing and skip connections.

Model
TSPM [45]
CDM [38]
ESR [6]
RCPR [5]
SDM [35]
TCDCN [41]
TCDCN baseline (our implementation)
SumNet (FCN/HC) baseline (this)
RCN (this)

AFLW AFW
14.3
11.1
10.4
9.3
8.8
8.2
7.87
6.33
5.36

15.9
13.1
12.4
11.6
8.5
8.0
7.60
6.27
5.60

model on 5 keypoint AFLW [15] and AFW [45] sets, and
applied the same pre-processing as our other experiments.
Through hyper-parameter search, we even improved upon
the AFLW and AFW results reported in [41]. Table 3 com-
pares RCN with other models. Especially, it improves the
SumNet baseline, which is equivalent to FCN and Hyper-
column models, and it also converges faster. The SumNet
baseline is also provided by this paper and to the best of our
knowledge this is the ﬁrst application of any such coarse-to-
ﬁne convolutional architecture to the facial keypoint prob-
lem. Figure 6 compares TCDCN with SumNet and RCN
models, on some difﬁcult samples reported in [41].

300W dataset [20]: The RCN model that achieved the
best result on the validation set, contains 5 branches with 64
channels for all layers (higher capacity is needed to extract
features for more keypoints) and 2 extra convolutional lay-
ers with 1 × 1 kernel size in the ﬁnest branch right before
applying the softmax. Table 4 compares different models on
all keypoints (68) and a subset of keypoints (49) reported in
[32]. The denoising model is trained by randomly choos-
ing 35 keypoints in each image and jittering them (chang-
ing their location uniformly to any place in the 2D map).
It improves the RCN’s prediction by considering how loca-
tions of different keypoints are inter-dependent. Figure 7
compares the output of RCN, the denoising model and the
joint model, showing how the keypoint distribution model-
ing can reduce the error. We only trained RCN on the 2834

#keypoints Common

49

68

Model
PO-CR [32]
RCN (this)
RCN + denoising
keypoint model (this)
CDM [38]
DRMF [2]
RCPR [5]
GN-DPM [33]
CFAN [40]
ESR [6]
SDM [35]
ERT [7]
LBF [18]
CFSS[44]
TCDCN † [42]
RCN (this)
RCN + denoising
keypoint model (this)

4.00
2.64

2.59
10.10
6.65
6.18
5.78
5.50
5.28
5.57
-
4.95
4.73
4.80
4.70

IBUG Fullset
4.56
6.82
3.88
5.10

4.81
19.54
19.79
17.26
-
16.78
17.00
15.40
-
11.98
9.98
8.60
9.00

3.76
11.94
9.22
8.35
-
7.69
7.58
7.50
6.40
6.32
5.76
5.54
5.54

Table 4. Facial landmark mean error normalized by interocular dis-
tance on 300W test sets (as a percent; lower is better). 11

4.67

8.44

5.41

images in the train-set. No extra data is taken to pre-train or
ﬁne-tune the model 12. The current state-of-the-art model
without any extra data† is CFSS[44]. We reduce the error
by 15% on the IBUG subset compared to CFSS.

The model

In this paper we have introduced the Recombinator Net-
works architecture for combining coarse maps of pooled
features with ﬁne non-pooled features in convolutional
neural networks.
improves upon previous
summation-based approaches by feeding coarser branches
into ﬁner branches, allowing the ﬁner resolutions to learn
upon the features extracted by coarser branches. We ﬁnd
that this new architecture leads to both reduced training time
and increased facial keypoint prediction accuracy. We have
also proposed a denoising model for keypoints which in-
volves explicit modeling of valid spatial conﬁgurations of
keypoints. This allows our complete approach to deal with
more complex cases such as those with occlusions.

Acknowledgments

We would like to thank the Theano developers, particularly
F. Bastien and P. Lamblin, for their help throughout this
project. We appreciate Y. Bengio and H. Larochelle feed-
backs and also L. Yao, F. Ahmed and M. Pezeshki’s helps
in this project. We also thank Compute Canada, and Cal-
cul Quebec for providing computational resources. Finally,
we would like to thank Fonds de Recherche du Qu´ebec –
Nature et Technologies (FRQNT) for a doctoral research
scholarship (B2) grant during 2014 and 2015 (SH) and the
NASA Space Technology Research Fellowship (JY).

12We only jittered the train-set images by random scaling, translation

and rotation similar to the 5 keypoint dataset.

† TCDCN [42] uses 20,000 extra dataset for pre-training.

6

(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)

Features

Models

Efﬁcient
Localization [31]

Deep
Cascade [28]

Hyper-
columns [13]

Coarse features: hard crop or soft combination?
Learned coarse features fed into ﬁner branches?

Hard
No

Hard
No

Soft
No

Table 5. Comparison of multi-resolution architectures. The Efﬁcient Localization and Deep Cascade models use coarse features to crop
images (or ﬁne layer features), which are then fed into ﬁne models. This process saves computation when dealing with high-resolution
images but at the expense of making a greedy decision halfway through the model. Soft models merge local and global features of the entire
image and do not require a greedy decision. The Hypercolumn and FCN models propagate all coarse information to the ﬁnal layer but
merge information via addition instead of conditioning ﬁne features on coarse features. The Recombinator Networks (RCN), in contrast,
injects coarse features directly into ﬁner branches, allowing the ﬁne computation to be tuned by (conditioned on) the coarse information.
The model is trained end-to-end and results in learned coarse features which are tuned directly to support the eventual ﬁne predictions.

FCN
[17]

Soft
No

RCN
(this)

Soft
Yes

Figure 2. Denoising / joint keypoint model. The Recombinator Networks (RCN) and the keypoint location denoising models are trained
separately. At test time, the keypoint hard prediction of RCN is ﬁrst injected into the denoising model as one-hot maps. Then the pre-
softmax values computed by the RCN and the denoising models are summed and pass through a ﬁnal softmax to predict keypoint locations.

Figure 3. Keypoint predictions on random test set images from easy (left) to hard (right). Each column shows predictions of following
models from top to bottom: SumNet, SumNet with occlusion, RCN, RCN with occlusion (all models have 5 branches). We note for each
test set image (including both AFLW and AFW) the average error over the four models and use this as a notion of that image’s difﬁculty.
We then sort all images by difﬁculty and draw a random image from percentile bins, using the bin boundaries noted above the images.
To showcase the models’ differing performance, we show only a few easier images on the left side and focus more on the hardest couple
percent of images toward the right side. The value on the left is the average error of these samples per model (much higher than the results
reported in Table 3 because of the skew toward difﬁcult images). The yellow line connects the true keypoint location (green) to the model’s
prediction (red). Dots are small to avoid covering large regions of the image. Best viewed with zoom in color. Figure S2 shows the
performance of these four models as the difﬁculty of the examples increase.

7

Figure 4. Samples with different expressions (green border), contrast and illuminations (red border) and occlusions (blue border) from
AFLW and AFW sets. In each box, top row depicts samples from SumNet and bottom row shows samples from RCN, both with occlusion
pre-processing.

Figure 5. Samples from AFLW and AFW test sets showing keypoint detection accuracy without (top row) and with (bottom row) occlusion
pre-processing using RCN.

Figure 6. Samples from TCDCN [41] (yellow border with green predicted points) versus SumNet (orange border) and RCN (blue border).
In the latter two models, red and green dots show predicted and true keypoints. TCDCN samples are taken directly from [41].

Figure 7. Samples from 300W test sets. Each column shows samples in this order (top to bottom): RCN, keypoint denoising model and
the joint model. The ﬁrst two columns show extreme expression and occlusion samples where RCN’s prediction is highly accurate. The
next 5 columns show samples where the denoising model improves the RCN’s predictions. In the 8th column the structured model ﬁnd
a reasonable keypoint distribution but deteriorates the RCN’s predictions. Finally, the last two columns show cases where the denoising
model generates plausible keypoint distributions but far from the true keypoints.

8

References

[1] A. Asthana, T. Marks, M. Jones, K. Tieu, and M. Rohith.
Fully automatic pose-invariant face recognition via 3d pose
normalization. In ICCV, pages 937–944, 2011.

[2] A. Asthana, S. Zafeiriou, S. Cheng, and M. Pantic. Robust
discriminative response map ﬁtting with constrained local
models. In CVPR, pages 3444–3451, 2013.

[3] T. Baltruˇsaitis, P. Robinson, and L.-P. Morency. Continuous
conditional neural ﬁelds for structured regression. In ECCV,
pages 593–608. 2014.

[4] F. Bastien, P. Lamblin, R. Pascanu, J. Bergstra, I. Good-
fellow, A. Bergeron, N. Bouchard, D. Warde-Farley, and
Y. Bengio. Theano: new features and speed improvements.
In NIPS Workshop on Deep Learning, 2012.

[5] X. Burgos-Artizzu, P. Perona, and P. Doll´ar. Robust face
landmark estimation under occlusion. In ICCV, pages 1513–
1520, 2013.

[6] X. Cao, Y. Wei, F. Wen, and J. Sun. Face alignment by ex-
plicit shape regression. In ICCV, 107(2):177–190, 2014.
[7] X. Cao, Y. Wei, F. Wen, and J. Sun. Face alignment by ex-
plicit shape regression. In IJCV, 107(2):177–190, 2014.
[8] T. Cootes, G. Edwards, and C. Taylor. Active appearance

models. In PAMI, 23(6):681–685, 2001.

[9] T. Cootes, C. Taylor, D. Cooper, and J. Graham. Active shape
models-their training and application. In CVIU, 61(1):38–59,
1995.

[10] D. Cristinacce and T. Cootes. Feature detection and tracking
with constrained local models. In BMVC, volume 2, page 6,
2006.

[11] D. Cristinacce and T. Cootes. Automatic feature localisa-
tion with constrained local models. Pattern Recognition,
41(10):3054–3067, 2008.

[12] D. Cristinacce and T. F. Cootes. Boosted regression active

shape models. In BMVC, pages 1–10, 2007.

[13] B. Hariharan, P. Arbel´aez, R. Girshick, and J. Malik. Hyper-
columns for object segmentation and ﬁne-grained localiza-
tion. In CVPR, 2015.

[14] G. Huang, M. Ramesh, T. Berg, and E. Learned-Miller. La-
beled faces in the wild: A database for studying face recogni-
tion in unconstrained environments. Technical report, 07-49,
University of Massachusetts, Amherst, 2007.

[15] M. Kostinger, P. Wohlhart, P. Roth, and H. Bischof. Anno-
tated facial landmarks in the wild: A large-scale, real-world
In ICCV Work-
database for facial landmark localization.
shop, pages 2144–2151, 2011.

[16] A. Krizhevsky, I. Sutskever, and G. E. Hinton.

classiﬁcation with deep convolutional neural networks.
NIPS, pages 1106–1114, 2012.

Imagenet
In

[17] J. Long, E. Shelhamer, and T. Darrell. Fully convolutional
networks for semantic segmentation. In CVPR, 2015.
[18] S. Ren, X. Cao, Y. Wei, and J. Sun. Face alignment at 3000
In CVPR, pages

fps via regressing local binary features.
1685–1692, 2014.

[19] O. Ronneberger, P. Fischer, and T. Brox. U-net: Convolu-
tional networks for biomedical image segmentation. In Med-
ical Image Computing and Computer-Assisted Intervention–
MICCAI 2015, pages 234–241. Springer, 2015.

[20] C. Sagonas, G. Tzimiropoulos, S. Zafeiriou, and M. Pantic.
300 faces in-the-wild challenge: The ﬁrst facial landmark
localization challenge. In ICCV Workshop, pages 397–403,
2013.

[21] J. M. Saragih, S. Lucey, and J. F. Cohn. Face alignment
through subspace constrained mean-shifts. In ICCV, pages
1034–1041, 2009.

[22] P. Sermanet, K. Kavukcuoglu, S. Chintala, and Y. LeCun.
Pedestrian detection with unsupervised multi-stage feature
learning. In CVPR, pages 3626–3633, 2013.

[23] P. Sermanet and Y. LeCun. Trafﬁc sign recognition with
multi-scale convolutional networks. In IJCNN, pages 2809–
2813, 2011.

[24] K. Simonyan and A. Zisserman. Very deep convolutional

networks for large-scale image recognition. CVPR, 2014.

[25] B. Smith and L. Zhang. Collaborative facial landmark local-
ization for transferring annotations across datasets. In ECCV,
pages 78–93. 2014.

[26] B. M. Smith, J. Brandt, Z. Lin, and L. Zhang. Nonpara-
metric context modeling of local appearance for pose-and
In CVPR,
expression-robust facial landmark localization.
pages 1741–1748, 2014.

[27] Y. Sun, Y. Chen, X. Wang, and X. Tang. Deep learning face
representation by joint identiﬁcation-veriﬁcation. In NIPS,
pages 1988–1996, 2014.

[28] Y. Sun, X. Wang, and X. Tang. Deep convolutional network
In CVPR, pages 3476–

cascade for facial point detection.
3483, 2013.

[29] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed,
D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabinovich.
Going deeper with convolutions. In CVPR, 2014.

[30] Y. Taigman, M. Yang, M. Ranzato, and L. Wolf. Deepface:
Closing the gap to human-level performance in face veriﬁca-
tion. In CVPR, pages 1701–1708, 2014.

[31] J. Tompson, R. Goroshin, A. Jain, Y. LeCun, and C. Bregler.
Efﬁcient object localization using convolutional networks. In
CVPR, 2015.

[32] G. Tzimiropoulos. Project-out cascaded regression with an
application to face alignment. In Computer Vision and Pat-
tern Recognition (CVPR), 2015 IEEE Conference on, pages
3659–3667. IEEE, 2015.

[33] G. Tzimiropoulos and M. Pantic. Gauss-newton deformable
part models for face alignment in-the-wild. In CVPR, pages
1851–1858, 2014.

[34] P. Vincent, H. Larochelle, Y. Bengio, and P.-A. Manzagol.
Extracting and composing robust features with denoising au-
toencoders. In ICML, pages 1096–1103, 2008.

[35] X. Xiong and F. De la Torre. Supervised descent method and
its applications to face alignment. In CVPR, pages 532–539,
2013.

[36] H. Yang and I. Patras. Sieving regression forest votes for

facial feature detection in the wild. In ICCV. IEEE, 2013.

[37] J. Yosinski, J. Clune, A. Nguyen, T. Fuchs, and H. Lipson.
Understanding neural networks through deep visualization.
In ICML Workshop on Deep Learning, 2015.

[38] X. Yu, J. Huang, S. Zhang, W. Yan, and D. Metaxas. Pose-
free facial landmark ﬁtting via optimized part mixtures and

9

cascaded deformable shape model.
1951, 2013.

In ICCV, pages 1944–

[39] X. Yu, J. Huang, S. Zhang, W. Yan, and D. N. Metaxas. Pose-
free facial landmark ﬁtting via optimized part mixtures and
In ICCV, pages 1944–
cascaded deformable shape model.
1951, 2013.

[40] J. Zhang, S. Shan, M. Kan, and X. Chen. Coarse-to-ﬁne
auto-encoder networks (cfan) for real-time face alignment.
In ECCV, pages 1–16. 2014.

[41] Z. Zhang, P. Luo, C. Loy, and X. Tang. Facial landmark
detection by deep multi-task learning. In ECCV, pages 94–
108. 2014.

[42] Z. Zhang, P. Luo, C. C. Loy, and X. Tang. Learning deep
representation for face alignment with auxiliary attributes.
In PAMI, 2015.

[43] X. Zhao, S. Shan, X. Chai, and X. Chen.

Locality-
constrained active appearance model. In ACCV, pages 636–
647. 2013.

[44] S. Zhu, C. Li, C. C. Loy, and X. Tang. Face alignment by
coarse-to-ﬁne shape searching. In CVPR, pages 4998–5006,
2015.

[45] X. Zhu and D. Ramanan. Face detection, pose estimation,
and landmark localization in the wild. In CVPR, pages 2879–
2886, 2012.

10

Supplementary Information for
Recombinator Networks: Learning Coarse-to-Fine Feature Aggregation

a

b

c

d

e

f

Figure S1. Sub-ﬁgures a, b, c, d show pre-sum (left) and softmax (right) of the coarsest to ﬁnest branches in a 4-branch SumNet model.
The softmax used in these branches are only for illustration purposes and is not part of the trained model. Sub-ﬁgure e (left) shows the sum
of branches in the SumNet model and Sub-ﬁgure f (left) depicts the pre-softmax values in RCN. The true keypoint locations are shown by
green cross in all ﬁgures to show their relative correspondence with the branch activations. SumNet and RCN’s predictions are shown by
red plus on the post-softmax maps in Sub-ﬁgures e (right) and f (right), respectively. In each row the images correspond to the keypoints
in this order from left to right: left-eye, right-eye, nose, left-mouth, right-mouth. Best viewed electronically with zoom.

1

Figure S2. The performance of SumNet and RCN models with and without occlusion pre-processing on the merged AFW and AFLW test
sets as the difﬁculty of the examples increase (lower is better). To get this plot, we note for each test set image (including both AFLW and
AFW) the average error over the four models and use this as a notion of that image’s difﬁculty. We then sort all images by difﬁculty and
get each model’s log error (using Eq. 4) on each test example. Finally, we plot each model’s performance on the sorted test set examples
from the easiest (0% difﬁculty) to the most difﬁcult (100% difﬁculty) percentage of the test set examples. The plot shows RCN performs
better than SumNet, especially on the harder examples. The occlusion pre-processing helps RCN on most difﬁcult examples (difﬁculty >
65%), while it slightly helps SumNet.

2

Recombinator Networks: Learning Coarse-to-Fine Feature Aggregation

Sina Honari1, Jason Yosinski2, Pascal Vincent1,4, Christopher Pal3
1University of Montreal, 2Cornell University, 3Ecole Polytechnique of Montreal, 4CIFAR
1{honaris, vincentp}@iro.umontreal.ca, 2yosinski@cs.cornell.edu, 3christopher.pal@polymtl.ca

6
1
0
2
 
r
p
A
 
7
1
 
 
]

V
C
.
s
c
[
 
 
2
v
6
5
3
7
0
.
1
1
5
1
:
v
i
X
r
a

Abstract

Deep neural networks with alternating convolutional,
max-pooling and decimation layers are widely used in state
of the art architectures for computer vision. Max-pooling
purposefully discards precise spatial information in order
to create features that are more robust, and typically orga-
nized as lower resolution spatial feature maps. On some
tasks, such as whole-image classiﬁcation, max-pooling de-
rived features are well suited; however, for tasks requiring
precise localization, such as pixel level prediction and seg-
mentation, max-pooling destroys exactly the information re-
quired to perform well. Precise localization may be pre-
served by shallow convnets without pooling but at the ex-
pense of robustness. Can we have our max-pooled multi-
layered cake and eat it too? Several papers have proposed
summation and concatenation based methods for combin-
ing upsampled coarse, abstract features with ﬁner features
to produce robust pixel level predictions. Here we intro-
duce another model — dubbed Recombinator Networks —
where coarse features inform ﬁner features early in their
formation such that ﬁner features can make use of several
layers of computation in deciding how to use coarse fea-
tures. The model is trained once, end-to-end and performs
better than summation-based architectures, reducing the er-
ror from the previous state of the art on two facial keypoint
datasets, AFW and AFLW, by 30% and beating the current
state-of-the-art on 300W without using extra data. We im-
prove performance even further by adding a denoising pre-
diction model based on a novel convnet formulation.

1. Introduction

Recent progress in computer vision has been driven by
the use of large convolutional neural networks. Such net-
works beneﬁt from alternating convolution and pooling lay-
ers [16, 23, 22, 29, 24, 27, 42] where the pooling layers
serve to summarize small regions of the layer below. The
operations of convolution, followed by max-pooling, then
decimation cause features in subsequent layers of the net-
work to be increasingly translation invariant, more robust,
and to more coarsely summarize progressively larger re-

gions of the input image. As a result, features in the fourth
or ﬁfth convolutional layer serve as more robust detectors
of more global, but spatially imprecise high level patterns
like text or human faces [37]. In practice these properties
are critical for many visual tasks, and they have been par-
ticularly successful at enabling whole image classiﬁcation
[16, 29, 24]. However, for other types of vision tasks these
architectural elements are not as well suited. For example
on tasks requiring pixel-precise localization or labeling, fea-
tures arising from max-pooling and decimation operations
can only provide approximate localization, as in the pro-
cess of creating them, the network has already thrown out
precise spatial information by design. If we wish to gener-
ate features that preserve accurate localization, we may do
so using shallow networks without max-pooling, but shal-
low networks without pooling cannot learn robust, invariant
features. What we would like is to have our cake and eat
it too: to combine the best of both worlds, merging ﬁnely-
localized information from shallow, non-pooled networks
with robust, coarsely-localized features computed by deep,
pooled networks.

Several recently proposed approaches [17, 13, 31] ad-
dress this by adding or concatenating the features obtained
across multiple levels. We use this approach in our base-
line model termed SumNet for our task of interest: facial
keypoint localization. To the best of our knowledge this
is the ﬁrst time this general approach has been applied to
the problem of facial keypoint localization and even our
baseline is capable of yielding state of the art results. A
possible weakness of these approaches however is that all
detection paths, from coarsely to ﬁnely localized features,
only become aggregated at the very end of the feature pro-
cessing pipeline. As a thought experiment to illustrate this
approach’s weakness, imagine that we have a photo of a
boat ﬂoating in the ocean and would like to train a con-
vnet to predict with single pixel accuracy a keypoint cor-
responding to the tip of the boat’s bow. Coarsely local-
ized features1 could highlight the rough region of the bow
of the boat, and ﬁnely localized features could be tuned to

1From now on we use the shorthand ﬁne/coarse features to mean

ﬁnely/coarsely localized features.

1

Figure 1. (Left) Architecture of summation based coarse-ﬁne network (SumNet). C is a convolutional layer. P,C represents a pooling
layer followed by a convolutional layer. All convolutions are 3 × 3 and all poolings are 2 × 2. All convolutional layers are followed
by ReLU non-linearity except the last convolutional layer in each branch. U represents an upsampling layer. Each branch’s output is 5
feature maps of size 80 × 80. FCN/Hypercolumn models use this architecture. (Right) Architecture of the Recombinator Networks (RCN).
All convolutions are 3 × 3 and all poolings are 2 × 2. All upsamplings are by a factor of 2. K represents concatenation of two sets of
feature maps along the feature map dimension. All convolutional layers are followed by ReLU non-linearity except the one right before the
softmax. In the Recombinator Networks model with skip connections (not shown), each branch takes upsampled features not only from
one coarser branch, but from all coarser branches.

ﬁnd generic boat edges, but the ﬁne features must remain
generic, being forced to learn boat edge detectors for all
possible ocean and boat color combinations. This would be
difﬁcult, because boat and ocean pixels could take similar
colors and textures. Instead, we would like a way for the
coarse features which contain information about the global
scene structure (perhaps that the water is dark blue and the
boat is bright blue) to provide information to the ﬁne feature
detectors earlier in their processing pipeline. Without such
information, the ﬁne feature detectors would be unable to
tell which half of a light blue/dark blue edge was ocean and
which was boat. In the Recombinator Networks proposed
in this paper, the ﬁnely localized features are conditioned
on higher level more coarsely localized information. It re-
sults in a model which is deeper but – interestingly – trains
faster than the summation baseline and yields more precise
localization predictions. In summary, this work makes the
following contributions:

1. We propose a novel architecture — the Recombinator
Networks — for combining information over different
spatial localization resolutions (Section 3).

2. We show how a simple denoising model may be used

to enhance model predictions (Section 4).

3. We provide an in-depth empirical evaluation of a wide
variety of relevant architectural variants (Section 5.1).
4. We show state of the art performance on two widely
used and competitive evaluations for facial keypoint
localization (Section 5.2).

2. Related work

Keypoint localization methods: Our task of interest
is the well studied problem of facial keypoint localization
[44, 42, 38, 2, 33, 40, 6, 35, 7, 18, 45] illustrated in Fig-
ure 1. Precise facial keypoint localization is often an es-
sential preprocessing step for face recognition [1] and de-

tection [45]. Recent face veriﬁcation models like DeepFace
[30] and DeepID2 [27] also include keypoint localization
as the ﬁrst step. There have been many other approaches to
general keypoint localization, including active appearance
models [8, 43], constrained local models [10, 21, 11, 2], ac-
tive shape models [12], point distribution models [9], struc-
tured model prediction [3, 31], tree structured face mod-
els [45], group sparse learning based methods [39], shape
regularization models that combines multiple datasets [25],
feature voting based landmark localization [26, 36] and
convolutional neural networks based models [41, 28, 42].
Two other related models are [31], where a multi-resolution
model is proposed with dual coarse/ﬁne paths and tied ﬁl-
ters, and [28], which uses a cascaded architecture to reﬁne
predictions over several stages. Both of these latter mod-
els make hard decisions using coarse information halfway
through the model.

Approaches that combine features across multiple
levels: Several recent models — including the fully convo-
lutional networks (FCNs) in [17], the Hypercolumn model
[13], and the localization model of Tompson et al. [31] —
generate features or predictions at multiple resolutions, up-
sample the coarse features to the ﬁne resolution, and then
add or concatenate the features or predictions together. This
approach has generally worked well, improving on previ-
ous state of the art results in detection, segmentation, and
human-body pose estimation [13, 17, 31]. In this paper we
create a baseline model similar to these approaches that we
refer to as SumNet in which we use a network that aggre-
gates information from features across different levels in the
hierarchy of a conv-pool-decimate network using concate-
nation followed by a weighted sum over feature maps prior
to ﬁnal layer softmax predictions. Our goal in this paper is
to improve upon this architecture. Differences between the
Recombinator Networks and related architectures are sum-

2

marized in Table 5. U-Net [19] is another model that merges
features across multiple levels and has a very similar archi-
tecture to Recombinator Networks. The two models have
been developed independently and were designed for differ-
ent problems2. Note that none of these models use a learned
denoising post-processing as we do (see section 4).

3. Summation versus Recombinator Networks

In this section we describe our baseline SumNet model
based on a common architectural design where information
from different levels of granularity are merged just prior to
predictions being made. We contrast this with the Recom-
binator Networks architecture.

3.1. Summation based Networks

The SumNet architecture, shown in Figure 1(left), adds
to the usual bottom to top convolution and spatial pool-
ing, or “trunk”, a horizontal left-to-right “branch” at each
resolution level. While spatial pooling progressively re-
duces the resolution as we move “up” the network along
the trunk, the horizontal branches only contains full con-
volutions and element-wise non-linearities, with no spatial
pooling, so that they can preserve the spatial resolution at
that level while doing further processing. The output of
the ﬁnest resolution branch only goes through convolutional
layers. The ﬁnest resolution layers keep positional informa-
tion and use it to guide the coarser layers within the patch
that they cannot have any preference, while the coarser res-
olution layers help ﬁner layers to get rid of false positives.
The architecture then combines the rightmost low resolution
output of all horizontal branches, into a single high resolu-
tion prediction, by ﬁrst up-sampling3 them all to the model’s
input image resolution (80 × 80 for our experiments) and
then taking a weighted sum to yield the pre-softmax val-
ues. Finally, a softmax function is applied to yield the ﬁ-
nal location probability map for each keypoint. Formally,
given an input image x, deﬁne the trunk of the network as
a sequence of blocks of traditional groups of convolution,
pooling and decimation operations. Starting from the layer
yielding the coarsest scale feature maps we call the outputs
of R such blocks T (1), . . . , T (R). At each level r of the
trunk we have a horizontal branch that takes T (r) as its in-
put and consists of a sequence of convolutional layers with
no subsampling. The output of such a branch is a stack of
K feature maps, one for each of the K target keypoints, at
the same resolution as its input T (r), and we denote this
output as branch(T (r)).
It is then upsampled up[×F ] by
some factor F which returns the feature map to the original
resolution of the input image. Let these upsampled maps
be M (1)
is the score map given by

K where M (r)

1 , . . . , M (R)

k

2For keypoint localization, we apply the softmax spatially i.e. across
possible spatial locations, whereas for segmentation [13, 17, 19] it is ap-
plied across all possible classes for each pixel.

3Upsampling can be performed either by tiling values or by using bilin-
ear interpolation. We found bilinear interpolation degraded performance in
some cases, so we instead used the simpler tiling approach.

k

the rth branch to the kth keypoint (left eye, right eye, . . .).
Each such map M (r)
is a matrix of the same resolution as
the image fed as input (i.e. 80 × 80). The score ascribed
by branch r for keypoint k being at coordinate i, j is given
by M (r)
k,i,j. The ﬁnal probability map for the location Yk of
keypoint k is given by a softmax over all possible locations.
We can therefore write the model as

M (1) = up[×2R−1](branch(T (1)))
M (2) = up[×2R−2](branch(T (2)))
. . .
M (R) = branch(T (R))

P (Yk|X = x) = softmax

(cid:16) R
(cid:88)

r=1

αrkM (r)

k

(cid:17)

,

(1)

where αrk is a 2D matrix that gives a weight to every
pixel location i, j of keypoint k in branch r. The weighted
sum of features over all branches taken here is equivalent to
concatenating the features of all branches and multiplying
them in a set of weights, which results in one feature map
per keypoint. This architecture is trained globally using
gradient backpropagation to minimize the sum of negated
conditional log probabilities of all N training (input-image,
keypoint-locations) pairs, for all K keypoints (x(n), y(n)
k ),
with an additional regularization term for the weights ; i.e.
we search for network parameters W that minimize 4

L(W) =

− log P (Yk = y(n)

k |X = x(n)) + λ(cid:107)W(cid:107)2.

1
N

N
(cid:88)

K
(cid:88)

n=1

k=1

(2)

3.2. The Recombinator Networks

In the SumNet model, different branches can only com-
municate through the updates received from the output layer
and the features are merged linearly through summation. In
the Recombinator Networks (RCN) architecture, as shown
in Figure 1(right), instead of taking a weighted sum of the
upsampled feature maps in each branch and then passing
them to a softmax, the output of each branch is upsampled,
then concatenated with the next level branch with one de-
gree of ﬁner resolution. In contrast to the SumNet model,
each branch does not end in K feature maps. The infor-
mation stays in the form of a keypoint independent feature
map. It is only at the end of the Rth branch that feature
maps are converted into a per-keypoint scoring represen-
tation that has the same resolution as the input image, on
which a softmax is then applied. As a result of RCN’s dif-
ferent architecture, branches pass more information to each
other during training, such that convolutional layers in the
ﬁner branches get inputs from both coarse and ﬁne layers,
letting the network learn how to combine them non-linearly
to maximize the log likelihood of the keypoints given the

4 We also tried L2 distance cost between true and estimated keypoints
(as a regression problem) and got worse results. This may be due to the
fact that a softmax probability map can be multimodal , while L2 distance
implicitly corresponds to likelihood of a unimodal isotropic Gaussian.

3

input images. The whole network is trained end-to-end
by backprop. Following the previous conventions and by
deﬁning the concatenation operator on feature maps A, B
as concat(A, B), we can write the model as

M (cid:48)(1) = up[×2](branch(T (1)))
M (cid:48)(2) = up[×2](branch(concat(T (2), M (cid:48)(1))))
. . .
M (cid:48)(R) = branch(concat(T (R), M (cid:48)(R−1)))
P (Yk|X = x) = softmax(M (cid:48)(R)

).

k

(3)

skip

also
the

each branch are

explore RCN with
features of

connections,
We
concate-
where
nated with upsampled features of not only one-level
coarser branch,
coarser branches
the last branch computes M (cid:48)(R) =
and,
therefore,
branch(concat(T (R), M (cid:48)(R−1), M (cid:48)(R−2), . . . , M (cid:48)(1)).
In
practice, the information ﬂow between different branches
makes RCN converge faster and also perform better
compared to the SumNet model.

all previous

but

4. Denoising keypoint model

Convolutional networks are excellent edge detectors. If
there are few samples with occlusion in the training sets,
convnets have problem detecting occluded keypoints and
instead select nearby edges (see some samples in Figures
3, 5). Moreover, the convnet predictions, especially on
datasets with many keypoints, do not always correspond to
a plausible keypoint distribution and some keypoints jump
off the curve (e.g. on the face contour or eye-brows) irre-
spective of other keypoints’ position (see some samples in
Figure 7). This type of error can be addressed by using a
structured output predictor on top of the convnet, that takes
into account how likely the location of a keypoint is rel-
ative to other keypoints. Our approach is to train another
convolutional network that captures useful aspects of the
prior keypoint distribution (not conditioned on the image).
We train it to predict the position of a random subsets of
keypoints, given the position of the other keypoints. More
speciﬁcally, we train the convolutional network as a denois-
ing model, similar to the denoising auto-encoder [34] by
completely corrupting the location of a randomly chosen
subset of the keypoints and learning to accurately predict
their correct location given that of the other keypoints. This
network receives as input, not the image, but only keypoint
locations represented as one-hot 2D maps (one 2D map per
keypoint, with a 1 at the position of the keypoint and ze-
ros elsewhere). It is composed of convolutional layers with
large receptive ﬁelds (to get to see nearby keypoints), ReLU
nonlinearities and no subsampling (see Figure 2). The net-
work outputs probability maps for the location of all key-
points, however, its training criterion uses only prediction

errors of the corrupted ones. The cost being optimized sim-
ilar to Eq.(2) but includes only the corrupted keypoints.

Once, this denoising model is trained, the output of RCN
(the predicted most likely location in one-hot binary loca-
tion 2D map format) is fed to the denoising model. We
then simply sum the pre-softmax values of both RCN and
denoising models and pass them through a softmax to gen-
erate the ﬁnal output probability maps. The joint model is
depicted in Figure 2. The joint model combines the RCN’s
predicted conditional distribution for keypoint k given the
image P (Yk|X = x) with the denoising model’s distri-
bution of the location of that keypoint given other key-
points P (Yk|Y¬k), to yield an estimation of keypoint k’s
location given both image and other keypoint locations
P (Yk|Y¬k, X = x). The choice of convolutional networks
for the denoising model allows it to be easily combined with
RCN in a uniﬁed deep convolutional architecture.

5. Experimental setup and results

We evaluate our model5 on the following datasets with

evaluation protocols deﬁned by previous literature:

AFLW and AFW datasets: Similar to TCDCN [41], we
trained our models on the MTFL dataset,6 which we split
into 9,000 images for training and 1,000 for validation. We
evaluate our models on the same subsets of AFLW [15] and
AFW [45] used by [41], consisting of 2995 and 377 images,
respectively, each labeled with 5 facial keypoints.

300W dataset:

300W [20] standardizes multiple
datasets into one common dataset with 68 keypoints. The
training set is composed of 3148 images (337 AFW, 2000
Helen, and 811 LFPW). The test set is composed of 689
images (135 IBUG, 224 LFPW, and 330 Helen). The IBUG
is referred to as the challenging subset, and the union of
LFPW and Helen test sets is referred to as the common sub-
set. We shufﬂe the training set and split it into 90% train-set
(2834 images) and 10% valid-set (314 images).

One challenging issue in these datasets is that the test set
examples are signiﬁcantly different and more difﬁcult com-
pared to the training sets. In other words the train and test
set images are not from the same distribution. In particular,
the AFLW and AFW test sets contain many samples with
occlusion and more extreme rotation and expression cases
than the training set. The IBUG subset of 300W contains
more extreme pose and expressions than other subsets.

Error Metric: The euclidean distance between the true
and estimated landmark positions normalized by the dis-

5Our

code
https://github.com/SinaHonari/RCN

models

and

[14] and 5849 images from the web.

6MTFL consists of 10,000 training images: 4151 images from LFW

are

publicly

available

at

4

tance between the eyes (interocular distance) is used:

(cid:113)

N
(cid:88)

K
(cid:88)

(w(n)

k − ˜w(n)

error =

1
KN

n=1

k=1

k )2 + (h(n)
D(n)

k − ˜h(n)

k )2

,

(4)

where K is the number of keypoints, N is the total num-
ber of images, D(n) is the interocular distance in image n.
(w(n)
k ) represent the true and esti-
mated coordinates for keypoint k in image n, respectively.

k ) and ( ˜w(n)

k , h(n)

k , ˜h(n)

5.1. Evaluation on SumNet and RCN

We evaluate RCN on the 5-keypoint test sets. To avoid
overﬁtting and improve performance, we applied online
data augmentation to the 9,000 MTFL train set using ran-
dom scale, rotation, and translation jittering7. We prepro-
cessed images by making them gray-scale and applying lo-
cal contrast normalization 8. In Figure S1, we show a visu-
alization of the contribution of each branch of the SumNet
to the ﬁnal predictions: the coarsest layer provides robust
but blurry keypoint locations, while the ﬁnest layer gives
detailed face information but suffers from many false pos-
itives. However, the sum of branches in SumNet and the
ﬁnest branch in RCN make precise predictions.

Since the test sets contain more extreme occlusion and
lighting conditions compared to the train set, we applied a
preprocessing to the train set to bring it closer to the test set
distribution. In addition to the jittering, we found it helpful
to occlude images in the training set with randomly placed
black rectangles9 at each training iteration. This trick forced
the convnet models to use more global facial components to
localize the keypoints and not rely as much on the features
around the keypoints, which in turn, made it more robust
against occlusion and lighting contrast in the test set. Figure
3 shows the effects of this occlusion when used to train the
SumNet and RCN models on randomly drawn samples. The
samples show for most of the test set examples the models
do a good prediction. Figure 4 shows some hand-picked
examples from the test sets, to show extreme expression,
occlusion and contrast that are not captured in the random
samples of Figure 3. Figure 5 similarly uses some manually
selected examples to show the beneﬁts of using occlusion.
To evaluate how much each branch contributes to the
overall performance of the model, we trained models ex-
cluding some branches and report the results in Table 1. The
ﬁnest layer on its own does a poor job due to many false
positives, while the coarsest layer on its own does a reason-
able job, but still lacks high accuracy. One notable result

7We jittered data separately in each epoch, whose parameters were uni-
formly sampled in the following ranges (selected based on the validation
set performance): Translation and Scaling: [-10%, +10%] of face bound-
ing box size; Rotation: [-40, +40] degrees.

8RGB images performed worse in our experiments.
9Each image was occluded with one black (zeros) rectangle, whose size
was drawn uniformly in the range [20, 50] pixels. It’s location was drawn
uniformly over the entire image.

is that using only the coarsest and ﬁnest branches together
produces reasonable performance. However, the best per-
formance is achieved by using all branches, merging four
resolutions of coarse, medium, and ﬁne information. We

Mask
1, 0, 0, 0
0, 1, 0, 0
1, 1, 0, 0
0, 0, 1, 0
0, 0, 0, 1
0, 0, 1, 1
0, 1, 1, 1
1, 0, 0, 1
1, 1, 1, 1

SumNet

RCN

AFLW AFW AFLW AFW
10.89
10.54
11.87
11.28
9.44
9.47
15.91
16.14
48.61
45.39
13.53
13.90
7.95
7.91
7.27
6.91
6.43
6.44

10.61
11.56
9.31
15.78
46.87
12.67
7.62
6.79
6.37

10.63
11.43
9.65
16.35
47.97
14.14
8.22
7.51
6.78

Table 1. The performance of SumNet and RCN trained with masks
applied to different branches. A mask value of 1 indicates the
branch is included in the model and 0 indicates it is omitted (as a
percent; lower is better). In SumNet model mask 0 indicates no
contribution from that branch to the summation of all branches,
while in RCN, if a branch is omitted, the previous coarse branch
is upsampled to the following ﬁne branch. The mask numbers are
ordered from the coarsest branch to the ﬁnest branch.

also experimented with adding extra branches, getting to a
coarser resolution of 5 × 5 in the 5 branch model, 2 × 2
in the 6 branch model and 1 × 1 in the 7 branch model. In
each branch, the same number of convolutional layers with
the same kernel size is applied,10 and all new layers have
48 channels. The best performing model, as shown in Table
2, is RCN with 6 branches. Comparing RCN and SumNet
training, RCN converges faster. Using early stopping and
without occlusion pre-processing, RCN requires on average
200 epochs to converge (about 4 hours on a NVidia Tesla
K20 GPU), while SumNet needs on average more than 800
epochs (almost 14 hours). RCN’s error on both test sets
drops below 7% on average after only 15 epochs (about 20
minutes), while SumNet needs on average 110 epochs (al-
most 2 hours) to get to this error. Using occlusion prepro-
cessing increases these times slightly but results in lower
test error. At test time, a feedforward pass on a K20 GPU
takes 2.2ms for SumNet and 2.5ms for RCN per image in
Theano [4]. Table 2 shows occlusion pre-processing sig-
niﬁcantly helps boost the accuracy of RCN, while slightly
helping SumNet. We believe this is due to global informa-
tion ﬂow from coarser to ﬁner branches in RCN.

5.2. Comparison with other models

AFLW and AFW datasets: We ﬁrst re-implemented the
TCDCN model [41], which is the current state of the art

10A single exception is that when the 5 × 5 resolution map is reduced
to 2 × 2, we apply 3 × 3 pooling with stride 2 instead of the usual 2 × 2
pooling, to keep the resulting map left-right symmetric.

11SumNet and RCN models are trained using occlusion preprocessing.

5

Table 3. Facial landmark mean error normalized by interocular dis-
tance on AFW and AFLW sets (as a percent; lower is better).11

6. Conclusion

Model
SumNet (4 branch)
SumNet (5 branch)
SumNet (6 branch)
SumNet (5 branch - occlusion)
SumNet (6 branch - occlusion)
RCN (4 branch)
RCN (5 branch)
RCN (6 branch)
RCN (7 branch)
RCN (5 branch - occlusion)
RCN (6 branch - occlusion)
RCN (7 branch - occlusion)
RCN (6 branch - occlusion - skip)

AFLW AFW
6.78
6.53
6.48
6.34
6.33
6.43
6.05
5.98
6.12
5.44
5.36
5.55
5.56

6.44
6.42
6.34
6.29
6.27
6.37
6.11
6.00
6.17
5.65
5.60
5.76
5.63

Table 2. SumNet and RCN performance with different number of
branches, occlusion preprocessing and skip connections.

Model
TSPM [45]
CDM [38]
ESR [6]
RCPR [5]
SDM [35]
TCDCN [41]
TCDCN baseline (our implementation)
SumNet (FCN/HC) baseline (this)
RCN (this)

AFLW AFW
14.3
11.1
10.4
9.3
8.8
8.2
7.87
6.33
5.36

15.9
13.1
12.4
11.6
8.5
8.0
7.60
6.27
5.60

model on 5 keypoint AFLW [15] and AFW [45] sets, and
applied the same pre-processing as our other experiments.
Through hyper-parameter search, we even improved upon
the AFLW and AFW results reported in [41]. Table 3 com-
pares RCN with other models. Especially, it improves the
SumNet baseline, which is equivalent to FCN and Hyper-
column models, and it also converges faster. The SumNet
baseline is also provided by this paper and to the best of our
knowledge this is the ﬁrst application of any such coarse-to-
ﬁne convolutional architecture to the facial keypoint prob-
lem. Figure 6 compares TCDCN with SumNet and RCN
models, on some difﬁcult samples reported in [41].

300W dataset [20]: The RCN model that achieved the
best result on the validation set, contains 5 branches with 64
channels for all layers (higher capacity is needed to extract
features for more keypoints) and 2 extra convolutional lay-
ers with 1 × 1 kernel size in the ﬁnest branch right before
applying the softmax. Table 4 compares different models on
all keypoints (68) and a subset of keypoints (49) reported in
[32]. The denoising model is trained by randomly choos-
ing 35 keypoints in each image and jittering them (chang-
ing their location uniformly to any place in the 2D map).
It improves the RCN’s prediction by considering how loca-
tions of different keypoints are inter-dependent. Figure 7
compares the output of RCN, the denoising model and the
joint model, showing how the keypoint distribution model-
ing can reduce the error. We only trained RCN on the 2834

#keypoints Common

49

68

Model
PO-CR [32]
RCN (this)
RCN + denoising
keypoint model (this)
CDM [38]
DRMF [2]
RCPR [5]
GN-DPM [33]
CFAN [40]
ESR [6]
SDM [35]
ERT [7]
LBF [18]
CFSS[44]
TCDCN † [42]
RCN (this)
RCN + denoising
keypoint model (this)

4.00
2.64

2.59
10.10
6.65
6.18
5.78
5.50
5.28
5.57
-
4.95
4.73
4.80
4.70

IBUG Fullset
4.56
6.82
3.88
5.10

4.81
19.54
19.79
17.26
-
16.78
17.00
15.40
-
11.98
9.98
8.60
9.00

3.76
11.94
9.22
8.35
-
7.69
7.58
7.50
6.40
6.32
5.76
5.54
5.54

Table 4. Facial landmark mean error normalized by interocular dis-
tance on 300W test sets (as a percent; lower is better). 11

4.67

8.44

5.41

images in the train-set. No extra data is taken to pre-train or
ﬁne-tune the model 12. The current state-of-the-art model
without any extra data† is CFSS[44]. We reduce the error
by 15% on the IBUG subset compared to CFSS.

The model

In this paper we have introduced the Recombinator Net-
works architecture for combining coarse maps of pooled
features with ﬁne non-pooled features in convolutional
neural networks.
improves upon previous
summation-based approaches by feeding coarser branches
into ﬁner branches, allowing the ﬁner resolutions to learn
upon the features extracted by coarser branches. We ﬁnd
that this new architecture leads to both reduced training time
and increased facial keypoint prediction accuracy. We have
also proposed a denoising model for keypoints which in-
volves explicit modeling of valid spatial conﬁgurations of
keypoints. This allows our complete approach to deal with
more complex cases such as those with occlusions.

Acknowledgments

We would like to thank the Theano developers, particularly
F. Bastien and P. Lamblin, for their help throughout this
project. We appreciate Y. Bengio and H. Larochelle feed-
backs and also L. Yao, F. Ahmed and M. Pezeshki’s helps
in this project. We also thank Compute Canada, and Cal-
cul Quebec for providing computational resources. Finally,
we would like to thank Fonds de Recherche du Qu´ebec –
Nature et Technologies (FRQNT) for a doctoral research
scholarship (B2) grant during 2014 and 2015 (SH) and the
NASA Space Technology Research Fellowship (JY).

12We only jittered the train-set images by random scaling, translation

and rotation similar to the 5 keypoint dataset.

† TCDCN [42] uses 20,000 extra dataset for pre-training.

6

(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)

Features

Models

Efﬁcient
Localization [31]

Deep
Cascade [28]

Hyper-
columns [13]

Coarse features: hard crop or soft combination?
Learned coarse features fed into ﬁner branches?

Hard
No

Hard
No

Soft
No

Table 5. Comparison of multi-resolution architectures. The Efﬁcient Localization and Deep Cascade models use coarse features to crop
images (or ﬁne layer features), which are then fed into ﬁne models. This process saves computation when dealing with high-resolution
images but at the expense of making a greedy decision halfway through the model. Soft models merge local and global features of the entire
image and do not require a greedy decision. The Hypercolumn and FCN models propagate all coarse information to the ﬁnal layer but
merge information via addition instead of conditioning ﬁne features on coarse features. The Recombinator Networks (RCN), in contrast,
injects coarse features directly into ﬁner branches, allowing the ﬁne computation to be tuned by (conditioned on) the coarse information.
The model is trained end-to-end and results in learned coarse features which are tuned directly to support the eventual ﬁne predictions.

FCN
[17]

Soft
No

RCN
(this)

Soft
Yes

Figure 2. Denoising / joint keypoint model. The Recombinator Networks (RCN) and the keypoint location denoising models are trained
separately. At test time, the keypoint hard prediction of RCN is ﬁrst injected into the denoising model as one-hot maps. Then the pre-
softmax values computed by the RCN and the denoising models are summed and pass through a ﬁnal softmax to predict keypoint locations.

Figure 3. Keypoint predictions on random test set images from easy (left) to hard (right). Each column shows predictions of following
models from top to bottom: SumNet, SumNet with occlusion, RCN, RCN with occlusion (all models have 5 branches). We note for each
test set image (including both AFLW and AFW) the average error over the four models and use this as a notion of that image’s difﬁculty.
We then sort all images by difﬁculty and draw a random image from percentile bins, using the bin boundaries noted above the images.
To showcase the models’ differing performance, we show only a few easier images on the left side and focus more on the hardest couple
percent of images toward the right side. The value on the left is the average error of these samples per model (much higher than the results
reported in Table 3 because of the skew toward difﬁcult images). The yellow line connects the true keypoint location (green) to the model’s
prediction (red). Dots are small to avoid covering large regions of the image. Best viewed with zoom in color. Figure S2 shows the
performance of these four models as the difﬁculty of the examples increase.

7

Figure 4. Samples with different expressions (green border), contrast and illuminations (red border) and occlusions (blue border) from
AFLW and AFW sets. In each box, top row depicts samples from SumNet and bottom row shows samples from RCN, both with occlusion
pre-processing.

Figure 5. Samples from AFLW and AFW test sets showing keypoint detection accuracy without (top row) and with (bottom row) occlusion
pre-processing using RCN.

Figure 6. Samples from TCDCN [41] (yellow border with green predicted points) versus SumNet (orange border) and RCN (blue border).
In the latter two models, red and green dots show predicted and true keypoints. TCDCN samples are taken directly from [41].

Figure 7. Samples from 300W test sets. Each column shows samples in this order (top to bottom): RCN, keypoint denoising model and
the joint model. The ﬁrst two columns show extreme expression and occlusion samples where RCN’s prediction is highly accurate. The
next 5 columns show samples where the denoising model improves the RCN’s predictions. In the 8th column the structured model ﬁnd
a reasonable keypoint distribution but deteriorates the RCN’s predictions. Finally, the last two columns show cases where the denoising
model generates plausible keypoint distributions but far from the true keypoints.

8

References

[1] A. Asthana, T. Marks, M. Jones, K. Tieu, and M. Rohith.
Fully automatic pose-invariant face recognition via 3d pose
normalization. In ICCV, pages 937–944, 2011.

[2] A. Asthana, S. Zafeiriou, S. Cheng, and M. Pantic. Robust
discriminative response map ﬁtting with constrained local
models. In CVPR, pages 3444–3451, 2013.

[3] T. Baltruˇsaitis, P. Robinson, and L.-P. Morency. Continuous
conditional neural ﬁelds for structured regression. In ECCV,
pages 593–608. 2014.

[4] F. Bastien, P. Lamblin, R. Pascanu, J. Bergstra, I. Good-
fellow, A. Bergeron, N. Bouchard, D. Warde-Farley, and
Y. Bengio. Theano: new features and speed improvements.
In NIPS Workshop on Deep Learning, 2012.

[5] X. Burgos-Artizzu, P. Perona, and P. Doll´ar. Robust face
landmark estimation under occlusion. In ICCV, pages 1513–
1520, 2013.

[6] X. Cao, Y. Wei, F. Wen, and J. Sun. Face alignment by ex-
plicit shape regression. In ICCV, 107(2):177–190, 2014.
[7] X. Cao, Y. Wei, F. Wen, and J. Sun. Face alignment by ex-
plicit shape regression. In IJCV, 107(2):177–190, 2014.
[8] T. Cootes, G. Edwards, and C. Taylor. Active appearance

models. In PAMI, 23(6):681–685, 2001.

[9] T. Cootes, C. Taylor, D. Cooper, and J. Graham. Active shape
models-their training and application. In CVIU, 61(1):38–59,
1995.

[10] D. Cristinacce and T. Cootes. Feature detection and tracking
with constrained local models. In BMVC, volume 2, page 6,
2006.

[11] D. Cristinacce and T. Cootes. Automatic feature localisa-
tion with constrained local models. Pattern Recognition,
41(10):3054–3067, 2008.

[12] D. Cristinacce and T. F. Cootes. Boosted regression active

shape models. In BMVC, pages 1–10, 2007.

[13] B. Hariharan, P. Arbel´aez, R. Girshick, and J. Malik. Hyper-
columns for object segmentation and ﬁne-grained localiza-
tion. In CVPR, 2015.

[14] G. Huang, M. Ramesh, T. Berg, and E. Learned-Miller. La-
beled faces in the wild: A database for studying face recogni-
tion in unconstrained environments. Technical report, 07-49,
University of Massachusetts, Amherst, 2007.

[15] M. Kostinger, P. Wohlhart, P. Roth, and H. Bischof. Anno-
tated facial landmarks in the wild: A large-scale, real-world
In ICCV Work-
database for facial landmark localization.
shop, pages 2144–2151, 2011.

[16] A. Krizhevsky, I. Sutskever, and G. E. Hinton.

classiﬁcation with deep convolutional neural networks.
NIPS, pages 1106–1114, 2012.

Imagenet
In

[17] J. Long, E. Shelhamer, and T. Darrell. Fully convolutional
networks for semantic segmentation. In CVPR, 2015.
[18] S. Ren, X. Cao, Y. Wei, and J. Sun. Face alignment at 3000
In CVPR, pages

fps via regressing local binary features.
1685–1692, 2014.

[19] O. Ronneberger, P. Fischer, and T. Brox. U-net: Convolu-
tional networks for biomedical image segmentation. In Med-
ical Image Computing and Computer-Assisted Intervention–
MICCAI 2015, pages 234–241. Springer, 2015.

[20] C. Sagonas, G. Tzimiropoulos, S. Zafeiriou, and M. Pantic.
300 faces in-the-wild challenge: The ﬁrst facial landmark
localization challenge. In ICCV Workshop, pages 397–403,
2013.

[21] J. M. Saragih, S. Lucey, and J. F. Cohn. Face alignment
through subspace constrained mean-shifts. In ICCV, pages
1034–1041, 2009.

[22] P. Sermanet, K. Kavukcuoglu, S. Chintala, and Y. LeCun.
Pedestrian detection with unsupervised multi-stage feature
learning. In CVPR, pages 3626–3633, 2013.

[23] P. Sermanet and Y. LeCun. Trafﬁc sign recognition with
multi-scale convolutional networks. In IJCNN, pages 2809–
2813, 2011.

[24] K. Simonyan and A. Zisserman. Very deep convolutional

networks for large-scale image recognition. CVPR, 2014.

[25] B. Smith and L. Zhang. Collaborative facial landmark local-
ization for transferring annotations across datasets. In ECCV,
pages 78–93. 2014.

[26] B. M. Smith, J. Brandt, Z. Lin, and L. Zhang. Nonpara-
metric context modeling of local appearance for pose-and
In CVPR,
expression-robust facial landmark localization.
pages 1741–1748, 2014.

[27] Y. Sun, Y. Chen, X. Wang, and X. Tang. Deep learning face
representation by joint identiﬁcation-veriﬁcation. In NIPS,
pages 1988–1996, 2014.

[28] Y. Sun, X. Wang, and X. Tang. Deep convolutional network
In CVPR, pages 3476–

cascade for facial point detection.
3483, 2013.

[29] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed,
D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabinovich.
Going deeper with convolutions. In CVPR, 2014.

[30] Y. Taigman, M. Yang, M. Ranzato, and L. Wolf. Deepface:
Closing the gap to human-level performance in face veriﬁca-
tion. In CVPR, pages 1701–1708, 2014.

[31] J. Tompson, R. Goroshin, A. Jain, Y. LeCun, and C. Bregler.
Efﬁcient object localization using convolutional networks. In
CVPR, 2015.

[32] G. Tzimiropoulos. Project-out cascaded regression with an
application to face alignment. In Computer Vision and Pat-
tern Recognition (CVPR), 2015 IEEE Conference on, pages
3659–3667. IEEE, 2015.

[33] G. Tzimiropoulos and M. Pantic. Gauss-newton deformable
part models for face alignment in-the-wild. In CVPR, pages
1851–1858, 2014.

[34] P. Vincent, H. Larochelle, Y. Bengio, and P.-A. Manzagol.
Extracting and composing robust features with denoising au-
toencoders. In ICML, pages 1096–1103, 2008.

[35] X. Xiong and F. De la Torre. Supervised descent method and
its applications to face alignment. In CVPR, pages 532–539,
2013.

[36] H. Yang and I. Patras. Sieving regression forest votes for

facial feature detection in the wild. In ICCV. IEEE, 2013.

[37] J. Yosinski, J. Clune, A. Nguyen, T. Fuchs, and H. Lipson.
Understanding neural networks through deep visualization.
In ICML Workshop on Deep Learning, 2015.

[38] X. Yu, J. Huang, S. Zhang, W. Yan, and D. Metaxas. Pose-
free facial landmark ﬁtting via optimized part mixtures and

9

cascaded deformable shape model.
1951, 2013.

In ICCV, pages 1944–

[39] X. Yu, J. Huang, S. Zhang, W. Yan, and D. N. Metaxas. Pose-
free facial landmark ﬁtting via optimized part mixtures and
In ICCV, pages 1944–
cascaded deformable shape model.
1951, 2013.

[40] J. Zhang, S. Shan, M. Kan, and X. Chen. Coarse-to-ﬁne
auto-encoder networks (cfan) for real-time face alignment.
In ECCV, pages 1–16. 2014.

[41] Z. Zhang, P. Luo, C. Loy, and X. Tang. Facial landmark
detection by deep multi-task learning. In ECCV, pages 94–
108. 2014.

[42] Z. Zhang, P. Luo, C. C. Loy, and X. Tang. Learning deep
representation for face alignment with auxiliary attributes.
In PAMI, 2015.

[43] X. Zhao, S. Shan, X. Chai, and X. Chen.

Locality-
constrained active appearance model. In ACCV, pages 636–
647. 2013.

[44] S. Zhu, C. Li, C. C. Loy, and X. Tang. Face alignment by
coarse-to-ﬁne shape searching. In CVPR, pages 4998–5006,
2015.

[45] X. Zhu and D. Ramanan. Face detection, pose estimation,
and landmark localization in the wild. In CVPR, pages 2879–
2886, 2012.

10

Supplementary Information for
Recombinator Networks: Learning Coarse-to-Fine Feature Aggregation

a

b

c

d

e

f

Figure S1. Sub-ﬁgures a, b, c, d show pre-sum (left) and softmax (right) of the coarsest to ﬁnest branches in a 4-branch SumNet model.
The softmax used in these branches are only for illustration purposes and is not part of the trained model. Sub-ﬁgure e (left) shows the sum
of branches in the SumNet model and Sub-ﬁgure f (left) depicts the pre-softmax values in RCN. The true keypoint locations are shown by
green cross in all ﬁgures to show their relative correspondence with the branch activations. SumNet and RCN’s predictions are shown by
red plus on the post-softmax maps in Sub-ﬁgures e (right) and f (right), respectively. In each row the images correspond to the keypoints
in this order from left to right: left-eye, right-eye, nose, left-mouth, right-mouth. Best viewed electronically with zoom.

1

Figure S2. The performance of SumNet and RCN models with and without occlusion pre-processing on the merged AFW and AFLW test
sets as the difﬁculty of the examples increase (lower is better). To get this plot, we note for each test set image (including both AFLW and
AFW) the average error over the four models and use this as a notion of that image’s difﬁculty. We then sort all images by difﬁculty and
get each model’s log error (using Eq. 4) on each test example. Finally, we plot each model’s performance on the sorted test set examples
from the easiest (0% difﬁculty) to the most difﬁcult (100% difﬁculty) percentage of the test set examples. The plot shows RCN performs
better than SumNet, especially on the harder examples. The occlusion pre-processing helps RCN on most difﬁcult examples (difﬁculty >
65%), while it slightly helps SumNet.

2

Recombinator Networks: Learning Coarse-to-Fine Feature Aggregation

Sina Honari1, Jason Yosinski2, Pascal Vincent1,4, Christopher Pal3
1University of Montreal, 2Cornell University, 3Ecole Polytechnique of Montreal, 4CIFAR
1{honaris, vincentp}@iro.umontreal.ca, 2yosinski@cs.cornell.edu, 3christopher.pal@polymtl.ca

6
1
0
2
 
r
p
A
 
7
1
 
 
]

V
C
.
s
c
[
 
 
2
v
6
5
3
7
0
.
1
1
5
1
:
v
i
X
r
a

Abstract

Deep neural networks with alternating convolutional,
max-pooling and decimation layers are widely used in state
of the art architectures for computer vision. Max-pooling
purposefully discards precise spatial information in order
to create features that are more robust, and typically orga-
nized as lower resolution spatial feature maps. On some
tasks, such as whole-image classiﬁcation, max-pooling de-
rived features are well suited; however, for tasks requiring
precise localization, such as pixel level prediction and seg-
mentation, max-pooling destroys exactly the information re-
quired to perform well. Precise localization may be pre-
served by shallow convnets without pooling but at the ex-
pense of robustness. Can we have our max-pooled multi-
layered cake and eat it too? Several papers have proposed
summation and concatenation based methods for combin-
ing upsampled coarse, abstract features with ﬁner features
to produce robust pixel level predictions. Here we intro-
duce another model — dubbed Recombinator Networks —
where coarse features inform ﬁner features early in their
formation such that ﬁner features can make use of several
layers of computation in deciding how to use coarse fea-
tures. The model is trained once, end-to-end and performs
better than summation-based architectures, reducing the er-
ror from the previous state of the art on two facial keypoint
datasets, AFW and AFLW, by 30% and beating the current
state-of-the-art on 300W without using extra data. We im-
prove performance even further by adding a denoising pre-
diction model based on a novel convnet formulation.

1. Introduction

Recent progress in computer vision has been driven by
the use of large convolutional neural networks. Such net-
works beneﬁt from alternating convolution and pooling lay-
ers [16, 23, 22, 29, 24, 27, 42] where the pooling layers
serve to summarize small regions of the layer below. The
operations of convolution, followed by max-pooling, then
decimation cause features in subsequent layers of the net-
work to be increasingly translation invariant, more robust,
and to more coarsely summarize progressively larger re-

gions of the input image. As a result, features in the fourth
or ﬁfth convolutional layer serve as more robust detectors
of more global, but spatially imprecise high level patterns
like text or human faces [37]. In practice these properties
are critical for many visual tasks, and they have been par-
ticularly successful at enabling whole image classiﬁcation
[16, 29, 24]. However, for other types of vision tasks these
architectural elements are not as well suited. For example
on tasks requiring pixel-precise localization or labeling, fea-
tures arising from max-pooling and decimation operations
can only provide approximate localization, as in the pro-
cess of creating them, the network has already thrown out
precise spatial information by design. If we wish to gener-
ate features that preserve accurate localization, we may do
so using shallow networks without max-pooling, but shal-
low networks without pooling cannot learn robust, invariant
features. What we would like is to have our cake and eat
it too: to combine the best of both worlds, merging ﬁnely-
localized information from shallow, non-pooled networks
with robust, coarsely-localized features computed by deep,
pooled networks.

Several recently proposed approaches [17, 13, 31] ad-
dress this by adding or concatenating the features obtained
across multiple levels. We use this approach in our base-
line model termed SumNet for our task of interest: facial
keypoint localization. To the best of our knowledge this
is the ﬁrst time this general approach has been applied to
the problem of facial keypoint localization and even our
baseline is capable of yielding state of the art results. A
possible weakness of these approaches however is that all
detection paths, from coarsely to ﬁnely localized features,
only become aggregated at the very end of the feature pro-
cessing pipeline. As a thought experiment to illustrate this
approach’s weakness, imagine that we have a photo of a
boat ﬂoating in the ocean and would like to train a con-
vnet to predict with single pixel accuracy a keypoint cor-
responding to the tip of the boat’s bow. Coarsely local-
ized features1 could highlight the rough region of the bow
of the boat, and ﬁnely localized features could be tuned to

1From now on we use the shorthand ﬁne/coarse features to mean

ﬁnely/coarsely localized features.

1

Figure 1. (Left) Architecture of summation based coarse-ﬁne network (SumNet). C is a convolutional layer. P,C represents a pooling
layer followed by a convolutional layer. All convolutions are 3 × 3 and all poolings are 2 × 2. All convolutional layers are followed
by ReLU non-linearity except the last convolutional layer in each branch. U represents an upsampling layer. Each branch’s output is 5
feature maps of size 80 × 80. FCN/Hypercolumn models use this architecture. (Right) Architecture of the Recombinator Networks (RCN).
All convolutions are 3 × 3 and all poolings are 2 × 2. All upsamplings are by a factor of 2. K represents concatenation of two sets of
feature maps along the feature map dimension. All convolutional layers are followed by ReLU non-linearity except the one right before the
softmax. In the Recombinator Networks model with skip connections (not shown), each branch takes upsampled features not only from
one coarser branch, but from all coarser branches.

ﬁnd generic boat edges, but the ﬁne features must remain
generic, being forced to learn boat edge detectors for all
possible ocean and boat color combinations. This would be
difﬁcult, because boat and ocean pixels could take similar
colors and textures. Instead, we would like a way for the
coarse features which contain information about the global
scene structure (perhaps that the water is dark blue and the
boat is bright blue) to provide information to the ﬁne feature
detectors earlier in their processing pipeline. Without such
information, the ﬁne feature detectors would be unable to
tell which half of a light blue/dark blue edge was ocean and
which was boat. In the Recombinator Networks proposed
in this paper, the ﬁnely localized features are conditioned
on higher level more coarsely localized information. It re-
sults in a model which is deeper but – interestingly – trains
faster than the summation baseline and yields more precise
localization predictions. In summary, this work makes the
following contributions:

1. We propose a novel architecture — the Recombinator
Networks — for combining information over different
spatial localization resolutions (Section 3).

2. We show how a simple denoising model may be used

to enhance model predictions (Section 4).

3. We provide an in-depth empirical evaluation of a wide
variety of relevant architectural variants (Section 5.1).
4. We show state of the art performance on two widely
used and competitive evaluations for facial keypoint
localization (Section 5.2).

2. Related work

Keypoint localization methods: Our task of interest
is the well studied problem of facial keypoint localization
[44, 42, 38, 2, 33, 40, 6, 35, 7, 18, 45] illustrated in Fig-
ure 1. Precise facial keypoint localization is often an es-
sential preprocessing step for face recognition [1] and de-

tection [45]. Recent face veriﬁcation models like DeepFace
[30] and DeepID2 [27] also include keypoint localization
as the ﬁrst step. There have been many other approaches to
general keypoint localization, including active appearance
models [8, 43], constrained local models [10, 21, 11, 2], ac-
tive shape models [12], point distribution models [9], struc-
tured model prediction [3, 31], tree structured face mod-
els [45], group sparse learning based methods [39], shape
regularization models that combines multiple datasets [25],
feature voting based landmark localization [26, 36] and
convolutional neural networks based models [41, 28, 42].
Two other related models are [31], where a multi-resolution
model is proposed with dual coarse/ﬁne paths and tied ﬁl-
ters, and [28], which uses a cascaded architecture to reﬁne
predictions over several stages. Both of these latter mod-
els make hard decisions using coarse information halfway
through the model.

Approaches that combine features across multiple
levels: Several recent models — including the fully convo-
lutional networks (FCNs) in [17], the Hypercolumn model
[13], and the localization model of Tompson et al. [31] —
generate features or predictions at multiple resolutions, up-
sample the coarse features to the ﬁne resolution, and then
add or concatenate the features or predictions together. This
approach has generally worked well, improving on previ-
ous state of the art results in detection, segmentation, and
human-body pose estimation [13, 17, 31]. In this paper we
create a baseline model similar to these approaches that we
refer to as SumNet in which we use a network that aggre-
gates information from features across different levels in the
hierarchy of a conv-pool-decimate network using concate-
nation followed by a weighted sum over feature maps prior
to ﬁnal layer softmax predictions. Our goal in this paper is
to improve upon this architecture. Differences between the
Recombinator Networks and related architectures are sum-

2

marized in Table 5. U-Net [19] is another model that merges
features across multiple levels and has a very similar archi-
tecture to Recombinator Networks. The two models have
been developed independently and were designed for differ-
ent problems2. Note that none of these models use a learned
denoising post-processing as we do (see section 4).

3. Summation versus Recombinator Networks

In this section we describe our baseline SumNet model
based on a common architectural design where information
from different levels of granularity are merged just prior to
predictions being made. We contrast this with the Recom-
binator Networks architecture.

3.1. Summation based Networks

The SumNet architecture, shown in Figure 1(left), adds
to the usual bottom to top convolution and spatial pool-
ing, or “trunk”, a horizontal left-to-right “branch” at each
resolution level. While spatial pooling progressively re-
duces the resolution as we move “up” the network along
the trunk, the horizontal branches only contains full con-
volutions and element-wise non-linearities, with no spatial
pooling, so that they can preserve the spatial resolution at
that level while doing further processing. The output of
the ﬁnest resolution branch only goes through convolutional
layers. The ﬁnest resolution layers keep positional informa-
tion and use it to guide the coarser layers within the patch
that they cannot have any preference, while the coarser res-
olution layers help ﬁner layers to get rid of false positives.
The architecture then combines the rightmost low resolution
output of all horizontal branches, into a single high resolu-
tion prediction, by ﬁrst up-sampling3 them all to the model’s
input image resolution (80 × 80 for our experiments) and
then taking a weighted sum to yield the pre-softmax val-
ues. Finally, a softmax function is applied to yield the ﬁ-
nal location probability map for each keypoint. Formally,
given an input image x, deﬁne the trunk of the network as
a sequence of blocks of traditional groups of convolution,
pooling and decimation operations. Starting from the layer
yielding the coarsest scale feature maps we call the outputs
of R such blocks T (1), . . . , T (R). At each level r of the
trunk we have a horizontal branch that takes T (r) as its in-
put and consists of a sequence of convolutional layers with
no subsampling. The output of such a branch is a stack of
K feature maps, one for each of the K target keypoints, at
the same resolution as its input T (r), and we denote this
output as branch(T (r)).
It is then upsampled up[×F ] by
some factor F which returns the feature map to the original
resolution of the input image. Let these upsampled maps
be M (1)
is the score map given by

K where M (r)

1 , . . . , M (R)

k

2For keypoint localization, we apply the softmax spatially i.e. across
possible spatial locations, whereas for segmentation [13, 17, 19] it is ap-
plied across all possible classes for each pixel.

3Upsampling can be performed either by tiling values or by using bilin-
ear interpolation. We found bilinear interpolation degraded performance in
some cases, so we instead used the simpler tiling approach.

k

the rth branch to the kth keypoint (left eye, right eye, . . .).
Each such map M (r)
is a matrix of the same resolution as
the image fed as input (i.e. 80 × 80). The score ascribed
by branch r for keypoint k being at coordinate i, j is given
by M (r)
k,i,j. The ﬁnal probability map for the location Yk of
keypoint k is given by a softmax over all possible locations.
We can therefore write the model as

M (1) = up[×2R−1](branch(T (1)))
M (2) = up[×2R−2](branch(T (2)))
. . .
M (R) = branch(T (R))

P (Yk|X = x) = softmax

(cid:16) R
(cid:88)

r=1

αrkM (r)

k

(cid:17)

,

(1)

where αrk is a 2D matrix that gives a weight to every
pixel location i, j of keypoint k in branch r. The weighted
sum of features over all branches taken here is equivalent to
concatenating the features of all branches and multiplying
them in a set of weights, which results in one feature map
per keypoint. This architecture is trained globally using
gradient backpropagation to minimize the sum of negated
conditional log probabilities of all N training (input-image,
keypoint-locations) pairs, for all K keypoints (x(n), y(n)
k ),
with an additional regularization term for the weights ; i.e.
we search for network parameters W that minimize 4

L(W) =

− log P (Yk = y(n)

k |X = x(n)) + λ(cid:107)W(cid:107)2.

1
N

N
(cid:88)

K
(cid:88)

n=1

k=1

(2)

3.2. The Recombinator Networks

In the SumNet model, different branches can only com-
municate through the updates received from the output layer
and the features are merged linearly through summation. In
the Recombinator Networks (RCN) architecture, as shown
in Figure 1(right), instead of taking a weighted sum of the
upsampled feature maps in each branch and then passing
them to a softmax, the output of each branch is upsampled,
then concatenated with the next level branch with one de-
gree of ﬁner resolution. In contrast to the SumNet model,
each branch does not end in K feature maps. The infor-
mation stays in the form of a keypoint independent feature
map. It is only at the end of the Rth branch that feature
maps are converted into a per-keypoint scoring represen-
tation that has the same resolution as the input image, on
which a softmax is then applied. As a result of RCN’s dif-
ferent architecture, branches pass more information to each
other during training, such that convolutional layers in the
ﬁner branches get inputs from both coarse and ﬁne layers,
letting the network learn how to combine them non-linearly
to maximize the log likelihood of the keypoints given the

4 We also tried L2 distance cost between true and estimated keypoints
(as a regression problem) and got worse results. This may be due to the
fact that a softmax probability map can be multimodal , while L2 distance
implicitly corresponds to likelihood of a unimodal isotropic Gaussian.

3

input images. The whole network is trained end-to-end
by backprop. Following the previous conventions and by
deﬁning the concatenation operator on feature maps A, B
as concat(A, B), we can write the model as

M (cid:48)(1) = up[×2](branch(T (1)))
M (cid:48)(2) = up[×2](branch(concat(T (2), M (cid:48)(1))))
. . .
M (cid:48)(R) = branch(concat(T (R), M (cid:48)(R−1)))
P (Yk|X = x) = softmax(M (cid:48)(R)

).

k

(3)

skip

also
the

each branch are

explore RCN with
features of

connections,
We
concate-
where
nated with upsampled features of not only one-level
coarser branch,
coarser branches
the last branch computes M (cid:48)(R) =
and,
therefore,
branch(concat(T (R), M (cid:48)(R−1), M (cid:48)(R−2), . . . , M (cid:48)(1)).
In
practice, the information ﬂow between different branches
makes RCN converge faster and also perform better
compared to the SumNet model.

all previous

but

4. Denoising keypoint model

Convolutional networks are excellent edge detectors. If
there are few samples with occlusion in the training sets,
convnets have problem detecting occluded keypoints and
instead select nearby edges (see some samples in Figures
3, 5). Moreover, the convnet predictions, especially on
datasets with many keypoints, do not always correspond to
a plausible keypoint distribution and some keypoints jump
off the curve (e.g. on the face contour or eye-brows) irre-
spective of other keypoints’ position (see some samples in
Figure 7). This type of error can be addressed by using a
structured output predictor on top of the convnet, that takes
into account how likely the location of a keypoint is rel-
ative to other keypoints. Our approach is to train another
convolutional network that captures useful aspects of the
prior keypoint distribution (not conditioned on the image).
We train it to predict the position of a random subsets of
keypoints, given the position of the other keypoints. More
speciﬁcally, we train the convolutional network as a denois-
ing model, similar to the denoising auto-encoder [34] by
completely corrupting the location of a randomly chosen
subset of the keypoints and learning to accurately predict
their correct location given that of the other keypoints. This
network receives as input, not the image, but only keypoint
locations represented as one-hot 2D maps (one 2D map per
keypoint, with a 1 at the position of the keypoint and ze-
ros elsewhere). It is composed of convolutional layers with
large receptive ﬁelds (to get to see nearby keypoints), ReLU
nonlinearities and no subsampling (see Figure 2). The net-
work outputs probability maps for the location of all key-
points, however, its training criterion uses only prediction

errors of the corrupted ones. The cost being optimized sim-
ilar to Eq.(2) but includes only the corrupted keypoints.

Once, this denoising model is trained, the output of RCN
(the predicted most likely location in one-hot binary loca-
tion 2D map format) is fed to the denoising model. We
then simply sum the pre-softmax values of both RCN and
denoising models and pass them through a softmax to gen-
erate the ﬁnal output probability maps. The joint model is
depicted in Figure 2. The joint model combines the RCN’s
predicted conditional distribution for keypoint k given the
image P (Yk|X = x) with the denoising model’s distri-
bution of the location of that keypoint given other key-
points P (Yk|Y¬k), to yield an estimation of keypoint k’s
location given both image and other keypoint locations
P (Yk|Y¬k, X = x). The choice of convolutional networks
for the denoising model allows it to be easily combined with
RCN in a uniﬁed deep convolutional architecture.

5. Experimental setup and results

We evaluate our model5 on the following datasets with

evaluation protocols deﬁned by previous literature:

AFLW and AFW datasets: Similar to TCDCN [41], we
trained our models on the MTFL dataset,6 which we split
into 9,000 images for training and 1,000 for validation. We
evaluate our models on the same subsets of AFLW [15] and
AFW [45] used by [41], consisting of 2995 and 377 images,
respectively, each labeled with 5 facial keypoints.

300W dataset:

300W [20] standardizes multiple
datasets into one common dataset with 68 keypoints. The
training set is composed of 3148 images (337 AFW, 2000
Helen, and 811 LFPW). The test set is composed of 689
images (135 IBUG, 224 LFPW, and 330 Helen). The IBUG
is referred to as the challenging subset, and the union of
LFPW and Helen test sets is referred to as the common sub-
set. We shufﬂe the training set and split it into 90% train-set
(2834 images) and 10% valid-set (314 images).

One challenging issue in these datasets is that the test set
examples are signiﬁcantly different and more difﬁcult com-
pared to the training sets. In other words the train and test
set images are not from the same distribution. In particular,
the AFLW and AFW test sets contain many samples with
occlusion and more extreme rotation and expression cases
than the training set. The IBUG subset of 300W contains
more extreme pose and expressions than other subsets.

Error Metric: The euclidean distance between the true
and estimated landmark positions normalized by the dis-

5Our

code
https://github.com/SinaHonari/RCN

models

and

[14] and 5849 images from the web.

6MTFL consists of 10,000 training images: 4151 images from LFW

are

publicly

available

at

4

tance between the eyes (interocular distance) is used:

(cid:113)

N
(cid:88)

K
(cid:88)

(w(n)

k − ˜w(n)

error =

1
KN

n=1

k=1

k )2 + (h(n)
D(n)

k − ˜h(n)

k )2

,

(4)

where K is the number of keypoints, N is the total num-
ber of images, D(n) is the interocular distance in image n.
(w(n)
k ) represent the true and esti-
mated coordinates for keypoint k in image n, respectively.

k ) and ( ˜w(n)

k , h(n)

k , ˜h(n)

5.1. Evaluation on SumNet and RCN

We evaluate RCN on the 5-keypoint test sets. To avoid
overﬁtting and improve performance, we applied online
data augmentation to the 9,000 MTFL train set using ran-
dom scale, rotation, and translation jittering7. We prepro-
cessed images by making them gray-scale and applying lo-
cal contrast normalization 8. In Figure S1, we show a visu-
alization of the contribution of each branch of the SumNet
to the ﬁnal predictions: the coarsest layer provides robust
but blurry keypoint locations, while the ﬁnest layer gives
detailed face information but suffers from many false pos-
itives. However, the sum of branches in SumNet and the
ﬁnest branch in RCN make precise predictions.

Since the test sets contain more extreme occlusion and
lighting conditions compared to the train set, we applied a
preprocessing to the train set to bring it closer to the test set
distribution. In addition to the jittering, we found it helpful
to occlude images in the training set with randomly placed
black rectangles9 at each training iteration. This trick forced
the convnet models to use more global facial components to
localize the keypoints and not rely as much on the features
around the keypoints, which in turn, made it more robust
against occlusion and lighting contrast in the test set. Figure
3 shows the effects of this occlusion when used to train the
SumNet and RCN models on randomly drawn samples. The
samples show for most of the test set examples the models
do a good prediction. Figure 4 shows some hand-picked
examples from the test sets, to show extreme expression,
occlusion and contrast that are not captured in the random
samples of Figure 3. Figure 5 similarly uses some manually
selected examples to show the beneﬁts of using occlusion.
To evaluate how much each branch contributes to the
overall performance of the model, we trained models ex-
cluding some branches and report the results in Table 1. The
ﬁnest layer on its own does a poor job due to many false
positives, while the coarsest layer on its own does a reason-
able job, but still lacks high accuracy. One notable result

7We jittered data separately in each epoch, whose parameters were uni-
formly sampled in the following ranges (selected based on the validation
set performance): Translation and Scaling: [-10%, +10%] of face bound-
ing box size; Rotation: [-40, +40] degrees.

8RGB images performed worse in our experiments.
9Each image was occluded with one black (zeros) rectangle, whose size
was drawn uniformly in the range [20, 50] pixels. It’s location was drawn
uniformly over the entire image.

is that using only the coarsest and ﬁnest branches together
produces reasonable performance. However, the best per-
formance is achieved by using all branches, merging four
resolutions of coarse, medium, and ﬁne information. We

Mask
1, 0, 0, 0
0, 1, 0, 0
1, 1, 0, 0
0, 0, 1, 0
0, 0, 0, 1
0, 0, 1, 1
0, 1, 1, 1
1, 0, 0, 1
1, 1, 1, 1

SumNet

RCN

AFLW AFW AFLW AFW
10.89
10.54
11.87
11.28
9.44
9.47
15.91
16.14
48.61
45.39
13.53
13.90
7.95
7.91
7.27
6.91
6.43
6.44

10.63
11.43
9.65
16.35
47.97
14.14
8.22
7.51
6.78

10.61
11.56
9.31
15.78
46.87
12.67
7.62
6.79
6.37

Table 1. The performance of SumNet and RCN trained with masks
applied to different branches. A mask value of 1 indicates the
branch is included in the model and 0 indicates it is omitted (as a
percent; lower is better). In SumNet model mask 0 indicates no
contribution from that branch to the summation of all branches,
while in RCN, if a branch is omitted, the previous coarse branch
is upsampled to the following ﬁne branch. The mask numbers are
ordered from the coarsest branch to the ﬁnest branch.

also experimented with adding extra branches, getting to a
coarser resolution of 5 × 5 in the 5 branch model, 2 × 2
in the 6 branch model and 1 × 1 in the 7 branch model. In
each branch, the same number of convolutional layers with
the same kernel size is applied,10 and all new layers have
48 channels. The best performing model, as shown in Table
2, is RCN with 6 branches. Comparing RCN and SumNet
training, RCN converges faster. Using early stopping and
without occlusion pre-processing, RCN requires on average
200 epochs to converge (about 4 hours on a NVidia Tesla
K20 GPU), while SumNet needs on average more than 800
epochs (almost 14 hours). RCN’s error on both test sets
drops below 7% on average after only 15 epochs (about 20
minutes), while SumNet needs on average 110 epochs (al-
most 2 hours) to get to this error. Using occlusion prepro-
cessing increases these times slightly but results in lower
test error. At test time, a feedforward pass on a K20 GPU
takes 2.2ms for SumNet and 2.5ms for RCN per image in
Theano [4]. Table 2 shows occlusion pre-processing sig-
niﬁcantly helps boost the accuracy of RCN, while slightly
helping SumNet. We believe this is due to global informa-
tion ﬂow from coarser to ﬁner branches in RCN.

5.2. Comparison with other models

AFLW and AFW datasets: We ﬁrst re-implemented the
TCDCN model [41], which is the current state of the art

10A single exception is that when the 5 × 5 resolution map is reduced
to 2 × 2, we apply 3 × 3 pooling with stride 2 instead of the usual 2 × 2
pooling, to keep the resulting map left-right symmetric.

11SumNet and RCN models are trained using occlusion preprocessing.

5

Table 3. Facial landmark mean error normalized by interocular dis-
tance on AFW and AFLW sets (as a percent; lower is better).11

6. Conclusion

Model
SumNet (4 branch)
SumNet (5 branch)
SumNet (6 branch)
SumNet (5 branch - occlusion)
SumNet (6 branch - occlusion)
RCN (4 branch)
RCN (5 branch)
RCN (6 branch)
RCN (7 branch)
RCN (5 branch - occlusion)
RCN (6 branch - occlusion)
RCN (7 branch - occlusion)
RCN (6 branch - occlusion - skip)

AFLW AFW
6.78
6.53
6.48
6.34
6.33
6.43
6.05
5.98
6.12
5.44
5.36
5.55
5.56

6.44
6.42
6.34
6.29
6.27
6.37
6.11
6.00
6.17
5.65
5.60
5.76
5.63

Table 2. SumNet and RCN performance with different number of
branches, occlusion preprocessing and skip connections.

Model
TSPM [45]
CDM [38]
ESR [6]
RCPR [5]
SDM [35]
TCDCN [41]
TCDCN baseline (our implementation)
SumNet (FCN/HC) baseline (this)
RCN (this)

AFLW AFW
14.3
11.1
10.4
9.3
8.8
8.2
7.87
6.33
5.36

15.9
13.1
12.4
11.6
8.5
8.0
7.60
6.27
5.60

model on 5 keypoint AFLW [15] and AFW [45] sets, and
applied the same pre-processing as our other experiments.
Through hyper-parameter search, we even improved upon
the AFLW and AFW results reported in [41]. Table 3 com-
pares RCN with other models. Especially, it improves the
SumNet baseline, which is equivalent to FCN and Hyper-
column models, and it also converges faster. The SumNet
baseline is also provided by this paper and to the best of our
knowledge this is the ﬁrst application of any such coarse-to-
ﬁne convolutional architecture to the facial keypoint prob-
lem. Figure 6 compares TCDCN with SumNet and RCN
models, on some difﬁcult samples reported in [41].

300W dataset [20]: The RCN model that achieved the
best result on the validation set, contains 5 branches with 64
channels for all layers (higher capacity is needed to extract
features for more keypoints) and 2 extra convolutional lay-
ers with 1 × 1 kernel size in the ﬁnest branch right before
applying the softmax. Table 4 compares different models on
all keypoints (68) and a subset of keypoints (49) reported in
[32]. The denoising model is trained by randomly choos-
ing 35 keypoints in each image and jittering them (chang-
ing their location uniformly to any place in the 2D map).
It improves the RCN’s prediction by considering how loca-
tions of different keypoints are inter-dependent. Figure 7
compares the output of RCN, the denoising model and the
joint model, showing how the keypoint distribution model-
ing can reduce the error. We only trained RCN on the 2834

#keypoints Common

49

68

Model
PO-CR [32]
RCN (this)
RCN + denoising
keypoint model (this)
CDM [38]
DRMF [2]
RCPR [5]
GN-DPM [33]
CFAN [40]
ESR [6]
SDM [35]
ERT [7]
LBF [18]
CFSS[44]
TCDCN † [42]
RCN (this)
RCN + denoising
keypoint model (this)

4.00
2.64

2.59
10.10
6.65
6.18
5.78
5.50
5.28
5.57
-
4.95
4.73
4.80
4.70

IBUG Fullset
4.56
6.82
3.88
5.10

4.81
19.54
19.79
17.26
-
16.78
17.00
15.40
-
11.98
9.98
8.60
9.00

3.76
11.94
9.22
8.35
-
7.69
7.58
7.50
6.40
6.32
5.76
5.54
5.54

Table 4. Facial landmark mean error normalized by interocular dis-
tance on 300W test sets (as a percent; lower is better). 11

4.67

8.44

5.41

images in the train-set. No extra data is taken to pre-train or
ﬁne-tune the model 12. The current state-of-the-art model
without any extra data† is CFSS[44]. We reduce the error
by 15% on the IBUG subset compared to CFSS.

The model

In this paper we have introduced the Recombinator Net-
works architecture for combining coarse maps of pooled
features with ﬁne non-pooled features in convolutional
neural networks.
improves upon previous
summation-based approaches by feeding coarser branches
into ﬁner branches, allowing the ﬁner resolutions to learn
upon the features extracted by coarser branches. We ﬁnd
that this new architecture leads to both reduced training time
and increased facial keypoint prediction accuracy. We have
also proposed a denoising model for keypoints which in-
volves explicit modeling of valid spatial conﬁgurations of
keypoints. This allows our complete approach to deal with
more complex cases such as those with occlusions.

Acknowledgments

We would like to thank the Theano developers, particularly
F. Bastien and P. Lamblin, for their help throughout this
project. We appreciate Y. Bengio and H. Larochelle feed-
backs and also L. Yao, F. Ahmed and M. Pezeshki’s helps
in this project. We also thank Compute Canada, and Cal-
cul Quebec for providing computational resources. Finally,
we would like to thank Fonds de Recherche du Qu´ebec –
Nature et Technologies (FRQNT) for a doctoral research
scholarship (B2) grant during 2014 and 2015 (SH) and the
NASA Space Technology Research Fellowship (JY).

12We only jittered the train-set images by random scaling, translation

and rotation similar to the 5 keypoint dataset.

† TCDCN [42] uses 20,000 extra dataset for pre-training.

6

(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)

Features

Models

Efﬁcient
Localization [31]

Deep
Cascade [28]

Hyper-
columns [13]

Coarse features: hard crop or soft combination?
Learned coarse features fed into ﬁner branches?

Hard
No

Hard
No

Soft
No

Table 5. Comparison of multi-resolution architectures. The Efﬁcient Localization and Deep Cascade models use coarse features to crop
images (or ﬁne layer features), which are then fed into ﬁne models. This process saves computation when dealing with high-resolution
images but at the expense of making a greedy decision halfway through the model. Soft models merge local and global features of the entire
image and do not require a greedy decision. The Hypercolumn and FCN models propagate all coarse information to the ﬁnal layer but
merge information via addition instead of conditioning ﬁne features on coarse features. The Recombinator Networks (RCN), in contrast,
injects coarse features directly into ﬁner branches, allowing the ﬁne computation to be tuned by (conditioned on) the coarse information.
The model is trained end-to-end and results in learned coarse features which are tuned directly to support the eventual ﬁne predictions.

FCN
[17]

Soft
No

RCN
(this)

Soft
Yes

Figure 2. Denoising / joint keypoint model. The Recombinator Networks (RCN) and the keypoint location denoising models are trained
separately. At test time, the keypoint hard prediction of RCN is ﬁrst injected into the denoising model as one-hot maps. Then the pre-
softmax values computed by the RCN and the denoising models are summed and pass through a ﬁnal softmax to predict keypoint locations.

Figure 3. Keypoint predictions on random test set images from easy (left) to hard (right). Each column shows predictions of following
models from top to bottom: SumNet, SumNet with occlusion, RCN, RCN with occlusion (all models have 5 branches). We note for each
test set image (including both AFLW and AFW) the average error over the four models and use this as a notion of that image’s difﬁculty.
We then sort all images by difﬁculty and draw a random image from percentile bins, using the bin boundaries noted above the images.
To showcase the models’ differing performance, we show only a few easier images on the left side and focus more on the hardest couple
percent of images toward the right side. The value on the left is the average error of these samples per model (much higher than the results
reported in Table 3 because of the skew toward difﬁcult images). The yellow line connects the true keypoint location (green) to the model’s
prediction (red). Dots are small to avoid covering large regions of the image. Best viewed with zoom in color. Figure S2 shows the
performance of these four models as the difﬁculty of the examples increase.

7

Figure 4. Samples with different expressions (green border), contrast and illuminations (red border) and occlusions (blue border) from
AFLW and AFW sets. In each box, top row depicts samples from SumNet and bottom row shows samples from RCN, both with occlusion
pre-processing.

Figure 5. Samples from AFLW and AFW test sets showing keypoint detection accuracy without (top row) and with (bottom row) occlusion
pre-processing using RCN.

Figure 6. Samples from TCDCN [41] (yellow border with green predicted points) versus SumNet (orange border) and RCN (blue border).
In the latter two models, red and green dots show predicted and true keypoints. TCDCN samples are taken directly from [41].

Figure 7. Samples from 300W test sets. Each column shows samples in this order (top to bottom): RCN, keypoint denoising model and
the joint model. The ﬁrst two columns show extreme expression and occlusion samples where RCN’s prediction is highly accurate. The
next 5 columns show samples where the denoising model improves the RCN’s predictions. In the 8th column the structured model ﬁnd
a reasonable keypoint distribution but deteriorates the RCN’s predictions. Finally, the last two columns show cases where the denoising
model generates plausible keypoint distributions but far from the true keypoints.

8

References

[1] A. Asthana, T. Marks, M. Jones, K. Tieu, and M. Rohith.
Fully automatic pose-invariant face recognition via 3d pose
normalization. In ICCV, pages 937–944, 2011.

[2] A. Asthana, S. Zafeiriou, S. Cheng, and M. Pantic. Robust
discriminative response map ﬁtting with constrained local
models. In CVPR, pages 3444–3451, 2013.

[3] T. Baltruˇsaitis, P. Robinson, and L.-P. Morency. Continuous
conditional neural ﬁelds for structured regression. In ECCV,
pages 593–608. 2014.

[4] F. Bastien, P. Lamblin, R. Pascanu, J. Bergstra, I. Good-
fellow, A. Bergeron, N. Bouchard, D. Warde-Farley, and
Y. Bengio. Theano: new features and speed improvements.
In NIPS Workshop on Deep Learning, 2012.

[5] X. Burgos-Artizzu, P. Perona, and P. Doll´ar. Robust face
landmark estimation under occlusion. In ICCV, pages 1513–
1520, 2013.

[6] X. Cao, Y. Wei, F. Wen, and J. Sun. Face alignment by ex-
plicit shape regression. In ICCV, 107(2):177–190, 2014.
[7] X. Cao, Y. Wei, F. Wen, and J. Sun. Face alignment by ex-
plicit shape regression. In IJCV, 107(2):177–190, 2014.
[8] T. Cootes, G. Edwards, and C. Taylor. Active appearance

models. In PAMI, 23(6):681–685, 2001.

[9] T. Cootes, C. Taylor, D. Cooper, and J. Graham. Active shape
models-their training and application. In CVIU, 61(1):38–59,
1995.

[10] D. Cristinacce and T. Cootes. Feature detection and tracking
with constrained local models. In BMVC, volume 2, page 6,
2006.

[11] D. Cristinacce and T. Cootes. Automatic feature localisa-
tion with constrained local models. Pattern Recognition,
41(10):3054–3067, 2008.

[12] D. Cristinacce and T. F. Cootes. Boosted regression active

shape models. In BMVC, pages 1–10, 2007.

[13] B. Hariharan, P. Arbel´aez, R. Girshick, and J. Malik. Hyper-
columns for object segmentation and ﬁne-grained localiza-
tion. In CVPR, 2015.

[14] G. Huang, M. Ramesh, T. Berg, and E. Learned-Miller. La-
beled faces in the wild: A database for studying face recogni-
tion in unconstrained environments. Technical report, 07-49,
University of Massachusetts, Amherst, 2007.

[15] M. Kostinger, P. Wohlhart, P. Roth, and H. Bischof. Anno-
tated facial landmarks in the wild: A large-scale, real-world
In ICCV Work-
database for facial landmark localization.
shop, pages 2144–2151, 2011.

[16] A. Krizhevsky, I. Sutskever, and G. E. Hinton.

classiﬁcation with deep convolutional neural networks.
NIPS, pages 1106–1114, 2012.

Imagenet
In

[17] J. Long, E. Shelhamer, and T. Darrell. Fully convolutional
networks for semantic segmentation. In CVPR, 2015.
[18] S. Ren, X. Cao, Y. Wei, and J. Sun. Face alignment at 3000
In CVPR, pages

fps via regressing local binary features.
1685–1692, 2014.

[19] O. Ronneberger, P. Fischer, and T. Brox. U-net: Convolu-
tional networks for biomedical image segmentation. In Med-
ical Image Computing and Computer-Assisted Intervention–
MICCAI 2015, pages 234–241. Springer, 2015.

[20] C. Sagonas, G. Tzimiropoulos, S. Zafeiriou, and M. Pantic.
300 faces in-the-wild challenge: The ﬁrst facial landmark
localization challenge. In ICCV Workshop, pages 397–403,
2013.

[21] J. M. Saragih, S. Lucey, and J. F. Cohn. Face alignment
through subspace constrained mean-shifts. In ICCV, pages
1034–1041, 2009.

[22] P. Sermanet, K. Kavukcuoglu, S. Chintala, and Y. LeCun.
Pedestrian detection with unsupervised multi-stage feature
learning. In CVPR, pages 3626–3633, 2013.

[23] P. Sermanet and Y. LeCun. Trafﬁc sign recognition with
multi-scale convolutional networks. In IJCNN, pages 2809–
2813, 2011.

[24] K. Simonyan and A. Zisserman. Very deep convolutional

networks for large-scale image recognition. CVPR, 2014.

[25] B. Smith and L. Zhang. Collaborative facial landmark local-
ization for transferring annotations across datasets. In ECCV,
pages 78–93. 2014.

[26] B. M. Smith, J. Brandt, Z. Lin, and L. Zhang. Nonpara-
metric context modeling of local appearance for pose-and
In CVPR,
expression-robust facial landmark localization.
pages 1741–1748, 2014.

[27] Y. Sun, Y. Chen, X. Wang, and X. Tang. Deep learning face
representation by joint identiﬁcation-veriﬁcation. In NIPS,
pages 1988–1996, 2014.

[28] Y. Sun, X. Wang, and X. Tang. Deep convolutional network
In CVPR, pages 3476–

cascade for facial point detection.
3483, 2013.

[29] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed,
D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabinovich.
Going deeper with convolutions. In CVPR, 2014.

[30] Y. Taigman, M. Yang, M. Ranzato, and L. Wolf. Deepface:
Closing the gap to human-level performance in face veriﬁca-
tion. In CVPR, pages 1701–1708, 2014.

[31] J. Tompson, R. Goroshin, A. Jain, Y. LeCun, and C. Bregler.
Efﬁcient object localization using convolutional networks. In
CVPR, 2015.

[32] G. Tzimiropoulos. Project-out cascaded regression with an
application to face alignment. In Computer Vision and Pat-
tern Recognition (CVPR), 2015 IEEE Conference on, pages
3659–3667. IEEE, 2015.

[33] G. Tzimiropoulos and M. Pantic. Gauss-newton deformable
part models for face alignment in-the-wild. In CVPR, pages
1851–1858, 2014.

[34] P. Vincent, H. Larochelle, Y. Bengio, and P.-A. Manzagol.
Extracting and composing robust features with denoising au-
toencoders. In ICML, pages 1096–1103, 2008.

[35] X. Xiong and F. De la Torre. Supervised descent method and
its applications to face alignment. In CVPR, pages 532–539,
2013.

[36] H. Yang and I. Patras. Sieving regression forest votes for

facial feature detection in the wild. In ICCV. IEEE, 2013.

[37] J. Yosinski, J. Clune, A. Nguyen, T. Fuchs, and H. Lipson.
Understanding neural networks through deep visualization.
In ICML Workshop on Deep Learning, 2015.

[38] X. Yu, J. Huang, S. Zhang, W. Yan, and D. Metaxas. Pose-
free facial landmark ﬁtting via optimized part mixtures and

9

cascaded deformable shape model.
1951, 2013.

In ICCV, pages 1944–

[39] X. Yu, J. Huang, S. Zhang, W. Yan, and D. N. Metaxas. Pose-
free facial landmark ﬁtting via optimized part mixtures and
In ICCV, pages 1944–
cascaded deformable shape model.
1951, 2013.

[40] J. Zhang, S. Shan, M. Kan, and X. Chen. Coarse-to-ﬁne
auto-encoder networks (cfan) for real-time face alignment.
In ECCV, pages 1–16. 2014.

[41] Z. Zhang, P. Luo, C. Loy, and X. Tang. Facial landmark
detection by deep multi-task learning. In ECCV, pages 94–
108. 2014.

[42] Z. Zhang, P. Luo, C. C. Loy, and X. Tang. Learning deep
representation for face alignment with auxiliary attributes.
In PAMI, 2015.

[43] X. Zhao, S. Shan, X. Chai, and X. Chen.

Locality-
constrained active appearance model. In ACCV, pages 636–
647. 2013.

[44] S. Zhu, C. Li, C. C. Loy, and X. Tang. Face alignment by
coarse-to-ﬁne shape searching. In CVPR, pages 4998–5006,
2015.

[45] X. Zhu and D. Ramanan. Face detection, pose estimation,
and landmark localization in the wild. In CVPR, pages 2879–
2886, 2012.

10

Supplementary Information for
Recombinator Networks: Learning Coarse-to-Fine Feature Aggregation

a

b

c

d

e

f

Figure S1. Sub-ﬁgures a, b, c, d show pre-sum (left) and softmax (right) of the coarsest to ﬁnest branches in a 4-branch SumNet model.
The softmax used in these branches are only for illustration purposes and is not part of the trained model. Sub-ﬁgure e (left) shows the sum
of branches in the SumNet model and Sub-ﬁgure f (left) depicts the pre-softmax values in RCN. The true keypoint locations are shown by
green cross in all ﬁgures to show their relative correspondence with the branch activations. SumNet and RCN’s predictions are shown by
red plus on the post-softmax maps in Sub-ﬁgures e (right) and f (right), respectively. In each row the images correspond to the keypoints
in this order from left to right: left-eye, right-eye, nose, left-mouth, right-mouth. Best viewed electronically with zoom.

1

Figure S2. The performance of SumNet and RCN models with and without occlusion pre-processing on the merged AFW and AFLW test
sets as the difﬁculty of the examples increase (lower is better). To get this plot, we note for each test set image (including both AFLW and
AFW) the average error over the four models and use this as a notion of that image’s difﬁculty. We then sort all images by difﬁculty and
get each model’s log error (using Eq. 4) on each test example. Finally, we plot each model’s performance on the sorted test set examples
from the easiest (0% difﬁculty) to the most difﬁcult (100% difﬁculty) percentage of the test set examples. The plot shows RCN performs
better than SumNet, especially on the harder examples. The occlusion pre-processing helps RCN on most difﬁcult examples (difﬁculty >
65%), while it slightly helps SumNet.

2

Recombinator Networks: Learning Coarse-to-Fine Feature Aggregation

Sina Honari1, Jason Yosinski2, Pascal Vincent1,4, Christopher Pal3
1University of Montreal, 2Cornell University, 3Ecole Polytechnique of Montreal, 4CIFAR
1{honaris, vincentp}@iro.umontreal.ca, 2yosinski@cs.cornell.edu, 3christopher.pal@polymtl.ca

6
1
0
2
 
r
p
A
 
7
1
 
 
]

V
C
.
s
c
[
 
 
2
v
6
5
3
7
0
.
1
1
5
1
:
v
i
X
r
a

Abstract

Deep neural networks with alternating convolutional,
max-pooling and decimation layers are widely used in state
of the art architectures for computer vision. Max-pooling
purposefully discards precise spatial information in order
to create features that are more robust, and typically orga-
nized as lower resolution spatial feature maps. On some
tasks, such as whole-image classiﬁcation, max-pooling de-
rived features are well suited; however, for tasks requiring
precise localization, such as pixel level prediction and seg-
mentation, max-pooling destroys exactly the information re-
quired to perform well. Precise localization may be pre-
served by shallow convnets without pooling but at the ex-
pense of robustness. Can we have our max-pooled multi-
layered cake and eat it too? Several papers have proposed
summation and concatenation based methods for combin-
ing upsampled coarse, abstract features with ﬁner features
to produce robust pixel level predictions. Here we intro-
duce another model — dubbed Recombinator Networks —
where coarse features inform ﬁner features early in their
formation such that ﬁner features can make use of several
layers of computation in deciding how to use coarse fea-
tures. The model is trained once, end-to-end and performs
better than summation-based architectures, reducing the er-
ror from the previous state of the art on two facial keypoint
datasets, AFW and AFLW, by 30% and beating the current
state-of-the-art on 300W without using extra data. We im-
prove performance even further by adding a denoising pre-
diction model based on a novel convnet formulation.

1. Introduction

Recent progress in computer vision has been driven by
the use of large convolutional neural networks. Such net-
works beneﬁt from alternating convolution and pooling lay-
ers [16, 23, 22, 29, 24, 27, 42] where the pooling layers
serve to summarize small regions of the layer below. The
operations of convolution, followed by max-pooling, then
decimation cause features in subsequent layers of the net-
work to be increasingly translation invariant, more robust,
and to more coarsely summarize progressively larger re-

gions of the input image. As a result, features in the fourth
or ﬁfth convolutional layer serve as more robust detectors
of more global, but spatially imprecise high level patterns
like text or human faces [37]. In practice these properties
are critical for many visual tasks, and they have been par-
ticularly successful at enabling whole image classiﬁcation
[16, 29, 24]. However, for other types of vision tasks these
architectural elements are not as well suited. For example
on tasks requiring pixel-precise localization or labeling, fea-
tures arising from max-pooling and decimation operations
can only provide approximate localization, as in the pro-
cess of creating them, the network has already thrown out
precise spatial information by design. If we wish to gener-
ate features that preserve accurate localization, we may do
so using shallow networks without max-pooling, but shal-
low networks without pooling cannot learn robust, invariant
features. What we would like is to have our cake and eat
it too: to combine the best of both worlds, merging ﬁnely-
localized information from shallow, non-pooled networks
with robust, coarsely-localized features computed by deep,
pooled networks.

Several recently proposed approaches [17, 13, 31] ad-
dress this by adding or concatenating the features obtained
across multiple levels. We use this approach in our base-
line model termed SumNet for our task of interest: facial
keypoint localization. To the best of our knowledge this
is the ﬁrst time this general approach has been applied to
the problem of facial keypoint localization and even our
baseline is capable of yielding state of the art results. A
possible weakness of these approaches however is that all
detection paths, from coarsely to ﬁnely localized features,
only become aggregated at the very end of the feature pro-
cessing pipeline. As a thought experiment to illustrate this
approach’s weakness, imagine that we have a photo of a
boat ﬂoating in the ocean and would like to train a con-
vnet to predict with single pixel accuracy a keypoint cor-
responding to the tip of the boat’s bow. Coarsely local-
ized features1 could highlight the rough region of the bow
of the boat, and ﬁnely localized features could be tuned to

1From now on we use the shorthand ﬁne/coarse features to mean

ﬁnely/coarsely localized features.

1

Figure 1. (Left) Architecture of summation based coarse-ﬁne network (SumNet). C is a convolutional layer. P,C represents a pooling
layer followed by a convolutional layer. All convolutions are 3 × 3 and all poolings are 2 × 2. All convolutional layers are followed
by ReLU non-linearity except the last convolutional layer in each branch. U represents an upsampling layer. Each branch’s output is 5
feature maps of size 80 × 80. FCN/Hypercolumn models use this architecture. (Right) Architecture of the Recombinator Networks (RCN).
All convolutions are 3 × 3 and all poolings are 2 × 2. All upsamplings are by a factor of 2. K represents concatenation of two sets of
feature maps along the feature map dimension. All convolutional layers are followed by ReLU non-linearity except the one right before the
softmax. In the Recombinator Networks model with skip connections (not shown), each branch takes upsampled features not only from
one coarser branch, but from all coarser branches.

ﬁnd generic boat edges, but the ﬁne features must remain
generic, being forced to learn boat edge detectors for all
possible ocean and boat color combinations. This would be
difﬁcult, because boat and ocean pixels could take similar
colors and textures. Instead, we would like a way for the
coarse features which contain information about the global
scene structure (perhaps that the water is dark blue and the
boat is bright blue) to provide information to the ﬁne feature
detectors earlier in their processing pipeline. Without such
information, the ﬁne feature detectors would be unable to
tell which half of a light blue/dark blue edge was ocean and
which was boat. In the Recombinator Networks proposed
in this paper, the ﬁnely localized features are conditioned
on higher level more coarsely localized information. It re-
sults in a model which is deeper but – interestingly – trains
faster than the summation baseline and yields more precise
localization predictions. In summary, this work makes the
following contributions:

1. We propose a novel architecture — the Recombinator
Networks — for combining information over different
spatial localization resolutions (Section 3).

2. We show how a simple denoising model may be used

to enhance model predictions (Section 4).

3. We provide an in-depth empirical evaluation of a wide
variety of relevant architectural variants (Section 5.1).
4. We show state of the art performance on two widely
used and competitive evaluations for facial keypoint
localization (Section 5.2).

2. Related work

Keypoint localization methods: Our task of interest
is the well studied problem of facial keypoint localization
[44, 42, 38, 2, 33, 40, 6, 35, 7, 18, 45] illustrated in Fig-
ure 1. Precise facial keypoint localization is often an es-
sential preprocessing step for face recognition [1] and de-

tection [45]. Recent face veriﬁcation models like DeepFace
[30] and DeepID2 [27] also include keypoint localization
as the ﬁrst step. There have been many other approaches to
general keypoint localization, including active appearance
models [8, 43], constrained local models [10, 21, 11, 2], ac-
tive shape models [12], point distribution models [9], struc-
tured model prediction [3, 31], tree structured face mod-
els [45], group sparse learning based methods [39], shape
regularization models that combines multiple datasets [25],
feature voting based landmark localization [26, 36] and
convolutional neural networks based models [41, 28, 42].
Two other related models are [31], where a multi-resolution
model is proposed with dual coarse/ﬁne paths and tied ﬁl-
ters, and [28], which uses a cascaded architecture to reﬁne
predictions over several stages. Both of these latter mod-
els make hard decisions using coarse information halfway
through the model.

Approaches that combine features across multiple
levels: Several recent models — including the fully convo-
lutional networks (FCNs) in [17], the Hypercolumn model
[13], and the localization model of Tompson et al. [31] —
generate features or predictions at multiple resolutions, up-
sample the coarse features to the ﬁne resolution, and then
add or concatenate the features or predictions together. This
approach has generally worked well, improving on previ-
ous state of the art results in detection, segmentation, and
human-body pose estimation [13, 17, 31]. In this paper we
create a baseline model similar to these approaches that we
refer to as SumNet in which we use a network that aggre-
gates information from features across different levels in the
hierarchy of a conv-pool-decimate network using concate-
nation followed by a weighted sum over feature maps prior
to ﬁnal layer softmax predictions. Our goal in this paper is
to improve upon this architecture. Differences between the
Recombinator Networks and related architectures are sum-

2

marized in Table 5. U-Net [19] is another model that merges
features across multiple levels and has a very similar archi-
tecture to Recombinator Networks. The two models have
been developed independently and were designed for differ-
ent problems2. Note that none of these models use a learned
denoising post-processing as we do (see section 4).

3. Summation versus Recombinator Networks

In this section we describe our baseline SumNet model
based on a common architectural design where information
from different levels of granularity are merged just prior to
predictions being made. We contrast this with the Recom-
binator Networks architecture.

3.1. Summation based Networks

The SumNet architecture, shown in Figure 1(left), adds
to the usual bottom to top convolution and spatial pool-
ing, or “trunk”, a horizontal left-to-right “branch” at each
resolution level. While spatial pooling progressively re-
duces the resolution as we move “up” the network along
the trunk, the horizontal branches only contains full con-
volutions and element-wise non-linearities, with no spatial
pooling, so that they can preserve the spatial resolution at
that level while doing further processing. The output of
the ﬁnest resolution branch only goes through convolutional
layers. The ﬁnest resolution layers keep positional informa-
tion and use it to guide the coarser layers within the patch
that they cannot have any preference, while the coarser res-
olution layers help ﬁner layers to get rid of false positives.
The architecture then combines the rightmost low resolution
output of all horizontal branches, into a single high resolu-
tion prediction, by ﬁrst up-sampling3 them all to the model’s
input image resolution (80 × 80 for our experiments) and
then taking a weighted sum to yield the pre-softmax val-
ues. Finally, a softmax function is applied to yield the ﬁ-
nal location probability map for each keypoint. Formally,
given an input image x, deﬁne the trunk of the network as
a sequence of blocks of traditional groups of convolution,
pooling and decimation operations. Starting from the layer
yielding the coarsest scale feature maps we call the outputs
of R such blocks T (1), . . . , T (R). At each level r of the
trunk we have a horizontal branch that takes T (r) as its in-
put and consists of a sequence of convolutional layers with
no subsampling. The output of such a branch is a stack of
K feature maps, one for each of the K target keypoints, at
the same resolution as its input T (r), and we denote this
output as branch(T (r)).
It is then upsampled up[×F ] by
some factor F which returns the feature map to the original
resolution of the input image. Let these upsampled maps
be M (1)
is the score map given by

K where M (r)

1 , . . . , M (R)

k

2For keypoint localization, we apply the softmax spatially i.e. across
possible spatial locations, whereas for segmentation [13, 17, 19] it is ap-
plied across all possible classes for each pixel.

3Upsampling can be performed either by tiling values or by using bilin-
ear interpolation. We found bilinear interpolation degraded performance in
some cases, so we instead used the simpler tiling approach.

k

the rth branch to the kth keypoint (left eye, right eye, . . .).
Each such map M (r)
is a matrix of the same resolution as
the image fed as input (i.e. 80 × 80). The score ascribed
by branch r for keypoint k being at coordinate i, j is given
by M (r)
k,i,j. The ﬁnal probability map for the location Yk of
keypoint k is given by a softmax over all possible locations.
We can therefore write the model as

M (1) = up[×2R−1](branch(T (1)))
M (2) = up[×2R−2](branch(T (2)))
. . .
M (R) = branch(T (R))

P (Yk|X = x) = softmax

(cid:16) R
(cid:88)

r=1

αrkM (r)

k

(cid:17)

,

(1)

where αrk is a 2D matrix that gives a weight to every
pixel location i, j of keypoint k in branch r. The weighted
sum of features over all branches taken here is equivalent to
concatenating the features of all branches and multiplying
them in a set of weights, which results in one feature map
per keypoint. This architecture is trained globally using
gradient backpropagation to minimize the sum of negated
conditional log probabilities of all N training (input-image,
keypoint-locations) pairs, for all K keypoints (x(n), y(n)
k ),
with an additional regularization term for the weights ; i.e.
we search for network parameters W that minimize 4

L(W) =

− log P (Yk = y(n)

k |X = x(n)) + λ(cid:107)W(cid:107)2.

1
N

N
(cid:88)

K
(cid:88)

n=1

k=1

(2)

3.2. The Recombinator Networks

In the SumNet model, different branches can only com-
municate through the updates received from the output layer
and the features are merged linearly through summation. In
the Recombinator Networks (RCN) architecture, as shown
in Figure 1(right), instead of taking a weighted sum of the
upsampled feature maps in each branch and then passing
them to a softmax, the output of each branch is upsampled,
then concatenated with the next level branch with one de-
gree of ﬁner resolution. In contrast to the SumNet model,
each branch does not end in K feature maps. The infor-
mation stays in the form of a keypoint independent feature
map. It is only at the end of the Rth branch that feature
maps are converted into a per-keypoint scoring represen-
tation that has the same resolution as the input image, on
which a softmax is then applied. As a result of RCN’s dif-
ferent architecture, branches pass more information to each
other during training, such that convolutional layers in the
ﬁner branches get inputs from both coarse and ﬁne layers,
letting the network learn how to combine them non-linearly
to maximize the log likelihood of the keypoints given the

4 We also tried L2 distance cost between true and estimated keypoints
(as a regression problem) and got worse results. This may be due to the
fact that a softmax probability map can be multimodal , while L2 distance
implicitly corresponds to likelihood of a unimodal isotropic Gaussian.

3

input images. The whole network is trained end-to-end
by backprop. Following the previous conventions and by
deﬁning the concatenation operator on feature maps A, B
as concat(A, B), we can write the model as

M (cid:48)(1) = up[×2](branch(T (1)))
M (cid:48)(2) = up[×2](branch(concat(T (2), M (cid:48)(1))))
. . .
M (cid:48)(R) = branch(concat(T (R), M (cid:48)(R−1)))
P (Yk|X = x) = softmax(M (cid:48)(R)

).

k

(3)

skip

also
the

each branch are

explore RCN with
features of

connections,
We
concate-
where
nated with upsampled features of not only one-level
coarser branch,
coarser branches
the last branch computes M (cid:48)(R) =
and,
therefore,
branch(concat(T (R), M (cid:48)(R−1), M (cid:48)(R−2), . . . , M (cid:48)(1)).
In
practice, the information ﬂow between different branches
makes RCN converge faster and also perform better
compared to the SumNet model.

all previous

but

4. Denoising keypoint model

Convolutional networks are excellent edge detectors. If
there are few samples with occlusion in the training sets,
convnets have problem detecting occluded keypoints and
instead select nearby edges (see some samples in Figures
3, 5). Moreover, the convnet predictions, especially on
datasets with many keypoints, do not always correspond to
a plausible keypoint distribution and some keypoints jump
off the curve (e.g. on the face contour or eye-brows) irre-
spective of other keypoints’ position (see some samples in
Figure 7). This type of error can be addressed by using a
structured output predictor on top of the convnet, that takes
into account how likely the location of a keypoint is rel-
ative to other keypoints. Our approach is to train another
convolutional network that captures useful aspects of the
prior keypoint distribution (not conditioned on the image).
We train it to predict the position of a random subsets of
keypoints, given the position of the other keypoints. More
speciﬁcally, we train the convolutional network as a denois-
ing model, similar to the denoising auto-encoder [34] by
completely corrupting the location of a randomly chosen
subset of the keypoints and learning to accurately predict
their correct location given that of the other keypoints. This
network receives as input, not the image, but only keypoint
locations represented as one-hot 2D maps (one 2D map per
keypoint, with a 1 at the position of the keypoint and ze-
ros elsewhere). It is composed of convolutional layers with
large receptive ﬁelds (to get to see nearby keypoints), ReLU
nonlinearities and no subsampling (see Figure 2). The net-
work outputs probability maps for the location of all key-
points, however, its training criterion uses only prediction

errors of the corrupted ones. The cost being optimized sim-
ilar to Eq.(2) but includes only the corrupted keypoints.

Once, this denoising model is trained, the output of RCN
(the predicted most likely location in one-hot binary loca-
tion 2D map format) is fed to the denoising model. We
then simply sum the pre-softmax values of both RCN and
denoising models and pass them through a softmax to gen-
erate the ﬁnal output probability maps. The joint model is
depicted in Figure 2. The joint model combines the RCN’s
predicted conditional distribution for keypoint k given the
image P (Yk|X = x) with the denoising model’s distri-
bution of the location of that keypoint given other key-
points P (Yk|Y¬k), to yield an estimation of keypoint k’s
location given both image and other keypoint locations
P (Yk|Y¬k, X = x). The choice of convolutional networks
for the denoising model allows it to be easily combined with
RCN in a uniﬁed deep convolutional architecture.

5. Experimental setup and results

We evaluate our model5 on the following datasets with

evaluation protocols deﬁned by previous literature:

AFLW and AFW datasets: Similar to TCDCN [41], we
trained our models on the MTFL dataset,6 which we split
into 9,000 images for training and 1,000 for validation. We
evaluate our models on the same subsets of AFLW [15] and
AFW [45] used by [41], consisting of 2995 and 377 images,
respectively, each labeled with 5 facial keypoints.

300W dataset:

300W [20] standardizes multiple
datasets into one common dataset with 68 keypoints. The
training set is composed of 3148 images (337 AFW, 2000
Helen, and 811 LFPW). The test set is composed of 689
images (135 IBUG, 224 LFPW, and 330 Helen). The IBUG
is referred to as the challenging subset, and the union of
LFPW and Helen test sets is referred to as the common sub-
set. We shufﬂe the training set and split it into 90% train-set
(2834 images) and 10% valid-set (314 images).

One challenging issue in these datasets is that the test set
examples are signiﬁcantly different and more difﬁcult com-
pared to the training sets. In other words the train and test
set images are not from the same distribution. In particular,
the AFLW and AFW test sets contain many samples with
occlusion and more extreme rotation and expression cases
than the training set. The IBUG subset of 300W contains
more extreme pose and expressions than other subsets.

Error Metric: The euclidean distance between the true
and estimated landmark positions normalized by the dis-

5Our

code
https://github.com/SinaHonari/RCN

models

and

[14] and 5849 images from the web.

6MTFL consists of 10,000 training images: 4151 images from LFW

are

publicly

available

at

4

tance between the eyes (interocular distance) is used:

(cid:113)

N
(cid:88)

K
(cid:88)

(w(n)

k − ˜w(n)

error =

1
KN

n=1

k=1

k )2 + (h(n)
D(n)

k − ˜h(n)

k )2

,

(4)

where K is the number of keypoints, N is the total num-
ber of images, D(n) is the interocular distance in image n.
(w(n)
k ) represent the true and esti-
mated coordinates for keypoint k in image n, respectively.

k ) and ( ˜w(n)

k , h(n)

k , ˜h(n)

5.1. Evaluation on SumNet and RCN

We evaluate RCN on the 5-keypoint test sets. To avoid
overﬁtting and improve performance, we applied online
data augmentation to the 9,000 MTFL train set using ran-
dom scale, rotation, and translation jittering7. We prepro-
cessed images by making them gray-scale and applying lo-
cal contrast normalization 8. In Figure S1, we show a visu-
alization of the contribution of each branch of the SumNet
to the ﬁnal predictions: the coarsest layer provides robust
but blurry keypoint locations, while the ﬁnest layer gives
detailed face information but suffers from many false pos-
itives. However, the sum of branches in SumNet and the
ﬁnest branch in RCN make precise predictions.

Since the test sets contain more extreme occlusion and
lighting conditions compared to the train set, we applied a
preprocessing to the train set to bring it closer to the test set
distribution. In addition to the jittering, we found it helpful
to occlude images in the training set with randomly placed
black rectangles9 at each training iteration. This trick forced
the convnet models to use more global facial components to
localize the keypoints and not rely as much on the features
around the keypoints, which in turn, made it more robust
against occlusion and lighting contrast in the test set. Figure
3 shows the effects of this occlusion when used to train the
SumNet and RCN models on randomly drawn samples. The
samples show for most of the test set examples the models
do a good prediction. Figure 4 shows some hand-picked
examples from the test sets, to show extreme expression,
occlusion and contrast that are not captured in the random
samples of Figure 3. Figure 5 similarly uses some manually
selected examples to show the beneﬁts of using occlusion.
To evaluate how much each branch contributes to the
overall performance of the model, we trained models ex-
cluding some branches and report the results in Table 1. The
ﬁnest layer on its own does a poor job due to many false
positives, while the coarsest layer on its own does a reason-
able job, but still lacks high accuracy. One notable result

7We jittered data separately in each epoch, whose parameters were uni-
formly sampled in the following ranges (selected based on the validation
set performance): Translation and Scaling: [-10%, +10%] of face bound-
ing box size; Rotation: [-40, +40] degrees.

8RGB images performed worse in our experiments.
9Each image was occluded with one black (zeros) rectangle, whose size
was drawn uniformly in the range [20, 50] pixels. It’s location was drawn
uniformly over the entire image.

is that using only the coarsest and ﬁnest branches together
produces reasonable performance. However, the best per-
formance is achieved by using all branches, merging four
resolutions of coarse, medium, and ﬁne information. We

Mask
1, 0, 0, 0
0, 1, 0, 0
1, 1, 0, 0
0, 0, 1, 0
0, 0, 0, 1
0, 0, 1, 1
0, 1, 1, 1
1, 0, 0, 1
1, 1, 1, 1

SumNet

RCN

AFLW AFW AFLW AFW
10.89
10.54
11.87
11.28
9.44
9.47
15.91
16.14
48.61
45.39
13.53
13.90
7.95
7.91
7.27
6.91
6.43
6.44

10.63
11.43
9.65
16.35
47.97
14.14
8.22
7.51
6.78

10.61
11.56
9.31
15.78
46.87
12.67
7.62
6.79
6.37

Table 1. The performance of SumNet and RCN trained with masks
applied to different branches. A mask value of 1 indicates the
branch is included in the model and 0 indicates it is omitted (as a
percent; lower is better). In SumNet model mask 0 indicates no
contribution from that branch to the summation of all branches,
while in RCN, if a branch is omitted, the previous coarse branch
is upsampled to the following ﬁne branch. The mask numbers are
ordered from the coarsest branch to the ﬁnest branch.

also experimented with adding extra branches, getting to a
coarser resolution of 5 × 5 in the 5 branch model, 2 × 2
in the 6 branch model and 1 × 1 in the 7 branch model. In
each branch, the same number of convolutional layers with
the same kernel size is applied,10 and all new layers have
48 channels. The best performing model, as shown in Table
2, is RCN with 6 branches. Comparing RCN and SumNet
training, RCN converges faster. Using early stopping and
without occlusion pre-processing, RCN requires on average
200 epochs to converge (about 4 hours on a NVidia Tesla
K20 GPU), while SumNet needs on average more than 800
epochs (almost 14 hours). RCN’s error on both test sets
drops below 7% on average after only 15 epochs (about 20
minutes), while SumNet needs on average 110 epochs (al-
most 2 hours) to get to this error. Using occlusion prepro-
cessing increases these times slightly but results in lower
test error. At test time, a feedforward pass on a K20 GPU
takes 2.2ms for SumNet and 2.5ms for RCN per image in
Theano [4]. Table 2 shows occlusion pre-processing sig-
niﬁcantly helps boost the accuracy of RCN, while slightly
helping SumNet. We believe this is due to global informa-
tion ﬂow from coarser to ﬁner branches in RCN.

5.2. Comparison with other models

AFLW and AFW datasets: We ﬁrst re-implemented the
TCDCN model [41], which is the current state of the art

10A single exception is that when the 5 × 5 resolution map is reduced
to 2 × 2, we apply 3 × 3 pooling with stride 2 instead of the usual 2 × 2
pooling, to keep the resulting map left-right symmetric.

11SumNet and RCN models are trained using occlusion preprocessing.

5

Table 3. Facial landmark mean error normalized by interocular dis-
tance on AFW and AFLW sets (as a percent; lower is better).11

6. Conclusion

Model
SumNet (4 branch)
SumNet (5 branch)
SumNet (6 branch)
SumNet (5 branch - occlusion)
SumNet (6 branch - occlusion)
RCN (4 branch)
RCN (5 branch)
RCN (6 branch)
RCN (7 branch)
RCN (5 branch - occlusion)
RCN (6 branch - occlusion)
RCN (7 branch - occlusion)
RCN (6 branch - occlusion - skip)

AFLW AFW
6.78
6.53
6.48
6.34
6.33
6.43
6.05
5.98
6.12
5.44
5.36
5.55
5.56

6.44
6.42
6.34
6.29
6.27
6.37
6.11
6.00
6.17
5.65
5.60
5.76
5.63

Table 2. SumNet and RCN performance with different number of
branches, occlusion preprocessing and skip connections.

Model
TSPM [45]
CDM [38]
ESR [6]
RCPR [5]
SDM [35]
TCDCN [41]
TCDCN baseline (our implementation)
SumNet (FCN/HC) baseline (this)
RCN (this)

AFLW AFW
14.3
11.1
10.4
9.3
8.8
8.2
7.87
6.33
5.36

15.9
13.1
12.4
11.6
8.5
8.0
7.60
6.27
5.60

model on 5 keypoint AFLW [15] and AFW [45] sets, and
applied the same pre-processing as our other experiments.
Through hyper-parameter search, we even improved upon
the AFLW and AFW results reported in [41]. Table 3 com-
pares RCN with other models. Especially, it improves the
SumNet baseline, which is equivalent to FCN and Hyper-
column models, and it also converges faster. The SumNet
baseline is also provided by this paper and to the best of our
knowledge this is the ﬁrst application of any such coarse-to-
ﬁne convolutional architecture to the facial keypoint prob-
lem. Figure 6 compares TCDCN with SumNet and RCN
models, on some difﬁcult samples reported in [41].

300W dataset [20]: The RCN model that achieved the
best result on the validation set, contains 5 branches with 64
channels for all layers (higher capacity is needed to extract
features for more keypoints) and 2 extra convolutional lay-
ers with 1 × 1 kernel size in the ﬁnest branch right before
applying the softmax. Table 4 compares different models on
all keypoints (68) and a subset of keypoints (49) reported in
[32]. The denoising model is trained by randomly choos-
ing 35 keypoints in each image and jittering them (chang-
ing their location uniformly to any place in the 2D map).
It improves the RCN’s prediction by considering how loca-
tions of different keypoints are inter-dependent. Figure 7
compares the output of RCN, the denoising model and the
joint model, showing how the keypoint distribution model-
ing can reduce the error. We only trained RCN on the 2834

#keypoints Common

49

68

Model
PO-CR [32]
RCN (this)
RCN + denoising
keypoint model (this)
CDM [38]
DRMF [2]
RCPR [5]
GN-DPM [33]
CFAN [40]
ESR [6]
SDM [35]
ERT [7]
LBF [18]
CFSS[44]
TCDCN † [42]
RCN (this)
RCN + denoising
keypoint model (this)

4.00
2.64

2.59
10.10
6.65
6.18
5.78
5.50
5.28
5.57
-
4.95
4.73
4.80
4.70

IBUG Fullset
4.56
6.82
3.88
5.10

4.81
19.54
19.79
17.26
-
16.78
17.00
15.40
-
11.98
9.98
8.60
9.00

3.76
11.94
9.22
8.35
-
7.69
7.58
7.50
6.40
6.32
5.76
5.54
5.54

Table 4. Facial landmark mean error normalized by interocular dis-
tance on 300W test sets (as a percent; lower is better). 11

4.67

8.44

5.41

images in the train-set. No extra data is taken to pre-train or
ﬁne-tune the model 12. The current state-of-the-art model
without any extra data† is CFSS[44]. We reduce the error
by 15% on the IBUG subset compared to CFSS.

The model

In this paper we have introduced the Recombinator Net-
works architecture for combining coarse maps of pooled
features with ﬁne non-pooled features in convolutional
neural networks.
improves upon previous
summation-based approaches by feeding coarser branches
into ﬁner branches, allowing the ﬁner resolutions to learn
upon the features extracted by coarser branches. We ﬁnd
that this new architecture leads to both reduced training time
and increased facial keypoint prediction accuracy. We have
also proposed a denoising model for keypoints which in-
volves explicit modeling of valid spatial conﬁgurations of
keypoints. This allows our complete approach to deal with
more complex cases such as those with occlusions.

Acknowledgments

We would like to thank the Theano developers, particularly
F. Bastien and P. Lamblin, for their help throughout this
project. We appreciate Y. Bengio and H. Larochelle feed-
backs and also L. Yao, F. Ahmed and M. Pezeshki’s helps
in this project. We also thank Compute Canada, and Cal-
cul Quebec for providing computational resources. Finally,
we would like to thank Fonds de Recherche du Qu´ebec –
Nature et Technologies (FRQNT) for a doctoral research
scholarship (B2) grant during 2014 and 2015 (SH) and the
NASA Space Technology Research Fellowship (JY).

12We only jittered the train-set images by random scaling, translation

and rotation similar to the 5 keypoint dataset.

† TCDCN [42] uses 20,000 extra dataset for pre-training.

6

(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)(cid:88)

Features

Models

Efﬁcient
Localization [31]

Deep
Cascade [28]

Hyper-
columns [13]

Coarse features: hard crop or soft combination?
Learned coarse features fed into ﬁner branches?

Hard
No

Hard
No

Soft
No

Table 5. Comparison of multi-resolution architectures. The Efﬁcient Localization and Deep Cascade models use coarse features to crop
images (or ﬁne layer features), which are then fed into ﬁne models. This process saves computation when dealing with high-resolution
images but at the expense of making a greedy decision halfway through the model. Soft models merge local and global features of the entire
image and do not require a greedy decision. The Hypercolumn and FCN models propagate all coarse information to the ﬁnal layer but
merge information via addition instead of conditioning ﬁne features on coarse features. The Recombinator Networks (RCN), in contrast,
injects coarse features directly into ﬁner branches, allowing the ﬁne computation to be tuned by (conditioned on) the coarse information.
The model is trained end-to-end and results in learned coarse features which are tuned directly to support the eventual ﬁne predictions.

FCN
[17]

Soft
No

RCN
(this)

Soft
Yes

Figure 2. Denoising / joint keypoint model. The Recombinator Networks (RCN) and the keypoint location denoising models are trained
separately. At test time, the keypoint hard prediction of RCN is ﬁrst injected into the denoising model as one-hot maps. Then the pre-
softmax values computed by the RCN and the denoising models are summed and pass through a ﬁnal softmax to predict keypoint locations.

Figure 3. Keypoint predictions on random test set images from easy (left) to hard (right). Each column shows predictions of following
models from top to bottom: SumNet, SumNet with occlusion, RCN, RCN with occlusion (all models have 5 branches). We note for each
test set image (including both AFLW and AFW) the average error over the four models and use this as a notion of that image’s difﬁculty.
We then sort all images by difﬁculty and draw a random image from percentile bins, using the bin boundaries noted above the images.
To showcase the models’ differing performance, we show only a few easier images on the left side and focus more on the hardest couple
percent of images toward the right side. The value on the left is the average error of these samples per model (much higher than the results
reported in Table 3 because of the skew toward difﬁcult images). The yellow line connects the true keypoint location (green) to the model’s
prediction (red). Dots are small to avoid covering large regions of the image. Best viewed with zoom in color. Figure S2 shows the
performance of these four models as the difﬁculty of the examples increase.

7

Figure 4. Samples with different expressions (green border), contrast and illuminations (red border) and occlusions (blue border) from
AFLW and AFW sets. In each box, top row depicts samples from SumNet and bottom row shows samples from RCN, both with occlusion
pre-processing.

Figure 5. Samples from AFLW and AFW test sets showing keypoint detection accuracy without (top row) and with (bottom row) occlusion
pre-processing using RCN.

Figure 6. Samples from TCDCN [41] (yellow border with green predicted points) versus SumNet (orange border) and RCN (blue border).
In the latter two models, red and green dots show predicted and true keypoints. TCDCN samples are taken directly from [41].

Figure 7. Samples from 300W test sets. Each column shows samples in this order (top to bottom): RCN, keypoint denoising model and
the joint model. The ﬁrst two columns show extreme expression and occlusion samples where RCN’s prediction is highly accurate. The
next 5 columns show samples where the denoising model improves the RCN’s predictions. In the 8th column the structured model ﬁnd
a reasonable keypoint distribution but deteriorates the RCN’s predictions. Finally, the last two columns show cases where the denoising
model generates plausible keypoint distributions but far from the true keypoints.

8

References

[1] A. Asthana, T. Marks, M. Jones, K. Tieu, and M. Rohith.
Fully automatic pose-invariant face recognition via 3d pose
normalization. In ICCV, pages 937–944, 2011.

[2] A. Asthana, S. Zafeiriou, S. Cheng, and M. Pantic. Robust
discriminative response map ﬁtting with constrained local
models. In CVPR, pages 3444–3451, 2013.

[3] T. Baltruˇsaitis, P. Robinson, and L.-P. Morency. Continuous
conditional neural ﬁelds for structured regression. In ECCV,
pages 593–608. 2014.

[4] F. Bastien, P. Lamblin, R. Pascanu, J. Bergstra, I. Good-
fellow, A. Bergeron, N. Bouchard, D. Warde-Farley, and
Y. Bengio. Theano: new features and speed improvements.
In NIPS Workshop on Deep Learning, 2012.

[5] X. Burgos-Artizzu, P. Perona, and P. Doll´ar. Robust face
landmark estimation under occlusion. In ICCV, pages 1513–
1520, 2013.

[6] X. Cao, Y. Wei, F. Wen, and J. Sun. Face alignment by ex-
plicit shape regression. In ICCV, 107(2):177–190, 2014.
[7] X. Cao, Y. Wei, F. Wen, and J. Sun. Face alignment by ex-
plicit shape regression. In IJCV, 107(2):177–190, 2014.
[8] T. Cootes, G. Edwards, and C. Taylor. Active appearance

models. In PAMI, 23(6):681–685, 2001.

[9] T. Cootes, C. Taylor, D. Cooper, and J. Graham. Active shape
models-their training and application. In CVIU, 61(1):38–59,
1995.

[10] D. Cristinacce and T. Cootes. Feature detection and tracking
with constrained local models. In BMVC, volume 2, page 6,
2006.

[11] D. Cristinacce and T. Cootes. Automatic feature localisa-
tion with constrained local models. Pattern Recognition,
41(10):3054–3067, 2008.

[12] D. Cristinacce and T. F. Cootes. Boosted regression active

shape models. In BMVC, pages 1–10, 2007.

[13] B. Hariharan, P. Arbel´aez, R. Girshick, and J. Malik. Hyper-
columns for object segmentation and ﬁne-grained localiza-
tion. In CVPR, 2015.

[14] G. Huang, M. Ramesh, T. Berg, and E. Learned-Miller. La-
beled faces in the wild: A database for studying face recogni-
tion in unconstrained environments. Technical report, 07-49,
University of Massachusetts, Amherst, 2007.

[15] M. Kostinger, P. Wohlhart, P. Roth, and H. Bischof. Anno-
tated facial landmarks in the wild: A large-scale, real-world
In ICCV Work-
database for facial landmark localization.
shop, pages 2144–2151, 2011.

[16] A. Krizhevsky, I. Sutskever, and G. E. Hinton.

classiﬁcation with deep convolutional neural networks.
NIPS, pages 1106–1114, 2012.

Imagenet
In

[17] J. Long, E. Shelhamer, and T. Darrell. Fully convolutional
networks for semantic segmentation. In CVPR, 2015.
[18] S. Ren, X. Cao, Y. Wei, and J. Sun. Face alignment at 3000
In CVPR, pages

fps via regressing local binary features.
1685–1692, 2014.

[19] O. Ronneberger, P. Fischer, and T. Brox. U-net: Convolu-
tional networks for biomedical image segmentation. In Med-
ical Image Computing and Computer-Assisted Intervention–
MICCAI 2015, pages 234–241. Springer, 2015.

[20] C. Sagonas, G. Tzimiropoulos, S. Zafeiriou, and M. Pantic.
300 faces in-the-wild challenge: The ﬁrst facial landmark
localization challenge. In ICCV Workshop, pages 397–403,
2013.

[21] J. M. Saragih, S. Lucey, and J. F. Cohn. Face alignment
through subspace constrained mean-shifts. In ICCV, pages
1034–1041, 2009.

[22] P. Sermanet, K. Kavukcuoglu, S. Chintala, and Y. LeCun.
Pedestrian detection with unsupervised multi-stage feature
learning. In CVPR, pages 3626–3633, 2013.

[23] P. Sermanet and Y. LeCun. Trafﬁc sign recognition with
multi-scale convolutional networks. In IJCNN, pages 2809–
2813, 2011.

[24] K. Simonyan and A. Zisserman. Very deep convolutional

networks for large-scale image recognition. CVPR, 2014.

[25] B. Smith and L. Zhang. Collaborative facial landmark local-
ization for transferring annotations across datasets. In ECCV,
pages 78–93. 2014.

[26] B. M. Smith, J. Brandt, Z. Lin, and L. Zhang. Nonpara-
metric context modeling of local appearance for pose-and
In CVPR,
expression-robust facial landmark localization.
pages 1741–1748, 2014.

[27] Y. Sun, Y. Chen, X. Wang, and X. Tang. Deep learning face
representation by joint identiﬁcation-veriﬁcation. In NIPS,
pages 1988–1996, 2014.

[28] Y. Sun, X. Wang, and X. Tang. Deep convolutional network
In CVPR, pages 3476–

cascade for facial point detection.
3483, 2013.

[29] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed,
D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabinovich.
Going deeper with convolutions. In CVPR, 2014.

[30] Y. Taigman, M. Yang, M. Ranzato, and L. Wolf. Deepface:
Closing the gap to human-level performance in face veriﬁca-
tion. In CVPR, pages 1701–1708, 2014.

[31] J. Tompson, R. Goroshin, A. Jain, Y. LeCun, and C. Bregler.
Efﬁcient object localization using convolutional networks. In
CVPR, 2015.

[32] G. Tzimiropoulos. Project-out cascaded regression with an
application to face alignment. In Computer Vision and Pat-
tern Recognition (CVPR), 2015 IEEE Conference on, pages
3659–3667. IEEE, 2015.

[33] G. Tzimiropoulos and M. Pantic. Gauss-newton deformable
part models for face alignment in-the-wild. In CVPR, pages
1851–1858, 2014.

[34] P. Vincent, H. Larochelle, Y. Bengio, and P.-A. Manzagol.
Extracting and composing robust features with denoising au-
toencoders. In ICML, pages 1096–1103, 2008.

[35] X. Xiong and F. De la Torre. Supervised descent method and
its applications to face alignment. In CVPR, pages 532–539,
2013.

[36] H. Yang and I. Patras. Sieving regression forest votes for

facial feature detection in the wild. In ICCV. IEEE, 2013.

[37] J. Yosinski, J. Clune, A. Nguyen, T. Fuchs, and H. Lipson.
Understanding neural networks through deep visualization.
In ICML Workshop on Deep Learning, 2015.

[38] X. Yu, J. Huang, S. Zhang, W. Yan, and D. Metaxas. Pose-
free facial landmark ﬁtting via optimized part mixtures and

9

cascaded deformable shape model.
1951, 2013.

In ICCV, pages 1944–

[39] X. Yu, J. Huang, S. Zhang, W. Yan, and D. N. Metaxas. Pose-
free facial landmark ﬁtting via optimized part mixtures and
In ICCV, pages 1944–
cascaded deformable shape model.
1951, 2013.

[40] J. Zhang, S. Shan, M. Kan, and X. Chen. Coarse-to-ﬁne
auto-encoder networks (cfan) for real-time face alignment.
In ECCV, pages 1–16. 2014.

[41] Z. Zhang, P. Luo, C. Loy, and X. Tang. Facial landmark
detection by deep multi-task learning. In ECCV, pages 94–
108. 2014.

[42] Z. Zhang, P. Luo, C. C. Loy, and X. Tang. Learning deep
representation for face alignment with auxiliary attributes.
In PAMI, 2015.

[43] X. Zhao, S. Shan, X. Chai, and X. Chen.

Locality-
constrained active appearance model. In ACCV, pages 636–
647. 2013.

[44] S. Zhu, C. Li, C. C. Loy, and X. Tang. Face alignment by
coarse-to-ﬁne shape searching. In CVPR, pages 4998–5006,
2015.

[45] X. Zhu and D. Ramanan. Face detection, pose estimation,
and landmark localization in the wild. In CVPR, pages 2879–
2886, 2012.

10

Supplementary Information for
Recombinator Networks: Learning Coarse-to-Fine Feature Aggregation

a

b

c

d

e

f

Figure S1. Sub-ﬁgures a, b, c, d show pre-sum (left) and softmax (right) of the coarsest to ﬁnest branches in a 4-branch SumNet model.
The softmax used in these branches are only for illustration purposes and is not part of the trained model. Sub-ﬁgure e (left) shows the sum
of branches in the SumNet model and Sub-ﬁgure f (left) depicts the pre-softmax values in RCN. The true keypoint locations are shown by
green cross in all ﬁgures to show their relative correspondence with the branch activations. SumNet and RCN’s predictions are shown by
red plus on the post-softmax maps in Sub-ﬁgures e (right) and f (right), respectively. In each row the images correspond to the keypoints
in this order from left to right: left-eye, right-eye, nose, left-mouth, right-mouth. Best viewed electronically with zoom.

1

Figure S2. The performance of SumNet and RCN models with and without occlusion pre-processing on the merged AFW and AFLW test
sets as the difﬁculty of the examples increase (lower is better). To get this plot, we note for each test set image (including both AFLW and
AFW) the average error over the four models and use this as a notion of that image’s difﬁculty. We then sort all images by difﬁculty and
get each model’s log error (using Eq. 4) on each test example. Finally, we plot each model’s performance on the sorted test set examples
from the easiest (0% difﬁculty) to the most difﬁcult (100% difﬁculty) percentage of the test set examples. The plot shows RCN performs
better than SumNet, especially on the harder examples. The occlusion pre-processing helps RCN on most difﬁcult examples (difﬁculty >
65%), while it slightly helps SumNet.

2

