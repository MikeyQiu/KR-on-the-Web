Learning Language Games through Interaction

Sida I. Wang

Percy Liang

Christopher D. Manning

Computer Science Department
Stanford University
{sidaw,pliang,manning}@cs.stanford.edu

6
1
0
2
 
n
u
J
 
8
 
 
]
L
C
.
s
c
[
 
 
1
v
7
4
4
2
0
.
6
0
6
1
:
v
i
X
r
a

Abstract

We introduce a new language learning
setting relevant to building adaptive nat-
It is inspired
ural language interfaces.
by Wittgenstein’s language games: a hu-
man wishes to accomplish some task
(e.g., achieving a certain conﬁguration of
blocks), but can only communicate with a
computer, who performs the actual actions
(e.g., removing all red blocks). The com-
puter initially knows nothing about lan-
guage and therefore must learn it from
scratch through interaction, while the hu-
man adapts to the computer’s capabilities.
We created a game called SHRDLURN in
a blocks world and collected interactions
from 100 people playing it. First, we an-
alyze the humans’ strategies, showing that
using compositionality and avoiding syn-
onyms correlates positively with task per-
formance. Second, we compare computer
strategies, showing that modeling prag-
matics on a semantic parsing model accel-
erates learning for more strategic players.

1

Introduction

Wittgenstein (1953) famously said that language
derives its meaning from use, and introduced the
concept of language games to illustrate the ﬂuid-
ity and purpose-orientedness of language. He de-
scribed how a builder B and an assistant A can use
a primitive language consisting of four words—
‘block’, ‘pillar’, ‘slab’, ‘beam’—to successfully
communicate what block to pass from A to B. This
is only one such language; many others would also
work for accomplishing the cooperative goal.

This paper operationalizes and explores the idea
of language games in a learning setting, which we
call interactive learning through language games

Figure 1: The SHRDLURN game: the objective
is to transform the start state into the goal state.
The human types in an utterance, and the computer
(which does not know the goal state) tries to in-
terpret the utterance and perform the correspond-
ing action. The computer initially knows nothing
about the language, but through the human’s feed-
back, learns the human’s language while making
progress towards the game goal.

(ILLG). In the ILLG setting, the two parties do not
initially speak a common language, but nonethe-
less need to collaboratively accomplish a goal.
Speciﬁcally, we created a game called SHRD-
LURN,1 in homage to the seminal work of Wino-
grad (1972). As shown in Figure 1, the objective
is to transform a start state into a goal state, but
the only action the human can take is entering an
utterance. The computer parses the utterance and
produces a ranked list of possible interpretations
according to its current model. The human scrolls
through the list and chooses the intended one, si-
multaneously advancing the state of the blocks and
providing feedback to the computer. Both the hu-
man and the computer wish to reach the goal state

1Demo: http://shrdlurn.sidaw.xyz

(only known to the human) with as little scrolling
as possible. For the computer to be successful, it
has to learn the human’s language quickly over the
course of the game, so that the human can accom-
plish the goal more efﬁciently. Conversely, the hu-
man must also accommodate the computer, at least
partially understanding what it can and cannot do.

We model the computer in the ILLG as a se-
mantic parser (Section 3), which maps natural lan-
guage utterances (e.g., ‘remove red’) into logical
forms (e.g., remove(with(red))). The seman-
tic parser has no seed lexicon and no annotated
logical forms, so it just generates many candidate
logical forms. Based on the human’s feedback, it
performs online gradient updates on the parame-
ters corresponding to simple lexical features.

During development,

it became evident that
while the computer was eventually able to learn
the language, it was learning less quickly than
one might hope. For example, after learning that
‘remove red’ maps to remove(with(red)),
it would think that ‘remove cyan’ also mapped
to remove(with(red)), whereas a human
would likely use mutual exclusivity to rule out that
hypothesis (Markman and Wachtel, 1988). We
therefore introduce a pragmatics model in which
the computer explicitly reasons about the human,
in the spirit of previous work on pragmatics (Gol-
land et al., 2010; Frank and Goodman, 2012;
Smith et al., 2013). To make the model suitable
for our ILLG setting, we introduce a new online
learning algorithm. Empirically, we show that our
pragmatic model improves the online accuracy by
8% compared to our best non-pragmatic model on
the 10 most successful players (Section 5.3).

What is special about the ILLG setting is the
real-time nature of learning, in which the human
also learns and adapts to the computer. While
the human can teach the computer any language—
English, Arabic, Polish, a custom programming
language—a good human player will choose to
use utterances that the computer is more likely to
learn quickly. In the parlance of communication
theory, the human accommodates the computer
(Giles, 2008; Ireland et al., 2011). Using Ama-
zon Mechanical Turk, we collected and analyzed
around 10k utterances from 100 games of SHRD-
LURN. We show that successful players tend to
use compositional utterances with a consistent vo-
cabulary and syntax, which matches the inductive
biases of the computer (Section 5.2). In addition,

through this interaction, many players adapt to the
computer by becoming more consistent, more pre-
cise, and more concise.

On the practical side, natural language systems
are often trained once and deployed, and users
must live with their imperfections. We believe
that studying the ILLG setting will be integral for
creating adaptive and customizable systems, es-
pecially for resource-poor languages and new do-
mains where starting from close to scratch is un-
avoidable.

2 Setting

(e.g.

We now describe the interactive learning of lan-
guage games (ILLG) setting formally. There are
two players, the human and the computer. The
game proceeds through a ﬁxed number of levels.
In each level, both players are presented with a
starting state s ∈ Y, but only the human sees
in SHRDLURN, Y
the goal state t ∈ Y.
is the set of all conﬁgurations of blocks). The
human transmits an utterance x (e.g., ‘remove
red’) to the computer. The computer then con-
structs a ranked list of candidate actions Z =
[z1, . . . , zK] ⊆ Z (e.g., remove(with(red)),
add(with(orange)), etc.), where Z is all
possible actions. For each zi ∈ Z, it computes
yi =
s, the successor state from executing ac-
(cid:75)
tion zi on state s. The computer returns to the hu-
man the ordered list Y = [y1, . . . , yK] of succes-
sor states. The human then chooses yi from the list
Y (we say the computer is correct if i = 1). The
state then updates to s = yi. The level ends when
s = t, and the players advance to the next level.

zi
(cid:74)

Since only the human knows the goal state t and
only the computer can perform actions, the only
way for the two to play the game successfully is
for the human to somehow encode the desired ac-
tion in the utterance x. However, we assume the
two players do not have a shared language, so the
human needs to pick a language and teach it to the
computer. As an additional twist, the human does
not know the exact set of actions Z (although they
might have some preconception of the computer’s
capabilities).2 Finally, the human only sees the
outcomes of the computer’s actions, not the actual
logical actions themselves.

We expect the game to proceed as follows: In
the beginning, the computer does not understand

2This is often the case when we try to interact with a new

software system or service before reading the manual.

what the human is saying and performs arbitrary
actions. As the computer obtains feedback and
learns, the two should become more proﬁcient at
communicating and thus playing the game. Herein
lies our key design principle: language learning
should be necessary for the players to achieve
good game performance.

SHRDLURN. Let us now describe the details
of our speciﬁc game, SHRDLURN. Each state
s ∈ Y consists of stacks of colored blocks ar-
ranged in a line (Figure 1), where each stack
The actions
is a vertical column of blocks.
Z are deﬁned compositionally via the gram-
mar in Table 1.
Each action either adds to
or removes from a set of stacks, and a set of
stacks is computed via various set operations
and selecting by color. For example, the action
remove(leftmost(with(red))) removes the
top block from the leftmost stack whose topmost
block is red. The compositionality of the actions
gives the computer non-trivial capabilities. Of
course, the human must teach a language to har-
ness those capabilities, while not quite knowing
the exact extent of the capabilities. The actual
game proceeds according to a curriculum, where
the earlier levels only need simpler actions with
fewer predicates.

We designed SHRDLURN in this way for sev-
eral reasons. First, visual block manipulations are
intuitive and can be easily crowdsourced, and it
can be fun as an actual game that people would
play. Second, the action space is designed to be
compositional, mirroring the structure of natural
language. Third, many actions z lead to the same
s; e.g., the ‘leftmost stack’
successor state y =
(cid:75)
might coincide with the ‘stack with red blocks’ for
some state s and therefore an action involving ei-
ther one would result in the same outcome. Since
the human only points out the correct y, the com-
puter must grapple with this indirect supervision,
a reﬂection of real language learning.

z
(cid:74)

3 Semantic parsing model

Following Zettlemoyer and Collins (2005) and
most recent work on semantic parsing, we use
a log-linear model over logical forms (actions)
z ∈ Z given an utterance x:

pθ(z | x) ∝ exp(θTφ(x, z)),

(1)

where φ(x, z) ∈ Rd is a feature vector and θ ∈ Rd
is a parameter vector. The denotation y (succes-

sor state) is obtained by executing z on a state s;
formally, y =

z
(cid:74)

s.
(cid:75)

Features. Our features are n-grams (including
skip-grams) conjoined with tree-grams on the log-
Speciﬁcally, on the utterance
ical form side.
side (e.g., ‘stack red on orange’), we use uni-
grams (‘stack’, ∗, ∗), bigrams (‘red’, ‘on’, ∗), tri-
grams (‘red’, ‘on’, ‘orange’), and skip-trigrams
(‘stack’, ∗, ‘on’). On the logical form side, fea-
tures corresponds to the predicates in the logical
forms and their arguments. For each predicate h,
let h.i be the i-th argument of h. Then, we de-
ﬁne tree-gram features ψ(h, d) for predicate h and
depth d = 0, 1, 2, 3 recursively as follows:

ψ(h, 0) = {h},

ψ(h, d) = {(h, i, ψ(h.i, d − 1)) | i = 1, 2, 3}.

The set of all features is just the cross product
of utterance features and logical form features.
if x = ‘enlever tout’ and z =
For example,
remove(all()), then features include:

(‘enlever’, all)
(‘enlever’, remove)
(‘enlever’, (remove, 1, all))
(‘tout’, (remove, 1, all))

(‘tout’, all)
(‘tout’, remove)

Note that we do not model an explicit alignment
or derivation compositionally connecting the utter-
ance and the logical form, in contrast to most tradi-
tional work in semantic parsing (Zettlemoyer and
Collins, 2005; Wong and Mooney, 2007; Liang
et al., 2011; Kwiatkowski et al., 2010; Berant
et al., 2013), instead following a looser model of
semantics similar to (Pasupat and Liang, 2015).
Modeling explicit alignments or derivations is
only computationally feasible when we are learn-
ing from annotated logical forms or have a seed
lexicon, since the number of derivations is much
larger than the number of logical forms.
In the
ILLG setting, neither are available.

Generation/parsing. We generate logical forms
from smallest
to largest using beam search.
Speciﬁcally, for each size n = 1, . . . , 8, we con-
struct a set of logical forms of size n (with ex-
actly n predicates) by combining logical forms of
smaller sizes according to the grammar rules in Ta-
ble 1. For each n, we keep the 100 logical forms z
with the highest score θTφ(x, z) according to the
current model θ. Let Z be the set of logical forms
on the ﬁnal beam, which contains logical forms
of all sizes n. During training, due to pruning at

Rule

Semantics

Description

Set
Color
Color → Set
Set → Set
Set → Set
Set Color → Act add(s, c)
Set → Act

remove(s)

all stacks

all()
cyan|brown|red|orange primitive color
with(c)
not(s)
leftmost|rightmost(s)

stacks whose top block has color c
all stacks except those in s
leftmost/rightmost stack in s
add block with color c on each stack in s
remove the topmost block of each stack in s

Table 1: The formal grammar deﬁning the compositional action space Z for SHRDLURN.
We use c to denote a Color, and s to denote a Set.
For example, one action that we
the leftmost brown block’
(cid:55)→
have in SHRDLURN is:
add(not(leftmost(with(brown))),orange).

‘add an orange block to all but

intermediate sizes, Z is not guaranteed to contain
the logical form that obtains the observed state y.
To mitigate this effect, we use a curriculum so that
only simple actions are needed in the initial levels,
giving the human an opportunity to teach the com-
puter about basic terms such as colors ﬁrst before
moving to larger composite actions.

The system executes all of the logical forms on
the ﬁnal beam Z, and orders the resulting denota-
tions y by the maximum probability of any logical
form that produced it.3

Learning. When the human provides feedback
in the form of a particular y, the system forms the
following loss function:

(cid:96)(θ, x, y) = − log pθ(y | x, s) + λ||θ||1,

pθ(y | x, s) =

pθ(z | x).

(2)

(3)

(cid:88)

z:

z
(cid:74)

s=y
(cid:75)

Then it makes a single gradient update using Ada-
Grad (Duchi et al., 2010), which maintains a per-
feature step size.

4 Modeling pragmatics

In our initial experience with the semantic pars-
ing model described in Section 3, we found
that it was able to learn reasonably well, but
lacked a reasoning ability that one ﬁnds in hu-
man learners. To illustrate the point, consider
the beginning of a game when θ = 0 in the
log-linear model pθ(z
Suppose that
human utters ‘remove red’ and then identiﬁes

| x).

3 We tried ordering based on the sum of the probabilities
(which corresponds to marginalizing out the logical form),
but this had the degenerate effect of assigning too much prob-
ability mass to y being the set of empty stacks, which can
result from many actions.

zrm-red = remove(with(red)) as the cor-
rect logical form. The computer then performs
a gradient update on the loss function (2), up-
weighting features such as (‘remove’, remove)
and (‘remove’, red).

Next, suppose the human utters ‘remove cyan’.
Note that zrm-red will score higher than all other
formulas since the (‘remove’, red) feature will
ﬁre again. While statistically justiﬁed, this be-
havior fails to meet our intuitive expectations for
a smart language learner. Moreover, this behav-
ior is not speciﬁc to our model, but applies to any
statistical model that simply tries to ﬁt the data
without additional prior knowledge about the spe-
ciﬁc language. While we would not expect the
computer to magically guess ‘remove cyan’
(cid:55)→
remove(with(cyan)), it should at least push
down the probability of zrm-red because zrm-red
intuitively is already well-explained by another ut-
terance ‘remove red’.

This phenomenon, mutual exclusivity, was stud-
ied by Markman and Wachtel (1988). They found
that children, during their language acquisition
process, reject a second label for an object and
treat it instead as a label for a novel object.

The pragmatic computer. To model mutual ex-
clusivity formally, we turn to probabilistic mod-
els of pragmatics (Golland et al., 2010; Frank and
Goodman, 2012; Smith et al., 2013; Goodman and
Lassiter, 2015), which operationalize the ideas of
Grice (1975). The central idea in these models is
to treat language as a cooperative game between
a speaker (human) and a listener (computer) as
we are doing, but where the listener has an ex-
plicit model of the speaker’s strategy, which in
turn models the listener. Formally, let S(x | z) be
the speaker’s strategy and L(z | x) be the listener’s

zrm-red

z3, z4, . . .

‘remove red’
‘remove cyan’

0.8
0.6

‘remove red’
‘remove cyan’

‘remove red’
‘remove cyan’

0.57
0.43

0.46
0.24

zrm-cyan
pθ(z | x)
0.1
0.2
S(x | z)
0.33
0.67
L(z | x)
0.27
0.38

0.1
0.2

0.33
0.67

0.27
0.38

top:

Table 2: Suppose the computer saw one exam-
ple of ‘remove red’ (cid:55)→zrm-red, and then the hu-
man utters ‘remove cyan’.
the literal lis-
tener, pθ(z | x), mistakingly chooses zrm-red
over zrm-cyan. middle:
the pragmatic speaker,
S(x | z), assigns a higher probability to to ‘remove
cyan’ given zrm-cyan; bottom: the pragmatic lis-
tener, L(z | x) correctly assigns a lower probabil-
ity to zrm-red where p(z) is uniform.

strategy. The speaker takes into account the literal
semantic parsing model pθ(z | x) as well as a prior
over utterances p(x), while the listener considers
the speaker S(x | z) and a prior p(z):

S(x | z) ∝ (pθ(z | x)p(x))β ,
L(z | x) ∝ S(x | z)p(z),

(4)

(5)

where β ≥ 1 is a hyperparameter that sharpens
the distribution (Smith et al., 2013). The com-
puter would then use L(z | x) to rank candidates
rather than pθ. Note that our pragmatic model only
affects the ranking of actions returned to the hu-
man and does not affect the gradient updates of
the model pθ.

Let us walk through a simple example to see the
effect of modeling pragmatics. Table 2 shows that
the literal listener pθ(z | x) assigns high probabil-
ity to zrm-red for both ‘remove red’ and ‘remove
cyan’. Assuming a uniform p(x) and β = 1, the
pragmatic speaker S(x | z) corresponds to normal-
izing each column of pθ. Note that if the pragmatic
speaker wanted to convey zrm-cyan, there is a de-
cent chance that they would favor ‘remove cyan’.
Next, assuming a uniform p(z), the pragmatic lis-
tener L(z | x) corresponds to normalizing each
row of S(x | z). The result is that conditioned on
‘remove cyan’, zrm-cyan is now more likely than
zrm-red, which is the desired effect.

The pragmatic listener models the speaker as a
cooperative agent who behaves in a way to max-
imize communicative success. Certain speaker

behaviors such as avoiding synonyms (e.g., not
‘delete cardinal’) and using a consistent word or-
dering (e.g, not ‘red remove’) fall out of the game
theory.4 For speakers that do not follow this strat-
egy, our pragmatic model is incorrect, but as we
get more data through game play, the literal lis-
tener pθ(z | x) will sharpen, so that the literal lis-
tener and the pragmatic listener will coincide in
the limit.

∀z, C(z) ← 0
∀z, Q(z) ← (cid:15)
repeat

receive utterance x from human
L(z | x) ∝ P (z)
Q(z) pθ(z | x)β
send human a list Y ranked by L(z | x)

receive y ∈ Y from human
θ ← θ − η∇θ(cid:96)(θ, x, y)
Q(z) ← Q(z) + pθ(z | x)β
C(z) ← C(z) + pθ(z | x,
P (z) ←

C(z)+α

(cid:80)

z(cid:48):C(z(cid:48))>0

z
(cid:74)

s = y)
(cid:75)
(cid:0)C(z(cid:48))+α(cid:1)

until game ends

Algorithm 1: Online learning algorithm that
updates the parameters of the semantic parser
θ as well as counts C, Q required to perform
pragmatic reasoning.

Online learning with pragmatics. To imple-
ment the pragmatic listener as deﬁned in (5), we
need to compute the speaker’s normalization con-
stant (cid:80)
x pθ(z | x)p(x) in order to compute S(x |
z) in (4). This requires parsing all utterances x
based on pθ(z | x). To avoid this heavy computa-
tion in an online setting, we propose Algorithm 1,
where some approximations are used for the sake
of efﬁciency. First, to approximate the intractable
sum over all utterances x, we only use the exam-
ples that are seen to compute the normalization
x pθ(z | x)p(x) ≈ (cid:80)
constant (cid:80)
i pθ(z | xi).
Then, in order to avoid parsing all previous exam-
ples again using the current parameters for each
new example, we store Q(z) = (cid:80)
i pθi(z | xi)β,
where θi is the parameter after the model updates
on the ith example xi. While θi is different from
the current parameter θ, pθ(z | xi) ≈ pθi(z | xi)
for the relevant example xi, which is accounted for

4 Of course, synonyms and variable word order occur in
real language. We would need a more complex game com-
pared to SHRDLURN to capture this effect.

by both θi and θ.

In Algorithm 1, the pragmatic listener L(z | x)
can be interpreted as an importance-weighted ver-
sion of the sharpened literal listener pβ
θ , where it
is downweighted by Q(z), which reﬂects which
z’s the literal listener prefers, and upweighted by
P (z), which is just a smoothed estimate of the ac-
tual distribution over logical forms p(z). By con-
struction, Algorithm 1 is the same as (4) except
that it uses the normalization constant Q based on
stale parameters θi after seeing example, and it
uses samples to compute the sum over x. Follow-
ing (5), we also need p(z), which is estimated by
P (z) using add-α smoothing on the counts C(z).
Note that Q(z) and C(z) are updated after the
model parameters are updated for the current ex-
ample.

z
(cid:74)

z
(cid:74)

z
(cid:74)

Lastly, there is a small complication due to only
observing the denotation y and not the logical
form z. We simply give each consistent logical
s = y} a pseudocount based on
form {z |
(cid:75)
the model: C(z) ← C(z) + pθ(z | x,
s = y)
(cid:75)
s = y) ∝ exp(θTφ(x, z)) for
where pθ(z | x,
(cid:75)
z
(cid:74)

s = y (0 otherwise).
(cid:75)
Compared to prior work where the setting is
speciﬁcally designed to require pragmatic infer-
ence, pragmatics arises naturally in ILLG. We
think that this form of pragmatics is the most im-
portant during learning, and becomes less impor-
tant if we had more data. Indeed, if we have a lot
of data and a small number of possible zs, then
L(z|x) ≈ pθ(z|x) as (cid:80)
x pθ(z|x)p(x) → p(z)
when β = 1.5 However, for semantic parsing,
we would not be in this regime even if we have
a large amount of training data. In particular, we
are nowhere near that regime in SHRDLURN, and
most of our utterances / logical forms are seen only
once, and the importance of modeling pragmatics
remains.

5 Experiments

5.1 Setting

Data. Using Amazon Mechanical Turk (AMT),
we paid 100 workers 3 dollars each to play SHRD-
LURN. In total, we have 10223 utterances along
with their starting states s. Of these, 8874 ut-
terances are labeled with their denotations y; the
rest are unlabeled, since the player can try any ut-
terance without accepting an action. 100 players
completed the entire game under identical settings.

5Technically, we also need pθ to be well-speciﬁed.

We deliberately chose to start from scratch for ev-
ery worker, so that we can study the diversity of
strategies that different people used in a controlled
setting.

Each game consists of 50 blocks tasks divided
into 5 levels of 10 tasks each, in increasing com-
plexity. Each level aims to reach an end goal
given a start state. Each game took on average
89 utterances to complete.6 It only took 6 hours
to complete these 100 games on AMT and each
game took around an hour on average according to
AMT’s work time tracker (which does not account
for multi-tasking players). The players were pro-
vided minimal instructions on the game controls.
Importantly, we gave no example utterances in or-
der to avoid biasing their language use. Around
20 players were confused and told us that the in-
structions were not clear and gave us mostly spam
utterances. Fortunately, most players understood
the setting and some even enjoyed SHRDLURN
as reﬂected by their optional comments:

• That was probably the most fun thing I have

ever done on mTurk.

• Wow this was one mind bending games [sic].

Metrics. We use the number of scrolls as a mea-
sure of game performance for each player. For
each example, the number of scrolls is the position
in the list Y of the action selected by the player. It
was possible to complete this version of SHRD-
LURN by scrolling (all actions can be found in
the ﬁrst 125 of Y )—22 of the 100 players failed to
teach an actual language, and instead ﬁnished the
game mostly by scrolling. Let us call them spam
players, who usually typed single letters, random
words, digits, or random phrases (e.g. ‘how are
you’). Overall, spam players had to scroll a lot:
21.6 scrolls per utterance versus only 7.4 for the
non-spam players.

5.2 Human strategies

Some example utterances can be found in Table 3.
Most of the players used English, but vary in their
adherence to conventions such as use of determin-
ers, plurals, and proper word ordering. 5 players
invented their own language, which are more pre-
cise, more consistent than general English. One
player used Polish, and another used Polish nota-
tion (bottom of Table 3).

6 This number is not 50 because some block tasks need
multiple steps and players are also allowed to explore without
reaching the goal.

Most successful players (1st–20th)

rem cy pos 1, stack or blk pos 4, rem
blk pos 2 thru 5, rem blk pos 2 thru 4,
stack bn blk pos 1 thru 2, ﬁll bn blk,
stack or blk pos 2 thru 6, rem cy blk
pos 2 ﬁll rd blk (3.01)

remove the brown block, remove all
orange blocks, put brown block on
orange blocks, put orange blocks on
all blocks, put blue block on leftmost
blue block in top row (2.78)

Average players (21th–50th)

Remove the center block, Remove the
red block, Remove all red blocks,
Remove the ﬁrst orange block, Put a
brown block on the ﬁrst brown block,
Add blue block on ﬁrst blue block
(2.72)

reinsert pink, take brown, put in pink,
remove two pink from second layer,
Add two red to second layer in odd
intervals, Add ﬁve pink to second
layer, Remove one blue and one
brown from bottom layer (9.17)

remove red, remove 1 red, remove 2 4
orange, add 2 red, add 1 2 3 4 blue,
emove 1 3 5 orange, add 2 4 orange,
add 2 orange, remove 2 3 brown, add
1 2 3 4 5 red, remove 2 3 4 5 6,
remove 2, add 1 2 3 4 6 red (8.37)

move second cube, double red with
blue, double ﬁrst red with red, triple
second and fourth with orange, add
red, remove orange on row two, add
blue to column two, add brown on
ﬁrst and third (7.18)

holdleftmost, holdbrown,
holdleftmost, blueonblue,
brownonblue1, blueonorange,
holdblue, holdorange2, blueonred2 ,
holdends1, holdrightend, hold2,
orangeonorangerightmost (14.15)

usu´n br ˛azowe klocki, postaw
pomara´nczowy klocek na pierwszym
klocku, postaw czerwone klocki na
pomara´nczowych, usu´n
pomara´nczowe klocki w górnym
rz˛edzie

Least successful players (51th–)

‘add red cubes on center left, center
right, far left and far right’, ‘remove
blue blocks on row two column two,
row two column four’, remove red
blocks in center left and center right
on second row (12.6)

Spam players (∼ 85th–100)

Most interesting

rm scat + 1 c, + 1 c, rm sh, + 1 2 4 sh,
+ 1 c, - 4 o, rm 1 r, + 1 3 o, full ﬁll c,
rm o, full ﬁll sh, - 1 3, full ﬁll sh, rm
sh, rm r, + 2 3 r, rm o, + 3 sh, + 2 3
sh, rm b, - 1 o, + 2 c,

laugh with me, red blocks with one
aqua, aqua red alternate, brown red
red orange aqua orange, red brown
red brown red brown, space red
orange red, second level red space red
space red space (14.32)

mBROWN,mBLUE,mORANGE
RED+ORANGEˆORANGE,
BROWN+BROWNm1+BROWNm3,
ORANGE +BROWN
+ORANGEˆm1+ ORANGEˆm3 +
BROWNˆˆ2 + BROWNˆˆ4

next, hello happy, how are you, move, gold, build goal blocks, 23,house, gabboli, x, run„xav, d, j, xcv, dulicate goal (21.7)

Table 3: Example utterances, along with the average number of scrolls for that player in parentheses.
Success is measured by the number of scrolls, where the more successful players need less scrolls. 1)
The 20 most successful players tend to use consistent and concise language whose semantics is similar
to our logical language. 2) Average players tend to be slightly more verbose and inconsistent (left and
right), or signiﬁcantly different from our logical langauge (middle). 3) Reasons for being unsuccessful
vary. Left: no tokenization, middle: used a coordinate system and many conjunctions; right: confused in
the beginning, and used a language very different from our logical language.

Overall, we ﬁnd that many players adapt in
ILLG by becoming more consistent, less verbose,
and more precise, even if they used standard En-
glish at the beginning. For example, some players
became more consistent over time (e.g. from us-
ing both ‘remove’ and ‘discard’ to only using ‘re-
move’). In terms of verbosity, removing function
words like determiners as the game progresses is
In each of the following
a common adaptation.
examples from different players, we compare an
utterance that appeared early in the game to a sim-
ilar utterance that appeared later: ‘Remove the red
ones’ became ‘Remove red.’; ‘add brown on top of
red’ became ‘add orange on red’; ‘add red blocks
to all red blocks’ became ‘add red to red’; ‘dark
red’ became ‘red’; one player used ‘the’ in all of
the ﬁrst 20 utterances, and then never used ‘the’ in
the last 75 utterances.

Players also vary in precision, ranging from
overspeciﬁed (e.g. ‘remove the orange cube at the
left’, ‘remove red blocks from top row’) to under-
speciﬁed or requiring context (e.g. ‘change col-
ors’, ‘add one blue’, ‘Build more blocus’, ‘Move
the blocks fool’,‘Add two red cubes’). We found
that some players became more precise over time,
as they gain a better understanding of ILLG.

Most players use utterances that actually do not
match our logical language in Table 1, even the
successful players. In particular, numbers are of-
ten used. While some concepts always have the
same effect in our blocks world (e.g. ‘ﬁrst block’
means leftmost), most are different. More con-
cretely, of the top 10 players, 7 used numbers of
some form and only 3 players matched our logical
language. Some players who did not match the
logical language performed quite well neverthe-

less. One possible explanation is because the ac-
tion required is somewhat constrained by the logi-
cal language and some tokens can have unintended
interpretations. For example, the computer can
correctly interpret numerical positional references,
as long as the player only refers to the leftmost
and rightmost positions. So if the player says ‘rem
blk pos 4’ and ‘rem blk pos 1’, the computer can
interpret ‘pos’ as rightmost and interpret the
bigram (‘pos’, ‘1’) as leftmost. On the other
hand, players who deviated signiﬁcantly by de-
scribing the desired state declaratively (e.g. ‘red
orange red’, ‘246’) rather than using actions, or
a coordinate system (e.g. ‘row two column two’)
performed poorly. Although players do not have
to match our logical language exactly to perform
well, being similar is deﬁnitely helpful.

Compositionality. As far as we can tell, all
players used a compositional language; no one in-
vented unrelated words for each action. Interest-
ingly, 3 players did not put spaces between words.
Since we assume monomorphemic words sepa-
rated by spaces, they had to do a lot of scrolling
as a result (e.g., 14.15 with utterances like ‘or-
angeonorangerightmost’).

5.3 Computer strategies

We now present quantitative results on how
quickly the computer can learn, where our goal is
to achieve high accuracy on new utterances as we
make just a single pass over the data. The num-
ber of scrolls used to evaluate player is sensitive to
outliers and not as intuitive as accuracy. Instead,
we consider online accuracy, described as follows.
Formally, if a player produced T utterances x(j)
and labeled them y(j), then

online accuracy

def=

1
T

T
(cid:88)

(cid:104)

I

j=1

y(j) =

(cid:105)

,

z(j)
(cid:74)

s(j)
(cid:75)

where z(j) = arg maxz pθ(j−1)(z|x(j)) is the
model prediction based on the previous parame-
ter θ(j−1). Note that the online accuracy is de-
ﬁned with respect to the player-reported labels,
which only corresponds to the actual accuracy if
the player is precise and honest. This is not true
for most spam players.

Compositionality. To study the importance of
compositionality, we consider
two baselines.
First, consider a non-compositional model (mem-

(a)

(b)

Figure 2: Pragmatics improve online accuracy. In
these plots, each marker is a player. red o: play-
ers who ranked 1–20 in terms of minimizing num-
ber of scrolls, green x: players 20–50; blue +:
lower than 50 (includes spam players). Marker
sizes correspond to player rank, where better play-
ers are depicted with larger markers. 2a: online
accuracies with and without pragmatics on the full
model; 2b: same for the half model.

Method
memorize
half model
half + prag
full model
full + prag

players ranked by # of scrolls

top 10
25.4
38.7
43.7
48.6
52.8

top 20
24.5
38.4
42.7
47.8
49.8

top 50
22.5
36.0
39.7
44.9
45.8

all 100
17.6
27.0
29.4
33.3
33.8

Table 4: Average online accuracy under vari-
featurize entire utter-
ous settings. memorize:
ance and logical form non-compositionally; half
model: featurize the utterances with unigrams, bi-
grams, and skip-grams but conjoin with the entire
logical form; full model: the model described in
Section 3; +prag: the models above, with our on-
line pragmatics algorithm described in Section 4.
Both compositionality and pragmatics improve ac-
curacy.

orize) that just remembers pairs of complete ut-
terance and logical forms. We implement this
using indicator features on features (x, z), e.g.,
(‘remove all the red blocks’, zrm-red), and use a
large learning rate.
Second, we consider a
model (half ) that treats utterances composition-
ally with unigrams, bigrams, and skip-trigrams
features, but the logical forms are regarded as
non-compositional, so we have features such as
(‘remove’, zrm-red), (‘red’, zrm-red), etc.

Table 4 shows that the full model (Section 3)
signiﬁcantly outperforms both the memorize and
half baselines. The learning rate η = 0.1 is se-
lected via cross validation, and we used α = 1
and β = 3 following Smith et al. (2013).

Pragmatics. Next, we study the effect of prag-
Figure 2 shows
matics on online accuracy.
that modeling pragmatics helps successful players
(e.g., top 10 by number of scrolls) who use precise
and consistent languages. Interestingly, our prag-
matics model did not help and can even hurt the
less successful players who are less precise and
consistent. This is expected behavior: the prag-
matics model assumes that the human is coopera-
tive and behaving rationally. For the bottom half
of the players, this assumption is not true, in which
case the pragmatics model is not useful.

6 Related Work and Discussion

Our work connects with a broad body of work on
grounded language, in which language is used in
some environment as a means towards some goal.
Examples include playing games (Branavan et al.,
2009, 2010; Reckman et al., 2010) interacting with
robotics (Tellex et al., 2011, 2014), and following
instructions (Vogel and Jurafsky, 2010; Chen and
Mooney, 2011; Artzi and Zettlemoyer, 2013) Se-
mantic parsing utterances to logical forms, which
we leverage, plays an important role in these set-
tings (Kollar et al., 2010; Matuszek et al., 2012;
Artzi and Zettlemoyer, 2013).

What makes this work unique is our new inter-
active learning of language games (ILLG) setting,
in which a model has to learn a language from
scratch through interaction. While online gradient
descent is frequently used, for example in seman-
tic parsing (Zettlemoyer and Collins, 2007; Chen,
2012), we using it in a truly online setting, taking
one pass over the data and measuring online accu-
racy (Cesa-Bianchi and Lugosi, 2006).

To speed up learning, we leverage computa-
tional models of pragmatics (Jäger, 2008; Golland
et al., 2010; Frank and Goodman, 2012; Smith
et al., 2013; Vogel et al., 2013). The main differ-
ence is these previous works use pragmatics with
a trained base model, whereas we learn the model
online. Monroe and Potts (2015) uses learning
to improve the pragmatics model.
In contrast,
we use pragmatics to speed up the learning pro-
cess by capturing phenomena like mutual exclu-
sivity (Markman and Wachtel, 1988). We also dif-
fer from prior work in several details. First, we
model pragmatics in the online learning setting
where we use an online update for the pragmat-
ics model. Second, unlikely the reference games
where pragmatic effects plays an important role by

design, SHRDLURN is not speciﬁcally designed
to require pragmatics. The improvement we get
is mainly due to players trying to be consistent in
their language use. Finaly, we treat both the utter-
ance and the logical forms as featurized composi-
tional objects. Smith et al. (2013) treats utterances
(i.e. words) and logical forms (i.e. objects) as cat-
egories; Monroe and Potts (2015) used features,
but also over ﬂat categories.

Looking forward, we believe that the ILLG set-
ting is worth studying and has important implica-
tions for natural language interfaces. Today, these
If these
systems are trained once and deployed.
systems could quickly adapt to user feedback in
real-time as in this work, then we might be able
to more readily create systems for resource-poor
languages and new domains, that are customizable
and improve through use.

Acknowledgments

DARPA Communicating with Computers (CwC)
program under ARO prime contract no. W911NF-
15-1-0462. The ﬁrst author is supported by a
NSERC PGS-D fellowship. In addition, we thank
Will Monroe, and Chris Potts for their insightful
comments and discussions on pragmatics.

Reproducibility

All code, data, and experiments for this paper are
available on the CodaLab platform:
https://worksheets.

codalab.org/worksheets/

0x9fe4d080bac944e9a6bd58478cb05e5e
The client side code is here:
https://github.com/sidaw/shrdlurn/tree/

acl16-demo
and a demo: http://shrdlurn.sidaw.xyz

References

Y. Artzi and L. Zettlemoyer. 2013. Weakly super-
vised learning of semantic parsers for mapping
instructions to actions. Transactions of the As-
sociation for Computational Linguistics (TACL)
1:49–62.

J. Berant, A. Chou, R. Frostig, and P. Liang. 2013.
Semantic parsing on Freebase from question-
answer pairs. In Empirical Methods in Natural
Language Processing (EMNLP).

S. Branavan, H. Chen, L. S. Zettlemoyer, and
R. Barzilay. 2009. Reinforcement learning for

In Associa-
mapping instructions to actions.
tion for Computational Linguistics and Inter-
national Joint Conference on Natural Language
Processing (ACL-IJCNLP). pages 82–90.

T. Kollar, S. Tellex, D. Roy, and N. Roy. 2010.
Grounding verbs of motion in natural language
commands to robots. In International Sympo-
sium on Experimental Robotics (ISER).

S. Branavan, L. Zettlemoyer, and R. Barzilay.
2010. Reading between the lines: Learning
to map high-level instructions to commands.
In Association for Computational Linguistics
(ACL). pages 1268–1277.

N. Cesa-Bianchi and G. Lugosi. 2006. Predic-
tion, learning, and games. Cambridge Univer-
sity Press.

D. L. Chen. 2012. Fast online lexicon learning for
grounded language acquisition. In Association
for Computational Linguistics (ACL).

D. L. Chen and R. J. Mooney. 2011. Learning
to interpret natural language navigation instruc-
tions from observations. In Association for the
Advancement of Artiﬁcial Intelligence (AAAI).
pages 859–865.

J. Duchi, E. Hazan, and Y. Singer. 2010. Adap-
tive subgradient methods for online learning
and stochastic optimization. In Conference on
Learning Theory (COLT).

M. Frank and N. D. Goodman. 2012. Predicting
pragmatic reasoning in language games. Sci-
ence 336:998–998.

H. Giles. 2008. Communication accommodation

theory. Sage Publications, Inc.

D. Golland, P. Liang, and D. Klein. 2010. A game-
theoretic approach to generating spatial descrip-
In Empirical Methods in Natural Lan-
tions.
guage Processing (EMNLP).

N. Goodman and D. Lassiter. 2015. Probabilistic
Semantics and Pragmatics: Uncertainty in Lan-
guage and Thought. The Handbook of Contem-
porary Semantic Theory, 2nd Edition Wiley-
Blackwell.

H. P. Grice. 1975. Logic and conversation. Syntax

and semantics 3:41–58.

M. E. Ireland, R. B. Slatcher, P. W. Eastwick, L. E.
Scissors, E. J. Finkel, and J. W. Pennebaker.
2011. Language style matching predicts rela-
tionship initiation and stability. Psychological
Science 22(1):39–44.

G. Jäger. 2008. Game theory in semantics and
pragmatics. Technical report, University of
Tübingen.

T. Kwiatkowski, L. Zettlemoyer, S. Goldwater,
and M. Steedman. 2010. Inducing probabilistic
CCG grammars from logical form with higher-
In Empirical Methods in
order uniﬁcation.
Natural Language Processing (EMNLP). pages
1223–1233.

P. Liang, M. I. Jordan, and D. Klein. 2011.
Learning dependency-based compositional se-
mantics. In Association for Computational Lin-
guistics (ACL). pages 590–599.

E. Markman and G. F. Wachtel. 1988. Children’s
use of mutual exclusivity to constrain the mean-
ings of words. Cognitive Psychology 20:125–
157.

C. Matuszek, N. FitzGerald, L. Zettlemoyer,
L. Bo, and D. Fox. 2012. A joint model of
language and perception for grounded attribute
In International Conference on Ma-
learning.
chine Learning (ICML). pages 1671–1678.

W. Monroe and C. Potts. 2015. Learning in the
Rational Speech Acts model. In Proceedings of
20th Amsterdam Colloquium.

P. Pasupat and P. Liang. 2015. Compositional se-
mantic parsing on semi-structured tables. In As-
sociation for Computational Linguistics (ACL).

H. Reckman, J. Orkin, and D. Roy. 2010. Learning
meanings of words and constructions, grounded
In Conference on Natural
in a virtual game.
Language Processing (KONVENS).

N. J. Smith, N. D. Goodman, and M. C. Frank.
2013. Learning and using language via re-
cursive pragmatic reasoning about other agents.
In Advances in Neural Information Processing
Systems (NIPS).

S. Tellex, R. Knepper, A. Li, D. Rus, and N. Roy.
2014. Asking for help using inverse semantics.
In Robotics: Science and Systems (RSS).

S. Tellex, T. Kollar, S. Dickerson, M. R. Walter,
A. G. Banerjee, S. J. Teller, and N. Roy. 2011.
Understanding natural language commands for
robotic navigation and mobile manipulation. In
Association for the Advancement of Artiﬁcial
Intelligence (AAAI).

A. Vogel, M. Bodoia, C. Potts, and D. Juraf-
sky. 2013. Emergence of gricean maxims from

In North Ameri-
multi-agent decision theory.
can Association for Computational Linguistics
(NAACL). pages 1072–1081.

A. Vogel and D. Jurafsky. 2010. Learning to fol-
low navigational directions. In Association for
Computational Linguistics (ACL). pages 806–
814.

T. Winograd. 1972. Understanding Natural Lan-

guage. Academic Press.

L. Wittgenstein. 1953. Philosophical Investiga-

tions. Blackwell, Oxford.

Y. W. Wong and R. J. Mooney. 2007. Learn-
ing synchronous grammars for semantic parsing
with lambda calculus. In Association for Com-
putational Linguistics (ACL). pages 960–967.

L. S. Zettlemoyer and M. Collins. 2005. Learn-
ing to map sentences to logical form: Struc-
tured classiﬁcation with probabilistic categorial
In Uncertainty in Artiﬁcial Intelli-
grammars.
gence (UAI). pages 658–666.

L. S. Zettlemoyer and M. Collins. 2007. Online
learning of relaxed CCG grammars for parsing
to logical form. In Empirical Methods in Nat-
ural Language Processing and Computational
Natural Language Learning (EMNLP/CoNLL).
pages 678–687.

Learning Language Games through Interaction

Sida I. Wang

Percy Liang

Christopher D. Manning

Computer Science Department
Stanford University
{sidaw,pliang,manning}@cs.stanford.edu

6
1
0
2
 
n
u
J
 
8
 
 
]
L
C
.
s
c
[
 
 
1
v
7
4
4
2
0
.
6
0
6
1
:
v
i
X
r
a

Abstract

We introduce a new language learning
setting relevant to building adaptive nat-
It is inspired
ural language interfaces.
by Wittgenstein’s language games: a hu-
man wishes to accomplish some task
(e.g., achieving a certain conﬁguration of
blocks), but can only communicate with a
computer, who performs the actual actions
(e.g., removing all red blocks). The com-
puter initially knows nothing about lan-
guage and therefore must learn it from
scratch through interaction, while the hu-
man adapts to the computer’s capabilities.
We created a game called SHRDLURN in
a blocks world and collected interactions
from 100 people playing it. First, we an-
alyze the humans’ strategies, showing that
using compositionality and avoiding syn-
onyms correlates positively with task per-
formance. Second, we compare computer
strategies, showing that modeling prag-
matics on a semantic parsing model accel-
erates learning for more strategic players.

1

Introduction

Wittgenstein (1953) famously said that language
derives its meaning from use, and introduced the
concept of language games to illustrate the ﬂuid-
ity and purpose-orientedness of language. He de-
scribed how a builder B and an assistant A can use
a primitive language consisting of four words—
‘block’, ‘pillar’, ‘slab’, ‘beam’—to successfully
communicate what block to pass from A to B. This
is only one such language; many others would also
work for accomplishing the cooperative goal.

This paper operationalizes and explores the idea
of language games in a learning setting, which we
call interactive learning through language games

Figure 1: The SHRDLURN game: the objective
is to transform the start state into the goal state.
The human types in an utterance, and the computer
(which does not know the goal state) tries to in-
terpret the utterance and perform the correspond-
ing action. The computer initially knows nothing
about the language, but through the human’s feed-
back, learns the human’s language while making
progress towards the game goal.

(ILLG). In the ILLG setting, the two parties do not
initially speak a common language, but nonethe-
less need to collaboratively accomplish a goal.
Speciﬁcally, we created a game called SHRD-
LURN,1 in homage to the seminal work of Wino-
grad (1972). As shown in Figure 1, the objective
is to transform a start state into a goal state, but
the only action the human can take is entering an
utterance. The computer parses the utterance and
produces a ranked list of possible interpretations
according to its current model. The human scrolls
through the list and chooses the intended one, si-
multaneously advancing the state of the blocks and
providing feedback to the computer. Both the hu-
man and the computer wish to reach the goal state

1Demo: http://shrdlurn.sidaw.xyz

(only known to the human) with as little scrolling
as possible. For the computer to be successful, it
has to learn the human’s language quickly over the
course of the game, so that the human can accom-
plish the goal more efﬁciently. Conversely, the hu-
man must also accommodate the computer, at least
partially understanding what it can and cannot do.

We model the computer in the ILLG as a se-
mantic parser (Section 3), which maps natural lan-
guage utterances (e.g., ‘remove red’) into logical
forms (e.g., remove(with(red))). The seman-
tic parser has no seed lexicon and no annotated
logical forms, so it just generates many candidate
logical forms. Based on the human’s feedback, it
performs online gradient updates on the parame-
ters corresponding to simple lexical features.

During development,

it became evident that
while the computer was eventually able to learn
the language, it was learning less quickly than
one might hope. For example, after learning that
‘remove red’ maps to remove(with(red)),
it would think that ‘remove cyan’ also mapped
to remove(with(red)), whereas a human
would likely use mutual exclusivity to rule out that
hypothesis (Markman and Wachtel, 1988). We
therefore introduce a pragmatics model in which
the computer explicitly reasons about the human,
in the spirit of previous work on pragmatics (Gol-
land et al., 2010; Frank and Goodman, 2012;
Smith et al., 2013). To make the model suitable
for our ILLG setting, we introduce a new online
learning algorithm. Empirically, we show that our
pragmatic model improves the online accuracy by
8% compared to our best non-pragmatic model on
the 10 most successful players (Section 5.3).

What is special about the ILLG setting is the
real-time nature of learning, in which the human
also learns and adapts to the computer. While
the human can teach the computer any language—
English, Arabic, Polish, a custom programming
language—a good human player will choose to
use utterances that the computer is more likely to
learn quickly. In the parlance of communication
theory, the human accommodates the computer
(Giles, 2008; Ireland et al., 2011). Using Ama-
zon Mechanical Turk, we collected and analyzed
around 10k utterances from 100 games of SHRD-
LURN. We show that successful players tend to
use compositional utterances with a consistent vo-
cabulary and syntax, which matches the inductive
biases of the computer (Section 5.2). In addition,

through this interaction, many players adapt to the
computer by becoming more consistent, more pre-
cise, and more concise.

On the practical side, natural language systems
are often trained once and deployed, and users
must live with their imperfections. We believe
that studying the ILLG setting will be integral for
creating adaptive and customizable systems, es-
pecially for resource-poor languages and new do-
mains where starting from close to scratch is un-
avoidable.

2 Setting

(e.g.

We now describe the interactive learning of lan-
guage games (ILLG) setting formally. There are
two players, the human and the computer. The
game proceeds through a ﬁxed number of levels.
In each level, both players are presented with a
starting state s ∈ Y, but only the human sees
in SHRDLURN, Y
the goal state t ∈ Y.
is the set of all conﬁgurations of blocks). The
human transmits an utterance x (e.g., ‘remove
red’) to the computer. The computer then con-
structs a ranked list of candidate actions Z =
[z1, . . . , zK] ⊆ Z (e.g., remove(with(red)),
add(with(orange)), etc.), where Z is all
possible actions. For each zi ∈ Z, it computes
yi =
s, the successor state from executing ac-
(cid:75)
tion zi on state s. The computer returns to the hu-
man the ordered list Y = [y1, . . . , yK] of succes-
sor states. The human then chooses yi from the list
Y (we say the computer is correct if i = 1). The
state then updates to s = yi. The level ends when
s = t, and the players advance to the next level.

zi
(cid:74)

Since only the human knows the goal state t and
only the computer can perform actions, the only
way for the two to play the game successfully is
for the human to somehow encode the desired ac-
tion in the utterance x. However, we assume the
two players do not have a shared language, so the
human needs to pick a language and teach it to the
computer. As an additional twist, the human does
not know the exact set of actions Z (although they
might have some preconception of the computer’s
capabilities).2 Finally, the human only sees the
outcomes of the computer’s actions, not the actual
logical actions themselves.

We expect the game to proceed as follows: In
the beginning, the computer does not understand

2This is often the case when we try to interact with a new

software system or service before reading the manual.

what the human is saying and performs arbitrary
actions. As the computer obtains feedback and
learns, the two should become more proﬁcient at
communicating and thus playing the game. Herein
lies our key design principle: language learning
should be necessary for the players to achieve
good game performance.

SHRDLURN. Let us now describe the details
of our speciﬁc game, SHRDLURN. Each state
s ∈ Y consists of stacks of colored blocks ar-
ranged in a line (Figure 1), where each stack
The actions
is a vertical column of blocks.
Z are deﬁned compositionally via the gram-
mar in Table 1.
Each action either adds to
or removes from a set of stacks, and a set of
stacks is computed via various set operations
and selecting by color. For example, the action
remove(leftmost(with(red))) removes the
top block from the leftmost stack whose topmost
block is red. The compositionality of the actions
gives the computer non-trivial capabilities. Of
course, the human must teach a language to har-
ness those capabilities, while not quite knowing
the exact extent of the capabilities. The actual
game proceeds according to a curriculum, where
the earlier levels only need simpler actions with
fewer predicates.

We designed SHRDLURN in this way for sev-
eral reasons. First, visual block manipulations are
intuitive and can be easily crowdsourced, and it
can be fun as an actual game that people would
play. Second, the action space is designed to be
compositional, mirroring the structure of natural
language. Third, many actions z lead to the same
s; e.g., the ‘leftmost stack’
successor state y =
(cid:75)
might coincide with the ‘stack with red blocks’ for
some state s and therefore an action involving ei-
ther one would result in the same outcome. Since
the human only points out the correct y, the com-
puter must grapple with this indirect supervision,
a reﬂection of real language learning.

z
(cid:74)

3 Semantic parsing model

Following Zettlemoyer and Collins (2005) and
most recent work on semantic parsing, we use
a log-linear model over logical forms (actions)
z ∈ Z given an utterance x:

pθ(z | x) ∝ exp(θTφ(x, z)),

(1)

where φ(x, z) ∈ Rd is a feature vector and θ ∈ Rd
is a parameter vector. The denotation y (succes-

sor state) is obtained by executing z on a state s;
formally, y =

z
(cid:74)

s.
(cid:75)

Features. Our features are n-grams (including
skip-grams) conjoined with tree-grams on the log-
Speciﬁcally, on the utterance
ical form side.
side (e.g., ‘stack red on orange’), we use uni-
grams (‘stack’, ∗, ∗), bigrams (‘red’, ‘on’, ∗), tri-
grams (‘red’, ‘on’, ‘orange’), and skip-trigrams
(‘stack’, ∗, ‘on’). On the logical form side, fea-
tures corresponds to the predicates in the logical
forms and their arguments. For each predicate h,
let h.i be the i-th argument of h. Then, we de-
ﬁne tree-gram features ψ(h, d) for predicate h and
depth d = 0, 1, 2, 3 recursively as follows:

ψ(h, 0) = {h},

ψ(h, d) = {(h, i, ψ(h.i, d − 1)) | i = 1, 2, 3}.

The set of all features is just the cross product
of utterance features and logical form features.
if x = ‘enlever tout’ and z =
For example,
remove(all()), then features include:

(‘enlever’, all)
(‘enlever’, remove)
(‘enlever’, (remove, 1, all))
(‘tout’, (remove, 1, all))

(‘tout’, all)
(‘tout’, remove)

Note that we do not model an explicit alignment
or derivation compositionally connecting the utter-
ance and the logical form, in contrast to most tradi-
tional work in semantic parsing (Zettlemoyer and
Collins, 2005; Wong and Mooney, 2007; Liang
et al., 2011; Kwiatkowski et al., 2010; Berant
et al., 2013), instead following a looser model of
semantics similar to (Pasupat and Liang, 2015).
Modeling explicit alignments or derivations is
only computationally feasible when we are learn-
ing from annotated logical forms or have a seed
lexicon, since the number of derivations is much
larger than the number of logical forms.
In the
ILLG setting, neither are available.

Generation/parsing. We generate logical forms
from smallest
to largest using beam search.
Speciﬁcally, for each size n = 1, . . . , 8, we con-
struct a set of logical forms of size n (with ex-
actly n predicates) by combining logical forms of
smaller sizes according to the grammar rules in Ta-
ble 1. For each n, we keep the 100 logical forms z
with the highest score θTφ(x, z) according to the
current model θ. Let Z be the set of logical forms
on the ﬁnal beam, which contains logical forms
of all sizes n. During training, due to pruning at

Rule

Semantics

Description

Set
Color
Color → Set
Set → Set
Set → Set
Set Color → Act add(s, c)
Set → Act

remove(s)

all stacks

all()
cyan|brown|red|orange primitive color
with(c)
not(s)
leftmost|rightmost(s)

stacks whose top block has color c
all stacks except those in s
leftmost/rightmost stack in s
add block with color c on each stack in s
remove the topmost block of each stack in s

Table 1: The formal grammar deﬁning the compositional action space Z for SHRDLURN.
We use c to denote a Color, and s to denote a Set.
For example, one action that we
the leftmost brown block’
(cid:55)→
have in SHRDLURN is:
add(not(leftmost(with(brown))),orange).

‘add an orange block to all but

intermediate sizes, Z is not guaranteed to contain
the logical form that obtains the observed state y.
To mitigate this effect, we use a curriculum so that
only simple actions are needed in the initial levels,
giving the human an opportunity to teach the com-
puter about basic terms such as colors ﬁrst before
moving to larger composite actions.

The system executes all of the logical forms on
the ﬁnal beam Z, and orders the resulting denota-
tions y by the maximum probability of any logical
form that produced it.3

Learning. When the human provides feedback
in the form of a particular y, the system forms the
following loss function:

(cid:96)(θ, x, y) = − log pθ(y | x, s) + λ||θ||1,

pθ(y | x, s) =

pθ(z | x).

(2)

(3)

(cid:88)

z:

z
(cid:74)

s=y
(cid:75)

Then it makes a single gradient update using Ada-
Grad (Duchi et al., 2010), which maintains a per-
feature step size.

4 Modeling pragmatics

In our initial experience with the semantic pars-
ing model described in Section 3, we found
that it was able to learn reasonably well, but
lacked a reasoning ability that one ﬁnds in hu-
man learners. To illustrate the point, consider
the beginning of a game when θ = 0 in the
log-linear model pθ(z
Suppose that
human utters ‘remove red’ and then identiﬁes

| x).

3 We tried ordering based on the sum of the probabilities
(which corresponds to marginalizing out the logical form),
but this had the degenerate effect of assigning too much prob-
ability mass to y being the set of empty stacks, which can
result from many actions.

zrm-red = remove(with(red)) as the cor-
rect logical form. The computer then performs
a gradient update on the loss function (2), up-
weighting features such as (‘remove’, remove)
and (‘remove’, red).

Next, suppose the human utters ‘remove cyan’.
Note that zrm-red will score higher than all other
formulas since the (‘remove’, red) feature will
ﬁre again. While statistically justiﬁed, this be-
havior fails to meet our intuitive expectations for
a smart language learner. Moreover, this behav-
ior is not speciﬁc to our model, but applies to any
statistical model that simply tries to ﬁt the data
without additional prior knowledge about the spe-
ciﬁc language. While we would not expect the
computer to magically guess ‘remove cyan’
(cid:55)→
remove(with(cyan)), it should at least push
down the probability of zrm-red because zrm-red
intuitively is already well-explained by another ut-
terance ‘remove red’.

This phenomenon, mutual exclusivity, was stud-
ied by Markman and Wachtel (1988). They found
that children, during their language acquisition
process, reject a second label for an object and
treat it instead as a label for a novel object.

The pragmatic computer. To model mutual ex-
clusivity formally, we turn to probabilistic mod-
els of pragmatics (Golland et al., 2010; Frank and
Goodman, 2012; Smith et al., 2013; Goodman and
Lassiter, 2015), which operationalize the ideas of
Grice (1975). The central idea in these models is
to treat language as a cooperative game between
a speaker (human) and a listener (computer) as
we are doing, but where the listener has an ex-
plicit model of the speaker’s strategy, which in
turn models the listener. Formally, let S(x | z) be
the speaker’s strategy and L(z | x) be the listener’s

zrm-red

z3, z4, . . .

‘remove red’
‘remove cyan’

0.8
0.6

‘remove red’
‘remove cyan’

‘remove red’
‘remove cyan’

0.57
0.43

0.46
0.24

zrm-cyan
pθ(z | x)
0.1
0.2
S(x | z)
0.33
0.67
L(z | x)
0.27
0.38

0.1
0.2

0.33
0.67

0.27
0.38

top:

Table 2: Suppose the computer saw one exam-
ple of ‘remove red’ (cid:55)→zrm-red, and then the hu-
man utters ‘remove cyan’.
the literal lis-
tener, pθ(z | x), mistakingly chooses zrm-red
over zrm-cyan. middle:
the pragmatic speaker,
S(x | z), assigns a higher probability to to ‘remove
cyan’ given zrm-cyan; bottom: the pragmatic lis-
tener, L(z | x) correctly assigns a lower probabil-
ity to zrm-red where p(z) is uniform.

strategy. The speaker takes into account the literal
semantic parsing model pθ(z | x) as well as a prior
over utterances p(x), while the listener considers
the speaker S(x | z) and a prior p(z):

S(x | z) ∝ (pθ(z | x)p(x))β ,
L(z | x) ∝ S(x | z)p(z),

(4)

(5)

where β ≥ 1 is a hyperparameter that sharpens
the distribution (Smith et al., 2013). The com-
puter would then use L(z | x) to rank candidates
rather than pθ. Note that our pragmatic model only
affects the ranking of actions returned to the hu-
man and does not affect the gradient updates of
the model pθ.

Let us walk through a simple example to see the
effect of modeling pragmatics. Table 2 shows that
the literal listener pθ(z | x) assigns high probabil-
ity to zrm-red for both ‘remove red’ and ‘remove
cyan’. Assuming a uniform p(x) and β = 1, the
pragmatic speaker S(x | z) corresponds to normal-
izing each column of pθ. Note that if the pragmatic
speaker wanted to convey zrm-cyan, there is a de-
cent chance that they would favor ‘remove cyan’.
Next, assuming a uniform p(z), the pragmatic lis-
tener L(z | x) corresponds to normalizing each
row of S(x | z). The result is that conditioned on
‘remove cyan’, zrm-cyan is now more likely than
zrm-red, which is the desired effect.

The pragmatic listener models the speaker as a
cooperative agent who behaves in a way to max-
imize communicative success. Certain speaker

behaviors such as avoiding synonyms (e.g., not
‘delete cardinal’) and using a consistent word or-
dering (e.g, not ‘red remove’) fall out of the game
theory.4 For speakers that do not follow this strat-
egy, our pragmatic model is incorrect, but as we
get more data through game play, the literal lis-
tener pθ(z | x) will sharpen, so that the literal lis-
tener and the pragmatic listener will coincide in
the limit.

∀z, C(z) ← 0
∀z, Q(z) ← (cid:15)
repeat

receive utterance x from human
L(z | x) ∝ P (z)
Q(z) pθ(z | x)β
send human a list Y ranked by L(z | x)

receive y ∈ Y from human
θ ← θ − η∇θ(cid:96)(θ, x, y)
Q(z) ← Q(z) + pθ(z | x)β
C(z) ← C(z) + pθ(z | x,
P (z) ←

C(z)+α

(cid:80)

z(cid:48):C(z(cid:48))>0

z
(cid:74)

s = y)
(cid:75)
(cid:0)C(z(cid:48))+α(cid:1)

until game ends

Algorithm 1: Online learning algorithm that
updates the parameters of the semantic parser
θ as well as counts C, Q required to perform
pragmatic reasoning.

Online learning with pragmatics. To imple-
ment the pragmatic listener as deﬁned in (5), we
need to compute the speaker’s normalization con-
stant (cid:80)
x pθ(z | x)p(x) in order to compute S(x |
z) in (4). This requires parsing all utterances x
based on pθ(z | x). To avoid this heavy computa-
tion in an online setting, we propose Algorithm 1,
where some approximations are used for the sake
of efﬁciency. First, to approximate the intractable
sum over all utterances x, we only use the exam-
ples that are seen to compute the normalization
x pθ(z | x)p(x) ≈ (cid:80)
constant (cid:80)
i pθ(z | xi).
Then, in order to avoid parsing all previous exam-
ples again using the current parameters for each
new example, we store Q(z) = (cid:80)
i pθi(z | xi)β,
where θi is the parameter after the model updates
on the ith example xi. While θi is different from
the current parameter θ, pθ(z | xi) ≈ pθi(z | xi)
for the relevant example xi, which is accounted for

4 Of course, synonyms and variable word order occur in
real language. We would need a more complex game com-
pared to SHRDLURN to capture this effect.

by both θi and θ.

In Algorithm 1, the pragmatic listener L(z | x)
can be interpreted as an importance-weighted ver-
sion of the sharpened literal listener pβ
θ , where it
is downweighted by Q(z), which reﬂects which
z’s the literal listener prefers, and upweighted by
P (z), which is just a smoothed estimate of the ac-
tual distribution over logical forms p(z). By con-
struction, Algorithm 1 is the same as (4) except
that it uses the normalization constant Q based on
stale parameters θi after seeing example, and it
uses samples to compute the sum over x. Follow-
ing (5), we also need p(z), which is estimated by
P (z) using add-α smoothing on the counts C(z).
Note that Q(z) and C(z) are updated after the
model parameters are updated for the current ex-
ample.

z
(cid:74)

z
(cid:74)

z
(cid:74)

Lastly, there is a small complication due to only
observing the denotation y and not the logical
form z. We simply give each consistent logical
s = y} a pseudocount based on
form {z |
(cid:75)
the model: C(z) ← C(z) + pθ(z | x,
s = y)
(cid:75)
s = y) ∝ exp(θTφ(x, z)) for
where pθ(z | x,
(cid:75)
z
(cid:74)

s = y (0 otherwise).
(cid:75)
Compared to prior work where the setting is
speciﬁcally designed to require pragmatic infer-
ence, pragmatics arises naturally in ILLG. We
think that this form of pragmatics is the most im-
portant during learning, and becomes less impor-
tant if we had more data. Indeed, if we have a lot
of data and a small number of possible zs, then
L(z|x) ≈ pθ(z|x) as (cid:80)
x pθ(z|x)p(x) → p(z)
when β = 1.5 However, for semantic parsing,
we would not be in this regime even if we have
a large amount of training data. In particular, we
are nowhere near that regime in SHRDLURN, and
most of our utterances / logical forms are seen only
once, and the importance of modeling pragmatics
remains.

5 Experiments

5.1 Setting

Data. Using Amazon Mechanical Turk (AMT),
we paid 100 workers 3 dollars each to play SHRD-
LURN. In total, we have 10223 utterances along
with their starting states s. Of these, 8874 ut-
terances are labeled with their denotations y; the
rest are unlabeled, since the player can try any ut-
terance without accepting an action. 100 players
completed the entire game under identical settings.

5Technically, we also need pθ to be well-speciﬁed.

We deliberately chose to start from scratch for ev-
ery worker, so that we can study the diversity of
strategies that different people used in a controlled
setting.

Each game consists of 50 blocks tasks divided
into 5 levels of 10 tasks each, in increasing com-
plexity. Each level aims to reach an end goal
given a start state. Each game took on average
89 utterances to complete.6 It only took 6 hours
to complete these 100 games on AMT and each
game took around an hour on average according to
AMT’s work time tracker (which does not account
for multi-tasking players). The players were pro-
vided minimal instructions on the game controls.
Importantly, we gave no example utterances in or-
der to avoid biasing their language use. Around
20 players were confused and told us that the in-
structions were not clear and gave us mostly spam
utterances. Fortunately, most players understood
the setting and some even enjoyed SHRDLURN
as reﬂected by their optional comments:

• That was probably the most fun thing I have

ever done on mTurk.

• Wow this was one mind bending games [sic].

Metrics. We use the number of scrolls as a mea-
sure of game performance for each player. For
each example, the number of scrolls is the position
in the list Y of the action selected by the player. It
was possible to complete this version of SHRD-
LURN by scrolling (all actions can be found in
the ﬁrst 125 of Y )—22 of the 100 players failed to
teach an actual language, and instead ﬁnished the
game mostly by scrolling. Let us call them spam
players, who usually typed single letters, random
words, digits, or random phrases (e.g. ‘how are
you’). Overall, spam players had to scroll a lot:
21.6 scrolls per utterance versus only 7.4 for the
non-spam players.

5.2 Human strategies

Some example utterances can be found in Table 3.
Most of the players used English, but vary in their
adherence to conventions such as use of determin-
ers, plurals, and proper word ordering. 5 players
invented their own language, which are more pre-
cise, more consistent than general English. One
player used Polish, and another used Polish nota-
tion (bottom of Table 3).

6 This number is not 50 because some block tasks need
multiple steps and players are also allowed to explore without
reaching the goal.

Most successful players (1st–20th)

rem cy pos 1, stack or blk pos 4, rem
blk pos 2 thru 5, rem blk pos 2 thru 4,
stack bn blk pos 1 thru 2, ﬁll bn blk,
stack or blk pos 2 thru 6, rem cy blk
pos 2 ﬁll rd blk (3.01)

remove the brown block, remove all
orange blocks, put brown block on
orange blocks, put orange blocks on
all blocks, put blue block on leftmost
blue block in top row (2.78)

Average players (21th–50th)

Remove the center block, Remove the
red block, Remove all red blocks,
Remove the ﬁrst orange block, Put a
brown block on the ﬁrst brown block,
Add blue block on ﬁrst blue block
(2.72)

reinsert pink, take brown, put in pink,
remove two pink from second layer,
Add two red to second layer in odd
intervals, Add ﬁve pink to second
layer, Remove one blue and one
brown from bottom layer (9.17)

remove red, remove 1 red, remove 2 4
orange, add 2 red, add 1 2 3 4 blue,
emove 1 3 5 orange, add 2 4 orange,
add 2 orange, remove 2 3 brown, add
1 2 3 4 5 red, remove 2 3 4 5 6,
remove 2, add 1 2 3 4 6 red (8.37)

move second cube, double red with
blue, double ﬁrst red with red, triple
second and fourth with orange, add
red, remove orange on row two, add
blue to column two, add brown on
ﬁrst and third (7.18)

holdleftmost, holdbrown,
holdleftmost, blueonblue,
brownonblue1, blueonorange,
holdblue, holdorange2, blueonred2 ,
holdends1, holdrightend, hold2,
orangeonorangerightmost (14.15)

usu´n br ˛azowe klocki, postaw
pomara´nczowy klocek na pierwszym
klocku, postaw czerwone klocki na
pomara´nczowych, usu´n
pomara´nczowe klocki w górnym
rz˛edzie

Least successful players (51th–)

‘add red cubes on center left, center
right, far left and far right’, ‘remove
blue blocks on row two column two,
row two column four’, remove red
blocks in center left and center right
on second row (12.6)

Spam players (∼ 85th–100)

Most interesting

rm scat + 1 c, + 1 c, rm sh, + 1 2 4 sh,
+ 1 c, - 4 o, rm 1 r, + 1 3 o, full ﬁll c,
rm o, full ﬁll sh, - 1 3, full ﬁll sh, rm
sh, rm r, + 2 3 r, rm o, + 3 sh, + 2 3
sh, rm b, - 1 o, + 2 c,

laugh with me, red blocks with one
aqua, aqua red alternate, brown red
red orange aqua orange, red brown
red brown red brown, space red
orange red, second level red space red
space red space (14.32)

mBROWN,mBLUE,mORANGE
RED+ORANGEˆORANGE,
BROWN+BROWNm1+BROWNm3,
ORANGE +BROWN
+ORANGEˆm1+ ORANGEˆm3 +
BROWNˆˆ2 + BROWNˆˆ4

next, hello happy, how are you, move, gold, build goal blocks, 23,house, gabboli, x, run„xav, d, j, xcv, dulicate goal (21.7)

Table 3: Example utterances, along with the average number of scrolls for that player in parentheses.
Success is measured by the number of scrolls, where the more successful players need less scrolls. 1)
The 20 most successful players tend to use consistent and concise language whose semantics is similar
to our logical language. 2) Average players tend to be slightly more verbose and inconsistent (left and
right), or signiﬁcantly different from our logical langauge (middle). 3) Reasons for being unsuccessful
vary. Left: no tokenization, middle: used a coordinate system and many conjunctions; right: confused in
the beginning, and used a language very different from our logical language.

Overall, we ﬁnd that many players adapt in
ILLG by becoming more consistent, less verbose,
and more precise, even if they used standard En-
glish at the beginning. For example, some players
became more consistent over time (e.g. from us-
ing both ‘remove’ and ‘discard’ to only using ‘re-
move’). In terms of verbosity, removing function
words like determiners as the game progresses is
In each of the following
a common adaptation.
examples from different players, we compare an
utterance that appeared early in the game to a sim-
ilar utterance that appeared later: ‘Remove the red
ones’ became ‘Remove red.’; ‘add brown on top of
red’ became ‘add orange on red’; ‘add red blocks
to all red blocks’ became ‘add red to red’; ‘dark
red’ became ‘red’; one player used ‘the’ in all of
the ﬁrst 20 utterances, and then never used ‘the’ in
the last 75 utterances.

Players also vary in precision, ranging from
overspeciﬁed (e.g. ‘remove the orange cube at the
left’, ‘remove red blocks from top row’) to under-
speciﬁed or requiring context (e.g. ‘change col-
ors’, ‘add one blue’, ‘Build more blocus’, ‘Move
the blocks fool’,‘Add two red cubes’). We found
that some players became more precise over time,
as they gain a better understanding of ILLG.

Most players use utterances that actually do not
match our logical language in Table 1, even the
successful players. In particular, numbers are of-
ten used. While some concepts always have the
same effect in our blocks world (e.g. ‘ﬁrst block’
means leftmost), most are different. More con-
cretely, of the top 10 players, 7 used numbers of
some form and only 3 players matched our logical
language. Some players who did not match the
logical language performed quite well neverthe-

less. One possible explanation is because the ac-
tion required is somewhat constrained by the logi-
cal language and some tokens can have unintended
interpretations. For example, the computer can
correctly interpret numerical positional references,
as long as the player only refers to the leftmost
and rightmost positions. So if the player says ‘rem
blk pos 4’ and ‘rem blk pos 1’, the computer can
interpret ‘pos’ as rightmost and interpret the
bigram (‘pos’, ‘1’) as leftmost. On the other
hand, players who deviated signiﬁcantly by de-
scribing the desired state declaratively (e.g. ‘red
orange red’, ‘246’) rather than using actions, or
a coordinate system (e.g. ‘row two column two’)
performed poorly. Although players do not have
to match our logical language exactly to perform
well, being similar is deﬁnitely helpful.

Compositionality. As far as we can tell, all
players used a compositional language; no one in-
vented unrelated words for each action. Interest-
ingly, 3 players did not put spaces between words.
Since we assume monomorphemic words sepa-
rated by spaces, they had to do a lot of scrolling
as a result (e.g., 14.15 with utterances like ‘or-
angeonorangerightmost’).

5.3 Computer strategies

We now present quantitative results on how
quickly the computer can learn, where our goal is
to achieve high accuracy on new utterances as we
make just a single pass over the data. The num-
ber of scrolls used to evaluate player is sensitive to
outliers and not as intuitive as accuracy. Instead,
we consider online accuracy, described as follows.
Formally, if a player produced T utterances x(j)
and labeled them y(j), then

online accuracy

def=

1
T

T
(cid:88)

(cid:104)

I

j=1

y(j) =

(cid:105)

,

z(j)
(cid:74)

s(j)
(cid:75)

where z(j) = arg maxz pθ(j−1)(z|x(j)) is the
model prediction based on the previous parame-
ter θ(j−1). Note that the online accuracy is de-
ﬁned with respect to the player-reported labels,
which only corresponds to the actual accuracy if
the player is precise and honest. This is not true
for most spam players.

Compositionality. To study the importance of
compositionality, we consider
two baselines.
First, consider a non-compositional model (mem-

(a)

(b)

Figure 2: Pragmatics improve online accuracy. In
these plots, each marker is a player. red o: play-
ers who ranked 1–20 in terms of minimizing num-
ber of scrolls, green x: players 20–50; blue +:
lower than 50 (includes spam players). Marker
sizes correspond to player rank, where better play-
ers are depicted with larger markers. 2a: online
accuracies with and without pragmatics on the full
model; 2b: same for the half model.

Method
memorize
half model
half + prag
full model
full + prag

players ranked by # of scrolls

top 10
25.4
38.7
43.7
48.6
52.8

top 20
24.5
38.4
42.7
47.8
49.8

top 50
22.5
36.0
39.7
44.9
45.8

all 100
17.6
27.0
29.4
33.3
33.8

Table 4: Average online accuracy under vari-
featurize entire utter-
ous settings. memorize:
ance and logical form non-compositionally; half
model: featurize the utterances with unigrams, bi-
grams, and skip-grams but conjoin with the entire
logical form; full model: the model described in
Section 3; +prag: the models above, with our on-
line pragmatics algorithm described in Section 4.
Both compositionality and pragmatics improve ac-
curacy.

orize) that just remembers pairs of complete ut-
terance and logical forms. We implement this
using indicator features on features (x, z), e.g.,
(‘remove all the red blocks’, zrm-red), and use a
large learning rate.
Second, we consider a
model (half ) that treats utterances composition-
ally with unigrams, bigrams, and skip-trigrams
features, but the logical forms are regarded as
non-compositional, so we have features such as
(‘remove’, zrm-red), (‘red’, zrm-red), etc.

Table 4 shows that the full model (Section 3)
signiﬁcantly outperforms both the memorize and
half baselines. The learning rate η = 0.1 is se-
lected via cross validation, and we used α = 1
and β = 3 following Smith et al. (2013).

Pragmatics. Next, we study the effect of prag-
Figure 2 shows
matics on online accuracy.
that modeling pragmatics helps successful players
(e.g., top 10 by number of scrolls) who use precise
and consistent languages. Interestingly, our prag-
matics model did not help and can even hurt the
less successful players who are less precise and
consistent. This is expected behavior: the prag-
matics model assumes that the human is coopera-
tive and behaving rationally. For the bottom half
of the players, this assumption is not true, in which
case the pragmatics model is not useful.

6 Related Work and Discussion

Our work connects with a broad body of work on
grounded language, in which language is used in
some environment as a means towards some goal.
Examples include playing games (Branavan et al.,
2009, 2010; Reckman et al., 2010) interacting with
robotics (Tellex et al., 2011, 2014), and following
instructions (Vogel and Jurafsky, 2010; Chen and
Mooney, 2011; Artzi and Zettlemoyer, 2013) Se-
mantic parsing utterances to logical forms, which
we leverage, plays an important role in these set-
tings (Kollar et al., 2010; Matuszek et al., 2012;
Artzi and Zettlemoyer, 2013).

What makes this work unique is our new inter-
active learning of language games (ILLG) setting,
in which a model has to learn a language from
scratch through interaction. While online gradient
descent is frequently used, for example in seman-
tic parsing (Zettlemoyer and Collins, 2007; Chen,
2012), we using it in a truly online setting, taking
one pass over the data and measuring online accu-
racy (Cesa-Bianchi and Lugosi, 2006).

To speed up learning, we leverage computa-
tional models of pragmatics (Jäger, 2008; Golland
et al., 2010; Frank and Goodman, 2012; Smith
et al., 2013; Vogel et al., 2013). The main differ-
ence is these previous works use pragmatics with
a trained base model, whereas we learn the model
online. Monroe and Potts (2015) uses learning
to improve the pragmatics model.
In contrast,
we use pragmatics to speed up the learning pro-
cess by capturing phenomena like mutual exclu-
sivity (Markman and Wachtel, 1988). We also dif-
fer from prior work in several details. First, we
model pragmatics in the online learning setting
where we use an online update for the pragmat-
ics model. Second, unlikely the reference games
where pragmatic effects plays an important role by

design, SHRDLURN is not speciﬁcally designed
to require pragmatics. The improvement we get
is mainly due to players trying to be consistent in
their language use. Finaly, we treat both the utter-
ance and the logical forms as featurized composi-
tional objects. Smith et al. (2013) treats utterances
(i.e. words) and logical forms (i.e. objects) as cat-
egories; Monroe and Potts (2015) used features,
but also over ﬂat categories.

Looking forward, we believe that the ILLG set-
ting is worth studying and has important implica-
tions for natural language interfaces. Today, these
If these
systems are trained once and deployed.
systems could quickly adapt to user feedback in
real-time as in this work, then we might be able
to more readily create systems for resource-poor
languages and new domains, that are customizable
and improve through use.

Acknowledgments

DARPA Communicating with Computers (CwC)
program under ARO prime contract no. W911NF-
15-1-0462. The ﬁrst author is supported by a
NSERC PGS-D fellowship. In addition, we thank
Will Monroe, and Chris Potts for their insightful
comments and discussions on pragmatics.

Reproducibility

All code, data, and experiments for this paper are
available on the CodaLab platform:
https://worksheets.

codalab.org/worksheets/

0x9fe4d080bac944e9a6bd58478cb05e5e
The client side code is here:
https://github.com/sidaw/shrdlurn/tree/

acl16-demo
and a demo: http://shrdlurn.sidaw.xyz

References

Y. Artzi and L. Zettlemoyer. 2013. Weakly super-
vised learning of semantic parsers for mapping
instructions to actions. Transactions of the As-
sociation for Computational Linguistics (TACL)
1:49–62.

J. Berant, A. Chou, R. Frostig, and P. Liang. 2013.
Semantic parsing on Freebase from question-
answer pairs. In Empirical Methods in Natural
Language Processing (EMNLP).

S. Branavan, H. Chen, L. S. Zettlemoyer, and
R. Barzilay. 2009. Reinforcement learning for

In Associa-
mapping instructions to actions.
tion for Computational Linguistics and Inter-
national Joint Conference on Natural Language
Processing (ACL-IJCNLP). pages 82–90.

T. Kollar, S. Tellex, D. Roy, and N. Roy. 2010.
Grounding verbs of motion in natural language
commands to robots. In International Sympo-
sium on Experimental Robotics (ISER).

S. Branavan, L. Zettlemoyer, and R. Barzilay.
2010. Reading between the lines: Learning
to map high-level instructions to commands.
In Association for Computational Linguistics
(ACL). pages 1268–1277.

N. Cesa-Bianchi and G. Lugosi. 2006. Predic-
tion, learning, and games. Cambridge Univer-
sity Press.

D. L. Chen. 2012. Fast online lexicon learning for
grounded language acquisition. In Association
for Computational Linguistics (ACL).

D. L. Chen and R. J. Mooney. 2011. Learning
to interpret natural language navigation instruc-
tions from observations. In Association for the
Advancement of Artiﬁcial Intelligence (AAAI).
pages 859–865.

J. Duchi, E. Hazan, and Y. Singer. 2010. Adap-
tive subgradient methods for online learning
and stochastic optimization. In Conference on
Learning Theory (COLT).

M. Frank and N. D. Goodman. 2012. Predicting
pragmatic reasoning in language games. Sci-
ence 336:998–998.

H. Giles. 2008. Communication accommodation

theory. Sage Publications, Inc.

D. Golland, P. Liang, and D. Klein. 2010. A game-
theoretic approach to generating spatial descrip-
In Empirical Methods in Natural Lan-
tions.
guage Processing (EMNLP).

N. Goodman and D. Lassiter. 2015. Probabilistic
Semantics and Pragmatics: Uncertainty in Lan-
guage and Thought. The Handbook of Contem-
porary Semantic Theory, 2nd Edition Wiley-
Blackwell.

H. P. Grice. 1975. Logic and conversation. Syntax

and semantics 3:41–58.

M. E. Ireland, R. B. Slatcher, P. W. Eastwick, L. E.
Scissors, E. J. Finkel, and J. W. Pennebaker.
2011. Language style matching predicts rela-
tionship initiation and stability. Psychological
Science 22(1):39–44.

G. Jäger. 2008. Game theory in semantics and
pragmatics. Technical report, University of
Tübingen.

T. Kwiatkowski, L. Zettlemoyer, S. Goldwater,
and M. Steedman. 2010. Inducing probabilistic
CCG grammars from logical form with higher-
In Empirical Methods in
order uniﬁcation.
Natural Language Processing (EMNLP). pages
1223–1233.

P. Liang, M. I. Jordan, and D. Klein. 2011.
Learning dependency-based compositional se-
mantics. In Association for Computational Lin-
guistics (ACL). pages 590–599.

E. Markman and G. F. Wachtel. 1988. Children’s
use of mutual exclusivity to constrain the mean-
ings of words. Cognitive Psychology 20:125–
157.

C. Matuszek, N. FitzGerald, L. Zettlemoyer,
L. Bo, and D. Fox. 2012. A joint model of
language and perception for grounded attribute
In International Conference on Ma-
learning.
chine Learning (ICML). pages 1671–1678.

W. Monroe and C. Potts. 2015. Learning in the
Rational Speech Acts model. In Proceedings of
20th Amsterdam Colloquium.

P. Pasupat and P. Liang. 2015. Compositional se-
mantic parsing on semi-structured tables. In As-
sociation for Computational Linguistics (ACL).

H. Reckman, J. Orkin, and D. Roy. 2010. Learning
meanings of words and constructions, grounded
In Conference on Natural
in a virtual game.
Language Processing (KONVENS).

N. J. Smith, N. D. Goodman, and M. C. Frank.
2013. Learning and using language via re-
cursive pragmatic reasoning about other agents.
In Advances in Neural Information Processing
Systems (NIPS).

S. Tellex, R. Knepper, A. Li, D. Rus, and N. Roy.
2014. Asking for help using inverse semantics.
In Robotics: Science and Systems (RSS).

S. Tellex, T. Kollar, S. Dickerson, M. R. Walter,
A. G. Banerjee, S. J. Teller, and N. Roy. 2011.
Understanding natural language commands for
robotic navigation and mobile manipulation. In
Association for the Advancement of Artiﬁcial
Intelligence (AAAI).

A. Vogel, M. Bodoia, C. Potts, and D. Juraf-
sky. 2013. Emergence of gricean maxims from

In North Ameri-
multi-agent decision theory.
can Association for Computational Linguistics
(NAACL). pages 1072–1081.

A. Vogel and D. Jurafsky. 2010. Learning to fol-
low navigational directions. In Association for
Computational Linguistics (ACL). pages 806–
814.

T. Winograd. 1972. Understanding Natural Lan-

guage. Academic Press.

L. Wittgenstein. 1953. Philosophical Investiga-

tions. Blackwell, Oxford.

Y. W. Wong and R. J. Mooney. 2007. Learn-
ing synchronous grammars for semantic parsing
with lambda calculus. In Association for Com-
putational Linguistics (ACL). pages 960–967.

L. S. Zettlemoyer and M. Collins. 2005. Learn-
ing to map sentences to logical form: Struc-
tured classiﬁcation with probabilistic categorial
In Uncertainty in Artiﬁcial Intelli-
grammars.
gence (UAI). pages 658–666.

L. S. Zettlemoyer and M. Collins. 2007. Online
learning of relaxed CCG grammars for parsing
to logical form. In Empirical Methods in Nat-
ural Language Processing and Computational
Natural Language Learning (EMNLP/CoNLL).
pages 678–687.

Learning Language Games through Interaction

Sida I. Wang

Percy Liang

Christopher D. Manning

Computer Science Department
Stanford University
{sidaw,pliang,manning}@cs.stanford.edu

6
1
0
2
 
n
u
J
 
8
 
 
]
L
C
.
s
c
[
 
 
1
v
7
4
4
2
0
.
6
0
6
1
:
v
i
X
r
a

Abstract

We introduce a new language learning
setting relevant to building adaptive nat-
It is inspired
ural language interfaces.
by Wittgenstein’s language games: a hu-
man wishes to accomplish some task
(e.g., achieving a certain conﬁguration of
blocks), but can only communicate with a
computer, who performs the actual actions
(e.g., removing all red blocks). The com-
puter initially knows nothing about lan-
guage and therefore must learn it from
scratch through interaction, while the hu-
man adapts to the computer’s capabilities.
We created a game called SHRDLURN in
a blocks world and collected interactions
from 100 people playing it. First, we an-
alyze the humans’ strategies, showing that
using compositionality and avoiding syn-
onyms correlates positively with task per-
formance. Second, we compare computer
strategies, showing that modeling prag-
matics on a semantic parsing model accel-
erates learning for more strategic players.

1

Introduction

Wittgenstein (1953) famously said that language
derives its meaning from use, and introduced the
concept of language games to illustrate the ﬂuid-
ity and purpose-orientedness of language. He de-
scribed how a builder B and an assistant A can use
a primitive language consisting of four words—
‘block’, ‘pillar’, ‘slab’, ‘beam’—to successfully
communicate what block to pass from A to B. This
is only one such language; many others would also
work for accomplishing the cooperative goal.

This paper operationalizes and explores the idea
of language games in a learning setting, which we
call interactive learning through language games

Figure 1: The SHRDLURN game: the objective
is to transform the start state into the goal state.
The human types in an utterance, and the computer
(which does not know the goal state) tries to in-
terpret the utterance and perform the correspond-
ing action. The computer initially knows nothing
about the language, but through the human’s feed-
back, learns the human’s language while making
progress towards the game goal.

(ILLG). In the ILLG setting, the two parties do not
initially speak a common language, but nonethe-
less need to collaboratively accomplish a goal.
Speciﬁcally, we created a game called SHRD-
LURN,1 in homage to the seminal work of Wino-
grad (1972). As shown in Figure 1, the objective
is to transform a start state into a goal state, but
the only action the human can take is entering an
utterance. The computer parses the utterance and
produces a ranked list of possible interpretations
according to its current model. The human scrolls
through the list and chooses the intended one, si-
multaneously advancing the state of the blocks and
providing feedback to the computer. Both the hu-
man and the computer wish to reach the goal state

1Demo: http://shrdlurn.sidaw.xyz

(only known to the human) with as little scrolling
as possible. For the computer to be successful, it
has to learn the human’s language quickly over the
course of the game, so that the human can accom-
plish the goal more efﬁciently. Conversely, the hu-
man must also accommodate the computer, at least
partially understanding what it can and cannot do.

We model the computer in the ILLG as a se-
mantic parser (Section 3), which maps natural lan-
guage utterances (e.g., ‘remove red’) into logical
forms (e.g., remove(with(red))). The seman-
tic parser has no seed lexicon and no annotated
logical forms, so it just generates many candidate
logical forms. Based on the human’s feedback, it
performs online gradient updates on the parame-
ters corresponding to simple lexical features.

During development,

it became evident that
while the computer was eventually able to learn
the language, it was learning less quickly than
one might hope. For example, after learning that
‘remove red’ maps to remove(with(red)),
it would think that ‘remove cyan’ also mapped
to remove(with(red)), whereas a human
would likely use mutual exclusivity to rule out that
hypothesis (Markman and Wachtel, 1988). We
therefore introduce a pragmatics model in which
the computer explicitly reasons about the human,
in the spirit of previous work on pragmatics (Gol-
land et al., 2010; Frank and Goodman, 2012;
Smith et al., 2013). To make the model suitable
for our ILLG setting, we introduce a new online
learning algorithm. Empirically, we show that our
pragmatic model improves the online accuracy by
8% compared to our best non-pragmatic model on
the 10 most successful players (Section 5.3).

What is special about the ILLG setting is the
real-time nature of learning, in which the human
also learns and adapts to the computer. While
the human can teach the computer any language—
English, Arabic, Polish, a custom programming
language—a good human player will choose to
use utterances that the computer is more likely to
learn quickly. In the parlance of communication
theory, the human accommodates the computer
(Giles, 2008; Ireland et al., 2011). Using Ama-
zon Mechanical Turk, we collected and analyzed
around 10k utterances from 100 games of SHRD-
LURN. We show that successful players tend to
use compositional utterances with a consistent vo-
cabulary and syntax, which matches the inductive
biases of the computer (Section 5.2). In addition,

through this interaction, many players adapt to the
computer by becoming more consistent, more pre-
cise, and more concise.

On the practical side, natural language systems
are often trained once and deployed, and users
must live with their imperfections. We believe
that studying the ILLG setting will be integral for
creating adaptive and customizable systems, es-
pecially for resource-poor languages and new do-
mains where starting from close to scratch is un-
avoidable.

2 Setting

(e.g.

We now describe the interactive learning of lan-
guage games (ILLG) setting formally. There are
two players, the human and the computer. The
game proceeds through a ﬁxed number of levels.
In each level, both players are presented with a
starting state s ∈ Y, but only the human sees
in SHRDLURN, Y
the goal state t ∈ Y.
is the set of all conﬁgurations of blocks). The
human transmits an utterance x (e.g., ‘remove
red’) to the computer. The computer then con-
structs a ranked list of candidate actions Z =
[z1, . . . , zK] ⊆ Z (e.g., remove(with(red)),
add(with(orange)), etc.), where Z is all
possible actions. For each zi ∈ Z, it computes
yi =
s, the successor state from executing ac-
(cid:75)
tion zi on state s. The computer returns to the hu-
man the ordered list Y = [y1, . . . , yK] of succes-
sor states. The human then chooses yi from the list
Y (we say the computer is correct if i = 1). The
state then updates to s = yi. The level ends when
s = t, and the players advance to the next level.

zi
(cid:74)

Since only the human knows the goal state t and
only the computer can perform actions, the only
way for the two to play the game successfully is
for the human to somehow encode the desired ac-
tion in the utterance x. However, we assume the
two players do not have a shared language, so the
human needs to pick a language and teach it to the
computer. As an additional twist, the human does
not know the exact set of actions Z (although they
might have some preconception of the computer’s
capabilities).2 Finally, the human only sees the
outcomes of the computer’s actions, not the actual
logical actions themselves.

We expect the game to proceed as follows: In
the beginning, the computer does not understand

2This is often the case when we try to interact with a new

software system or service before reading the manual.

what the human is saying and performs arbitrary
actions. As the computer obtains feedback and
learns, the two should become more proﬁcient at
communicating and thus playing the game. Herein
lies our key design principle: language learning
should be necessary for the players to achieve
good game performance.

SHRDLURN. Let us now describe the details
of our speciﬁc game, SHRDLURN. Each state
s ∈ Y consists of stacks of colored blocks ar-
ranged in a line (Figure 1), where each stack
The actions
is a vertical column of blocks.
Z are deﬁned compositionally via the gram-
mar in Table 1.
Each action either adds to
or removes from a set of stacks, and a set of
stacks is computed via various set operations
and selecting by color. For example, the action
remove(leftmost(with(red))) removes the
top block from the leftmost stack whose topmost
block is red. The compositionality of the actions
gives the computer non-trivial capabilities. Of
course, the human must teach a language to har-
ness those capabilities, while not quite knowing
the exact extent of the capabilities. The actual
game proceeds according to a curriculum, where
the earlier levels only need simpler actions with
fewer predicates.

We designed SHRDLURN in this way for sev-
eral reasons. First, visual block manipulations are
intuitive and can be easily crowdsourced, and it
can be fun as an actual game that people would
play. Second, the action space is designed to be
compositional, mirroring the structure of natural
language. Third, many actions z lead to the same
s; e.g., the ‘leftmost stack’
successor state y =
(cid:75)
might coincide with the ‘stack with red blocks’ for
some state s and therefore an action involving ei-
ther one would result in the same outcome. Since
the human only points out the correct y, the com-
puter must grapple with this indirect supervision,
a reﬂection of real language learning.

z
(cid:74)

3 Semantic parsing model

Following Zettlemoyer and Collins (2005) and
most recent work on semantic parsing, we use
a log-linear model over logical forms (actions)
z ∈ Z given an utterance x:

pθ(z | x) ∝ exp(θTφ(x, z)),

(1)

where φ(x, z) ∈ Rd is a feature vector and θ ∈ Rd
is a parameter vector. The denotation y (succes-

sor state) is obtained by executing z on a state s;
formally, y =

z
(cid:74)

s.
(cid:75)

Features. Our features are n-grams (including
skip-grams) conjoined with tree-grams on the log-
Speciﬁcally, on the utterance
ical form side.
side (e.g., ‘stack red on orange’), we use uni-
grams (‘stack’, ∗, ∗), bigrams (‘red’, ‘on’, ∗), tri-
grams (‘red’, ‘on’, ‘orange’), and skip-trigrams
(‘stack’, ∗, ‘on’). On the logical form side, fea-
tures corresponds to the predicates in the logical
forms and their arguments. For each predicate h,
let h.i be the i-th argument of h. Then, we de-
ﬁne tree-gram features ψ(h, d) for predicate h and
depth d = 0, 1, 2, 3 recursively as follows:

ψ(h, 0) = {h},

ψ(h, d) = {(h, i, ψ(h.i, d − 1)) | i = 1, 2, 3}.

The set of all features is just the cross product
of utterance features and logical form features.
if x = ‘enlever tout’ and z =
For example,
remove(all()), then features include:

(‘enlever’, all)
(‘enlever’, remove)
(‘enlever’, (remove, 1, all))
(‘tout’, (remove, 1, all))

(‘tout’, all)
(‘tout’, remove)

Note that we do not model an explicit alignment
or derivation compositionally connecting the utter-
ance and the logical form, in contrast to most tradi-
tional work in semantic parsing (Zettlemoyer and
Collins, 2005; Wong and Mooney, 2007; Liang
et al., 2011; Kwiatkowski et al., 2010; Berant
et al., 2013), instead following a looser model of
semantics similar to (Pasupat and Liang, 2015).
Modeling explicit alignments or derivations is
only computationally feasible when we are learn-
ing from annotated logical forms or have a seed
lexicon, since the number of derivations is much
larger than the number of logical forms.
In the
ILLG setting, neither are available.

Generation/parsing. We generate logical forms
from smallest
to largest using beam search.
Speciﬁcally, for each size n = 1, . . . , 8, we con-
struct a set of logical forms of size n (with ex-
actly n predicates) by combining logical forms of
smaller sizes according to the grammar rules in Ta-
ble 1. For each n, we keep the 100 logical forms z
with the highest score θTφ(x, z) according to the
current model θ. Let Z be the set of logical forms
on the ﬁnal beam, which contains logical forms
of all sizes n. During training, due to pruning at

Rule

Semantics

Description

Set
Color
Color → Set
Set → Set
Set → Set
Set Color → Act add(s, c)
Set → Act

remove(s)

all stacks

all()
cyan|brown|red|orange primitive color
with(c)
not(s)
leftmost|rightmost(s)

stacks whose top block has color c
all stacks except those in s
leftmost/rightmost stack in s
add block with color c on each stack in s
remove the topmost block of each stack in s

Table 1: The formal grammar deﬁning the compositional action space Z for SHRDLURN.
We use c to denote a Color, and s to denote a Set.
For example, one action that we
the leftmost brown block’
(cid:55)→
have in SHRDLURN is:
add(not(leftmost(with(brown))),orange).

‘add an orange block to all but

intermediate sizes, Z is not guaranteed to contain
the logical form that obtains the observed state y.
To mitigate this effect, we use a curriculum so that
only simple actions are needed in the initial levels,
giving the human an opportunity to teach the com-
puter about basic terms such as colors ﬁrst before
moving to larger composite actions.

The system executes all of the logical forms on
the ﬁnal beam Z, and orders the resulting denota-
tions y by the maximum probability of any logical
form that produced it.3

Learning. When the human provides feedback
in the form of a particular y, the system forms the
following loss function:

(cid:96)(θ, x, y) = − log pθ(y | x, s) + λ||θ||1,

pθ(y | x, s) =

pθ(z | x).

(2)

(3)

(cid:88)

z:

z
(cid:74)

s=y
(cid:75)

Then it makes a single gradient update using Ada-
Grad (Duchi et al., 2010), which maintains a per-
feature step size.

4 Modeling pragmatics

In our initial experience with the semantic pars-
ing model described in Section 3, we found
that it was able to learn reasonably well, but
lacked a reasoning ability that one ﬁnds in hu-
man learners. To illustrate the point, consider
the beginning of a game when θ = 0 in the
log-linear model pθ(z
Suppose that
human utters ‘remove red’ and then identiﬁes

| x).

3 We tried ordering based on the sum of the probabilities
(which corresponds to marginalizing out the logical form),
but this had the degenerate effect of assigning too much prob-
ability mass to y being the set of empty stacks, which can
result from many actions.

zrm-red = remove(with(red)) as the cor-
rect logical form. The computer then performs
a gradient update on the loss function (2), up-
weighting features such as (‘remove’, remove)
and (‘remove’, red).

Next, suppose the human utters ‘remove cyan’.
Note that zrm-red will score higher than all other
formulas since the (‘remove’, red) feature will
ﬁre again. While statistically justiﬁed, this be-
havior fails to meet our intuitive expectations for
a smart language learner. Moreover, this behav-
ior is not speciﬁc to our model, but applies to any
statistical model that simply tries to ﬁt the data
without additional prior knowledge about the spe-
ciﬁc language. While we would not expect the
computer to magically guess ‘remove cyan’
(cid:55)→
remove(with(cyan)), it should at least push
down the probability of zrm-red because zrm-red
intuitively is already well-explained by another ut-
terance ‘remove red’.

This phenomenon, mutual exclusivity, was stud-
ied by Markman and Wachtel (1988). They found
that children, during their language acquisition
process, reject a second label for an object and
treat it instead as a label for a novel object.

The pragmatic computer. To model mutual ex-
clusivity formally, we turn to probabilistic mod-
els of pragmatics (Golland et al., 2010; Frank and
Goodman, 2012; Smith et al., 2013; Goodman and
Lassiter, 2015), which operationalize the ideas of
Grice (1975). The central idea in these models is
to treat language as a cooperative game between
a speaker (human) and a listener (computer) as
we are doing, but where the listener has an ex-
plicit model of the speaker’s strategy, which in
turn models the listener. Formally, let S(x | z) be
the speaker’s strategy and L(z | x) be the listener’s

zrm-red

z3, z4, . . .

‘remove red’
‘remove cyan’

0.8
0.6

‘remove red’
‘remove cyan’

‘remove red’
‘remove cyan’

0.57
0.43

0.46
0.24

zrm-cyan
pθ(z | x)
0.1
0.2
S(x | z)
0.33
0.67
L(z | x)
0.27
0.38

0.1
0.2

0.33
0.67

0.27
0.38

top:

Table 2: Suppose the computer saw one exam-
ple of ‘remove red’ (cid:55)→zrm-red, and then the hu-
man utters ‘remove cyan’.
the literal lis-
tener, pθ(z | x), mistakingly chooses zrm-red
over zrm-cyan. middle:
the pragmatic speaker,
S(x | z), assigns a higher probability to to ‘remove
cyan’ given zrm-cyan; bottom: the pragmatic lis-
tener, L(z | x) correctly assigns a lower probabil-
ity to zrm-red where p(z) is uniform.

strategy. The speaker takes into account the literal
semantic parsing model pθ(z | x) as well as a prior
over utterances p(x), while the listener considers
the speaker S(x | z) and a prior p(z):

S(x | z) ∝ (pθ(z | x)p(x))β ,
L(z | x) ∝ S(x | z)p(z),

(4)

(5)

where β ≥ 1 is a hyperparameter that sharpens
the distribution (Smith et al., 2013). The com-
puter would then use L(z | x) to rank candidates
rather than pθ. Note that our pragmatic model only
affects the ranking of actions returned to the hu-
man and does not affect the gradient updates of
the model pθ.

Let us walk through a simple example to see the
effect of modeling pragmatics. Table 2 shows that
the literal listener pθ(z | x) assigns high probabil-
ity to zrm-red for both ‘remove red’ and ‘remove
cyan’. Assuming a uniform p(x) and β = 1, the
pragmatic speaker S(x | z) corresponds to normal-
izing each column of pθ. Note that if the pragmatic
speaker wanted to convey zrm-cyan, there is a de-
cent chance that they would favor ‘remove cyan’.
Next, assuming a uniform p(z), the pragmatic lis-
tener L(z | x) corresponds to normalizing each
row of S(x | z). The result is that conditioned on
‘remove cyan’, zrm-cyan is now more likely than
zrm-red, which is the desired effect.

The pragmatic listener models the speaker as a
cooperative agent who behaves in a way to max-
imize communicative success. Certain speaker

behaviors such as avoiding synonyms (e.g., not
‘delete cardinal’) and using a consistent word or-
dering (e.g, not ‘red remove’) fall out of the game
theory.4 For speakers that do not follow this strat-
egy, our pragmatic model is incorrect, but as we
get more data through game play, the literal lis-
tener pθ(z | x) will sharpen, so that the literal lis-
tener and the pragmatic listener will coincide in
the limit.

∀z, C(z) ← 0
∀z, Q(z) ← (cid:15)
repeat

receive utterance x from human
L(z | x) ∝ P (z)
Q(z) pθ(z | x)β
send human a list Y ranked by L(z | x)

receive y ∈ Y from human
θ ← θ − η∇θ(cid:96)(θ, x, y)
Q(z) ← Q(z) + pθ(z | x)β
C(z) ← C(z) + pθ(z | x,
P (z) ←

C(z)+α

(cid:80)

z(cid:48):C(z(cid:48))>0

z
(cid:74)

s = y)
(cid:75)
(cid:0)C(z(cid:48))+α(cid:1)

until game ends

Algorithm 1: Online learning algorithm that
updates the parameters of the semantic parser
θ as well as counts C, Q required to perform
pragmatic reasoning.

Online learning with pragmatics. To imple-
ment the pragmatic listener as deﬁned in (5), we
need to compute the speaker’s normalization con-
stant (cid:80)
x pθ(z | x)p(x) in order to compute S(x |
z) in (4). This requires parsing all utterances x
based on pθ(z | x). To avoid this heavy computa-
tion in an online setting, we propose Algorithm 1,
where some approximations are used for the sake
of efﬁciency. First, to approximate the intractable
sum over all utterances x, we only use the exam-
ples that are seen to compute the normalization
x pθ(z | x)p(x) ≈ (cid:80)
constant (cid:80)
i pθ(z | xi).
Then, in order to avoid parsing all previous exam-
ples again using the current parameters for each
new example, we store Q(z) = (cid:80)
i pθi(z | xi)β,
where θi is the parameter after the model updates
on the ith example xi. While θi is different from
the current parameter θ, pθ(z | xi) ≈ pθi(z | xi)
for the relevant example xi, which is accounted for

4 Of course, synonyms and variable word order occur in
real language. We would need a more complex game com-
pared to SHRDLURN to capture this effect.

by both θi and θ.

In Algorithm 1, the pragmatic listener L(z | x)
can be interpreted as an importance-weighted ver-
sion of the sharpened literal listener pβ
θ , where it
is downweighted by Q(z), which reﬂects which
z’s the literal listener prefers, and upweighted by
P (z), which is just a smoothed estimate of the ac-
tual distribution over logical forms p(z). By con-
struction, Algorithm 1 is the same as (4) except
that it uses the normalization constant Q based on
stale parameters θi after seeing example, and it
uses samples to compute the sum over x. Follow-
ing (5), we also need p(z), which is estimated by
P (z) using add-α smoothing on the counts C(z).
Note that Q(z) and C(z) are updated after the
model parameters are updated for the current ex-
ample.

z
(cid:74)

z
(cid:74)

z
(cid:74)

Lastly, there is a small complication due to only
observing the denotation y and not the logical
form z. We simply give each consistent logical
s = y} a pseudocount based on
form {z |
(cid:75)
the model: C(z) ← C(z) + pθ(z | x,
s = y)
(cid:75)
s = y) ∝ exp(θTφ(x, z)) for
where pθ(z | x,
(cid:75)
z
(cid:74)

s = y (0 otherwise).
(cid:75)
Compared to prior work where the setting is
speciﬁcally designed to require pragmatic infer-
ence, pragmatics arises naturally in ILLG. We
think that this form of pragmatics is the most im-
portant during learning, and becomes less impor-
tant if we had more data. Indeed, if we have a lot
of data and a small number of possible zs, then
L(z|x) ≈ pθ(z|x) as (cid:80)
x pθ(z|x)p(x) → p(z)
when β = 1.5 However, for semantic parsing,
we would not be in this regime even if we have
a large amount of training data. In particular, we
are nowhere near that regime in SHRDLURN, and
most of our utterances / logical forms are seen only
once, and the importance of modeling pragmatics
remains.

5 Experiments

5.1 Setting

Data. Using Amazon Mechanical Turk (AMT),
we paid 100 workers 3 dollars each to play SHRD-
LURN. In total, we have 10223 utterances along
with their starting states s. Of these, 8874 ut-
terances are labeled with their denotations y; the
rest are unlabeled, since the player can try any ut-
terance without accepting an action. 100 players
completed the entire game under identical settings.

5Technically, we also need pθ to be well-speciﬁed.

We deliberately chose to start from scratch for ev-
ery worker, so that we can study the diversity of
strategies that different people used in a controlled
setting.

Each game consists of 50 blocks tasks divided
into 5 levels of 10 tasks each, in increasing com-
plexity. Each level aims to reach an end goal
given a start state. Each game took on average
89 utterances to complete.6 It only took 6 hours
to complete these 100 games on AMT and each
game took around an hour on average according to
AMT’s work time tracker (which does not account
for multi-tasking players). The players were pro-
vided minimal instructions on the game controls.
Importantly, we gave no example utterances in or-
der to avoid biasing their language use. Around
20 players were confused and told us that the in-
structions were not clear and gave us mostly spam
utterances. Fortunately, most players understood
the setting and some even enjoyed SHRDLURN
as reﬂected by their optional comments:

• That was probably the most fun thing I have

ever done on mTurk.

• Wow this was one mind bending games [sic].

Metrics. We use the number of scrolls as a mea-
sure of game performance for each player. For
each example, the number of scrolls is the position
in the list Y of the action selected by the player. It
was possible to complete this version of SHRD-
LURN by scrolling (all actions can be found in
the ﬁrst 125 of Y )—22 of the 100 players failed to
teach an actual language, and instead ﬁnished the
game mostly by scrolling. Let us call them spam
players, who usually typed single letters, random
words, digits, or random phrases (e.g. ‘how are
you’). Overall, spam players had to scroll a lot:
21.6 scrolls per utterance versus only 7.4 for the
non-spam players.

5.2 Human strategies

Some example utterances can be found in Table 3.
Most of the players used English, but vary in their
adherence to conventions such as use of determin-
ers, plurals, and proper word ordering. 5 players
invented their own language, which are more pre-
cise, more consistent than general English. One
player used Polish, and another used Polish nota-
tion (bottom of Table 3).

6 This number is not 50 because some block tasks need
multiple steps and players are also allowed to explore without
reaching the goal.

Most successful players (1st–20th)

rem cy pos 1, stack or blk pos 4, rem
blk pos 2 thru 5, rem blk pos 2 thru 4,
stack bn blk pos 1 thru 2, ﬁll bn blk,
stack or blk pos 2 thru 6, rem cy blk
pos 2 ﬁll rd blk (3.01)

remove the brown block, remove all
orange blocks, put brown block on
orange blocks, put orange blocks on
all blocks, put blue block on leftmost
blue block in top row (2.78)

Average players (21th–50th)

Remove the center block, Remove the
red block, Remove all red blocks,
Remove the ﬁrst orange block, Put a
brown block on the ﬁrst brown block,
Add blue block on ﬁrst blue block
(2.72)

reinsert pink, take brown, put in pink,
remove two pink from second layer,
Add two red to second layer in odd
intervals, Add ﬁve pink to second
layer, Remove one blue and one
brown from bottom layer (9.17)

remove red, remove 1 red, remove 2 4
orange, add 2 red, add 1 2 3 4 blue,
emove 1 3 5 orange, add 2 4 orange,
add 2 orange, remove 2 3 brown, add
1 2 3 4 5 red, remove 2 3 4 5 6,
remove 2, add 1 2 3 4 6 red (8.37)

move second cube, double red with
blue, double ﬁrst red with red, triple
second and fourth with orange, add
red, remove orange on row two, add
blue to column two, add brown on
ﬁrst and third (7.18)

holdleftmost, holdbrown,
holdleftmost, blueonblue,
brownonblue1, blueonorange,
holdblue, holdorange2, blueonred2 ,
holdends1, holdrightend, hold2,
orangeonorangerightmost (14.15)

usu´n br ˛azowe klocki, postaw
pomara´nczowy klocek na pierwszym
klocku, postaw czerwone klocki na
pomara´nczowych, usu´n
pomara´nczowe klocki w górnym
rz˛edzie

Least successful players (51th–)

‘add red cubes on center left, center
right, far left and far right’, ‘remove
blue blocks on row two column two,
row two column four’, remove red
blocks in center left and center right
on second row (12.6)

Spam players (∼ 85th–100)

Most interesting

rm scat + 1 c, + 1 c, rm sh, + 1 2 4 sh,
+ 1 c, - 4 o, rm 1 r, + 1 3 o, full ﬁll c,
rm o, full ﬁll sh, - 1 3, full ﬁll sh, rm
sh, rm r, + 2 3 r, rm o, + 3 sh, + 2 3
sh, rm b, - 1 o, + 2 c,

laugh with me, red blocks with one
aqua, aqua red alternate, brown red
red orange aqua orange, red brown
red brown red brown, space red
orange red, second level red space red
space red space (14.32)

mBROWN,mBLUE,mORANGE
RED+ORANGEˆORANGE,
BROWN+BROWNm1+BROWNm3,
ORANGE +BROWN
+ORANGEˆm1+ ORANGEˆm3 +
BROWNˆˆ2 + BROWNˆˆ4

next, hello happy, how are you, move, gold, build goal blocks, 23,house, gabboli, x, run„xav, d, j, xcv, dulicate goal (21.7)

Table 3: Example utterances, along with the average number of scrolls for that player in parentheses.
Success is measured by the number of scrolls, where the more successful players need less scrolls. 1)
The 20 most successful players tend to use consistent and concise language whose semantics is similar
to our logical language. 2) Average players tend to be slightly more verbose and inconsistent (left and
right), or signiﬁcantly different from our logical langauge (middle). 3) Reasons for being unsuccessful
vary. Left: no tokenization, middle: used a coordinate system and many conjunctions; right: confused in
the beginning, and used a language very different from our logical language.

Overall, we ﬁnd that many players adapt in
ILLG by becoming more consistent, less verbose,
and more precise, even if they used standard En-
glish at the beginning. For example, some players
became more consistent over time (e.g. from us-
ing both ‘remove’ and ‘discard’ to only using ‘re-
move’). In terms of verbosity, removing function
words like determiners as the game progresses is
In each of the following
a common adaptation.
examples from different players, we compare an
utterance that appeared early in the game to a sim-
ilar utterance that appeared later: ‘Remove the red
ones’ became ‘Remove red.’; ‘add brown on top of
red’ became ‘add orange on red’; ‘add red blocks
to all red blocks’ became ‘add red to red’; ‘dark
red’ became ‘red’; one player used ‘the’ in all of
the ﬁrst 20 utterances, and then never used ‘the’ in
the last 75 utterances.

Players also vary in precision, ranging from
overspeciﬁed (e.g. ‘remove the orange cube at the
left’, ‘remove red blocks from top row’) to under-
speciﬁed or requiring context (e.g. ‘change col-
ors’, ‘add one blue’, ‘Build more blocus’, ‘Move
the blocks fool’,‘Add two red cubes’). We found
that some players became more precise over time,
as they gain a better understanding of ILLG.

Most players use utterances that actually do not
match our logical language in Table 1, even the
successful players. In particular, numbers are of-
ten used. While some concepts always have the
same effect in our blocks world (e.g. ‘ﬁrst block’
means leftmost), most are different. More con-
cretely, of the top 10 players, 7 used numbers of
some form and only 3 players matched our logical
language. Some players who did not match the
logical language performed quite well neverthe-

less. One possible explanation is because the ac-
tion required is somewhat constrained by the logi-
cal language and some tokens can have unintended
interpretations. For example, the computer can
correctly interpret numerical positional references,
as long as the player only refers to the leftmost
and rightmost positions. So if the player says ‘rem
blk pos 4’ and ‘rem blk pos 1’, the computer can
interpret ‘pos’ as rightmost and interpret the
bigram (‘pos’, ‘1’) as leftmost. On the other
hand, players who deviated signiﬁcantly by de-
scribing the desired state declaratively (e.g. ‘red
orange red’, ‘246’) rather than using actions, or
a coordinate system (e.g. ‘row two column two’)
performed poorly. Although players do not have
to match our logical language exactly to perform
well, being similar is deﬁnitely helpful.

Compositionality. As far as we can tell, all
players used a compositional language; no one in-
vented unrelated words for each action. Interest-
ingly, 3 players did not put spaces between words.
Since we assume monomorphemic words sepa-
rated by spaces, they had to do a lot of scrolling
as a result (e.g., 14.15 with utterances like ‘or-
angeonorangerightmost’).

5.3 Computer strategies

We now present quantitative results on how
quickly the computer can learn, where our goal is
to achieve high accuracy on new utterances as we
make just a single pass over the data. The num-
ber of scrolls used to evaluate player is sensitive to
outliers and not as intuitive as accuracy. Instead,
we consider online accuracy, described as follows.
Formally, if a player produced T utterances x(j)
and labeled them y(j), then

online accuracy

def=

1
T

T
(cid:88)

(cid:104)

I

j=1

y(j) =

(cid:105)

,

z(j)
(cid:74)

s(j)
(cid:75)

where z(j) = arg maxz pθ(j−1)(z|x(j)) is the
model prediction based on the previous parame-
ter θ(j−1). Note that the online accuracy is de-
ﬁned with respect to the player-reported labels,
which only corresponds to the actual accuracy if
the player is precise and honest. This is not true
for most spam players.

Compositionality. To study the importance of
compositionality, we consider
two baselines.
First, consider a non-compositional model (mem-

(a)

(b)

Figure 2: Pragmatics improve online accuracy. In
these plots, each marker is a player. red o: play-
ers who ranked 1–20 in terms of minimizing num-
ber of scrolls, green x: players 20–50; blue +:
lower than 50 (includes spam players). Marker
sizes correspond to player rank, where better play-
ers are depicted with larger markers. 2a: online
accuracies with and without pragmatics on the full
model; 2b: same for the half model.

Method
memorize
half model
half + prag
full model
full + prag

players ranked by # of scrolls

top 10
25.4
38.7
43.7
48.6
52.8

top 20
24.5
38.4
42.7
47.8
49.8

top 50
22.5
36.0
39.7
44.9
45.8

all 100
17.6
27.0
29.4
33.3
33.8

Table 4: Average online accuracy under vari-
featurize entire utter-
ous settings. memorize:
ance and logical form non-compositionally; half
model: featurize the utterances with unigrams, bi-
grams, and skip-grams but conjoin with the entire
logical form; full model: the model described in
Section 3; +prag: the models above, with our on-
line pragmatics algorithm described in Section 4.
Both compositionality and pragmatics improve ac-
curacy.

orize) that just remembers pairs of complete ut-
terance and logical forms. We implement this
using indicator features on features (x, z), e.g.,
(‘remove all the red blocks’, zrm-red), and use a
large learning rate.
Second, we consider a
model (half ) that treats utterances composition-
ally with unigrams, bigrams, and skip-trigrams
features, but the logical forms are regarded as
non-compositional, so we have features such as
(‘remove’, zrm-red), (‘red’, zrm-red), etc.

Table 4 shows that the full model (Section 3)
signiﬁcantly outperforms both the memorize and
half baselines. The learning rate η = 0.1 is se-
lected via cross validation, and we used α = 1
and β = 3 following Smith et al. (2013).

Pragmatics. Next, we study the effect of prag-
Figure 2 shows
matics on online accuracy.
that modeling pragmatics helps successful players
(e.g., top 10 by number of scrolls) who use precise
and consistent languages. Interestingly, our prag-
matics model did not help and can even hurt the
less successful players who are less precise and
consistent. This is expected behavior: the prag-
matics model assumes that the human is coopera-
tive and behaving rationally. For the bottom half
of the players, this assumption is not true, in which
case the pragmatics model is not useful.

6 Related Work and Discussion

Our work connects with a broad body of work on
grounded language, in which language is used in
some environment as a means towards some goal.
Examples include playing games (Branavan et al.,
2009, 2010; Reckman et al., 2010) interacting with
robotics (Tellex et al., 2011, 2014), and following
instructions (Vogel and Jurafsky, 2010; Chen and
Mooney, 2011; Artzi and Zettlemoyer, 2013) Se-
mantic parsing utterances to logical forms, which
we leverage, plays an important role in these set-
tings (Kollar et al., 2010; Matuszek et al., 2012;
Artzi and Zettlemoyer, 2013).

What makes this work unique is our new inter-
active learning of language games (ILLG) setting,
in which a model has to learn a language from
scratch through interaction. While online gradient
descent is frequently used, for example in seman-
tic parsing (Zettlemoyer and Collins, 2007; Chen,
2012), we using it in a truly online setting, taking
one pass over the data and measuring online accu-
racy (Cesa-Bianchi and Lugosi, 2006).

To speed up learning, we leverage computa-
tional models of pragmatics (Jäger, 2008; Golland
et al., 2010; Frank and Goodman, 2012; Smith
et al., 2013; Vogel et al., 2013). The main differ-
ence is these previous works use pragmatics with
a trained base model, whereas we learn the model
online. Monroe and Potts (2015) uses learning
to improve the pragmatics model.
In contrast,
we use pragmatics to speed up the learning pro-
cess by capturing phenomena like mutual exclu-
sivity (Markman and Wachtel, 1988). We also dif-
fer from prior work in several details. First, we
model pragmatics in the online learning setting
where we use an online update for the pragmat-
ics model. Second, unlikely the reference games
where pragmatic effects plays an important role by

design, SHRDLURN is not speciﬁcally designed
to require pragmatics. The improvement we get
is mainly due to players trying to be consistent in
their language use. Finaly, we treat both the utter-
ance and the logical forms as featurized composi-
tional objects. Smith et al. (2013) treats utterances
(i.e. words) and logical forms (i.e. objects) as cat-
egories; Monroe and Potts (2015) used features,
but also over ﬂat categories.

Looking forward, we believe that the ILLG set-
ting is worth studying and has important implica-
tions for natural language interfaces. Today, these
If these
systems are trained once and deployed.
systems could quickly adapt to user feedback in
real-time as in this work, then we might be able
to more readily create systems for resource-poor
languages and new domains, that are customizable
and improve through use.

Acknowledgments

DARPA Communicating with Computers (CwC)
program under ARO prime contract no. W911NF-
15-1-0462. The ﬁrst author is supported by a
NSERC PGS-D fellowship. In addition, we thank
Will Monroe, and Chris Potts for their insightful
comments and discussions on pragmatics.

Reproducibility

All code, data, and experiments for this paper are
available on the CodaLab platform:
https://worksheets.

codalab.org/worksheets/

0x9fe4d080bac944e9a6bd58478cb05e5e
The client side code is here:
https://github.com/sidaw/shrdlurn/tree/

acl16-demo
and a demo: http://shrdlurn.sidaw.xyz

References

Y. Artzi and L. Zettlemoyer. 2013. Weakly super-
vised learning of semantic parsers for mapping
instructions to actions. Transactions of the As-
sociation for Computational Linguistics (TACL)
1:49–62.

J. Berant, A. Chou, R. Frostig, and P. Liang. 2013.
Semantic parsing on Freebase from question-
answer pairs. In Empirical Methods in Natural
Language Processing (EMNLP).

S. Branavan, H. Chen, L. S. Zettlemoyer, and
R. Barzilay. 2009. Reinforcement learning for

In Associa-
mapping instructions to actions.
tion for Computational Linguistics and Inter-
national Joint Conference on Natural Language
Processing (ACL-IJCNLP). pages 82–90.

T. Kollar, S. Tellex, D. Roy, and N. Roy. 2010.
Grounding verbs of motion in natural language
commands to robots. In International Sympo-
sium on Experimental Robotics (ISER).

S. Branavan, L. Zettlemoyer, and R. Barzilay.
2010. Reading between the lines: Learning
to map high-level instructions to commands.
In Association for Computational Linguistics
(ACL). pages 1268–1277.

N. Cesa-Bianchi and G. Lugosi. 2006. Predic-
tion, learning, and games. Cambridge Univer-
sity Press.

D. L. Chen. 2012. Fast online lexicon learning for
grounded language acquisition. In Association
for Computational Linguistics (ACL).

D. L. Chen and R. J. Mooney. 2011. Learning
to interpret natural language navigation instruc-
tions from observations. In Association for the
Advancement of Artiﬁcial Intelligence (AAAI).
pages 859–865.

J. Duchi, E. Hazan, and Y. Singer. 2010. Adap-
tive subgradient methods for online learning
and stochastic optimization. In Conference on
Learning Theory (COLT).

M. Frank and N. D. Goodman. 2012. Predicting
pragmatic reasoning in language games. Sci-
ence 336:998–998.

H. Giles. 2008. Communication accommodation

theory. Sage Publications, Inc.

D. Golland, P. Liang, and D. Klein. 2010. A game-
theoretic approach to generating spatial descrip-
In Empirical Methods in Natural Lan-
tions.
guage Processing (EMNLP).

N. Goodman and D. Lassiter. 2015. Probabilistic
Semantics and Pragmatics: Uncertainty in Lan-
guage and Thought. The Handbook of Contem-
porary Semantic Theory, 2nd Edition Wiley-
Blackwell.

H. P. Grice. 1975. Logic and conversation. Syntax

and semantics 3:41–58.

M. E. Ireland, R. B. Slatcher, P. W. Eastwick, L. E.
Scissors, E. J. Finkel, and J. W. Pennebaker.
2011. Language style matching predicts rela-
tionship initiation and stability. Psychological
Science 22(1):39–44.

G. Jäger. 2008. Game theory in semantics and
pragmatics. Technical report, University of
Tübingen.

T. Kwiatkowski, L. Zettlemoyer, S. Goldwater,
and M. Steedman. 2010. Inducing probabilistic
CCG grammars from logical form with higher-
In Empirical Methods in
order uniﬁcation.
Natural Language Processing (EMNLP). pages
1223–1233.

P. Liang, M. I. Jordan, and D. Klein. 2011.
Learning dependency-based compositional se-
mantics. In Association for Computational Lin-
guistics (ACL). pages 590–599.

E. Markman and G. F. Wachtel. 1988. Children’s
use of mutual exclusivity to constrain the mean-
ings of words. Cognitive Psychology 20:125–
157.

C. Matuszek, N. FitzGerald, L. Zettlemoyer,
L. Bo, and D. Fox. 2012. A joint model of
language and perception for grounded attribute
In International Conference on Ma-
learning.
chine Learning (ICML). pages 1671–1678.

W. Monroe and C. Potts. 2015. Learning in the
Rational Speech Acts model. In Proceedings of
20th Amsterdam Colloquium.

P. Pasupat and P. Liang. 2015. Compositional se-
mantic parsing on semi-structured tables. In As-
sociation for Computational Linguistics (ACL).

H. Reckman, J. Orkin, and D. Roy. 2010. Learning
meanings of words and constructions, grounded
In Conference on Natural
in a virtual game.
Language Processing (KONVENS).

N. J. Smith, N. D. Goodman, and M. C. Frank.
2013. Learning and using language via re-
cursive pragmatic reasoning about other agents.
In Advances in Neural Information Processing
Systems (NIPS).

S. Tellex, R. Knepper, A. Li, D. Rus, and N. Roy.
2014. Asking for help using inverse semantics.
In Robotics: Science and Systems (RSS).

S. Tellex, T. Kollar, S. Dickerson, M. R. Walter,
A. G. Banerjee, S. J. Teller, and N. Roy. 2011.
Understanding natural language commands for
robotic navigation and mobile manipulation. In
Association for the Advancement of Artiﬁcial
Intelligence (AAAI).

A. Vogel, M. Bodoia, C. Potts, and D. Juraf-
sky. 2013. Emergence of gricean maxims from

In North Ameri-
multi-agent decision theory.
can Association for Computational Linguistics
(NAACL). pages 1072–1081.

A. Vogel and D. Jurafsky. 2010. Learning to fol-
low navigational directions. In Association for
Computational Linguistics (ACL). pages 806–
814.

T. Winograd. 1972. Understanding Natural Lan-

guage. Academic Press.

L. Wittgenstein. 1953. Philosophical Investiga-

tions. Blackwell, Oxford.

Y. W. Wong and R. J. Mooney. 2007. Learn-
ing synchronous grammars for semantic parsing
with lambda calculus. In Association for Com-
putational Linguistics (ACL). pages 960–967.

L. S. Zettlemoyer and M. Collins. 2005. Learn-
ing to map sentences to logical form: Struc-
tured classiﬁcation with probabilistic categorial
In Uncertainty in Artiﬁcial Intelli-
grammars.
gence (UAI). pages 658–666.

L. S. Zettlemoyer and M. Collins. 2007. Online
learning of relaxed CCG grammars for parsing
to logical form. In Empirical Methods in Nat-
ural Language Processing and Computational
Natural Language Learning (EMNLP/CoNLL).
pages 678–687.

Learning Language Games through Interaction

Sida I. Wang

Percy Liang

Christopher D. Manning

Computer Science Department
Stanford University
{sidaw,pliang,manning}@cs.stanford.edu

6
1
0
2
 
n
u
J
 
8
 
 
]
L
C
.
s
c
[
 
 
1
v
7
4
4
2
0
.
6
0
6
1
:
v
i
X
r
a

Abstract

We introduce a new language learning
setting relevant to building adaptive nat-
It is inspired
ural language interfaces.
by Wittgenstein’s language games: a hu-
man wishes to accomplish some task
(e.g., achieving a certain conﬁguration of
blocks), but can only communicate with a
computer, who performs the actual actions
(e.g., removing all red blocks). The com-
puter initially knows nothing about lan-
guage and therefore must learn it from
scratch through interaction, while the hu-
man adapts to the computer’s capabilities.
We created a game called SHRDLURN in
a blocks world and collected interactions
from 100 people playing it. First, we an-
alyze the humans’ strategies, showing that
using compositionality and avoiding syn-
onyms correlates positively with task per-
formance. Second, we compare computer
strategies, showing that modeling prag-
matics on a semantic parsing model accel-
erates learning for more strategic players.

1

Introduction

Wittgenstein (1953) famously said that language
derives its meaning from use, and introduced the
concept of language games to illustrate the ﬂuid-
ity and purpose-orientedness of language. He de-
scribed how a builder B and an assistant A can use
a primitive language consisting of four words—
‘block’, ‘pillar’, ‘slab’, ‘beam’—to successfully
communicate what block to pass from A to B. This
is only one such language; many others would also
work for accomplishing the cooperative goal.

This paper operationalizes and explores the idea
of language games in a learning setting, which we
call interactive learning through language games

Figure 1: The SHRDLURN game: the objective
is to transform the start state into the goal state.
The human types in an utterance, and the computer
(which does not know the goal state) tries to in-
terpret the utterance and perform the correspond-
ing action. The computer initially knows nothing
about the language, but through the human’s feed-
back, learns the human’s language while making
progress towards the game goal.

(ILLG). In the ILLG setting, the two parties do not
initially speak a common language, but nonethe-
less need to collaboratively accomplish a goal.
Speciﬁcally, we created a game called SHRD-
LURN,1 in homage to the seminal work of Wino-
grad (1972). As shown in Figure 1, the objective
is to transform a start state into a goal state, but
the only action the human can take is entering an
utterance. The computer parses the utterance and
produces a ranked list of possible interpretations
according to its current model. The human scrolls
through the list and chooses the intended one, si-
multaneously advancing the state of the blocks and
providing feedback to the computer. Both the hu-
man and the computer wish to reach the goal state

1Demo: http://shrdlurn.sidaw.xyz

(only known to the human) with as little scrolling
as possible. For the computer to be successful, it
has to learn the human’s language quickly over the
course of the game, so that the human can accom-
plish the goal more efﬁciently. Conversely, the hu-
man must also accommodate the computer, at least
partially understanding what it can and cannot do.

We model the computer in the ILLG as a se-
mantic parser (Section 3), which maps natural lan-
guage utterances (e.g., ‘remove red’) into logical
forms (e.g., remove(with(red))). The seman-
tic parser has no seed lexicon and no annotated
logical forms, so it just generates many candidate
logical forms. Based on the human’s feedback, it
performs online gradient updates on the parame-
ters corresponding to simple lexical features.

During development,

it became evident that
while the computer was eventually able to learn
the language, it was learning less quickly than
one might hope. For example, after learning that
‘remove red’ maps to remove(with(red)),
it would think that ‘remove cyan’ also mapped
to remove(with(red)), whereas a human
would likely use mutual exclusivity to rule out that
hypothesis (Markman and Wachtel, 1988). We
therefore introduce a pragmatics model in which
the computer explicitly reasons about the human,
in the spirit of previous work on pragmatics (Gol-
land et al., 2010; Frank and Goodman, 2012;
Smith et al., 2013). To make the model suitable
for our ILLG setting, we introduce a new online
learning algorithm. Empirically, we show that our
pragmatic model improves the online accuracy by
8% compared to our best non-pragmatic model on
the 10 most successful players (Section 5.3).

What is special about the ILLG setting is the
real-time nature of learning, in which the human
also learns and adapts to the computer. While
the human can teach the computer any language—
English, Arabic, Polish, a custom programming
language—a good human player will choose to
use utterances that the computer is more likely to
learn quickly. In the parlance of communication
theory, the human accommodates the computer
(Giles, 2008; Ireland et al., 2011). Using Ama-
zon Mechanical Turk, we collected and analyzed
around 10k utterances from 100 games of SHRD-
LURN. We show that successful players tend to
use compositional utterances with a consistent vo-
cabulary and syntax, which matches the inductive
biases of the computer (Section 5.2). In addition,

through this interaction, many players adapt to the
computer by becoming more consistent, more pre-
cise, and more concise.

On the practical side, natural language systems
are often trained once and deployed, and users
must live with their imperfections. We believe
that studying the ILLG setting will be integral for
creating adaptive and customizable systems, es-
pecially for resource-poor languages and new do-
mains where starting from close to scratch is un-
avoidable.

2 Setting

(e.g.

We now describe the interactive learning of lan-
guage games (ILLG) setting formally. There are
two players, the human and the computer. The
game proceeds through a ﬁxed number of levels.
In each level, both players are presented with a
starting state s ∈ Y, but only the human sees
in SHRDLURN, Y
the goal state t ∈ Y.
is the set of all conﬁgurations of blocks). The
human transmits an utterance x (e.g., ‘remove
red’) to the computer. The computer then con-
structs a ranked list of candidate actions Z =
[z1, . . . , zK] ⊆ Z (e.g., remove(with(red)),
add(with(orange)), etc.), where Z is all
possible actions. For each zi ∈ Z, it computes
yi =
s, the successor state from executing ac-
(cid:75)
tion zi on state s. The computer returns to the hu-
man the ordered list Y = [y1, . . . , yK] of succes-
sor states. The human then chooses yi from the list
Y (we say the computer is correct if i = 1). The
state then updates to s = yi. The level ends when
s = t, and the players advance to the next level.

zi
(cid:74)

Since only the human knows the goal state t and
only the computer can perform actions, the only
way for the two to play the game successfully is
for the human to somehow encode the desired ac-
tion in the utterance x. However, we assume the
two players do not have a shared language, so the
human needs to pick a language and teach it to the
computer. As an additional twist, the human does
not know the exact set of actions Z (although they
might have some preconception of the computer’s
capabilities).2 Finally, the human only sees the
outcomes of the computer’s actions, not the actual
logical actions themselves.

We expect the game to proceed as follows: In
the beginning, the computer does not understand

2This is often the case when we try to interact with a new

software system or service before reading the manual.

what the human is saying and performs arbitrary
actions. As the computer obtains feedback and
learns, the two should become more proﬁcient at
communicating and thus playing the game. Herein
lies our key design principle: language learning
should be necessary for the players to achieve
good game performance.

SHRDLURN. Let us now describe the details
of our speciﬁc game, SHRDLURN. Each state
s ∈ Y consists of stacks of colored blocks ar-
ranged in a line (Figure 1), where each stack
The actions
is a vertical column of blocks.
Z are deﬁned compositionally via the gram-
mar in Table 1.
Each action either adds to
or removes from a set of stacks, and a set of
stacks is computed via various set operations
and selecting by color. For example, the action
remove(leftmost(with(red))) removes the
top block from the leftmost stack whose topmost
block is red. The compositionality of the actions
gives the computer non-trivial capabilities. Of
course, the human must teach a language to har-
ness those capabilities, while not quite knowing
the exact extent of the capabilities. The actual
game proceeds according to a curriculum, where
the earlier levels only need simpler actions with
fewer predicates.

We designed SHRDLURN in this way for sev-
eral reasons. First, visual block manipulations are
intuitive and can be easily crowdsourced, and it
can be fun as an actual game that people would
play. Second, the action space is designed to be
compositional, mirroring the structure of natural
language. Third, many actions z lead to the same
s; e.g., the ‘leftmost stack’
successor state y =
(cid:75)
might coincide with the ‘stack with red blocks’ for
some state s and therefore an action involving ei-
ther one would result in the same outcome. Since
the human only points out the correct y, the com-
puter must grapple with this indirect supervision,
a reﬂection of real language learning.

z
(cid:74)

3 Semantic parsing model

Following Zettlemoyer and Collins (2005) and
most recent work on semantic parsing, we use
a log-linear model over logical forms (actions)
z ∈ Z given an utterance x:

pθ(z | x) ∝ exp(θTφ(x, z)),

(1)

where φ(x, z) ∈ Rd is a feature vector and θ ∈ Rd
is a parameter vector. The denotation y (succes-

sor state) is obtained by executing z on a state s;
formally, y =

z
(cid:74)

s.
(cid:75)

Features. Our features are n-grams (including
skip-grams) conjoined with tree-grams on the log-
Speciﬁcally, on the utterance
ical form side.
side (e.g., ‘stack red on orange’), we use uni-
grams (‘stack’, ∗, ∗), bigrams (‘red’, ‘on’, ∗), tri-
grams (‘red’, ‘on’, ‘orange’), and skip-trigrams
(‘stack’, ∗, ‘on’). On the logical form side, fea-
tures corresponds to the predicates in the logical
forms and their arguments. For each predicate h,
let h.i be the i-th argument of h. Then, we de-
ﬁne tree-gram features ψ(h, d) for predicate h and
depth d = 0, 1, 2, 3 recursively as follows:

ψ(h, 0) = {h},

ψ(h, d) = {(h, i, ψ(h.i, d − 1)) | i = 1, 2, 3}.

The set of all features is just the cross product
of utterance features and logical form features.
if x = ‘enlever tout’ and z =
For example,
remove(all()), then features include:

(‘enlever’, all)
(‘enlever’, remove)
(‘enlever’, (remove, 1, all))
(‘tout’, (remove, 1, all))

(‘tout’, all)
(‘tout’, remove)

Note that we do not model an explicit alignment
or derivation compositionally connecting the utter-
ance and the logical form, in contrast to most tradi-
tional work in semantic parsing (Zettlemoyer and
Collins, 2005; Wong and Mooney, 2007; Liang
et al., 2011; Kwiatkowski et al., 2010; Berant
et al., 2013), instead following a looser model of
semantics similar to (Pasupat and Liang, 2015).
Modeling explicit alignments or derivations is
only computationally feasible when we are learn-
ing from annotated logical forms or have a seed
lexicon, since the number of derivations is much
larger than the number of logical forms.
In the
ILLG setting, neither are available.

Generation/parsing. We generate logical forms
from smallest
to largest using beam search.
Speciﬁcally, for each size n = 1, . . . , 8, we con-
struct a set of logical forms of size n (with ex-
actly n predicates) by combining logical forms of
smaller sizes according to the grammar rules in Ta-
ble 1. For each n, we keep the 100 logical forms z
with the highest score θTφ(x, z) according to the
current model θ. Let Z be the set of logical forms
on the ﬁnal beam, which contains logical forms
of all sizes n. During training, due to pruning at

Rule

Semantics

Description

Set
Color
Color → Set
Set → Set
Set → Set
Set Color → Act add(s, c)
Set → Act

remove(s)

all stacks

all()
cyan|brown|red|orange primitive color
with(c)
not(s)
leftmost|rightmost(s)

stacks whose top block has color c
all stacks except those in s
leftmost/rightmost stack in s
add block with color c on each stack in s
remove the topmost block of each stack in s

Table 1: The formal grammar deﬁning the compositional action space Z for SHRDLURN.
We use c to denote a Color, and s to denote a Set.
For example, one action that we
the leftmost brown block’
(cid:55)→
have in SHRDLURN is:
add(not(leftmost(with(brown))),orange).

‘add an orange block to all but

intermediate sizes, Z is not guaranteed to contain
the logical form that obtains the observed state y.
To mitigate this effect, we use a curriculum so that
only simple actions are needed in the initial levels,
giving the human an opportunity to teach the com-
puter about basic terms such as colors ﬁrst before
moving to larger composite actions.

The system executes all of the logical forms on
the ﬁnal beam Z, and orders the resulting denota-
tions y by the maximum probability of any logical
form that produced it.3

Learning. When the human provides feedback
in the form of a particular y, the system forms the
following loss function:

(cid:96)(θ, x, y) = − log pθ(y | x, s) + λ||θ||1,

pθ(y | x, s) =

pθ(z | x).

(2)

(3)

(cid:88)

z:

z
(cid:74)

s=y
(cid:75)

Then it makes a single gradient update using Ada-
Grad (Duchi et al., 2010), which maintains a per-
feature step size.

4 Modeling pragmatics

In our initial experience with the semantic pars-
ing model described in Section 3, we found
that it was able to learn reasonably well, but
lacked a reasoning ability that one ﬁnds in hu-
man learners. To illustrate the point, consider
the beginning of a game when θ = 0 in the
log-linear model pθ(z
Suppose that
human utters ‘remove red’ and then identiﬁes

| x).

3 We tried ordering based on the sum of the probabilities
(which corresponds to marginalizing out the logical form),
but this had the degenerate effect of assigning too much prob-
ability mass to y being the set of empty stacks, which can
result from many actions.

zrm-red = remove(with(red)) as the cor-
rect logical form. The computer then performs
a gradient update on the loss function (2), up-
weighting features such as (‘remove’, remove)
and (‘remove’, red).

Next, suppose the human utters ‘remove cyan’.
Note that zrm-red will score higher than all other
formulas since the (‘remove’, red) feature will
ﬁre again. While statistically justiﬁed, this be-
havior fails to meet our intuitive expectations for
a smart language learner. Moreover, this behav-
ior is not speciﬁc to our model, but applies to any
statistical model that simply tries to ﬁt the data
without additional prior knowledge about the spe-
ciﬁc language. While we would not expect the
computer to magically guess ‘remove cyan’
(cid:55)→
remove(with(cyan)), it should at least push
down the probability of zrm-red because zrm-red
intuitively is already well-explained by another ut-
terance ‘remove red’.

This phenomenon, mutual exclusivity, was stud-
ied by Markman and Wachtel (1988). They found
that children, during their language acquisition
process, reject a second label for an object and
treat it instead as a label for a novel object.

The pragmatic computer. To model mutual ex-
clusivity formally, we turn to probabilistic mod-
els of pragmatics (Golland et al., 2010; Frank and
Goodman, 2012; Smith et al., 2013; Goodman and
Lassiter, 2015), which operationalize the ideas of
Grice (1975). The central idea in these models is
to treat language as a cooperative game between
a speaker (human) and a listener (computer) as
we are doing, but where the listener has an ex-
plicit model of the speaker’s strategy, which in
turn models the listener. Formally, let S(x | z) be
the speaker’s strategy and L(z | x) be the listener’s

zrm-red

z3, z4, . . .

‘remove red’
‘remove cyan’

0.8
0.6

‘remove red’
‘remove cyan’

‘remove red’
‘remove cyan’

0.57
0.43

0.46
0.24

zrm-cyan
pθ(z | x)
0.1
0.2
S(x | z)
0.33
0.67
L(z | x)
0.27
0.38

0.1
0.2

0.33
0.67

0.27
0.38

top:

Table 2: Suppose the computer saw one exam-
ple of ‘remove red’ (cid:55)→zrm-red, and then the hu-
man utters ‘remove cyan’.
the literal lis-
tener, pθ(z | x), mistakingly chooses zrm-red
over zrm-cyan. middle:
the pragmatic speaker,
S(x | z), assigns a higher probability to to ‘remove
cyan’ given zrm-cyan; bottom: the pragmatic lis-
tener, L(z | x) correctly assigns a lower probabil-
ity to zrm-red where p(z) is uniform.

strategy. The speaker takes into account the literal
semantic parsing model pθ(z | x) as well as a prior
over utterances p(x), while the listener considers
the speaker S(x | z) and a prior p(z):

S(x | z) ∝ (pθ(z | x)p(x))β ,
L(z | x) ∝ S(x | z)p(z),

(4)

(5)

where β ≥ 1 is a hyperparameter that sharpens
the distribution (Smith et al., 2013). The com-
puter would then use L(z | x) to rank candidates
rather than pθ. Note that our pragmatic model only
affects the ranking of actions returned to the hu-
man and does not affect the gradient updates of
the model pθ.

Let us walk through a simple example to see the
effect of modeling pragmatics. Table 2 shows that
the literal listener pθ(z | x) assigns high probabil-
ity to zrm-red for both ‘remove red’ and ‘remove
cyan’. Assuming a uniform p(x) and β = 1, the
pragmatic speaker S(x | z) corresponds to normal-
izing each column of pθ. Note that if the pragmatic
speaker wanted to convey zrm-cyan, there is a de-
cent chance that they would favor ‘remove cyan’.
Next, assuming a uniform p(z), the pragmatic lis-
tener L(z | x) corresponds to normalizing each
row of S(x | z). The result is that conditioned on
‘remove cyan’, zrm-cyan is now more likely than
zrm-red, which is the desired effect.

The pragmatic listener models the speaker as a
cooperative agent who behaves in a way to max-
imize communicative success. Certain speaker

behaviors such as avoiding synonyms (e.g., not
‘delete cardinal’) and using a consistent word or-
dering (e.g, not ‘red remove’) fall out of the game
theory.4 For speakers that do not follow this strat-
egy, our pragmatic model is incorrect, but as we
get more data through game play, the literal lis-
tener pθ(z | x) will sharpen, so that the literal lis-
tener and the pragmatic listener will coincide in
the limit.

∀z, C(z) ← 0
∀z, Q(z) ← (cid:15)
repeat

receive utterance x from human
L(z | x) ∝ P (z)
Q(z) pθ(z | x)β
send human a list Y ranked by L(z | x)

receive y ∈ Y from human
θ ← θ − η∇θ(cid:96)(θ, x, y)
Q(z) ← Q(z) + pθ(z | x)β
C(z) ← C(z) + pθ(z | x,
P (z) ←

C(z)+α

(cid:80)

z(cid:48):C(z(cid:48))>0

z
(cid:74)

s = y)
(cid:75)
(cid:0)C(z(cid:48))+α(cid:1)

until game ends

Algorithm 1: Online learning algorithm that
updates the parameters of the semantic parser
θ as well as counts C, Q required to perform
pragmatic reasoning.

Online learning with pragmatics. To imple-
ment the pragmatic listener as deﬁned in (5), we
need to compute the speaker’s normalization con-
stant (cid:80)
x pθ(z | x)p(x) in order to compute S(x |
z) in (4). This requires parsing all utterances x
based on pθ(z | x). To avoid this heavy computa-
tion in an online setting, we propose Algorithm 1,
where some approximations are used for the sake
of efﬁciency. First, to approximate the intractable
sum over all utterances x, we only use the exam-
ples that are seen to compute the normalization
x pθ(z | x)p(x) ≈ (cid:80)
constant (cid:80)
i pθ(z | xi).
Then, in order to avoid parsing all previous exam-
ples again using the current parameters for each
new example, we store Q(z) = (cid:80)
i pθi(z | xi)β,
where θi is the parameter after the model updates
on the ith example xi. While θi is different from
the current parameter θ, pθ(z | xi) ≈ pθi(z | xi)
for the relevant example xi, which is accounted for

4 Of course, synonyms and variable word order occur in
real language. We would need a more complex game com-
pared to SHRDLURN to capture this effect.

by both θi and θ.

In Algorithm 1, the pragmatic listener L(z | x)
can be interpreted as an importance-weighted ver-
sion of the sharpened literal listener pβ
θ , where it
is downweighted by Q(z), which reﬂects which
z’s the literal listener prefers, and upweighted by
P (z), which is just a smoothed estimate of the ac-
tual distribution over logical forms p(z). By con-
struction, Algorithm 1 is the same as (4) except
that it uses the normalization constant Q based on
stale parameters θi after seeing example, and it
uses samples to compute the sum over x. Follow-
ing (5), we also need p(z), which is estimated by
P (z) using add-α smoothing on the counts C(z).
Note that Q(z) and C(z) are updated after the
model parameters are updated for the current ex-
ample.

z
(cid:74)

z
(cid:74)

z
(cid:74)

Lastly, there is a small complication due to only
observing the denotation y and not the logical
form z. We simply give each consistent logical
s = y} a pseudocount based on
form {z |
(cid:75)
the model: C(z) ← C(z) + pθ(z | x,
s = y)
(cid:75)
s = y) ∝ exp(θTφ(x, z)) for
where pθ(z | x,
(cid:75)
z
(cid:74)

s = y (0 otherwise).
(cid:75)
Compared to prior work where the setting is
speciﬁcally designed to require pragmatic infer-
ence, pragmatics arises naturally in ILLG. We
think that this form of pragmatics is the most im-
portant during learning, and becomes less impor-
tant if we had more data. Indeed, if we have a lot
of data and a small number of possible zs, then
L(z|x) ≈ pθ(z|x) as (cid:80)
x pθ(z|x)p(x) → p(z)
when β = 1.5 However, for semantic parsing,
we would not be in this regime even if we have
a large amount of training data. In particular, we
are nowhere near that regime in SHRDLURN, and
most of our utterances / logical forms are seen only
once, and the importance of modeling pragmatics
remains.

5 Experiments

5.1 Setting

Data. Using Amazon Mechanical Turk (AMT),
we paid 100 workers 3 dollars each to play SHRD-
LURN. In total, we have 10223 utterances along
with their starting states s. Of these, 8874 ut-
terances are labeled with their denotations y; the
rest are unlabeled, since the player can try any ut-
terance without accepting an action. 100 players
completed the entire game under identical settings.

5Technically, we also need pθ to be well-speciﬁed.

We deliberately chose to start from scratch for ev-
ery worker, so that we can study the diversity of
strategies that different people used in a controlled
setting.

Each game consists of 50 blocks tasks divided
into 5 levels of 10 tasks each, in increasing com-
plexity. Each level aims to reach an end goal
given a start state. Each game took on average
89 utterances to complete.6 It only took 6 hours
to complete these 100 games on AMT and each
game took around an hour on average according to
AMT’s work time tracker (which does not account
for multi-tasking players). The players were pro-
vided minimal instructions on the game controls.
Importantly, we gave no example utterances in or-
der to avoid biasing their language use. Around
20 players were confused and told us that the in-
structions were not clear and gave us mostly spam
utterances. Fortunately, most players understood
the setting and some even enjoyed SHRDLURN
as reﬂected by their optional comments:

• That was probably the most fun thing I have

ever done on mTurk.

• Wow this was one mind bending games [sic].

Metrics. We use the number of scrolls as a mea-
sure of game performance for each player. For
each example, the number of scrolls is the position
in the list Y of the action selected by the player. It
was possible to complete this version of SHRD-
LURN by scrolling (all actions can be found in
the ﬁrst 125 of Y )—22 of the 100 players failed to
teach an actual language, and instead ﬁnished the
game mostly by scrolling. Let us call them spam
players, who usually typed single letters, random
words, digits, or random phrases (e.g. ‘how are
you’). Overall, spam players had to scroll a lot:
21.6 scrolls per utterance versus only 7.4 for the
non-spam players.

5.2 Human strategies

Some example utterances can be found in Table 3.
Most of the players used English, but vary in their
adherence to conventions such as use of determin-
ers, plurals, and proper word ordering. 5 players
invented their own language, which are more pre-
cise, more consistent than general English. One
player used Polish, and another used Polish nota-
tion (bottom of Table 3).

6 This number is not 50 because some block tasks need
multiple steps and players are also allowed to explore without
reaching the goal.

Most successful players (1st–20th)

rem cy pos 1, stack or blk pos 4, rem
blk pos 2 thru 5, rem blk pos 2 thru 4,
stack bn blk pos 1 thru 2, ﬁll bn blk,
stack or blk pos 2 thru 6, rem cy blk
pos 2 ﬁll rd blk (3.01)

remove the brown block, remove all
orange blocks, put brown block on
orange blocks, put orange blocks on
all blocks, put blue block on leftmost
blue block in top row (2.78)

Average players (21th–50th)

Remove the center block, Remove the
red block, Remove all red blocks,
Remove the ﬁrst orange block, Put a
brown block on the ﬁrst brown block,
Add blue block on ﬁrst blue block
(2.72)

reinsert pink, take brown, put in pink,
remove two pink from second layer,
Add two red to second layer in odd
intervals, Add ﬁve pink to second
layer, Remove one blue and one
brown from bottom layer (9.17)

remove red, remove 1 red, remove 2 4
orange, add 2 red, add 1 2 3 4 blue,
emove 1 3 5 orange, add 2 4 orange,
add 2 orange, remove 2 3 brown, add
1 2 3 4 5 red, remove 2 3 4 5 6,
remove 2, add 1 2 3 4 6 red (8.37)

move second cube, double red with
blue, double ﬁrst red with red, triple
second and fourth with orange, add
red, remove orange on row two, add
blue to column two, add brown on
ﬁrst and third (7.18)

holdleftmost, holdbrown,
holdleftmost, blueonblue,
brownonblue1, blueonorange,
holdblue, holdorange2, blueonred2 ,
holdends1, holdrightend, hold2,
orangeonorangerightmost (14.15)

usu´n br ˛azowe klocki, postaw
pomara´nczowy klocek na pierwszym
klocku, postaw czerwone klocki na
pomara´nczowych, usu´n
pomara´nczowe klocki w górnym
rz˛edzie

Least successful players (51th–)

‘add red cubes on center left, center
right, far left and far right’, ‘remove
blue blocks on row two column two,
row two column four’, remove red
blocks in center left and center right
on second row (12.6)

Spam players (∼ 85th–100)

Most interesting

rm scat + 1 c, + 1 c, rm sh, + 1 2 4 sh,
+ 1 c, - 4 o, rm 1 r, + 1 3 o, full ﬁll c,
rm o, full ﬁll sh, - 1 3, full ﬁll sh, rm
sh, rm r, + 2 3 r, rm o, + 3 sh, + 2 3
sh, rm b, - 1 o, + 2 c,

laugh with me, red blocks with one
aqua, aqua red alternate, brown red
red orange aqua orange, red brown
red brown red brown, space red
orange red, second level red space red
space red space (14.32)

mBROWN,mBLUE,mORANGE
RED+ORANGEˆORANGE,
BROWN+BROWNm1+BROWNm3,
ORANGE +BROWN
+ORANGEˆm1+ ORANGEˆm3 +
BROWNˆˆ2 + BROWNˆˆ4

next, hello happy, how are you, move, gold, build goal blocks, 23,house, gabboli, x, run„xav, d, j, xcv, dulicate goal (21.7)

Table 3: Example utterances, along with the average number of scrolls for that player in parentheses.
Success is measured by the number of scrolls, where the more successful players need less scrolls. 1)
The 20 most successful players tend to use consistent and concise language whose semantics is similar
to our logical language. 2) Average players tend to be slightly more verbose and inconsistent (left and
right), or signiﬁcantly different from our logical langauge (middle). 3) Reasons for being unsuccessful
vary. Left: no tokenization, middle: used a coordinate system and many conjunctions; right: confused in
the beginning, and used a language very different from our logical language.

Overall, we ﬁnd that many players adapt in
ILLG by becoming more consistent, less verbose,
and more precise, even if they used standard En-
glish at the beginning. For example, some players
became more consistent over time (e.g. from us-
ing both ‘remove’ and ‘discard’ to only using ‘re-
move’). In terms of verbosity, removing function
words like determiners as the game progresses is
In each of the following
a common adaptation.
examples from different players, we compare an
utterance that appeared early in the game to a sim-
ilar utterance that appeared later: ‘Remove the red
ones’ became ‘Remove red.’; ‘add brown on top of
red’ became ‘add orange on red’; ‘add red blocks
to all red blocks’ became ‘add red to red’; ‘dark
red’ became ‘red’; one player used ‘the’ in all of
the ﬁrst 20 utterances, and then never used ‘the’ in
the last 75 utterances.

Players also vary in precision, ranging from
overspeciﬁed (e.g. ‘remove the orange cube at the
left’, ‘remove red blocks from top row’) to under-
speciﬁed or requiring context (e.g. ‘change col-
ors’, ‘add one blue’, ‘Build more blocus’, ‘Move
the blocks fool’,‘Add two red cubes’). We found
that some players became more precise over time,
as they gain a better understanding of ILLG.

Most players use utterances that actually do not
match our logical language in Table 1, even the
successful players. In particular, numbers are of-
ten used. While some concepts always have the
same effect in our blocks world (e.g. ‘ﬁrst block’
means leftmost), most are different. More con-
cretely, of the top 10 players, 7 used numbers of
some form and only 3 players matched our logical
language. Some players who did not match the
logical language performed quite well neverthe-

less. One possible explanation is because the ac-
tion required is somewhat constrained by the logi-
cal language and some tokens can have unintended
interpretations. For example, the computer can
correctly interpret numerical positional references,
as long as the player only refers to the leftmost
and rightmost positions. So if the player says ‘rem
blk pos 4’ and ‘rem blk pos 1’, the computer can
interpret ‘pos’ as rightmost and interpret the
bigram (‘pos’, ‘1’) as leftmost. On the other
hand, players who deviated signiﬁcantly by de-
scribing the desired state declaratively (e.g. ‘red
orange red’, ‘246’) rather than using actions, or
a coordinate system (e.g. ‘row two column two’)
performed poorly. Although players do not have
to match our logical language exactly to perform
well, being similar is deﬁnitely helpful.

Compositionality. As far as we can tell, all
players used a compositional language; no one in-
vented unrelated words for each action. Interest-
ingly, 3 players did not put spaces between words.
Since we assume monomorphemic words sepa-
rated by spaces, they had to do a lot of scrolling
as a result (e.g., 14.15 with utterances like ‘or-
angeonorangerightmost’).

5.3 Computer strategies

We now present quantitative results on how
quickly the computer can learn, where our goal is
to achieve high accuracy on new utterances as we
make just a single pass over the data. The num-
ber of scrolls used to evaluate player is sensitive to
outliers and not as intuitive as accuracy. Instead,
we consider online accuracy, described as follows.
Formally, if a player produced T utterances x(j)
and labeled them y(j), then

online accuracy

def=

1
T

T
(cid:88)

(cid:104)

I

j=1

y(j) =

(cid:105)

,

z(j)
(cid:74)

s(j)
(cid:75)

where z(j) = arg maxz pθ(j−1)(z|x(j)) is the
model prediction based on the previous parame-
ter θ(j−1). Note that the online accuracy is de-
ﬁned with respect to the player-reported labels,
which only corresponds to the actual accuracy if
the player is precise and honest. This is not true
for most spam players.

Compositionality. To study the importance of
compositionality, we consider
two baselines.
First, consider a non-compositional model (mem-

(a)

(b)

Figure 2: Pragmatics improve online accuracy. In
these plots, each marker is a player. red o: play-
ers who ranked 1–20 in terms of minimizing num-
ber of scrolls, green x: players 20–50; blue +:
lower than 50 (includes spam players). Marker
sizes correspond to player rank, where better play-
ers are depicted with larger markers. 2a: online
accuracies with and without pragmatics on the full
model; 2b: same for the half model.

Method
memorize
half model
half + prag
full model
full + prag

players ranked by # of scrolls

top 10
25.4
38.7
43.7
48.6
52.8

top 20
24.5
38.4
42.7
47.8
49.8

top 50
22.5
36.0
39.7
44.9
45.8

all 100
17.6
27.0
29.4
33.3
33.8

Table 4: Average online accuracy under vari-
featurize entire utter-
ous settings. memorize:
ance and logical form non-compositionally; half
model: featurize the utterances with unigrams, bi-
grams, and skip-grams but conjoin with the entire
logical form; full model: the model described in
Section 3; +prag: the models above, with our on-
line pragmatics algorithm described in Section 4.
Both compositionality and pragmatics improve ac-
curacy.

orize) that just remembers pairs of complete ut-
terance and logical forms. We implement this
using indicator features on features (x, z), e.g.,
(‘remove all the red blocks’, zrm-red), and use a
large learning rate.
Second, we consider a
model (half ) that treats utterances composition-
ally with unigrams, bigrams, and skip-trigrams
features, but the logical forms are regarded as
non-compositional, so we have features such as
(‘remove’, zrm-red), (‘red’, zrm-red), etc.

Table 4 shows that the full model (Section 3)
signiﬁcantly outperforms both the memorize and
half baselines. The learning rate η = 0.1 is se-
lected via cross validation, and we used α = 1
and β = 3 following Smith et al. (2013).

Pragmatics. Next, we study the effect of prag-
Figure 2 shows
matics on online accuracy.
that modeling pragmatics helps successful players
(e.g., top 10 by number of scrolls) who use precise
and consistent languages. Interestingly, our prag-
matics model did not help and can even hurt the
less successful players who are less precise and
consistent. This is expected behavior: the prag-
matics model assumes that the human is coopera-
tive and behaving rationally. For the bottom half
of the players, this assumption is not true, in which
case the pragmatics model is not useful.

6 Related Work and Discussion

Our work connects with a broad body of work on
grounded language, in which language is used in
some environment as a means towards some goal.
Examples include playing games (Branavan et al.,
2009, 2010; Reckman et al., 2010) interacting with
robotics (Tellex et al., 2011, 2014), and following
instructions (Vogel and Jurafsky, 2010; Chen and
Mooney, 2011; Artzi and Zettlemoyer, 2013) Se-
mantic parsing utterances to logical forms, which
we leverage, plays an important role in these set-
tings (Kollar et al., 2010; Matuszek et al., 2012;
Artzi and Zettlemoyer, 2013).

What makes this work unique is our new inter-
active learning of language games (ILLG) setting,
in which a model has to learn a language from
scratch through interaction. While online gradient
descent is frequently used, for example in seman-
tic parsing (Zettlemoyer and Collins, 2007; Chen,
2012), we using it in a truly online setting, taking
one pass over the data and measuring online accu-
racy (Cesa-Bianchi and Lugosi, 2006).

To speed up learning, we leverage computa-
tional models of pragmatics (Jäger, 2008; Golland
et al., 2010; Frank and Goodman, 2012; Smith
et al., 2013; Vogel et al., 2013). The main differ-
ence is these previous works use pragmatics with
a trained base model, whereas we learn the model
online. Monroe and Potts (2015) uses learning
to improve the pragmatics model.
In contrast,
we use pragmatics to speed up the learning pro-
cess by capturing phenomena like mutual exclu-
sivity (Markman and Wachtel, 1988). We also dif-
fer from prior work in several details. First, we
model pragmatics in the online learning setting
where we use an online update for the pragmat-
ics model. Second, unlikely the reference games
where pragmatic effects plays an important role by

design, SHRDLURN is not speciﬁcally designed
to require pragmatics. The improvement we get
is mainly due to players trying to be consistent in
their language use. Finaly, we treat both the utter-
ance and the logical forms as featurized composi-
tional objects. Smith et al. (2013) treats utterances
(i.e. words) and logical forms (i.e. objects) as cat-
egories; Monroe and Potts (2015) used features,
but also over ﬂat categories.

Looking forward, we believe that the ILLG set-
ting is worth studying and has important implica-
tions for natural language interfaces. Today, these
If these
systems are trained once and deployed.
systems could quickly adapt to user feedback in
real-time as in this work, then we might be able
to more readily create systems for resource-poor
languages and new domains, that are customizable
and improve through use.

Acknowledgments

DARPA Communicating with Computers (CwC)
program under ARO prime contract no. W911NF-
15-1-0462. The ﬁrst author is supported by a
NSERC PGS-D fellowship. In addition, we thank
Will Monroe, and Chris Potts for their insightful
comments and discussions on pragmatics.

Reproducibility

All code, data, and experiments for this paper are
available on the CodaLab platform:
https://worksheets.

codalab.org/worksheets/

0x9fe4d080bac944e9a6bd58478cb05e5e
The client side code is here:
https://github.com/sidaw/shrdlurn/tree/

acl16-demo
and a demo: http://shrdlurn.sidaw.xyz

References

Y. Artzi and L. Zettlemoyer. 2013. Weakly super-
vised learning of semantic parsers for mapping
instructions to actions. Transactions of the As-
sociation for Computational Linguistics (TACL)
1:49–62.

J. Berant, A. Chou, R. Frostig, and P. Liang. 2013.
Semantic parsing on Freebase from question-
answer pairs. In Empirical Methods in Natural
Language Processing (EMNLP).

S. Branavan, H. Chen, L. S. Zettlemoyer, and
R. Barzilay. 2009. Reinforcement learning for

In Associa-
mapping instructions to actions.
tion for Computational Linguistics and Inter-
national Joint Conference on Natural Language
Processing (ACL-IJCNLP). pages 82–90.

T. Kollar, S. Tellex, D. Roy, and N. Roy. 2010.
Grounding verbs of motion in natural language
commands to robots. In International Sympo-
sium on Experimental Robotics (ISER).

S. Branavan, L. Zettlemoyer, and R. Barzilay.
2010. Reading between the lines: Learning
to map high-level instructions to commands.
In Association for Computational Linguistics
(ACL). pages 1268–1277.

N. Cesa-Bianchi and G. Lugosi. 2006. Predic-
tion, learning, and games. Cambridge Univer-
sity Press.

D. L. Chen. 2012. Fast online lexicon learning for
grounded language acquisition. In Association
for Computational Linguistics (ACL).

D. L. Chen and R. J. Mooney. 2011. Learning
to interpret natural language navigation instruc-
tions from observations. In Association for the
Advancement of Artiﬁcial Intelligence (AAAI).
pages 859–865.

J. Duchi, E. Hazan, and Y. Singer. 2010. Adap-
tive subgradient methods for online learning
and stochastic optimization. In Conference on
Learning Theory (COLT).

M. Frank and N. D. Goodman. 2012. Predicting
pragmatic reasoning in language games. Sci-
ence 336:998–998.

H. Giles. 2008. Communication accommodation

theory. Sage Publications, Inc.

D. Golland, P. Liang, and D. Klein. 2010. A game-
theoretic approach to generating spatial descrip-
In Empirical Methods in Natural Lan-
tions.
guage Processing (EMNLP).

N. Goodman and D. Lassiter. 2015. Probabilistic
Semantics and Pragmatics: Uncertainty in Lan-
guage and Thought. The Handbook of Contem-
porary Semantic Theory, 2nd Edition Wiley-
Blackwell.

H. P. Grice. 1975. Logic and conversation. Syntax

and semantics 3:41–58.

M. E. Ireland, R. B. Slatcher, P. W. Eastwick, L. E.
Scissors, E. J. Finkel, and J. W. Pennebaker.
2011. Language style matching predicts rela-
tionship initiation and stability. Psychological
Science 22(1):39–44.

G. Jäger. 2008. Game theory in semantics and
pragmatics. Technical report, University of
Tübingen.

T. Kwiatkowski, L. Zettlemoyer, S. Goldwater,
and M. Steedman. 2010. Inducing probabilistic
CCG grammars from logical form with higher-
In Empirical Methods in
order uniﬁcation.
Natural Language Processing (EMNLP). pages
1223–1233.

P. Liang, M. I. Jordan, and D. Klein. 2011.
Learning dependency-based compositional se-
mantics. In Association for Computational Lin-
guistics (ACL). pages 590–599.

E. Markman and G. F. Wachtel. 1988. Children’s
use of mutual exclusivity to constrain the mean-
ings of words. Cognitive Psychology 20:125–
157.

C. Matuszek, N. FitzGerald, L. Zettlemoyer,
L. Bo, and D. Fox. 2012. A joint model of
language and perception for grounded attribute
In International Conference on Ma-
learning.
chine Learning (ICML). pages 1671–1678.

W. Monroe and C. Potts. 2015. Learning in the
Rational Speech Acts model. In Proceedings of
20th Amsterdam Colloquium.

P. Pasupat and P. Liang. 2015. Compositional se-
mantic parsing on semi-structured tables. In As-
sociation for Computational Linguistics (ACL).

H. Reckman, J. Orkin, and D. Roy. 2010. Learning
meanings of words and constructions, grounded
In Conference on Natural
in a virtual game.
Language Processing (KONVENS).

N. J. Smith, N. D. Goodman, and M. C. Frank.
2013. Learning and using language via re-
cursive pragmatic reasoning about other agents.
In Advances in Neural Information Processing
Systems (NIPS).

S. Tellex, R. Knepper, A. Li, D. Rus, and N. Roy.
2014. Asking for help using inverse semantics.
In Robotics: Science and Systems (RSS).

S. Tellex, T. Kollar, S. Dickerson, M. R. Walter,
A. G. Banerjee, S. J. Teller, and N. Roy. 2011.
Understanding natural language commands for
robotic navigation and mobile manipulation. In
Association for the Advancement of Artiﬁcial
Intelligence (AAAI).

A. Vogel, M. Bodoia, C. Potts, and D. Juraf-
sky. 2013. Emergence of gricean maxims from

In North Ameri-
multi-agent decision theory.
can Association for Computational Linguistics
(NAACL). pages 1072–1081.

A. Vogel and D. Jurafsky. 2010. Learning to fol-
low navigational directions. In Association for
Computational Linguistics (ACL). pages 806–
814.

T. Winograd. 1972. Understanding Natural Lan-

guage. Academic Press.

L. Wittgenstein. 1953. Philosophical Investiga-

tions. Blackwell, Oxford.

Y. W. Wong and R. J. Mooney. 2007. Learn-
ing synchronous grammars for semantic parsing
with lambda calculus. In Association for Com-
putational Linguistics (ACL). pages 960–967.

L. S. Zettlemoyer and M. Collins. 2005. Learn-
ing to map sentences to logical form: Struc-
tured classiﬁcation with probabilistic categorial
In Uncertainty in Artiﬁcial Intelli-
grammars.
gence (UAI). pages 658–666.

L. S. Zettlemoyer and M. Collins. 2007. Online
learning of relaxed CCG grammars for parsing
to logical form. In Empirical Methods in Nat-
ural Language Processing and Computational
Natural Language Learning (EMNLP/CoNLL).
pages 678–687.

Learning Language Games through Interaction

Sida I. Wang

Percy Liang

Christopher D. Manning

Computer Science Department
Stanford University
{sidaw,pliang,manning}@cs.stanford.edu

6
1
0
2
 
n
u
J
 
8
 
 
]
L
C
.
s
c
[
 
 
1
v
7
4
4
2
0
.
6
0
6
1
:
v
i
X
r
a

Abstract

We introduce a new language learning
setting relevant to building adaptive nat-
It is inspired
ural language interfaces.
by Wittgenstein’s language games: a hu-
man wishes to accomplish some task
(e.g., achieving a certain conﬁguration of
blocks), but can only communicate with a
computer, who performs the actual actions
(e.g., removing all red blocks). The com-
puter initially knows nothing about lan-
guage and therefore must learn it from
scratch through interaction, while the hu-
man adapts to the computer’s capabilities.
We created a game called SHRDLURN in
a blocks world and collected interactions
from 100 people playing it. First, we an-
alyze the humans’ strategies, showing that
using compositionality and avoiding syn-
onyms correlates positively with task per-
formance. Second, we compare computer
strategies, showing that modeling prag-
matics on a semantic parsing model accel-
erates learning for more strategic players.

1

Introduction

Wittgenstein (1953) famously said that language
derives its meaning from use, and introduced the
concept of language games to illustrate the ﬂuid-
ity and purpose-orientedness of language. He de-
scribed how a builder B and an assistant A can use
a primitive language consisting of four words—
‘block’, ‘pillar’, ‘slab’, ‘beam’—to successfully
communicate what block to pass from A to B. This
is only one such language; many others would also
work for accomplishing the cooperative goal.

This paper operationalizes and explores the idea
of language games in a learning setting, which we
call interactive learning through language games

Figure 1: The SHRDLURN game: the objective
is to transform the start state into the goal state.
The human types in an utterance, and the computer
(which does not know the goal state) tries to in-
terpret the utterance and perform the correspond-
ing action. The computer initially knows nothing
about the language, but through the human’s feed-
back, learns the human’s language while making
progress towards the game goal.

(ILLG). In the ILLG setting, the two parties do not
initially speak a common language, but nonethe-
less need to collaboratively accomplish a goal.
Speciﬁcally, we created a game called SHRD-
LURN,1 in homage to the seminal work of Wino-
grad (1972). As shown in Figure 1, the objective
is to transform a start state into a goal state, but
the only action the human can take is entering an
utterance. The computer parses the utterance and
produces a ranked list of possible interpretations
according to its current model. The human scrolls
through the list and chooses the intended one, si-
multaneously advancing the state of the blocks and
providing feedback to the computer. Both the hu-
man and the computer wish to reach the goal state

1Demo: http://shrdlurn.sidaw.xyz

(only known to the human) with as little scrolling
as possible. For the computer to be successful, it
has to learn the human’s language quickly over the
course of the game, so that the human can accom-
plish the goal more efﬁciently. Conversely, the hu-
man must also accommodate the computer, at least
partially understanding what it can and cannot do.

We model the computer in the ILLG as a se-
mantic parser (Section 3), which maps natural lan-
guage utterances (e.g., ‘remove red’) into logical
forms (e.g., remove(with(red))). The seman-
tic parser has no seed lexicon and no annotated
logical forms, so it just generates many candidate
logical forms. Based on the human’s feedback, it
performs online gradient updates on the parame-
ters corresponding to simple lexical features.

During development,

it became evident that
while the computer was eventually able to learn
the language, it was learning less quickly than
one might hope. For example, after learning that
‘remove red’ maps to remove(with(red)),
it would think that ‘remove cyan’ also mapped
to remove(with(red)), whereas a human
would likely use mutual exclusivity to rule out that
hypothesis (Markman and Wachtel, 1988). We
therefore introduce a pragmatics model in which
the computer explicitly reasons about the human,
in the spirit of previous work on pragmatics (Gol-
land et al., 2010; Frank and Goodman, 2012;
Smith et al., 2013). To make the model suitable
for our ILLG setting, we introduce a new online
learning algorithm. Empirically, we show that our
pragmatic model improves the online accuracy by
8% compared to our best non-pragmatic model on
the 10 most successful players (Section 5.3).

What is special about the ILLG setting is the
real-time nature of learning, in which the human
also learns and adapts to the computer. While
the human can teach the computer any language—
English, Arabic, Polish, a custom programming
language—a good human player will choose to
use utterances that the computer is more likely to
learn quickly. In the parlance of communication
theory, the human accommodates the computer
(Giles, 2008; Ireland et al., 2011). Using Ama-
zon Mechanical Turk, we collected and analyzed
around 10k utterances from 100 games of SHRD-
LURN. We show that successful players tend to
use compositional utterances with a consistent vo-
cabulary and syntax, which matches the inductive
biases of the computer (Section 5.2). In addition,

through this interaction, many players adapt to the
computer by becoming more consistent, more pre-
cise, and more concise.

On the practical side, natural language systems
are often trained once and deployed, and users
must live with their imperfections. We believe
that studying the ILLG setting will be integral for
creating adaptive and customizable systems, es-
pecially for resource-poor languages and new do-
mains where starting from close to scratch is un-
avoidable.

2 Setting

(e.g.

We now describe the interactive learning of lan-
guage games (ILLG) setting formally. There are
two players, the human and the computer. The
game proceeds through a ﬁxed number of levels.
In each level, both players are presented with a
starting state s ∈ Y, but only the human sees
in SHRDLURN, Y
the goal state t ∈ Y.
is the set of all conﬁgurations of blocks). The
human transmits an utterance x (e.g., ‘remove
red’) to the computer. The computer then con-
structs a ranked list of candidate actions Z =
[z1, . . . , zK] ⊆ Z (e.g., remove(with(red)),
add(with(orange)), etc.), where Z is all
possible actions. For each zi ∈ Z, it computes
yi =
s, the successor state from executing ac-
(cid:75)
tion zi on state s. The computer returns to the hu-
man the ordered list Y = [y1, . . . , yK] of succes-
sor states. The human then chooses yi from the list
Y (we say the computer is correct if i = 1). The
state then updates to s = yi. The level ends when
s = t, and the players advance to the next level.

zi
(cid:74)

Since only the human knows the goal state t and
only the computer can perform actions, the only
way for the two to play the game successfully is
for the human to somehow encode the desired ac-
tion in the utterance x. However, we assume the
two players do not have a shared language, so the
human needs to pick a language and teach it to the
computer. As an additional twist, the human does
not know the exact set of actions Z (although they
might have some preconception of the computer’s
capabilities).2 Finally, the human only sees the
outcomes of the computer’s actions, not the actual
logical actions themselves.

We expect the game to proceed as follows: In
the beginning, the computer does not understand

2This is often the case when we try to interact with a new

software system or service before reading the manual.

what the human is saying and performs arbitrary
actions. As the computer obtains feedback and
learns, the two should become more proﬁcient at
communicating and thus playing the game. Herein
lies our key design principle: language learning
should be necessary for the players to achieve
good game performance.

SHRDLURN. Let us now describe the details
of our speciﬁc game, SHRDLURN. Each state
s ∈ Y consists of stacks of colored blocks ar-
ranged in a line (Figure 1), where each stack
The actions
is a vertical column of blocks.
Z are deﬁned compositionally via the gram-
mar in Table 1.
Each action either adds to
or removes from a set of stacks, and a set of
stacks is computed via various set operations
and selecting by color. For example, the action
remove(leftmost(with(red))) removes the
top block from the leftmost stack whose topmost
block is red. The compositionality of the actions
gives the computer non-trivial capabilities. Of
course, the human must teach a language to har-
ness those capabilities, while not quite knowing
the exact extent of the capabilities. The actual
game proceeds according to a curriculum, where
the earlier levels only need simpler actions with
fewer predicates.

We designed SHRDLURN in this way for sev-
eral reasons. First, visual block manipulations are
intuitive and can be easily crowdsourced, and it
can be fun as an actual game that people would
play. Second, the action space is designed to be
compositional, mirroring the structure of natural
language. Third, many actions z lead to the same
s; e.g., the ‘leftmost stack’
successor state y =
(cid:75)
might coincide with the ‘stack with red blocks’ for
some state s and therefore an action involving ei-
ther one would result in the same outcome. Since
the human only points out the correct y, the com-
puter must grapple with this indirect supervision,
a reﬂection of real language learning.

z
(cid:74)

3 Semantic parsing model

Following Zettlemoyer and Collins (2005) and
most recent work on semantic parsing, we use
a log-linear model over logical forms (actions)
z ∈ Z given an utterance x:

pθ(z | x) ∝ exp(θTφ(x, z)),

(1)

where φ(x, z) ∈ Rd is a feature vector and θ ∈ Rd
is a parameter vector. The denotation y (succes-

sor state) is obtained by executing z on a state s;
formally, y =

z
(cid:74)

s.
(cid:75)

Features. Our features are n-grams (including
skip-grams) conjoined with tree-grams on the log-
Speciﬁcally, on the utterance
ical form side.
side (e.g., ‘stack red on orange’), we use uni-
grams (‘stack’, ∗, ∗), bigrams (‘red’, ‘on’, ∗), tri-
grams (‘red’, ‘on’, ‘orange’), and skip-trigrams
(‘stack’, ∗, ‘on’). On the logical form side, fea-
tures corresponds to the predicates in the logical
forms and their arguments. For each predicate h,
let h.i be the i-th argument of h. Then, we de-
ﬁne tree-gram features ψ(h, d) for predicate h and
depth d = 0, 1, 2, 3 recursively as follows:

ψ(h, 0) = {h},

ψ(h, d) = {(h, i, ψ(h.i, d − 1)) | i = 1, 2, 3}.

The set of all features is just the cross product
of utterance features and logical form features.
if x = ‘enlever tout’ and z =
For example,
remove(all()), then features include:

(‘enlever’, all)
(‘enlever’, remove)
(‘enlever’, (remove, 1, all))
(‘tout’, (remove, 1, all))

(‘tout’, all)
(‘tout’, remove)

Note that we do not model an explicit alignment
or derivation compositionally connecting the utter-
ance and the logical form, in contrast to most tradi-
tional work in semantic parsing (Zettlemoyer and
Collins, 2005; Wong and Mooney, 2007; Liang
et al., 2011; Kwiatkowski et al., 2010; Berant
et al., 2013), instead following a looser model of
semantics similar to (Pasupat and Liang, 2015).
Modeling explicit alignments or derivations is
only computationally feasible when we are learn-
ing from annotated logical forms or have a seed
lexicon, since the number of derivations is much
larger than the number of logical forms.
In the
ILLG setting, neither are available.

Generation/parsing. We generate logical forms
from smallest
to largest using beam search.
Speciﬁcally, for each size n = 1, . . . , 8, we con-
struct a set of logical forms of size n (with ex-
actly n predicates) by combining logical forms of
smaller sizes according to the grammar rules in Ta-
ble 1. For each n, we keep the 100 logical forms z
with the highest score θTφ(x, z) according to the
current model θ. Let Z be the set of logical forms
on the ﬁnal beam, which contains logical forms
of all sizes n. During training, due to pruning at

Rule

Semantics

Description

Set
Color
Color → Set
Set → Set
Set → Set
Set Color → Act add(s, c)
Set → Act

remove(s)

all stacks

all()
cyan|brown|red|orange primitive color
with(c)
not(s)
leftmost|rightmost(s)

stacks whose top block has color c
all stacks except those in s
leftmost/rightmost stack in s
add block with color c on each stack in s
remove the topmost block of each stack in s

Table 1: The formal grammar deﬁning the compositional action space Z for SHRDLURN.
We use c to denote a Color, and s to denote a Set.
For example, one action that we
the leftmost brown block’
(cid:55)→
have in SHRDLURN is:
add(not(leftmost(with(brown))),orange).

‘add an orange block to all but

intermediate sizes, Z is not guaranteed to contain
the logical form that obtains the observed state y.
To mitigate this effect, we use a curriculum so that
only simple actions are needed in the initial levels,
giving the human an opportunity to teach the com-
puter about basic terms such as colors ﬁrst before
moving to larger composite actions.

The system executes all of the logical forms on
the ﬁnal beam Z, and orders the resulting denota-
tions y by the maximum probability of any logical
form that produced it.3

Learning. When the human provides feedback
in the form of a particular y, the system forms the
following loss function:

(cid:96)(θ, x, y) = − log pθ(y | x, s) + λ||θ||1,

pθ(y | x, s) =

pθ(z | x).

(2)

(3)

(cid:88)

z:

z
(cid:74)

s=y
(cid:75)

Then it makes a single gradient update using Ada-
Grad (Duchi et al., 2010), which maintains a per-
feature step size.

4 Modeling pragmatics

In our initial experience with the semantic pars-
ing model described in Section 3, we found
that it was able to learn reasonably well, but
lacked a reasoning ability that one ﬁnds in hu-
man learners. To illustrate the point, consider
the beginning of a game when θ = 0 in the
log-linear model pθ(z
Suppose that
human utters ‘remove red’ and then identiﬁes

| x).

3 We tried ordering based on the sum of the probabilities
(which corresponds to marginalizing out the logical form),
but this had the degenerate effect of assigning too much prob-
ability mass to y being the set of empty stacks, which can
result from many actions.

zrm-red = remove(with(red)) as the cor-
rect logical form. The computer then performs
a gradient update on the loss function (2), up-
weighting features such as (‘remove’, remove)
and (‘remove’, red).

Next, suppose the human utters ‘remove cyan’.
Note that zrm-red will score higher than all other
formulas since the (‘remove’, red) feature will
ﬁre again. While statistically justiﬁed, this be-
havior fails to meet our intuitive expectations for
a smart language learner. Moreover, this behav-
ior is not speciﬁc to our model, but applies to any
statistical model that simply tries to ﬁt the data
without additional prior knowledge about the spe-
ciﬁc language. While we would not expect the
computer to magically guess ‘remove cyan’
(cid:55)→
remove(with(cyan)), it should at least push
down the probability of zrm-red because zrm-red
intuitively is already well-explained by another ut-
terance ‘remove red’.

This phenomenon, mutual exclusivity, was stud-
ied by Markman and Wachtel (1988). They found
that children, during their language acquisition
process, reject a second label for an object and
treat it instead as a label for a novel object.

The pragmatic computer. To model mutual ex-
clusivity formally, we turn to probabilistic mod-
els of pragmatics (Golland et al., 2010; Frank and
Goodman, 2012; Smith et al., 2013; Goodman and
Lassiter, 2015), which operationalize the ideas of
Grice (1975). The central idea in these models is
to treat language as a cooperative game between
a speaker (human) and a listener (computer) as
we are doing, but where the listener has an ex-
plicit model of the speaker’s strategy, which in
turn models the listener. Formally, let S(x | z) be
the speaker’s strategy and L(z | x) be the listener’s

zrm-red

z3, z4, . . .

‘remove red’
‘remove cyan’

0.8
0.6

‘remove red’
‘remove cyan’

‘remove red’
‘remove cyan’

0.57
0.43

0.46
0.24

zrm-cyan
pθ(z | x)
0.1
0.2
S(x | z)
0.33
0.67
L(z | x)
0.27
0.38

0.1
0.2

0.33
0.67

0.27
0.38

top:

Table 2: Suppose the computer saw one exam-
ple of ‘remove red’ (cid:55)→zrm-red, and then the hu-
man utters ‘remove cyan’.
the literal lis-
tener, pθ(z | x), mistakingly chooses zrm-red
over zrm-cyan. middle:
the pragmatic speaker,
S(x | z), assigns a higher probability to to ‘remove
cyan’ given zrm-cyan; bottom: the pragmatic lis-
tener, L(z | x) correctly assigns a lower probabil-
ity to zrm-red where p(z) is uniform.

strategy. The speaker takes into account the literal
semantic parsing model pθ(z | x) as well as a prior
over utterances p(x), while the listener considers
the speaker S(x | z) and a prior p(z):

S(x | z) ∝ (pθ(z | x)p(x))β ,
L(z | x) ∝ S(x | z)p(z),

(4)

(5)

where β ≥ 1 is a hyperparameter that sharpens
the distribution (Smith et al., 2013). The com-
puter would then use L(z | x) to rank candidates
rather than pθ. Note that our pragmatic model only
affects the ranking of actions returned to the hu-
man and does not affect the gradient updates of
the model pθ.

Let us walk through a simple example to see the
effect of modeling pragmatics. Table 2 shows that
the literal listener pθ(z | x) assigns high probabil-
ity to zrm-red for both ‘remove red’ and ‘remove
cyan’. Assuming a uniform p(x) and β = 1, the
pragmatic speaker S(x | z) corresponds to normal-
izing each column of pθ. Note that if the pragmatic
speaker wanted to convey zrm-cyan, there is a de-
cent chance that they would favor ‘remove cyan’.
Next, assuming a uniform p(z), the pragmatic lis-
tener L(z | x) corresponds to normalizing each
row of S(x | z). The result is that conditioned on
‘remove cyan’, zrm-cyan is now more likely than
zrm-red, which is the desired effect.

The pragmatic listener models the speaker as a
cooperative agent who behaves in a way to max-
imize communicative success. Certain speaker

behaviors such as avoiding synonyms (e.g., not
‘delete cardinal’) and using a consistent word or-
dering (e.g, not ‘red remove’) fall out of the game
theory.4 For speakers that do not follow this strat-
egy, our pragmatic model is incorrect, but as we
get more data through game play, the literal lis-
tener pθ(z | x) will sharpen, so that the literal lis-
tener and the pragmatic listener will coincide in
the limit.

∀z, C(z) ← 0
∀z, Q(z) ← (cid:15)
repeat

receive utterance x from human
L(z | x) ∝ P (z)
Q(z) pθ(z | x)β
send human a list Y ranked by L(z | x)

receive y ∈ Y from human
θ ← θ − η∇θ(cid:96)(θ, x, y)
Q(z) ← Q(z) + pθ(z | x)β
C(z) ← C(z) + pθ(z | x,
P (z) ←

C(z)+α

(cid:80)

z(cid:48):C(z(cid:48))>0

z
(cid:74)

s = y)
(cid:75)
(cid:0)C(z(cid:48))+α(cid:1)

until game ends

Algorithm 1: Online learning algorithm that
updates the parameters of the semantic parser
θ as well as counts C, Q required to perform
pragmatic reasoning.

Online learning with pragmatics. To imple-
ment the pragmatic listener as deﬁned in (5), we
need to compute the speaker’s normalization con-
stant (cid:80)
x pθ(z | x)p(x) in order to compute S(x |
z) in (4). This requires parsing all utterances x
based on pθ(z | x). To avoid this heavy computa-
tion in an online setting, we propose Algorithm 1,
where some approximations are used for the sake
of efﬁciency. First, to approximate the intractable
sum over all utterances x, we only use the exam-
ples that are seen to compute the normalization
x pθ(z | x)p(x) ≈ (cid:80)
constant (cid:80)
i pθ(z | xi).
Then, in order to avoid parsing all previous exam-
ples again using the current parameters for each
new example, we store Q(z) = (cid:80)
i pθi(z | xi)β,
where θi is the parameter after the model updates
on the ith example xi. While θi is different from
the current parameter θ, pθ(z | xi) ≈ pθi(z | xi)
for the relevant example xi, which is accounted for

4 Of course, synonyms and variable word order occur in
real language. We would need a more complex game com-
pared to SHRDLURN to capture this effect.

by both θi and θ.

In Algorithm 1, the pragmatic listener L(z | x)
can be interpreted as an importance-weighted ver-
sion of the sharpened literal listener pβ
θ , where it
is downweighted by Q(z), which reﬂects which
z’s the literal listener prefers, and upweighted by
P (z), which is just a smoothed estimate of the ac-
tual distribution over logical forms p(z). By con-
struction, Algorithm 1 is the same as (4) except
that it uses the normalization constant Q based on
stale parameters θi after seeing example, and it
uses samples to compute the sum over x. Follow-
ing (5), we also need p(z), which is estimated by
P (z) using add-α smoothing on the counts C(z).
Note that Q(z) and C(z) are updated after the
model parameters are updated for the current ex-
ample.

z
(cid:74)

z
(cid:74)

z
(cid:74)

Lastly, there is a small complication due to only
observing the denotation y and not the logical
form z. We simply give each consistent logical
s = y} a pseudocount based on
form {z |
(cid:75)
the model: C(z) ← C(z) + pθ(z | x,
s = y)
(cid:75)
s = y) ∝ exp(θTφ(x, z)) for
where pθ(z | x,
(cid:75)
z
(cid:74)

s = y (0 otherwise).
(cid:75)
Compared to prior work where the setting is
speciﬁcally designed to require pragmatic infer-
ence, pragmatics arises naturally in ILLG. We
think that this form of pragmatics is the most im-
portant during learning, and becomes less impor-
tant if we had more data. Indeed, if we have a lot
of data and a small number of possible zs, then
L(z|x) ≈ pθ(z|x) as (cid:80)
x pθ(z|x)p(x) → p(z)
when β = 1.5 However, for semantic parsing,
we would not be in this regime even if we have
a large amount of training data. In particular, we
are nowhere near that regime in SHRDLURN, and
most of our utterances / logical forms are seen only
once, and the importance of modeling pragmatics
remains.

5 Experiments

5.1 Setting

Data. Using Amazon Mechanical Turk (AMT),
we paid 100 workers 3 dollars each to play SHRD-
LURN. In total, we have 10223 utterances along
with their starting states s. Of these, 8874 ut-
terances are labeled with their denotations y; the
rest are unlabeled, since the player can try any ut-
terance without accepting an action. 100 players
completed the entire game under identical settings.

5Technically, we also need pθ to be well-speciﬁed.

We deliberately chose to start from scratch for ev-
ery worker, so that we can study the diversity of
strategies that different people used in a controlled
setting.

Each game consists of 50 blocks tasks divided
into 5 levels of 10 tasks each, in increasing com-
plexity. Each level aims to reach an end goal
given a start state. Each game took on average
89 utterances to complete.6 It only took 6 hours
to complete these 100 games on AMT and each
game took around an hour on average according to
AMT’s work time tracker (which does not account
for multi-tasking players). The players were pro-
vided minimal instructions on the game controls.
Importantly, we gave no example utterances in or-
der to avoid biasing their language use. Around
20 players were confused and told us that the in-
structions were not clear and gave us mostly spam
utterances. Fortunately, most players understood
the setting and some even enjoyed SHRDLURN
as reﬂected by their optional comments:

• That was probably the most fun thing I have

ever done on mTurk.

• Wow this was one mind bending games [sic].

Metrics. We use the number of scrolls as a mea-
sure of game performance for each player. For
each example, the number of scrolls is the position
in the list Y of the action selected by the player. It
was possible to complete this version of SHRD-
LURN by scrolling (all actions can be found in
the ﬁrst 125 of Y )—22 of the 100 players failed to
teach an actual language, and instead ﬁnished the
game mostly by scrolling. Let us call them spam
players, who usually typed single letters, random
words, digits, or random phrases (e.g. ‘how are
you’). Overall, spam players had to scroll a lot:
21.6 scrolls per utterance versus only 7.4 for the
non-spam players.

5.2 Human strategies

Some example utterances can be found in Table 3.
Most of the players used English, but vary in their
adherence to conventions such as use of determin-
ers, plurals, and proper word ordering. 5 players
invented their own language, which are more pre-
cise, more consistent than general English. One
player used Polish, and another used Polish nota-
tion (bottom of Table 3).

6 This number is not 50 because some block tasks need
multiple steps and players are also allowed to explore without
reaching the goal.

Most successful players (1st–20th)

rem cy pos 1, stack or blk pos 4, rem
blk pos 2 thru 5, rem blk pos 2 thru 4,
stack bn blk pos 1 thru 2, ﬁll bn blk,
stack or blk pos 2 thru 6, rem cy blk
pos 2 ﬁll rd blk (3.01)

remove the brown block, remove all
orange blocks, put brown block on
orange blocks, put orange blocks on
all blocks, put blue block on leftmost
blue block in top row (2.78)

Average players (21th–50th)

Remove the center block, Remove the
red block, Remove all red blocks,
Remove the ﬁrst orange block, Put a
brown block on the ﬁrst brown block,
Add blue block on ﬁrst blue block
(2.72)

reinsert pink, take brown, put in pink,
remove two pink from second layer,
Add two red to second layer in odd
intervals, Add ﬁve pink to second
layer, Remove one blue and one
brown from bottom layer (9.17)

remove red, remove 1 red, remove 2 4
orange, add 2 red, add 1 2 3 4 blue,
emove 1 3 5 orange, add 2 4 orange,
add 2 orange, remove 2 3 brown, add
1 2 3 4 5 red, remove 2 3 4 5 6,
remove 2, add 1 2 3 4 6 red (8.37)

move second cube, double red with
blue, double ﬁrst red with red, triple
second and fourth with orange, add
red, remove orange on row two, add
blue to column two, add brown on
ﬁrst and third (7.18)

holdleftmost, holdbrown,
holdleftmost, blueonblue,
brownonblue1, blueonorange,
holdblue, holdorange2, blueonred2 ,
holdends1, holdrightend, hold2,
orangeonorangerightmost (14.15)

usu´n br ˛azowe klocki, postaw
pomara´nczowy klocek na pierwszym
klocku, postaw czerwone klocki na
pomara´nczowych, usu´n
pomara´nczowe klocki w górnym
rz˛edzie

Least successful players (51th–)

‘add red cubes on center left, center
right, far left and far right’, ‘remove
blue blocks on row two column two,
row two column four’, remove red
blocks in center left and center right
on second row (12.6)

Spam players (∼ 85th–100)

Most interesting

rm scat + 1 c, + 1 c, rm sh, + 1 2 4 sh,
+ 1 c, - 4 o, rm 1 r, + 1 3 o, full ﬁll c,
rm o, full ﬁll sh, - 1 3, full ﬁll sh, rm
sh, rm r, + 2 3 r, rm o, + 3 sh, + 2 3
sh, rm b, - 1 o, + 2 c,

laugh with me, red blocks with one
aqua, aqua red alternate, brown red
red orange aqua orange, red brown
red brown red brown, space red
orange red, second level red space red
space red space (14.32)

mBROWN,mBLUE,mORANGE
RED+ORANGEˆORANGE,
BROWN+BROWNm1+BROWNm3,
ORANGE +BROWN
+ORANGEˆm1+ ORANGEˆm3 +
BROWNˆˆ2 + BROWNˆˆ4

next, hello happy, how are you, move, gold, build goal blocks, 23,house, gabboli, x, run„xav, d, j, xcv, dulicate goal (21.7)

Table 3: Example utterances, along with the average number of scrolls for that player in parentheses.
Success is measured by the number of scrolls, where the more successful players need less scrolls. 1)
The 20 most successful players tend to use consistent and concise language whose semantics is similar
to our logical language. 2) Average players tend to be slightly more verbose and inconsistent (left and
right), or signiﬁcantly different from our logical langauge (middle). 3) Reasons for being unsuccessful
vary. Left: no tokenization, middle: used a coordinate system and many conjunctions; right: confused in
the beginning, and used a language very different from our logical language.

Overall, we ﬁnd that many players adapt in
ILLG by becoming more consistent, less verbose,
and more precise, even if they used standard En-
glish at the beginning. For example, some players
became more consistent over time (e.g. from us-
ing both ‘remove’ and ‘discard’ to only using ‘re-
move’). In terms of verbosity, removing function
words like determiners as the game progresses is
In each of the following
a common adaptation.
examples from different players, we compare an
utterance that appeared early in the game to a sim-
ilar utterance that appeared later: ‘Remove the red
ones’ became ‘Remove red.’; ‘add brown on top of
red’ became ‘add orange on red’; ‘add red blocks
to all red blocks’ became ‘add red to red’; ‘dark
red’ became ‘red’; one player used ‘the’ in all of
the ﬁrst 20 utterances, and then never used ‘the’ in
the last 75 utterances.

Players also vary in precision, ranging from
overspeciﬁed (e.g. ‘remove the orange cube at the
left’, ‘remove red blocks from top row’) to under-
speciﬁed or requiring context (e.g. ‘change col-
ors’, ‘add one blue’, ‘Build more blocus’, ‘Move
the blocks fool’,‘Add two red cubes’). We found
that some players became more precise over time,
as they gain a better understanding of ILLG.

Most players use utterances that actually do not
match our logical language in Table 1, even the
successful players. In particular, numbers are of-
ten used. While some concepts always have the
same effect in our blocks world (e.g. ‘ﬁrst block’
means leftmost), most are different. More con-
cretely, of the top 10 players, 7 used numbers of
some form and only 3 players matched our logical
language. Some players who did not match the
logical language performed quite well neverthe-

less. One possible explanation is because the ac-
tion required is somewhat constrained by the logi-
cal language and some tokens can have unintended
interpretations. For example, the computer can
correctly interpret numerical positional references,
as long as the player only refers to the leftmost
and rightmost positions. So if the player says ‘rem
blk pos 4’ and ‘rem blk pos 1’, the computer can
interpret ‘pos’ as rightmost and interpret the
bigram (‘pos’, ‘1’) as leftmost. On the other
hand, players who deviated signiﬁcantly by de-
scribing the desired state declaratively (e.g. ‘red
orange red’, ‘246’) rather than using actions, or
a coordinate system (e.g. ‘row two column two’)
performed poorly. Although players do not have
to match our logical language exactly to perform
well, being similar is deﬁnitely helpful.

Compositionality. As far as we can tell, all
players used a compositional language; no one in-
vented unrelated words for each action. Interest-
ingly, 3 players did not put spaces between words.
Since we assume monomorphemic words sepa-
rated by spaces, they had to do a lot of scrolling
as a result (e.g., 14.15 with utterances like ‘or-
angeonorangerightmost’).

5.3 Computer strategies

We now present quantitative results on how
quickly the computer can learn, where our goal is
to achieve high accuracy on new utterances as we
make just a single pass over the data. The num-
ber of scrolls used to evaluate player is sensitive to
outliers and not as intuitive as accuracy. Instead,
we consider online accuracy, described as follows.
Formally, if a player produced T utterances x(j)
and labeled them y(j), then

online accuracy

def=

1
T

T
(cid:88)

(cid:104)

I

j=1

y(j) =

(cid:105)

,

z(j)
(cid:74)

s(j)
(cid:75)

where z(j) = arg maxz pθ(j−1)(z|x(j)) is the
model prediction based on the previous parame-
ter θ(j−1). Note that the online accuracy is de-
ﬁned with respect to the player-reported labels,
which only corresponds to the actual accuracy if
the player is precise and honest. This is not true
for most spam players.

Compositionality. To study the importance of
compositionality, we consider
two baselines.
First, consider a non-compositional model (mem-

(a)

(b)

Figure 2: Pragmatics improve online accuracy. In
these plots, each marker is a player. red o: play-
ers who ranked 1–20 in terms of minimizing num-
ber of scrolls, green x: players 20–50; blue +:
lower than 50 (includes spam players). Marker
sizes correspond to player rank, where better play-
ers are depicted with larger markers. 2a: online
accuracies with and without pragmatics on the full
model; 2b: same for the half model.

Method
memorize
half model
half + prag
full model
full + prag

players ranked by # of scrolls

top 10
25.4
38.7
43.7
48.6
52.8

top 20
24.5
38.4
42.7
47.8
49.8

top 50
22.5
36.0
39.7
44.9
45.8

all 100
17.6
27.0
29.4
33.3
33.8

Table 4: Average online accuracy under vari-
featurize entire utter-
ous settings. memorize:
ance and logical form non-compositionally; half
model: featurize the utterances with unigrams, bi-
grams, and skip-grams but conjoin with the entire
logical form; full model: the model described in
Section 3; +prag: the models above, with our on-
line pragmatics algorithm described in Section 4.
Both compositionality and pragmatics improve ac-
curacy.

orize) that just remembers pairs of complete ut-
terance and logical forms. We implement this
using indicator features on features (x, z), e.g.,
(‘remove all the red blocks’, zrm-red), and use a
large learning rate.
Second, we consider a
model (half ) that treats utterances composition-
ally with unigrams, bigrams, and skip-trigrams
features, but the logical forms are regarded as
non-compositional, so we have features such as
(‘remove’, zrm-red), (‘red’, zrm-red), etc.

Table 4 shows that the full model (Section 3)
signiﬁcantly outperforms both the memorize and
half baselines. The learning rate η = 0.1 is se-
lected via cross validation, and we used α = 1
and β = 3 following Smith et al. (2013).

Pragmatics. Next, we study the effect of prag-
Figure 2 shows
matics on online accuracy.
that modeling pragmatics helps successful players
(e.g., top 10 by number of scrolls) who use precise
and consistent languages. Interestingly, our prag-
matics model did not help and can even hurt the
less successful players who are less precise and
consistent. This is expected behavior: the prag-
matics model assumes that the human is coopera-
tive and behaving rationally. For the bottom half
of the players, this assumption is not true, in which
case the pragmatics model is not useful.

6 Related Work and Discussion

Our work connects with a broad body of work on
grounded language, in which language is used in
some environment as a means towards some goal.
Examples include playing games (Branavan et al.,
2009, 2010; Reckman et al., 2010) interacting with
robotics (Tellex et al., 2011, 2014), and following
instructions (Vogel and Jurafsky, 2010; Chen and
Mooney, 2011; Artzi and Zettlemoyer, 2013) Se-
mantic parsing utterances to logical forms, which
we leverage, plays an important role in these set-
tings (Kollar et al., 2010; Matuszek et al., 2012;
Artzi and Zettlemoyer, 2013).

What makes this work unique is our new inter-
active learning of language games (ILLG) setting,
in which a model has to learn a language from
scratch through interaction. While online gradient
descent is frequently used, for example in seman-
tic parsing (Zettlemoyer and Collins, 2007; Chen,
2012), we using it in a truly online setting, taking
one pass over the data and measuring online accu-
racy (Cesa-Bianchi and Lugosi, 2006).

To speed up learning, we leverage computa-
tional models of pragmatics (Jäger, 2008; Golland
et al., 2010; Frank and Goodman, 2012; Smith
et al., 2013; Vogel et al., 2013). The main differ-
ence is these previous works use pragmatics with
a trained base model, whereas we learn the model
online. Monroe and Potts (2015) uses learning
to improve the pragmatics model.
In contrast,
we use pragmatics to speed up the learning pro-
cess by capturing phenomena like mutual exclu-
sivity (Markman and Wachtel, 1988). We also dif-
fer from prior work in several details. First, we
model pragmatics in the online learning setting
where we use an online update for the pragmat-
ics model. Second, unlikely the reference games
where pragmatic effects plays an important role by

design, SHRDLURN is not speciﬁcally designed
to require pragmatics. The improvement we get
is mainly due to players trying to be consistent in
their language use. Finaly, we treat both the utter-
ance and the logical forms as featurized composi-
tional objects. Smith et al. (2013) treats utterances
(i.e. words) and logical forms (i.e. objects) as cat-
egories; Monroe and Potts (2015) used features,
but also over ﬂat categories.

Looking forward, we believe that the ILLG set-
ting is worth studying and has important implica-
tions for natural language interfaces. Today, these
If these
systems are trained once and deployed.
systems could quickly adapt to user feedback in
real-time as in this work, then we might be able
to more readily create systems for resource-poor
languages and new domains, that are customizable
and improve through use.

Acknowledgments

DARPA Communicating with Computers (CwC)
program under ARO prime contract no. W911NF-
15-1-0462. The ﬁrst author is supported by a
NSERC PGS-D fellowship. In addition, we thank
Will Monroe, and Chris Potts for their insightful
comments and discussions on pragmatics.

Reproducibility

All code, data, and experiments for this paper are
available on the CodaLab platform:
https://worksheets.

codalab.org/worksheets/

0x9fe4d080bac944e9a6bd58478cb05e5e
The client side code is here:
https://github.com/sidaw/shrdlurn/tree/

acl16-demo
and a demo: http://shrdlurn.sidaw.xyz

References

Y. Artzi and L. Zettlemoyer. 2013. Weakly super-
vised learning of semantic parsers for mapping
instructions to actions. Transactions of the As-
sociation for Computational Linguistics (TACL)
1:49–62.

J. Berant, A. Chou, R. Frostig, and P. Liang. 2013.
Semantic parsing on Freebase from question-
answer pairs. In Empirical Methods in Natural
Language Processing (EMNLP).

S. Branavan, H. Chen, L. S. Zettlemoyer, and
R. Barzilay. 2009. Reinforcement learning for

In Associa-
mapping instructions to actions.
tion for Computational Linguistics and Inter-
national Joint Conference on Natural Language
Processing (ACL-IJCNLP). pages 82–90.

T. Kollar, S. Tellex, D. Roy, and N. Roy. 2010.
Grounding verbs of motion in natural language
commands to robots. In International Sympo-
sium on Experimental Robotics (ISER).

S. Branavan, L. Zettlemoyer, and R. Barzilay.
2010. Reading between the lines: Learning
to map high-level instructions to commands.
In Association for Computational Linguistics
(ACL). pages 1268–1277.

N. Cesa-Bianchi and G. Lugosi. 2006. Predic-
tion, learning, and games. Cambridge Univer-
sity Press.

D. L. Chen. 2012. Fast online lexicon learning for
grounded language acquisition. In Association
for Computational Linguistics (ACL).

D. L. Chen and R. J. Mooney. 2011. Learning
to interpret natural language navigation instruc-
tions from observations. In Association for the
Advancement of Artiﬁcial Intelligence (AAAI).
pages 859–865.

J. Duchi, E. Hazan, and Y. Singer. 2010. Adap-
tive subgradient methods for online learning
and stochastic optimization. In Conference on
Learning Theory (COLT).

M. Frank and N. D. Goodman. 2012. Predicting
pragmatic reasoning in language games. Sci-
ence 336:998–998.

H. Giles. 2008. Communication accommodation

theory. Sage Publications, Inc.

D. Golland, P. Liang, and D. Klein. 2010. A game-
theoretic approach to generating spatial descrip-
In Empirical Methods in Natural Lan-
tions.
guage Processing (EMNLP).

N. Goodman and D. Lassiter. 2015. Probabilistic
Semantics and Pragmatics: Uncertainty in Lan-
guage and Thought. The Handbook of Contem-
porary Semantic Theory, 2nd Edition Wiley-
Blackwell.

H. P. Grice. 1975. Logic and conversation. Syntax

and semantics 3:41–58.

M. E. Ireland, R. B. Slatcher, P. W. Eastwick, L. E.
Scissors, E. J. Finkel, and J. W. Pennebaker.
2011. Language style matching predicts rela-
tionship initiation and stability. Psychological
Science 22(1):39–44.

G. Jäger. 2008. Game theory in semantics and
pragmatics. Technical report, University of
Tübingen.

T. Kwiatkowski, L. Zettlemoyer, S. Goldwater,
and M. Steedman. 2010. Inducing probabilistic
CCG grammars from logical form with higher-
In Empirical Methods in
order uniﬁcation.
Natural Language Processing (EMNLP). pages
1223–1233.

P. Liang, M. I. Jordan, and D. Klein. 2011.
Learning dependency-based compositional se-
mantics. In Association for Computational Lin-
guistics (ACL). pages 590–599.

E. Markman and G. F. Wachtel. 1988. Children’s
use of mutual exclusivity to constrain the mean-
ings of words. Cognitive Psychology 20:125–
157.

C. Matuszek, N. FitzGerald, L. Zettlemoyer,
L. Bo, and D. Fox. 2012. A joint model of
language and perception for grounded attribute
In International Conference on Ma-
learning.
chine Learning (ICML). pages 1671–1678.

W. Monroe and C. Potts. 2015. Learning in the
Rational Speech Acts model. In Proceedings of
20th Amsterdam Colloquium.

P. Pasupat and P. Liang. 2015. Compositional se-
mantic parsing on semi-structured tables. In As-
sociation for Computational Linguistics (ACL).

H. Reckman, J. Orkin, and D. Roy. 2010. Learning
meanings of words and constructions, grounded
In Conference on Natural
in a virtual game.
Language Processing (KONVENS).

N. J. Smith, N. D. Goodman, and M. C. Frank.
2013. Learning and using language via re-
cursive pragmatic reasoning about other agents.
In Advances in Neural Information Processing
Systems (NIPS).

S. Tellex, R. Knepper, A. Li, D. Rus, and N. Roy.
2014. Asking for help using inverse semantics.
In Robotics: Science and Systems (RSS).

S. Tellex, T. Kollar, S. Dickerson, M. R. Walter,
A. G. Banerjee, S. J. Teller, and N. Roy. 2011.
Understanding natural language commands for
robotic navigation and mobile manipulation. In
Association for the Advancement of Artiﬁcial
Intelligence (AAAI).

A. Vogel, M. Bodoia, C. Potts, and D. Juraf-
sky. 2013. Emergence of gricean maxims from

In North Ameri-
multi-agent decision theory.
can Association for Computational Linguistics
(NAACL). pages 1072–1081.

A. Vogel and D. Jurafsky. 2010. Learning to fol-
low navigational directions. In Association for
Computational Linguistics (ACL). pages 806–
814.

T. Winograd. 1972. Understanding Natural Lan-

guage. Academic Press.

L. Wittgenstein. 1953. Philosophical Investiga-

tions. Blackwell, Oxford.

Y. W. Wong and R. J. Mooney. 2007. Learn-
ing synchronous grammars for semantic parsing
with lambda calculus. In Association for Com-
putational Linguistics (ACL). pages 960–967.

L. S. Zettlemoyer and M. Collins. 2005. Learn-
ing to map sentences to logical form: Struc-
tured classiﬁcation with probabilistic categorial
In Uncertainty in Artiﬁcial Intelli-
grammars.
gence (UAI). pages 658–666.

L. S. Zettlemoyer and M. Collins. 2007. Online
learning of relaxed CCG grammars for parsing
to logical form. In Empirical Methods in Nat-
ural Language Processing and Computational
Natural Language Learning (EMNLP/CoNLL).
pages 678–687.

