6
1
0
2
 
r
p
A
 
1
1
 
 
]

V
C
.
s
c
[
 
 
2
v
1
1
7
7
0
.
2
1
5
1
:
v
i
X
r
a

Adaptive Object Detection Using Adjacency and Zoom Prediction

Yongxi Lu
University of California, San Diego
yol070@ucsd.edu

Tara Javidi
University of California, San Diego
tjavidi@ucsd.edu

Svetlana Lazebnik
University of Illinois at Urbana-Champaign
slazebni@illinois.edu

Abstract

State-of-the-art object detection systems rely on an ac-
curate set of region proposals. Several recent methods use
a neural network architecture to hypothesize promising ob-
ject locations. While these approaches are computation-
ally efﬁcient, they rely on ﬁxed image regions as anchors
for predictions. In this paper we propose to use a search
strategy that adaptively directs computational resources to
sub-regions likely to contain objects. Compared to meth-
ods based on ﬁxed anchor locations, our approach natu-
rally adapts to cases where object instances are sparse and
small. Our approach is comparable in terms of accuracy
to the state-of-the-art Faster R-CNN approach while using
two orders of magnitude fewer anchors on average. Code is
publicly available.

1. Introduction

Object detection is an important computer vision prob-
lem for its intriguing challenges and large variety of ap-
plications. Signiﬁcant recent progress in this area has
been achieved by incorporating deep convolutional neu-
ral networks (DCNN) [15] into object detection systems
[5, 8, 10, 12, 17, 23, 25].

An object detection algorithm with state-of-the-art ac-
curacy typically has the following two-step cascade: a set
of class-independent region proposals are hypothesized and
are then used as input to a detector that gives each region
a class label. The role of region proposals is to reduce the
complexity through limiting the number of regions that need
be evaluated by the detector. However, with recently intro-
duced techniques that enable sharing of convolutional fea-
tures [9, 12], traditional region proposal algorithms such as
selective search [27] and EdgeBoxes [29] become the bot-
tleneck of the detection pipeline.

ods are based on end-to-end trained deep neural networks
[5, 22]. The common idea in these approaches is to train
a class-independent regressor on a small set of pre-deﬁned
anchor regions. More speciﬁcally, each anchor region is as-
signed the task of deciding whether an object is in its neigh-
borhood (in terms of center location, scale and aspect ratio),
and predicting a bounding box for that object through re-
gression if that is the case. The design of anchors differs for
each method. For example, MultiBox [5] uses 800 anchors
from clustering, YOLO [21] uses a non-overlapping 7 by 7
grid, RPN [22] uses overlapping sliding windows. In these
prior works the test-time anchors are not adaptive to the ac-
tual content of the images, thus to further improve accuracy
for detecting small object instances a denser grid of anchors
is required for all images, resulting in longer test time and a
more complex network model.

We alternatively consider the following adaptive search
strategy. Instead of ﬁxing a priori a set of anchor regions,
our algorithm starts with the entire image.
It then recur-
sively divides the image into sub-regions (see Figure 2) un-
til it decides that a given region is unlikely to enclose any
small objects. The regions that are visited in the process
effectively serve as anchors that are assigned the task of
predicting bounding boxes for objects nearby. A salient
feature of our algorithm is that the decision of whether to
divide a region further is based on features extracted from
that particular region. As a result, the generation of the set
of anchor regions is conditioned on the image content. For
an image with only a few small objects most regions are
pruned early in the search, leaving a few small anchor re-
gions near the objects. For images that contain exclusively
large instances, our approach gracefully falls back to exist-
ing methods that rely on a small number of large anchor
regions. In this manner, our algorithm adaptively directs its
computational resources to regions that are likely to contain
objects. Figure 1 compares our algorithm with RPN.

An emerging class of efﬁcient region proposal meth-

To support our adaptive search algorithm, we train a deep

1

Figure 1. Comparison of our proposed adaptive search algorithm with the non-adaptive RPN method. The red boxes show region proposals
from adjacency predictions. Note that for small objects, RPN is forced to perform regression from much larger anchors, while our AZ-Net
approach can adaptively use features from small regions.

neural network we call Adjacency and Zoom Network (AZ-
Net). Given an input anchor region, the AZ-Net outputs a
scalar zoom indicator which is used to decide whether to
further zoom into (divide) the region and a set of bound-
ing boxes with conﬁdence scores, or adjacency predictions.
The adjacency predictions with high conﬁdence scores are
then used as region proposals for a subsequent object de-
tector. The network is applied recursively starting from the
whole image to generate an adaptive set of proposals.

To intuitively motivate the design of our network, con-
sider a situation in which one needs to perform a quick
search for a car. A good strategy is to ﬁrst look for
larger structures that could provide evidence for existence
of smaller structures in related categories. A search agent
could, for example, look for roads and use that to reason
about where cars should be. Once the search nears the car,
one could use the fact that seeing certain parts is highly pre-
dictive of the spatial support of the whole. For instance,
the wheels provide strong evidence for a tight box of the
car. In our design, the zoom indicator mimics the process
of searching for larger structures, while the adjacency pre-
dictions mimic the process of neighborhood inference.

To validate this design we extensively evaluate our al-
gorithm on Pascal VOC 2007 [6] with ﬁne-grained analy-
sis. We also report baseline results on the recently intro-
duced MSCOCO [18] dataset. Our algorithm achieves de-
tection mAP that is close to state-of-the-art methods at a
fast frame rate. Code has been made publicly available at
https://github.com/luyongxi/az-net.

In summary, we make the following contributions:

• We design a search strategy for object detection that
adaptively focuses computational resources on image
regions that contain objects.

• We evaluate our approach on Pascal VOC 2007 and
MSCOCO datasets and demonstrate it is comparable

to Fast R-CNN and Faster R-CNN with fewer anchor
and proposal regions.

• We provide a ﬁne-grained analysis that shows intrigu-
ing features of our approach. Namely, our proposal
strategy has better recall for higher intersection-over-
union thresholds, higher recall for smaller numbers of
top proposals, and for smaller object instances.

This paper is organized as follows. In section 2 we sur-
vey existing literature highlighting the novelty of our ap-
proach. In Section 3 we introduce the design of our algo-
rithm. Section 4 presents an empirical comparison to exist-
ing object detection methods on standard evaluation bench-
marks, and Section 5 discusses possible future directions.

2. Previous Work

Lampert et al. [16] ﬁrst proposed an adaptive branch-
and-bound approach. More recently, Gonzeles-Garcia et al.
[11], Caicedo and Lazebnik [3], and Yoo et al. [28] explored
active object detection with DCNN features. While these
approaches show the promise of using an adaptive algo-
rithm for object detection, their detectors are class-wise and
their methods cannot achieve competitive accuracy. Our ap-
proach, on the other hand, is multi-class and is compara-
ble to state-of-the-art approaches in both accuracy and test
speed.

The idea of using spatial context has been previously ex-
plored in the literature. Previous work by Torralba et al.
[26] used a biologically inspired visual attention model [2],
but our focus is on efﬁcient engineering design. Divvala et
al. [4] evaluated the use of context for localization, but their
empirical study was performed on hand-crafted features and
needs to be reexamined in combination with more accurate
recent approaches.

Our method is closely related to recent approaches that

2

1

3

5

2

4

Figure 2. As illustrated, a given region is divided into 5 sub-regions
(numbered). Each of these sub-regions is recursively divided if its
zoom indicator is above a threshold.

No zoom

No zoom

Zoom

Figure 3. Illustration of desired zoom indicator for common situa-
tions. The green boxes are objects, and the red boxes are regions.
Left: the object is small but it is mostly outside the region – there
is no gain in zooming in. Middle: the object is mostly inside but
its size is large relative to the region – there is no gain in zooming
in. Right: there is a small object that is completely inside the re-
gion. In this case further division of the region greatly increases
the chance of detection for that object.

use anchor regions for proposal generation or detection. For
example, Erhan et al. [5] use 800 data-driven anchors for re-
gion proposals and Redmon et al. [21] use a ﬁxed grid of 49
non-overlapping regions to provide class-wise detections.
The former has the concern that these anchors could over-
ﬁt the data, while the latter cannot achieve state-of-the-art
performance without model ensembles. Our work is most
related to the recent work by Ren et al. [22], which uses a set
of heuristically designed 2400 overlapping anchor regions.
Our approach uses a similar regression technique to predict
multiple bounding boxes from an anchor region. However,
our anchor regions are generated adaptively, making them
intrinsically more efﬁcient. In particular, we show that it is
possible to detect small object instances in the scene with-
out an excessive number of anchor regions. We propose to
grow a tree of ﬁner-grained anchor regions based on local
image evidence, and design the regression model strategi-
cally on top of it. We extensively compare the output of our
method against [22] in our experimental section and show
the unique advantages of our approach.

This paper is a follow-up to the work published in the
53rd Annual Allerton Conference [20]. Here, we introduce
a substantially improved algorithm and add extensive eval-
uations on standard benchmarks.

3

1

3

2

1

3

1

3

2

2

4

Figure 4. Illustration of sub-region priors. From left to right: ver-
tical stripes, horizontal stripes, neighboring squares. The red rect-
angular box is the image. In the ﬁgure the numbered regions are
template sub-regions. The gaps between sub-regions are exagger-
ated for better visualization. The vertical stripes are used to detect
tall objects, the horizontal stripes are used to detect fat objects,
while the neighboring squares are used to detect objects that fall
in the gaps between anchor regions generated in the search pro-
cess.

3. Design of the Algorithm

3.1. Overview of the Adaptive Search

Our object detection algorithm consists of two steps. In
step 1, a set of class-independent region proposals are gen-
erated using Adaptive Search with AZ-Net (see Algorithm
1). In step 2, an object detector evaluates each region pro-
posed in step 1 to provide class-wise detections. In our ex-
periments the detector is Fast R-CNN.

Our focus is on improving step 1. We consider a recur-
sive search strategy, starting from the entire image as the
root region. For any region encountered in the search pro-
cedure, the algorithm extracts features from this region to
compute the zoom indicator and the adjacency predictions.
The adjacency predictions with conﬁdence scores above a
threshold are included in the set of output region proposals.
If the zoom indicator is above a threshold, this indicates
that the current region is likely to contain small objects. To
detect these embedded small objects, the current region is
divided into sub-regions in the manner shown in Figure 2.
Each of these sub-regions is then recursively processed in
the same manner as its parent region, until either its area
or its zoom indicator is too small. Figure 1 illustrates this
procedure.

In the following section, we discuss the design of the

zoom indicator and adjacency prediction.

3.2. Design of Building Blocks

The zoom indicator should be large for a region only
when there exists at least one object whose spatial support
mostly lies within the region, and whose size is sufﬁciently
small compared to the region. The reasoning is that we
should zoom in to a region only when it substantially in-
creases the chance of detection. For example, if an object is
mostly outside the region, dividing the region further is un-
likely to increase the chance of detecting that object. Sim-
ilarly, if an object is large compared to the current region,
the task of detecting this object should be handled by this

Algorithm 1: Adaptive search with AZ-Net.
Data: Input image x (the whole image region bx). Yk is the region proposed at step k. Y k are the accumulated region
proposals up to step k. Zk are the regions to further zoom in to at step k. Bk are anchor regions at step k.

Compute adjacency predictions Ab and the zoom indicator zb using AZ-Net.
Include all a ∈ Ab with high conﬁdence scores into Yk.
Include b into Zk if zb is above threshold.

Result: Region proposals at termination Y K.
Initialization: B0 ← {bx}. Y 0 ← ∅, k ← 0
while (Bk is not an empty set) do

Initialize Yk and Zk as empty sets.
foreach b ∈ Bk do

end
Y k ← Y k−1 ∪ Yk
Bk+1 ← Divide-Regions(Zk)
k ← k + 1

end
K ← k − 1

make sub-region priors large compared to the anchor under
the intuition that if an object is small, it is best to wait until
the features extracted are at the right scale to make bound-
ing box predictions.

3.3. Implementation

We implement our algorithm using the Caffe [14] frame-
work, utilizing the open source infrastructure provided by
the Fast R-CNN repository [9].
In this section we intro-
duce the implementation details of our approach. We use
the Fast R-CNN detector since it is a fast and accurate re-
cent approach. Our method should in principle work for a
broad class of object detectors that use region proposals.

We train a deep neural network as illustrated in Figure
5. Note that in addition to the sub-region priors as shown
in Figure 4, we also add the region itself as a special prior
region, making in total 11 adjacency predictions per anchor.
For the convolutional layers, we use the VGG16 model [23]
pre-trained on ImageNet data. The fully-connected layers
are on top of a region pooling layer introduced in [9] which
allows efﬁcient sharing of convolutional layer features.

The training is performed as a three-step procedure.
First, a set of regions is sampled from the image. These
samples should contain hard positive and negative exam-
ples for both the zoom indicator and the adjacency predic-
tion. Finally, the tuples of samples and labels are used in
standard stochastic gradient descent training. We now dis-
cuss how the regions are sampled and labeled, and the loss
function we choose.

3.3.1 Region Sampling and Labeling

Since a typical image only has a few object instances, to
provide sufﬁcient positive examples for adjacency predic-

Figure 5. Illustration of the AZ-Net architecture.

region or its parents. In the latter case, further division of
the region not only wastes computational resources, but also
introduces false positives in the region proposals. Figure 3
shows common situations and the desirable behavior of the
zoom indicator.

The role of adjacency prediction is to detect one or mul-
tiple objects that overlap with the anchor region sufﬁciently
by providing tight bounding boxes. The adjacency predic-
tion should be aware of the search geometry induced by the
zoom indicator. More speciﬁcally, the adjacency predic-
tion should perform well on the effective anchor regions in-
duced by the search algorithm. For this purpose we propose
a training procedure that is aware of the adaptive search
scheme (discussed in Section 3.3). On the other hand, its
design should explicitly account for typical geometric con-
ﬁgurations of objects that fall inside the region, so that the
training can be performed in a consistent fashion. For this
reason, we propose to make predictions based on a set of
sub-region priors as shown in Figure 4. Note that we also
include the anchor region itself as an additional prior. We

4

[22]. Unlike in Fast R-CNN, to provide multiple predic-
tions from any region, the conﬁdence scores are not nor-
malized to a probability vector. Correspondingly we use
smooth L1-loss for bounding box output and element-wise
cross-entropy loss for conﬁdence score output. The three
losses are summed together to form a multi-task loss func-
tion.

3.3.3 Fast R-CNN Detectors

The detectors we use to evaluate proposal regions are Fast
R-CNN detectors trained using AZ-Net proposals. As in
[22], we implement two versions: one with unshared con-
volutional features and the other that shares convolutional
features with AZ-Net. The shared version is trained using
alternating optimization.

4. Experiments

We evaluate our approach on Pascal VOC 2007 [6] and
MSCOCO [18] datasets. In addition to evaluating the accu-
racy of the ﬁnal detectors, we also perform detailed compar-
isons between the RPN approach adopted in Faster R-CNN
and our AZ-Net on VOC 2007. At the end of the section,
we give an analysis of the efﬁciency of our adaptive search
strategy.

4.1. Results on VOC 2007

To set up a baseline comparison, we evaluate our ap-
proach using the standard average precision (AP) metric
for object detection. For AP evaluation we use the de-
velopment kit provided by the VOC 2007 object detection
challenge. We compare our approach against the recently
introduced Fast R-CNN [9] and Faster R-CNN [22] sys-
tems, which achieve state-of-the-art performance in stan-
dard benchmarks, such as VOC 2007 [6] and VOC 2012
[7]. A comparison is shown in Table 1. The results sug-
gest that our approach is comparable to or better than these
methods.

4.2. Quality of Region Proposals

We preform a detailed analysis of the quality of region
proposals from our AZ-Net, highlighting a comparison to
the RPN network used in Faster R-CNN. For all our ex-
periments, we analyze the recall on Pascal VOC 2007 test
set using the following deﬁnition: An object is counted as
retrieved if there exists a region proposal with an above-
threshold IoU with it. The recall is then calculated as the
proportion of the retrieved objects among all ground truth
object instances. To accurately reproduce the RPN ap-
proach, we downloaded the region proposals provided on
the Faster R-CNN repository 1. We used the results from

1https://github.com/ShaoqingRen/faster_rcnn

Figure 6. Illustration of the inverse matching procedure. The red
box is the inverse match for the object (green box). The left ﬁgure
shows inverse matching of a neighboring square, the right ﬁgure
shows inverse matching of a vertical stripe.

tions our method inversely ﬁnds regions that will see a
ground truth object as a perfect ﬁt to its prior sub-regions
(see Figure 6 for illustration). This provides k × 11 training
examples for each image, where k is the number of objects.
To mine for negative examples and hard positive exam-
ples, we search the input image as in Algorithm 1. Note
that the algorithm uses zoom indicators from the AZ-Net.
Instead of optimizing AZ-Net with an on-policy approach
(that uses the intermediate AZ-Net model to sample re-
gions), which might cause training to diverge, we replace
the zoom prediction with the zoom indicator label. How-
ever, we note that using the zoom label directly could cause
overﬁtting, since at test time the algorithm might encounter
situations where a previous zoom prediction is wrong. To
improve the robustness of the model, we add noise to the
zoom label by ﬂipping the ground truth with a probability
of 0.3. We found that models trained without random ﬂip-
ping are signiﬁcantly less accurate. For each input image
we initiate this procedure with ﬁve sub-images and repeat it
multiple times. We also append horizontally ﬂipped images
to the dataset for data augmentation.

Assignment of labels for the zoom indicator follows the
discussion of Section 3. The label is 1 if there exists an ob-
ject with 50% of its area inside the region and the area is
at most 25% of the size of the region. Note that here we
use a loose deﬁnition of inclusion to add robustness for ob-
jects falling between boundaries of anchors. For adjacency
prediction, we set a threshold in the intersection-over-union
(IoU) score between an object and a region. A region is
assigned to detect objects with which it has sufﬁcient over-
lap. The assigned objects are then greedily matched to one
of the sub-regions deﬁned by the priors shown in Figure 4.
The priority in the matching is determined by the IoU score
between the objects and the sub-regions. We note that in
this manner multiple predictions from a region are possible.

3.3.2 Loss Function

As shown in Figure 5, the AZ-Net has three output layers.
The zoom indicator outputs from a sigmoid activation func-
tion. To train it we use the cross-entropy loss function pop-
ular for binary classiﬁcation. For the adjacency predictions,
the bounding boxes are parameterized as in Fast R-CNN

5

Figure 7. Example outputs of our algorithm. The left column shows the original image. The middle column shows the anchor regions
induced by our adaptive search. The right column shows the top 100 adjacency predictions made around the anchor regions. The anchor
regions and the adjacency predictions are superimposed into a ﬁgure at the same resolution of the original image. We note that the anchor
regions and the region proposals in our approach are shared across object categories. For example, for the last image, the algorithm
generates anchor regions at proper scales near the dogs, the person, and the bottles.

Method

AZ-Net
AZ-Net*
RPN
RPN*
FRCNN

boxes

mAP

231
228
300
300
2000

70.2
70.4
69.9
68.5
68.1

aero

73.3
73.9
70.0
74.1
74.6

bike

78.8
79.9
80.6
77.2
79.0

bird

69.2
68.8
70.1
67.7
68.6

boat

59.9
58.9
57.3
53.9
57.0

bottle

48.7
49.1
49.9
51.0
39.3

bus

81.4
80.8
78.2
75.1
79.5

car

82.8
83.3
80.4
79.2
78.6

cat

83.6
83.7
82.0
78.9
81.9

chair

47.5
47.2
52.2
50.7
48.0

cow

77.3
75.8
75.3
78.0
74.0

table

62.9
63.8
67.2
61.1
67.4

dog

81.1
80.6
80.3
79.1
80.5

horse

mbike

person

plant

sheep

83.5
84.4
79.8
81.9
80.7

78.0
78.9
75.0
72.2
74.1

75.8
75.8
76.3
75.9
69.6

38.0
39.2
39.1
37.2
31.8

68.7
70.2
68.3
71.4
67.1

sofa

67.2
67.4
67.3
62.5
68.4

train

79.0
78.4
81.1
77.4
75.3

tv

66.4
68.3
67.6
66.4
65.5

Table 1. Comparison on VOC 2007 test set using VGG-16 for convolutional layers. The results of RPN are reported in [22]. The results
for Fast R-CNN are reported in [9]. The AZ-Net and RPN results are reported for top-300 region proposals, but in AZ-Net many images
have too few anchors to generate 300 proposals. * indicates results without shared convolutional features. All listed methods use DCNN
models trained on VOC 2007 trainval.

a model reportedly trained on VOC 2007 trainval. Cor-
respondingly we compare it against our model trained on
VOC 2007 trainval set. The comparisons concerning top-

N regions are performed by ranking the region proposals in
order of their conﬁdence scores.

Figure 8 shows a comparison of recall at different IoU

6

AZ−Net (Ours)
 
RPN (Faster R−CNN)

AZ−Net (Ours)
RPN (Faster R−CNN)

 

 

.

 

0
5
0
=
d
l
o
h
s
e
r
h
T
U
o
I
 
t
a

 

 
l
l
a
c
e
R

1

0.8

0.6

0.4

0.2

0

 

1

0.8

0.6

0.4

0.2

 

s
l
a
s
o
p
o
r
P
n
o
i
g
e
R
 
0
0
3
−
p
o
T

 
t
a
 
l
l
a
c
e
R

0
0.5

s
l
a
s
o
p
o
r
P
 
g
n
i
h
c
t
a
M

 
f
o
 
r
e
b
m
u
N

20

15

10

5

0

1

0.8

0.6

0.4

0.2

 

0
5
.
0
 
=
d
l
o
h
s
e
r
h
T
U
o
I
 
t
a
 
l
l
a
c
e
R

 

0
10

0

0.55

0.6

0.65

0.7

0.75

0.8

0.85

0.9

0.95

Threshold at IoU

Figure 8. Comparison of recall of region proposals generated by
AZ-Net and RPN at different intersection over union thresholds
on VOC 2007 test. The comparison is performed at top-300 re-
gion proposals. Our approach has better recall at large IoU thresh-
olds, which suggests that AZ-Net proposals are more accurate in
localizing the objects.

AZ−Net (Ours)
RPN (Faster R−CNN)

 

Small

Medium
Size of Ground Truth Boxes

Large

Figure 9. Number of proposals matched to ground truth (with
IoU= 0.5). This shows proposals from AZ-Net are more con-
centrated around true object locations.

 

AZ−Net (Ours)
RPN (Faster R−CNN)

1

10

2

10

Number of Region Proposals

Figure 10. Comparison of recall of region proposals generated by
AZ-Net and RPN at different number of region proposals on VOC
2007 test. The comparison is performed at IoU threshold 0.5. Our
approach has better early recall. In particular, it reaches 0.6 recall
with only 10 proposals.

Small

Medium
Size of Ground Truth Boxes

Large

Figure 11. Comparison of recall of region proposals generated by
AZ-Net and RPN for objects of different sizes on VOC 2007 test.
The comparison is performed at IoU threshold 0.5 with top-300
proposals. Our approach has signiﬁcantly better recall for small
objects.

Anchor Regions

Region proposals

Runtime (ms)

Method

AZ-Net
AZ-Net*
RPN
RPN*
FRCNN

62
44
2400
2400
N/A

231
228
300
300
2000

171
237
198
342
1830

Table 2. Numbers related to the efﬁciency of the object detection
methods listed in Table 1. The runtimes for RPN and Fast R-CNN
are reported for a K40 GPU [22]. Our runtime experiment is per-
formed on a GTX 980Ti GPU. The K40 GPU has larger GPU
memory, while the GTX 980Ti has higher clock rate. * indicates
unshared convolutional feature version.

thresholds. Our AZ-net has consistently higher recall than
RPN, and the advantage is larger at higher IoU thresholds.
This suggests our method generates bounding boxes that in
general overlap with the ground truth objects better. The
proposals are also more concentrated around objects, as
shown in Figure 9.

Figure 10 shows a plot of recall as a function of the num-
ber of proposals. A region proposal algorithm is more efﬁ-
cient in covering objects if its area under the curve is larger.
Our experiment suggests that our AZ-Net approach has a
better early recall than RPN. That means our algorithm in
general can recover more objects with the same number of
region proposals.

Figure 11 shows a comparison of recall for objects with
different sizes. The “small object” has an area less than
322, a “medium object” has an area between 322 and 962,
and a “large object” has an area greater than 962, same as
the deﬁnition in MSCOCO [18]. Our approach achieves
higher recall on the small object subset. This is because
when small objects are present in the scene our adaptive
search strategy generates small anchor regions around them,
as shown in Figure 7.

4.3. Efﬁciency of Adaptive Search

Our approach is efﬁcient in runtime, as shown in Table
2. We note that this is achieved even with several severe in-

7

y
c
n
e
u
q
e
r
F

700

600

500

400

300

200

100

0
0

Median: 40

Mean: 62

96% of the
distribution

50
250
150
Number of Evaluated Anchor Regions

200

100

300

Figure 12. Distribution of the number of anchor regions evaluated
on VOC 2007 test set. For most images a few dozen anchor regions
are required. Note that anchors are shared across categories.

efﬁciencies in our implementation. First, for each image
our algorithm requires several rounds of fully connected
layer evaluation, which induces expensive memory trans-
fer between GPU and CPU. Secondly, the Faster R-CNN
approach uses convolutional computation for the evaluation
of anchor regions, which is highly optimized compared to
the RoI pooling technique we adopted. Despite these in-
efﬁciencies, our approach still achieves high accuracy at a
state-of-the-art frame rate, using lower-end hardware. With
improved implementation and model design we expect our
algorithm to be signiﬁcantly faster.

An interesting aspect that highlights the advantages of
our approach is the small number of anchor regions to eval-
uate. To further understand this aspect of our algorithm,
we show in Figure 12 the distribution of anchor regions
evaluated for each image. For most images our method
only requires a few dozen anchor regions. This number is
much smaller than the 2400 anchor regions used in RPN
[22] and the 800 used in MultiBox [5]. Future work could
further capitalize on this advantage by using an expensive
but more accurate per-anchor step, or by exploring applica-
tions to very high-resolution images, for which traditional
non-adaptive approaches will face intrinsic difﬁculties due
to scalability issues. Our experiment also demonstrates the
possibility of designing a class-generic search. Unlike per-
class search methods widely used in previous adaptive ob-
ject detection schemes [3, 28] our anchor regions are shared
among object classes, making it efﬁcient for multi-class de-
tection.

4.4. Results on MSCOCO

We also evaluated our method on MSCOCO dataset and
submitted a “UCSD” entry to the MSCOCO 2015 detection
challenge. Our post-competition work greatly improved ac-
curacy with more training iterations. A comparison with
other recent methods is shown in Table 3. Our model is

8

Method

FRCNN (VGG16) [9]
FRCNN (VGG16) [22]
RPN (VGG16)
RPN (ResNet)
AZ-Net (VGG16)

AP

19.7
19.3
21.9
37.4
22.3

AP IoU=0.50

35.9
39.3
42.7
59.0
41.0

Table 3. The detection mAP on MSCOCO 2015 test-dev set. The
RPN (ResNet) entry won the MSCOCO 2015 detection challenge.
Updated leaderboard can be found in http://mscoco.org.

trained with minibatches consisting of 256 regions sampled
from one image, and 720k iterations in total. The results
for RPN(VGG16) reported in [22] were obtained with an
8-GPU implementation that effectively has 8 and 16 images
per minibatch for RPN and Fast R-CNN respectively, each
trained at 320k training iterations. Despite the much shorter
effective training iterations, our AZ-Net achieves similar
mAP with RPN(VGG16) and is more accurate when eval-
uated on the MSCOCO mAP metric that rewards accurate
localization.

Our best post-competition model is still signiﬁcantly
outperformed by the winning “MSRA” entry. Their ap-
proach is a Faster-R-CNN-style detection pipeline, replac-
ing the VGG-16 network with an ultra-deep architecture
called Deep Residual Network [13]. They also report signif-
icant improvement from using model ensembles and global
contextual information. We note that these developments
are complementary to our contribution.

5. Conclusion and Future Work

This paper has introduced an adaptive object detection
system using adjacency and zoom predictions. Our al-
gorithm adaptively focuses its computational resources on
small regions likely to contain objects, and demonstrates
state-of-the-art accuracy at a fast frame rate.

The current method can be further extended and im-
proved in many aspects. Better pre-trained models [13]
can be incorporated into the current system for even bet-
ter accuracy. Further reﬁning the model to allow single-
pipeline detection that directly predicts class labels, as in
YOLO [21] and the more recent SSD [19] method, could
signiﬁcantly boost testing frame rate. Recent techniques
that improve small object detection, such as the contextual
model and skip layers adopted in Inside-Outside Net [1],
suggest additional promising directions. It is also interest-
ing to consider more aggressive extensions. For instance, it
might be advantageous to use our search structure to focus
high-resolution convolutional layer computation on smaller
regions, especially for very high-resolution images.

Acknowledgment

This work is supported by the National Science Foun-
dation grants CIF-1302438, CCF-1302588 and CNS-
1329819, as well as Xerox UAC, and the Sloan Foundation.

[16] C. H. Lampert, M. B. Blaschko, and T. Hofmann. Efﬁcient
subwindow search: A branch and bound framework for ob-
ject localization. Pattern Analysis and Machine Intelligence,
IEEE Transactions on, 31(12):2129–2142, 2009.

[17] X. Liang, S. Liu, Y. Wei, L. Liu, L. Lin, and S. Yan. To-
wards computational baby learning: A weakly-supervised
approach for object detection.
In The IEEE International
Conference on Computer Vision (ICCV), December 2015.

[18] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona, D. Ra-
manan, P. Doll´ar, and C. L. Zitnick. Microsoft coco: Com-
mon objects in context.
In Computer Vision–ECCV 2014,
pages 740–755. Springer, 2014.

[19] W. Liu, D. Anguelov, D. Erhan, C. Szegedy, and S. Reed.
arXiv preprint

Single shot multibox detector.

Ssd:
arXiv:1512.02325, 2015.

[20] Y. Lu and T. Javidi. Efﬁcient object detection for high reso-
lution images. arXiv preprint arXiv:1510.01257, 2015.
[21] J. Redmon, S. Divvala, R. Girshick, and A. Farhadi. You
only look once: Uniﬁed, real-time object detection. arXiv
preprint arXiv:1506.02640, 2015.

[22] S. Ren, K. He, R. Girshick, and J. Sun. Faster r-cnn: Towards
real-time object detection with region proposal networks. In
C. Cortes, N. D. Lawrence, D. D. Lee, M. Sugiyama, and
R. Garnett, editors, Advances in Neural Information Process-
ing Systems 28, pages 91–99. Curran Associates, Inc., 2015.
[23] K. Simonyan and A. Zisserman. Very deep convolutional
networks for large-scale image recognition. arXiv preprint
arXiv:1409.1556, 2014.

[24] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed,
D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabi-
novich. Going deeper with convolutions. arXiv preprint
arXiv:1409.4842, 2014.

[25] C. Szegedy, A. Toshev, and D. Erhan. Deep neural networks
for object detection. In Advances in Neural Information Pro-
cessing Systems, pages 2553–2561, 2013.

[26] A. Torralba, A. Oliva, M. S. Castelhano, and J. M. Hender-
son. Contextual guidance of eye movements and attention
in real-world scenes:
the role of global features in object
search. Psychological review, 113(4):766, 2006.

[27] J. R. Uijlings, K. E. van de Sande, T. Gevers, and A. W.
Smeulders. Selective search for object recognition. Interna-
tional journal of computer vision, 104(2):154–171, 2013.
[28] D. Yoo, S. Park, J.-Y. Lee, A. S. Paek, and I. So Kweon. At-
tentionnet: Aggregating weak directions for accurate object
detection. In The IEEE International Conference on Com-
puter Vision (ICCV), December 2015.

[29] C. L. Zitnick and P. Doll´ar. Edge boxes: Locating object pro-
posals from edges. In Computer Vision–ECCV 2014, pages
391–405. Springer, 2014.

References

[1] S. Bell, C. L. Zitnick, K. Bala, and R. Girshick.

Inside-
outside net: Detecting objects in context with skip
pooling and recurrent neural networks.
arXiv preprint
arXiv:1512.04143, 2015.

[2] A. Borji and L. Itti. State-of-the-art in visual attention model-
ing. Pattern Analysis and Machine Intelligence, IEEE Trans-
actions on, 35(1):185–207, 2013.

[3] J. C. Caicedo and S. Lazebnik. Active object localization
with deep reinforcement learning. In The IEEE International
Conference on Computer Vision (ICCV), December 2015.
[4] S. K. Divvala, D. Hoiem, J. H. Hays, A. Efros, M. Hebert,
et al. An empirical study of context in object detection.
In Computer Vision and Pattern Recognition, 2009. CVPR
2009. IEEE Conference on, pages 1271–1278. IEEE, 2009.
[5] D. Erhan, C. Szegedy, A. Toshev, and D. Anguelov. Scalable
object detection using deep neural networks.
In Computer
Vision and Pattern Recognition (CVPR), 2014 IEEE Confer-
ence on, pages 2155–2162. IEEE, 2014.

[6] M. Everingham, L. Van Gool, C. K. I. Williams, J. Winn,
and A. Zisserman. The PASCAL Visual Object Classes
Challenge 2007 (VOC2007) Results.
http://www.pascal-
network.org/challenges/VOC/voc2007/workshop/index.html.
[7] M. Everingham, L. Van Gool, C. K. I. Williams, J. Winn,
and A. Zisserman. The PASCAL Visual Object Classes
Challenge 2012 (VOC2012) Results.
http://www.pascal-
network.org/challenges/VOC/voc2012/workshop/index.html.
[8] S. Gidaris and N. Komodakis. Object detection via a multi-
region and semantic segmentation-aware cnn model. In The
IEEE International Conference on Computer Vision (ICCV),
December 2015.

[9] R. Girshick. Fast r-cnn. In The IEEE International Confer-

ence on Computer Vision (ICCV), December 2015.

[10] R. Girshick, J. Donahue, T. Darrell, and J. Malik. Rich fea-
ture hierarchies for accurate object detection and semantic
segmentation. In Computer Vision and Pattern Recognition
(CVPR), 2014 IEEE Conference on, pages 580–587. IEEE,
2014.

[11] A. Gonzalez-Garcia, A. Vezhnevets, and V. Ferrari. An ac-
tive search strategy for efﬁcient object class detection.
In
Proceedings of the IEEE Conference on Computer Vision
and Pattern Recognition, pages 3022–3031, 2015.

[12] K. He, X. Zhang, S. Ren, and J. Sun. Spatial pyramid pool-
ing in deep convolutional networks for visual recognition.
In Computer Vision–ECCV 2014, pages 346–361. Springer,
2014.

[13] K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learn-
ing for image recognition. arXiv preprint arXiv:1512.03385,
2015.

[14] Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long, R. Gir-
shick, S. Guadarrama, and T. Darrell. Caffe: Convolu-
tional architecture for fast feature embedding. arXiv preprint
arXiv:1408.5093, 2014.

[15] A. Krizhevsky, I. Sutskever, and G. E. Hinton.

Imagenet
In
classiﬁcation with deep convolutional neural networks.
Advances in neural information processing systems, pages
1097–1105, 2012.

9

6
1
0
2
 
r
p
A
 
1
1
 
 
]

V
C
.
s
c
[
 
 
2
v
1
1
7
7
0
.
2
1
5
1
:
v
i
X
r
a

Adaptive Object Detection Using Adjacency and Zoom Prediction

Yongxi Lu
University of California, San Diego
yol070@ucsd.edu

Tara Javidi
University of California, San Diego
tjavidi@ucsd.edu

Svetlana Lazebnik
University of Illinois at Urbana-Champaign
slazebni@illinois.edu

Abstract

State-of-the-art object detection systems rely on an ac-
curate set of region proposals. Several recent methods use
a neural network architecture to hypothesize promising ob-
ject locations. While these approaches are computation-
ally efﬁcient, they rely on ﬁxed image regions as anchors
for predictions. In this paper we propose to use a search
strategy that adaptively directs computational resources to
sub-regions likely to contain objects. Compared to meth-
ods based on ﬁxed anchor locations, our approach natu-
rally adapts to cases where object instances are sparse and
small. Our approach is comparable in terms of accuracy
to the state-of-the-art Faster R-CNN approach while using
two orders of magnitude fewer anchors on average. Code is
publicly available.

1. Introduction

Object detection is an important computer vision prob-
lem for its intriguing challenges and large variety of ap-
plications. Signiﬁcant recent progress in this area has
been achieved by incorporating deep convolutional neu-
ral networks (DCNN) [15] into object detection systems
[5, 8, 10, 12, 17, 23, 25].

An object detection algorithm with state-of-the-art ac-
curacy typically has the following two-step cascade: a set
of class-independent region proposals are hypothesized and
are then used as input to a detector that gives each region
a class label. The role of region proposals is to reduce the
complexity through limiting the number of regions that need
be evaluated by the detector. However, with recently intro-
duced techniques that enable sharing of convolutional fea-
tures [9, 12], traditional region proposal algorithms such as
selective search [27] and EdgeBoxes [29] become the bot-
tleneck of the detection pipeline.

ods are based on end-to-end trained deep neural networks
[5, 22]. The common idea in these approaches is to train
a class-independent regressor on a small set of pre-deﬁned
anchor regions. More speciﬁcally, each anchor region is as-
signed the task of deciding whether an object is in its neigh-
borhood (in terms of center location, scale and aspect ratio),
and predicting a bounding box for that object through re-
gression if that is the case. The design of anchors differs for
each method. For example, MultiBox [5] uses 800 anchors
from clustering, YOLO [21] uses a non-overlapping 7 by 7
grid, RPN [22] uses overlapping sliding windows. In these
prior works the test-time anchors are not adaptive to the ac-
tual content of the images, thus to further improve accuracy
for detecting small object instances a denser grid of anchors
is required for all images, resulting in longer test time and a
more complex network model.

We alternatively consider the following adaptive search
strategy. Instead of ﬁxing a priori a set of anchor regions,
our algorithm starts with the entire image.
It then recur-
sively divides the image into sub-regions (see Figure 2) un-
til it decides that a given region is unlikely to enclose any
small objects. The regions that are visited in the process
effectively serve as anchors that are assigned the task of
predicting bounding boxes for objects nearby. A salient
feature of our algorithm is that the decision of whether to
divide a region further is based on features extracted from
that particular region. As a result, the generation of the set
of anchor regions is conditioned on the image content. For
an image with only a few small objects most regions are
pruned early in the search, leaving a few small anchor re-
gions near the objects. For images that contain exclusively
large instances, our approach gracefully falls back to exist-
ing methods that rely on a small number of large anchor
regions. In this manner, our algorithm adaptively directs its
computational resources to regions that are likely to contain
objects. Figure 1 compares our algorithm with RPN.

An emerging class of efﬁcient region proposal meth-

To support our adaptive search algorithm, we train a deep

1

Figure 1. Comparison of our proposed adaptive search algorithm with the non-adaptive RPN method. The red boxes show region proposals
from adjacency predictions. Note that for small objects, RPN is forced to perform regression from much larger anchors, while our AZ-Net
approach can adaptively use features from small regions.

neural network we call Adjacency and Zoom Network (AZ-
Net). Given an input anchor region, the AZ-Net outputs a
scalar zoom indicator which is used to decide whether to
further zoom into (divide) the region and a set of bound-
ing boxes with conﬁdence scores, or adjacency predictions.
The adjacency predictions with high conﬁdence scores are
then used as region proposals for a subsequent object de-
tector. The network is applied recursively starting from the
whole image to generate an adaptive set of proposals.

To intuitively motivate the design of our network, con-
sider a situation in which one needs to perform a quick
search for a car. A good strategy is to ﬁrst look for
larger structures that could provide evidence for existence
of smaller structures in related categories. A search agent
could, for example, look for roads and use that to reason
about where cars should be. Once the search nears the car,
one could use the fact that seeing certain parts is highly pre-
dictive of the spatial support of the whole. For instance,
the wheels provide strong evidence for a tight box of the
car. In our design, the zoom indicator mimics the process
of searching for larger structures, while the adjacency pre-
dictions mimic the process of neighborhood inference.

To validate this design we extensively evaluate our al-
gorithm on Pascal VOC 2007 [6] with ﬁne-grained analy-
sis. We also report baseline results on the recently intro-
duced MSCOCO [18] dataset. Our algorithm achieves de-
tection mAP that is close to state-of-the-art methods at a
fast frame rate. Code has been made publicly available at
https://github.com/luyongxi/az-net.

In summary, we make the following contributions:

• We design a search strategy for object detection that
adaptively focuses computational resources on image
regions that contain objects.

• We evaluate our approach on Pascal VOC 2007 and
MSCOCO datasets and demonstrate it is comparable

to Fast R-CNN and Faster R-CNN with fewer anchor
and proposal regions.

• We provide a ﬁne-grained analysis that shows intrigu-
ing features of our approach. Namely, our proposal
strategy has better recall for higher intersection-over-
union thresholds, higher recall for smaller numbers of
top proposals, and for smaller object instances.

This paper is organized as follows. In section 2 we sur-
vey existing literature highlighting the novelty of our ap-
proach. In Section 3 we introduce the design of our algo-
rithm. Section 4 presents an empirical comparison to exist-
ing object detection methods on standard evaluation bench-
marks, and Section 5 discusses possible future directions.

2. Previous Work

Lampert et al. [16] ﬁrst proposed an adaptive branch-
and-bound approach. More recently, Gonzeles-Garcia et al.
[11], Caicedo and Lazebnik [3], and Yoo et al. [28] explored
active object detection with DCNN features. While these
approaches show the promise of using an adaptive algo-
rithm for object detection, their detectors are class-wise and
their methods cannot achieve competitive accuracy. Our ap-
proach, on the other hand, is multi-class and is compara-
ble to state-of-the-art approaches in both accuracy and test
speed.

The idea of using spatial context has been previously ex-
plored in the literature. Previous work by Torralba et al.
[26] used a biologically inspired visual attention model [2],
but our focus is on efﬁcient engineering design. Divvala et
al. [4] evaluated the use of context for localization, but their
empirical study was performed on hand-crafted features and
needs to be reexamined in combination with more accurate
recent approaches.

Our method is closely related to recent approaches that

2

1

3

5

2

4

Figure 2. As illustrated, a given region is divided into 5 sub-regions
(numbered). Each of these sub-regions is recursively divided if its
zoom indicator is above a threshold.

No zoom

No zoom

Zoom

Figure 3. Illustration of desired zoom indicator for common situa-
tions. The green boxes are objects, and the red boxes are regions.
Left: the object is small but it is mostly outside the region – there
is no gain in zooming in. Middle: the object is mostly inside but
its size is large relative to the region – there is no gain in zooming
in. Right: there is a small object that is completely inside the re-
gion. In this case further division of the region greatly increases
the chance of detection for that object.

use anchor regions for proposal generation or detection. For
example, Erhan et al. [5] use 800 data-driven anchors for re-
gion proposals and Redmon et al. [21] use a ﬁxed grid of 49
non-overlapping regions to provide class-wise detections.
The former has the concern that these anchors could over-
ﬁt the data, while the latter cannot achieve state-of-the-art
performance without model ensembles. Our work is most
related to the recent work by Ren et al. [22], which uses a set
of heuristically designed 2400 overlapping anchor regions.
Our approach uses a similar regression technique to predict
multiple bounding boxes from an anchor region. However,
our anchor regions are generated adaptively, making them
intrinsically more efﬁcient. In particular, we show that it is
possible to detect small object instances in the scene with-
out an excessive number of anchor regions. We propose to
grow a tree of ﬁner-grained anchor regions based on local
image evidence, and design the regression model strategi-
cally on top of it. We extensively compare the output of our
method against [22] in our experimental section and show
the unique advantages of our approach.

This paper is a follow-up to the work published in the
53rd Annual Allerton Conference [20]. Here, we introduce
a substantially improved algorithm and add extensive eval-
uations on standard benchmarks.

3

1

3

2

1

3

1

3

2

2

4

Figure 4. Illustration of sub-region priors. From left to right: ver-
tical stripes, horizontal stripes, neighboring squares. The red rect-
angular box is the image. In the ﬁgure the numbered regions are
template sub-regions. The gaps between sub-regions are exagger-
ated for better visualization. The vertical stripes are used to detect
tall objects, the horizontal stripes are used to detect fat objects,
while the neighboring squares are used to detect objects that fall
in the gaps between anchor regions generated in the search pro-
cess.

3. Design of the Algorithm

3.1. Overview of the Adaptive Search

Our object detection algorithm consists of two steps. In
step 1, a set of class-independent region proposals are gen-
erated using Adaptive Search with AZ-Net (see Algorithm
1). In step 2, an object detector evaluates each region pro-
posed in step 1 to provide class-wise detections. In our ex-
periments the detector is Fast R-CNN.

Our focus is on improving step 1. We consider a recur-
sive search strategy, starting from the entire image as the
root region. For any region encountered in the search pro-
cedure, the algorithm extracts features from this region to
compute the zoom indicator and the adjacency predictions.
The adjacency predictions with conﬁdence scores above a
threshold are included in the set of output region proposals.
If the zoom indicator is above a threshold, this indicates
that the current region is likely to contain small objects. To
detect these embedded small objects, the current region is
divided into sub-regions in the manner shown in Figure 2.
Each of these sub-regions is then recursively processed in
the same manner as its parent region, until either its area
or its zoom indicator is too small. Figure 1 illustrates this
procedure.

In the following section, we discuss the design of the

zoom indicator and adjacency prediction.

3.2. Design of Building Blocks

The zoom indicator should be large for a region only
when there exists at least one object whose spatial support
mostly lies within the region, and whose size is sufﬁciently
small compared to the region. The reasoning is that we
should zoom in to a region only when it substantially in-
creases the chance of detection. For example, if an object is
mostly outside the region, dividing the region further is un-
likely to increase the chance of detecting that object. Sim-
ilarly, if an object is large compared to the current region,
the task of detecting this object should be handled by this

Algorithm 1: Adaptive search with AZ-Net.
Data: Input image x (the whole image region bx). Yk is the region proposed at step k. Y k are the accumulated region
proposals up to step k. Zk are the regions to further zoom in to at step k. Bk are anchor regions at step k.

Compute adjacency predictions Ab and the zoom indicator zb using AZ-Net.
Include all a ∈ Ab with high conﬁdence scores into Yk.
Include b into Zk if zb is above threshold.

Result: Region proposals at termination Y K.
Initialization: B0 ← {bx}. Y 0 ← ∅, k ← 0
while (Bk is not an empty set) do

Initialize Yk and Zk as empty sets.
foreach b ∈ Bk do

end
Y k ← Y k−1 ∪ Yk
Bk+1 ← Divide-Regions(Zk)
k ← k + 1

end
K ← k − 1

make sub-region priors large compared to the anchor under
the intuition that if an object is small, it is best to wait until
the features extracted are at the right scale to make bound-
ing box predictions.

3.3. Implementation

We implement our algorithm using the Caffe [14] frame-
work, utilizing the open source infrastructure provided by
the Fast R-CNN repository [9].
In this section we intro-
duce the implementation details of our approach. We use
the Fast R-CNN detector since it is a fast and accurate re-
cent approach. Our method should in principle work for a
broad class of object detectors that use region proposals.

We train a deep neural network as illustrated in Figure
5. Note that in addition to the sub-region priors as shown
in Figure 4, we also add the region itself as a special prior
region, making in total 11 adjacency predictions per anchor.
For the convolutional layers, we use the VGG16 model [23]
pre-trained on ImageNet data. The fully-connected layers
are on top of a region pooling layer introduced in [9] which
allows efﬁcient sharing of convolutional layer features.

The training is performed as a three-step procedure.
First, a set of regions is sampled from the image. These
samples should contain hard positive and negative exam-
ples for both the zoom indicator and the adjacency predic-
tion. Finally, the tuples of samples and labels are used in
standard stochastic gradient descent training. We now dis-
cuss how the regions are sampled and labeled, and the loss
function we choose.

3.3.1 Region Sampling and Labeling

Since a typical image only has a few object instances, to
provide sufﬁcient positive examples for adjacency predic-

Figure 5. Illustration of the AZ-Net architecture.

region or its parents. In the latter case, further division of
the region not only wastes computational resources, but also
introduces false positives in the region proposals. Figure 3
shows common situations and the desirable behavior of the
zoom indicator.

The role of adjacency prediction is to detect one or mul-
tiple objects that overlap with the anchor region sufﬁciently
by providing tight bounding boxes. The adjacency predic-
tion should be aware of the search geometry induced by the
zoom indicator. More speciﬁcally, the adjacency predic-
tion should perform well on the effective anchor regions in-
duced by the search algorithm. For this purpose we propose
a training procedure that is aware of the adaptive search
scheme (discussed in Section 3.3). On the other hand, its
design should explicitly account for typical geometric con-
ﬁgurations of objects that fall inside the region, so that the
training can be performed in a consistent fashion. For this
reason, we propose to make predictions based on a set of
sub-region priors as shown in Figure 4. Note that we also
include the anchor region itself as an additional prior. We

4

[22]. Unlike in Fast R-CNN, to provide multiple predic-
tions from any region, the conﬁdence scores are not nor-
malized to a probability vector. Correspondingly we use
smooth L1-loss for bounding box output and element-wise
cross-entropy loss for conﬁdence score output. The three
losses are summed together to form a multi-task loss func-
tion.

3.3.3 Fast R-CNN Detectors

The detectors we use to evaluate proposal regions are Fast
R-CNN detectors trained using AZ-Net proposals. As in
[22], we implement two versions: one with unshared con-
volutional features and the other that shares convolutional
features with AZ-Net. The shared version is trained using
alternating optimization.

4. Experiments

We evaluate our approach on Pascal VOC 2007 [6] and
MSCOCO [18] datasets. In addition to evaluating the accu-
racy of the ﬁnal detectors, we also perform detailed compar-
isons between the RPN approach adopted in Faster R-CNN
and our AZ-Net on VOC 2007. At the end of the section,
we give an analysis of the efﬁciency of our adaptive search
strategy.

4.1. Results on VOC 2007

To set up a baseline comparison, we evaluate our ap-
proach using the standard average precision (AP) metric
for object detection. For AP evaluation we use the de-
velopment kit provided by the VOC 2007 object detection
challenge. We compare our approach against the recently
introduced Fast R-CNN [9] and Faster R-CNN [22] sys-
tems, which achieve state-of-the-art performance in stan-
dard benchmarks, such as VOC 2007 [6] and VOC 2012
[7]. A comparison is shown in Table 1. The results sug-
gest that our approach is comparable to or better than these
methods.

4.2. Quality of Region Proposals

We preform a detailed analysis of the quality of region
proposals from our AZ-Net, highlighting a comparison to
the RPN network used in Faster R-CNN. For all our ex-
periments, we analyze the recall on Pascal VOC 2007 test
set using the following deﬁnition: An object is counted as
retrieved if there exists a region proposal with an above-
threshold IoU with it. The recall is then calculated as the
proportion of the retrieved objects among all ground truth
object instances. To accurately reproduce the RPN ap-
proach, we downloaded the region proposals provided on
the Faster R-CNN repository 1. We used the results from

1https://github.com/ShaoqingRen/faster_rcnn

Figure 6. Illustration of the inverse matching procedure. The red
box is the inverse match for the object (green box). The left ﬁgure
shows inverse matching of a neighboring square, the right ﬁgure
shows inverse matching of a vertical stripe.

tions our method inversely ﬁnds regions that will see a
ground truth object as a perfect ﬁt to its prior sub-regions
(see Figure 6 for illustration). This provides k × 11 training
examples for each image, where k is the number of objects.
To mine for negative examples and hard positive exam-
ples, we search the input image as in Algorithm 1. Note
that the algorithm uses zoom indicators from the AZ-Net.
Instead of optimizing AZ-Net with an on-policy approach
(that uses the intermediate AZ-Net model to sample re-
gions), which might cause training to diverge, we replace
the zoom prediction with the zoom indicator label. How-
ever, we note that using the zoom label directly could cause
overﬁtting, since at test time the algorithm might encounter
situations where a previous zoom prediction is wrong. To
improve the robustness of the model, we add noise to the
zoom label by ﬂipping the ground truth with a probability
of 0.3. We found that models trained without random ﬂip-
ping are signiﬁcantly less accurate. For each input image
we initiate this procedure with ﬁve sub-images and repeat it
multiple times. We also append horizontally ﬂipped images
to the dataset for data augmentation.

Assignment of labels for the zoom indicator follows the
discussion of Section 3. The label is 1 if there exists an ob-
ject with 50% of its area inside the region and the area is
at most 25% of the size of the region. Note that here we
use a loose deﬁnition of inclusion to add robustness for ob-
jects falling between boundaries of anchors. For adjacency
prediction, we set a threshold in the intersection-over-union
(IoU) score between an object and a region. A region is
assigned to detect objects with which it has sufﬁcient over-
lap. The assigned objects are then greedily matched to one
of the sub-regions deﬁned by the priors shown in Figure 4.
The priority in the matching is determined by the IoU score
between the objects and the sub-regions. We note that in
this manner multiple predictions from a region are possible.

3.3.2 Loss Function

As shown in Figure 5, the AZ-Net has three output layers.
The zoom indicator outputs from a sigmoid activation func-
tion. To train it we use the cross-entropy loss function pop-
ular for binary classiﬁcation. For the adjacency predictions,
the bounding boxes are parameterized as in Fast R-CNN

5

Figure 7. Example outputs of our algorithm. The left column shows the original image. The middle column shows the anchor regions
induced by our adaptive search. The right column shows the top 100 adjacency predictions made around the anchor regions. The anchor
regions and the adjacency predictions are superimposed into a ﬁgure at the same resolution of the original image. We note that the anchor
regions and the region proposals in our approach are shared across object categories. For example, for the last image, the algorithm
generates anchor regions at proper scales near the dogs, the person, and the bottles.

Method

AZ-Net
AZ-Net*
RPN
RPN*
FRCNN

boxes

mAP

231
228
300
300
2000

70.2
70.4
69.9
68.5
68.1

aero

73.3
73.9
70.0
74.1
74.6

bike

78.8
79.9
80.6
77.2
79.0

bird

69.2
68.8
70.1
67.7
68.6

boat

59.9
58.9
57.3
53.9
57.0

bottle

48.7
49.1
49.9
51.0
39.3

bus

81.4
80.8
78.2
75.1
79.5

car

82.8
83.3
80.4
79.2
78.6

cat

83.6
83.7
82.0
78.9
81.9

chair

47.5
47.2
52.2
50.7
48.0

cow

77.3
75.8
75.3
78.0
74.0

table

62.9
63.8
67.2
61.1
67.4

dog

81.1
80.6
80.3
79.1
80.5

horse

mbike

person

plant

sheep

83.5
84.4
79.8
81.9
80.7

78.0
78.9
75.0
72.2
74.1

75.8
75.8
76.3
75.9
69.6

38.0
39.2
39.1
37.2
31.8

68.7
70.2
68.3
71.4
67.1

sofa

67.2
67.4
67.3
62.5
68.4

train

79.0
78.4
81.1
77.4
75.3

tv

66.4
68.3
67.6
66.4
65.5

Table 1. Comparison on VOC 2007 test set using VGG-16 for convolutional layers. The results of RPN are reported in [22]. The results
for Fast R-CNN are reported in [9]. The AZ-Net and RPN results are reported for top-300 region proposals, but in AZ-Net many images
have too few anchors to generate 300 proposals. * indicates results without shared convolutional features. All listed methods use DCNN
models trained on VOC 2007 trainval.

a model reportedly trained on VOC 2007 trainval. Cor-
respondingly we compare it against our model trained on
VOC 2007 trainval set. The comparisons concerning top-

N regions are performed by ranking the region proposals in
order of their conﬁdence scores.

Figure 8 shows a comparison of recall at different IoU

6

AZ−Net (Ours)
 
RPN (Faster R−CNN)

AZ−Net (Ours)
RPN (Faster R−CNN)

 

 

.

 

0
5
0
=
d
l
o
h
s
e
r
h
T
U
o
I
 
t
a

 

 
l
l
a
c
e
R

1

0.8

0.6

0.4

0.2

0

 

1

0.8

0.6

0.4

0.2

 

s
l
a
s
o
p
o
r
P
n
o
i
g
e
R
 
0
0
3
−
p
o
T

 
t
a
 
l
l
a
c
e
R

0
0.5

s
l
a
s
o
p
o
r
P
 
g
n
i
h
c
t
a
M

 
f
o
 
r
e
b
m
u
N

20

15

10

5

0

1

0.8

0.6

0.4

0.2

 

0
5
.
0
 
=
d
l
o
h
s
e
r
h
T
U
o
I
 
t
a
 
l
l
a
c
e
R

 

0
10

0

0.55

0.6

0.65

0.7

0.75

0.8

0.85

0.9

0.95

Threshold at IoU

Figure 8. Comparison of recall of region proposals generated by
AZ-Net and RPN at different intersection over union thresholds
on VOC 2007 test. The comparison is performed at top-300 re-
gion proposals. Our approach has better recall at large IoU thresh-
olds, which suggests that AZ-Net proposals are more accurate in
localizing the objects.

AZ−Net (Ours)
RPN (Faster R−CNN)

 

Small

Medium
Size of Ground Truth Boxes

Large

Figure 9. Number of proposals matched to ground truth (with
IoU= 0.5). This shows proposals from AZ-Net are more con-
centrated around true object locations.

 

AZ−Net (Ours)
RPN (Faster R−CNN)

1

10

2

10

Number of Region Proposals

Figure 10. Comparison of recall of region proposals generated by
AZ-Net and RPN at different number of region proposals on VOC
2007 test. The comparison is performed at IoU threshold 0.5. Our
approach has better early recall. In particular, it reaches 0.6 recall
with only 10 proposals.

Small

Medium
Size of Ground Truth Boxes

Large

Figure 11. Comparison of recall of region proposals generated by
AZ-Net and RPN for objects of different sizes on VOC 2007 test.
The comparison is performed at IoU threshold 0.5 with top-300
proposals. Our approach has signiﬁcantly better recall for small
objects.

Anchor Regions

Region proposals

Runtime (ms)

Method

AZ-Net
AZ-Net*
RPN
RPN*
FRCNN

62
44
2400
2400
N/A

231
228
300
300
2000

171
237
198
342
1830

Table 2. Numbers related to the efﬁciency of the object detection
methods listed in Table 1. The runtimes for RPN and Fast R-CNN
are reported for a K40 GPU [22]. Our runtime experiment is per-
formed on a GTX 980Ti GPU. The K40 GPU has larger GPU
memory, while the GTX 980Ti has higher clock rate. * indicates
unshared convolutional feature version.

thresholds. Our AZ-net has consistently higher recall than
RPN, and the advantage is larger at higher IoU thresholds.
This suggests our method generates bounding boxes that in
general overlap with the ground truth objects better. The
proposals are also more concentrated around objects, as
shown in Figure 9.

Figure 10 shows a plot of recall as a function of the num-
ber of proposals. A region proposal algorithm is more efﬁ-
cient in covering objects if its area under the curve is larger.
Our experiment suggests that our AZ-Net approach has a
better early recall than RPN. That means our algorithm in
general can recover more objects with the same number of
region proposals.

Figure 11 shows a comparison of recall for objects with
different sizes. The “small object” has an area less than
322, a “medium object” has an area between 322 and 962,
and a “large object” has an area greater than 962, same as
the deﬁnition in MSCOCO [18]. Our approach achieves
higher recall on the small object subset. This is because
when small objects are present in the scene our adaptive
search strategy generates small anchor regions around them,
as shown in Figure 7.

4.3. Efﬁciency of Adaptive Search

Our approach is efﬁcient in runtime, as shown in Table
2. We note that this is achieved even with several severe in-

7

y
c
n
e
u
q
e
r
F

700

600

500

400

300

200

100

0
0

Median: 40

Mean: 62

96% of the
distribution

50
250
150
Number of Evaluated Anchor Regions

200

100

300

Figure 12. Distribution of the number of anchor regions evaluated
on VOC 2007 test set. For most images a few dozen anchor regions
are required. Note that anchors are shared across categories.

efﬁciencies in our implementation. First, for each image
our algorithm requires several rounds of fully connected
layer evaluation, which induces expensive memory trans-
fer between GPU and CPU. Secondly, the Faster R-CNN
approach uses convolutional computation for the evaluation
of anchor regions, which is highly optimized compared to
the RoI pooling technique we adopted. Despite these in-
efﬁciencies, our approach still achieves high accuracy at a
state-of-the-art frame rate, using lower-end hardware. With
improved implementation and model design we expect our
algorithm to be signiﬁcantly faster.

An interesting aspect that highlights the advantages of
our approach is the small number of anchor regions to eval-
uate. To further understand this aspect of our algorithm,
we show in Figure 12 the distribution of anchor regions
evaluated for each image. For most images our method
only requires a few dozen anchor regions. This number is
much smaller than the 2400 anchor regions used in RPN
[22] and the 800 used in MultiBox [5]. Future work could
further capitalize on this advantage by using an expensive
but more accurate per-anchor step, or by exploring applica-
tions to very high-resolution images, for which traditional
non-adaptive approaches will face intrinsic difﬁculties due
to scalability issues. Our experiment also demonstrates the
possibility of designing a class-generic search. Unlike per-
class search methods widely used in previous adaptive ob-
ject detection schemes [3, 28] our anchor regions are shared
among object classes, making it efﬁcient for multi-class de-
tection.

4.4. Results on MSCOCO

We also evaluated our method on MSCOCO dataset and
submitted a “UCSD” entry to the MSCOCO 2015 detection
challenge. Our post-competition work greatly improved ac-
curacy with more training iterations. A comparison with
other recent methods is shown in Table 3. Our model is

8

Method

FRCNN (VGG16) [9]
FRCNN (VGG16) [22]
RPN (VGG16)
RPN (ResNet)
AZ-Net (VGG16)

AP

19.7
19.3
21.9
37.4
22.3

AP IoU=0.50

35.9
39.3
42.7
59.0
41.0

Table 3. The detection mAP on MSCOCO 2015 test-dev set. The
RPN (ResNet) entry won the MSCOCO 2015 detection challenge.
Updated leaderboard can be found in http://mscoco.org.

trained with minibatches consisting of 256 regions sampled
from one image, and 720k iterations in total. The results
for RPN(VGG16) reported in [22] were obtained with an
8-GPU implementation that effectively has 8 and 16 images
per minibatch for RPN and Fast R-CNN respectively, each
trained at 320k training iterations. Despite the much shorter
effective training iterations, our AZ-Net achieves similar
mAP with RPN(VGG16) and is more accurate when eval-
uated on the MSCOCO mAP metric that rewards accurate
localization.

Our best post-competition model is still signiﬁcantly
outperformed by the winning “MSRA” entry. Their ap-
proach is a Faster-R-CNN-style detection pipeline, replac-
ing the VGG-16 network with an ultra-deep architecture
called Deep Residual Network [13]. They also report signif-
icant improvement from using model ensembles and global
contextual information. We note that these developments
are complementary to our contribution.

5. Conclusion and Future Work

This paper has introduced an adaptive object detection
system using adjacency and zoom predictions. Our al-
gorithm adaptively focuses its computational resources on
small regions likely to contain objects, and demonstrates
state-of-the-art accuracy at a fast frame rate.

The current method can be further extended and im-
proved in many aspects. Better pre-trained models [13]
can be incorporated into the current system for even bet-
ter accuracy. Further reﬁning the model to allow single-
pipeline detection that directly predicts class labels, as in
YOLO [21] and the more recent SSD [19] method, could
signiﬁcantly boost testing frame rate. Recent techniques
that improve small object detection, such as the contextual
model and skip layers adopted in Inside-Outside Net [1],
suggest additional promising directions. It is also interest-
ing to consider more aggressive extensions. For instance, it
might be advantageous to use our search structure to focus
high-resolution convolutional layer computation on smaller
regions, especially for very high-resolution images.

Acknowledgment

This work is supported by the National Science Foun-
dation grants CIF-1302438, CCF-1302588 and CNS-
1329819, as well as Xerox UAC, and the Sloan Foundation.

[16] C. H. Lampert, M. B. Blaschko, and T. Hofmann. Efﬁcient
subwindow search: A branch and bound framework for ob-
ject localization. Pattern Analysis and Machine Intelligence,
IEEE Transactions on, 31(12):2129–2142, 2009.

[17] X. Liang, S. Liu, Y. Wei, L. Liu, L. Lin, and S. Yan. To-
wards computational baby learning: A weakly-supervised
approach for object detection.
In The IEEE International
Conference on Computer Vision (ICCV), December 2015.

[18] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona, D. Ra-
manan, P. Doll´ar, and C. L. Zitnick. Microsoft coco: Com-
mon objects in context.
In Computer Vision–ECCV 2014,
pages 740–755. Springer, 2014.

[19] W. Liu, D. Anguelov, D. Erhan, C. Szegedy, and S. Reed.
arXiv preprint

Single shot multibox detector.

Ssd:
arXiv:1512.02325, 2015.

[20] Y. Lu and T. Javidi. Efﬁcient object detection for high reso-
lution images. arXiv preprint arXiv:1510.01257, 2015.
[21] J. Redmon, S. Divvala, R. Girshick, and A. Farhadi. You
only look once: Uniﬁed, real-time object detection. arXiv
preprint arXiv:1506.02640, 2015.

[22] S. Ren, K. He, R. Girshick, and J. Sun. Faster r-cnn: Towards
real-time object detection with region proposal networks. In
C. Cortes, N. D. Lawrence, D. D. Lee, M. Sugiyama, and
R. Garnett, editors, Advances in Neural Information Process-
ing Systems 28, pages 91–99. Curran Associates, Inc., 2015.
[23] K. Simonyan and A. Zisserman. Very deep convolutional
networks for large-scale image recognition. arXiv preprint
arXiv:1409.1556, 2014.

[24] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed,
D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabi-
novich. Going deeper with convolutions. arXiv preprint
arXiv:1409.4842, 2014.

[25] C. Szegedy, A. Toshev, and D. Erhan. Deep neural networks
for object detection. In Advances in Neural Information Pro-
cessing Systems, pages 2553–2561, 2013.

[26] A. Torralba, A. Oliva, M. S. Castelhano, and J. M. Hender-
son. Contextual guidance of eye movements and attention
in real-world scenes:
the role of global features in object
search. Psychological review, 113(4):766, 2006.

[27] J. R. Uijlings, K. E. van de Sande, T. Gevers, and A. W.
Smeulders. Selective search for object recognition. Interna-
tional journal of computer vision, 104(2):154–171, 2013.
[28] D. Yoo, S. Park, J.-Y. Lee, A. S. Paek, and I. So Kweon. At-
tentionnet: Aggregating weak directions for accurate object
detection. In The IEEE International Conference on Com-
puter Vision (ICCV), December 2015.

[29] C. L. Zitnick and P. Doll´ar. Edge boxes: Locating object pro-
posals from edges. In Computer Vision–ECCV 2014, pages
391–405. Springer, 2014.

References

[1] S. Bell, C. L. Zitnick, K. Bala, and R. Girshick.

Inside-
outside net: Detecting objects in context with skip
pooling and recurrent neural networks.
arXiv preprint
arXiv:1512.04143, 2015.

[2] A. Borji and L. Itti. State-of-the-art in visual attention model-
ing. Pattern Analysis and Machine Intelligence, IEEE Trans-
actions on, 35(1):185–207, 2013.

[3] J. C. Caicedo and S. Lazebnik. Active object localization
with deep reinforcement learning. In The IEEE International
Conference on Computer Vision (ICCV), December 2015.
[4] S. K. Divvala, D. Hoiem, J. H. Hays, A. Efros, M. Hebert,
et al. An empirical study of context in object detection.
In Computer Vision and Pattern Recognition, 2009. CVPR
2009. IEEE Conference on, pages 1271–1278. IEEE, 2009.
[5] D. Erhan, C. Szegedy, A. Toshev, and D. Anguelov. Scalable
object detection using deep neural networks.
In Computer
Vision and Pattern Recognition (CVPR), 2014 IEEE Confer-
ence on, pages 2155–2162. IEEE, 2014.

[6] M. Everingham, L. Van Gool, C. K. I. Williams, J. Winn,
and A. Zisserman. The PASCAL Visual Object Classes
Challenge 2007 (VOC2007) Results.
http://www.pascal-
network.org/challenges/VOC/voc2007/workshop/index.html.
[7] M. Everingham, L. Van Gool, C. K. I. Williams, J. Winn,
and A. Zisserman. The PASCAL Visual Object Classes
Challenge 2012 (VOC2012) Results.
http://www.pascal-
network.org/challenges/VOC/voc2012/workshop/index.html.
[8] S. Gidaris and N. Komodakis. Object detection via a multi-
region and semantic segmentation-aware cnn model. In The
IEEE International Conference on Computer Vision (ICCV),
December 2015.

[9] R. Girshick. Fast r-cnn. In The IEEE International Confer-

ence on Computer Vision (ICCV), December 2015.

[10] R. Girshick, J. Donahue, T. Darrell, and J. Malik. Rich fea-
ture hierarchies for accurate object detection and semantic
segmentation. In Computer Vision and Pattern Recognition
(CVPR), 2014 IEEE Conference on, pages 580–587. IEEE,
2014.

[11] A. Gonzalez-Garcia, A. Vezhnevets, and V. Ferrari. An ac-
tive search strategy for efﬁcient object class detection.
In
Proceedings of the IEEE Conference on Computer Vision
and Pattern Recognition, pages 3022–3031, 2015.

[12] K. He, X. Zhang, S. Ren, and J. Sun. Spatial pyramid pool-
ing in deep convolutional networks for visual recognition.
In Computer Vision–ECCV 2014, pages 346–361. Springer,
2014.

[13] K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learn-
ing for image recognition. arXiv preprint arXiv:1512.03385,
2015.

[14] Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long, R. Gir-
shick, S. Guadarrama, and T. Darrell. Caffe: Convolu-
tional architecture for fast feature embedding. arXiv preprint
arXiv:1408.5093, 2014.

[15] A. Krizhevsky, I. Sutskever, and G. E. Hinton.

Imagenet
In
classiﬁcation with deep convolutional neural networks.
Advances in neural information processing systems, pages
1097–1105, 2012.

9

6
1
0
2
 
r
p
A
 
1
1
 
 
]

V
C
.
s
c
[
 
 
2
v
1
1
7
7
0
.
2
1
5
1
:
v
i
X
r
a

Adaptive Object Detection Using Adjacency and Zoom Prediction

Yongxi Lu
University of California, San Diego
yol070@ucsd.edu

Tara Javidi
University of California, San Diego
tjavidi@ucsd.edu

Svetlana Lazebnik
University of Illinois at Urbana-Champaign
slazebni@illinois.edu

Abstract

State-of-the-art object detection systems rely on an ac-
curate set of region proposals. Several recent methods use
a neural network architecture to hypothesize promising ob-
ject locations. While these approaches are computation-
ally efﬁcient, they rely on ﬁxed image regions as anchors
for predictions. In this paper we propose to use a search
strategy that adaptively directs computational resources to
sub-regions likely to contain objects. Compared to meth-
ods based on ﬁxed anchor locations, our approach natu-
rally adapts to cases where object instances are sparse and
small. Our approach is comparable in terms of accuracy
to the state-of-the-art Faster R-CNN approach while using
two orders of magnitude fewer anchors on average. Code is
publicly available.

1. Introduction

Object detection is an important computer vision prob-
lem for its intriguing challenges and large variety of ap-
plications. Signiﬁcant recent progress in this area has
been achieved by incorporating deep convolutional neu-
ral networks (DCNN) [15] into object detection systems
[5, 8, 10, 12, 17, 23, 25].

An object detection algorithm with state-of-the-art ac-
curacy typically has the following two-step cascade: a set
of class-independent region proposals are hypothesized and
are then used as input to a detector that gives each region
a class label. The role of region proposals is to reduce the
complexity through limiting the number of regions that need
be evaluated by the detector. However, with recently intro-
duced techniques that enable sharing of convolutional fea-
tures [9, 12], traditional region proposal algorithms such as
selective search [27] and EdgeBoxes [29] become the bot-
tleneck of the detection pipeline.

ods are based on end-to-end trained deep neural networks
[5, 22]. The common idea in these approaches is to train
a class-independent regressor on a small set of pre-deﬁned
anchor regions. More speciﬁcally, each anchor region is as-
signed the task of deciding whether an object is in its neigh-
borhood (in terms of center location, scale and aspect ratio),
and predicting a bounding box for that object through re-
gression if that is the case. The design of anchors differs for
each method. For example, MultiBox [5] uses 800 anchors
from clustering, YOLO [21] uses a non-overlapping 7 by 7
grid, RPN [22] uses overlapping sliding windows. In these
prior works the test-time anchors are not adaptive to the ac-
tual content of the images, thus to further improve accuracy
for detecting small object instances a denser grid of anchors
is required for all images, resulting in longer test time and a
more complex network model.

We alternatively consider the following adaptive search
strategy. Instead of ﬁxing a priori a set of anchor regions,
our algorithm starts with the entire image.
It then recur-
sively divides the image into sub-regions (see Figure 2) un-
til it decides that a given region is unlikely to enclose any
small objects. The regions that are visited in the process
effectively serve as anchors that are assigned the task of
predicting bounding boxes for objects nearby. A salient
feature of our algorithm is that the decision of whether to
divide a region further is based on features extracted from
that particular region. As a result, the generation of the set
of anchor regions is conditioned on the image content. For
an image with only a few small objects most regions are
pruned early in the search, leaving a few small anchor re-
gions near the objects. For images that contain exclusively
large instances, our approach gracefully falls back to exist-
ing methods that rely on a small number of large anchor
regions. In this manner, our algorithm adaptively directs its
computational resources to regions that are likely to contain
objects. Figure 1 compares our algorithm with RPN.

An emerging class of efﬁcient region proposal meth-

To support our adaptive search algorithm, we train a deep

1

Figure 1. Comparison of our proposed adaptive search algorithm with the non-adaptive RPN method. The red boxes show region proposals
from adjacency predictions. Note that for small objects, RPN is forced to perform regression from much larger anchors, while our AZ-Net
approach can adaptively use features from small regions.

neural network we call Adjacency and Zoom Network (AZ-
Net). Given an input anchor region, the AZ-Net outputs a
scalar zoom indicator which is used to decide whether to
further zoom into (divide) the region and a set of bound-
ing boxes with conﬁdence scores, or adjacency predictions.
The adjacency predictions with high conﬁdence scores are
then used as region proposals for a subsequent object de-
tector. The network is applied recursively starting from the
whole image to generate an adaptive set of proposals.

To intuitively motivate the design of our network, con-
sider a situation in which one needs to perform a quick
search for a car. A good strategy is to ﬁrst look for
larger structures that could provide evidence for existence
of smaller structures in related categories. A search agent
could, for example, look for roads and use that to reason
about where cars should be. Once the search nears the car,
one could use the fact that seeing certain parts is highly pre-
dictive of the spatial support of the whole. For instance,
the wheels provide strong evidence for a tight box of the
car. In our design, the zoom indicator mimics the process
of searching for larger structures, while the adjacency pre-
dictions mimic the process of neighborhood inference.

To validate this design we extensively evaluate our al-
gorithm on Pascal VOC 2007 [6] with ﬁne-grained analy-
sis. We also report baseline results on the recently intro-
duced MSCOCO [18] dataset. Our algorithm achieves de-
tection mAP that is close to state-of-the-art methods at a
fast frame rate. Code has been made publicly available at
https://github.com/luyongxi/az-net.

In summary, we make the following contributions:

• We design a search strategy for object detection that
adaptively focuses computational resources on image
regions that contain objects.

• We evaluate our approach on Pascal VOC 2007 and
MSCOCO datasets and demonstrate it is comparable

to Fast R-CNN and Faster R-CNN with fewer anchor
and proposal regions.

• We provide a ﬁne-grained analysis that shows intrigu-
ing features of our approach. Namely, our proposal
strategy has better recall for higher intersection-over-
union thresholds, higher recall for smaller numbers of
top proposals, and for smaller object instances.

This paper is organized as follows. In section 2 we sur-
vey existing literature highlighting the novelty of our ap-
proach. In Section 3 we introduce the design of our algo-
rithm. Section 4 presents an empirical comparison to exist-
ing object detection methods on standard evaluation bench-
marks, and Section 5 discusses possible future directions.

2. Previous Work

Lampert et al. [16] ﬁrst proposed an adaptive branch-
and-bound approach. More recently, Gonzeles-Garcia et al.
[11], Caicedo and Lazebnik [3], and Yoo et al. [28] explored
active object detection with DCNN features. While these
approaches show the promise of using an adaptive algo-
rithm for object detection, their detectors are class-wise and
their methods cannot achieve competitive accuracy. Our ap-
proach, on the other hand, is multi-class and is compara-
ble to state-of-the-art approaches in both accuracy and test
speed.

The idea of using spatial context has been previously ex-
plored in the literature. Previous work by Torralba et al.
[26] used a biologically inspired visual attention model [2],
but our focus is on efﬁcient engineering design. Divvala et
al. [4] evaluated the use of context for localization, but their
empirical study was performed on hand-crafted features and
needs to be reexamined in combination with more accurate
recent approaches.

Our method is closely related to recent approaches that

2

1

3

5

2

4

Figure 2. As illustrated, a given region is divided into 5 sub-regions
(numbered). Each of these sub-regions is recursively divided if its
zoom indicator is above a threshold.

No zoom

No zoom

Zoom

Figure 3. Illustration of desired zoom indicator for common situa-
tions. The green boxes are objects, and the red boxes are regions.
Left: the object is small but it is mostly outside the region – there
is no gain in zooming in. Middle: the object is mostly inside but
its size is large relative to the region – there is no gain in zooming
in. Right: there is a small object that is completely inside the re-
gion. In this case further division of the region greatly increases
the chance of detection for that object.

use anchor regions for proposal generation or detection. For
example, Erhan et al. [5] use 800 data-driven anchors for re-
gion proposals and Redmon et al. [21] use a ﬁxed grid of 49
non-overlapping regions to provide class-wise detections.
The former has the concern that these anchors could over-
ﬁt the data, while the latter cannot achieve state-of-the-art
performance without model ensembles. Our work is most
related to the recent work by Ren et al. [22], which uses a set
of heuristically designed 2400 overlapping anchor regions.
Our approach uses a similar regression technique to predict
multiple bounding boxes from an anchor region. However,
our anchor regions are generated adaptively, making them
intrinsically more efﬁcient. In particular, we show that it is
possible to detect small object instances in the scene with-
out an excessive number of anchor regions. We propose to
grow a tree of ﬁner-grained anchor regions based on local
image evidence, and design the regression model strategi-
cally on top of it. We extensively compare the output of our
method against [22] in our experimental section and show
the unique advantages of our approach.

This paper is a follow-up to the work published in the
53rd Annual Allerton Conference [20]. Here, we introduce
a substantially improved algorithm and add extensive eval-
uations on standard benchmarks.

3

1

3

2

1

3

1

3

2

2

4

Figure 4. Illustration of sub-region priors. From left to right: ver-
tical stripes, horizontal stripes, neighboring squares. The red rect-
angular box is the image. In the ﬁgure the numbered regions are
template sub-regions. The gaps between sub-regions are exagger-
ated for better visualization. The vertical stripes are used to detect
tall objects, the horizontal stripes are used to detect fat objects,
while the neighboring squares are used to detect objects that fall
in the gaps between anchor regions generated in the search pro-
cess.

3. Design of the Algorithm

3.1. Overview of the Adaptive Search

Our object detection algorithm consists of two steps. In
step 1, a set of class-independent region proposals are gen-
erated using Adaptive Search with AZ-Net (see Algorithm
1). In step 2, an object detector evaluates each region pro-
posed in step 1 to provide class-wise detections. In our ex-
periments the detector is Fast R-CNN.

Our focus is on improving step 1. We consider a recur-
sive search strategy, starting from the entire image as the
root region. For any region encountered in the search pro-
cedure, the algorithm extracts features from this region to
compute the zoom indicator and the adjacency predictions.
The adjacency predictions with conﬁdence scores above a
threshold are included in the set of output region proposals.
If the zoom indicator is above a threshold, this indicates
that the current region is likely to contain small objects. To
detect these embedded small objects, the current region is
divided into sub-regions in the manner shown in Figure 2.
Each of these sub-regions is then recursively processed in
the same manner as its parent region, until either its area
or its zoom indicator is too small. Figure 1 illustrates this
procedure.

In the following section, we discuss the design of the

zoom indicator and adjacency prediction.

3.2. Design of Building Blocks

The zoom indicator should be large for a region only
when there exists at least one object whose spatial support
mostly lies within the region, and whose size is sufﬁciently
small compared to the region. The reasoning is that we
should zoom in to a region only when it substantially in-
creases the chance of detection. For example, if an object is
mostly outside the region, dividing the region further is un-
likely to increase the chance of detecting that object. Sim-
ilarly, if an object is large compared to the current region,
the task of detecting this object should be handled by this

Algorithm 1: Adaptive search with AZ-Net.
Data: Input image x (the whole image region bx). Yk is the region proposed at step k. Y k are the accumulated region
proposals up to step k. Zk are the regions to further zoom in to at step k. Bk are anchor regions at step k.

Compute adjacency predictions Ab and the zoom indicator zb using AZ-Net.
Include all a ∈ Ab with high conﬁdence scores into Yk.
Include b into Zk if zb is above threshold.

Result: Region proposals at termination Y K.
Initialization: B0 ← {bx}. Y 0 ← ∅, k ← 0
while (Bk is not an empty set) do

Initialize Yk and Zk as empty sets.
foreach b ∈ Bk do

end
Y k ← Y k−1 ∪ Yk
Bk+1 ← Divide-Regions(Zk)
k ← k + 1

end
K ← k − 1

make sub-region priors large compared to the anchor under
the intuition that if an object is small, it is best to wait until
the features extracted are at the right scale to make bound-
ing box predictions.

3.3. Implementation

We implement our algorithm using the Caffe [14] frame-
work, utilizing the open source infrastructure provided by
the Fast R-CNN repository [9].
In this section we intro-
duce the implementation details of our approach. We use
the Fast R-CNN detector since it is a fast and accurate re-
cent approach. Our method should in principle work for a
broad class of object detectors that use region proposals.

We train a deep neural network as illustrated in Figure
5. Note that in addition to the sub-region priors as shown
in Figure 4, we also add the region itself as a special prior
region, making in total 11 adjacency predictions per anchor.
For the convolutional layers, we use the VGG16 model [23]
pre-trained on ImageNet data. The fully-connected layers
are on top of a region pooling layer introduced in [9] which
allows efﬁcient sharing of convolutional layer features.

The training is performed as a three-step procedure.
First, a set of regions is sampled from the image. These
samples should contain hard positive and negative exam-
ples for both the zoom indicator and the adjacency predic-
tion. Finally, the tuples of samples and labels are used in
standard stochastic gradient descent training. We now dis-
cuss how the regions are sampled and labeled, and the loss
function we choose.

3.3.1 Region Sampling and Labeling

Since a typical image only has a few object instances, to
provide sufﬁcient positive examples for adjacency predic-

Figure 5. Illustration of the AZ-Net architecture.

region or its parents. In the latter case, further division of
the region not only wastes computational resources, but also
introduces false positives in the region proposals. Figure 3
shows common situations and the desirable behavior of the
zoom indicator.

The role of adjacency prediction is to detect one or mul-
tiple objects that overlap with the anchor region sufﬁciently
by providing tight bounding boxes. The adjacency predic-
tion should be aware of the search geometry induced by the
zoom indicator. More speciﬁcally, the adjacency predic-
tion should perform well on the effective anchor regions in-
duced by the search algorithm. For this purpose we propose
a training procedure that is aware of the adaptive search
scheme (discussed in Section 3.3). On the other hand, its
design should explicitly account for typical geometric con-
ﬁgurations of objects that fall inside the region, so that the
training can be performed in a consistent fashion. For this
reason, we propose to make predictions based on a set of
sub-region priors as shown in Figure 4. Note that we also
include the anchor region itself as an additional prior. We

4

[22]. Unlike in Fast R-CNN, to provide multiple predic-
tions from any region, the conﬁdence scores are not nor-
malized to a probability vector. Correspondingly we use
smooth L1-loss for bounding box output and element-wise
cross-entropy loss for conﬁdence score output. The three
losses are summed together to form a multi-task loss func-
tion.

3.3.3 Fast R-CNN Detectors

The detectors we use to evaluate proposal regions are Fast
R-CNN detectors trained using AZ-Net proposals. As in
[22], we implement two versions: one with unshared con-
volutional features and the other that shares convolutional
features with AZ-Net. The shared version is trained using
alternating optimization.

4. Experiments

We evaluate our approach on Pascal VOC 2007 [6] and
MSCOCO [18] datasets. In addition to evaluating the accu-
racy of the ﬁnal detectors, we also perform detailed compar-
isons between the RPN approach adopted in Faster R-CNN
and our AZ-Net on VOC 2007. At the end of the section,
we give an analysis of the efﬁciency of our adaptive search
strategy.

4.1. Results on VOC 2007

To set up a baseline comparison, we evaluate our ap-
proach using the standard average precision (AP) metric
for object detection. For AP evaluation we use the de-
velopment kit provided by the VOC 2007 object detection
challenge. We compare our approach against the recently
introduced Fast R-CNN [9] and Faster R-CNN [22] sys-
tems, which achieve state-of-the-art performance in stan-
dard benchmarks, such as VOC 2007 [6] and VOC 2012
[7]. A comparison is shown in Table 1. The results sug-
gest that our approach is comparable to or better than these
methods.

4.2. Quality of Region Proposals

We preform a detailed analysis of the quality of region
proposals from our AZ-Net, highlighting a comparison to
the RPN network used in Faster R-CNN. For all our ex-
periments, we analyze the recall on Pascal VOC 2007 test
set using the following deﬁnition: An object is counted as
retrieved if there exists a region proposal with an above-
threshold IoU with it. The recall is then calculated as the
proportion of the retrieved objects among all ground truth
object instances. To accurately reproduce the RPN ap-
proach, we downloaded the region proposals provided on
the Faster R-CNN repository 1. We used the results from

1https://github.com/ShaoqingRen/faster_rcnn

Figure 6. Illustration of the inverse matching procedure. The red
box is the inverse match for the object (green box). The left ﬁgure
shows inverse matching of a neighboring square, the right ﬁgure
shows inverse matching of a vertical stripe.

tions our method inversely ﬁnds regions that will see a
ground truth object as a perfect ﬁt to its prior sub-regions
(see Figure 6 for illustration). This provides k × 11 training
examples for each image, where k is the number of objects.
To mine for negative examples and hard positive exam-
ples, we search the input image as in Algorithm 1. Note
that the algorithm uses zoom indicators from the AZ-Net.
Instead of optimizing AZ-Net with an on-policy approach
(that uses the intermediate AZ-Net model to sample re-
gions), which might cause training to diverge, we replace
the zoom prediction with the zoom indicator label. How-
ever, we note that using the zoom label directly could cause
overﬁtting, since at test time the algorithm might encounter
situations where a previous zoom prediction is wrong. To
improve the robustness of the model, we add noise to the
zoom label by ﬂipping the ground truth with a probability
of 0.3. We found that models trained without random ﬂip-
ping are signiﬁcantly less accurate. For each input image
we initiate this procedure with ﬁve sub-images and repeat it
multiple times. We also append horizontally ﬂipped images
to the dataset for data augmentation.

Assignment of labels for the zoom indicator follows the
discussion of Section 3. The label is 1 if there exists an ob-
ject with 50% of its area inside the region and the area is
at most 25% of the size of the region. Note that here we
use a loose deﬁnition of inclusion to add robustness for ob-
jects falling between boundaries of anchors. For adjacency
prediction, we set a threshold in the intersection-over-union
(IoU) score between an object and a region. A region is
assigned to detect objects with which it has sufﬁcient over-
lap. The assigned objects are then greedily matched to one
of the sub-regions deﬁned by the priors shown in Figure 4.
The priority in the matching is determined by the IoU score
between the objects and the sub-regions. We note that in
this manner multiple predictions from a region are possible.

3.3.2 Loss Function

As shown in Figure 5, the AZ-Net has three output layers.
The zoom indicator outputs from a sigmoid activation func-
tion. To train it we use the cross-entropy loss function pop-
ular for binary classiﬁcation. For the adjacency predictions,
the bounding boxes are parameterized as in Fast R-CNN

5

Figure 7. Example outputs of our algorithm. The left column shows the original image. The middle column shows the anchor regions
induced by our adaptive search. The right column shows the top 100 adjacency predictions made around the anchor regions. The anchor
regions and the adjacency predictions are superimposed into a ﬁgure at the same resolution of the original image. We note that the anchor
regions and the region proposals in our approach are shared across object categories. For example, for the last image, the algorithm
generates anchor regions at proper scales near the dogs, the person, and the bottles.

Method

AZ-Net
AZ-Net*
RPN
RPN*
FRCNN

boxes

mAP

231
228
300
300
2000

70.2
70.4
69.9
68.5
68.1

aero

73.3
73.9
70.0
74.1
74.6

bike

78.8
79.9
80.6
77.2
79.0

bird

69.2
68.8
70.1
67.7
68.6

boat

59.9
58.9
57.3
53.9
57.0

bottle

48.7
49.1
49.9
51.0
39.3

bus

81.4
80.8
78.2
75.1
79.5

car

82.8
83.3
80.4
79.2
78.6

cat

83.6
83.7
82.0
78.9
81.9

chair

47.5
47.2
52.2
50.7
48.0

cow

77.3
75.8
75.3
78.0
74.0

table

62.9
63.8
67.2
61.1
67.4

dog

81.1
80.6
80.3
79.1
80.5

horse

mbike

person

plant

sheep

83.5
84.4
79.8
81.9
80.7

78.0
78.9
75.0
72.2
74.1

75.8
75.8
76.3
75.9
69.6

38.0
39.2
39.1
37.2
31.8

68.7
70.2
68.3
71.4
67.1

sofa

67.2
67.4
67.3
62.5
68.4

train

79.0
78.4
81.1
77.4
75.3

tv

66.4
68.3
67.6
66.4
65.5

Table 1. Comparison on VOC 2007 test set using VGG-16 for convolutional layers. The results of RPN are reported in [22]. The results
for Fast R-CNN are reported in [9]. The AZ-Net and RPN results are reported for top-300 region proposals, but in AZ-Net many images
have too few anchors to generate 300 proposals. * indicates results without shared convolutional features. All listed methods use DCNN
models trained on VOC 2007 trainval.

a model reportedly trained on VOC 2007 trainval. Cor-
respondingly we compare it against our model trained on
VOC 2007 trainval set. The comparisons concerning top-

N regions are performed by ranking the region proposals in
order of their conﬁdence scores.

Figure 8 shows a comparison of recall at different IoU

6

AZ−Net (Ours)
 
RPN (Faster R−CNN)

AZ−Net (Ours)
RPN (Faster R−CNN)

 

 

 

.

0
5
0
=
d
l
o
h
s
e
r
h
T
U
o
I
 
t
a

 

 
l
l
a
c
e
R

1

0.8

0.6

0.4

0.2

0

 

1

0.8

0.6

0.4

0.2

 

s
l
a
s
o
p
o
r
P
n
o
i
g
e
R
 
0
0
3
−
p
o
T

 
t
a
 
l
l
a
c
e
R

0
0.5

s
l
a
s
o
p
o
r
P
 
g
n
i
h
c
t
a
M

 
f
o
 
r
e
b
m
u
N

20

15

10

5

0

1

0.8

0.6

0.4

0.2

 

0
5
.
0
 
=
d
l
o
h
s
e
r
h
T
U
o
I
 
t
a
 
l
l
a
c
e
R

 

0
10

0

0.55

0.6

0.65

0.7

0.75

0.8

0.85

0.9

0.95

Threshold at IoU

Figure 8. Comparison of recall of region proposals generated by
AZ-Net and RPN at different intersection over union thresholds
on VOC 2007 test. The comparison is performed at top-300 re-
gion proposals. Our approach has better recall at large IoU thresh-
olds, which suggests that AZ-Net proposals are more accurate in
localizing the objects.

AZ−Net (Ours)
RPN (Faster R−CNN)

 

Small

Medium
Size of Ground Truth Boxes

Large

Figure 9. Number of proposals matched to ground truth (with
IoU= 0.5). This shows proposals from AZ-Net are more con-
centrated around true object locations.

 

AZ−Net (Ours)
RPN (Faster R−CNN)

1

10

2

10

Number of Region Proposals

Figure 10. Comparison of recall of region proposals generated by
AZ-Net and RPN at different number of region proposals on VOC
2007 test. The comparison is performed at IoU threshold 0.5. Our
approach has better early recall. In particular, it reaches 0.6 recall
with only 10 proposals.

Small

Medium
Size of Ground Truth Boxes

Large

Figure 11. Comparison of recall of region proposals generated by
AZ-Net and RPN for objects of different sizes on VOC 2007 test.
The comparison is performed at IoU threshold 0.5 with top-300
proposals. Our approach has signiﬁcantly better recall for small
objects.

Anchor Regions

Region proposals

Runtime (ms)

Method

AZ-Net
AZ-Net*
RPN
RPN*
FRCNN

62
44
2400
2400
N/A

231
228
300
300
2000

171
237
198
342
1830

Table 2. Numbers related to the efﬁciency of the object detection
methods listed in Table 1. The runtimes for RPN and Fast R-CNN
are reported for a K40 GPU [22]. Our runtime experiment is per-
formed on a GTX 980Ti GPU. The K40 GPU has larger GPU
memory, while the GTX 980Ti has higher clock rate. * indicates
unshared convolutional feature version.

thresholds. Our AZ-net has consistently higher recall than
RPN, and the advantage is larger at higher IoU thresholds.
This suggests our method generates bounding boxes that in
general overlap with the ground truth objects better. The
proposals are also more concentrated around objects, as
shown in Figure 9.

Figure 10 shows a plot of recall as a function of the num-
ber of proposals. A region proposal algorithm is more efﬁ-
cient in covering objects if its area under the curve is larger.
Our experiment suggests that our AZ-Net approach has a
better early recall than RPN. That means our algorithm in
general can recover more objects with the same number of
region proposals.

Figure 11 shows a comparison of recall for objects with
different sizes. The “small object” has an area less than
322, a “medium object” has an area between 322 and 962,
and a “large object” has an area greater than 962, same as
the deﬁnition in MSCOCO [18]. Our approach achieves
higher recall on the small object subset. This is because
when small objects are present in the scene our adaptive
search strategy generates small anchor regions around them,
as shown in Figure 7.

4.3. Efﬁciency of Adaptive Search

Our approach is efﬁcient in runtime, as shown in Table
2. We note that this is achieved even with several severe in-

7

y
c
n
e
u
q
e
r
F

700

600

500

400

300

200

100

0
0

Median: 40

Mean: 62

96% of the
distribution

50
250
150
Number of Evaluated Anchor Regions

200

100

300

Figure 12. Distribution of the number of anchor regions evaluated
on VOC 2007 test set. For most images a few dozen anchor regions
are required. Note that anchors are shared across categories.

efﬁciencies in our implementation. First, for each image
our algorithm requires several rounds of fully connected
layer evaluation, which induces expensive memory trans-
fer between GPU and CPU. Secondly, the Faster R-CNN
approach uses convolutional computation for the evaluation
of anchor regions, which is highly optimized compared to
the RoI pooling technique we adopted. Despite these in-
efﬁciencies, our approach still achieves high accuracy at a
state-of-the-art frame rate, using lower-end hardware. With
improved implementation and model design we expect our
algorithm to be signiﬁcantly faster.

An interesting aspect that highlights the advantages of
our approach is the small number of anchor regions to eval-
uate. To further understand this aspect of our algorithm,
we show in Figure 12 the distribution of anchor regions
evaluated for each image. For most images our method
only requires a few dozen anchor regions. This number is
much smaller than the 2400 anchor regions used in RPN
[22] and the 800 used in MultiBox [5]. Future work could
further capitalize on this advantage by using an expensive
but more accurate per-anchor step, or by exploring applica-
tions to very high-resolution images, for which traditional
non-adaptive approaches will face intrinsic difﬁculties due
to scalability issues. Our experiment also demonstrates the
possibility of designing a class-generic search. Unlike per-
class search methods widely used in previous adaptive ob-
ject detection schemes [3, 28] our anchor regions are shared
among object classes, making it efﬁcient for multi-class de-
tection.

4.4. Results on MSCOCO

We also evaluated our method on MSCOCO dataset and
submitted a “UCSD” entry to the MSCOCO 2015 detection
challenge. Our post-competition work greatly improved ac-
curacy with more training iterations. A comparison with
other recent methods is shown in Table 3. Our model is

8

Method

FRCNN (VGG16) [9]
FRCNN (VGG16) [22]
RPN (VGG16)
RPN (ResNet)
AZ-Net (VGG16)

AP

19.7
19.3
21.9
37.4
22.3

AP IoU=0.50

35.9
39.3
42.7
59.0
41.0

Table 3. The detection mAP on MSCOCO 2015 test-dev set. The
RPN (ResNet) entry won the MSCOCO 2015 detection challenge.
Updated leaderboard can be found in http://mscoco.org.

trained with minibatches consisting of 256 regions sampled
from one image, and 720k iterations in total. The results
for RPN(VGG16) reported in [22] were obtained with an
8-GPU implementation that effectively has 8 and 16 images
per minibatch for RPN and Fast R-CNN respectively, each
trained at 320k training iterations. Despite the much shorter
effective training iterations, our AZ-Net achieves similar
mAP with RPN(VGG16) and is more accurate when eval-
uated on the MSCOCO mAP metric that rewards accurate
localization.

Our best post-competition model is still signiﬁcantly
outperformed by the winning “MSRA” entry. Their ap-
proach is a Faster-R-CNN-style detection pipeline, replac-
ing the VGG-16 network with an ultra-deep architecture
called Deep Residual Network [13]. They also report signif-
icant improvement from using model ensembles and global
contextual information. We note that these developments
are complementary to our contribution.

5. Conclusion and Future Work

This paper has introduced an adaptive object detection
system using adjacency and zoom predictions. Our al-
gorithm adaptively focuses its computational resources on
small regions likely to contain objects, and demonstrates
state-of-the-art accuracy at a fast frame rate.

The current method can be further extended and im-
proved in many aspects. Better pre-trained models [13]
can be incorporated into the current system for even bet-
ter accuracy. Further reﬁning the model to allow single-
pipeline detection that directly predicts class labels, as in
YOLO [21] and the more recent SSD [19] method, could
signiﬁcantly boost testing frame rate. Recent techniques
that improve small object detection, such as the contextual
model and skip layers adopted in Inside-Outside Net [1],
suggest additional promising directions. It is also interest-
ing to consider more aggressive extensions. For instance, it
might be advantageous to use our search structure to focus
high-resolution convolutional layer computation on smaller
regions, especially for very high-resolution images.

Acknowledgment

This work is supported by the National Science Foun-
dation grants CIF-1302438, CCF-1302588 and CNS-
1329819, as well as Xerox UAC, and the Sloan Foundation.

[16] C. H. Lampert, M. B. Blaschko, and T. Hofmann. Efﬁcient
subwindow search: A branch and bound framework for ob-
ject localization. Pattern Analysis and Machine Intelligence,
IEEE Transactions on, 31(12):2129–2142, 2009.

[17] X. Liang, S. Liu, Y. Wei, L. Liu, L. Lin, and S. Yan. To-
wards computational baby learning: A weakly-supervised
approach for object detection.
In The IEEE International
Conference on Computer Vision (ICCV), December 2015.

[18] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona, D. Ra-
manan, P. Doll´ar, and C. L. Zitnick. Microsoft coco: Com-
mon objects in context.
In Computer Vision–ECCV 2014,
pages 740–755. Springer, 2014.

[19] W. Liu, D. Anguelov, D. Erhan, C. Szegedy, and S. Reed.
arXiv preprint

Single shot multibox detector.

Ssd:
arXiv:1512.02325, 2015.

[20] Y. Lu and T. Javidi. Efﬁcient object detection for high reso-
lution images. arXiv preprint arXiv:1510.01257, 2015.
[21] J. Redmon, S. Divvala, R. Girshick, and A. Farhadi. You
only look once: Uniﬁed, real-time object detection. arXiv
preprint arXiv:1506.02640, 2015.

[22] S. Ren, K. He, R. Girshick, and J. Sun. Faster r-cnn: Towards
real-time object detection with region proposal networks. In
C. Cortes, N. D. Lawrence, D. D. Lee, M. Sugiyama, and
R. Garnett, editors, Advances in Neural Information Process-
ing Systems 28, pages 91–99. Curran Associates, Inc., 2015.
[23] K. Simonyan and A. Zisserman. Very deep convolutional
networks for large-scale image recognition. arXiv preprint
arXiv:1409.1556, 2014.

[24] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed,
D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabi-
novich. Going deeper with convolutions. arXiv preprint
arXiv:1409.4842, 2014.

[25] C. Szegedy, A. Toshev, and D. Erhan. Deep neural networks
for object detection. In Advances in Neural Information Pro-
cessing Systems, pages 2553–2561, 2013.

[26] A. Torralba, A. Oliva, M. S. Castelhano, and J. M. Hender-
son. Contextual guidance of eye movements and attention
in real-world scenes:
the role of global features in object
search. Psychological review, 113(4):766, 2006.

[27] J. R. Uijlings, K. E. van de Sande, T. Gevers, and A. W.
Smeulders. Selective search for object recognition. Interna-
tional journal of computer vision, 104(2):154–171, 2013.
[28] D. Yoo, S. Park, J.-Y. Lee, A. S. Paek, and I. So Kweon. At-
tentionnet: Aggregating weak directions for accurate object
detection. In The IEEE International Conference on Com-
puter Vision (ICCV), December 2015.

[29] C. L. Zitnick and P. Doll´ar. Edge boxes: Locating object pro-
posals from edges. In Computer Vision–ECCV 2014, pages
391–405. Springer, 2014.

References

[1] S. Bell, C. L. Zitnick, K. Bala, and R. Girshick.

Inside-
outside net: Detecting objects in context with skip
pooling and recurrent neural networks.
arXiv preprint
arXiv:1512.04143, 2015.

[2] A. Borji and L. Itti. State-of-the-art in visual attention model-
ing. Pattern Analysis and Machine Intelligence, IEEE Trans-
actions on, 35(1):185–207, 2013.

[3] J. C. Caicedo and S. Lazebnik. Active object localization
with deep reinforcement learning. In The IEEE International
Conference on Computer Vision (ICCV), December 2015.
[4] S. K. Divvala, D. Hoiem, J. H. Hays, A. Efros, M. Hebert,
et al. An empirical study of context in object detection.
In Computer Vision and Pattern Recognition, 2009. CVPR
2009. IEEE Conference on, pages 1271–1278. IEEE, 2009.
[5] D. Erhan, C. Szegedy, A. Toshev, and D. Anguelov. Scalable
object detection using deep neural networks.
In Computer
Vision and Pattern Recognition (CVPR), 2014 IEEE Confer-
ence on, pages 2155–2162. IEEE, 2014.

[6] M. Everingham, L. Van Gool, C. K. I. Williams, J. Winn,
and A. Zisserman. The PASCAL Visual Object Classes
Challenge 2007 (VOC2007) Results.
http://www.pascal-
network.org/challenges/VOC/voc2007/workshop/index.html.
[7] M. Everingham, L. Van Gool, C. K. I. Williams, J. Winn,
and A. Zisserman. The PASCAL Visual Object Classes
Challenge 2012 (VOC2012) Results.
http://www.pascal-
network.org/challenges/VOC/voc2012/workshop/index.html.
[8] S. Gidaris and N. Komodakis. Object detection via a multi-
region and semantic segmentation-aware cnn model. In The
IEEE International Conference on Computer Vision (ICCV),
December 2015.

[9] R. Girshick. Fast r-cnn. In The IEEE International Confer-

ence on Computer Vision (ICCV), December 2015.

[10] R. Girshick, J. Donahue, T. Darrell, and J. Malik. Rich fea-
ture hierarchies for accurate object detection and semantic
segmentation. In Computer Vision and Pattern Recognition
(CVPR), 2014 IEEE Conference on, pages 580–587. IEEE,
2014.

[11] A. Gonzalez-Garcia, A. Vezhnevets, and V. Ferrari. An ac-
tive search strategy for efﬁcient object class detection.
In
Proceedings of the IEEE Conference on Computer Vision
and Pattern Recognition, pages 3022–3031, 2015.

[12] K. He, X. Zhang, S. Ren, and J. Sun. Spatial pyramid pool-
ing in deep convolutional networks for visual recognition.
In Computer Vision–ECCV 2014, pages 346–361. Springer,
2014.

[13] K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learn-
ing for image recognition. arXiv preprint arXiv:1512.03385,
2015.

[14] Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long, R. Gir-
shick, S. Guadarrama, and T. Darrell. Caffe: Convolu-
tional architecture for fast feature embedding. arXiv preprint
arXiv:1408.5093, 2014.

[15] A. Krizhevsky, I. Sutskever, and G. E. Hinton.

Imagenet
In
classiﬁcation with deep convolutional neural networks.
Advances in neural information processing systems, pages
1097–1105, 2012.

9

