LightNet: A Versatile, Standalone Matlab-based
Environment for Deep Learning

[Simplify Deep Learning in Hundreds of Lines of Code]

Chengxi Ye, Chen Zhao*, Yezhou Yang, Cornelia Fermüller, Yiannis Aloimonos
Computer Science Department, University of Maryland, College Park, MD 20740, USA.
{cxy, yzyang, fer, yiannis}@umiacs.umd.edu *chenzhao@umd.edu

6
1
0
2
 
g
u
A
 
2
 
 
]

G
L
.
s
c
[
 
 
3
v
6
6
7
2
0
.
5
0
6
1
:
v
i
X
r
a

ABSTRACT
LightNet is a lightweight, versatile, purely Matlab-
based deep learning framework. The idea underlying its
design is to provide an easy-to-understand, easy-to-use and
eﬃcient computational platform for deep learning research.
The implemented framework supports major deep learn-
ing architectures such as Multilayer Perceptron Networks
(MLP), Convolutional Neural Networks (CNN) and Recur-
rent Neural Networks (RNN). The framework also supports
both CPU and GPU computation, and the switch between
them is straightforward. Diﬀerent applications in computer
vision, natural language processing and robotics are demon-
strated as experiments.

Availability: the source code and data is available at:

https://github.com/yechengxi/LightNet

Categories and Subject Descriptors
D.0 [Software]: General; I.2.10 [Artiﬁcial Intelligence]:
Vision and Scene Understanding

Keywords
Computer vision; natural language processing; image un-
derstanding; machine learning; deep learning; convolutional
neural networks; multilayer perceptrons; recurrent neural
networks; reinforcement learning

1.

INTRODUCTION

Deep neural networks

[8] have given rise to major ad-
vancements in many problems of machine intelligence. Most
current implementations of neural network models primarily
emphasize eﬃciency. These pipelines (Table 1) can consist
of a quarter to half a million lines of code and often in-
volve multiple programming languages [5, 13, 2]. It requires
extensive eﬀorts to thoroughly understand and modify the
models. A straightforward and self-explanatory deep learn-
ing framework is highly anticipated to accelerate the under-
standing and application of deep neural network models.

Table 1: Deep Neural Network Packages

Native Models

Language
C++

Framework
Caﬀe
Theano
Torch
TensorFlow
Matconvnet Matlab, C
LightNet

CNN
Python, C MLP/CNN/RNN
Lua, C MLP/CNN/RNN
C++ MLP/CNN/RNN
CNN
Matlab MLP/CNN/RNN

Lines of Code
74,903
148,817
458,650
335,669
43,087
951 (1,762)*

* Lines of code in the core modules and in the whole package.

We present LightNet, a lightweight, versatile, purely
Matlab-based implementation of modern deep neural net-
work models. Succinct and eﬃcient Matlab programming
techniques have been used to implement all the computa-
tional modules. Many popular types of neural networks,
such as multilayer perceptrons, convolutional neural net-
works, and recurrent neural networks are implemented in
LightNet, together with several variations of stochastic gra-
dient descent (SDG) based optimization algorithms.

Since LightNet is implemented solely with Matlab, the
major computations are vectorized and implemented in hun-
dreds of lines of code, orders of magnitude more succinct
than existing pipelines. All fundamental operations can be
easily customized, only basic knowledge of Matlab program-
ming is required. Mathematically oriented researchers can
focus on the mathematical modeling part rather than the
engineering part. Application oriented users can easily un-
derstand and modify any part of the framework to develop
new network architectures and adapt them to new applica-
tions. Aside from its simplicity, LightNet has the following
features: 1. LightNet contains the most modern network
architectures. 2. Applications in computer vision, natural
language processing and reinforcement learning are demon-
strated. 3. LightNet provides a comprehensive collection of
optimization algorithms. 4. LightNet supports straightfor-
ward switching between CPU and GPU computing. 5. Fast
Fourier transforms are used to eﬃciently compute convolu-
tions, and thus large convolution kernels are supported. 6.
LightNet automates hyper-parameter tuning with a novel
Selective-SGD algorithm.

Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
MM ’16 October 15-19, 2016, Amsterdam, Netherlands
c(cid:13) 2016 Copyright held by the owner/author(s).

ACM ISBN 978-1-4503-3603-1/16/10.
DOI: http://dx.doi.org/10.1145/2964284.2973791

2. USING THE PACKAGE

An example of using LightNet can be found in (Fig. 1):
a simple template is provided to start the training process.
The user is required to ﬁll in some critical training parame-
ters, such as the number of training epochs, or the training
method. A Selective-SGD algorithm is provided to facilitate
the selection of an optimal learning rate. The learning rate is

∂z
∂b , which are the gradients that guide the gradient descent
process.

∂z
∂x

=

∂z
∂y

·

∂y
∂x

= f (cid:48)(y)T · W

∂z
∂W

=

∂z
∂y

·

∂y
∂W

= f (cid:48)(y) · xT

∂z
∂b

=

∂z
∂y

·

∂y
∂b

= f (cid:48)(y)

(1)

(2)

(3)

The module adopts extensively optimized Matlab matrix

operations to calculate the matrix-vector products.

3.1.2 Convolutional Layer

1≤i≤Nmap in

A convolutional layer maps Nmap in input feature maps to
Nmap out output feature maps with a multidimensional ﬁlter
bank kio. Each input feature map xi is convolved with the
corresponding ﬁlter bank kio. The convolution results are
summed, and a bias value bo is added, to generate the o-th
output map: yo = (cid:80)
kio ∗ xi+bo. To allow using
large convolution kernels, fast Fourier transforms (FFT) are
used for computing convolutions (and correlations). Accord-
ing to the convolution theorem [10], convolution in the spa-
tial domain is equivalent to point-wise multiplication in the
frequency domain. Therefore, ki ∗ xi can be calculated using
the Fourier transform as: ki ∗ xi = F −1{F{ki} · F{xi}}.
Here, F denotes the Fourier transform and · denotes the
point-wise multiplication operation. The convolution layer
supports both padding and striding.

The mapping from the o-th output feature map to the
network output can be expressed as: z = f (yo). Here f is
the non-linear mapping from the o-th output feature map yo
to the ﬁnal network output. As before (in Sec. 3.1.1), ∂z
,
∂xi
∂z
need to be calculated in the backward process,
∂ki
as follows:

, and ∂z
∂bo

∂z
∂xi

=

∂z
∂yo

·

∂yo
∂xi

= f (cid:48)(yo) (cid:63) ki,

(4)

where (cid:63) denotes the correlation operation. Denoting the
complex conjugate as conj, this correlation is calculated in
the frequency domain using the Fourier transform as: x(cid:63)k =
F −1{F{x} · conj(F{k})}.

=

∂z
∂yo

∂z
∂k∗
io

∂yo
∂k∗
io
where k∗ represents the ﬂipped kernel k. Thus, the gradient
∂z
is calculated by ﬂipping the correlation output. Finally,
∂kio

= f (cid:48)(yo) (cid:63) xi,

(5)

·

∂z
∂bo

=

∂z
∂yo

·

∂yo
∂bo

= 1T · vec(f (cid:48)(yo))

(6)

In words, the gradient ∂z
∂bo
summation of the values in f (cid:48)(yo).

can be calculated by point-wise

3.1.3 Max-pooling Layer

The max pooling layer calculates the largest element in
Pr × Pc windows, with stride size Sr × Sc. A customized
im2col ln function is implemented to convert the stridden
pooling patches into column vectors, to vectorize the pooling
computation in Matlab. The built-in max function is called
on these column vectors to return the pooling result and the
indices of these maximum values. Then, the indices in the

Figure 1: A basic example, which shows how to train
a CNN on the MNIST dataset with LightNet.

selected automatically, and can optionally be adjusted dur-
ing the training. The framework supports both GPU and
CPU computation, through the opts.use gpu option. Two
additional functions are provided to prepare the training
data and initialize the network structure. Every experiment
in this paper can reproduced by running the related script
ﬁle. More details can be found on the project webpage.

3. BUILDING BLOCKS

The primary computational module includes a feed for-
ward process and a backward/back propagation process. The
feed forward process evaluates the model, and the back prop-
agation reports the network gradients. Stochastic gradient
descent based algorithms are used to optimize the model
parameters.

3.1 Core Computational Modules

LightNet allows us to focus on the mathematical modeling
of the network, rather than low-level engineering details. To
make this paper self-contained, we explain the main com-
putational modules of LightNet. All networks ( and related
experiments) in this paper are built with these modules. The
notations below are chosen for simplicity. Readers can easily
extend the derivations to the mini-batch setting.

3.1.1 Linear Perceptron Layer

A linear perceptron layer can be expressed as: y = W x+b.
Here, x denotes the input data of size input dim × 1, W
denotes the weight matrix of size output dim × input dim,
b is a bias vector of size output dim × 1, and y denotes the
linear layer output of size output dim × 1.

The mapping from the input of the linear perceptron to
the ﬁnal network output can be expressed as: z = f (y) =
f (W x + b), where f is a non-linear function that represents
the network’s computation in the deeper layers, and z is the
network output, which is usually a loss value.

The backward process calculates the derivative ∂z

is the derivative passing to the shallower layers, and ∂z

∂x , which
∂W ,

original batched data are recovered accordingly. Also, zero
padding can be applied to the input data.

Without the loss of generality, the mapping from the max-
pooling layer input to the ﬁnal network output can be ex-
pressed as: z = f (y) = f (Sx), where S is a selection matrix,
and x is a column vector which denotes the input data in
this layer.

In the backward process, ∂z
∂x = ∂z

the shallower layers: ∂z

∂x is calculated and passed to
∂y · S = f (cid:48)(y)T S.

When the pooling range is less than or equal to the stride
size, ∂z
∂x can be calculated with simple matrix indexing tech-
niques in Matlab. Speciﬁcally, an empty tensor dzdx of the
same size with the input data is created. dzdx(f rom) =
dzdy, where f rom is the pooling indices, and dzdy is a ten-
sor recording the pooling results. When the pooling range
is larger than the stride size, each entry in x can be pooled
multiple times, and the back propagation gradients need to
be accumulated for each of these multiple-pooled entries. In
this case, the ∂z
∂x is calculated using the Matlab function:
accumarray().

3.1.4 Rectiﬁed Linear Unit

The rectiﬁed linear unit (ReLU ) is implemented as a ma-
jor non-linear mapping function, some other functions in-
cluding sigmoid and tanh are omitted from the discussion
here. The ReLU function is the identity function if the input
is larger than 0 and outputs 0 otherwise: y = relu(x) = x ·
ind(x > 0). In the backward process, the gradient is passed
to the shallower layer if the input data is non-negative. Oth-
erwise, the gradient is ignored.

3.2 Loss function

Usually, a loss function is connected to the outputs of the
deepest core computation module. Currently, LightNet sup-
ports the softmax log-loss function for classiﬁcation tasks.

3.3 Optimization Algorithms

Stochastic gradient descent (SGD) algorithm based op-
timization algorithms are the primary tools to train deep
neural networks. The standard SGD algorithm and several
of its popular variants such as Adagrad [3], RMSProp [12]
and Adam [6] are also implemented for deep learning re-
search. It is worth mentioning that we implement a novel
Selective-SGD algorithm to facilitate the selection of hyper-
parameters, especially the learning rate. This algorithm se-
lects the most eﬃcient learning rate by running the SGD
process for a few iterations using each learning rate from a
discrete candidate set. During the middle of the neural net
training, the Selective-SGD algorithm can also be applied to
select diﬀerent learning rates to accelerate the energy decay.

4. EXPERIMENTS

4.1 Multilayer Perceptron Network

A multilayer perceptron network is constructed to test
the performance of LightNet on MNIST data [9]. The net-
work takes 28 × 28 inputs from the MNIST image dataset
and has 128 nodes respectively in the next two layers. The
128-dimensional features are then connected to 10 nodes to
calculate the softmax output. See Fig. 2 for the experiment
results.

4.2 Convolutional Neural Network

(a)

(b)

Figure 2: Loss and error rates during training
and testing phases using LightNet on the MNIST
dataset.

(a)

(b)

Figure 3: Loss and error rates of training and testing
with LightNet on the CIFAR-10 dataset.

LightNet supports using state-of-the-art convolutional net-
work models pretrained on the ImageNet dataset.
It also
supports training novel network models from scratch. A con-
volutional network with 4 convolution layers is constructed
to test the performance of LightNet on CIFAR-10 data [7].
There are 32, 32, 64, 64 convolution kernels of size 5 × 5 in
the ﬁrst three layers, the last layer has kernel size 4 × 4.
relu functions are applied after each convolution layer as
the non-linear mapping function. LightNet automatically
selects and adjusts the learning rate and can achieve state-
of-the-art accuracy with this architecture. Selective-SGD
leads to better accuracy compared with standard SGD with
a ﬁxed learning rate. Most importantly, using Selective-SGD
avoids manual tuning of the learning rate. See Fig. 3 for the
experiment results. The computations are carried out on a
desktop computer with an Intel i5 6600K CPU and a Nvidia
Titan X GPU with 12GB memory. The current version of
LightNet can process 750 images per second with this net-
work structure on the GPU, around 5× faster than using
CPU.

4.3 LSTM Network

The Long Short Term Memory (LSTM)

[4] is a popu-
lar recurrent neural network model. Because of LightNet’s
versatility, the LSTM network can be implemented in the
LightNet package as a particular application. Notably, the
core computational modules in LightNet are used to per-
form time domain forward process and back propagation for
LSTM.

The forward process in an LSTM model can be formulated

∂z
∂cs−1

=

∂z
∂cs

∂cs
∂cs−1

+

∂zs−1
∂cs−1

.

(13)

[3] Duchi, J., Hazan, E., and Singer, Y. Adaptive

as:

it = sigmoid(Wihht−1 + Wixxt + bi),

ot = sigmoid(Wohht−1 + Woxxt + bo),

ft = sigmoid(Wf hht−1 + Wf xxt + bf ),

(7)

(8)

(9)

gt = tanh(Wghht−1 + Wgxxt + bg),

(10)

ct = ft (cid:12) ct−1 + it (cid:12) gt, ht = ot (cid:12) tanh(ct),

(11)

zt = f (ht), z =

zt.

(12)

T
(cid:88)

t=1

Where it/ot/ft denotes the response of the input/output/forget

gate at time t. gt denotes the distorted input to the memory
cell at time t. ct denotes the content of the memory cell at
time t. ht denotes the hidden node value. f maps the hidden
nodes to the network loss zt at time t. The full network loss
is calculated by summing the loss at each individual time
frame in Eq. 12.

To optimize the LSTM model, back propagation through
time is implemented and the most critical value to calculate
in LSTM is: ∂z
.
∂cs

A critical iterative property is adopted to calculate the

= (cid:80)T

∂zt
∂cs

t=s

above value:

A few other gradients can be calculated through the chain

rule using the above calculation output:

∂zt
∂ot

=

∂zt
∂ht

∂ht
∂ot

,

∂z
∂{i, f, g}t

=

∂z
∂ct

∂ct
∂{i, f, g}t

.

(14)

The LSTM network is tested on a character language mod-
eling task. The dataset consists of 20, 000 sentences selected
from works of Shakespeare. Each sentence is broken into 67
characters (and punctuation marks), and the LSTM model is
deployed to predict the next character based on the charac-
ters before. 30 hidden nodes are used in the network model
and RMSProp is used for the training. After 10 epochs,
the prediction accuracy of the next character is improved to
70%.

4.4 Q-Network

As an application in reinforcement learning, We created
a Q-Network [11] with the MLP network. The Q-Network
is then applied to the classic Cart-Pole problem [1]. The
dynamics of the Cart-Pole system can be learned with a two-
layer network in hundreds of iterations. One iteration of the
update process of the Q-Network is:

Qnew(stateold, act) = reward+γQcurrent(statenew, actbest)

= reward + γmaxaQcurrent(statenew, a)

= reward + γV (statenew).

(15)

The action is randomly selected with probability epsilon,
otherwise the action leading to the highest score is selected.
The desired network output Qnew is calculated using the
observed reward and the discounted value γV (statenew) of
the resulting state, predicted by the current network through
Eq. 15.

By using a least squared loss function:

z = (y − Qcurrent(stateold, act))2
= (Qnew(stateold, act) − Qcurrent(stateold, act))2,

the Q-Network can be optimized using the gradient:

∂z
∂θ

=

∂z
∂Qcurrent

∂Qcurrent
∂θ

.

Here θ denotes the parameters in the Q-Network.

(16)

(17)

5. CONCLUSION

LightNet provides an easy-to-expand ecosystem for the
understanding and development of deep neural network mod-
els. Thanks to its user-friendly Matlab based environment,
the whole computational process can be easily tracked and
visualized. This set of the main features can provide unique
convenience to the deep learning research community.

6. REFERENCES
[1] Barto, A. G., Sutton, R. S., and Anderson, C. W.
Neuronlike adaptive elements that can solve diﬃcult
learning control problems. Systems, Man and Cybernetics,
IEEE Transactions on, 5 (1983), 834–846.

[2] Bastien, F., Lamblin, P., Pascanu, R., Bergstra, J.,

Goodfellow, I., Bergeron, A., Bouchard, N.,
Warde-Farley, D., and Bengio, Y. Theano: new features
and speed improvements. arXiv preprint arXiv:1211.5590
(2012).

subgradient methods for online learning and stochastic
optimization. The Journal of Machine Learning Research
12 (2011), 2121–2159.

[4] Hochreiter, S., and Schmidhuber, J. Long short-term
memory. Neural computation 9, 8 (1997), 1735–1780.
[5] Jia, Y., Shelhamer, E., Donahue, J., Karayev, S.,

Long, J., Girshick, R., Guadarrama, S., and Darrell,
T. Caﬀe: Convolutional architecture for fast feature
embedding. In Proceedings of the ACM International
Conference on Multimedia (2014), ACM, pp. 675–678.
[6] Kingma, D., and Ba, J. Adam: A method for stochastic
optimization. arXiv preprint arXiv:1412.6980 (2014).
[7] Krizhevsky, A., and Hinton, G. Learning multiple layers

of features from tiny images, 2009.

[8] Krizhevsky, A., Sutskever, I., and Hinton, G. E.
Imagenet classiﬁcation with deep convolutional neural
networks. In Advances in neural information processing
systems (2012), pp. 1097–1105.

[9] LeCun, Y., Bottou, L., Bengio, Y., and Haffner, P.
Gradient-based learning applied to document recognition.
Proceedings of the IEEE 86, 11 (1998), 2278–2324.

[10] Mallat, S. A wavelet tour of signal processing: the sparse

way. Academic press, 2008.

[11] Mnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A.,

Veness, J., Bellemare, M. G., Graves, A., Riedmiller,
M., Fidjeland, A. K., Ostrovski, G., et al. Human-level
control through deep reinforcement learning. Nature 518,
7540 (2015), 529–533.

[12] Tieleman, T., and Hinton, G. Lecture 6.5-rmsprop:
Divide the gradient by a running average of its recent
magnitude. COURSERA: Neural Networks for Machine
Learning 4 (2012), 2.

[13] Vedaldi, A., and Lenc, K. Matconvnet: Convolutional

neural networks for matlab. In Proceedings of the 23rd
Annual ACM Conference on Multimedia Conference
(2015), ACM, pp. 689–692.

LightNet: A Versatile, Standalone Matlab-based
Environment for Deep Learning

[Simplify Deep Learning in Hundreds of Lines of Code]

Chengxi Ye, Chen Zhao*, Yezhou Yang, Cornelia Fermüller, Yiannis Aloimonos
Computer Science Department, University of Maryland, College Park, MD 20740, USA.
{cxy, yzyang, fer, yiannis}@umiacs.umd.edu *chenzhao@umd.edu

6
1
0
2
 
g
u
A
 
2
 
 
]

G
L
.
s
c
[
 
 
3
v
6
6
7
2
0
.
5
0
6
1
:
v
i
X
r
a

ABSTRACT
LightNet is a lightweight, versatile, purely Matlab-
based deep learning framework. The idea underlying its
design is to provide an easy-to-understand, easy-to-use and
eﬃcient computational platform for deep learning research.
The implemented framework supports major deep learn-
ing architectures such as Multilayer Perceptron Networks
(MLP), Convolutional Neural Networks (CNN) and Recur-
rent Neural Networks (RNN). The framework also supports
both CPU and GPU computation, and the switch between
them is straightforward. Diﬀerent applications in computer
vision, natural language processing and robotics are demon-
strated as experiments.

Availability: the source code and data is available at:

https://github.com/yechengxi/LightNet

Categories and Subject Descriptors
D.0 [Software]: General; I.2.10 [Artiﬁcial Intelligence]:
Vision and Scene Understanding

Keywords
Computer vision; natural language processing; image un-
derstanding; machine learning; deep learning; convolutional
neural networks; multilayer perceptrons; recurrent neural
networks; reinforcement learning

1.

INTRODUCTION

Deep neural networks

[8] have given rise to major ad-
vancements in many problems of machine intelligence. Most
current implementations of neural network models primarily
emphasize eﬃciency. These pipelines (Table 1) can consist
of a quarter to half a million lines of code and often in-
volve multiple programming languages [5, 13, 2]. It requires
extensive eﬀorts to thoroughly understand and modify the
models. A straightforward and self-explanatory deep learn-
ing framework is highly anticipated to accelerate the under-
standing and application of deep neural network models.

Table 1: Deep Neural Network Packages

Native Models

Language
C++

Framework
Caﬀe
Theano
Torch
TensorFlow
Matconvnet Matlab, C
LightNet

CNN
Python, C MLP/CNN/RNN
Lua, C MLP/CNN/RNN
C++ MLP/CNN/RNN
CNN
Matlab MLP/CNN/RNN

Lines of Code
74,903
148,817
458,650
335,669
43,087
951 (1,762)*

* Lines of code in the core modules and in the whole package.

We present LightNet, a lightweight, versatile, purely
Matlab-based implementation of modern deep neural net-
work models. Succinct and eﬃcient Matlab programming
techniques have been used to implement all the computa-
tional modules. Many popular types of neural networks,
such as multilayer perceptrons, convolutional neural net-
works, and recurrent neural networks are implemented in
LightNet, together with several variations of stochastic gra-
dient descent (SDG) based optimization algorithms.

Since LightNet is implemented solely with Matlab, the
major computations are vectorized and implemented in hun-
dreds of lines of code, orders of magnitude more succinct
than existing pipelines. All fundamental operations can be
easily customized, only basic knowledge of Matlab program-
ming is required. Mathematically oriented researchers can
focus on the mathematical modeling part rather than the
engineering part. Application oriented users can easily un-
derstand and modify any part of the framework to develop
new network architectures and adapt them to new applica-
tions. Aside from its simplicity, LightNet has the following
features: 1. LightNet contains the most modern network
architectures. 2. Applications in computer vision, natural
language processing and reinforcement learning are demon-
strated. 3. LightNet provides a comprehensive collection of
optimization algorithms. 4. LightNet supports straightfor-
ward switching between CPU and GPU computing. 5. Fast
Fourier transforms are used to eﬃciently compute convolu-
tions, and thus large convolution kernels are supported. 6.
LightNet automates hyper-parameter tuning with a novel
Selective-SGD algorithm.

Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
MM ’16 October 15-19, 2016, Amsterdam, Netherlands
c(cid:13) 2016 Copyright held by the owner/author(s).

ACM ISBN 978-1-4503-3603-1/16/10.
DOI: http://dx.doi.org/10.1145/2964284.2973791

2. USING THE PACKAGE

An example of using LightNet can be found in (Fig. 1):
a simple template is provided to start the training process.
The user is required to ﬁll in some critical training parame-
ters, such as the number of training epochs, or the training
method. A Selective-SGD algorithm is provided to facilitate
the selection of an optimal learning rate. The learning rate is

∂z
∂b , which are the gradients that guide the gradient descent
process.

∂z
∂x

=

∂z
∂y

·

∂y
∂x

= f (cid:48)(y)T · W

∂z
∂W

=

∂z
∂y

·

∂y
∂W

= f (cid:48)(y) · xT

∂z
∂b

=

∂z
∂y

·

∂y
∂b

= f (cid:48)(y)

(1)

(2)

(3)

The module adopts extensively optimized Matlab matrix

operations to calculate the matrix-vector products.

3.1.2 Convolutional Layer

1≤i≤Nmap in

A convolutional layer maps Nmap in input feature maps to
Nmap out output feature maps with a multidimensional ﬁlter
bank kio. Each input feature map xi is convolved with the
corresponding ﬁlter bank kio. The convolution results are
summed, and a bias value bo is added, to generate the o-th
output map: yo = (cid:80)
kio ∗ xi+bo. To allow using
large convolution kernels, fast Fourier transforms (FFT) are
used for computing convolutions (and correlations). Accord-
ing to the convolution theorem [10], convolution in the spa-
tial domain is equivalent to point-wise multiplication in the
frequency domain. Therefore, ki ∗ xi can be calculated using
the Fourier transform as: ki ∗ xi = F −1{F{ki} · F{xi}}.
Here, F denotes the Fourier transform and · denotes the
point-wise multiplication operation. The convolution layer
supports both padding and striding.

The mapping from the o-th output feature map to the
network output can be expressed as: z = f (yo). Here f is
the non-linear mapping from the o-th output feature map yo
to the ﬁnal network output. As before (in Sec. 3.1.1), ∂z
,
∂xi
∂z
need to be calculated in the backward process,
∂ki
as follows:

, and ∂z
∂bo

∂z
∂xi

=

∂z
∂yo

·

∂yo
∂xi

= f (cid:48)(yo) (cid:63) ki,

(4)

where (cid:63) denotes the correlation operation. Denoting the
complex conjugate as conj, this correlation is calculated in
the frequency domain using the Fourier transform as: x(cid:63)k =
F −1{F{x} · conj(F{k})}.

=

∂z
∂yo

∂z
∂k∗
io

∂yo
∂k∗
io
where k∗ represents the ﬂipped kernel k. Thus, the gradient
∂z
is calculated by ﬂipping the correlation output. Finally,
∂kio

= f (cid:48)(yo) (cid:63) xi,

(5)

·

∂z
∂bo

=

∂z
∂yo

·

∂yo
∂bo

= 1T · vec(f (cid:48)(yo))

(6)

In words, the gradient ∂z
∂bo
summation of the values in f (cid:48)(yo).

can be calculated by point-wise

3.1.3 Max-pooling Layer

The max pooling layer calculates the largest element in
Pr × Pc windows, with stride size Sr × Sc. A customized
im2col ln function is implemented to convert the stridden
pooling patches into column vectors, to vectorize the pooling
computation in Matlab. The built-in max function is called
on these column vectors to return the pooling result and the
indices of these maximum values. Then, the indices in the

Figure 1: A basic example, which shows how to train
a CNN on the MNIST dataset with LightNet.

selected automatically, and can optionally be adjusted dur-
ing the training. The framework supports both GPU and
CPU computation, through the opts.use gpu option. Two
additional functions are provided to prepare the training
data and initialize the network structure. Every experiment
in this paper can reproduced by running the related script
ﬁle. More details can be found on the project webpage.

3. BUILDING BLOCKS

The primary computational module includes a feed for-
ward process and a backward/back propagation process. The
feed forward process evaluates the model, and the back prop-
agation reports the network gradients. Stochastic gradient
descent based algorithms are used to optimize the model
parameters.

3.1 Core Computational Modules

LightNet allows us to focus on the mathematical modeling
of the network, rather than low-level engineering details. To
make this paper self-contained, we explain the main com-
putational modules of LightNet. All networks ( and related
experiments) in this paper are built with these modules. The
notations below are chosen for simplicity. Readers can easily
extend the derivations to the mini-batch setting.

3.1.1 Linear Perceptron Layer

A linear perceptron layer can be expressed as: y = W x+b.
Here, x denotes the input data of size input dim × 1, W
denotes the weight matrix of size output dim × input dim,
b is a bias vector of size output dim × 1, and y denotes the
linear layer output of size output dim × 1.

The mapping from the input of the linear perceptron to
the ﬁnal network output can be expressed as: z = f (y) =
f (W x + b), where f is a non-linear function that represents
the network’s computation in the deeper layers, and z is the
network output, which is usually a loss value.

The backward process calculates the derivative ∂z

is the derivative passing to the shallower layers, and ∂z

∂x , which
∂W ,

original batched data are recovered accordingly. Also, zero
padding can be applied to the input data.

Without the loss of generality, the mapping from the max-
pooling layer input to the ﬁnal network output can be ex-
pressed as: z = f (y) = f (Sx), where S is a selection matrix,
and x is a column vector which denotes the input data in
this layer.

In the backward process, ∂z
∂x = ∂z

the shallower layers: ∂z

∂x is calculated and passed to
∂y · S = f (cid:48)(y)T S.

When the pooling range is less than or equal to the stride
size, ∂z
∂x can be calculated with simple matrix indexing tech-
niques in Matlab. Speciﬁcally, an empty tensor dzdx of the
same size with the input data is created. dzdx(f rom) =
dzdy, where f rom is the pooling indices, and dzdy is a ten-
sor recording the pooling results. When the pooling range
is larger than the stride size, each entry in x can be pooled
multiple times, and the back propagation gradients need to
be accumulated for each of these multiple-pooled entries. In
this case, the ∂z
∂x is calculated using the Matlab function:
accumarray().

3.1.4 Rectiﬁed Linear Unit

The rectiﬁed linear unit (ReLU ) is implemented as a ma-
jor non-linear mapping function, some other functions in-
cluding sigmoid and tanh are omitted from the discussion
here. The ReLU function is the identity function if the input
is larger than 0 and outputs 0 otherwise: y = relu(x) = x ·
ind(x > 0). In the backward process, the gradient is passed
to the shallower layer if the input data is non-negative. Oth-
erwise, the gradient is ignored.

3.2 Loss function

Usually, a loss function is connected to the outputs of the
deepest core computation module. Currently, LightNet sup-
ports the softmax log-loss function for classiﬁcation tasks.

3.3 Optimization Algorithms

Stochastic gradient descent (SGD) algorithm based op-
timization algorithms are the primary tools to train deep
neural networks. The standard SGD algorithm and several
of its popular variants such as Adagrad [3], RMSProp [12]
and Adam [6] are also implemented for deep learning re-
search. It is worth mentioning that we implement a novel
Selective-SGD algorithm to facilitate the selection of hyper-
parameters, especially the learning rate. This algorithm se-
lects the most eﬃcient learning rate by running the SGD
process for a few iterations using each learning rate from a
discrete candidate set. During the middle of the neural net
training, the Selective-SGD algorithm can also be applied to
select diﬀerent learning rates to accelerate the energy decay.

4. EXPERIMENTS

4.1 Multilayer Perceptron Network

A multilayer perceptron network is constructed to test
the performance of LightNet on MNIST data [9]. The net-
work takes 28 × 28 inputs from the MNIST image dataset
and has 128 nodes respectively in the next two layers. The
128-dimensional features are then connected to 10 nodes to
calculate the softmax output. See Fig. 2 for the experiment
results.

4.2 Convolutional Neural Network

(a)

(b)

Figure 2: Loss and error rates during training
and testing phases using LightNet on the MNIST
dataset.

(a)

(b)

Figure 3: Loss and error rates of training and testing
with LightNet on the CIFAR-10 dataset.

LightNet supports using state-of-the-art convolutional net-
work models pretrained on the ImageNet dataset.
It also
supports training novel network models from scratch. A con-
volutional network with 4 convolution layers is constructed
to test the performance of LightNet on CIFAR-10 data [7].
There are 32, 32, 64, 64 convolution kernels of size 5 × 5 in
the ﬁrst three layers, the last layer has kernel size 4 × 4.
relu functions are applied after each convolution layer as
the non-linear mapping function. LightNet automatically
selects and adjusts the learning rate and can achieve state-
of-the-art accuracy with this architecture. Selective-SGD
leads to better accuracy compared with standard SGD with
a ﬁxed learning rate. Most importantly, using Selective-SGD
avoids manual tuning of the learning rate. See Fig. 3 for the
experiment results. The computations are carried out on a
desktop computer with an Intel i5 6600K CPU and a Nvidia
Titan X GPU with 12GB memory. The current version of
LightNet can process 750 images per second with this net-
work structure on the GPU, around 5× faster than using
CPU.

4.3 LSTM Network

The Long Short Term Memory (LSTM)

[4] is a popu-
lar recurrent neural network model. Because of LightNet’s
versatility, the LSTM network can be implemented in the
LightNet package as a particular application. Notably, the
core computational modules in LightNet are used to per-
form time domain forward process and back propagation for
LSTM.

The forward process in an LSTM model can be formulated

∂z
∂cs−1

=

∂z
∂cs

∂cs
∂cs−1

+

∂zs−1
∂cs−1

.

(13)

[3] Duchi, J., Hazan, E., and Singer, Y. Adaptive

as:

it = sigmoid(Wihht−1 + Wixxt + bi),

ot = sigmoid(Wohht−1 + Woxxt + bo),

ft = sigmoid(Wf hht−1 + Wf xxt + bf ),

(7)

(8)

(9)

gt = tanh(Wghht−1 + Wgxxt + bg),

(10)

ct = ft (cid:12) ct−1 + it (cid:12) gt, ht = ot (cid:12) tanh(ct),

(11)

zt = f (ht), z =

zt.

(12)

T
(cid:88)

t=1

Where it/ot/ft denotes the response of the input/output/forget

gate at time t. gt denotes the distorted input to the memory
cell at time t. ct denotes the content of the memory cell at
time t. ht denotes the hidden node value. f maps the hidden
nodes to the network loss zt at time t. The full network loss
is calculated by summing the loss at each individual time
frame in Eq. 12.

To optimize the LSTM model, back propagation through
time is implemented and the most critical value to calculate
in LSTM is: ∂z
.
∂cs

A critical iterative property is adopted to calculate the

= (cid:80)T

∂zt
∂cs

t=s

above value:

A few other gradients can be calculated through the chain

rule using the above calculation output:

∂zt
∂ot

=

∂zt
∂ht

∂ht
∂ot

,

∂z
∂{i, f, g}t

=

∂z
∂ct

∂ct
∂{i, f, g}t

.

(14)

The LSTM network is tested on a character language mod-
eling task. The dataset consists of 20, 000 sentences selected
from works of Shakespeare. Each sentence is broken into 67
characters (and punctuation marks), and the LSTM model is
deployed to predict the next character based on the charac-
ters before. 30 hidden nodes are used in the network model
and RMSProp is used for the training. After 10 epochs,
the prediction accuracy of the next character is improved to
70%.

4.4 Q-Network

As an application in reinforcement learning, We created
a Q-Network [11] with the MLP network. The Q-Network
is then applied to the classic Cart-Pole problem [1]. The
dynamics of the Cart-Pole system can be learned with a two-
layer network in hundreds of iterations. One iteration of the
update process of the Q-Network is:

Qnew(stateold, act) = reward+γQcurrent(statenew, actbest)

= reward + γmaxaQcurrent(statenew, a)

= reward + γV (statenew).

(15)

The action is randomly selected with probability epsilon,
otherwise the action leading to the highest score is selected.
The desired network output Qnew is calculated using the
observed reward and the discounted value γV (statenew) of
the resulting state, predicted by the current network through
Eq. 15.

By using a least squared loss function:

z = (y − Qcurrent(stateold, act))2
= (Qnew(stateold, act) − Qcurrent(stateold, act))2,

the Q-Network can be optimized using the gradient:

∂z
∂θ

=

∂z
∂Qcurrent

∂Qcurrent
∂θ

.

Here θ denotes the parameters in the Q-Network.

(16)

(17)

5. CONCLUSION

LightNet provides an easy-to-expand ecosystem for the
understanding and development of deep neural network mod-
els. Thanks to its user-friendly Matlab based environment,
the whole computational process can be easily tracked and
visualized. This set of the main features can provide unique
convenience to the deep learning research community.

6. REFERENCES
[1] Barto, A. G., Sutton, R. S., and Anderson, C. W.
Neuronlike adaptive elements that can solve diﬃcult
learning control problems. Systems, Man and Cybernetics,
IEEE Transactions on, 5 (1983), 834–846.

[2] Bastien, F., Lamblin, P., Pascanu, R., Bergstra, J.,

Goodfellow, I., Bergeron, A., Bouchard, N.,
Warde-Farley, D., and Bengio, Y. Theano: new features
and speed improvements. arXiv preprint arXiv:1211.5590
(2012).

subgradient methods for online learning and stochastic
optimization. The Journal of Machine Learning Research
12 (2011), 2121–2159.

[4] Hochreiter, S., and Schmidhuber, J. Long short-term
memory. Neural computation 9, 8 (1997), 1735–1780.
[5] Jia, Y., Shelhamer, E., Donahue, J., Karayev, S.,

Long, J., Girshick, R., Guadarrama, S., and Darrell,
T. Caﬀe: Convolutional architecture for fast feature
embedding. In Proceedings of the ACM International
Conference on Multimedia (2014), ACM, pp. 675–678.
[6] Kingma, D., and Ba, J. Adam: A method for stochastic
optimization. arXiv preprint arXiv:1412.6980 (2014).
[7] Krizhevsky, A., and Hinton, G. Learning multiple layers

of features from tiny images, 2009.

[8] Krizhevsky, A., Sutskever, I., and Hinton, G. E.
Imagenet classiﬁcation with deep convolutional neural
networks. In Advances in neural information processing
systems (2012), pp. 1097–1105.

[9] LeCun, Y., Bottou, L., Bengio, Y., and Haffner, P.
Gradient-based learning applied to document recognition.
Proceedings of the IEEE 86, 11 (1998), 2278–2324.

[10] Mallat, S. A wavelet tour of signal processing: the sparse

way. Academic press, 2008.

[11] Mnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A.,

Veness, J., Bellemare, M. G., Graves, A., Riedmiller,
M., Fidjeland, A. K., Ostrovski, G., et al. Human-level
control through deep reinforcement learning. Nature 518,
7540 (2015), 529–533.

[12] Tieleman, T., and Hinton, G. Lecture 6.5-rmsprop:
Divide the gradient by a running average of its recent
magnitude. COURSERA: Neural Networks for Machine
Learning 4 (2012), 2.

[13] Vedaldi, A., and Lenc, K. Matconvnet: Convolutional

neural networks for matlab. In Proceedings of the 23rd
Annual ACM Conference on Multimedia Conference
(2015), ACM, pp. 689–692.

