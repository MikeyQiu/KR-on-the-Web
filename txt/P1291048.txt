Spatial Memory for Context Reasoning in Object Detection

Xinlei Chen

Abhinav Gupta

School of Computer Science, Carnegie Mellon University
{xinleic,abhinavg}@cs.cmu.edu

7
1
0
2
 
r
p
A
 
3
1
 
 
]

V
C
.
s
c
[
 
 
1
v
4
2
2
4
0
.
4
0
7
1
:
v
i
X
r
a

Abstract

Modeling instance-level context and object-object rela-
tionships is extremely challenging.
It requires reasoning
about bounding boxes of different classes, locations etc.
Above all, instance-level spatial reasoning inherently re-
quires modeling conditional distributions on previous de-
tections. Unfortunately, our current object detection sys-
tems do not have any memory to remember what to con-
dition on! The state-of-the-art object detectors still detect
all object in parallel followed by non-maximal suppression
(NMS). While memory has been used for tasks such as cap-
tioning, they mostly use image-level memory cells without
capturing the spatial layout. On the other hand, model-
ing object-object relationships requires spatial reasoning –
not only do we need a memory to store the spatial layout,
but also a effective reasoning module to extract spatial pat-
terns. This paper presents a conceptually simple yet power-
ful solution – Spatial Memory Network (SMN), to model the
instance-level context efﬁciently and effectively. Our spatial
memory essentially assembles object instances back into a
pseudo “image” representation that is easy to be fed into
another ConvNet for object-object context reasoning. This
leads to a new sequential reasoning architecture where im-
age and memory are processed in parallel to obtain detec-
tions which update the memory again. We show our SMN
direction is promising as it provides 2.2% improvement over
baseline Faster RCNN on the COCO dataset so far.

Figure 1: Evidence of image-level context reasoning inside
ConvNets. All examples are from our baseline faster RCNN
detector with VGG16 conv5 3 features on COCO [52].
Numbers are class conﬁdences. Top and bottom left: three
examples where the ConvNet is able to detect tiny and
simple-shaped objects much smaller than the receptive ﬁeld
size. Bottom right: a false positive detection for person
given the seat on a passenger train. Our Spatial Memory
Network takes advantage of this power by encoding multi-
ple object instances into a “pseudo” image representation.

1. Introduction

Context helps image understanding! Apart from strong
psychological evidence [4, 37, 64, 65] that context is vital
for humans to recognize objects, many empirical studies in
the computer vision community [10, 11, 16, 22, 23, 43, 60,
62, 73, 82, 83] have also suggested that recognition algo-
rithms can be improved by proper modeling of context.

But what is the right model for context? Consider the
problem of object detection. There are two common mod-
els of context often used in the community. The ﬁrst type
of model incorporates image or scene level context [5, 36,

46, 58, 63, 74, 81]. The second type models object-object
relationships at instance-level [15, 27, 32, 58, 67, 94]. Take
the the top-left image of Fig. 1 as an example, both the per-
son and the tennis racket can be used to create a contextual
prior on where the ball should be.

Of these two models, which one is more effective for
modeling context? A quick glimpse on the current state-
of-the-art approaches, the idea of single region classiﬁca-
tion [40, 49, 51, 53, 69] with deep ConvNets [33, 76] is
still dominating object detection. On the surface, these ap-
proaches hardly use any contextual reasoning; but we be-

1

lieve the large receptive ﬁelds of the neurons in fact do in-
corporate image-level context (See Fig. 1 for evidences).
On the other hand, there has been little or no success in
modeling object-object relationships or instance-level con-
text in recent years.

Why so? Arguably, modeling the instance-level context
is more challenging. Instance-level reasoning for object de-
tection would have to tackle bounding boxes pairs or groups
in different classes, locations, scales, aspect ratios, etc.
Moreover, for modeling image-level context, the grid struc-
ture of pixels allows the number of contextual inputs to be
reduced efﬁciently (e.g. to a local neighborhood [11, 43, 73]
or a smaller scale [76, 87]), whereas such reductions for
arbitrary instances appear to be not so trivial. Above all,
instance-level spatial reasoning inherently requires model-
ing conditional distributions on previous detections, but our
current object detection systems do not have any memory to
remember what to condition on! Even in the case of multi-
class object detection, the joint layout [15] is estimated by
detecting all objects in parallel followed by non-maximal
suppression (NMS) [20]. What we need is an object detec-
tion system with memory built inside it!

Memory has been successfully used in the recognition
community recently for tasks such as captioning [13, 17,
59, 84, 85, 92] or visual question answering [2, 3, 24, 44,
55, 57, 72, 90, 91, 93, 97]. However, these works mostly fo-
cus on modeling an image-level memory, without capturing
the spatial layout of the understanding so far. On the other
hand, modeling object-object relationships requires spatial
reasoning – not only do we need a memory to store the spa-
tial layout, but also a suitable reasoning module to extract
spatial patterns. This paper presents a conceptually simple
yet powerful solution – Spatial Memory Network (SMN), to
model the instance-level context efﬁciently and effectively.
Our key insight is that the best spatial reasoning module
is a ConvNet itself!
In fact, we argue that ConvNets are
actually the most generic1 and effective framework for ex-
tracting spatial and contextual information so far! Inspired
by this observation, our spatial memory essentially assem-
bles object instances back into a pseudo “image” represen-
tation that is easy to be fed into another ConvNet to perform
object-object context reasoning.

However, if ConvNets are already so excellent at mod-
eling context, why would we even bother something else?
Isn’t the image itself the ultimate source of information and
therefore the best form of “spatial memory”? Given an im-
age, shouldn’t an ultra-deep network already take care of the
full reasoning inside its architecture? In spite of these valid
concerns, we argue that a spatial memory still presents as
an important next step for object detection and other related
tasks, for the following reasons:

1Many context models can be built or formulated as ConvNets [89, 96].

• First, we note that current region-based object detec-
tion methods are still treating object detection as a
perception problem, not a reasoning problem: the re-
gion classiﬁer still produces multiple detection results
around an object instance during inference, and relies
on manually designed NMS [69] with a pre-deﬁned
threshold for de-duplication. This process can be sub-
optimal. We show that with a spatial memory that
memorizes the already detected objects, it is possible
to learn the functionality of NMS automatically.

• Second, replacing NMS is merely a ﬁrst demonstration
for context-based reasoning for object detection. Since
the spatial memory is supposed to store both semantic
and location information, a legitimate next step would
i.e., infer the “what” and
be full context reasoning:
“where” of other instances based on the current layout
of detected objects in the scene. We show evidence for
such beneﬁts on COCO [52].

• Third, our spatial memory essentially presents as a
general framework to encode instance-level visual
knowledge [48], which requires the model to properly
handle the spatial (e.g. overlaps) and semantic (e.g.
poses) interactions between groups of objects. Our ap-
proach follows the spirit of end-to-end learning, opti-
mizing the representation for an end-task – object de-
tection. Both the representation and the idea can be
applied to other tasks that require holistic image un-
derstanding [3, 42, 98].

2. Related Work

As we already mentioned most related work for con-
text and memory in Sec. 1, in this section we mainly re-
view ideas that use sequential prediction for object detec-
tion. A large portion of the literature [28, 45, 56] focuses
on sequential approaches for region proposals (i.e., fore-
ground/background classiﬁcation). The motivation is to re-
lieve the burden for region classiﬁers by replacing an ex-
haustive sliding-window search [20] with a smarter and
faster search process. In the era of ConvNet-based detec-
tors, such methods usually struggle to keep a delicate bal-
ance between efﬁciency and accuracy, since a convolution
based 0/1 classiﬁer (e.g. region proposal network [69]) al-
ready achieves an impressive performance when maintain-
ing a reasonable speed. Sequential search has also been
used for localizing small landmarks [77], but the per-class
model assumes the existence of such objects in an image
and lacks the ability to use other categories as context.

Another commonly used trick especially beneﬁcial for
reducing localization error is iterative bounding box reﬁne-
ment [25, 26, 69, 95], which leverages local image context
to predict a better bounding box iteratively. This line of re-
search is complementary to our SMN, since its goal is to

locate the original instance itself better, whereas our focus
is on how to better detect other objects given the current
detections.

An interesting recent direction focuses on using deep re-
inforcement learning (DRL) to optimize the sequence se-
lection problem in detection [6, 9, 50, 61]. However, due to
the lack of full supervision signal in a problem with high-
dimensional action space2, DRL has so far only been used
for bounding box reﬁnements or knoledge-assisted detec-
ton, where the action space is greatly reduced. Neverthe-
less, SMN can naturally serve as an encoder of the state in
a DRL system to directly optimize average precision [34].

Note that the idea of using higher-dimensional memory
It has resemblance to spa-
in vision is not entirely new.
tial attention, which has been explored in many high-level
tasks [47, 68, 91, 92]. To bypass NMS, LSTM [35] cells ar-
ranged in 2D order [78] and intersection-over-union (IoU)
maps [39] have been used for single-class object detection.
We also notice a recent trend in using 2D memory as a
map for planning and navigation [31, 66]. Our work ex-
tends such efforts into generic, multi-class object detection,
performing joint reasoning on both space and semantics.

3. Background: Faster RCNN

Our spatial memory network is agnostic to the choice of
base object detection model. In this paper we build SMN
on top of Faster R-CNN [69] (FRCNN) as a demonstration,
which is a state-of-the-art detector that predicts and classi-
ﬁes Regions of Interest (RoIs). Here we ﬁrst give a brief
review of the approach.

3.1. Base Network

We use VGG16 [76] as the base network for feature ex-
It has 13 convolutional (conv), 5 max-pooling
traction.
(pool), and 2 fully connected (fc) layers before feeding
into the ﬁnal classiﬁer, and was pre-trained on the ILSVRC
challenge [71]. Given an image I of height h and width w,
feature maps from the last conv layer (conv5 3) are ﬁrst
extracted by FRCNN. The conv5 3 feature size (h(cid:48), w(cid:48))
is roughly γ=1/16 of the original image in each spatial di-
mension. On top of it, FRCNN proceeds by allocating two
sub-networks for region proposal and region classiﬁcation.

3.2. Region Proposal

The region proposal network essentially trains a class-
agnostic objectness [1] classiﬁer, proposing regions that are
likely to have a foreground object in a sliding window man-
It consists of 3 conv layers, one maps from
ner [20].
conv5 3 to a suitable representation for RoI proposals,
and two 1×1 siblings on top of this representation for fore-
ground/background classiﬁcation and bounding box regres-
sion. Note that at each location, anchor boxes [69] of multi-

2Jointly reason about all bounding boxes and all classes.

ple scales (s) and aspect ratios (r) are used to cover a dense
sampling of possible windows. Therefore the total num-
ber of proposed boxes is K≈h(cid:48)×w(cid:48)×s×r3. During train-
ing and testing, k(cid:28)K regions are selected by this network
as candidates for the second-stage region classiﬁcation.

3.3. Region Classiﬁcation

Since the base network is originally an image classiﬁer,
region classiﬁcation network inherits most usable parts of
VGG16, with two caveats. First, because RoI proposals
can be be arbitrary rectangular bounding boxes, RoI pool-
ing [26, 40] is used in place of pool on conv5 3 to match
the the square-sized (7×7) input requirement for fc6. Sec-
ond, the 1, 000-way fc layer for ILSVRC classiﬁcation
is replaced by two fc layers for C-way classiﬁcation and
bounding box regression respectively. Each of the C classes
gets a separate bounding box regressor.

3.4. De-duplication

We want to point out the often-neglected fact that a
standard post-processing step is used in almost all detec-
tors [20, 49, 53, 69] to disambiguate duplications – NMS.
For FRCNN, NMS takes place in both stages. First, for
region proposals, it prunes out the overlapping RoIs that
are likely corresponding to the same object (“one-for-all-
class”) to train the region classiﬁer. Second, for the ﬁnal
detection results, NMS is applied in an isolated, per-class
manner (“one-for-each-class”). In this paper, we still use
NMS for RoI sampling during training [12], and mainly fo-
cus on building a model to replace the per-class NMS, with
the hope that the model can encode the rich interplay across
multiple classes when suppressing redundant detections.

4. Spatial Memory Network

To better motivate the use of spatial memory network, we
resort to a mathematical formulation of the task at hand. For
object detection, the goal is to jointly infer and detect all the
object instances O=[O1, O2, O3, · · · , ON ] given an image
I, where N is the maximum number of object instances for
any image4. Then the objective function of training a model
(e.g. FRCNN) M is to maximize the log-likelihood:

arg max
M

L = log P(O1:N |M, I)

(cid:88)

=

n=1:N

log P (On|O0:n−1, M, I),

(1)

where O0:n−1 is short for [O1, O2, O3, · · · , On−1] and O0:0
is an empty set. Note that this decomposition of the joint

3Boarder anchors excluded.
4On denotes both the class and location of the object instance. When
there is not enough foreground objects, the sequence can be padded with
the background class.

(Sec. 4.4) with features (Sec. 4.3) extracted from the de-
tected region. Then a context model (Sec. 4.5) aggregates
spatial and other information from the memory, and outputs
(Sec. 4.6) scores that help region proposal and region clas-
siﬁcation in FRCNN. Then the next potential detection is
picked (Sec. 4.7) to update the memory again. This process
goes on until a ﬁxed number of iterations have reached (See
Fig. 2 for an overview).

We now describe each module, beginning with a descrip-

tion of the memory itself.

4.1. Memory

Different from previous works that either mixes mem-
ory with computation [14, 18, 35] or mimics the one-
dimensional memory in the Turing machine/von Neumann
architecture [86], we would like to build a two-dimensional
memory for images. This is intuitive because images are
intrinsically 2D mappings of the 3D visual world. But more
importantly, we aim to leverage the power of ConvNets for
context reasoning, which “forces” us to provide an image-
like 2D input.

How big the memory should be spatially? For object
detection, FRCNN that operates entirely on conv5 3 fea-
tures can already retrieve even tiny objects (e.g. the ones in
Fig. 1), suggesting that a resolution 1/16 of the full image
strikes a reasonable balance between speed and accuracy.
At each location, the memory cell is a D=256 dimensional
vector that stores the visual information discovered so far.
Ideally, the initial values within the memory should capture
the photographic bias of a natural image, i.e., prior about
where a certain object tend to occur (e.g. sun is more likely
to occur in the upper part). But the prior cannot be depen-
dent on the input image size. To this end, we simply initial-
ize the memory with a ﬁxed spatial size (20×20×256 cells),
and resize it according to the incoming conv5 3 size using
bilinear interpolation. In this way, the memory is fully uti-
lized to learn the prior, regardless of different image sizes.

4.2. Indexing

The most difﬁcult problem that previous works [29, 79]
face when building an differentiable external memory is the
design of memory indexing. The core problem is which
memory cell to write to for what inputs. Luckily for our
problem, strong correspondence between memory and 2D
images solves this problem. Speciﬁcally, the target re-
gions to look up in 2D memory are already provided. Fur-
thermore, RoI pooling [26, 40] is precisely the operations
needed to read off from the spatial memory6. The only re-
maining task is to create a write function that updates the

6Although RoI pooling only computes partial gradients, back-
propagation w.r.t. bounding box coordinates are not entirely necessary [69]
and previously found unstable [40].

Figure 2: Overview of memory iterations for object detec-
tion. The original components from FRCNN are shown in
the gray area. The old detection (person) is marked with a
green box, and the new detection (car) is marked with blue.
Here the network is unrolled one iteration.

layout probability is exact [18], regardless of the order we
are choosing.

For a region-based object detector, Eq.(1) is approxi-

mated by detecting each object instance separately:

arg max
M

L ≈

(cid:88)

n=1:N

log P (On|M, I),

(2)

where NMS shoulders the responsibility to model the cor-
relations in the entire sequence of detections. Since NMS is
mostly5 dependent on overlapping patterns, the information
it can provide is limited compared to O0:n−1.

How can we do better? Inspired by networks that impose
a memory [14, 18, 29, 35, 79] for sequential and reasoning
tasks, and the two-dimensional nature of images, we pro-
pose to encode O0:n−1 in a spatial memory, where we learn
to store all the previous detections. I.e., we introduce mem-
ory variable Sn−1, which gets updated each time an object
instance is detected, and the approximation becomes:

arg max
M,S

L ≈

(cid:88)

n=1:N

log P (On|Sn−1, M, I),

(3)

where the memory S is jointly optimized with M.

With the above formulation, the inference procedure for
object becomes conditional: An empty memory is initial-
ized at ﬁrst (Sec. 4.1). Once an object instance is de-
tected, selected cells (Sec. 4.2) in the memory gets updated

5Since NMS is applied in a per-class manner, there is also semantic

information.

Figure 3: Illustration of the input module (Sec. 4.3). It as-
sembles spatial and non-spatial features: detection scores
after SoftMax (fc8) are tiled at each location of the RoI
pooled 14×14 conv5 3 feature. Two additional conv lay-
ers are used to merge the information from two sources.
Dotted arrow shows how the feature at one location is trans-
formed.

memory given a detection. This can be divided into two
parts, “what” (Sec. 4.3), and “how” (Sec. 4.4).

4.3. Input Features

It may appear trivial, but the decision of what features to
insert into the memory requires careful deliberation. First,
since conv5 3 feature preserves spatial information, we
need to incorporate it. Speciﬁcally, we use RoI pooling
(without taking Max) to obtain the feature map at the lo-
cation, and resize it to 14×14. However, merely hav-
ing conv5 3 is not sufﬁcient to capture the higher-level
semantic information, especially pertaining which object
class is detected. The detection score is particularly use-
ful for disambiguation when two objects occur in the same
region, e.g., a person riding a horse. Therefore, we also in-
clude fc8 SoftMax score as an input, which is appended at
each conv5 3 locations and followed by two 1×1 conv
layers to fuse the information (see Fig. 3). We choose the
full score over a one-hot class vector, because it is more
robust to false detections.

4.4. Writing

Given the region location and the input features xn, we
update the corresponding memory cells with a convolu-
tional Gated Recurrent Unit [14] (GRU), which uses 3×3
conv ﬁlters in place of fc layers as weights. The GRU
has a reset gate, and an update gate, shared at each loca-
tion and activated with Sigmoid function σ(·). Hyperbolic
tangent tanh(·) is used to constrain the memory values be-
tween −1. and 1. For alignment, the region from the origi-
nal memory Sn−1 is also cropped with the same RoI pool-
ing operation to 14×14. After GRU, the new memory cells
are placed back to Sn with a reverse RoI operation.

4.5. Context Model

Now that the detected objects are encoded in the mem-
ory, all we have to do for context reasoning is stacking an-

Figure 4: Illustration of the output module (Sec. 4.6) for
region classiﬁcation. FRCNN scores are optimized at the
ﬁrst iteration when memory is empty, and then augmented
with memory scores in later iterations. Same is done for
region proposals. Two additional fc layers are used to fuse
FRCNN and memory features.

other ConNet on the top.
In the current setup, we use a
simple 5-layer all-convolutional network to extract the spa-
tial patterns. Each conv ﬁlter has a spatial size of 3×3,
and channel size of 256. Padding is added to keep the ﬁ-
nal layer m-conv5 same size of conv5 3. To ease back-
propagation, we add residual connections [33] every two
layers.

4.6. Output

As for the module that outputs the reasoning results, we
treat m-conv5 exactly the same way as conv5 3 in FR-
CNN: 3 conv layers for region proposal, and 2 fc layers
with RoI pooling for region classiﬁcation. The fc layers
have 2048 neurons each.

We design another residual architecture to combine the
memory scores with the FRCNN scores (see Fig. 4): in the
ﬁrst iteration when the memory is empty, we only use FR-
CNN for detection; from the second iteration on, we add the
memory predictions on top of the FRCNN ones, so that the
memory essentially provides the additional context to close
the gap. This design allows a handy visualization of the
prediction difference with/without context. But more im-
portantly, such an architecture is critical to let us converge
the full network. Details for this are covered in Sec. 5.1.

4.7. Selecting Next Region

Since spatial memory turns object detection into a se-
quential prediction problem, an important decision to make
is which region to take-in next [7]. Intuitively, some ob-
jects are more useful serving as context for others (e.g. per-
son) [21, 30, 32, 94], and some object instances are easier
to detect and less prone to consequent errors. However, in
this paper we simply follow a greedy strategy – the most
conﬁdent foreground object box is selected to update the
memory, leaving more advanced models that directly opti-
mize the sequence [80] as future work.

help much. Tracking the learning process, we ﬁnd where
the actual problem lies – because the network needs to de-
duplicate, it keeps receiving contradicting signals: the nor-
mal one that guides perception, and the adversarial one that
prevents more perception. And because S also starts off
from scratch, the signal it can provide is also weak and un-
reliable. As a result, part of both error signals are back-
propagated to M7, causing trouble for learning further.

Realizing where the issue is, a direct solution is to just
stop the adversarial signal from ﬂowing back and canceling
the normal one. Therefore, we stopped the gradient to FR-
CNN from second iteration on (Fig. 5 (c)), and the network
can successfully converge.

To make it easy for training and showing the conﬁdence
changes for consequent detections given the context, we
further reduced the architecture to exclude all memory re-
lated weights in the ﬁrst iteration (Fig. 5 (d)). This way, the
change in predictions with/without memory can be read-off
directly8, and training can be done separately for M and S.

5.2. RoI Sampling

sampling ratio for

To avoid getting overwhelmed by negative boxes,
FRCNN enforces a target
fore-
ground/background boxes. The introduction of a spatial
memory that learns to de-duplicate, brings in another spe-
cial type – regions whose label is ﬂipped from previous iter-
ations. To keep these regions from being buried in negative
examples too, we changed the sampling distribution to in-
clude ﬂipped regions.

It is important to point out that RoI sampling greatly
enhances the robustness of our sequential detection sys-
tem. Because only k(cid:28)K regions are sampled from all re-
gions, the overall most conﬁdent RoI is not guaranteed to be
picked when updating the memory. This opens up chances
for other highly conﬁdent boxes to be inserted into the se-
quence as well [80] and reduces over-ﬁtting.

We also practiced the idea of multi-task learning for
SMN. The major motivation is to force the memory to mem-
orize more: the basic SMN is only asked fulﬁll the mission
of predicting the missing objects, which does not necessar-
ily translate to a good memorization of previously detected
objects. E.g., it may remember that one region has an object
in general, but does not store more categorical information
beyond that. To better converge the memory, we also added
a reconstruction loss [13, 70], i.e., letting the network in ad-
dition predict the object classes it has stored in the memory.
Speciﬁcally, we add an identical set of branches on top of

7Since there are two sets of scores (from M and fused fc) added to-
gether for prediction in Fig. 5 (b), we ﬁnd the conﬂicting signals are also
propagated to the biases of these predictions: resulting in one going up and
the other down while essentially canceling each other.

8Otherwise we have to run the inference again with S0.

Figure 5: Four design choices for learning the functionality
of de-duplication. M is FRCNN features, and Sn−1 repre-
sents memory features. Each design is shown by two gray
panels showing the information ﬂow of Iteration 0 (left) and
Iteration n>0 (right). We ﬁnd it hard to even converge the
network when the gradient is back-propagated to FRCNN in
all iterations (a) & (b). Stop the gradient in later iterations
(c) can successfully converge the network, and our ﬁnal de-
sign (d) separates perception from reasoning and makes it
easy to visualize the effect of context. All design choices
are abstract and apply to both region proposal and classiﬁ-
cation. Please see Sec. 5.1 for more details.

5. Training the Spatial Memory

Like a standard network with recurrent connections,
our SMN is trained by back-propagation through time
(BPTT) [88], which unrolls the network multiple times
before executing a weight-update. However, apart from
the well-known gradient propagation issue, imposing the
conditional structure on object detection incurs new chal-
lenges for training. Interestingly, the most difﬁcult one we
face in our experiment, is the “straightforward” task of de-
duplication.

Simply put, the functionality of de-duplication is: how
can the network learn that a detected instance should no
longer be detected again? More speciﬁcally, we need to
design the output module (Sec. 4.6) to fuse the memory (S)
and FRCNN (M) beliefs and predict intelligently: when
the memory is empty, the FRCNN score should be used;
but when the memory has the instance stored, the network
needs to ignore, or negate the cue from FRCNN.

Since multi-layer networks are universal function ap-
proximators [38], our ﬁrst attempt is to fuse the informa-
tion by directly feeding into a multi-layer network (Fig. 5
(a)). However, joint-training fails to even converge FR-
CNN. Suspicious that the longer, weaker supervision might
be the cause, we also added skip connections [5] to guide
the FRCNN training directly (Fig. 5 (b)). Yet it still does not

5.1. Learning De-duplication

5.3. Multi-Tasking

the m-conv5 features as FRCNN, for both region proposal
and region classiﬁcation in each iteration. These weights
are used to predict only the previously detected objects.

Table 1: Baseline and initial analysis on COCO 2014 mini-
val when constraining the number of detections N =5/10.
AP and AR numbers are from COCO evaluation tool.

5.4. Stage-wise Training

Thanks to the design of our memory augmented predic-
tion, so far we have trained the full model in two separate
stages, where FRCNN M, the perception model can be
optimized independently at ﬁrst; then the reasoning model
with spatial memory S is learned on top of ﬁxed M. This
helps us isolate the inﬂuence of the base model and focus
directly on the study of SMN.

For efﬁciency, we also follow a curriculum learning [8]
strategy: bootstrap a SMN of more iterations (e.g. N =10)
with a pre-trained SMN of fewer iterations (e.g. N =5). As
N gets larger, the task becomes harder. Curriculum learning
does not require re-learning de-duplication (which we learn
with N from 2 to 4), and allows the network to focus more
on object-object relationships instead.

5.5. Hyper-parameters

Given a pre-trained FRCNN or SMN (in the case of cur-
riculum learning), we train a ﬁxed number of 30k steps. The
initial learning rate is set to 1e−3 and reduced to 1e−4 af-
ter 20k steps. Since we do not use automatic normalization
tricks [41, 54], different variances are manually set when
initializing weights from scratch, in order to let different in-
puts contribute comparably (e.g. when concatenating fc7
and m-fc7). Other hyper-parameters are kept the same to
the ones used in FRCNN.

6. Experimental Results

We highlight the performance of our spatial memory net-
work on COCO [52]. However, for ablative analysis and
understanding the behaviour of our system, we use both
PASCAL VOC 2007 [19] and COCO [52]. For VOC we
use the trainval split for training, and test for evaluation.
For COCO we use trainval35k [5] and minival. For evalu-
ation, toolkits provided by the respective dataset are used.
The main metrics (mAP, AP and AR) are based on detection
average precision/recall.
Implementation Details: We use TensorFlow to imple-
ment our model, which is built on top of the open-sourced
FRCNN implementation9 serving as a baseline. For COCO,
this implementation has an AP of 29.1% compared to the
original one 24.2% [69].

Original FRCNN uses NMS for region sampling as well.
However, NMS hurts our performance more since we do
sequential prediction and one miss along the chain can neg-
atively impact all the follow-up detections. To overcome
this disadvantage, we would ideally like to examine all K
regions in a sliding window fashion. However, due to the

9https://github.com/endernewton/tf-faster-rcnn

N Method
FRCNN [69]
-
- Baseline [12]
5 Baseline
=
SMN
N
0 Baseline
1
=
SMN
N

AP AR-10 AR-S AR-M AR-L

24.2
29.1

23.8
24.5

27.1
28.1

33.7
38.7

27.8
28.9

33.5
35.0

11.7
17.7

7.0
7.3

10.8
11.5

39.5
44.9

28.7
29.7

36.7
38.1

54.1
56.9

48.4
50.6

53.8
56.4

GPU memory limit, the top 5k regions are used instead. We
analyze this choice in ablative analysis (Sec. 6.2). Due to
the same limitation, our current implementation of SMN
can only unroll N =10 times in a single GPU. At each
timestep in SMN, we do a soft max-prediction for the top
box selected, so that a single box can be assigned to multi-
ple classes. We will also justify and analyze this choice in
Sec. 6.2.
Initial Results: Table 1 shows the initial results of our ap-
proach as described. As it can be seen for N =5 detections
per image our SMN give an AP of 24.5% and for N =10
if gives an AP of 28.1%. When the baseline is allowed
the same number of detections (N =5, 10), the AP is 23.8%
and 27.1%. Therefore, while we do outperform baseline for
ﬁxed number of detections per image, due to limited roll-out
capability we are still ∼1% below the baseline [12].

6.1. SMN for Hard Examples

In this section, we want to go beyond N =10 detections
and see if the overall detection performance can be im-
proved with SMN. Intuitively, for highly conﬁdent detec-
tions, ConvNet-based FRCNN is already doing a decent job
and not much can be learned from an additional memory. It
is the “tails” that need help from the context! This means
two things: 1) with a limited resource budget, SMN should
be used in later iterations to provide conditional informa-
tion; and 2) at the beginning of the sequence, a standard
FRCNN can work as a proxy. Given these insights, we ex-
perimented with the following strategy: For the ﬁrst N1 it-
erations, we use a standard FRCNN to detect easier objects
and feed the memory with a sequence ordered by FRCNN
conﬁdence (after per-class NMS). Memory gets updated as
objects come in, but does not output features to augment
prediction. Only for the later N2 iterations it acts normally
as a context provider to detect harder examples. For COCO,
we set N1=50 and bootstrap from a N2=10 SMN model.

Although SMN is trained with the goal of context rea-
soning and learns new functionality (e.g. de-duplication)
that the original FRCNN does not have, it does have in-
troduced more parameters for memory-augmented predic-
tion. Therefore, we also add a MLP baseline, where a
5-layer ConvNet (Sec. 4.5) is directly stacked on top of

Table 2: Final comparison between SMN and baselines. We
additionally include MLP baseline where the number of pa-
rameters are kept the same as SMN for context aggregation
and output. Top 5k regions are used to select proposal in-
stead of NMS.

Method
Baseline [12]
MLP
SMN

AP AP-.5 AP-.75 AP-S AP-M AP-L AR-S AR-M AR-L

29.4

30.1
31.6

50.0

50.8
52.2

30.9

31.7
33.2

12.2

12.5
14.4

33.7

34.2
35.7

43.8

44.5
45.8

18.5

19.2
20.5

45.5

47.0
48.8

58.9

59.8
63.2

Figure 6: Examples of context has helped improve scores
by reasoning. Left: the score of sheep is increased due to
presence of other sheep in background. Right: the score of
horse is decreased due to the detection of cake and table.

conv5 3 for context aggregation, and the same output
modules (Sec. 4.6) are used to make predictions.

The results can be found in Table 2. As can be seen,
on our ﬁnal system, we are 2.2% better than the baseline
FRCNN. This demonstrates our ability to ﬁnd hard exam-
ples. It is worth noting that here hard does not necessar-
ily translate to small.
In fact, our reasoning system also
helps big objects, potentially due to its ability to perform
de-duplication more intelligently and beneﬁt larger objects
that are more likely to overlap.
Qualitative Results: We show a couple of examples of how
context using spatial memory can help improve the perfor-
mance and detections. In the ﬁrst case, the score of sheep
gets boosted due to other sheep. The score of horse de-
creases due to the detection of cake and table. Please check
the supplementary material for more examples.

6.2. Ablative Analysis

We now perform ablative analysis to explain all our
choices for the ﬁnal implementation. For ablative analysis,
we use both VOC and COCO datasets. The numbers are
summarized in Table 3. For the comparisons shown here,
we switch back to the standard NMS-based region sampling
and select top k=300 RoIs as in original FRCNN. Also,
when we do the roll-out, at each step we choose one detec-
tion and perform HardMax (rather than SoftMax): make the
hard decision about what class does the selected box belong
to – a natural idea for sequential prediction.

For N =5, we compared three models. First, SMN Base,
where we simply train the network as is done in FRCNN.
Next, regions with ﬂipped labels (Sec. 5.2) are added to re-
places some of the negative example – for training region

Table 3: Ablative analysis on VOC 2007 test and COCO
2014 minival. All approaches constrained by detections
N =5/10. mAP is used to evaluate VOC, AP and AR num-
bers are from COCO.

N Method

mAP AP AR-10 AR-S AR-M AR-L

Baseline (FR-CNN)
SMN Base

+ Sample Flipped

5
=
N

SMN Full

0 Baseline
1
=
N

SMN Full

+Tune from N =5

65.8 23.6
63.6 23.3
64.4 23.5
64.6 23.8

70.3 26.9
67.5 26.6
67.8 27.1

27.6
27.2
27.2
27.7

33.2
32.6
32.7

7.0
6.7
6.9
6.9

10.9
10.3
10.3

29.1
28.0
28.4
28.5

36.6
35.6
35.9

47.4
46.1
46.4
47.4

52.7
52.1
52.3

Table 4: Investigating the recall issue. S stands for Soft-
Max based testing, and H for HardMax. (cid:54)N is short for Non-
aggressive NMS, where top 5k RoIs are directly selected
without NMS.

5
=
N

N Method
Baseline
SMN Full
Baseline
SMN Full
Baseline
SMN Full
Baseline
SMN Full
Baseline
SMN Full
Baseline
SMN Full

0
1
=
N

7.0
7.5
6.7
6.9
7.0
7.3

27.6
28.8
27.2
27.7
27.8
28.9

29.1
29.7
28.6
28.5
28.7
29.7

65.8 23.6
66.4 24.1
65.4 23.5
64.6 23.8
66.0 23.8
66.6 24.5

(cid:54)N Max mAP AP AR-10 AR-S AR-M AR-L
(cid:55)
47.4
(cid:55)
50.0
(cid:55)
46.9
(cid:55)
47.4
(cid:51)
48.4
(cid:51)
50.6
(cid:55)
(cid:55)
(cid:55)
(cid:55)
(cid:51)
(cid:51)

70.3 26.9
69.4 27.7
68.0 26.4
67.8 27.1
70.4 27.1
70.0 28.1

10.9
11.6
9.7
10.3
10.8
11.5

36.6
37.6
35.0
35.9
36.7
38.1

52.7
55.7
50.7
52.3
53.8
56.4

33.2
35.0
31.9
32.7
33.5
35.0

S
S
H
H
S
S
S
S
H
H
S
S

proposal the ratio for positive/ﬂipped/negative is 2:1:1, and
for region classiﬁcation it is 1:1:2. Third, SMN Full, where
we keep the previous sampling strategy and in addition in-
clude the reconstruction loss (Sec. 5.3). Overall, both strate-
gies help performance but with a seemly different strength:
sampling ﬂipped regions helps more on small objects, and
multi-task learning helps more on bigger ones.

However, our best performance in Table 3 is still behind
the baseline and judging from the COCO AR we believe the
biggest issue lies in recall. Therefore, we take the best SMN
Full model and conduct two other investigations speciﬁcally
targeting recall. Here we only list the ﬁnal results, please
see supplementary material for more discussions.

SoftMax vs. HardMax: First, we address a subtle question:
if we take top N detections with the memory and compare
them directly with top N detections of Faster R-CNN: are
these results comparable? It turns out to be not! As men-
tioned in Sec. 3.4, because NMS is applied in a per-class
manner, the actual number of box candidates it can put in
the ﬁnal detection is k×C. To make it more clear, for a
confusing region where e.g. the belief for laptop is 40% and
keyboard is 35%, NMS can keep both candidates in the top
N detections, whereas for SMN it can only keep the max-

imum one10. Therefore, to be fair, we try: a) HardMax for
baseline; and b) SoftMax for SMN.
Non-aggressive NMS: Finally, we also evaluate our choice
of non-aggressive NMS during RoI sampling. Both baseline
and SMN perform better with 5k proposals; however our
boost on AP is more signiﬁcant due to sequential prediction
issues.

7. Conclusion

This paper is our ﬁrst step towards instance-level reason-
ing in object detection with ConvNets. We introduce a sim-
ple yet powerful framework of spatial memory network, to
model the instance-level context efﬁciently and effectively.
Our spatial memory essentially assembles object instances
back into a pseudo “image” representation. This memory
can simply be fed into another ConvNet to extract context
information and perform object-object relationship reason-
ing. We show our SMN direction is promising as it pro-
vides 2.2% improvement over baseline Faster RCNN on the
COCO dataset so far. We believe our framework is generic
and should promote research focusing on knowledge-based
reasoning on images.

Acknowledgements

XC would like to thank Jiwei Li for helpful discussions
on reinforcement learning, and everyone who took time to
provide useful feedback. This research is supported in part
by ONR MURI N000141612007, the Ofﬁce of the Direc-
tor of National Intelligence (ODNI), Intelligence Advanced
Research Projects Activity (IARPA) and hardware dona-
tions from NVIDIA. The views and conclusions contained
hereon are those of the authors and should not be interpreted
as necessarily representing the ofﬁcial policies, either ex-
pressed or implied of ODNI, IARPA or the US govern-
ment. The US Government is authorized to reproduce and
distribute the reprints for governmental purposed notwith-
standing any copyright annotation thereon.

References

[1] B. Alexe, T. Deselaers, and V. Ferrari. Measuring the object-
ness of image windows. TPAMI, 34(11):2189–2202, 2012.
3

[2] J. Andreas, M. Rohrbach, T. Darrell, and D. Klein. Learn-
ing to compose neural networks for question answering.
arXiv:1601.01705, 2016. 2

[3] S. Antol, A. Agrawal, J. Lu, M. Mitchell, D. Batra,
C. Lawrence Zitnick, and D. Parikh. Vqa: Visual question
answering. In ICCV, 2015. 2

[4] M. Bar. Visual objects in context. Nature Reviews Neuro-

science, 5(8):617–629, 2004. 1

10It’s also a result of our current input feature design, where we only
used fc8 and conv5 3 features to update the memory without a top-
down notion [75] of which class is picked, so there’s no more need for
SMN to return.

[5] S. Bell, C. Lawrence Zitnick, K. Bala, and R. Girshick.
Inside-outside net: Detecting objects in context with skip
pooling and recurrent neural networks. In CVPR, 2016. 1, 6,
7

[6] M. Bellver, X. Gir´o-i Nieto, F. Marqu´es, and J. Torres. Hier-
archical object detection with deep reinforcement learning.
arXiv:1611.03718, 2016. 3

[7] S. Bengio, O. Vinyals, N. Jaitly, and N. Shazeer. Scheduled
sampling for sequence prediction with recurrent neural net-
works. In NIPS, 2015. 5

[8] Y. Bengio, J. Louradour, R. Collobert, and J. Weston. Cur-

riculum learning. In ICML, 2009. 7

[9] J. C. Caicedo and S. Lazebnik. Active object localization

with deep reinforcement learning. In ICCV, 2015. 3
[10] P. Carbonetto, N. De Freitas, and K. Barnard. A statistical
model for general contextual object recognition. In ECCV,
2004. 1

[11] L.-C. Chen, G. Papandreou, I. Kokkinos, K. Murphy, and
A. L. Yuille. Deeplab: Semantic image segmentation with
deep convolutional nets, atrous convolution, and fully con-
nected crfs. arXiv:1606.00915, 2016. 1, 2

[12] X. Chen and A. Gupta. An implementation of faster rcnn
with study for region sampling. arXiv:1702.02138, 2017. 3,
7, 8, 13

[13] X. Chen and C. Lawrence Zitnick. Mind’s eye: A recurrent
visual representation for image caption generation. In CVPR,
2015. 2, 6

[14] J. Chung, C. Gulcehre, K. Cho, and Y. Bengio. Empirical
evaluation of gated recurrent neural networks on sequence
modeling. arXiv:1412.3555, 2014. 4, 5

[15] C. Desai, D. Ramanan, and C. C. Fowlkes. Discrimina-
tive models for multi-class object layout. IJCV, 95(1):1–12,
2011. 1, 2

[16] S. K. Divvala, D. Hoiem, J. H. Hays, A. A. Efros, and
M. Hebert. An empirical study of context in object detec-
tion. In CVPR, 2009. 1

[17] J. Donahue, L. A. Hendricks, S. Guadarrama, M. Rohrbach,
S. Venugopalan, K. Saenko, and T. Darrell. Long-term recur-
rent convolutional networks for visual recognition and de-
scription. arXiv:1411.4389, 2014. 2

[18] J. L. Elman. Finding structure in time. Cognitive science,

14(2):179–211, 1990. 4

[19] M. Everingham, L. Van Gool, C. K. Williams, J. Winn, and
A. Zisserman. The pascal visual object classes (voc) chal-
lenge. IJCV, 88(2):303–338, 2010. 7

[20] P. F. Felzenszwalb, R. B. Girshick, D. McAllester, and D. Ra-
manan. Object detection with discriminatively trained part-
based models. TPAMI, 32(9):1627–1645, 2010. 2, 3
[21] D. F. Fouhey, V. Delaitre, A. Gupta, A. A. Efros, I. Laptev,
and J. Sivic. People watching: Human actions as a cue for
single view geometry. IJCV, 110(3):259–274, 2014. 5
[22] C. Galleguillos and S. Belongie. Context based object cate-
gorization: A critical survey. CVIU, 114(6):712–722, 2010.
1

[23] C. Galleguillos, A. Rabinovich, and S. Belongie. Object cat-
egorization using co-occurrence, location and appearance. In
CVPR, 2008. 1

[24] H. Gao, J. Mao, J. Zhou, Z. Huang, L. Wang, and W. Xu.
Are you talking to a machine? dataset and methods for mul-
tilingual image question answering. In NIPS, 2015. 2

[25] S. Gidaris and N. Komodakis.

Active box proposal generation via in-out
arXiv:1606.04446, 2016. 2

Attend reﬁne repeat:
localization.

[26] R. Girshick. Fast r-cnn. In ICCV, 2015. 2, 3, 4
[27] G. Gkioxari, R. Girshick, and J. Malik. Contextual action

recognition with r* cnn. In ICCV, 2015. 1

[28] A. Gonzalez-Garcia, A. Vezhnevets, and V. Ferrari. An ac-
tive search strategy for efﬁcient object class detection.
In
CVPR, 2015. 2

[29] A. Graves, G. Wayne, M. Reynolds, T. Harley, I. Danihelka,
A. Grabska-Barwi´nska, S. G. Colmenarejo, E. Grefenstette,
T. Ramalho, J. Agapiou, et al. Hybrid computing using
a neural network with dynamic external memory. Nature,
538(7626):471–476, 2016. 4

[30] A. Gupta, A. Kembhavi, and L. S. Davis. Observing human-
object interactions: Using spatial and functional compatibil-
ity for recognition. TPAMI, 31(10):1775–1789, 2009. 5
[31] S. Gupta, J. Davidson, S. Levine, R. Sukthankar, and J. Ma-
lik. Cognitive mapping and planning for visual navigation.
arXiv:1702.03920, 2017. 3

[32] S. Gupta, B. Hariharan, and J. Malik.

Exploring per-
son context and local scene context for object detection.
arXiv:1511.08177, 2015. 1, 5

[33] K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learning

for image recognition. In CVPR, 2016. 1, 5

[34] P. Henderson and V. Ferrari.

End-to-end training
of object class detectors for mean average precision.
arXiv:1607.03476, 2016. 3

[35] S. Hochreiter and J. Schmidhuber. Long short-term memory.

Neural computation, 9(8):1735–1780, 1997. 3, 4

[36] D. Hoiem, A. A. Efros, and M. Hebert. Putting objects in

perspective. IJCV, 80(1):3–15, 2008. 1

[37] A. Hollingworth. Does consistent scene context facilitate ob-
ject perception? Journal of Experimental Psychology: Gen-
eral, 127(4):398, 1998. 1

[38] K. Hornik, M. Stinchcombe, and H. White. Multilayer feed-
forward networks are universal approximators. Neural net-
works, 2(5):359–366, 1989. 6

[39] J. Hosang, R. Benenson, and B. Schiele. A convnet for non-
In German Conference on Pattern

maximum suppression.
Recognition, 2016. 3

[40] J. Huang, V. Rathod, C. Sun, M. Zhu, A. Korattikara,
A. Fathi, I. Fischer, Z. Wojna, Y. Song, S. Guadarrama, and
K. Murphy. Speed/accuracy trade-offs for modern convolu-
tional object detectors. arXiv:1611.10012, 2016. 1, 3, 4
[41] S. Ioffe and C. Szegedy. Batch normalization: Accelerating
deep network training by reducing internal covariate shift.
arXiv:1502.03167, 2015. 7

[42] J. Johnson, A. Karpathy, and L. Fei-Fei. Densecap: Fully
convolutional localization networks for dense captioning. In
CVPR, 2016. 2

[43] P. Kr¨ahenb¨uhl and V. Koltun. Efﬁcient inference in fully
connected crfs with gaussian edge potentials. In NIPS, 2011.
1, 2

[44] R. Krishna, Y. Zhu, O. Groth, J. Johnson, K. Hata, J. Kravitz,
S. Chen, Y. Kalantidis, L.-J. Li, D. A. Shamma, et al. Vi-
sual genome: Connecting language and vision using crowd-
sourced dense image annotations. arXiv:1602.07332, 2016.
2

[45] C. H. Lampert, M. B. Blaschko, and T. Hofmann. Efﬁcient

subwindow search: A branch and bound framework for ob-
ject localization. TPAMI, 31(12):2129–2142, 2009. 2
[46] C. Li, D. Parikh, and T. Chen. Extracting adaptive contextual

cues from unlabeled regions. In ICCV, 2011. 1

[47] J. Li, Y. Wei, X. Liang, J. Dong, T. Xu, J. Feng, and S. Yan.
Attentive contexts for object detection. IEEE Transactions
on Multimedia, 2016. 3

[48] L.-J. Li, H. Su, L. Fei-Fei, and E. P. Xing. Object bank:
A high-level image representation for scene classiﬁcation &
semantic feature sparsiﬁcation. In NIPS, 2010. 2

[49] Y. Li, K. He, J. Sun, et al. R-fcn: Object detection via region-
based fully convolutional networks. In NIPS, 2016. 1, 3
[50] X. Liang, L. Lee, and E. P. Xing. Deep variation-structured
reinforcement learning for visual relationship and attribute
detection. arXiv:1703.03054, 2017. 3

[51] T.-Y. Lin, P. Doll´ar, R. Girshick, K. He, B. Hariharan, and
S. Belongie. Feature pyramid networks for object detection.
arXiv:1612.03144, 2016. 1

[52] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona, D. Ra-
manan, P. Doll´ar, and C. L. Zitnick. Microsoft coco: Com-
mon objects in context. In ECCV, 2014. 1, 2, 7

[53] W. Liu, D. Anguelov, D. Erhan, C. Szegedy, S. Reed, C.-Y.
Fu, and A. C. Berg. Ssd: Single shot multibox detector. In
ECCV, 2016. 1, 3

[54] W. Liu, A. Rabinovich, and A. C. Berg. Parsenet: Looking

wider to see better. arXiv:1506.04579, 2015. 7

[55] J. Lu, J. Yang, D. Batra, and D. Parikh. Hierarchical
question-image co-attention for visual question answering.
In NIPS, 2016. 2

[56] Y. Lu, T. Javidi, and S. Lazebnik. Adaptive object detection
using adjacency and zoom prediction. In CVPR, 2016. 2
[57] M. Malinowski, M. Rohrbach, and M. Fritz. Ask your neu-
rons: A neural-based approach to answering questions about
images. In ICCV, 2015. 2

[58] T. Malisiewicz and A. Efros. Beyond categories: The visual
memex model for reasoning about object relationships.
In
NIPS, 2009. 1

[59] J. Mao, W. Xu, Y. Yang, J. Wang, Z. Huang, and A. Yuille.
Deep captioning with multimodal recurrent neural networks
(m-rnn). arXiv:1412.6632, 2014. 2

[60] M. Marszalek, I. Laptev, and C. Schmid. Actions in context.

In CVPR, 2009. 1

[61] S. Mathe, A. Pirinen, and C. Sminchisescu. Reinforcement
learning for visual object detection. In CVPR, 2016. 3
[62] R. Mottaghi, X. Chen, X. Liu, N.-G. Cho, S.-W. Lee, S. Fi-
dler, R. Urtasun, and A. Yuille. The role of context for object
detection and semantic segmentation in the wild. In CVPR,
2014. 1

[63] K. Murphy, A. Torralba, W. Freeman, et al. Using the forest
to see the trees: a graphical model relating features, objects
and scenes. NIPS, 2003. 1

[64] A. Oliva and A. Torralba. The role of context in object recog-
nition. Trends in cognitive sciences, 11(12):520–527, 2007.
1

[65] t. E. Palmer. The effects of contextual scenes on the iden-
tiﬁcation of objects. Memory & Cognition, 3(5):519–526,
1975. 1

[66] E. Parisotto and R. Salakhutdinov. Neural map: Structured
memory for deep reinforcement learning. arXiv:1702.08360,
2017. 3

cations, pages 433–486, 1995. 6

[89] S. Xie, X. Huang, and Z. Tu. Top-down learning for struc-
In ECCV,

tured labeling with convolutional pseudoprior.
2016. 2

[90] C. Xiong, S. Merity, and R. Socher. Dynamic memory net-
arXiv,

works for visual and textual question answering.
1603, 2016. 2

[91] H. Xu and K. Saenko. Ask, attend and answer: Exploring
question-guided spatial attention for visual question answer-
ing. In ECCV, 2016. 2, 3

[92] K. Xu, J. Ba, R. Kiros, A. Courville, R. Salakhutdi-
Show, attend and tell:
image caption generation with visual attention.

nov, R. Zemel, and Y. Bengio.
Neural
arXiv:1502.03044, 2015. 2, 3

[93] Z. Yang, X. He, J. Gao, L. Deng, and A. Smola. Stacked
attention networks for image question answering. In CVPR,
2016. 2

[94] B. Yao and L. Fei-Fei. Modeling mutual context of object
and human pose in human-object interaction activities.
In
CVPR, 2010. 1, 5

[95] D. Yoo, S. Park, J.-Y. Lee, A. S. Paek, and I. So Kweon. At-
tentionnet: Aggregating weak directions for accurate object
detection. In ICCV, 2015. 2

[96] S. Zheng, S. Jayasumana, B. Romera-Paredes, V. Vineet,
Z. Su, D. Du, C. Huang, and P. H. Torr. Conditional ran-
dom ﬁelds as recurrent neural networks. In ICCV, 2015. 2

[97] Y. Zhu, O. Groth, M. Bernstein, and L. Fei-Fei. Visual7w:
Grounded question answering in images. In CVPR, 2016. 2
[98] Y. Zhu, C. Zhang, C. R´e, and L. Fei-Fei. Building a large-
scale multimodal knowledge base system for answering vi-
sual queries. arXiv:1507.05670, 2015. 2

[67] A. Rabinovich, A. Vedaldi, C. Galleguillos, E. Wiewiora,
and S. Belongie. Objects in context. In ICCV, 2007. 1
[68] M. Ren and R. S. Zemel. End-to-end instance segmentation
and counting with recurrent attention. arXiv:1605.09410,
2016. 3

[69] S. Ren, K. He, R. Girshick, and J. Sun. Faster r-cnn: To-
wards real-time object detection with region proposal net-
works. arXiv:1506.01497, 2015. 1, 2, 3, 4, 7, 13

[70] A. Rohrbach, M. Rohrbach, R. Hu, T. Darrell, and
B. Schiele. Grounding of textual phrases in images by re-
construction. In ECCV, 2016. 6

[71] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh,
S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein,
et al.
Imagenet large scale visual recognition challenge.
IJCV, 115(3):211–252, 2015. 3

[72] K. J. Shih, S. Singh, and D. Hoiem. Where to look: Focus
regions for visual question answering. In CVPR, 2016. 2
[73] J. Shotton, J. Winn, C. Rother, and A. Criminisi. Texton-
boost: Joint appearance, shape and context modeling for
multi-class object recognition and segmentation. In ECCV,
2006. 1, 2

[74] A. Shrivastava and A. Gupta. Contextual priming and feed-

back for faster r-cnn. In ECCV, 2016. 1

[75] A. Shrivastava, R. Sukthankar, J. Malik, and A. Gupta. Be-
yond Skip Connections: Top-Down Modulation for Object
Detection. arXiv:1612.06851, 2016. 9
[76] K. Simonyan and A. Zisserman.

Very deep con-
large-scale image recognition.

volutional networks for
arXiv:1409.1556, 2014. 1, 2, 3

[77] S. Singh, D. Hoiem, and D. Forsyth. Learning a sequential

search for landmarks. In CVPR, 2015. 2

[78] R. Stewart, M. Andriluka, and A. Y. Ng. End-to-end people

detection in crowded scenes. In CVPR, 2016. 3

[79] S. Sukhbaatar, J. Weston, R. Fergus, et al. End-to-end mem-

ory networks. In NIPS, 2015. 4

[80] R. S. Sutton, D. A. McAllester, S. P. Singh, Y. Mansour,
et al. Policy gradient methods for reinforcement learning
with function approximation. In NIPS, 1999. 5, 6

[81] A. Torralba. Contextual priming for object detection. IJCV,

53(2):169–191, 2003. 1

[82] A. Torralba, K. P. Murphy, W. T. Freeman, M. A. Rubin, et al.
Context-based vision system for place and object recogni-
tion. In ICCV, 2003. 1

[83] Z. Tu and X. Bai. Auto-context and its application to high-
level vision tasks and 3d brain image segmentation. TPAMI,
32(10):1744–1757, 2010. 1

[84] S. Venugopalan, M. Rohrbach, J. Donahue, R. Mooney,
T. Darrell, and K. Saenko. Sequence to sequence-video to
text. In ICCV, 2015. 2

[85] O. Vinyals, A. Toshev, S. Bengio, and D. Erhan. Show and
tell: A neural image caption generator. arXiv:1411.4555,
2014. 2

[86] J. Von Neumann. First draft of a report on the edvac. IEEE

Annals of the History of Computing, 15(4):27–75, 1993. 4

[87] P. Weinzaepfel, J. Revaud, Z. Harchaoui, and C. Schmid.
Deepﬂow: Large displacement optical ﬂow with deep match-
ing. In ICCV, 2013. 2

[88] R. J. Williams and D. Zipser. Gradient-based learning algo-
rithms for recurrent networks and their computational com-
plexity. Back-propagation: Theory, architectures and appli-

A1. More Qualitative Results

We show more qualitative results in Figure 7 to present
how the current version of SMN reasons with context for
object detection. On the top left, the conﬁdence of skis is
increased due to the detection of person and their relative
location. On the top right, the conﬁdence of tennis racket is
increased despite the motion blur owing to the person and
her pose. Similarly, the backpack on the middle left gains
conﬁdence due to the person carrying it. On the middle
right, we show the example of an occluded sheep detec-
tion. SMN is able to go beyond the overlapping reason-
ing of NMS, which will prevent the sheep in the back from
being detected. On the bottom row, we show two failure
examples, where the potatoes are mistaken as pizza in the
container (left), and the suppression of baby (person) given
the person holding it.

A2. Category-wise Ablative Analysis on VOC

Due to space limit, we excluded category-wise numbers
in the main paper. However, we believe it is interesting to
check the category-wise numbers and get a more insightful
idea for the ablative analysis part (Sec. 6.2, main paper).

In Table 3, we listed our ablative analysis on different
training strategies, but the best mAP we can reach on VOC
is still behind the baseline: for N =5 it is 64.6% compared
to 65.8%; for N =10 it is 67.8% compared to 70.3%. Judg-
ing from the COCO AR metrics, we speculate the issue lies
in recall. This motivates us to take the best SMN Full model
and conduct an investigation speciﬁcally targeting recall.

Turns out, the biggest issue lies in the SoftMax vs.
HardMax strategy. For SMN, we initially deployed a Hard-
Max one: given a bounding box, we proceed with the most
conﬁdent class (and take the bounding box after regression
corresponding to that particular class). This ignores all the
rest classes that are potentially competitive. E.g., on COCO
snowboard is usually confused with skis when buried in the
snow; hot-dog is usually confused with pizza when held in a
person’s hands. Note that this does not cause a problem for
NMS, because the de-duplication is done in a per-class man-
ner. Therefore, for a confusing bounding box where e.g. the
belief for laptop is 50% and keyboard is 35%, NMS can
keep both candidates in the top N detections, whereas for
SMN keyboard is suppressed because laptop has a higher
conﬁdence. While in theory this is not an issue because
SMN can learn to revisit the same region, we ﬁnd it ex-
tremely unlikely to happen in practice, mainly due to the
heavy burden on SMN to learn de-duplication automati-
cally and may also attribute to our current feature design.
To investigate whether it is indeed the case, we added two
ablative experiments: a) using HardMax strategy for base-
line with NMS, meaning an initial proposal can only be se-
lected once – by the most likely class; and b) using Soft-

Figure 7: Four successful reasoning examples and two fail-
ure cases. Please see Sec.A1 for a detailed explanation.

Max for SMN where the ﬁnal N detections can come from
all classes of the N bounding boxes returned by sequential
prediction.

As shown in Table 4, we ﬁnd it worked in both ways:
the recall indeed boosts for SMN when a SoftMax strat-
egy is used; and removing the confusing categories for the
same bounding box hurts the recall for NMS. For COCO,
the improvement on AR metrics directly reﬂects this ﬁnd-
ing, however it is less obvious for VOC. Here we addition-
ally include evidence from category-wise results in Table 5
to corroborate the observation. For example, categories like
cow and sheep get consistent improvements in SMN since
they are more likely to confuse, where as distinctive cate-
gories like person almost remain the same. Overall Soft-
Max outperforms HardMax in most cases.

Normally, k=300 RoIs are selected by NMS (i.e. region
proposal) before feeding into region classiﬁcation. How-
ever, SMN as a sequential prediction method is more vul-
nerable to such an aggressive region selection scheme, be-
cause one miss along the chain can negatively impact all
the follow-up detections. Therefore, in addition to the two
strategies, we also include the analysis on the impact of the
number of regions sampled. Speciﬁcally, we include a non-
aggressive NMS scheme, where the top 5k proposals are
directly selected without NMS.

Table 5: VOC 2007 test object detection average precision. S stands for SoftMax based testing, and H for HardMax. (cid:54)N is
short for Non-aggressive NMS, where top 5k RoIs are directly selected without NMS.

N Method

5
=
N

0
1
=
N

Baseline [12]
SMN Full
Baseline
SMN Full
Baseline
SMN Full
Baseline
SMN Full

Baseline
SMN Full
Baseline
SMN Full
Baseline
SMN Full
Baseline
SMN Full

42.2

42.0

65.4 67.3 71.3 60.1 50.0

65.8 66.8 71.3 66.1 50.0

66.4 66.3 75.3 65.4 53.3

(cid:54)N Max mAP aero bike bird boat bottle bus
(cid:55)
(cid:55)
(cid:55)
(cid:55)
(cid:51)
(cid:51)
(cid:51)
(cid:51)

66.0 67.4 71.2 66.8 51.5

64.6 60.7 71.4 65.3 50.9

65.8 67.4 71.2 66.8 51.2

66.6 65.5 71.4 66.1 54.6

65.4 60.8 71.3 66.1 51.8

S
S
H
H
S
S
H
H

41.7

41.7

41.9

41.7

42.2

41.9

car

cat

chair cow table dog horse mbike persn plant sheep sofa train

tv

74.5 79.6 79.3 42.4 76.3 58.0 77.3 79.4

70.1

42.5

60.0

64.8 75.0 72.2

74.1 79.5 81.9 44.5 72.7 61.9 76.5 77.0

70.1

41.8

63.9

65.5 75.1 71.6

74.6 79.6 79.3 42.4 76.4 57.9 77.2 79.4

70.1

42.5

60.0

64.8 75.1 68.6

74.2 79.4 78.9 42.3 67.9 59.0 75.9 72.4

70.0

41.8

59.6

65.5 75.0 68.1

75.3 79.8 79.1 43.3 76.7 57.6 76.6 79.6

70.3

41.2

60.3

64.7 76.0 71.5

75.2 79.6 82.4 45.8 75.4 63.1 76.6 77.6

70.5

41.0

63.7

64.8 76.0 71.1

75.3 79.8 79.0 43.1 76.7 57.6 76.8 79.6

70.3

41.3

60.3

64.8 75.8 68.2

75.0 79.6 78.4 43.3 75.3 62.8 76.4 78.1

70.5

40.9

59.2

64.4 75.8 67.9

(cid:55)
(cid:55)
(cid:55)
(cid:55)
(cid:51)
(cid:51)
(cid:51)
(cid:51)

S
S
H
H
S
S
H
H

70.3 67.5 78.5 67.1 53.4

54.3

78.0 84.7 84.4 48.9 82.1 66.4 77.3 80.8

77.0

46.1

70.7

64.8 75.0 73.6

69.4 66.8 79.0 69.1 52.3

53.9

73.7 82.8 83.6 46.6 78.5 64.2 76.7 80.2

77.1

44.6

67.2

67.7 75.9 72.7

68.0 67.5 78.5 67.1 50.4

50.3

74.9 79.9 79.4 47.0 77.0 64.8 77.3 80.9

77.0

43.4

67.0

65.1 75.0 69.0

67.8 67.0 79.0 66.6 49.8

49.8

73.8 79.8 79.6 42.5 75.9 64.1 76.7 80.2

77.0

42.6

64.7

66.4 76.0 68.5

70.4 67.5 79.0 67.6 55.2

53.4

78.9 84.5 84.0 49.6 82.0 63.4 80.3 80.6

77.3

44.8

66.7

65.8 78.5 73.2

70.0 68.3 78.1 69.5 55.0

53.6

77.7 85.1 82.5 49.2 78.0 63.8 76.5 80.0

77.5

44.3

67.6

66.6 78.7 71.8

68.8 67.3 79.0 67.5 52.2

49.2

75.3 80.1 79.2 47.6 81.8 63.5 76.5 80.6

77.3

42.1

66.7

64.9 76.0 73.1

68.3 66.2 78.1 66.6 51.7

49.9

75.8 85.0 78.9 47.6 76.1 64.1 76.7 79.9

77.4

42.0

65.1

65.4 76.1 67.9

69.1

69.7

69.3

69.5

69.8

69.2

69.8

69.2

75.2

75.0

69.7

75.1

75.7

76.0

75.4

76.2

Table 6: VOC 2007 test object detection average precision. We use SoftMax and top 5k RoIs during testing for all the
methods compared (except [69]).

Method

FRCNN [69]

Baseline [12]
MLP
SMN

mAP aero bike bird boat bottle bus

car

cat

chair cow table dog horse mbike persn plant sheep sofa train

tv

70.0 68.7 79.2 67.6 54.1

52.3

75.8 79.8 84.3 50.1 78.3 65.1 82.2 84.8

76.0

44.9

70.9

63.3 76.1 72.6

71.2 67.6 78.9 67.6 55.2

56.9

78.8 85.2 83.9 49.8 81.9 65.5 80.1 84.4

70.9 71.7 80.0 70.9 60.0

56.6

78.2 85.0 85.5 47.5 72.7 64.2 76.6 83.5

77.6

77.8

45.3

45.2

70.8

66.9 78.2 72.9

72.3

68.1 76.3 70.4

71.1 67.1 81.2 70.3 55.5

54.0

78.3 85.1 83.7 49.4 80.9 66.1 80.1 83.5

77.7

45.1

69.7

67.1 78.4 72.6

72.9

75.7

75.8

75.7

The result can be found in Table 6. As can be seen, our
method is on-par with baseline and MLP (∼71% mAP).
This difference to COCO is reasonable since compared to
COCO, there is not much “juice” left for context reasoning,
in terms of both quantity (number of images to train SMN
on top of FRCNN) and quality (how difﬁcult the detection
of objects are in the scene).

Note that because the baseline feeds more RoIs (k=300
or k=5, 000) for ﬁnal evaluation, it still bears a subtle ad-
vantage over SMN when testing with HardMax. For exam-
ple, if bounding box B1 suppresses cow over sheep, there is
still chance that a nearby (e.g. meansured by IoU) bound-
ing box B2 where sheep is selected over cow. On the other
hand, SMN gets N (cid:28)k chances for picking the candidates.
This difference is reﬂected when we compare k=300 vs.
k=5, 000 for baseline: SoftMax based testing has a larger
margin over HardMax when k is smaller. Regardless of this,
SMN is still able to achieve on-par (N =10) or better (N =5)
results in terms of mAP.

A3. Final Results on VOC

We also excluded the ﬁnal results on VOC comparing 1)
the baseline FRCNN, 2) the MLP where a 5-layer ConvNet
is directly stacked on top conv5 3 for context aggregation,
and 3) our SMN. We report the results here. For the ﬁnal
evaluation, we use top 5k RoIs for region sampling and the
SoftMax strategy for all methods. Due to the memory limi-
tation, the same idea of ﬁrst using NMS to ﬁnd easy exam-
ples, storing them in the spatial memory and then predicting
with SMN is used (Sec. 6.1). For VOC we set N1=10 and
bootstrap from a N2=10 SMN model, so in total N =20
bounding boxes are sent for evaluation.

