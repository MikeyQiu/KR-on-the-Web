6
1
0
2
 
n
u
J
 
2
 
 
]

G
L
.
s
c
[
 
 
2
v
1
1
0
4
0
.
2
1
5
1
:
v
i
X
r
a

L1-Regularized Distributed Optimization:
A Communication-Efﬁcient Primal-Dual Framework

Virginia Smith
UC Berkeley

Michael I. Jordan
UC Berkeley

Simone Forte
ETH Zürich†

Martin Jaggi
ETH Zürich

Abstract

Despite the importance of sparsity in many large-scale applications, there are few
methods for distributed optimization of sparsity-inducing objectives. In this paper,
we present a communication-efﬁcient framework for L1-regularized optimization
in the distributed environment. By viewing classical objectives in a more general
primal-dual setting, we develop a new class of methods that can be efﬁciently
distributed and applied to common sparsity-inducing models, such as Lasso, sparse
logistic regression, and elastic net-regularized problems. We provide theoretical
convergence guarantees for our framework, and demonstrate its efﬁciency and ﬂex-
ibility with a thorough experimental comparison on Amazon EC2. Our proposed
framework yields speedups of up to 50× as compared to current state-of-the-art
methods for distributed L1-regularized optimization.

1

Introduction

In this paper, we consider standard regularized loss minimization problems, including as our main
focus L1-regularized optimization problems of the form

min
α∈Rn

f (Aα) + λ (cid:107)α(cid:107)1 ,

where α ∈ Rn is the weight vector, A ∈ Rd×n is a given data matrix, and λ is a regularization pa-
rameter. This formulation includes many popular L1-regularized classiﬁcation and regression models,
such as Lasso and sparse logistic regression, and is easily extended to other separable regularizers
like elastic net. Models of this form are particularly useful in high-dimensional settings because
of their tendency to bias learning towards sparse solutions. However, despite their importance, few
methods currently exist to efﬁciently ﬁt such sparsity-inducing models in the distributed environment.
One promising distributed method is COCOA+ [12, 17], a recently proposed primal-dual framework
that demonstrates competitive performance, provides a ﬂexible communication scheme, and enables
the use of off-the-shelf single-machine solvers internally. However, by solving the problem in the dual,
COCOA+ (like SDCA, prox-SDCA, and numerous other primal-dual methods [26, 27, 30, 35, 36]) is
only equipped to handle strongly convex regularizers, which prevents it from being directly applied
to L1-regularized objectives. Moreover, by requiring the data to be distributed by data point rather
than by feature, communication can become a prohibitive bottleneck for COCOA+ as the number of
features grows large, which is precisely the setting of interest for L1 regularization.

In this work, we take a different perspective and propose a framework that can run either in the dual, or
on the primal directly. From this change in perspective we derive several new primal-dual distributed
optimization methods, in particular for sparsity-inducing regularizers. Our approach uses ideas
from COCOA+, though leveraging these ideas in this new setting requires signiﬁcant theoretical and
algorithmic modiﬁcations, particularly in handling non-strongly convex regularizers. The proposed
primal-dual framework and associated rates are novel contributions even in the non-distributed case.

†Parts of this work appear in SF’s Master’s Thesis [10].

1.1 Contributions
Generalized framework. By building on the COCOA+ framework, PROXCOCOA+ comes with
several beneﬁts, including the use of arbitrary local solvers on each machine, and the analysis of and
ability to solve subproblems to arbitrary accuracies. However in contrast to COCOA+, we consider
a much broader class of optimization problems. This results in a more general framework that: (1)
speciﬁcally incorporates the case of L1 regularization; (2) allows for the ﬂexibility of distributing
the data by either feature or data point; and (3) can be run on either the primal or dual formulation,
which we show to have signiﬁcant theoretical and practical implications.

Analysis of non-strongly convex regularizers and losses. We derive convergence rates for the
general class of problems considered in this work, leveraging a novel approach in the analysis of
primal-dual rates for non-strongly convex regularizers. The proposed technique is a signiﬁcant
improvement over simple smoothing techniques used in, e.g., [22, 27, 35] that enforce strong
convexity by adding a small L2 term to the objective. Our results include primal-dual rates and
certiﬁcates for both strongly convex and non-strongly convex regularizers and losses, and we show
how earlier rates of COCOA and COCOA+ can be derived as a special case of our new rates / methods.

Experimental comparison. The proposed framework yields order-of-magnitude speedups (as
much as 50× faster) as compared to other state-of-the-art methods for L1-regularized optimization.
We demonstrate these performance gains in an extensive experimental comparison on real-world
distributed datasets. We additionally show signiﬁcant improvements over COCOA+ when considering
strongly convex objectives. All algorithms for comparison are implemented in Apache Spark and run
on Amazon EC2 clusters. Our code is available at: github.com/gingsmith/proxcocoa.

2 Setup

A great variety of methods in machine learning and signal processing are posed as the minimization
of a weighted sum of two convex functions, where the ﬁrst term is a convex function of a linear
predictor and the second term is a regularizer:

min
α∈Rn

f (Aα) + g(α) .

(A)

Here α ∈ Rn is the parameter vector, and A := [x1; . . . ; xn] ∈ Rd×n is a data matrix with column
vectors xi ∈ Rd, i ∈ [n] and row vectors yT
j ∈ Rn, j ∈ [d]. Our central assumption will be that g(·)
is separable, meaning that

n
(cid:88)

g(α) =

gi(αi)

i=1
for convex functions gi : R → R. Furthermore, we assume f : Rd → R is (1/τ )-smooth for τ > 0.
Examples. The above setting encompasses all convex loss functions depending on linear predictors
yT
j α, together with most common convex regularizers, including all separable functions, such as L1-
or general Lp-norms, or the elastic net given by η
Data partitioning. To map this setup to the distributed environment, we suppose that the dataset A
k=1 of the columns of A ∈ Rd×n. We
is distributed over K machines according to a partition {Pk}K
denote the size of the partition on machine k by nk = |Pk|. For k ∈ [K] and α ∈ Rn, we deﬁne
α[k] ∈ Rn as the n-vector with elements (α[k])i := αi if i ∈ Pk and (α[k])i := 0 otherwise.

2 (cid:107)·(cid:107)2 + (1 − η) (cid:107)·(cid:107)1.

3 The PROXCOCOA+ Algorithmic Framework

The PROXCOCOA+ framework is given in Algorithm 1. This framework builds on the recent COCOA+
framework [12, 17], though with a more general objective, a modiﬁed subproblem, and where we
allow the method to be applied to either the primal or dual formulation. To distribute the method, we
assign each machine to work only on local coordinates of the weight vector α, and access only data
that is stored locally. Machines share state through the vector v := Aα. This vector is communicated
at each round after using local solvers in parallel to ﬁnd (possibly) approximate solutions to the
subproblems deﬁned in (2). Solving the primal problem (A) directly with PROXCOCOA+ will result
in distributing the data column-wise (by feature), and having the vector v be of length equal to the
number of data points. This can greatly reduce communication costs as the number of features grows
(see Section 6). Most importantly, the proposed setup will prepare us to handle non-strongly convex
regularizers in both theory and practice, as we further explain in the following sections.

2

Algorithm 1 PROXCOCOA+ Distributed Framework for Problem (A)
1: Input: Data matrix A distributed column-wise according to partition {Pk}K

parameter γ ∈ (0, 1], and parameter σ(cid:48) for the local subproblems Gσ(cid:48)
Starting point α(0) := 0 ∈ Rn, v(0) := 0 ∈ Rd.

k (∆α[k]; v, α[k]).

k=1, aggregation

2: for t = 0, 1, 2, . . . do
3:
4:

for k ∈ {1, 2, . . . , K} in parallel over computers do

call local solver, returning a Θ-approximate solution ∆α[k] of the local subproblem (2)
update local variables α(t+1)
return updates to shared state ∆vk := A∆α[k]

[k] + γ ∆α[k]

:= α(t)

[k]

5:
6:
7:
8:
9: end for

end for
reduce v(t+1) := v(t) + γ (cid:80)K

k=1 ∆vk

Data-local quadratic subproblems. For each machine, we deﬁne a data-local subproblem of the
original optimization problem (A). This simpler problem can be solved on machine k and only
requires accessing data which is already available locally, i.e., columns Ai such that i ∈ Pk. The
subproblem depends only on the previous shared vector v := Aα and the local data:

min
∆α[k]∈Rn

Gσ(cid:48)
k (∆α[k]; v, α[k]) ,

(1)

where

Gσ(cid:48)
k (∆α[k]; v, α[k]) :=

f (v) + wT A∆α[k] +

1
K

σ(cid:48)
2τ

(cid:13)
(cid:13)
(cid:13)A∆α[k]

(cid:13)
2
(cid:13)
(cid:13)

+

(cid:88)

i∈Pk

gi(αi + ∆α[k]i)

(2)

with w := ∇f (v). We denote the change of local variables αi for indices i ∈ Pk as ∆α[k]. For
a given aggregation parameter γ ∈ (0, 1], the subproblem relaxation parameter σ(cid:48) will be set as
σ(cid:48) := γK, but can also be improved in a data-dependent way as we discuss in Appendix E.

Reusability of existing single-machine solvers. Our local subproblems have the appealing prop-
erty of being very similar in structure to the global problem (A), with the main difference being that
they are deﬁned on a smaller (local) subset of the data. For the user of our framework, this presents
a major advantage in that existing single machine-solvers can be directly re-used in our distributed
framework (Algorithm 1) by employing them on the subproblems Gσ(cid:48)
k . Therefore, problem-speciﬁc
tuned solvers which have already been developed, along with associated speed improvements (such
as multi-core implementations), can be easily leveraged in the distributed setting. We quantify the
dependence on local solver performance in more detail in our convergence analysis (Section 4).

Interpretation. The above deﬁnition of the local objective functions Gσ(cid:48)
k are such that they closely
approximate the global objective in (A) as the “local” variable ∆α[k] varies, which we will see
in the analysis (Lemma 8 in the appendix). In fact, if the subproblem were solved exactly, this
could be interpreted as a data-dependent, block-separable proximal step, applied to the f part of the
objective (A) as follows:

K
(cid:88)

k=1

Gσ(cid:48)
k (∆α[k]; v, α[k]) = L + f (v) + ∇f (v)T A∆α +

∆αT

σ(cid:48)
2τ

AT

[1]A[1]






. . .



0


 ∆α ,

0

AT

[K]A[K]

where L = (cid:80)

i∈[n] gi(αi + ∆αi) .

However, note that in contrast to traditional proximal methods, our algorithm does not assume that
the prox subproblems be solved to high accuracy, as we instead allow the use of local solvers of any
approximation quality Θ. This notion is made precise with the following assumption.

Assumption 1 (Θ-approximate solution, see [17]). We assume that there exists Θ ∈ [0, 1) such that
∀k ∈ [K], the local solver at any outer iteration t produces a (possibly) randomized approximate
solution ∆α[k], which satisﬁes
E(cid:2)Gσ(cid:48)
k (∆α[k]; v, α[k])− Gσ(cid:48)

k (0; v, α[k]) − Gσ(cid:48)
Gσ(cid:48)

[k]; v, α[k])(cid:3) ≤ Θ

[k]; v, α[k])

k (∆α(cid:63)

k (∆α(cid:63)

, (3)

(cid:16)

(cid:17)

3

where

∆α(cid:63)

[k] ∈ arg min
∆α∈Rn

Gσ(cid:48)
k (∆α[k]; v, α[k]) ∀k ∈ [K] .

(4)

Remark 1. In practice, the time spent solving the local subproblems in parallel should be chosen
comparable to the required time of a communication round, for best overall efﬁciency on a given
system. We study this trade-off both in theory (Section 4) and experiments (Section 6).

3.1 Primal-Dual Context

Exploiting primal-dual structure is not a requirement to optimize (A); indeed, we have shown above
how to solve this optimization problem directly. However, noting the relationship between primal and
dual objectives has many beneﬁts, including computation of the duality gap, which allows us to have
a certiﬁcate of approximation quality. It is also useful as an analysis tool and helps relate this work to
the prior work of [30, 12, 17]. To leverage this structure, starting from our original formulation (A)
with objective function D(α) := f (Aα) + (cid:80)n

i=1 gi(αi), the dual problem is given by

(cid:104)

P(w) := f ∗(w) +

g∗
i (−xT

i w)

(cid:105)

.

min
w∈Rd

n
(cid:88)

i=1

(B)

Here w ∈ Rd is a weight vector and xi ∈ Rd are columns of the data matrix A. The functions f ∗, g∗
i
are the convex conjugates of f, gi in the original problem (A). This duality structure is known as
Fenchel-Rockafellar Duality (see [4, Theorem 4.4.2] or a self-contained derivation in the appendix).
Given α ∈ Rn in the context of (A), a corresponding primal vector w ∈ Rd for problem (B) is
obtained by:
w = w(α) := ∇f (Aα) .
(5)
This mapping is given by the ﬁrst-order optimality conditions for the f -part of the objective. (Recall
that we assumed gi : R → R are arbitrary closed convex functions, f : Rd → R is (1/τ )-smooth.)
The duality gap, given by:

i globally deﬁned and Lipschitz [8], as we prove in Section 4.

G(α) := P(w(α)) − (−D(α))
(6)
acts as a certiﬁcate of approximation quality, as the distance to the true optimum P(w(cid:63)) is always
bounded above by the duality gap. A globally deﬁned and ﬁnite duality gap G(α) for any problem (A)
can be obtained by bounding the region of interest for the iterates α. This “Lipschitzing” trick will
make the conjugates g∗
Primal vs. Dual. Previous work of COCOA+ mapped machine learning tasks to P(w) (B), and
then solved this problem in the dual. While this can still be accomplished with the machinery of
PROXCOCOA+ (see Section F), here our main focus is to instead solve the original objective D(α) (A)
directly. This can have a large practical impact for the described applications in the distributed setting,
as it implies that we can distribute the data by feature rather than by data point. Further, we will
communicate a vector equal in size to the number of data points, as opposed to the number of features.
When the number of features is high (as is common in sparsity-inducing models) this can signiﬁcantly
reduce communication and improve overall performance, as we demonstrate in Section 6. Further, it
allows us to directly leverage state-of-the-art coordinate-wise primal methods, such as GLMNET [11]
and extensions [34, 13]. From a theoretical perspective, solving D(α) will allow us to consider
non-strongly convex regularizers, which were not covered in COCOA+, as we discuss in Section 4.

4 Convergence Analysis

In this section we provide convergence rates for the proposed framework, and introduce an important
theoretical technique in analyzing non-strongly convex terms in the primal-dual setting. For simplicity
of presentation, we assume in the analysis that the data partition is balanced; i.e., nk = n/K for
all k. Furthermore, we assume that the columns of A satisfy (cid:107)xi(cid:107) ≤ 1 for all i ∈ [n]. We present
results for the case where γ := 1 in Algorithm 1, and where the subproblems (2) are deﬁned using the
corresponding safe bound σ(cid:48) := K. This case delivers the fastest convergence rates in the distributed
setting, which in particular don’t degrade as the number of machines K grows and n remains ﬁxed.

4.1 General Convex gi

Our ﬁrst main theorem provides convergence guarantees for objectives with non-strongly convex
regularizers, including models such as Lasso and sparse logistic regression. Providing primal-dual

4

rates and globally deﬁned primal-dual accuracy certiﬁcates requires a theoretical technique that we
introduce below, in which we show how to satisfy the following notion of L-bounded support.
Deﬁnition 1 (L-Bounded Support). A function h has L-bounded support if its effective domain is
bounded by L, i.e.,

h(u) < +∞ ⇒ (cid:107)u(cid:107) ≤ L .

(7)

As we explain in Section F of the appendix, our assumption of L-bounded support for the gi functions
can be interpreted as an assumption that their conjugates are globally L-Lipschitz.

Theorem 1. Consider Algorithm 1 with γ := 1, and let Θ be the quality of the local solver as in
Assumption 1. Let gi have L-bounded support, and f be (1/τ )-smooth. Then after T iterations where
(cid:108)
T ≥ T0+ max{

(cid:109)
,

(8)

} ,

1
1 − Θ

4L2n2
τ (cid:15)G(1 − Θ)
(cid:108) 1

(1−Θ) log

, t0 ≥ max(0,

(cid:16) τ (D(α(0))−D(α(cid:63)))
2L2Kn

(cid:17) (cid:109)

) ,

T0 ≥ t0 +

(cid:104)

2
1 − Θ

(cid:18) 8L2n2
τ (cid:15)G

(cid:19) (cid:105)

− 1

+

we have that the expected duality gap satisﬁes

where α is the averaged iterate returned by Algorithm 1.

E[P(w(α)) − (−D(α))] ≤ (cid:15)G ,

Bounded support modiﬁcation. Note that the absolute value function gi = | · | for L1 regular-
ization does not have L-bounded support, and thus violates the assumptions yielding convergence
in Theorem 1. Its dual, the indicator function of the interval, is not deﬁned globally, and thus does
not always allow a ﬁnite duality gap. To address this, existing approaches typically use a simple
smoothing technique as in [22]: by adding a small amount of L2 to the L1-norm, it becomes strongly
convex; see, e.g., [27]. This Nesterov smoothing technique is undesirable in practice, as it changes
the iterates, the convergence rate, and the tightness of the resulting duality gap. Further, the amount
of smoothing can be difﬁcult to tune and can have a large inﬂuence on the performance of the method
at hand. We show examples of this issue with experiments in Section 6.

In contrast, our approach preserves all solutions of the original objective, leaves the iterate sequence
unchanged, and allows for direct reusability of existing L1 solvers. It also removes the need for
additional parameter tuning. To achieve this, we modify the function | · | by imposing an additional
weak constraint that is inactive in our region of interest. Formally, we replace gi(·) = | · | by
(cid:26)|α|

: α ∈ [−B, B]

¯gi(α) :=

+∞ : otherwise.

For large enough B, this problem yields the same solution as the original L1-regularized objective.
Note that this only affects convergence theory, in that it allows us to present a strong primal-dual rate
(Theorem 1 for L=B). The modiﬁcation of gi does not affect the algorithms for the original problems.
Whenever a monotone optimizer is used, we will never leave the level set deﬁned by the objective at
the starting point. We provide further details on this technique in Section D.3, and illustrate how to
leverage it for a variety of applications (see Section C of the appendix and also [8]).

4.2 Strongly Convex gi

For the case of strongly convex gi, including elastic net-regularized objectives, we obtain the following
faster geometric convergence rate.

Theorem 2. Consider Algorithm 1 with γ := 1, and let Θ be the quality of the local solver as in
Assumption 1. Let gi be µ-strongly convex ∀i ∈ [n], and f be (1/τ )-smooth. Then we have that T
iterations are sufﬁcient for suboptimality (cid:15)D, with

T ≥

1
γ(1−Θ)

µτ +n
µτ

log n
(cid:15)D

.

(9)

Furthermore, after T iterations with

We provide proofs of both Theorem 1 and Theorem 2 in the appendix (Section E).

(cid:16)

T ≥

µτ +n
µτ

1
γ(1−Θ)

n
(cid:15)G
E[P(w(α(T ))) − (−D(α(T )))] ≤ (cid:15)G .

1
γ(1−Θ)

µτ +n
µτ

log

(cid:17)

,

5

5 Related Work

Single-machine coordinate solvers. For strongly convex regularizers, current state-of-the-art for
empirical loss minimization is randomized coordinate ascent on the dual (SDCA) [26] and its
accelerated variants, e.g., [27]. In contrast to primal stochastic gradient descent (SGD) methods, the
SDCA family is often preferred as it is free of learning-rate parameters and has faster (geometric)
convergence guarantees. Interestingly, a similar trend in coordinate solvers has been observed in
recent Lasso literature, but with the roles of primal and dual reversed. For those problems, coordinate
descent methods on the primal have become state-of-the-art, as in GLMNET [11] and extensions [34];
see, e.g., the overview in [33]. However, primal-dual convergence rates for unmodiﬁed coordinate
algorithms have to our knowledge been obtained only for strongly convex regularizers to date [27, 35].

Connection to coordinate-wise Newton methods. Coordinate descent on L1-regularized prob-
lems (A) with g(·) = λ(cid:107) · (cid:107)1 can be interpreted as the iterative minimization of a quadratic approx-
imation of the smooth part of the objective (as in a one-dimensional Newton step), followed by a
shrinkage step resulting from the L1 part. In the single-coordinate update case, this is at the core of
GLMNET [11, 33], and widely used in, e.g., solvers based on the primal formulation of L1-regularized
objectives [25, 34, 3, 9, 28]. When changing more than one coordinate at a time, again employing a
quadratic upper bound on the smooth part, this results in a two-loop method as in GLMNET [11] for
the special case of logistic regression. This idea is crucial for the distributed setting.

Parallel coordinate descent. Parallel coordinate descent for L1-regularized objectives (with and
without using mini-batches) was proposed in [7] (Shotgun) and generalized in [3] , and is among
the best performing solvers in the parallel setting. Our framework reduces to Shotgun as a special
case when the internal solver is a single coordinate update on the subproblem (2), γ = 1, and for a
suitable σ(cid:48). However, Shotgun is not covered by our convergence theory, since it uses a potentially
un-safe upper bound β instead of σ(cid:48), which isn’t guaranteed to satisfy the condition (21). Other
parallel coordinate descent methods on the L1-objective have recently been analyzed in [9, 28, 21],
but not in the communication-efﬁcient or distributed setting.

Distributed solvers. The methods most closely related to our approach are distributed variants
of GLMNET as in [18]. Inspired by GLMNET and [34], the work of [3, 18] introduced the idea of a
block-diagonal Hessian upper approximation in the distributed L1 context. The later work of [29]
specialized this approach to sparse logistic regression.
If hypothetically each of our quadratic subproblems Gσ(cid:48)
k (∆α[k]) as deﬁned in (2) were to be min-
imized exactly, the resulting steps could be interpreted as block-wise Newton-type steps on each
coordinate block k, where the Newton-subproblem is modiﬁed to also contain the L1-regularizer
[18, 34, 23]. While [18] allows a ﬁxed accuracy for these subproblems—but not arbitrary approxima-
tion quality Θ as in our framework—the work of [29, 34, 31] assumes that the quadratic subproblems
are solved exactly. Therefore, these methods are not able to freely trade off communication and
computation. Also, they do not allow the re-use of arbitrary local solvers. On the theoretical side, the
rate results provided by [18, 29, 34] are not explicit convergence rates but only asymptotic, as the
quadratic upper bounds are not explicitly controlled for safety as with our σ(cid:48).

Batch solvers. ADMM [5], proximal gradient descent, and quasi-Newton methods such as L-BFGS
and are also often used in distributed environments because of their relatively low communication
requirements. However, they require at least a full (distributed) batch gradient computation at each
round, and therefore do not allow the gradual trade-off between communication and computation
provided by PROXCOCOA+. The works of [19] and [15] have obtained encouraging results for
distributed systems employing coordinate descent variants on L1-problems. The latter approach
distributes both columns and rows of the data matrix and can be extended to Lasso. However it
only provides asymptotic improvement per step, and no convergence rate. We include experimental
comparisons with ADMM, prox-GD, and orthant-wise limited memory quasi-Newton (OWL-QN)
[1], an L-BFGS variant that can handle L1 regularization [32], but which has no convergence rate.
Finally, we note that while the provided convergence rates for PROXCOCOA+ mirror the convergence
class of classical batch gradient methods in terms of the number of outer rounds, existing batch
proximal gradient methods come with a weaker theory, as they do not allow general inexactness Θ
for the local subproblem (2). In contrast, our shown convergence rates incorporate this approximation
directly, and, moreover, hold for arbitrary local solvers of much cheaper cost than batch methods
(where in each round, every machine has to process exactly a full pass through the local data). This

6

Figure 1: Suboptimality in terms of D(α) for solving Lasso regression for: url (K=4, λ=1E-4), kddb (K=4,
λ=1E-6), epsilon (K=8, λ=1E-5), and webspam (K=16, λ=1E-5) datasets. PROXCOCOA+ applied to the primal
formulation converges more quickly than all other compared methods in terms of the time in seconds.

makes PROXCOCOA+ more ﬂexible in the distributed setting, as it can adapt to varied communication
costs on real systems. We will see in the following section that this ﬂexibility results in signiﬁcant
performance gains over the competing methods.

6 Experimental Results

In this section we compare PROXCOCOA+ to numerous state-of-the-art methods for large-scale
L1-regularized optimization, including:

• MB-SGD: mini-batch stochastic gradient

• ADMM: alternating direction method

descent with an L1-prox

of multipliers

• PROX-GD: full proximal gradient descent
• OWL-QN: orthant-wise limited quasi-Newton

• MB-CD: mini-batch parallel coordinate

descent, incl. SHOTGUN

The ﬁrst three methods are optimized and implemented in Apache Spark’s MLlib (v1.5.0) [20]. We
employ coordinate descent as a local solver for PROXCOCOA+, and apply PROXCOCOA+ directly
to the primal formulation of Lasso and elastic net, thereby mapping the problem to (A) and solving
this objective directly. A comparison with SHOTGUN is provided as an extreme case to highlight the
detrimental effects of frequent communication in the distributed environment.

We test the performance of each method in large-scale experiments ﬁtting Lasso and elastic net
regression models to the datasets shown in Table 1. All code is written in Apache Spark and
experiments are run on public cloud Amazon EC2 m3.xlarge machines with one core per machine.
For MB-CD, SHOTGUN, and PROXCOCOA+ in the primal, datasets are distributed by feature, whereas
for MB-SGD, PROX-GD, OWL-QN, ADMM, and COCOA+ they are distributed by datapoint.
We carefully tune each competing method for best
performance. ADMM requires the most tuning,
both in selecting the penalty parameter ρ and in solv-
ing the subproblems. Solving the subproblems to
completion for ADMM is prohibitively slow, and
we thus use iterations of conjugate gradient and im-
prove performance by allowing early stopping. We
also use a varying penalty parameter ρ — practices
described in [5, Sec. 4.3, 3.4.1]. For MB-SGD, we
tune the step size and mini-batch size parameters. For MB-CD, we scale the updates at each round
by β
b for mini-batch size b and β ∈ [1, b], and tune both parameters b and β. Further implementation
details for all methods are given in the appendix (Section G).

Dataset
url
epsilon
kddb
webspam

Training
2 M
400 K
19 M
350 K

Features
3 M
2 K
29 M
16 M

Sparsity
3.5e-5
1.0
9.8e-7
2.0e-4

Table 1: Datasets for Empirical Study

Comparison with L1 methods.
In analyzing the performance of each algorithm (Figure 1), we
measure the improvement to the primal objective given in (A) (D(α)) in terms of wall-clock time
in seconds. We see that both MB-SGD and MB-CD are slow to converge, and come with the
additional burden of having to tune extra parameters (though MB-CD makes clear improvements over
MB-SGD). As expected, naively distributing SHOTGUN [7] (single coordinate updates per machine)
does not perform well, as it is tailored to shared-memory systems and requires communicating
too frequently. OWL-QN performs the best of all compared methods, but is still much slower to
converge than PROXCOCOA+, converging, e.g., 50× more slowly for the webspam dataset. The
optimal performance of PROXCOCOA+ is particularly evident in datasets with large numbers of
features (e.g., url, kddb, webspam), which are exactly the datasets of interest for L1 regularization.

7

Figure 2: Suboptimality in terms of D(α) for solving
Lasso for the epsilon dataset (left, K=8) and elastic
net for the url dataset, (right, K=4, λ=1E-4). Speedup
are robust over different regularizers λ (left), and
across problem settings, including varying η parame-
ters of elastic net regularization (right).

Figure 3: Suboptimality in terms of D(α) for solving
Lasso for the webspam dataset (K=16, λ=1E-5). Here
we illustrate how the work spent in the local subprob-
lem (given by H) inﬂuences the total performance of
PROXCOCOA+ in terms of number of rounds as well
as wall time.

Results are shown for regularization parameters λ such that the resulting weight vector α is sparse.
However, our results are robust to varying values of λ as well as to various problem settings, as we
illustrate in Figure 2.

We note that in contrast to the compared meth-
ods, PROXCOCOA+ comes with the beneﬁt of
having only a single parameter to tune: the sub-
problem approximation quality, Θ, which can be
controlled via the number of local subproblem
iterations, H. We further explore the effect of
this parameter in Figure 3, and provide a gen-
eral guideline for choosing it in practice (see
Remark 1). In particular, we see that while in-
creasing H always results in better performance
in terms of rounds, smaller or larger values of
H may result in better performance in terms of
wall-clock time, depending on the cost of com-
munication and computation. The ﬂexibility to
tune H is one of the reasons for PROXCOCOA+’s
signiﬁcant performance gains.

(4a)

(4b)

Sparsity of ﬁnal iterates in (4b)

PROXCOCOA+
0.6030

δ = 0.0001

δ = 0.001

δ = 0.01

0.6035

0.6240

0.6465

(4c)
Figure 4: COCOA+ is ill-equipped to deal with large
feature sizes as compared to PROXCOCOA+, and the
gap in performance increases as the regularizer be-
comes less strongly convex, e.g., as η → 1.0 for elastic
net (4a). For pure L1 regularization, Nesterov smooth-
ing is not an effective option for COCOA+. It either
modiﬁes the solution (4c) or slows convergence (4b).

Comparison with COCOA+. Finally, we
point out several
important ways in which
PROXCOCOA+ improves upon the COCOA+
framework [17]. First, COCOA+ cannot be in-
cluded in the set of experiments in Figure 1 because it cannot be directly applied to the Lasso
objective (COCOA+ only allows for strongly convex regularizers1). Second, as shown in Figure 4,
the performance of COCOA+ degrades drastically when considering datasets with large numbers
of features, such as the webspam dataset. One reason for this is that COCOA+ distributes data by
data point, which necessitates communicating a vector of length equal to the feature size. When the
feature size is large, this can become expensive. The results shown hold despite the fact that we have
tuned H (the number of local solver iterations) separately for both PROXCOCOA+ and COCOA+.
Beyond communication, we also see that COCOA+ is slower to converge as the regularizer becomes
less strongly convex (Figure 4a). Indeed, even when the number of features is relatively low such as for
the epsilon dataset, we see that the performance of COCOA+ degrades signiﬁcantly as the regularizer
approaches pure L1. In Figure 4, we illustrate this by implementing the Nesterov smoothing technique
used in, e.g., [27, 35] — adding a small amount of strong convexity δ(cid:107)α(cid:107)2
2 to the objective for Lasso
regression. We show results for decreasing levels of δ. As δ decreases, the ﬁnal sparsity of the
problem starts to match that of running pure L1 (Figure 4c), but the performance also degrades
(Figure 4b). We note again that through the modiﬁcation presented in Section 4, we can deliver strong
rates without having to make these fundamental alterations to the problem of interest.

1COCOA+ in [17] is in fact limited to the case where the regularizer is equal to the L2 norm 1

the extension to strongly convex regularizers is covered as a special case in our analysis.

2 (cid:107) · (cid:107)2

2, though

8

We thank Michael P. Friedlander and Martin Takáˇc for fruitful discussions.

Acknowledgments

References

[1] G. Andrew and J. Gao. Scalable training of L1-regularized log-linear models. In ICML, 2007.
[2] H. H. Bauschke and P. L. Combettes. Convex Analysis and Monotone Operator Theory in Hilbert Spaces.

CMS Books in Mathematics. Springer New York, New York, NY, 2011.

[3] Y. Bian et al. Parallel coordinate descent newton method for efﬁcient g1-regularized minimization.

arXiv.org, 2013.

[4] J. M. Borwein and Q. Zhu. Techniques of Variational Analysis and Nonlinear Optimization. Canadian

Mathematical Society Books in Math, Springer New York, 2005.

[5] S. Boyd et al. Distributed optimization and statistical learning via the alternating direction method of

multipliers. Foundations and Trends in Machine Learning, 3(1):1–122, 2010.

[6] S. Boyd and L. Vandenberghe. Convex Optimization. Cambridge University Press, 2004.
[7] J. K. Bradley et al. Parallel coordinate descent for l1-regularized loss minimization. In ICML, 2011.
[8] C. Dünner et al. Primal-Dual Rates and Certiﬁcates. In ICML, 2016.
[9] O. Fercoq and P. Richtárik. Accelerated, Parallel, and Proximal Coordinate Descent. SIAM Journal on

Optimization, 25(4):1997–2023, Oct. 2015.

[10] S. Forte. Distributed Optimization for Non-Strongly Convex Regularizers. Master’s thesis, ETH Zürich,

Sept. 2015.

ICML, 2015.

[11] J. Friedman, T. Hastie, and R. Tibshirani. Regularization paths for generalized linear models via coordinate

descent. Journal of Statistical Software, 33(1):1–22, 2010.

[12] M. Jaggi et al. Communication-efﬁcient distributed dual coordinate ascent. In NIPS, 2014.
[13] T. Johnson and C. Guestrin. Blitz: A Principled Meta-Algorithm for Scaling Sparse Optimization. In

[14] S. M. Kakade, S. Shalev-Shwartz, and A. Tewari. On the duality of strong convexity and strong smoothness:

Learning applications and matrix regularization. Technical report, TTI, 2009.

[15] Kang et al. Data/feature distributed stochastic coordinate descent for logistic regression. In CIKM, 2014.
[16] Z. Lu and L. Xiao. On the complexity analysis of randomized block-coordinate descent methods. arXiv.org,

[17] C. Ma et al. Adding vs. averaging in distributed primal-dual optimization. In ICML, 2015.
[18] D. Mahajan, S. S. Keerthi, and S. Sundararajan. A distributed block coordinate descent method for training

l1 regularized linear classiﬁers. arXiv.org, 2014.

[19] H. B. McMahan et al. Ad click prediction: a view from the trenches. In KDD, 2013.
[20] X. Meng et al. Mllib: Machine learning in apache spark. arXiv.org, 2015.
[21] I. Necoara and D. Clipici. Parallel Random Coordinate Descent Method for Composite Minimization:
Convergence Analysis and Error Bounds. SIAM Journal on Optimization, 26(1):197–226, Jan. 2016.
[22] Y. Nesterov. Smooth minimization of non-smooth functions. Mathematical Programming, 103(1):127–152,

[23] Z. Qu et al. SDNA: Stochastic dual newton ascent for empirical risk minimization. arXiv.org, 2015.
[24] R. T. Rockafellar. Convex Analysis. Princeton University Press, 1997.
[25] S. Shalev-Shwartz and A. Tewari. Stochastic methods for l1-regularized loss minimization. Journal of

Machine Learning Research, 12:1865–1892, 2011.

[26] S. Shalev-Shwartz and T. Zhang. Stochastic dual coordinate ascent methods for regularized loss minimiza-

tion. Journal of Machine Learning Research, 14:567–599, 2013.

[27] S. Shalev-Shwartz and T. Zhang. Accelerated proximal stochastic dual coordinate ascent for regularized

loss minimization. Mathematical Programming, Series A:1–41, 2014.

[28] R. Tappenden and P. Richtárik. On the complexity of parallel coordinate descent. arXiv.org, 2015.
[29] I. Troﬁmov and A. Genkin. Distributed coordinate descent for l1-regularized logistic regression. arXiv.org,

[30] T. Yang. Trading computation for communication: Distributed stochastic dual coordinate ascent. In NIPS,

2013.

2005.

2014.

2013.

[31] I. E.-H. Yen, S.-W. Lin, and S.-D. Lin. A Dual Augmented Block Minimization Framework for Learning

with Limited Memory. In NIPS, 2015.

[32] J. Yu, S. Vishwanathan, S. Günter, and N. N. Schraudolph. A quasi-newton approach to nonsmooth convex

optimization problems in machine learning. Journal of Machine Learning Research, 2010.

9

[33] G.-X. Yuan et al. A comparison of optimization methods and software for large-scale l1-regularized linear

classiﬁcation. Journal of Machine Learning Research, 2010.

[34] G.-X. Yuan, C.-H. Ho, and C.-J. Lin. An improved glmnet for l1-regularized logistic regression. Journal

[35] Y. Zhang and X. Lin. Stochastic Primal-Dual Coordinate Method for Regularized Empirical Risk Mini-

[36] S. Zheng et al. A general distributed dual coordinate optimization framework for regularized loss mini-

of Machine Learning Research, 2012.

mization. In ICML, 2015.

mization. In arXiv.org, 2016.

10

Appendix

A Deﬁnitions

Deﬁnition 2 (L-Lipschitz Continuity). A function f : Rd → R is L-Lipschitz continuous if ∀a, b ∈
Rd, we have

|f (a) − f (b)| ≤ L(cid:107)a − b(cid:107) .
(10)
Deﬁnition’ 1 (L-Bounded Support). A function f : Rd → R has L-bounded support if its effective
domain is bounded by L, i.e.,

f (u) < +∞ ⇒ (cid:107)u(cid:107) ≤ L .
(11)
Deﬁnition 3 (L-Smoothness). A function f : Rd → R is called L-smooth, for L > 0, if it is
differentiable and its derivative is L-Lipschitz continuous, or equivalently

f (u) ≤ f (w) + (cid:104)∇f (w), u − w(cid:105) +

(cid:107)u − w(cid:107)2

∀u, w ∈ Rd .

Deﬁnition 4 (µ-Strong Convexity). A function f : Rd → R is called µ-strongly convex, for µ ≥ 0, if

f (u) ≥ f (w) + (cid:104)∇f (w), u − w(cid:105) +

(cid:107)u − w(cid:107)2

∀u, w ∈ Rd .

And analogously if the same holds for all subgradients, in the case of a general closed convex
function f .

L
2

µ
2

B Convex Conjugates

The convex conjugate of a function f : Rd → R is deﬁned as

f ∗(v) := max
u∈Rd

vT u − f (u) .

Below we list several useful properties of conjugates (see, e.g., [6, Section 3.3.2]):

• Double conjugate:

(f ∗)∗ = f if f is closed and convex.

• Value Scaling: (for α > 0)

f (v) = αg(v)

⇒

f ∗(w) = αg∗(w/α) .

• Argument Scaling: (for α (cid:54)= 0)

• Conjugate of a separable sum:

f (v) = g(αv)
f (v) = (cid:80)

i φi(vi)

⇒

⇒

f ∗(w) = g∗(w/α) .
f ∗(w) = (cid:80)
i φ∗

i (wi) .

Lemma 3 (Duality between Lipschitzness and L-Bounded Support, [24, Corollary 13.3.3]). Given a
proper convex function f , it holds that f is L-Lipschitz if and only if f ∗ has L-bounded support.

Lemma 4 (Duality between Smoothness and Strong Convexity, [14, Theorem 6]). Given a closed
the norm (cid:107) · (cid:107) if and only if f ∗ is
convex function f , it holds that f is µ strongly convex w.r.t.
(1/µ)-smooth w.r.t. the dual norm (cid:107) · (cid:107)∗.

(12)

(13)

(14)

C Applications

C.1 L1 and General Non-Strongly Convex Regularizers

L1 regularization is obtained in the objective (A) by letting gi(·) := λ| · |. Primal-dual convergence
can be obtained by using the modiﬁcation introduced in Section 4, which will guarantee L-bounded
support. Formally, we replace gi(·) = | · | by

¯g(α) :=

(cid:26)|α|

: α ∈ [−B, B]

+∞ : otherwise.

For large enough B, this problem yields the same solution as the original L1-objective. We provide a
detailed proof and description of this technique in Section D.3. Note that this only affects convergence
theory, in that it allows us to present a strong primal-dual rate (Theorem 1 for L=B).

11

C.2 Elastic Net and General Strongly Convex Regularizers

2 (cid:107)α(cid:107)2
Another application we can consider is elastic net regularization, η
2 + (1 − η) (cid:107)α(cid:107)1, for ﬁxed
parameter η ∈ (0, 1], which is obtained by setting gi(α) := λ(cid:2) η
2 α2 + (1 − η)|α|(cid:3) in (A). For the
special case η = 0, we obtain the L1-norm. For elastic-net-regularized problems of the form (A),
Theorem 2 gives a global linear (geometric) convergence rate, since gi is η-strongly convex. This
holds as long as the data-ﬁt function is smooth (see Section C.4), and directly yields a primal-dual
algorithm and corresponding rate.

C.3 Local Solvers for L1 and Elastic Net

For the L1-regularizer in the primal setting, the local subproblem (2) becomes a simple quadratic
problem on the local data, with regularization applied only to local variables α[k]. Therefore, existing
fast L1-solvers for the single-machine case, such as GLMNET variants [11] or BLITZ [13] can be
directly applied to each local subproblem Gσ(cid:48)
k ( · ; v, α[k]) within Algorithm 1. The sparsity induced
on the subproblem solutions of each machine naturally translates into the sparsity of the global
solution, since the local variables α[k] will be concatenated.
In terms of the approximation quality parameter Θ for the local problems (Assumption 1), we can
apply existing recent convergence results from the single machine case. For example, for randomized
coordinate descent (as part of GLMNET), [16, Theorem 1] gives a O(1/t) approximation quality for
any separable regularizer, including L1 and elastic net; see also [28, 25].

C.4 Smooth Data-Fit Functions

To illustrate the role of f as a smooth data-ﬁt function in this section—contrasting with its role as a
regularizer in traditional COCOA+ as we discuss in Section F—we consider the following examples.
Least squares loss. Let b ∈ Rd be labels or response values, and consider the least squares
objective f (v) := 1
2 (cid:107)v − b(cid:107)2
2, which is 1-smooth. We obtain the familiar least-squares regression
objective in our optimization problem (A), using
f (Aα) := 1

2 (cid:107)Aα − b(cid:107)2
2 .

Observing that the gradient of f is ∇f (v) = v − b, the dual-to-primal mapping is given by: w(α)
:= ∇f (v(α)) = Aα − b, which is well known as the residual vector in least-squares regression.

Logistic regression loss. For classiﬁcation problems, we consider a logistic regression model with
d training examples yj ∈ Rn for j ∈ [d] collected as the rows of the data matrix A. For each training
example, we are given a binary label, which we collect in the vector b ∈ {−1, 1}d. Formally, the
objective is deﬁned as f (v) := (cid:80)d
j=1 log (1 + exp (−bjvj)), which is again a separable function.
The classiﬁer loss is given by

f (Aα) :=

log (1 + exp (−bjyT

j α)) ,

(15)

d
(cid:88)

j=1

where α ∈ Rn is the parameter vector. It is not hard to show that f is 1-smooth if the labels satisfy
bj ∈ [−1, 1]; see e.g. Lemma 5 below. The primal-dual mapping w(α) := ∇f (v(α)) = ∇f (Aα)
is given by wj(α) =

−bj

1+exp (bj yT

j α) .

D Proofs of Primal-Dual Relationship

In the following subsections we provide derivations of the primal-dual relationship of the general
objectives (A) and (B), and then show how to derive this primal-dual setup for various applications.

D.1 Primal-Dual Relationship

The relation of our original formulation (A) to its dual formulation (B) is standard in convex analysis,
and is a special case of the concept of Fenchel Duality. Using the combination with the linear map
A as in our case, the relationship is called Fenchel-Rockafellar Duality, see e.g. [4, Theorem 4.4.2]
or [2, Proposition 15.18]. For completeness, we illustrate this correspondence with a self-contained
derivation of the duality.

12

Starting with the original formulation (A), we introduce a helper variable vector v ∈ Rd representing
v = Aα. Then optimization problem (A) becomes:

min
α∈Rn

f (v) + g(α)

such that v = Aα .

(16)

Introducing Lagrange multipliers w ∈ Rd, the Lagrangian is given by:

L(α, v; w) := f (v) + g(α) + wT (Aα − v) .

The dual problem of (A) follows by taking the inﬁmum with respect to both α and v:

inf
α,v

L(w, α, v) = inf
v

(cid:8)f (v) − wT v(cid:9) + inf

(cid:8)g(α) + wT Aα(cid:9)

= − sup

(cid:8)wT v − f (v)(cid:9) − sup

(cid:8)(−wT A)α − g(α)(cid:9)

α

α

(17)
We change signs and turn the maximization of the dual problem (17) into a minimization and thus we
arrive at the dual formulation (B) as claimed:

= −f ∗(w) − g∗(−AT w) .

P(w) := f ∗(w) + g∗(−AT w)

(cid:105)

.

min
w∈Rd

v

(cid:104)

D.2 Conjugates and Smoothness of f -Functions of Interest

Lemma 5 (Conjugate and Smoothness of the Logistic Loss). The logistic classiﬁer loss function

f (Aα) :=

log (1 + exp (−bjyT

j α))

d
(cid:88)

j=1

(see also (15) above) is the conjugate of f ∗, where

f ∗(w) :=

(cid:0)(1 + wjbj) log (1 + wjbj) − wjbj log (−wjbj)(cid:1) ,

(18)

d
(cid:88)

j=1

with the box constraint −wjbj ∈ [0, 1].
Furthermore, f ∗(w) is 1-strongly convex over its domain if the labels satisfy bj ∈ [−1, 1].

Proof of Lemma 5. By separability of f ∗, the conjugate of f ∗(v) = (cid:80)
(cid:80)

j φj(wj). For the losses, the conjugate pairs are φj(u) = log(1 + exp(−bju)), and φ∗
−wjbj log(−wjbj) + (1 + wjbj) log(1 + wjbj) with −wjbj ∈ [0, 1], see e.g. [26, Page 577].

j (vj) is f (w) =
j (wj) =

j φ∗

the strong convexity, we show 1-strong smoothness of

j=1 log (1 + exp (−bjvj)) = (cid:80)d

For
(cid:80)d
Using the second derivative h(cid:48)(cid:48)(a) = e−a
that ∇2f (v) = diag(cid:0)(h(cid:48)(cid:48)(bjvj)b2
the Euclidean norm.

j )j

:=
j=1 h(bjvj), which is an equivalent property, see Lemma 4.
(1+e−a)2 ≤ 1 of the function h(a) = log(1 + e−a), we have
(cid:1) = diag(cid:0)(
(cid:1) ≤ 1, so f (v) is 1-smooth w.r.t.

the conjugate f (v)

e−bj vj
(1+e−bj vj )2 b2
j )j

D.3 Conjugates of Common Regularizers

Lemma 6 (Conjugate of the Elastic Net Regularizer). For η ∈ (0, 1], the elastic net function
gi(α) := η

2 α2 + (1 − η)|α| is the convex conjugate of

g∗
i (x) := 1
2η

(cid:0)(cid:2)|x| − (1 − η)(cid:3)

(cid:1)2

,

+

where [.]+ is the positive part operator, [s]+ = s for s > 0, and zero otherwise. Furthermore, this g∗
is smooth, i.e. has Lipschitz continuous gradient with constant 1/η.

Proof. We start by applying the deﬁnition of convex conjugate, that is:
(cid:105)
g∗(x) = maxα∈R

(cid:104)
xα − η α2

2 − (1 − η)|α|

.

We now distinguish two cases for the optimal: α(cid:63) ≥ 0, α(cid:63) < 0. For the ﬁrst case we get that
(cid:104)

(cid:105)

g∗(x) = maxα∈R

xα − η α2

2 − (1 − η)α

.

13

Setting the derivative to 0 we get α(cid:63) = x−(1−η)
Replacing with α(cid:63) we thus get:
g∗(x) = α(cid:63)(x − 1

η

2 ηα(cid:63) − (1 − η)) = α(cid:63) (cid:0)x − 1
2 α(cid:63) (x − (1 − η)) = 1

1

2η (x − (1 − η))2 .

2 (x − (1 − η)) − (1 − η)(cid:1) =

. To satisfy α(cid:63) ≥ 0, we must have x ≥ 1 − η.

Similarly we can show that for x ≤ −(1 − η)
g∗(x) = 1

2η (x + (1 − η))2 .

Finally, by the fact that g∗(.) is convex, always positive, and g∗(−(1 − η)) = g∗(1 − η) = 0, it
follows that g∗(x) = 0 for every x ∈ [−(1 − η), 1 − η].
For the smoothness properties, we consider the derivative of this function g∗(x) and see that g∗(x) is
smooth, i.e. has Lipschitz continuous gradient with constant 1/η, assuming η > 0.

Continuous conjugate modiﬁcation for indicator functions. To apply the theoretical conver-
gence result from Theorem 1 to objectives with L1 norms, we modify the function | · | by imposing
an additional constraint. Consider replacing gi(·) = | · | by

¯g(α) :=

(cid:26)|α|

: α ∈ [−B, B]

+∞ : otherwise.

min
α∈Rn

f (Aα) + λ

¯g(αi) .

n
(cid:88)

i=1

With this modiﬁed L1-regularizer, the optimization problem (A) with regularization parameter λ
becomes

(19)

(20)

For large enough choice of the value B, this problems yields the same solution as the original
objective:

(cid:104)

min
α∈Rn

D(α) := f (Aα) + λ

(cid:105)

.

|αi|

n
(cid:88)

i=1

As we can see, the ¯g is nothing more than a constrained version of the absolute value to the interval
[−B, B]. Therefore by setting B to a large enough value that the interesting values of αi will never
reach, we can have continuous ¯g∗ and at the same time make (19) equivalent to (20).

Formally, a simple way to obtain a large enough value of B, so that all solutions of (20) are unaffected
is the following. Note that we start the algorithm at α = 0. For every solution encountered during
the execution of the algorithm, the objective values should never become worse than D(0). In other
words, we restrict the D(·) optimization problem to the level set given by the initial starting value.
Formally, this means that for every i, we will always require:

λ|αi| ≤ f (0) = D(0) =⇒ |αi| ≤

f (0)
λ

.

(Note that f (α) ≥ 0 holds without loss of generality). We can thus set the value of B to be f (0)
λ .

Lemma 7 (Conjugate of the modiﬁed L1-norm). The convex conjugate of ¯gi as deﬁned above is

(cid:26)0

¯g∗(x) =

B(|x| − 1)

: x ∈ [−1, 1]
: otherwise,

and is B-Lipschitz.

Proof. We start by applying the deﬁnition of convex conjugate:
[αx − ¯g∗(x)] .

¯g(α) = sup
x∈R

We begin by looking at the case in which α ≥ B; in this case it’s easy to see that when x → +∞, we
have:

αx − B(|x| − 1) = (α − B)x − B → +∞
as α − B ≥ 0. The case α ≤ −B holds analogously. We’ll now look at the case α ∈ [0, B]; in this
case it is clear we must have x(cid:63) ≥ 0. It also must hold that x(cid:63) ≤ 1, since

for every x > 1. Therefore the maximization becomes

αx − B(x − 1) < αx

14

which has maximum α at x = 1. The remaining α ∈ [−B, 0] case follows in similar fashion.

¯g(α) = sup
x∈[0,1]

αx ,

E Convergence Proofs

In this section we provide proofs of our main convergence results. The results are motivated by [17],
but where we have signiﬁcantly generalized the problem of interest, and where we derive separate
meaning by applying the problem directly to (A). We provide full details of Lemma 8 as a proof of
concept, but omit details in later proofs that can be derived using the arguments in [17] or earlier
work of [26], and instead outline the proof strategy and highlight sections where the theory deviates.

E.1 Approximation of D(·) by the Local Subproblems Gσ(cid:48)

k (·)

We begin with a deﬁnition of the data-dependent aggregation parameter for PROXCOCOA+, σ(cid:48), which
we will use in the throughout our convergence results.
Deﬁnition 5 (Data-dependent aggregation parameter). In Algorithm 1, the aggregation parameter γ
controls the level of adding (γ := 1) versus averaging (γ := 1
K ) of the partial solutions from all
machines. For the convergence results discussed below to hold, the subproblem parameter σ(cid:48) must be
chosen not smaller than

σ(cid:48) ≥ σ(cid:48)

min := γ max
α∈Rn

(cid:107)Aα(cid:107)2
k=1 (cid:107)Aα[k](cid:107)2

(cid:80)K

.

(21)

The simple choice of σ(cid:48) := γK is valid for (21), i.e.,
γK ≥ σ(cid:48)

min .

In some cases, it will be possible to give better (data-dependent) choices for σ(cid:48), closer to the actual
bound given in σ(cid:48)

min.

Our ﬁrst lemma in the overall proof of convergence helps to relate change in local subproblems to the
global objective D(·).
Lemma 8. For any dual α, ∆α ∈ Rn, v = v(α) := Aα, and real values γ, σ(cid:48) satisfying (21), it
holds that

(cid:16)

D

α + γ

(cid:17)
∆α[k]

K
(cid:88)

k=1

≤ (1 − γ)D(α) + γ

Gσ(cid:48)
k (∆α[k]; v, α[k]) .

(22)

Proof. In this proof we follow the line of reasoning in [17, Lemma 4] with a more general (1/τ )
smoothness assumption on f (·). An outer iteration of PROXCOCOA+ performs the following update:

D(α + γ

∆α[k]) = f (v(α + γ

∆α[k]))

+

gi(αi + γ(

∆α[k])i)

.

(23)

K
(cid:88)

k=1

K
(cid:88)

k=1
(cid:123)(cid:122)
A

(cid:124)

K
(cid:88)

k=1

(cid:123)(cid:122)
B

(cid:125)

We bound the terms A and B separately. First we bound A using (1/τ )-smoothness of f :

(cid:16)

(cid:17)

(cid:16)

A = f

v(α + γ

∆α[k])

= f

v(α) + γ

v(∆α[k])

(cid:17)

K
(cid:88)

k=1

smoothness of f as in (12)
≤

f (v(α)) +

γ∇f (v(α))T v(∆α[k]) +

v(α[k])(cid:107)2

K
(cid:88)

k=1

n
(cid:88)

i=1
(cid:124)

(cid:125)

K
(cid:88)

k=1

deﬁnition of w as in (5)
≤

f (v(α)) +

γv(∆α[k])T w(α) +

v(α[k])(cid:107)2

safe choice of σ(cid:48) as in (21)
≤

f (v(α)) +

γv(∆α[k])T w(α) +

γσ(cid:48)

(cid:107)v(α[k])(cid:107)2 .

K
(cid:88)

k=1

K
(cid:88)

k=1

K
(cid:88)

k=1

15

γ2
2τ

(cid:107)

K
(cid:88)

k=1

γ2
2τ

(cid:107)

K
(cid:88)

k=1

1
2τ

K
(cid:88)

k=1

Next we use Jensen’s inequality to bound B:

(cid:32)

K
(cid:88)

(cid:88)

k=1

i∈Pk

B =

gi(αi + γ(∆α[k])i)

=

gi((1 − γ)αi + γ(α + ∆α[k])i)

(cid:33)

(cid:33)

(1 − γ)gi(αi) + γgi(αi + ∆α[k]i)

.

(cid:33)

(cid:32)

K
(cid:88)

(cid:88)

k=1

K
(cid:88)

(cid:32)

i∈Pk

(cid:88)

k=1

i∈Pk

≤

Plugging A and B back into (23) yields:

(cid:16)

D

α + γ

(cid:17)

∆α[k]

K
(cid:88)

k=1

K
(cid:88)

k=1

≤ f (v(α)) ± γf (v(α)) +

γv(∆α[k])T w(α) +

γσ(cid:48)

(cid:107)v(α[k])(cid:107)2

1
2τ

K
(cid:88)

k=1

(1 − γ)gi(αi) + γgi(αi + ∆α[k]i)

= (1 − γ)f (v(α)) +

(1 − γ)gi(αi)

(cid:32)

K
(cid:88)

(cid:88)

i∈Pk

k=1
(cid:123)(cid:122)
(1−γ)D(α)

K
(cid:88)

(cid:88)

+

k=1

i∈Pk

(cid:124)

+ γ

(cid:32)

K
(cid:88)

k=1

1
K

(cid:33)

(cid:125)

σ(cid:48)
2τ

(2)= (1 − γ)D(α) + γ

Gσ(cid:48)
k (∆α[k]; v) ,

K
(cid:88)

k=1

f (v(α)) + v(∆α[k])T w(α) +

(cid:107)v(α[k])(cid:107)2 +

gi(αi + ∆α[k]i)

(cid:33)

(cid:88)

i∈Pk

where the last equality is by the deﬁnition of the subproblem objective Gσ(cid:48)

k (.) as in (2).

E.2 Proof of Main Convergence Result (Theorem 1)

Before proving the main convergence results, we introduce several useful quantities, including the
the following lemma, which characterizes the effect of iterations of Algorithm 1 on the duality gap
for any chosen local solver of approximation quality Θ.
Lemma 9. Let gi be strongly2 convex with convexity parameter µ ≥ 0 with respect to the norm (cid:107) · (cid:107),
∀i ∈ [n]. Then for all iterations t of Algorithm 1 under Assumption 1, and any s ∈ [0, 1], it holds that

E[D(α(t)) − D(α(t+1))] ≥ γ(1 − Θ)

sG(α(t)) −

(cid:16)

σ(cid:48)s2
2τ

R(t)(cid:17)

,

R(t) := − τ µ(1−s)

(cid:107)u(t) − α(t)(cid:107)2 + (cid:80)K

σ(cid:48)s

k=1(cid:107)A(u(t) − α(t))[k](cid:107)2 ,

where

for u(t) ∈ Rn with

u(t)
i ∈ ∂g∗

i (−xT

i w(α(t))) .

(24)

(25)

(26)

Proof. The line of proof is motivated by [26, Lemma 19] and follows [17, Lemma 5], with a main
addition being the extension to our generalized subproblems Gσ(cid:48)
k (·; v, α[k]) along with the general
mappings w(α) := ∇f (v(α)) with v(α) := Aα.

For simplicity, we write α instead of α(t), v instead of v(α(t)), w instead of w(α(t)) and u instead
of u(t). We can estimate the expected change of the objective D(α) as follows. Starting from the
deﬁnition of the update α(t+1) := α(t) + γ (cid:80)
k ∆α[k] from Algorithm 1, we apply Lemma 8, which
relates the local approximation Gσ(cid:48)
k (α; v, α[k]) to the global objective D(α), and then bound this

2Note that the case of weakly convex gi(.) is explicitly allowed here as well, as the Lemma holds for the

case µ = 0.

16

using the notion of quality of the local solver (Θ), as in Assumption 1. This gives us:

(cid:104)
E(cid:2)D(α(t)) − D(α(t+1))(cid:3) = E

D(α) − D

α + γ

(cid:16)

(cid:17)(cid:105)

∆α[k]

K
(cid:88)

k=1

K
(cid:88)

k=1

(cid:123)(cid:122)
C








(cid:124)








(cid:125)

≥ γ(1 − Θ)

D(α) −

Gσ(cid:48)
k (∆α(cid:63)

[k]; v, α[k])

.

(27)

We next upper bound the C term, denoting ∆α(cid:63) = (cid:80)K
the objective D in (A) and the local subproblems (2), and then substitute s(ui − αi) for ∆α(cid:63)
apply the µ-strong convexity of the gi terms. This gives us:

[k]. We ﬁrst plug in the deﬁnition of
i and

k=1 ∆α(cid:63)

(gi(αi) − gi(αi + ∆α(cid:63)

i )) − (A∆α(cid:63))T w(α) −

K
(cid:88)

k=1

σ(cid:48)
2τ

(cid:13)
(cid:13)A∆α(cid:63)
(cid:13)

[k]

(cid:13)
2
(cid:13)
(cid:13)

n
(cid:88)

C =

i=1
n
(cid:88)

(cid:16)

i=1

≥

sgi(αi) − sgi(ui) +

(1 − s)s(ui − αi)2(cid:17)

µ
2

− A(s(u − α))T w(α) −

K
(cid:88)

k=1

σ(cid:48)
2τ

(cid:13)
(cid:13)
2
(cid:13)
(cid:13)
(cid:13)A(s(u − α)[k])
(cid:13)

.

From the deﬁnition of the primal and dual optimization problems (A) and (B), and deﬁnition of
convex conjugates, we can write the duality gap as:

G(α) := P(w(α)) − (−D(α))

(A),(B)
=

(cid:0)g∗

i (−xT

i w(α)) + gi(αi)(cid:1) + f ∗(w(α)) + f (Aα))

n
(cid:88)

i=1

=

=

=

n
(cid:88)

i=1
n
(cid:88)

i=1
n
(cid:88)

i=1

(cid:0)g∗

i (−xT

i w(α)) + gi(αi)(cid:1) + f ∗(∇f (Aα)) + f (Aα)

(cid:0)g∗

i (−xT

i w(α)) + gi(αi)(cid:1) + (Aα)T w(α)

(cid:0)g∗

i (−xT

i w(α)) + gi(αi) + αixT

i w(α)(cid:1) .

(28)

(29)

(30)

The convex conjugate maximal property from (26) implies that
i (−xT

gi(ui) = ui(−xT

i w(α)) − g∗

i w(α)) .

Using (30) and (29), we therefore have:

n
(cid:88)

(cid:16)

(30)
≥

C

i=1

sgi(αi) − sui(−xT

i w(α)) + sg∗

i (−xT

i w(α)) +

(1 − s)s(ui − αi)2(cid:17)

µ
2

− A(s(u − α))T w(α) −

K
(cid:88)

k=1

σ(cid:48)
2τ

(cid:13)
(cid:13)
(cid:13)A(s(u − α)[k])

(cid:13)
2
(cid:13)
(cid:13)

=

n
(cid:88)

i=1

(cid:2)sgi(αi) + sg∗

i (−xT

i w(α)) + sxT

i w(α)αi

(cid:3) −

(cid:2)sxT

i w(α)(αi − ui) −

(1 − s)s(ui − αi)2(cid:3)

µ
2

n
(cid:88)

i=1

− A(s(u − α))T w(α) −

K
(cid:88)

k=1

σ(cid:48)
2τ

(cid:13)
(cid:13)
(cid:13)A(s(u − α)[k])

(cid:13)
2
(cid:13)
(cid:13)

(29)= sG(α) +

(1 − s)s(cid:107)u − α(cid:107)2 −

(cid:107)A(u − α)[k](cid:107)2 .

(31)

µ
2

σ(cid:48)s2
2τ

K
(cid:88)

k=1

17

The claimed improvement bound (24) then follows by plugging (31) into (27).

The following Lemma provides a uniform bound on R(t):
Lemma 10. If g∗

i are L-Lipschitz continuous for all i ∈ [n], then

where

∀t : R(t) ≤ 4L2

σknk

,

K
(cid:88)

k=1
(cid:124)

(cid:123)(cid:122)
=:σ

(cid:125)

σk := max
α[k]∈Rn

(cid:107)Aα[k](cid:107)2
(cid:107)α[k](cid:107)2 .

Proof. [17, Lemma 6]. For general convex functions, the strong convexity parameter is µ = 0, and
hence the deﬁnition (25) of the complexity constant R(t) becomes

R(t) =

(cid:107)A(u(t) − α(t))[k](cid:107)2

σk(cid:107)(u(t) − α(t))[k](cid:107)2 ≤

σk|Pk|4L2 .

K
(cid:88)

k=1

(33)
≤

K
(cid:88)

k=1

K
(cid:88)

k=1

Here the last inequality follows from in [26, Lemma 21], which shows that for g∗
L-Lipschitz, it holds that for any real value a with |a| > L one has that gi(a) = +∞.

i : R → R being

Remark 2. [17, Remark 7] If all data points xi are normalized such that (cid:107)xi(cid:107) ≤ 1 ∀i ∈ [n], then
σk ≤ |Pk| = nk. Furthermore, if we assume that the data partition is balanced, i.e., that nk = n/K
for all k, then σ ≤ n2/K. This can be used to bound the constants R(t), above, as R(t) ≤ 4L2n2
K .
Theorem 11. Consider Algorithm 1, using a local solver of quality Θ (See Assumption 1). Let g∗
i (·)
be L-Lipschitz continuous, and (cid:15)G > 0 be the desired duality gap (and hence an upper-bound on
suboptimality (cid:15)D). Then after T iterations, where

(cid:108)
T ≥ T0 + max{

(cid:109)
,

1
γ(1 − Θ)
(cid:19) (cid:105)

4L2σσ(cid:48)
τ (cid:15)Gγ(1 − Θ)
(cid:108)

,

t0 ≥ max(0,

} ,

T0 ≥ t0 +

(cid:104)

2
γ(1 − Θ)

(cid:18) 8L2σσ(cid:48)
τ (cid:15)G

− 1

+

we have that the expected duality gap satisﬁes

1

γ(1−Θ) log

(cid:16) τ (D(α(0))−D(α(cid:63)))
2L2σσ(cid:48)

(cid:17) (cid:109)

) ,

at the averaged iterate

E[P(w(α)) − (−D(α))] ≤ (cid:15)G

α := 1

T −T0

(cid:80)T −1

t=T0+1α(t) .

Proof. This proof draws from the line of reasoning in [26, Theorem 2] and follows [17, Theorem
8] but for the more general problem setting (A). We begin by estimating the expected change of
feasibility for D. We can bound this above by using Lemma 9 and the fact that the P(·) is always a
lower bound for −D(·), and then applying (32) to ﬁnd:

E[D(α(t+1)) − D(α(cid:63))] ≤ (1 − γ(1 − Θ)s) (D(α(t)) − D(α(cid:63))) + γ(1 − Θ) σ(cid:48)s2

2τ 4L2σ .

(36)

Using (36) recursively we have

E[D(α(t)) − D(α(cid:63))] ≤ (1 − γ(1 − Θ)s)t (D(α(0)) − D(α(cid:63))) + s

Choosing s = 1 and t = t0 := max{0, (cid:100)

1

γ(1−Θ) log(2(D(α(0)) − D(α(cid:63)))/(4L2σσ(cid:48)))(cid:101)} will lead to

4L2σσ(cid:48)
2τ

.

4L2σσ(cid:48)
2τ

≤

4L2σσ(cid:48)
τ

.

E[D(α(t)) − D(α(cid:63))] ≤ (1 − γ(1 − Θ))t0 (D(α(0)) − D(α(cid:63))) +

Next, we show inductively that

∀t ≥ t0 : E[D(α(t)) − D(α(cid:63))] ≤

4L2σσ(cid:48)

τ (1 + 1

2 γ(1 − Θ)(t − t0))

.

18

(32)

(33)

(34)

(35)

(37)

(38)

(39)

Clearly, (38) implies that (39) holds for t = t0. Assuming that it holds for any t ≥ t0, we show that
it must also hold for t + 1. Indeed, using

s =

1 + 1

2 γ(1 − Θ)(t − t0)

∈ [0, 1] ,

we obtain

E[D(α(t+1)) − D(α(cid:63))] ≤

4L2σσ(cid:48)
τ

(cid:18) 1 + 1

2 γ(1 − Θ)(t − t0) − 1
(1 + 1

2 γ(1 − Θ)(t − t0))2

2 γ(1 − Θ)

(cid:19)

(cid:125)

1

(cid:124)

by applying the bounds (36) and (39), plugging in the deﬁnition of s (40), and simplifying. We
upperbound the term D using the fact that geometric mean is less or equal to arithmetic mean:

1 + 1

2 γ(1 − Θ)(t + 1 − t0)

(1 + 1

2 γ(1 − Θ)(t + 1 − t0))(1 + 1
(1 + 1

2 γ(1 − Θ)(t − t0))2

2 γ(1 − Θ)(t − 1 − t0))

(cid:123)(cid:122)
D

(cid:123)(cid:122)
≤1

D =

≤

1

1

(cid:124)

,

1 + 1

2 γ(1 − Θ)(t + 1 − t0)

If α is deﬁned as (35), we apply the results of Lemma 9 and Lemma 10 to obtain
α(t)(cid:17)

E[G(α)] = E

(cid:32) T −1
(cid:88)

(cid:34) T −1
(cid:88)

≤ 1

α(t)

(cid:33)(cid:35)

G

G

E

(cid:16)

(cid:34)

(cid:35)

T −T0

1
T −T0

t=T0

≤

1
γ(1 − Θ)s

1
T − T0

(cid:104)
D(α(T0)) − D(α(cid:63))

E

+ 4L2σσ(cid:48)s
2τ

.

t=T0
(cid:105)

If T ≥ (cid:100)

γ(1−Θ) (cid:101) + T0 such that T0 ≥ t0 we have

1

E[G(α)]

(41),(39)
≤

1
γ(1 − Θ)s
(cid:18)

1
T − T0
1
γ(1 − Θ)s

4L2σσ(cid:48)
τ

=

(cid:18)

4L2σσ(cid:48)

τ (1 + 1
1
T − T0

1 + 1

2 γ(1 − Θ)(T0 − t0))
1

2 γ(1 − Θ)(T0 − t0)

+

(cid:19)

.

s
2

(cid:19)

+

4L2σσ(cid:48)s
2τ

s =

1
(T − T0)γ(1 − Θ)

∈ [0, 1]

E[G(α)]

(42),(43)
≤

(cid:18)

4L2σσ(cid:48)
τ

1 + 1

2 γ(1 − Θ)(T0 − t0)

+

1
(T − T0)γ(1 − Θ)

1
2

(cid:19)

.

To have right hand side of (44) smaller then (cid:15)G it is sufﬁcient to choose T0 and T such that

(40)

(cid:125)

(41)

(42)

(43)

(44)

(45)

(46)

Choosing

gives us

Hence if

(cid:18)

4L2σσ(cid:48)
τ
4L2σσ(cid:48)
τ

1 + 1
(cid:18)

2 γ(1 − Θ)(T0 − t0)
1
1
2
(T − T0)γ(1 − Θ)

(cid:19)

(cid:19)

≤

≤

1
2

1
2

(cid:15)G ,

(cid:15)G .

t0 +

2
γ(1 − Θ)

(cid:19)

− 1

(cid:18) 8L2σσ(cid:48)
τ (cid:15)G
4L2σσ(cid:48)
τ (cid:15)Gγ(1 − Θ)

T0 +

≤ T0 , and

≤ T ,

then (45) and (46) are satisﬁed.

The following main theorem simpliﬁes the results of Theorem 11 and is a generalization of [17,
Corollary 9] for general f ∗(·) functions:
Theorem’ 1. Consider Algorithm 1 with γ := 1, using a local solver of quality Θ (see Assumption
1). Let g∗
i (·) be L-Lipschitz continuous, and assume that the columns of A satisfy (cid:107)xi(cid:107) ≤ 1 ∀i ∈ [n].
Let (cid:15)G > 0 be the desired duality gap (and hence an upper-bound on primal sub-optimality). Then

1

1

19

after T iterations, where

T ≥ T0 + max{

T0 ≥ t0 +

(cid:104)

2
1 − Θ
(cid:108) 1

(cid:108)

(cid:109)
,

1
1 − Θ
(cid:18) 8L2n2
τ (cid:15)G

4L2n2
τ (cid:15)G(1 − Θ)
(cid:19) (cid:105)
+

− 1

,

} ,

t0 ≥ max(0,

(1−Θ) log

(cid:16) τ (D(α(0))−D(α(cid:63)))
2L2Kn

(cid:17) (cid:109)

) ,

(47)

we have that the expected duality gap satisﬁes

(where α is the averaged iterate returned by Algorithm 1).

E[P(w(α)) − (−D(α))] ≤ (cid:15)G

Proof. Plug in parameters γ := 1, σ(cid:48) := γK = K to the results of Theorem 11, and note that for
balanced datasets we have σ ≤ n2
K (see Remark 2). We can further simplify the rate by noting that
τ = 1 for the 1-smooth losses (least squares and logistic) given as examples in this work.

Remark 3. For pure L1-regularized problems as discussed in Section C.1, we have that the above
theorem directly delivers a primal-dual convergence with a sublinear rate. This is because in view
of Lemma 7, we know that g∗
i is B-Lipschitz for the bounded support modiﬁcation introduced in
Section 4.

E.3 Proof of Convergence Result for Strongly Convex gi

Our second main theorem follows reasoning in [26] and is a generalization of [17, Corollary 11]. We
ﬁrst introduce a lemma to simplify the proof.
Lemma 12. Assume that gi(0) ∈ [0, 1] for all i ∈ [n], then for the zero vector α(0) := 0 ∈ Rn, we
have

D(α(0)) − D(α(cid:63)) = D(0) − D(α(cid:63)) ≤ n .

(48)

Proof. For α := 0 ∈ Rn, we have w(α) = Aα = 0 ∈ Rd. Therefore, since the dual −D(·) is
always a lower bound on the primal P(·), and by deﬁnition of the objective D given in (A),

0 ≤ D(α) − D(α(cid:63)) ≤ P(w(α)) − (−D(α))

(A)
≤ n .

Theorem 13. Assume that gi are µ-strongly convex ∀i ∈ [n]. We deﬁne σmax = maxk∈[K] σk. Then
after T iterations of Algorithm 1, with

T ≥

1
γ(1−Θ)

µτ +σmaxσ(cid:48)
µτ

log n
(cid:15)D

,

E[D(α(T )) − D(α(cid:63))] ≤ (cid:15)D .

it holds that

Furthermore, after T iterations with

we have the expected duality gap

T ≥

1
γ(1−Θ)

µτ +σmaxσ(cid:48)
µτ

log

1
γ(1−Θ)

µτ +σmaxσ(cid:48)
µτ

n
(cid:15)G

(cid:16)

(cid:17)

,

E[P(w(α(T ))) − (−D(α(T )))] ≤ (cid:15)G .

Proof. Given that gi(.) is µ-strongly convex with respect to the (cid:107) · (cid:107) norm, we can apply (25) and the
deﬁnition of σk to ﬁnd:

R(t) ≤ − τ µ(1−s)
(cid:16)

σ(cid:48)s
− τ µ(1−s)

≤

(cid:107)u(t) − α(t)(cid:107)2 +

(cid:88)K

k=1

σk(cid:107)u(t) − α(t)

[k](cid:107)2

σ(cid:48)s + σmax

(cid:107)u(t) − α(t)(cid:107)2 ,

(cid:17)

where σmax = maxk∈[K] σk. If we plug the following value of s
τ µ + σmaxσ(cid:48) ∈ [0, 1]

s =

τ µ

(49)

(50)

20

(24),(50)

≥ γ(1 − Θ)

E[D(α(t)) − D(α(t+1))]

into (49) we obtain that ∀t : R(t) ≤ 0. Putting the same s into (24) will give us
τ µ + σmaxσ(cid:48) G(α(t)) ≥ γ(1 − Θ)

τ µ + σmaxσ(cid:48) (D(α(t)) − D(α(cid:63))) .
(51)
Using the fact that E[D(α(t)) − D(α(t+1))] = E[D(α(cid:63)) − D(α(t+1))] + D(α(t)) − D(α(cid:63)) we have
(51)
τ µ + σmaxσ(cid:48) (D(α(t)) − D(α(cid:63))) ,
≥ γ(1 − Θ)

E[D(α(cid:63)) − D(α(t+1))] + D(α(t)) − D(α(cid:63))

τ µ

τ µ

τ µ

which is equivalent to

E[D(α(t+1)) − D(α(cid:63))] ≤

1 − γ(1 − Θ)

(D(α(t)) − D(α(cid:63))) .

(52)

(cid:18)

(cid:19)

τ µ
τ µ + σmaxσ(cid:48)

Therefore if we denote (cid:15)(t)

(cid:18)

E[(cid:15)(t)
D ]

(52)
≤

1 − γ(1 − Θ)

D = D(α(t)) − D(α(cid:63)) we have recursively that
(cid:19)t

(cid:18)

1 − γ(1 − Θ)

τ µ
τ µ + σmaxσ(cid:48)

(cid:19)t

n

(cid:18)

≤ exp

−tγ(1 − Θ)

τ µ
τ µ + σmaxσ(cid:48)

(cid:15)(0)
D

(48)
≤

τ µ
τ µ + σmaxσ(cid:48)

(cid:19)

n .

The right hand side will be smaller than some (cid:15)D if

1
γ(1 − Θ)
Moreover, to bound the duality gap, we have
τ µ

t ≥

γ(1 − Θ)

τ µ + σmaxσ(cid:48)
τ µ

log

n
(cid:15)D

.

τ µ + σmaxσ(cid:48) G(α(t))
(cid:15)(t)
D . Hence if (cid:15)D ≤ γ(1 − Θ)

τ µ+σmaxσ(cid:48)
τ µ

1
γ(1−Θ)

(51)
≤ E[D(α(t)) − D(α(t+1))] ≤ E[D(α(t)) − D(α(cid:63))] .

τ µ

τ µ+σmaxσ(cid:48) (cid:15)G then G(α(t)) ≤ (cid:15)G.

Thus, G(α(t)) ≤
Therefore after

1
γ(1 − Θ)
iterations we have obtained a duality gap less than (cid:15)G.

τ µ + σmaxσ(cid:48)
τ µ

t ≥

log

(cid:18)

1
γ(1 − Θ)

τ µ + σmaxσ(cid:48)
τ µ

n
(cid:15)G

(cid:19)

Theorem’ 2. Consider Algorithm 1 with γ := 1, using a local solver of quality Θ (See Assumption
1). Let gi(·) be µ-strongly convex ∀i ∈ [n], and assume that the columns of A satisfy (cid:107)xi(cid:107) ≤ 1
∀i ∈ [n]. Then we have that T iterations are sufﬁcient for suboptimality (cid:15)D, with

Furthermore, after T iterations with

we have the expected duality gap

T ≥

1
γ(1−Θ)

τ µ+n

τ µ log n
(cid:15)D

.

T ≥

1
γ(1−Θ)

τ µ+n
τ µ log

1
γ(1−Θ)

τ µ+n
τ µ

n
(cid:15)G

(cid:16)

(cid:17)

,

E[P(w(α(T ))) − D(α(T ))] ≤ (cid:15)G .

Proof. Plug in parameters γ := 1, σ(cid:48) := γK = K to the results of Theorem 13 and note that for
balanced datasets we have σmax ≤ n
K (see Remark 2). We can further simplify the rate by noting
that τ = 1 for the 1-smooth losses (least squares and logistic) given as examples in this work.

Remark 4. For elastic net regularized problems as discussed in Section C.2, we have that the above
theorem directly delivers a primal-dual convergence with a geometric rate. This is because in view of
Lemma 6, we know that g∗

i is 1/η-smooth for any elastic net parameter η ∈ (0, 1].

F Recovering COCOA+ as a Special Case

As a special case, PROXCOCOA+ directly applies to any L2-regularized loss-minimization problem,
including those presented in [12, 17]. In this setting, the original machine-learning problem is mapped
to what we here refer to as the “dual” problem formulation (B):

(cid:104)

P(w) := f ∗(w) +

i (−xT
g∗

i w)

(cid:105)

,

min
w∈Rd

n
(cid:88)

i=1

21

2 (cid:107) · (cid:107)2 being the regularizer, and g∗

with f ∗(·) = λ
i taking the role of loss function, acting on a linear
i w (recall that xi is a column of the data matrix A). In other words, the PROXCOCOA+
predictor xT
algorithm will in this case apply to (A) as the dual of the original input problem (which will be
mapped to (B)), as described in [12, 17]. The following remarks show that we recover the linear
(geometric) convergence rates for smooth loss functions g∗
i , and sublinear convergence for Lipschitz
losses. Note that this contrasts the discussed applications of PROXCOCOA+ where the g function has
the role of the regularizer instead.

Remark 5. If we view (B) as the primal , restrict f ∗(·) := λ
Theorem 1 recovers as a special case the COCOA+ rates for general L-Lipschitz (cid:96)∗
Corollary 9]).

2 (cid:107) · (cid:107)2 (so that τ = λ), and let g∗

n (cid:96)∗
i ,
i losses (see [17,

i := 1

This follows since g∗
Remark 6. If we view (B) as the primal , restrict f ∗(·) := λ
i := 1
g∗
n (cid:96)∗
[17, Corollary 11]).

i is L-Lipschitz if and only if gi has L-bounded support [24, Corollary 13.3.3].
2 (cid:107) · (cid:107)2 (so that τ = λ), and scale
i )-smooth losses (see

i , Theorem 2 recovers as a special case the COCOA+ rates for (1/(cid:96)∗

i is µ-strongly convex if and only if gi is (1/µ)-smooth [14, Theorem 6].

This follows since g∗
Remark 7. Note that the approach of mapping the original objective to (B) does not allow general
regularizers such as L1. This is one of the reasons we have proposed swapping the roles of regularizers
and losses, and running PROXCOCOA+ on the primal of the original problem instead.

G Experiment Details

In this section we provide greater details on the experimental setup and implementations from
Section 6. All experiments are run on Amazon EC2 clusters of m3.xlarge machines, with one core
per machine. The code for each method is written in Apache Spark, v1.5.0. Our code is open-source
and publicly available at: github.com/gingsmith/proxcocoa.

ADMM Alternating Direction Method of Multipliers (ADMM) [5] is a popular method that lends
itself naturally to the distributed environment. Implementing ADMM for the problems of interest
requires solving a large linear system Cx = d on each machine, where C ∈ Rn×n with n scaling
beyond 107 for the datasets in Table 1, and with C being possibly dense. It is prohibitively slow
to solve this directly on each machine, and we therefore employ the iterative method of conjugate
gradient with early stopping (see, e.g., [5, Section 4.3]). We further improve performance by using a
varying rather than constant penalty parameter, as suggested in [5, Section 3.4.1].

Mini-batch SGD and Proximal GD Mini-batch SGD is a standard and widely used method for
parallel and distributed optimization. We use the optimized code provided in Spark’s machine
learning library, MLlib, v1.5.0. We tune both the size of the mini-batch and the SGD step size using
grid search. Proximal gradient descent can be seen as a speciﬁc setting of mini-batch SGD, where the
mini-batch size is equal to the total number of datapoints. We thus also use the implementation in
MLlib for prox-GD, and tune the step size parameter using grid search.

Mini-batch CD Mini-batch CD aims to improve mini-batch SGD by employing coordinate descent,
which has encouraging theoretical and practical backings [25, 9, 28]. We implement mini-batch CD
in Spark and scale the updates made at each round by β
b for mini-batch size b and β ∈ [1, b], tuning
both parameters b and β via grid search.

Shotgun As a special case of mini-batch CD, Shotgun [7] is a popular method for parallel optimiza-
tion. Shotgun can be seen an extreme case of mini-batch CD where the mini-batch is set to 1 element
per machine, i.e., there is a single update made by each machine per round. We see in the experiments
that communicating this frequently becomes prohibitively slow in the distributed environment.

OWL-QN OWN-QN [32] is a quasi-Newton method optimized in Spark’s spark.ml package. Outer
iterations of OWL-QN make signiﬁcant progress towards convergence, but the iterations themselves
can be slow because they require processing the entire dataset. PROXCOCOA+, the mini-batch
methods, and ADMM with early stopping all improve on this by allowing the ﬂexibility of only a
subset of the dataset to be processed at each iteration. PROXCOCOA+ and ADMM have even greater

22

ﬂexibility by allowing internal methods to process the dataset more than once. PROXCOCOA+ makes
this approximation quality speciﬁc, both in theoretical convergence rates and by providing general
guidelines for setting the parameter.
PROXCOCOA+ We implement PROXCOCOA+ with coordinate descent as a local solver. We note
that since the framework and theory allow any internal solver to be used, PROXCOCOA+ could beneﬁt
even beyond the results shown, by using existing fast L1-solvers for the single-machine case, such as
GLMNET variants [11] or BLITZ [13]. The only parameter necessary to tune for PROXCOCOA+ is the
level of approximation quality, which we parameterize in the experiments using H, the number of
local iterations of the iterative method run locally. Our theory relates local approximation quality to
global convergence, and we provide a guideline for how to choose this value in practice that links the
value to the systems environment at hand (Remark 1). We implement COCOA+ as a special case of
PROXCOCOA+ for elastic net regularized objectives by mapping the main objective to (B) according
to the steps described in Section F, and again use coordinate descent as a local solver.

23

6
1
0
2
 
n
u
J
 
2
 
 
]

G
L
.
s
c
[
 
 
2
v
1
1
0
4
0
.
2
1
5
1
:
v
i
X
r
a

L1-Regularized Distributed Optimization:
A Communication-Efﬁcient Primal-Dual Framework

Virginia Smith
UC Berkeley

Michael I. Jordan
UC Berkeley

Simone Forte
ETH Zürich†

Martin Jaggi
ETH Zürich

Abstract

Despite the importance of sparsity in many large-scale applications, there are few
methods for distributed optimization of sparsity-inducing objectives. In this paper,
we present a communication-efﬁcient framework for L1-regularized optimization
in the distributed environment. By viewing classical objectives in a more general
primal-dual setting, we develop a new class of methods that can be efﬁciently
distributed and applied to common sparsity-inducing models, such as Lasso, sparse
logistic regression, and elastic net-regularized problems. We provide theoretical
convergence guarantees for our framework, and demonstrate its efﬁciency and ﬂex-
ibility with a thorough experimental comparison on Amazon EC2. Our proposed
framework yields speedups of up to 50× as compared to current state-of-the-art
methods for distributed L1-regularized optimization.

1

Introduction

In this paper, we consider standard regularized loss minimization problems, including as our main
focus L1-regularized optimization problems of the form

min
α∈Rn

f (Aα) + λ (cid:107)α(cid:107)1 ,

where α ∈ Rn is the weight vector, A ∈ Rd×n is a given data matrix, and λ is a regularization pa-
rameter. This formulation includes many popular L1-regularized classiﬁcation and regression models,
such as Lasso and sparse logistic regression, and is easily extended to other separable regularizers
like elastic net. Models of this form are particularly useful in high-dimensional settings because
of their tendency to bias learning towards sparse solutions. However, despite their importance, few
methods currently exist to efﬁciently ﬁt such sparsity-inducing models in the distributed environment.
One promising distributed method is COCOA+ [12, 17], a recently proposed primal-dual framework
that demonstrates competitive performance, provides a ﬂexible communication scheme, and enables
the use of off-the-shelf single-machine solvers internally. However, by solving the problem in the dual,
COCOA+ (like SDCA, prox-SDCA, and numerous other primal-dual methods [26, 27, 30, 35, 36]) is
only equipped to handle strongly convex regularizers, which prevents it from being directly applied
to L1-regularized objectives. Moreover, by requiring the data to be distributed by data point rather
than by feature, communication can become a prohibitive bottleneck for COCOA+ as the number of
features grows large, which is precisely the setting of interest for L1 regularization.

In this work, we take a different perspective and propose a framework that can run either in the dual, or
on the primal directly. From this change in perspective we derive several new primal-dual distributed
optimization methods, in particular for sparsity-inducing regularizers. Our approach uses ideas
from COCOA+, though leveraging these ideas in this new setting requires signiﬁcant theoretical and
algorithmic modiﬁcations, particularly in handling non-strongly convex regularizers. The proposed
primal-dual framework and associated rates are novel contributions even in the non-distributed case.

†Parts of this work appear in SF’s Master’s Thesis [10].

1.1 Contributions
Generalized framework. By building on the COCOA+ framework, PROXCOCOA+ comes with
several beneﬁts, including the use of arbitrary local solvers on each machine, and the analysis of and
ability to solve subproblems to arbitrary accuracies. However in contrast to COCOA+, we consider
a much broader class of optimization problems. This results in a more general framework that: (1)
speciﬁcally incorporates the case of L1 regularization; (2) allows for the ﬂexibility of distributing
the data by either feature or data point; and (3) can be run on either the primal or dual formulation,
which we show to have signiﬁcant theoretical and practical implications.

Analysis of non-strongly convex regularizers and losses. We derive convergence rates for the
general class of problems considered in this work, leveraging a novel approach in the analysis of
primal-dual rates for non-strongly convex regularizers. The proposed technique is a signiﬁcant
improvement over simple smoothing techniques used in, e.g., [22, 27, 35] that enforce strong
convexity by adding a small L2 term to the objective. Our results include primal-dual rates and
certiﬁcates for both strongly convex and non-strongly convex regularizers and losses, and we show
how earlier rates of COCOA and COCOA+ can be derived as a special case of our new rates / methods.

Experimental comparison. The proposed framework yields order-of-magnitude speedups (as
much as 50× faster) as compared to other state-of-the-art methods for L1-regularized optimization.
We demonstrate these performance gains in an extensive experimental comparison on real-world
distributed datasets. We additionally show signiﬁcant improvements over COCOA+ when considering
strongly convex objectives. All algorithms for comparison are implemented in Apache Spark and run
on Amazon EC2 clusters. Our code is available at: github.com/gingsmith/proxcocoa.

2 Setup

A great variety of methods in machine learning and signal processing are posed as the minimization
of a weighted sum of two convex functions, where the ﬁrst term is a convex function of a linear
predictor and the second term is a regularizer:

min
α∈Rn

f (Aα) + g(α) .

(A)

Here α ∈ Rn is the parameter vector, and A := [x1; . . . ; xn] ∈ Rd×n is a data matrix with column
vectors xi ∈ Rd, i ∈ [n] and row vectors yT
j ∈ Rn, j ∈ [d]. Our central assumption will be that g(·)
is separable, meaning that

n
(cid:88)

g(α) =

gi(αi)

i=1
for convex functions gi : R → R. Furthermore, we assume f : Rd → R is (1/τ )-smooth for τ > 0.
Examples. The above setting encompasses all convex loss functions depending on linear predictors
yT
j α, together with most common convex regularizers, including all separable functions, such as L1-
or general Lp-norms, or the elastic net given by η
Data partitioning. To map this setup to the distributed environment, we suppose that the dataset A
k=1 of the columns of A ∈ Rd×n. We
is distributed over K machines according to a partition {Pk}K
denote the size of the partition on machine k by nk = |Pk|. For k ∈ [K] and α ∈ Rn, we deﬁne
α[k] ∈ Rn as the n-vector with elements (α[k])i := αi if i ∈ Pk and (α[k])i := 0 otherwise.

2 (cid:107)·(cid:107)2 + (1 − η) (cid:107)·(cid:107)1.

3 The PROXCOCOA+ Algorithmic Framework

The PROXCOCOA+ framework is given in Algorithm 1. This framework builds on the recent COCOA+
framework [12, 17], though with a more general objective, a modiﬁed subproblem, and where we
allow the method to be applied to either the primal or dual formulation. To distribute the method, we
assign each machine to work only on local coordinates of the weight vector α, and access only data
that is stored locally. Machines share state through the vector v := Aα. This vector is communicated
at each round after using local solvers in parallel to ﬁnd (possibly) approximate solutions to the
subproblems deﬁned in (2). Solving the primal problem (A) directly with PROXCOCOA+ will result
in distributing the data column-wise (by feature), and having the vector v be of length equal to the
number of data points. This can greatly reduce communication costs as the number of features grows
(see Section 6). Most importantly, the proposed setup will prepare us to handle non-strongly convex
regularizers in both theory and practice, as we further explain in the following sections.

2

Algorithm 1 PROXCOCOA+ Distributed Framework for Problem (A)
1: Input: Data matrix A distributed column-wise according to partition {Pk}K

parameter γ ∈ (0, 1], and parameter σ(cid:48) for the local subproblems Gσ(cid:48)
Starting point α(0) := 0 ∈ Rn, v(0) := 0 ∈ Rd.

k (∆α[k]; v, α[k]).

k=1, aggregation

2: for t = 0, 1, 2, . . . do
3:
4:

for k ∈ {1, 2, . . . , K} in parallel over computers do

call local solver, returning a Θ-approximate solution ∆α[k] of the local subproblem (2)
update local variables α(t+1)
return updates to shared state ∆vk := A∆α[k]

[k] + γ ∆α[k]

:= α(t)

[k]

5:
6:
7:
8:
9: end for

end for
reduce v(t+1) := v(t) + γ (cid:80)K

k=1 ∆vk

Data-local quadratic subproblems. For each machine, we deﬁne a data-local subproblem of the
original optimization problem (A). This simpler problem can be solved on machine k and only
requires accessing data which is already available locally, i.e., columns Ai such that i ∈ Pk. The
subproblem depends only on the previous shared vector v := Aα and the local data:

min
∆α[k]∈Rn

Gσ(cid:48)
k (∆α[k]; v, α[k]) ,

(1)

where

Gσ(cid:48)
k (∆α[k]; v, α[k]) :=

f (v) + wT A∆α[k] +

1
K

σ(cid:48)
2τ

(cid:13)
(cid:13)
(cid:13)A∆α[k]

(cid:13)
2
(cid:13)
(cid:13)

+

(cid:88)

i∈Pk

gi(αi + ∆α[k]i)

(2)

with w := ∇f (v). We denote the change of local variables αi for indices i ∈ Pk as ∆α[k]. For
a given aggregation parameter γ ∈ (0, 1], the subproblem relaxation parameter σ(cid:48) will be set as
σ(cid:48) := γK, but can also be improved in a data-dependent way as we discuss in Appendix E.

Reusability of existing single-machine solvers. Our local subproblems have the appealing prop-
erty of being very similar in structure to the global problem (A), with the main difference being that
they are deﬁned on a smaller (local) subset of the data. For the user of our framework, this presents
a major advantage in that existing single machine-solvers can be directly re-used in our distributed
framework (Algorithm 1) by employing them on the subproblems Gσ(cid:48)
k . Therefore, problem-speciﬁc
tuned solvers which have already been developed, along with associated speed improvements (such
as multi-core implementations), can be easily leveraged in the distributed setting. We quantify the
dependence on local solver performance in more detail in our convergence analysis (Section 4).

Interpretation. The above deﬁnition of the local objective functions Gσ(cid:48)
k are such that they closely
approximate the global objective in (A) as the “local” variable ∆α[k] varies, which we will see
in the analysis (Lemma 8 in the appendix). In fact, if the subproblem were solved exactly, this
could be interpreted as a data-dependent, block-separable proximal step, applied to the f part of the
objective (A) as follows:

K
(cid:88)

k=1

Gσ(cid:48)
k (∆α[k]; v, α[k]) = L + f (v) + ∇f (v)T A∆α +

∆αT

σ(cid:48)
2τ

AT

[1]A[1]






. . .



0


 ∆α ,

0

AT

[K]A[K]

where L = (cid:80)

i∈[n] gi(αi + ∆αi) .

However, note that in contrast to traditional proximal methods, our algorithm does not assume that
the prox subproblems be solved to high accuracy, as we instead allow the use of local solvers of any
approximation quality Θ. This notion is made precise with the following assumption.

Assumption 1 (Θ-approximate solution, see [17]). We assume that there exists Θ ∈ [0, 1) such that
∀k ∈ [K], the local solver at any outer iteration t produces a (possibly) randomized approximate
solution ∆α[k], which satisﬁes
E(cid:2)Gσ(cid:48)
k (∆α[k]; v, α[k])− Gσ(cid:48)

k (0; v, α[k]) − Gσ(cid:48)
Gσ(cid:48)

[k]; v, α[k])(cid:3) ≤ Θ

[k]; v, α[k])

k (∆α(cid:63)

k (∆α(cid:63)

, (3)

(cid:16)

(cid:17)

3

where

∆α(cid:63)

[k] ∈ arg min
∆α∈Rn

Gσ(cid:48)
k (∆α[k]; v, α[k]) ∀k ∈ [K] .

(4)

Remark 1. In practice, the time spent solving the local subproblems in parallel should be chosen
comparable to the required time of a communication round, for best overall efﬁciency on a given
system. We study this trade-off both in theory (Section 4) and experiments (Section 6).

3.1 Primal-Dual Context

Exploiting primal-dual structure is not a requirement to optimize (A); indeed, we have shown above
how to solve this optimization problem directly. However, noting the relationship between primal and
dual objectives has many beneﬁts, including computation of the duality gap, which allows us to have
a certiﬁcate of approximation quality. It is also useful as an analysis tool and helps relate this work to
the prior work of [30, 12, 17]. To leverage this structure, starting from our original formulation (A)
with objective function D(α) := f (Aα) + (cid:80)n

i=1 gi(αi), the dual problem is given by

(cid:104)

P(w) := f ∗(w) +

g∗
i (−xT

i w)

(cid:105)

.

min
w∈Rd

n
(cid:88)

i=1

(B)

Here w ∈ Rd is a weight vector and xi ∈ Rd are columns of the data matrix A. The functions f ∗, g∗
i
are the convex conjugates of f, gi in the original problem (A). This duality structure is known as
Fenchel-Rockafellar Duality (see [4, Theorem 4.4.2] or a self-contained derivation in the appendix).
Given α ∈ Rn in the context of (A), a corresponding primal vector w ∈ Rd for problem (B) is
obtained by:
w = w(α) := ∇f (Aα) .
(5)
This mapping is given by the ﬁrst-order optimality conditions for the f -part of the objective. (Recall
that we assumed gi : R → R are arbitrary closed convex functions, f : Rd → R is (1/τ )-smooth.)
The duality gap, given by:

i globally deﬁned and Lipschitz [8], as we prove in Section 4.

G(α) := P(w(α)) − (−D(α))
(6)
acts as a certiﬁcate of approximation quality, as the distance to the true optimum P(w(cid:63)) is always
bounded above by the duality gap. A globally deﬁned and ﬁnite duality gap G(α) for any problem (A)
can be obtained by bounding the region of interest for the iterates α. This “Lipschitzing” trick will
make the conjugates g∗
Primal vs. Dual. Previous work of COCOA+ mapped machine learning tasks to P(w) (B), and
then solved this problem in the dual. While this can still be accomplished with the machinery of
PROXCOCOA+ (see Section F), here our main focus is to instead solve the original objective D(α) (A)
directly. This can have a large practical impact for the described applications in the distributed setting,
as it implies that we can distribute the data by feature rather than by data point. Further, we will
communicate a vector equal in size to the number of data points, as opposed to the number of features.
When the number of features is high (as is common in sparsity-inducing models) this can signiﬁcantly
reduce communication and improve overall performance, as we demonstrate in Section 6. Further, it
allows us to directly leverage state-of-the-art coordinate-wise primal methods, such as GLMNET [11]
and extensions [34, 13]. From a theoretical perspective, solving D(α) will allow us to consider
non-strongly convex regularizers, which were not covered in COCOA+, as we discuss in Section 4.

4 Convergence Analysis

In this section we provide convergence rates for the proposed framework, and introduce an important
theoretical technique in analyzing non-strongly convex terms in the primal-dual setting. For simplicity
of presentation, we assume in the analysis that the data partition is balanced; i.e., nk = n/K for
all k. Furthermore, we assume that the columns of A satisfy (cid:107)xi(cid:107) ≤ 1 for all i ∈ [n]. We present
results for the case where γ := 1 in Algorithm 1, and where the subproblems (2) are deﬁned using the
corresponding safe bound σ(cid:48) := K. This case delivers the fastest convergence rates in the distributed
setting, which in particular don’t degrade as the number of machines K grows and n remains ﬁxed.

4.1 General Convex gi

Our ﬁrst main theorem provides convergence guarantees for objectives with non-strongly convex
regularizers, including models such as Lasso and sparse logistic regression. Providing primal-dual

4

rates and globally deﬁned primal-dual accuracy certiﬁcates requires a theoretical technique that we
introduce below, in which we show how to satisfy the following notion of L-bounded support.
Deﬁnition 1 (L-Bounded Support). A function h has L-bounded support if its effective domain is
bounded by L, i.e.,

h(u) < +∞ ⇒ (cid:107)u(cid:107) ≤ L .

(7)

As we explain in Section F of the appendix, our assumption of L-bounded support for the gi functions
can be interpreted as an assumption that their conjugates are globally L-Lipschitz.

Theorem 1. Consider Algorithm 1 with γ := 1, and let Θ be the quality of the local solver as in
Assumption 1. Let gi have L-bounded support, and f be (1/τ )-smooth. Then after T iterations where
(cid:108)
T ≥ T0+ max{

(cid:109)
,

(8)

} ,

1
1 − Θ

4L2n2
τ (cid:15)G(1 − Θ)
(cid:108) 1

(1−Θ) log

, t0 ≥ max(0,

(cid:16) τ (D(α(0))−D(α(cid:63)))
2L2Kn

(cid:17) (cid:109)

) ,

T0 ≥ t0 +

(cid:104)

2
1 − Θ

(cid:18) 8L2n2
τ (cid:15)G

(cid:19) (cid:105)

− 1

+

we have that the expected duality gap satisﬁes

where α is the averaged iterate returned by Algorithm 1.

E[P(w(α)) − (−D(α))] ≤ (cid:15)G ,

Bounded support modiﬁcation. Note that the absolute value function gi = | · | for L1 regular-
ization does not have L-bounded support, and thus violates the assumptions yielding convergence
in Theorem 1. Its dual, the indicator function of the interval, is not deﬁned globally, and thus does
not always allow a ﬁnite duality gap. To address this, existing approaches typically use a simple
smoothing technique as in [22]: by adding a small amount of L2 to the L1-norm, it becomes strongly
convex; see, e.g., [27]. This Nesterov smoothing technique is undesirable in practice, as it changes
the iterates, the convergence rate, and the tightness of the resulting duality gap. Further, the amount
of smoothing can be difﬁcult to tune and can have a large inﬂuence on the performance of the method
at hand. We show examples of this issue with experiments in Section 6.

In contrast, our approach preserves all solutions of the original objective, leaves the iterate sequence
unchanged, and allows for direct reusability of existing L1 solvers. It also removes the need for
additional parameter tuning. To achieve this, we modify the function | · | by imposing an additional
weak constraint that is inactive in our region of interest. Formally, we replace gi(·) = | · | by
(cid:26)|α|

: α ∈ [−B, B]

¯gi(α) :=

+∞ : otherwise.

For large enough B, this problem yields the same solution as the original L1-regularized objective.
Note that this only affects convergence theory, in that it allows us to present a strong primal-dual rate
(Theorem 1 for L=B). The modiﬁcation of gi does not affect the algorithms for the original problems.
Whenever a monotone optimizer is used, we will never leave the level set deﬁned by the objective at
the starting point. We provide further details on this technique in Section D.3, and illustrate how to
leverage it for a variety of applications (see Section C of the appendix and also [8]).

4.2 Strongly Convex gi

For the case of strongly convex gi, including elastic net-regularized objectives, we obtain the following
faster geometric convergence rate.

Theorem 2. Consider Algorithm 1 with γ := 1, and let Θ be the quality of the local solver as in
Assumption 1. Let gi be µ-strongly convex ∀i ∈ [n], and f be (1/τ )-smooth. Then we have that T
iterations are sufﬁcient for suboptimality (cid:15)D, with

T ≥

1
γ(1−Θ)

µτ +n
µτ

log n
(cid:15)D

.

(9)

Furthermore, after T iterations with

We provide proofs of both Theorem 1 and Theorem 2 in the appendix (Section E).

(cid:16)

T ≥

µτ +n
µτ

1
γ(1−Θ)

n
(cid:15)G
E[P(w(α(T ))) − (−D(α(T )))] ≤ (cid:15)G .

1
γ(1−Θ)

µτ +n
µτ

log

(cid:17)

,

5

5 Related Work

Single-machine coordinate solvers. For strongly convex regularizers, current state-of-the-art for
empirical loss minimization is randomized coordinate ascent on the dual (SDCA) [26] and its
accelerated variants, e.g., [27]. In contrast to primal stochastic gradient descent (SGD) methods, the
SDCA family is often preferred as it is free of learning-rate parameters and has faster (geometric)
convergence guarantees. Interestingly, a similar trend in coordinate solvers has been observed in
recent Lasso literature, but with the roles of primal and dual reversed. For those problems, coordinate
descent methods on the primal have become state-of-the-art, as in GLMNET [11] and extensions [34];
see, e.g., the overview in [33]. However, primal-dual convergence rates for unmodiﬁed coordinate
algorithms have to our knowledge been obtained only for strongly convex regularizers to date [27, 35].

Connection to coordinate-wise Newton methods. Coordinate descent on L1-regularized prob-
lems (A) with g(·) = λ(cid:107) · (cid:107)1 can be interpreted as the iterative minimization of a quadratic approx-
imation of the smooth part of the objective (as in a one-dimensional Newton step), followed by a
shrinkage step resulting from the L1 part. In the single-coordinate update case, this is at the core of
GLMNET [11, 33], and widely used in, e.g., solvers based on the primal formulation of L1-regularized
objectives [25, 34, 3, 9, 28]. When changing more than one coordinate at a time, again employing a
quadratic upper bound on the smooth part, this results in a two-loop method as in GLMNET [11] for
the special case of logistic regression. This idea is crucial for the distributed setting.

Parallel coordinate descent. Parallel coordinate descent for L1-regularized objectives (with and
without using mini-batches) was proposed in [7] (Shotgun) and generalized in [3] , and is among
the best performing solvers in the parallel setting. Our framework reduces to Shotgun as a special
case when the internal solver is a single coordinate update on the subproblem (2), γ = 1, and for a
suitable σ(cid:48). However, Shotgun is not covered by our convergence theory, since it uses a potentially
un-safe upper bound β instead of σ(cid:48), which isn’t guaranteed to satisfy the condition (21). Other
parallel coordinate descent methods on the L1-objective have recently been analyzed in [9, 28, 21],
but not in the communication-efﬁcient or distributed setting.

Distributed solvers. The methods most closely related to our approach are distributed variants
of GLMNET as in [18]. Inspired by GLMNET and [34], the work of [3, 18] introduced the idea of a
block-diagonal Hessian upper approximation in the distributed L1 context. The later work of [29]
specialized this approach to sparse logistic regression.
If hypothetically each of our quadratic subproblems Gσ(cid:48)
k (∆α[k]) as deﬁned in (2) were to be min-
imized exactly, the resulting steps could be interpreted as block-wise Newton-type steps on each
coordinate block k, where the Newton-subproblem is modiﬁed to also contain the L1-regularizer
[18, 34, 23]. While [18] allows a ﬁxed accuracy for these subproblems—but not arbitrary approxima-
tion quality Θ as in our framework—the work of [29, 34, 31] assumes that the quadratic subproblems
are solved exactly. Therefore, these methods are not able to freely trade off communication and
computation. Also, they do not allow the re-use of arbitrary local solvers. On the theoretical side, the
rate results provided by [18, 29, 34] are not explicit convergence rates but only asymptotic, as the
quadratic upper bounds are not explicitly controlled for safety as with our σ(cid:48).

Batch solvers. ADMM [5], proximal gradient descent, and quasi-Newton methods such as L-BFGS
and are also often used in distributed environments because of their relatively low communication
requirements. However, they require at least a full (distributed) batch gradient computation at each
round, and therefore do not allow the gradual trade-off between communication and computation
provided by PROXCOCOA+. The works of [19] and [15] have obtained encouraging results for
distributed systems employing coordinate descent variants on L1-problems. The latter approach
distributes both columns and rows of the data matrix and can be extended to Lasso. However it
only provides asymptotic improvement per step, and no convergence rate. We include experimental
comparisons with ADMM, prox-GD, and orthant-wise limited memory quasi-Newton (OWL-QN)
[1], an L-BFGS variant that can handle L1 regularization [32], but which has no convergence rate.
Finally, we note that while the provided convergence rates for PROXCOCOA+ mirror the convergence
class of classical batch gradient methods in terms of the number of outer rounds, existing batch
proximal gradient methods come with a weaker theory, as they do not allow general inexactness Θ
for the local subproblem (2). In contrast, our shown convergence rates incorporate this approximation
directly, and, moreover, hold for arbitrary local solvers of much cheaper cost than batch methods
(where in each round, every machine has to process exactly a full pass through the local data). This

6

Figure 1: Suboptimality in terms of D(α) for solving Lasso regression for: url (K=4, λ=1E-4), kddb (K=4,
λ=1E-6), epsilon (K=8, λ=1E-5), and webspam (K=16, λ=1E-5) datasets. PROXCOCOA+ applied to the primal
formulation converges more quickly than all other compared methods in terms of the time in seconds.

makes PROXCOCOA+ more ﬂexible in the distributed setting, as it can adapt to varied communication
costs on real systems. We will see in the following section that this ﬂexibility results in signiﬁcant
performance gains over the competing methods.

6 Experimental Results

In this section we compare PROXCOCOA+ to numerous state-of-the-art methods for large-scale
L1-regularized optimization, including:

• MB-SGD: mini-batch stochastic gradient

• ADMM: alternating direction method

descent with an L1-prox

of multipliers

• PROX-GD: full proximal gradient descent
• OWL-QN: orthant-wise limited quasi-Newton

• MB-CD: mini-batch parallel coordinate

descent, incl. SHOTGUN

The ﬁrst three methods are optimized and implemented in Apache Spark’s MLlib (v1.5.0) [20]. We
employ coordinate descent as a local solver for PROXCOCOA+, and apply PROXCOCOA+ directly
to the primal formulation of Lasso and elastic net, thereby mapping the problem to (A) and solving
this objective directly. A comparison with SHOTGUN is provided as an extreme case to highlight the
detrimental effects of frequent communication in the distributed environment.

We test the performance of each method in large-scale experiments ﬁtting Lasso and elastic net
regression models to the datasets shown in Table 1. All code is written in Apache Spark and
experiments are run on public cloud Amazon EC2 m3.xlarge machines with one core per machine.
For MB-CD, SHOTGUN, and PROXCOCOA+ in the primal, datasets are distributed by feature, whereas
for MB-SGD, PROX-GD, OWL-QN, ADMM, and COCOA+ they are distributed by datapoint.
We carefully tune each competing method for best
performance. ADMM requires the most tuning,
both in selecting the penalty parameter ρ and in solv-
ing the subproblems. Solving the subproblems to
completion for ADMM is prohibitively slow, and
we thus use iterations of conjugate gradient and im-
prove performance by allowing early stopping. We
also use a varying penalty parameter ρ — practices
described in [5, Sec. 4.3, 3.4.1]. For MB-SGD, we
tune the step size and mini-batch size parameters. For MB-CD, we scale the updates at each round
by β
b for mini-batch size b and β ∈ [1, b], and tune both parameters b and β. Further implementation
details for all methods are given in the appendix (Section G).

Dataset
url
epsilon
kddb
webspam

Training
2 M
400 K
19 M
350 K

Features
3 M
2 K
29 M
16 M

Sparsity
3.5e-5
1.0
9.8e-7
2.0e-4

Table 1: Datasets for Empirical Study

Comparison with L1 methods.
In analyzing the performance of each algorithm (Figure 1), we
measure the improvement to the primal objective given in (A) (D(α)) in terms of wall-clock time
in seconds. We see that both MB-SGD and MB-CD are slow to converge, and come with the
additional burden of having to tune extra parameters (though MB-CD makes clear improvements over
MB-SGD). As expected, naively distributing SHOTGUN [7] (single coordinate updates per machine)
does not perform well, as it is tailored to shared-memory systems and requires communicating
too frequently. OWL-QN performs the best of all compared methods, but is still much slower to
converge than PROXCOCOA+, converging, e.g., 50× more slowly for the webspam dataset. The
optimal performance of PROXCOCOA+ is particularly evident in datasets with large numbers of
features (e.g., url, kddb, webspam), which are exactly the datasets of interest for L1 regularization.

7

Figure 2: Suboptimality in terms of D(α) for solving
Lasso for the epsilon dataset (left, K=8) and elastic
net for the url dataset, (right, K=4, λ=1E-4). Speedup
are robust over different regularizers λ (left), and
across problem settings, including varying η parame-
ters of elastic net regularization (right).

Figure 3: Suboptimality in terms of D(α) for solving
Lasso for the webspam dataset (K=16, λ=1E-5). Here
we illustrate how the work spent in the local subprob-
lem (given by H) inﬂuences the total performance of
PROXCOCOA+ in terms of number of rounds as well
as wall time.

Results are shown for regularization parameters λ such that the resulting weight vector α is sparse.
However, our results are robust to varying values of λ as well as to various problem settings, as we
illustrate in Figure 2.

We note that in contrast to the compared meth-
ods, PROXCOCOA+ comes with the beneﬁt of
having only a single parameter to tune: the sub-
problem approximation quality, Θ, which can be
controlled via the number of local subproblem
iterations, H. We further explore the effect of
this parameter in Figure 3, and provide a gen-
eral guideline for choosing it in practice (see
Remark 1). In particular, we see that while in-
creasing H always results in better performance
in terms of rounds, smaller or larger values of
H may result in better performance in terms of
wall-clock time, depending on the cost of com-
munication and computation. The ﬂexibility to
tune H is one of the reasons for PROXCOCOA+’s
signiﬁcant performance gains.

(4a)

(4b)

Sparsity of ﬁnal iterates in (4b)

PROXCOCOA+
0.6030

δ = 0.0001

δ = 0.001

δ = 0.01

0.6035

0.6240

0.6465

(4c)
Figure 4: COCOA+ is ill-equipped to deal with large
feature sizes as compared to PROXCOCOA+, and the
gap in performance increases as the regularizer be-
comes less strongly convex, e.g., as η → 1.0 for elastic
net (4a). For pure L1 regularization, Nesterov smooth-
ing is not an effective option for COCOA+. It either
modiﬁes the solution (4c) or slows convergence (4b).

Comparison with COCOA+. Finally, we
point out several
important ways in which
PROXCOCOA+ improves upon the COCOA+
framework [17]. First, COCOA+ cannot be in-
cluded in the set of experiments in Figure 1 because it cannot be directly applied to the Lasso
objective (COCOA+ only allows for strongly convex regularizers1). Second, as shown in Figure 4,
the performance of COCOA+ degrades drastically when considering datasets with large numbers
of features, such as the webspam dataset. One reason for this is that COCOA+ distributes data by
data point, which necessitates communicating a vector of length equal to the feature size. When the
feature size is large, this can become expensive. The results shown hold despite the fact that we have
tuned H (the number of local solver iterations) separately for both PROXCOCOA+ and COCOA+.
Beyond communication, we also see that COCOA+ is slower to converge as the regularizer becomes
less strongly convex (Figure 4a). Indeed, even when the number of features is relatively low such as for
the epsilon dataset, we see that the performance of COCOA+ degrades signiﬁcantly as the regularizer
approaches pure L1. In Figure 4, we illustrate this by implementing the Nesterov smoothing technique
used in, e.g., [27, 35] — adding a small amount of strong convexity δ(cid:107)α(cid:107)2
2 to the objective for Lasso
regression. We show results for decreasing levels of δ. As δ decreases, the ﬁnal sparsity of the
problem starts to match that of running pure L1 (Figure 4c), but the performance also degrades
(Figure 4b). We note again that through the modiﬁcation presented in Section 4, we can deliver strong
rates without having to make these fundamental alterations to the problem of interest.

1COCOA+ in [17] is in fact limited to the case where the regularizer is equal to the L2 norm 1

the extension to strongly convex regularizers is covered as a special case in our analysis.

2 (cid:107) · (cid:107)2

2, though

8

We thank Michael P. Friedlander and Martin Takáˇc for fruitful discussions.

Acknowledgments

References

[1] G. Andrew and J. Gao. Scalable training of L1-regularized log-linear models. In ICML, 2007.
[2] H. H. Bauschke and P. L. Combettes. Convex Analysis and Monotone Operator Theory in Hilbert Spaces.

CMS Books in Mathematics. Springer New York, New York, NY, 2011.

[3] Y. Bian et al. Parallel coordinate descent newton method for efﬁcient g1-regularized minimization.

arXiv.org, 2013.

[4] J. M. Borwein and Q. Zhu. Techniques of Variational Analysis and Nonlinear Optimization. Canadian

Mathematical Society Books in Math, Springer New York, 2005.

[5] S. Boyd et al. Distributed optimization and statistical learning via the alternating direction method of

multipliers. Foundations and Trends in Machine Learning, 3(1):1–122, 2010.

[6] S. Boyd and L. Vandenberghe. Convex Optimization. Cambridge University Press, 2004.
[7] J. K. Bradley et al. Parallel coordinate descent for l1-regularized loss minimization. In ICML, 2011.
[8] C. Dünner et al. Primal-Dual Rates and Certiﬁcates. In ICML, 2016.
[9] O. Fercoq and P. Richtárik. Accelerated, Parallel, and Proximal Coordinate Descent. SIAM Journal on

Optimization, 25(4):1997–2023, Oct. 2015.

[10] S. Forte. Distributed Optimization for Non-Strongly Convex Regularizers. Master’s thesis, ETH Zürich,

Sept. 2015.

ICML, 2015.

[11] J. Friedman, T. Hastie, and R. Tibshirani. Regularization paths for generalized linear models via coordinate

descent. Journal of Statistical Software, 33(1):1–22, 2010.

[12] M. Jaggi et al. Communication-efﬁcient distributed dual coordinate ascent. In NIPS, 2014.
[13] T. Johnson and C. Guestrin. Blitz: A Principled Meta-Algorithm for Scaling Sparse Optimization. In

[14] S. M. Kakade, S. Shalev-Shwartz, and A. Tewari. On the duality of strong convexity and strong smoothness:

Learning applications and matrix regularization. Technical report, TTI, 2009.

[15] Kang et al. Data/feature distributed stochastic coordinate descent for logistic regression. In CIKM, 2014.
[16] Z. Lu and L. Xiao. On the complexity analysis of randomized block-coordinate descent methods. arXiv.org,

[17] C. Ma et al. Adding vs. averaging in distributed primal-dual optimization. In ICML, 2015.
[18] D. Mahajan, S. S. Keerthi, and S. Sundararajan. A distributed block coordinate descent method for training

l1 regularized linear classiﬁers. arXiv.org, 2014.

[19] H. B. McMahan et al. Ad click prediction: a view from the trenches. In KDD, 2013.
[20] X. Meng et al. Mllib: Machine learning in apache spark. arXiv.org, 2015.
[21] I. Necoara and D. Clipici. Parallel Random Coordinate Descent Method for Composite Minimization:
Convergence Analysis and Error Bounds. SIAM Journal on Optimization, 26(1):197–226, Jan. 2016.
[22] Y. Nesterov. Smooth minimization of non-smooth functions. Mathematical Programming, 103(1):127–152,

[23] Z. Qu et al. SDNA: Stochastic dual newton ascent for empirical risk minimization. arXiv.org, 2015.
[24] R. T. Rockafellar. Convex Analysis. Princeton University Press, 1997.
[25] S. Shalev-Shwartz and A. Tewari. Stochastic methods for l1-regularized loss minimization. Journal of

Machine Learning Research, 12:1865–1892, 2011.

[26] S. Shalev-Shwartz and T. Zhang. Stochastic dual coordinate ascent methods for regularized loss minimiza-

tion. Journal of Machine Learning Research, 14:567–599, 2013.

[27] S. Shalev-Shwartz and T. Zhang. Accelerated proximal stochastic dual coordinate ascent for regularized

loss minimization. Mathematical Programming, Series A:1–41, 2014.

[28] R. Tappenden and P. Richtárik. On the complexity of parallel coordinate descent. arXiv.org, 2015.
[29] I. Troﬁmov and A. Genkin. Distributed coordinate descent for l1-regularized logistic regression. arXiv.org,

[30] T. Yang. Trading computation for communication: Distributed stochastic dual coordinate ascent. In NIPS,

2013.

2005.

2014.

2013.

[31] I. E.-H. Yen, S.-W. Lin, and S.-D. Lin. A Dual Augmented Block Minimization Framework for Learning

with Limited Memory. In NIPS, 2015.

[32] J. Yu, S. Vishwanathan, S. Günter, and N. N. Schraudolph. A quasi-newton approach to nonsmooth convex

optimization problems in machine learning. Journal of Machine Learning Research, 2010.

9

[33] G.-X. Yuan et al. A comparison of optimization methods and software for large-scale l1-regularized linear

classiﬁcation. Journal of Machine Learning Research, 2010.

[34] G.-X. Yuan, C.-H. Ho, and C.-J. Lin. An improved glmnet for l1-regularized logistic regression. Journal

[35] Y. Zhang and X. Lin. Stochastic Primal-Dual Coordinate Method for Regularized Empirical Risk Mini-

[36] S. Zheng et al. A general distributed dual coordinate optimization framework for regularized loss mini-

of Machine Learning Research, 2012.

mization. In ICML, 2015.

mization. In arXiv.org, 2016.

10

Appendix

A Deﬁnitions

Deﬁnition 2 (L-Lipschitz Continuity). A function f : Rd → R is L-Lipschitz continuous if ∀a, b ∈
Rd, we have

|f (a) − f (b)| ≤ L(cid:107)a − b(cid:107) .
(10)
Deﬁnition’ 1 (L-Bounded Support). A function f : Rd → R has L-bounded support if its effective
domain is bounded by L, i.e.,

f (u) < +∞ ⇒ (cid:107)u(cid:107) ≤ L .
(11)
Deﬁnition 3 (L-Smoothness). A function f : Rd → R is called L-smooth, for L > 0, if it is
differentiable and its derivative is L-Lipschitz continuous, or equivalently

f (u) ≤ f (w) + (cid:104)∇f (w), u − w(cid:105) +

(cid:107)u − w(cid:107)2

∀u, w ∈ Rd .

Deﬁnition 4 (µ-Strong Convexity). A function f : Rd → R is called µ-strongly convex, for µ ≥ 0, if

f (u) ≥ f (w) + (cid:104)∇f (w), u − w(cid:105) +

(cid:107)u − w(cid:107)2

∀u, w ∈ Rd .

And analogously if the same holds for all subgradients, in the case of a general closed convex
function f .

L
2

µ
2

B Convex Conjugates

The convex conjugate of a function f : Rd → R is deﬁned as

f ∗(v) := max
u∈Rd

vT u − f (u) .

Below we list several useful properties of conjugates (see, e.g., [6, Section 3.3.2]):

• Double conjugate:

(f ∗)∗ = f if f is closed and convex.

• Value Scaling: (for α > 0)

f (v) = αg(v)

⇒

f ∗(w) = αg∗(w/α) .

• Argument Scaling: (for α (cid:54)= 0)

• Conjugate of a separable sum:

f (v) = g(αv)
f (v) = (cid:80)

i φi(vi)

⇒

⇒

f ∗(w) = g∗(w/α) .
f ∗(w) = (cid:80)
i φ∗

i (wi) .

Lemma 3 (Duality between Lipschitzness and L-Bounded Support, [24, Corollary 13.3.3]). Given a
proper convex function f , it holds that f is L-Lipschitz if and only if f ∗ has L-bounded support.

Lemma 4 (Duality between Smoothness and Strong Convexity, [14, Theorem 6]). Given a closed
the norm (cid:107) · (cid:107) if and only if f ∗ is
convex function f , it holds that f is µ strongly convex w.r.t.
(1/µ)-smooth w.r.t. the dual norm (cid:107) · (cid:107)∗.

(12)

(13)

(14)

C Applications

C.1 L1 and General Non-Strongly Convex Regularizers

L1 regularization is obtained in the objective (A) by letting gi(·) := λ| · |. Primal-dual convergence
can be obtained by using the modiﬁcation introduced in Section 4, which will guarantee L-bounded
support. Formally, we replace gi(·) = | · | by

¯g(α) :=

(cid:26)|α|

: α ∈ [−B, B]

+∞ : otherwise.

For large enough B, this problem yields the same solution as the original L1-objective. We provide a
detailed proof and description of this technique in Section D.3. Note that this only affects convergence
theory, in that it allows us to present a strong primal-dual rate (Theorem 1 for L=B).

11

C.2 Elastic Net and General Strongly Convex Regularizers

2 (cid:107)α(cid:107)2
Another application we can consider is elastic net regularization, η
2 + (1 − η) (cid:107)α(cid:107)1, for ﬁxed
parameter η ∈ (0, 1], which is obtained by setting gi(α) := λ(cid:2) η
2 α2 + (1 − η)|α|(cid:3) in (A). For the
special case η = 0, we obtain the L1-norm. For elastic-net-regularized problems of the form (A),
Theorem 2 gives a global linear (geometric) convergence rate, since gi is η-strongly convex. This
holds as long as the data-ﬁt function is smooth (see Section C.4), and directly yields a primal-dual
algorithm and corresponding rate.

C.3 Local Solvers for L1 and Elastic Net

For the L1-regularizer in the primal setting, the local subproblem (2) becomes a simple quadratic
problem on the local data, with regularization applied only to local variables α[k]. Therefore, existing
fast L1-solvers for the single-machine case, such as GLMNET variants [11] or BLITZ [13] can be
directly applied to each local subproblem Gσ(cid:48)
k ( · ; v, α[k]) within Algorithm 1. The sparsity induced
on the subproblem solutions of each machine naturally translates into the sparsity of the global
solution, since the local variables α[k] will be concatenated.
In terms of the approximation quality parameter Θ for the local problems (Assumption 1), we can
apply existing recent convergence results from the single machine case. For example, for randomized
coordinate descent (as part of GLMNET), [16, Theorem 1] gives a O(1/t) approximation quality for
any separable regularizer, including L1 and elastic net; see also [28, 25].

C.4 Smooth Data-Fit Functions

To illustrate the role of f as a smooth data-ﬁt function in this section—contrasting with its role as a
regularizer in traditional COCOA+ as we discuss in Section F—we consider the following examples.
Least squares loss. Let b ∈ Rd be labels or response values, and consider the least squares
objective f (v) := 1
2 (cid:107)v − b(cid:107)2
2, which is 1-smooth. We obtain the familiar least-squares regression
objective in our optimization problem (A), using
f (Aα) := 1

2 (cid:107)Aα − b(cid:107)2
2 .

Observing that the gradient of f is ∇f (v) = v − b, the dual-to-primal mapping is given by: w(α)
:= ∇f (v(α)) = Aα − b, which is well known as the residual vector in least-squares regression.

Logistic regression loss. For classiﬁcation problems, we consider a logistic regression model with
d training examples yj ∈ Rn for j ∈ [d] collected as the rows of the data matrix A. For each training
example, we are given a binary label, which we collect in the vector b ∈ {−1, 1}d. Formally, the
objective is deﬁned as f (v) := (cid:80)d
j=1 log (1 + exp (−bjvj)), which is again a separable function.
The classiﬁer loss is given by

f (Aα) :=

log (1 + exp (−bjyT

j α)) ,

(15)

d
(cid:88)

j=1

where α ∈ Rn is the parameter vector. It is not hard to show that f is 1-smooth if the labels satisfy
bj ∈ [−1, 1]; see e.g. Lemma 5 below. The primal-dual mapping w(α) := ∇f (v(α)) = ∇f (Aα)
is given by wj(α) =

−bj

1+exp (bj yT

j α) .

D Proofs of Primal-Dual Relationship

In the following subsections we provide derivations of the primal-dual relationship of the general
objectives (A) and (B), and then show how to derive this primal-dual setup for various applications.

D.1 Primal-Dual Relationship

The relation of our original formulation (A) to its dual formulation (B) is standard in convex analysis,
and is a special case of the concept of Fenchel Duality. Using the combination with the linear map
A as in our case, the relationship is called Fenchel-Rockafellar Duality, see e.g. [4, Theorem 4.4.2]
or [2, Proposition 15.18]. For completeness, we illustrate this correspondence with a self-contained
derivation of the duality.

12

Starting with the original formulation (A), we introduce a helper variable vector v ∈ Rd representing
v = Aα. Then optimization problem (A) becomes:

min
α∈Rn

f (v) + g(α)

such that v = Aα .

(16)

Introducing Lagrange multipliers w ∈ Rd, the Lagrangian is given by:

L(α, v; w) := f (v) + g(α) + wT (Aα − v) .

The dual problem of (A) follows by taking the inﬁmum with respect to both α and v:

inf
α,v

L(w, α, v) = inf
v

(cid:8)f (v) − wT v(cid:9) + inf

(cid:8)g(α) + wT Aα(cid:9)

= − sup

(cid:8)wT v − f (v)(cid:9) − sup

(cid:8)(−wT A)α − g(α)(cid:9)

α

α

(17)
We change signs and turn the maximization of the dual problem (17) into a minimization and thus we
arrive at the dual formulation (B) as claimed:

= −f ∗(w) − g∗(−AT w) .

P(w) := f ∗(w) + g∗(−AT w)

(cid:105)

.

min
w∈Rd

v

(cid:104)

D.2 Conjugates and Smoothness of f -Functions of Interest

Lemma 5 (Conjugate and Smoothness of the Logistic Loss). The logistic classiﬁer loss function

f (Aα) :=

log (1 + exp (−bjyT

j α))

d
(cid:88)

j=1

(see also (15) above) is the conjugate of f ∗, where

f ∗(w) :=

(cid:0)(1 + wjbj) log (1 + wjbj) − wjbj log (−wjbj)(cid:1) ,

(18)

d
(cid:88)

j=1

with the box constraint −wjbj ∈ [0, 1].
Furthermore, f ∗(w) is 1-strongly convex over its domain if the labels satisfy bj ∈ [−1, 1].

Proof of Lemma 5. By separability of f ∗, the conjugate of f ∗(v) = (cid:80)
(cid:80)

j φj(wj). For the losses, the conjugate pairs are φj(u) = log(1 + exp(−bju)), and φ∗
−wjbj log(−wjbj) + (1 + wjbj) log(1 + wjbj) with −wjbj ∈ [0, 1], see e.g. [26, Page 577].

j (vj) is f (w) =
j (wj) =

j φ∗

the strong convexity, we show 1-strong smoothness of

j=1 log (1 + exp (−bjvj)) = (cid:80)d

For
(cid:80)d
Using the second derivative h(cid:48)(cid:48)(a) = e−a
that ∇2f (v) = diag(cid:0)(h(cid:48)(cid:48)(bjvj)b2
the Euclidean norm.

j )j

:=
j=1 h(bjvj), which is an equivalent property, see Lemma 4.
(1+e−a)2 ≤ 1 of the function h(a) = log(1 + e−a), we have
(cid:1) = diag(cid:0)(
(cid:1) ≤ 1, so f (v) is 1-smooth w.r.t.

the conjugate f (v)

e−bj vj
(1+e−bj vj )2 b2
j )j

D.3 Conjugates of Common Regularizers

Lemma 6 (Conjugate of the Elastic Net Regularizer). For η ∈ (0, 1], the elastic net function
gi(α) := η

2 α2 + (1 − η)|α| is the convex conjugate of

g∗
i (x) := 1
2η

(cid:0)(cid:2)|x| − (1 − η)(cid:3)

(cid:1)2

,

+

where [.]+ is the positive part operator, [s]+ = s for s > 0, and zero otherwise. Furthermore, this g∗
is smooth, i.e. has Lipschitz continuous gradient with constant 1/η.

Proof. We start by applying the deﬁnition of convex conjugate, that is:
(cid:105)
g∗(x) = maxα∈R

(cid:104)
xα − η α2

2 − (1 − η)|α|

.

We now distinguish two cases for the optimal: α(cid:63) ≥ 0, α(cid:63) < 0. For the ﬁrst case we get that
(cid:104)

(cid:105)

g∗(x) = maxα∈R

xα − η α2

2 − (1 − η)α

.

13

Setting the derivative to 0 we get α(cid:63) = x−(1−η)
Replacing with α(cid:63) we thus get:
g∗(x) = α(cid:63)(x − 1

η

2 ηα(cid:63) − (1 − η)) = α(cid:63) (cid:0)x − 1
2 α(cid:63) (x − (1 − η)) = 1

1

2η (x − (1 − η))2 .

2 (x − (1 − η)) − (1 − η)(cid:1) =

. To satisfy α(cid:63) ≥ 0, we must have x ≥ 1 − η.

Similarly we can show that for x ≤ −(1 − η)
g∗(x) = 1

2η (x + (1 − η))2 .

Finally, by the fact that g∗(.) is convex, always positive, and g∗(−(1 − η)) = g∗(1 − η) = 0, it
follows that g∗(x) = 0 for every x ∈ [−(1 − η), 1 − η].
For the smoothness properties, we consider the derivative of this function g∗(x) and see that g∗(x) is
smooth, i.e. has Lipschitz continuous gradient with constant 1/η, assuming η > 0.

Continuous conjugate modiﬁcation for indicator functions. To apply the theoretical conver-
gence result from Theorem 1 to objectives with L1 norms, we modify the function | · | by imposing
an additional constraint. Consider replacing gi(·) = | · | by

¯g(α) :=

(cid:26)|α|

: α ∈ [−B, B]

+∞ : otherwise.

min
α∈Rn

f (Aα) + λ

¯g(αi) .

n
(cid:88)

i=1

With this modiﬁed L1-regularizer, the optimization problem (A) with regularization parameter λ
becomes

(19)

(20)

For large enough choice of the value B, this problems yields the same solution as the original
objective:

(cid:104)

min
α∈Rn

D(α) := f (Aα) + λ

(cid:105)

.

|αi|

n
(cid:88)

i=1

As we can see, the ¯g is nothing more than a constrained version of the absolute value to the interval
[−B, B]. Therefore by setting B to a large enough value that the interesting values of αi will never
reach, we can have continuous ¯g∗ and at the same time make (19) equivalent to (20).

Formally, a simple way to obtain a large enough value of B, so that all solutions of (20) are unaffected
is the following. Note that we start the algorithm at α = 0. For every solution encountered during
the execution of the algorithm, the objective values should never become worse than D(0). In other
words, we restrict the D(·) optimization problem to the level set given by the initial starting value.
Formally, this means that for every i, we will always require:

λ|αi| ≤ f (0) = D(0) =⇒ |αi| ≤

f (0)
λ

.

(Note that f (α) ≥ 0 holds without loss of generality). We can thus set the value of B to be f (0)
λ .

Lemma 7 (Conjugate of the modiﬁed L1-norm). The convex conjugate of ¯gi as deﬁned above is

(cid:26)0

¯g∗(x) =

B(|x| − 1)

: x ∈ [−1, 1]
: otherwise,

and is B-Lipschitz.

Proof. We start by applying the deﬁnition of convex conjugate:
[αx − ¯g∗(x)] .

¯g(α) = sup
x∈R

We begin by looking at the case in which α ≥ B; in this case it’s easy to see that when x → +∞, we
have:

αx − B(|x| − 1) = (α − B)x − B → +∞
as α − B ≥ 0. The case α ≤ −B holds analogously. We’ll now look at the case α ∈ [0, B]; in this
case it is clear we must have x(cid:63) ≥ 0. It also must hold that x(cid:63) ≤ 1, since

for every x > 1. Therefore the maximization becomes

αx − B(x − 1) < αx

14

which has maximum α at x = 1. The remaining α ∈ [−B, 0] case follows in similar fashion.

¯g(α) = sup
x∈[0,1]

αx ,

E Convergence Proofs

In this section we provide proofs of our main convergence results. The results are motivated by [17],
but where we have signiﬁcantly generalized the problem of interest, and where we derive separate
meaning by applying the problem directly to (A). We provide full details of Lemma 8 as a proof of
concept, but omit details in later proofs that can be derived using the arguments in [17] or earlier
work of [26], and instead outline the proof strategy and highlight sections where the theory deviates.

E.1 Approximation of D(·) by the Local Subproblems Gσ(cid:48)

k (·)

We begin with a deﬁnition of the data-dependent aggregation parameter for PROXCOCOA+, σ(cid:48), which
we will use in the throughout our convergence results.
Deﬁnition 5 (Data-dependent aggregation parameter). In Algorithm 1, the aggregation parameter γ
controls the level of adding (γ := 1) versus averaging (γ := 1
K ) of the partial solutions from all
machines. For the convergence results discussed below to hold, the subproblem parameter σ(cid:48) must be
chosen not smaller than

σ(cid:48) ≥ σ(cid:48)

min := γ max
α∈Rn

(cid:107)Aα(cid:107)2
k=1 (cid:107)Aα[k](cid:107)2

(cid:80)K

.

(21)

The simple choice of σ(cid:48) := γK is valid for (21), i.e.,
γK ≥ σ(cid:48)

min .

In some cases, it will be possible to give better (data-dependent) choices for σ(cid:48), closer to the actual
bound given in σ(cid:48)

min.

Our ﬁrst lemma in the overall proof of convergence helps to relate change in local subproblems to the
global objective D(·).
Lemma 8. For any dual α, ∆α ∈ Rn, v = v(α) := Aα, and real values γ, σ(cid:48) satisfying (21), it
holds that

(cid:16)

D

α + γ

(cid:17)
∆α[k]

K
(cid:88)

k=1

≤ (1 − γ)D(α) + γ

Gσ(cid:48)
k (∆α[k]; v, α[k]) .

(22)

Proof. In this proof we follow the line of reasoning in [17, Lemma 4] with a more general (1/τ )
smoothness assumption on f (·). An outer iteration of PROXCOCOA+ performs the following update:

D(α + γ

∆α[k]) = f (v(α + γ

∆α[k]))

+

gi(αi + γ(

∆α[k])i)

.

(23)

K
(cid:88)

k=1

K
(cid:88)

k=1
(cid:123)(cid:122)
A

(cid:124)

K
(cid:88)

k=1

(cid:123)(cid:122)
B

(cid:125)

We bound the terms A and B separately. First we bound A using (1/τ )-smoothness of f :

(cid:16)

(cid:17)

(cid:16)

A = f

v(α + γ

∆α[k])

= f

v(α) + γ

v(∆α[k])

(cid:17)

K
(cid:88)

k=1

smoothness of f as in (12)
≤

f (v(α)) +

γ∇f (v(α))T v(∆α[k]) +

v(α[k])(cid:107)2

K
(cid:88)

k=1

n
(cid:88)

i=1
(cid:124)

(cid:125)

K
(cid:88)

k=1

deﬁnition of w as in (5)
≤

f (v(α)) +

γv(∆α[k])T w(α) +

v(α[k])(cid:107)2

safe choice of σ(cid:48) as in (21)
≤

f (v(α)) +

γv(∆α[k])T w(α) +

γσ(cid:48)

(cid:107)v(α[k])(cid:107)2 .

K
(cid:88)

k=1

K
(cid:88)

k=1

K
(cid:88)

k=1

15

γ2
2τ

(cid:107)

K
(cid:88)

k=1

γ2
2τ

(cid:107)

K
(cid:88)

k=1

1
2τ

K
(cid:88)

k=1

Next we use Jensen’s inequality to bound B:

(cid:32)

K
(cid:88)

(cid:88)

k=1

i∈Pk

B =

gi(αi + γ(∆α[k])i)

=

gi((1 − γ)αi + γ(α + ∆α[k])i)

(cid:33)

(cid:33)

(1 − γ)gi(αi) + γgi(αi + ∆α[k]i)

.

(cid:33)

(cid:32)

K
(cid:88)

(cid:88)

k=1

K
(cid:88)

(cid:32)

i∈Pk

(cid:88)

k=1

i∈Pk

≤

Plugging A and B back into (23) yields:

(cid:16)

D

α + γ

(cid:17)

∆α[k]

K
(cid:88)

k=1

K
(cid:88)

k=1

≤ f (v(α)) ± γf (v(α)) +

γv(∆α[k])T w(α) +

γσ(cid:48)

(cid:107)v(α[k])(cid:107)2

1
2τ

K
(cid:88)

k=1

(1 − γ)gi(αi) + γgi(αi + ∆α[k]i)

= (1 − γ)f (v(α)) +

(1 − γ)gi(αi)

(cid:32)

K
(cid:88)

(cid:88)

i∈Pk

k=1
(cid:123)(cid:122)
(1−γ)D(α)

K
(cid:88)

(cid:88)

+

k=1

i∈Pk

(cid:124)

+ γ

(cid:32)

K
(cid:88)

k=1

1
K

(cid:33)

(cid:125)

σ(cid:48)
2τ

(2)= (1 − γ)D(α) + γ

Gσ(cid:48)
k (∆α[k]; v) ,

K
(cid:88)

k=1

f (v(α)) + v(∆α[k])T w(α) +

(cid:107)v(α[k])(cid:107)2 +

gi(αi + ∆α[k]i)

(cid:33)

(cid:88)

i∈Pk

where the last equality is by the deﬁnition of the subproblem objective Gσ(cid:48)

k (.) as in (2).

E.2 Proof of Main Convergence Result (Theorem 1)

Before proving the main convergence results, we introduce several useful quantities, including the
the following lemma, which characterizes the effect of iterations of Algorithm 1 on the duality gap
for any chosen local solver of approximation quality Θ.
Lemma 9. Let gi be strongly2 convex with convexity parameter µ ≥ 0 with respect to the norm (cid:107) · (cid:107),
∀i ∈ [n]. Then for all iterations t of Algorithm 1 under Assumption 1, and any s ∈ [0, 1], it holds that

E[D(α(t)) − D(α(t+1))] ≥ γ(1 − Θ)

sG(α(t)) −

(cid:16)

σ(cid:48)s2
2τ

R(t)(cid:17)

,

R(t) := − τ µ(1−s)

(cid:107)u(t) − α(t)(cid:107)2 + (cid:80)K

σ(cid:48)s

k=1(cid:107)A(u(t) − α(t))[k](cid:107)2 ,

where

for u(t) ∈ Rn with

u(t)
i ∈ ∂g∗

i (−xT

i w(α(t))) .

(24)

(25)

(26)

Proof. The line of proof is motivated by [26, Lemma 19] and follows [17, Lemma 5], with a main
addition being the extension to our generalized subproblems Gσ(cid:48)
k (·; v, α[k]) along with the general
mappings w(α) := ∇f (v(α)) with v(α) := Aα.

For simplicity, we write α instead of α(t), v instead of v(α(t)), w instead of w(α(t)) and u instead
of u(t). We can estimate the expected change of the objective D(α) as follows. Starting from the
deﬁnition of the update α(t+1) := α(t) + γ (cid:80)
k ∆α[k] from Algorithm 1, we apply Lemma 8, which
relates the local approximation Gσ(cid:48)
k (α; v, α[k]) to the global objective D(α), and then bound this

2Note that the case of weakly convex gi(.) is explicitly allowed here as well, as the Lemma holds for the

case µ = 0.

16

using the notion of quality of the local solver (Θ), as in Assumption 1. This gives us:

(cid:104)
E(cid:2)D(α(t)) − D(α(t+1))(cid:3) = E

D(α) − D

α + γ

(cid:16)

(cid:17)(cid:105)

∆α[k]

K
(cid:88)

k=1

K
(cid:88)

k=1

(cid:123)(cid:122)
C








(cid:124)








(cid:125)

≥ γ(1 − Θ)

D(α) −

Gσ(cid:48)
k (∆α(cid:63)

[k]; v, α[k])

.

(27)

We next upper bound the C term, denoting ∆α(cid:63) = (cid:80)K
the objective D in (A) and the local subproblems (2), and then substitute s(ui − αi) for ∆α(cid:63)
apply the µ-strong convexity of the gi terms. This gives us:

[k]. We ﬁrst plug in the deﬁnition of
i and

k=1 ∆α(cid:63)

(gi(αi) − gi(αi + ∆α(cid:63)

i )) − (A∆α(cid:63))T w(α) −

K
(cid:88)

k=1

σ(cid:48)
2τ

(cid:13)
(cid:13)A∆α(cid:63)
(cid:13)

[k]

(cid:13)
2
(cid:13)
(cid:13)

n
(cid:88)

C =

i=1
n
(cid:88)

(cid:16)

i=1

≥

sgi(αi) − sgi(ui) +

(1 − s)s(ui − αi)2(cid:17)

µ
2

− A(s(u − α))T w(α) −

K
(cid:88)

k=1

σ(cid:48)
2τ

(cid:13)
(cid:13)
2
(cid:13)
(cid:13)
(cid:13)A(s(u − α)[k])
(cid:13)

.

From the deﬁnition of the primal and dual optimization problems (A) and (B), and deﬁnition of
convex conjugates, we can write the duality gap as:

G(α) := P(w(α)) − (−D(α))

(A),(B)
=

(cid:0)g∗

i (−xT

i w(α)) + gi(αi)(cid:1) + f ∗(w(α)) + f (Aα))

n
(cid:88)

i=1

=

=

=

n
(cid:88)

i=1
n
(cid:88)

i=1
n
(cid:88)

i=1

(cid:0)g∗

i (−xT

i w(α)) + gi(αi)(cid:1) + f ∗(∇f (Aα)) + f (Aα)

(cid:0)g∗

i (−xT

i w(α)) + gi(αi)(cid:1) + (Aα)T w(α)

(cid:0)g∗

i (−xT

i w(α)) + gi(αi) + αixT

i w(α)(cid:1) .

(28)

(29)

(30)

The convex conjugate maximal property from (26) implies that
i (−xT

gi(ui) = ui(−xT

i w(α)) − g∗

i w(α)) .

Using (30) and (29), we therefore have:

n
(cid:88)

(cid:16)

(30)
≥

C

i=1

sgi(αi) − sui(−xT

i w(α)) + sg∗

i (−xT

i w(α)) +

(1 − s)s(ui − αi)2(cid:17)

µ
2

− A(s(u − α))T w(α) −

K
(cid:88)

k=1

σ(cid:48)
2τ

(cid:13)
(cid:13)
(cid:13)A(s(u − α)[k])

(cid:13)
2
(cid:13)
(cid:13)

=

n
(cid:88)

i=1

(cid:2)sgi(αi) + sg∗

i (−xT

i w(α)) + sxT

i w(α)αi

(cid:3) −

(cid:2)sxT

i w(α)(αi − ui) −

(1 − s)s(ui − αi)2(cid:3)

µ
2

n
(cid:88)

i=1

− A(s(u − α))T w(α) −

K
(cid:88)

k=1

σ(cid:48)
2τ

(cid:13)
(cid:13)
(cid:13)A(s(u − α)[k])

(cid:13)
2
(cid:13)
(cid:13)

(29)= sG(α) +

(1 − s)s(cid:107)u − α(cid:107)2 −

(cid:107)A(u − α)[k](cid:107)2 .

(31)

µ
2

σ(cid:48)s2
2τ

K
(cid:88)

k=1

17

The claimed improvement bound (24) then follows by plugging (31) into (27).

The following Lemma provides a uniform bound on R(t):
Lemma 10. If g∗

i are L-Lipschitz continuous for all i ∈ [n], then

where

∀t : R(t) ≤ 4L2

σknk

,

K
(cid:88)

k=1
(cid:124)

(cid:123)(cid:122)
=:σ

(cid:125)

σk := max
α[k]∈Rn

(cid:107)Aα[k](cid:107)2
(cid:107)α[k](cid:107)2 .

Proof. [17, Lemma 6]. For general convex functions, the strong convexity parameter is µ = 0, and
hence the deﬁnition (25) of the complexity constant R(t) becomes

R(t) =

(cid:107)A(u(t) − α(t))[k](cid:107)2

σk(cid:107)(u(t) − α(t))[k](cid:107)2 ≤

σk|Pk|4L2 .

K
(cid:88)

k=1

(33)
≤

K
(cid:88)

k=1

K
(cid:88)

k=1

Here the last inequality follows from in [26, Lemma 21], which shows that for g∗
L-Lipschitz, it holds that for any real value a with |a| > L one has that gi(a) = +∞.

i : R → R being

Remark 2. [17, Remark 7] If all data points xi are normalized such that (cid:107)xi(cid:107) ≤ 1 ∀i ∈ [n], then
σk ≤ |Pk| = nk. Furthermore, if we assume that the data partition is balanced, i.e., that nk = n/K
for all k, then σ ≤ n2/K. This can be used to bound the constants R(t), above, as R(t) ≤ 4L2n2
K .
Theorem 11. Consider Algorithm 1, using a local solver of quality Θ (See Assumption 1). Let g∗
i (·)
be L-Lipschitz continuous, and (cid:15)G > 0 be the desired duality gap (and hence an upper-bound on
suboptimality (cid:15)D). Then after T iterations, where

(cid:108)
T ≥ T0 + max{

(cid:109)
,

1
γ(1 − Θ)
(cid:19) (cid:105)

4L2σσ(cid:48)
τ (cid:15)Gγ(1 − Θ)
(cid:108)

,

t0 ≥ max(0,

} ,

T0 ≥ t0 +

(cid:104)

2
γ(1 − Θ)

(cid:18) 8L2σσ(cid:48)
τ (cid:15)G

− 1

+

we have that the expected duality gap satisﬁes

1

γ(1−Θ) log

(cid:16) τ (D(α(0))−D(α(cid:63)))
2L2σσ(cid:48)

(cid:17) (cid:109)

) ,

at the averaged iterate

E[P(w(α)) − (−D(α))] ≤ (cid:15)G

α := 1

T −T0

(cid:80)T −1

t=T0+1α(t) .

Proof. This proof draws from the line of reasoning in [26, Theorem 2] and follows [17, Theorem
8] but for the more general problem setting (A). We begin by estimating the expected change of
feasibility for D. We can bound this above by using Lemma 9 and the fact that the P(·) is always a
lower bound for −D(·), and then applying (32) to ﬁnd:

E[D(α(t+1)) − D(α(cid:63))] ≤ (1 − γ(1 − Θ)s) (D(α(t)) − D(α(cid:63))) + γ(1 − Θ) σ(cid:48)s2

2τ 4L2σ .

(36)

Using (36) recursively we have

E[D(α(t)) − D(α(cid:63))] ≤ (1 − γ(1 − Θ)s)t (D(α(0)) − D(α(cid:63))) + s

Choosing s = 1 and t = t0 := max{0, (cid:100)

1

γ(1−Θ) log(2(D(α(0)) − D(α(cid:63)))/(4L2σσ(cid:48)))(cid:101)} will lead to

4L2σσ(cid:48)
2τ

.

4L2σσ(cid:48)
2τ

≤

4L2σσ(cid:48)
τ

.

E[D(α(t)) − D(α(cid:63))] ≤ (1 − γ(1 − Θ))t0 (D(α(0)) − D(α(cid:63))) +

Next, we show inductively that

∀t ≥ t0 : E[D(α(t)) − D(α(cid:63))] ≤

4L2σσ(cid:48)

τ (1 + 1

2 γ(1 − Θ)(t − t0))

.

18

(32)

(33)

(34)

(35)

(37)

(38)

(39)

Clearly, (38) implies that (39) holds for t = t0. Assuming that it holds for any t ≥ t0, we show that
it must also hold for t + 1. Indeed, using

s =

1 + 1

2 γ(1 − Θ)(t − t0)

∈ [0, 1] ,

we obtain

E[D(α(t+1)) − D(α(cid:63))] ≤

4L2σσ(cid:48)
τ

(cid:18) 1 + 1

2 γ(1 − Θ)(t − t0) − 1
(1 + 1

2 γ(1 − Θ)(t − t0))2

2 γ(1 − Θ)

(cid:19)

(cid:125)

1

(cid:124)

by applying the bounds (36) and (39), plugging in the deﬁnition of s (40), and simplifying. We
upperbound the term D using the fact that geometric mean is less or equal to arithmetic mean:

1 + 1

2 γ(1 − Θ)(t + 1 − t0)

(1 + 1

2 γ(1 − Θ)(t + 1 − t0))(1 + 1
(1 + 1

2 γ(1 − Θ)(t − t0))2

2 γ(1 − Θ)(t − 1 − t0))

(cid:123)(cid:122)
D

(cid:123)(cid:122)
≤1

D =

≤

1

1

(cid:124)

,

1 + 1

2 γ(1 − Θ)(t + 1 − t0)

If α is deﬁned as (35), we apply the results of Lemma 9 and Lemma 10 to obtain
α(t)(cid:17)

E[G(α)] = E

(cid:32) T −1
(cid:88)

(cid:34) T −1
(cid:88)

≤ 1

α(t)

(cid:33)(cid:35)

G

G

E

(cid:16)

(cid:34)

(cid:35)

T −T0

1
T −T0

t=T0

≤

1
γ(1 − Θ)s

1
T − T0

(cid:104)
D(α(T0)) − D(α(cid:63))

E

+ 4L2σσ(cid:48)s
2τ

.

t=T0
(cid:105)

If T ≥ (cid:100)

γ(1−Θ) (cid:101) + T0 such that T0 ≥ t0 we have

1

E[G(α)]

(41),(39)
≤

1
γ(1 − Θ)s
(cid:18)

1
T − T0
1
γ(1 − Θ)s

4L2σσ(cid:48)
τ

=

(cid:18)

4L2σσ(cid:48)

τ (1 + 1
1
T − T0

1 + 1

2 γ(1 − Θ)(T0 − t0))
1

2 γ(1 − Θ)(T0 − t0)

+

(cid:19)

.

s
2

(cid:19)

+

4L2σσ(cid:48)s
2τ

s =

1
(T − T0)γ(1 − Θ)

∈ [0, 1]

E[G(α)]

(42),(43)
≤

(cid:18)

4L2σσ(cid:48)
τ

1 + 1

2 γ(1 − Θ)(T0 − t0)

+

1
(T − T0)γ(1 − Θ)

1
2

(cid:19)

.

To have right hand side of (44) smaller then (cid:15)G it is sufﬁcient to choose T0 and T such that

(40)

(cid:125)

(41)

(42)

(43)

(44)

(45)

(46)

Choosing

gives us

Hence if

(cid:18)

4L2σσ(cid:48)
τ
4L2σσ(cid:48)
τ

1 + 1
(cid:18)

2 γ(1 − Θ)(T0 − t0)
1
1
2
(T − T0)γ(1 − Θ)

(cid:19)

(cid:19)

≤

≤

1
2

1
2

(cid:15)G ,

(cid:15)G .

t0 +

2
γ(1 − Θ)

(cid:19)

− 1

(cid:18) 8L2σσ(cid:48)
τ (cid:15)G
4L2σσ(cid:48)
τ (cid:15)Gγ(1 − Θ)

T0 +

≤ T0 , and

≤ T ,

then (45) and (46) are satisﬁed.

The following main theorem simpliﬁes the results of Theorem 11 and is a generalization of [17,
Corollary 9] for general f ∗(·) functions:
Theorem’ 1. Consider Algorithm 1 with γ := 1, using a local solver of quality Θ (see Assumption
1). Let g∗
i (·) be L-Lipschitz continuous, and assume that the columns of A satisfy (cid:107)xi(cid:107) ≤ 1 ∀i ∈ [n].
Let (cid:15)G > 0 be the desired duality gap (and hence an upper-bound on primal sub-optimality). Then

1

1

19

after T iterations, where

T ≥ T0 + max{

T0 ≥ t0 +

(cid:104)

2
1 − Θ
(cid:108) 1

(cid:108)

(cid:109)
,

1
1 − Θ
(cid:18) 8L2n2
τ (cid:15)G

4L2n2
τ (cid:15)G(1 − Θ)
(cid:19) (cid:105)
+

− 1

,

} ,

t0 ≥ max(0,

(1−Θ) log

(cid:16) τ (D(α(0))−D(α(cid:63)))
2L2Kn

(cid:17) (cid:109)

) ,

(47)

we have that the expected duality gap satisﬁes

(where α is the averaged iterate returned by Algorithm 1).

E[P(w(α)) − (−D(α))] ≤ (cid:15)G

Proof. Plug in parameters γ := 1, σ(cid:48) := γK = K to the results of Theorem 11, and note that for
balanced datasets we have σ ≤ n2
K (see Remark 2). We can further simplify the rate by noting that
τ = 1 for the 1-smooth losses (least squares and logistic) given as examples in this work.

Remark 3. For pure L1-regularized problems as discussed in Section C.1, we have that the above
theorem directly delivers a primal-dual convergence with a sublinear rate. This is because in view
of Lemma 7, we know that g∗
i is B-Lipschitz for the bounded support modiﬁcation introduced in
Section 4.

E.3 Proof of Convergence Result for Strongly Convex gi

Our second main theorem follows reasoning in [26] and is a generalization of [17, Corollary 11]. We
ﬁrst introduce a lemma to simplify the proof.
Lemma 12. Assume that gi(0) ∈ [0, 1] for all i ∈ [n], then for the zero vector α(0) := 0 ∈ Rn, we
have

D(α(0)) − D(α(cid:63)) = D(0) − D(α(cid:63)) ≤ n .

(48)

Proof. For α := 0 ∈ Rn, we have w(α) = Aα = 0 ∈ Rd. Therefore, since the dual −D(·) is
always a lower bound on the primal P(·), and by deﬁnition of the objective D given in (A),

0 ≤ D(α) − D(α(cid:63)) ≤ P(w(α)) − (−D(α))

(A)
≤ n .

Theorem 13. Assume that gi are µ-strongly convex ∀i ∈ [n]. We deﬁne σmax = maxk∈[K] σk. Then
after T iterations of Algorithm 1, with

T ≥

1
γ(1−Θ)

µτ +σmaxσ(cid:48)
µτ

log n
(cid:15)D

,

E[D(α(T )) − D(α(cid:63))] ≤ (cid:15)D .

it holds that

Furthermore, after T iterations with

we have the expected duality gap

T ≥

1
γ(1−Θ)

µτ +σmaxσ(cid:48)
µτ

log

1
γ(1−Θ)

µτ +σmaxσ(cid:48)
µτ

n
(cid:15)G

(cid:16)

(cid:17)

,

E[P(w(α(T ))) − (−D(α(T )))] ≤ (cid:15)G .

Proof. Given that gi(.) is µ-strongly convex with respect to the (cid:107) · (cid:107) norm, we can apply (25) and the
deﬁnition of σk to ﬁnd:

R(t) ≤ − τ µ(1−s)
(cid:16)

σ(cid:48)s
− τ µ(1−s)

≤

(cid:107)u(t) − α(t)(cid:107)2 +

(cid:88)K

k=1

σk(cid:107)u(t) − α(t)

[k](cid:107)2

σ(cid:48)s + σmax

(cid:107)u(t) − α(t)(cid:107)2 ,

(cid:17)

where σmax = maxk∈[K] σk. If we plug the following value of s
τ µ + σmaxσ(cid:48) ∈ [0, 1]

s =

τ µ

(49)

(50)

20

(24),(50)

≥ γ(1 − Θ)

E[D(α(t)) − D(α(t+1))]

into (49) we obtain that ∀t : R(t) ≤ 0. Putting the same s into (24) will give us
τ µ + σmaxσ(cid:48) G(α(t)) ≥ γ(1 − Θ)

τ µ + σmaxσ(cid:48) (D(α(t)) − D(α(cid:63))) .
(51)
Using the fact that E[D(α(t)) − D(α(t+1))] = E[D(α(cid:63)) − D(α(t+1))] + D(α(t)) − D(α(cid:63)) we have
(51)
τ µ + σmaxσ(cid:48) (D(α(t)) − D(α(cid:63))) ,
≥ γ(1 − Θ)

E[D(α(cid:63)) − D(α(t+1))] + D(α(t)) − D(α(cid:63))

τ µ

τ µ

τ µ

which is equivalent to

E[D(α(t+1)) − D(α(cid:63))] ≤

1 − γ(1 − Θ)

(D(α(t)) − D(α(cid:63))) .

(52)

(cid:18)

(cid:19)

τ µ
τ µ + σmaxσ(cid:48)

Therefore if we denote (cid:15)(t)

(cid:18)

E[(cid:15)(t)
D ]

(52)
≤

1 − γ(1 − Θ)

D = D(α(t)) − D(α(cid:63)) we have recursively that
(cid:19)t

(cid:18)

1 − γ(1 − Θ)

τ µ
τ µ + σmaxσ(cid:48)

(cid:19)t

n

(cid:18)

≤ exp

−tγ(1 − Θ)

τ µ
τ µ + σmaxσ(cid:48)

(cid:15)(0)
D

(48)
≤

τ µ
τ µ + σmaxσ(cid:48)

(cid:19)

n .

The right hand side will be smaller than some (cid:15)D if

1
γ(1 − Θ)
Moreover, to bound the duality gap, we have
τ µ

t ≥

γ(1 − Θ)

τ µ + σmaxσ(cid:48)
τ µ

log

n
(cid:15)D

.

τ µ + σmaxσ(cid:48) G(α(t))
(cid:15)(t)
D . Hence if (cid:15)D ≤ γ(1 − Θ)

τ µ+σmaxσ(cid:48)
τ µ

1
γ(1−Θ)

(51)
≤ E[D(α(t)) − D(α(t+1))] ≤ E[D(α(t)) − D(α(cid:63))] .

τ µ

τ µ+σmaxσ(cid:48) (cid:15)G then G(α(t)) ≤ (cid:15)G.

Thus, G(α(t)) ≤
Therefore after

1
γ(1 − Θ)
iterations we have obtained a duality gap less than (cid:15)G.

τ µ + σmaxσ(cid:48)
τ µ

t ≥

log

(cid:18)

1
γ(1 − Θ)

τ µ + σmaxσ(cid:48)
τ µ

n
(cid:15)G

(cid:19)

Theorem’ 2. Consider Algorithm 1 with γ := 1, using a local solver of quality Θ (See Assumption
1). Let gi(·) be µ-strongly convex ∀i ∈ [n], and assume that the columns of A satisfy (cid:107)xi(cid:107) ≤ 1
∀i ∈ [n]. Then we have that T iterations are sufﬁcient for suboptimality (cid:15)D, with

Furthermore, after T iterations with

we have the expected duality gap

T ≥

1
γ(1−Θ)

τ µ+n

τ µ log n
(cid:15)D

.

T ≥

1
γ(1−Θ)

τ µ+n
τ µ log

1
γ(1−Θ)

τ µ+n
τ µ

n
(cid:15)G

(cid:16)

(cid:17)

,

E[P(w(α(T ))) − D(α(T ))] ≤ (cid:15)G .

Proof. Plug in parameters γ := 1, σ(cid:48) := γK = K to the results of Theorem 13 and note that for
balanced datasets we have σmax ≤ n
K (see Remark 2). We can further simplify the rate by noting
that τ = 1 for the 1-smooth losses (least squares and logistic) given as examples in this work.

Remark 4. For elastic net regularized problems as discussed in Section C.2, we have that the above
theorem directly delivers a primal-dual convergence with a geometric rate. This is because in view of
Lemma 6, we know that g∗

i is 1/η-smooth for any elastic net parameter η ∈ (0, 1].

F Recovering COCOA+ as a Special Case

As a special case, PROXCOCOA+ directly applies to any L2-regularized loss-minimization problem,
including those presented in [12, 17]. In this setting, the original machine-learning problem is mapped
to what we here refer to as the “dual” problem formulation (B):

(cid:104)

P(w) := f ∗(w) +

i (−xT
g∗

i w)

(cid:105)

,

min
w∈Rd

n
(cid:88)

i=1

21

2 (cid:107) · (cid:107)2 being the regularizer, and g∗

with f ∗(·) = λ
i taking the role of loss function, acting on a linear
i w (recall that xi is a column of the data matrix A). In other words, the PROXCOCOA+
predictor xT
algorithm will in this case apply to (A) as the dual of the original input problem (which will be
mapped to (B)), as described in [12, 17]. The following remarks show that we recover the linear
(geometric) convergence rates for smooth loss functions g∗
i , and sublinear convergence for Lipschitz
losses. Note that this contrasts the discussed applications of PROXCOCOA+ where the g function has
the role of the regularizer instead.

Remark 5. If we view (B) as the primal , restrict f ∗(·) := λ
Theorem 1 recovers as a special case the COCOA+ rates for general L-Lipschitz (cid:96)∗
Corollary 9]).

2 (cid:107) · (cid:107)2 (so that τ = λ), and let g∗

n (cid:96)∗
i ,
i losses (see [17,

i := 1

This follows since g∗
Remark 6. If we view (B) as the primal , restrict f ∗(·) := λ
i := 1
g∗
n (cid:96)∗
[17, Corollary 11]).

i is L-Lipschitz if and only if gi has L-bounded support [24, Corollary 13.3.3].
2 (cid:107) · (cid:107)2 (so that τ = λ), and scale
i )-smooth losses (see

i , Theorem 2 recovers as a special case the COCOA+ rates for (1/(cid:96)∗

i is µ-strongly convex if and only if gi is (1/µ)-smooth [14, Theorem 6].

This follows since g∗
Remark 7. Note that the approach of mapping the original objective to (B) does not allow general
regularizers such as L1. This is one of the reasons we have proposed swapping the roles of regularizers
and losses, and running PROXCOCOA+ on the primal of the original problem instead.

G Experiment Details

In this section we provide greater details on the experimental setup and implementations from
Section 6. All experiments are run on Amazon EC2 clusters of m3.xlarge machines, with one core
per machine. The code for each method is written in Apache Spark, v1.5.0. Our code is open-source
and publicly available at: github.com/gingsmith/proxcocoa.

ADMM Alternating Direction Method of Multipliers (ADMM) [5] is a popular method that lends
itself naturally to the distributed environment. Implementing ADMM for the problems of interest
requires solving a large linear system Cx = d on each machine, where C ∈ Rn×n with n scaling
beyond 107 for the datasets in Table 1, and with C being possibly dense. It is prohibitively slow
to solve this directly on each machine, and we therefore employ the iterative method of conjugate
gradient with early stopping (see, e.g., [5, Section 4.3]). We further improve performance by using a
varying rather than constant penalty parameter, as suggested in [5, Section 3.4.1].

Mini-batch SGD and Proximal GD Mini-batch SGD is a standard and widely used method for
parallel and distributed optimization. We use the optimized code provided in Spark’s machine
learning library, MLlib, v1.5.0. We tune both the size of the mini-batch and the SGD step size using
grid search. Proximal gradient descent can be seen as a speciﬁc setting of mini-batch SGD, where the
mini-batch size is equal to the total number of datapoints. We thus also use the implementation in
MLlib for prox-GD, and tune the step size parameter using grid search.

Mini-batch CD Mini-batch CD aims to improve mini-batch SGD by employing coordinate descent,
which has encouraging theoretical and practical backings [25, 9, 28]. We implement mini-batch CD
in Spark and scale the updates made at each round by β
b for mini-batch size b and β ∈ [1, b], tuning
both parameters b and β via grid search.

Shotgun As a special case of mini-batch CD, Shotgun [7] is a popular method for parallel optimiza-
tion. Shotgun can be seen an extreme case of mini-batch CD where the mini-batch is set to 1 element
per machine, i.e., there is a single update made by each machine per round. We see in the experiments
that communicating this frequently becomes prohibitively slow in the distributed environment.

OWL-QN OWN-QN [32] is a quasi-Newton method optimized in Spark’s spark.ml package. Outer
iterations of OWL-QN make signiﬁcant progress towards convergence, but the iterations themselves
can be slow because they require processing the entire dataset. PROXCOCOA+, the mini-batch
methods, and ADMM with early stopping all improve on this by allowing the ﬂexibility of only a
subset of the dataset to be processed at each iteration. PROXCOCOA+ and ADMM have even greater

22

ﬂexibility by allowing internal methods to process the dataset more than once. PROXCOCOA+ makes
this approximation quality speciﬁc, both in theoretical convergence rates and by providing general
guidelines for setting the parameter.
PROXCOCOA+ We implement PROXCOCOA+ with coordinate descent as a local solver. We note
that since the framework and theory allow any internal solver to be used, PROXCOCOA+ could beneﬁt
even beyond the results shown, by using existing fast L1-solvers for the single-machine case, such as
GLMNET variants [11] or BLITZ [13]. The only parameter necessary to tune for PROXCOCOA+ is the
level of approximation quality, which we parameterize in the experiments using H, the number of
local iterations of the iterative method run locally. Our theory relates local approximation quality to
global convergence, and we provide a guideline for how to choose this value in practice that links the
value to the systems environment at hand (Remark 1). We implement COCOA+ as a special case of
PROXCOCOA+ for elastic net regularized objectives by mapping the main objective to (B) according
to the steps described in Section F, and again use coordinate descent as a local solver.

23

