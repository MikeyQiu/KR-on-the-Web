A Graph Regularized Deep Neural Network for Unsupervised Image
Representation Learning

Shijie Yang1,2, Liang Li2∗, Shuhui Wang2, Weigang Zhang1,3 ,Qingming Huang1,2∗
1University of Chinese Academy of Sciences, Beijing, 100049, China
2Key Laboratory of Intelligent Information Processing of Chinese Academy of Sciences (CAS),
Institute of Computing Technology, CAS, Beijing, 100190, China
3School of Computer Science and Technology, Harbin Institute of Technology, Weihai, 264209, China
shijie.yang@vipl.ict.ac.cn, (cid:2)liang.li@vipl.ict.ac.cn, wangshuhui@ict.ac.cn
wgzhang@hit.edu.cn, qmhuang@ucas.ac.cn

Abstract

Deep Auto-Encoder (DAE) has shown its promising pow-
er in high-level representation learning. From the per-
spective of manifold learning, we propose a graph reg-
ularized deep neural network (GR-DNN) to endue tradi-
tional DAEs with the ability of retaining local geometric
structure. A deep-structured regularizer is formulated upon
multi-layer perceptions to capture this structure. The robust
and discriminative embedding space is learned to simulta-
neously preserve the high-level semantics and the geomet-
ric structure within local manifold tangent space. Theo-
retical analysis presents the close relationship between the
proposed graph regularizer and the graph Laplacian regu-
larizer in terms of the optimization objective. We also al-
leviate the growth of the network complexity by introduc-
ing the anchor-based bipartite graph, which guarantees the
good scalability for large scale data. The experiments on
four datasets show the comparable results of the proposed
GR-DNN with the state-of-the-art methods.

1. Introduction

Unsupervised representation learning via Deep Auto-
Encoder (DAE) has shown its promising power in comput-
er vision. Basically, an under-complete encoder compress-
es the input data into low-dimensional codes, and a similar
inverted decoder reconstructs the input from the codes. E-
quipped with multiple layers of non-linear transformations,
DAEs can simulate the perception of human brain to ex-
tract high-level semantic abstractions from low-level input
signals [19, 24, 9].

To capture the high-level semantics and avoid learning
the trivial suboptimal function, regularized DAEs make a
tradeoff-decision between attaining some speciﬁc proper-

class 1 

class k 

class 1 

class 2 

(a) 

class 2 

class k 

(b) 

(c) 

Figure 1: Toy examples of the learned embedding subspace: (a)
traditional DAEs, (b) local invariance learners, (c) our GR-DNN.
Different shapes denote the labels, and different colors denote the
neighbor relations.

ties and preserving the input information X. A regulariza-
tion term Φ is added to the reconstruction cost as follows.

Cost = Δ(X, ˜X) + γΦ.

(1)

The regularizations include the sparsity of the code [6], the
robustness to noise inputs [24] and the insensitivity of the
input signals [19]. These strategies penalize the sensitivity
of the code to small perturbations of the input signals, which
makes crucial contribution to the success of DAEs.

Meanwhile, a stream of successful manifold learning
methods beneﬁt from the local invariance theory, such as the
Locally Linear Embedding (LLE) [20], Laplacian Eigen-
map [1], and Locality Preserving Projections (LPP) [18].
They emphasize that the geometric relation among neigh-
boring points on the original manifold should be maintained
in the learned embedding space, which has been widely
used in unsupervised dimensional reduction [4] and semi-
supervised learning [27].

Comparing the above DAEs (Fig. 1a) with the manifold
learning models (Fig. 1b), the former follow a global recon-
struction criterion and extract the high-level salient factors

1203

Decoder 
 

Single layer 

Data-DAE 
 

Graph-DAE 

Code 

(cid:1876)(cid:3556)

Graph Laplacian 
regularizer 

Code 

Stacked deep structure 
(cid:1876)

Code 

… 

(cid:1876)(cid:3556)
… 

… 

 

Encoder 

(cid:1876)
(cid:1876)
(a) DAE

 

 

… 

 

(cid:1876)

(cid:1876)(cid:3556)
… 

… 

 

… 

… 

 graph 

 

(cid:1876)(cid:3556)
… 

Code 

… 

… 

 

(b) Laplacian auto-encoder (LAE)

(c) Pre-training of GR-DNN

(cid:142)(cid:145)(cid:133)(cid:131)(cid:142)

(cid:1876)

(d) Joint ﬁne-tuning of GR-DNN
(cid:1876)

Figure 2: Illustrations of the network structures. Dashed arrows represent the construction of local similarity graph, while solid arrows
denote deterministic connections.

which can best approximate the whole data space, while the
latter emphasize on preserving the local geometric structure
and infer the subspace according to the afﬁnity propaga-
tions across the local manifold tangents. In fact, the two
learning strategies complement each other. DAEs are de-
voted to extracting the inter-class structure, while the local
invariance learners focus more on modeling the intra-class
correlations. If the two learners were combined as illustrat-
ed in Fig. 1c, more discriminative representation could be
theoretically obtained, with both the global and local struc-
ture well preserved.

In recent literatures, the most widely used regularizer for
local invariance is the graph Laplacian [4, 14, 28], which
can be transformed to generalized eigenvalue problems. As
a representative work, Cai et al. [4] propose the Graph regu-
larized Nonnegative Matrix Factorization (G-NMF), which
incorporates graph Laplacian regularizer into a matrix fac-
torization objective. However, despite the popularity a-
mong shallow models, the graph Laplacian shows its lim-
itation when integrating with deep models [10]. Due to
the shallow-structure nature, it has to be treated as a basic
building block for the pre-training of each layer as shown in
Fig. 2b. This indicates that a completely new graph Lapla-
cian should be constructed based on the last hidden-layer’s
outputs, which is not scalable for deeper hierarchical archi-
tecture. As a result, it remains an open question to design a
local invariance regularizer for practical use in deep models.
This paper proposes a graph regularized deep neural
network (GR-DNN) for unsupervised image representation
learning, where both the high-level semantics and local ge-
ometric structure of the data manifold are simultaneously
learned. In details, a deep-structured regularizer is formu-
lated upon multi-layer perception (MLP) to leverage the
DAEs with the local invariant theory to explicitly recon-
struct the geometric similarity graph. As illustrated in
Fig. 2d, GR-DNN is a dual-pathway network composed of

one encoder and two decoders. The encoder transforms
the input data into low-dimensional codes, and one data-
decoder reconstructs the original input. Moreover, an ad-
ditional graph-decoder is introduced as the local invariance
regularizer to reconstruct a pre-constructed local similari-
ty graph. The two decoders share a bottleneck code lay-
er, and the loss function of GR-DNN is the weighted sum
of reconstruction errors from both the decoders. Further,
we alleviate the complexity-growth of the network struc-
ture by introducing the anchor-based bipartite graph, while
the complexity of traditionally reconstructing the similarity
graph grows dramatically w.r.t.
the data volume. The ex-
periments on four public datasets show the promising per-
formance of our proposed model, and demonstrate that the
proposed graph regularizer could be an effective module to
enhance traditional DAEs. To summarize, our main contri-
butions are as follows:

• A graph regularized deep neural network is proposed
to effectively leverage DAEs with the local invariant
theory for unsupervised image representation learning,
where both the high-level semantics and local geomet-
ric structure of the embedding subspace are simultane-
ously learned.

• A deep-structured graph regularizer is introduced with
solid theoretical analysis. Compared with traditional
graph Laplacian regularizer, it achieves both the lower
computational complexity and superior learning per-
formance.

2. Background

Representation learning attempts to transform the orig-
inal input to new feature representation which is more ro-
bust and compact to explain the data structure. Given a ma-
trix containing n data points X = [x1, ..., xn]⊤ ∈ Rn×m,

1204

where m is the dimension of the input space, our task is to
ﬁnd H = [h1, ..., hn]⊤ ∈ Rn×k with lower dimension k,
i.e., k < m.

2.1. Deep Auto-Encoders

DAE attempts to extract high-level semantic abstractions
using architectures composed of multiple layer perceptions
(MLP). Typically, deeper layers are expected to represent
more abstract features, i.e., better capturing the high-level
data distribution. As shown in Fig. 2a, the network contains
two symmetrical sub-networks. The encoder transforms the
input data X into low-dimensional code matrix H, and a
decoder network reconstructs the data from the code.

To learn more robust features and avoid the non-smooth
suboptimal input-feature mappings, regularized DAEs at-
tain some nice properties by introducing a regularization
term Φ to the reconstruction cost shown in Eq. (1). Speciﬁ-
cally, the denoising DAE (D-DAE) [24] is trained to discov-
er salient features which can recover the original data from
partially corrupted signals. A penalty term is added in Con-
tractive DAE (C-DAE) [19] which minimizes the Frobenius
norm of the Jacobian matrix of the code with respect to the
input. The learned representation better captures the local
manifold directions dictated by the data. To sum up, these
techniques obtain the robustness by encouraging the insen-
sitivity of the code to small perturbations of the input sig-
nals. In contrast, our work aims to enhance the DAEs by
explicitly enforcing the internal geometric structure, which
is performed based on the similarity metrics.

2.2. Local Invariance Regularizer

The local invariance theory [1, 8, 18] requires that the
points on the manifold with short geodesic distances should
be mapped close. Most of the existing methods adopt the
graph Laplacian regularizer [4, 10, 15], which is deﬁned
based on an undirected weighted graph G = (V, E), where
V = {x1, x2, ..., xn} is the node set and E = {eij} is the
edge set. The graph structure is encoded into a similarity
matrix denoted by S ∈ Rn×n where [S]ij ≥ 0 denotes the
similarity of xi and xj. In practice, the K-Nearest Neighbor
(K-NN) graph is constructed, where the similarity is deﬁned
using Gaussian kernels with the bandwidth parameter σ:

[S]ij=

exp
0

(cid:3)

(cid:2)

−(cid:3)xi−xj (cid:3)
σ

, if xi and xj are connected
, otherwise

(cid:4)

(2)
Speciﬁcally, we connect xi and xj if one of them is among
the K-Nearest Neighbors of the other according to a giv-
en distance measurement, i.e., usually Euclidean distance
[13]. With the above deﬁned similarity matrix S, the local
geometrical structure of the learned representation H can

be preserved by minimizing the following term:

n

Ω(H) = 1
2

(cid:4)hi − hj(cid:4)2[S]ij

i,j=1
(cid:5)
hi[D]ii −

h⊤
i

=

n

i=1
(cid:5)

h⊤
i

hj[S]ij

n

i,j=1
(cid:5)

= T r(H⊤DH) − T r(H⊤SH) = T r(H⊤LH),

(3)

where T r(.) denotes the trace of a matrix and D is a diag-
j [S]ij. Moreover,
onal matrix whose entries are [D]ii =
L = D − S, which is called graph Laplacian. By minimiz-
ing the term Ω(H), we expect that if two data points xi and
xj are close (i.e., [S]ij is large), hi and hj are mapped close
to each other in the new space.

(cid:5)

As a representative work, Cai et al. [4] proposes the
Graph regularized Nonnegative Matrix Factorization (G-
NMF), which incorporates graph Laplacian regularizer into
a matrix reconstruction objective as shown in Eq. (4).

Cost = ∆(X, ˜X) + γΩ(H).

(4)

It has been shown that the learning performance can be sig-
niﬁcantly enhanced if the geometric structure is exploited.
As the most related work (shown in Fig. 2b), Laplacian
regularized auto-encoder (LAE) [10, 15] formalizes the ter-
m ∆(X, ˜X) of Eq. (4) using DAEs. However, the shallow-
structured regularizer Ω(H) suffers from the following lim-
itation. When integrating with deep models, the shallow-
structured regularizer has to be treated as a basic building
block for pre-training each layer. As shown in Fig. 2b,
a completely new graph Laplacian should be constructed
based on the last hidden-layer’s outputs. Note that both con-
structing and solving the graph Laplacian need a quadratic
computational complexity w.r.t. the data volume, traditional
graph Laplacian regularizer is not scalable for deeper archi-
tectures.

3. Methodology

To endue traditional DAEs with the extra ability to p-
reserve the local geometric structure, we propose a graph
regularized deep neural network (GR-DNN). In details, we
formulate a deep-structured regularizer on the multi-layer
perception to explicitly capture the local geometric struc-
ture.

GR-DNN is composed of one encoder and two decoder-
s as shown in Fig. 2d. The encoder transforms a input data
item into a low-dimensional code, and the ﬁrst data-decoder
reconstructs the original input. Inspired by the graph auto-
encoders [23], we introduce a graph-decoder which explic-
itly enforces the internal geometric structure by reconstruct-
ing the similarity matrix S. The two decoders are connected
by a middle-bottleneck code layer. As shown in Eq. (5), the
loss function is the weighted sum of reconstruction errors of
the dual pathways. The learned codes simultaneously cap-
ture the high-level global abstractions, and attains the latent

1205

geometric structure within local manifold tangents.
+ ηΔ( S , ˜S )
(cid:5)

Δ(X, ˜X) + γΦ
(cid:5)
(cid:3)(cid:4)
(cid:2)
traditional (regularized) DAE

Cost =

(cid:3)(cid:4)
graph regularizer

(cid:2)

(5)

To learn the geometrical-aware representation, good ini-
tial codes are ﬁrst generated based on the global reconstruc-
tive objective. Then, the codes are further reﬁned accord-
ing to the afﬁnity propagation within local manifold region-
s. From the perspective of manifold learning, the graph-
decoder exerts a force to repel or attract the mapped points
depending on whether they are geometrically close. From
the perspective of multi-modal learning [17, 21, 25], the o-
riginal image data and the local geometric graph are taken
as two views or modalities to complement each other. Ac-
cordingly, compared with traditional DAEs in Fig. 2a, more
compact and discriminative representation could be learned
by the proposed structure.

Comparing GR-DNN with regularized denoising DAE
and contractive DAE, all of them could capture the local
manifold structure of the input data space. Differently, the
denoising DAE and contractive DAE achieve this by enforc-
ing the robustness and insensitiveness of the learned code
w.r.t. small perturbations of the input signals. Our GR-
DNN directly encodes the latent manifold structure by per-
forming afﬁnity propagation on the similarity graph, which
captures the geometric information more accurately.

Moreover, comparing with the siamese-network [5],
both of them could achieve weighted metric learning. How-
ever, the siamese-network is usually adopted in supervised
learning, which requires strong supervised information on
whether pairs of input samples are close or not. In contrast,
our deep graph regularizer softly encodes the local geomet-
ric structure of the original data space, and usually cooper-
ates with reconstructive criterion for unsupervised learning.

Corollary 2. H ∈ Rn×k contains the k eigenvectors which
provide the best rank-k reconstruction of S under the Frobe-
nuis norm.

Thus, we get the following conclusion for the graph
Laplacian regularizer, where g2 denotes the quadric func-
tion of H:

min
H⊤DH=I

T r(H⊤LH) → min

rank(H)=k

(cid:6)
(cid:6)

S − HH⊤(cid:6)
(cid:6)

2
F

(7)

→

min
rank(H)=k,g2

(cid:3)S − g2(H)(cid:3)2
F

On the other hand, for a DAE which reconstructs S by
minimizing the Frobenuis norm, we get Eq. (8), where f
and g are multiple layers of nonlinear encoder and decoder
respectively:

(cid:4)S − g(f (S))(cid:4)2

min
f,g

F → min

H=f (S),g

(cid:4)S − g(H)(cid:4)2
F

(8)

As we can see, both of the proposed graph-decoder and
the graph Laplacian regularizer aim to ﬁnd the best recon-
struction of the input graph similarity matrix. With the more
ﬂexible non-linear decoder g rather than the quadric g2, the
graph-decoder can be regarded as a more generalized ver-
sion of the graph Laplacian regularizer, and can uncover the
intrinsic graph structure with theoretical guarantees.

Compared with the graph Laplacian regularizer [10], the
proposed graph regularizer has the following advantages.
First, the MLP-based graph-decoder is more ﬂexible for pa-
rameterizing complex non-linear functions, and provides a
more smooth way of enforcing the local geometric structure.
Second, the similarity matrix S ∈ Rn×n can be regarded as
n regular n-dimensional input samples to perform the stan-
dard layer-wise pre-training. The local afﬁnity graph only
needs to be constructed once, which is more applicable in
deep models with arbitrary number of layers.

3.0.1 Relationship with graph Laplacian regularizer

3.1. Implementation Details

We ﬁrst analyze the close relationship in terms of the opti-
mization objective. Then, we discuss the superior property
of the proposed model.

Theorem 1 ([1]). The solution of ﬁnding

arg min

H⊤DH=I

T r(H⊤LH)

(6)

is provided by the matrix of eigenvectors corresponding to
the lowest eigenvalues of the generalized eigenvalue prob-
lem Lh = λDh.

In the above theorem, the constraint H⊤DH = I re-
moves an arbitrary scaling factor in the embedding space,
which can be omitted when used as regularization. Since
L = D − S and based on the Eckart-Young-Mirsky theo-
rem [7], we obtain the same corollary as in [23].

3.1.1 Anchor graph (AG) for large-scale data

As conventional graph-based methods, the similarity graph
is not directly applicable for large-scale data. In GR-DNN,
the K-NN similarity matrix S ∈ Rn×n is regarded as n
[s1, ..., sn]⊤, where each sample si ∈ Rn
data samples:
is an n-dimensional input data vector. This indicates that
the size of the input and output layer of a DAE grows lin-
early w.r.t. the data volume n. Considering this, we adopt
the efﬁcient approximation method in [13] and construct the
anchor-based graph (AG) instead. The key idea is to use a
small set of representative anchor points {a1, a2, ..., aNa }
(ai ∈ Rm) to approximate the graph structure. First,
the anchor points can be sampled through many strategies,
e.g., randomly selected or chosen to be the k-means clus-
ter centroids. We adopt the latter because of its effective-
ness and convenience. Then, the approximated K-NN graph

1206

ˆS ∈ Rn×Na is constructed between the original data points
{x1, x2, ..., xn} and the anchor points {a1, a2, ..., aNa } ac-
cording to Eq. (2). As a result, the size of the input and
output layer of a DAE can be ﬁxed to Na, and the construc-
tion of the graph becomes extremely efﬁcient since now we
only need to consider O(nNa) distances.

Table 1: Summary of the datasets

Dataset

Size: train,test

Dimension # of classes

COIL20
YaleB
MNIST
MNIST2

1440 : 1000, 440
5850 : 5000, 850
70k : 60k, 10k
120k : 100k, 20k

1024
1200
784
784

20
10
10
10

3.1.2 Training

4. Experiments

As the most popular strategy for training deep network, the
layer-wise pre-training [2] has been proven to be helpful in
achieving local optimal solutions.

d, ˆsi

d is the i-th data and ˆsi

The training of our model is composed of three parts,
i.e., (1) The layer-wise pre-training, (2) The path-wise ﬁne-
tuning (Fig. 2c) and (3) The joint ﬁne-tuning (Fig. 2d). For
g}Na
the dual-pathway, we deﬁne a set of input pairs {xi
i=1,
where xi
g is the corresponding row
vector of pre-constructed anchor graph ˆS. First, as shown
in Fig. 2c, we layer-wisely pre-train a regular data-DAE
and a graph-DAE as in [2]. Then, we unroll and ﬁne-tune
them separately.
In the end, as shown in Fig. 2d, a joint
ﬁne-tuning procedure is performed according to Eq. (5) to
get the optimal solution. We only choose the encoder of
data-DAE as the ﬁnal encoder of GR-DNN. Compared with
multi-modal networks [17, 21], it effectively extends our
network to handle out-of-sample data, i.e., no graph needs
to be constructed when encoding the test data.

3.2. Complexity Analysis

Training the GR-DNN consists of three stages, i.e., (1)
generating the anchor points using k-means, (2) construct-
ing a AG graph ˆS and (3) training the network. The ﬁrst
stage takes O(t1nNam) time, where t1 is the iterations
for running k-means, m is the original feature dimension,
and n is the total data volume and Na is the number of
anchor-points. The second stage takes O(nNam) to con-
struct the graph matrix.For the training stage, we suppose
there are t2 epochs. The computational cost of updating the
parameters for the l-th layer in each encoder and decoder
is O(nt2(sl
)), where p ∈ {d, g} represents the data-
pathway and graph-pathway respectively, and sl
p is the size
of the l-th layer. Then the overall complexity is

psl+1
p

O(t1nNam) + O(nNam) + O(nt2 (cid:7)

sl
psl+1
p

p∈{d,g}
))

sl
psl+1
p

)

(cid:7)
l

,

≈ O(n(t1Nam + t2 (cid:7)

(cid:7)
l

p∈{d,g}

whose complexity is nearly O(n), since Na, m ≪ n. Notic-
ing that the pre-training and path-wise ﬁne-tuning of the two
pathways can be parallelized, the additional computational
cost of GR-DNN over traditional DAEs mainly lies in the
ﬁrst two stages. Comparing with GR-DNN, the additional
computational cost of LAE is O((L − 1)n2), where L is the
depth of the network.

To verify the performance of the proposed GR-DNN,
we respectively conduct k-means clustering and nearest-
neighbor search experiments based on the learned repre-
sentation. For the clustering task, two standard evaluation
metrics, i.e., Accuracy (ACC) [3] and Normalized Mutual
Information(NMI), are reported. For the nearest-neighbor
search task, given a query sample, we retrieve the top k
nearest neighbors according to Euclidean distance. The
retrieval performance is evaluated using the mean average
precision (mAP), e.g., mAP@10 measures the mAP for the
top 10 retrieved samples. In all the evaluations, the num-
ber of clusters is set to be the true number of classes of the
dataset. For each method, all the experiments are repeated
for 20 times and the best mean results are reported. Our im-
plementation is publicly available 1 based on Theano [22].

4.1. Dataset and Parameter Setting

(1)
As in Table 1, four benchmark datasets are used.
The COIL20 image library [16] contains 32 × 32 gray im-
ages viewed from varying angles.
(2) The YaleB dataset
contains face images over 10 categories. (3) The MNIST
handwritten digits dataset [11] contains 28 × 28 gray scale
images. (4) MNIST2: Following [26], we add 50000 noisy
MNIST digits which are rotated at angles uniformly sam-
pled from between [− π
4 ] of the original MNIST. We take
the normalized pixel intensities (in the interval of [0, 1]) as
the input image for all the datasets. Speciﬁcally, the val-
idation sets are used for watching the early stopping, and
we evaluate all the performances on test set. For all the
auto-encoders, we adopt the more widely-used binary cross-
entropy instead of the Frobenuis norm for reconstruction.

4 , π

4.1.1 Comparison Methods

(1) KMEANS: K-means clustering on raw inputs. (2) N-
MF: Nonnegative matrix factorization [12].
(3) GNM-
F: Graph-regularized nonnegative matrix factorization [4].
(4) DAE: standard DAE without any regularizer.
(5) D-
DAE: Denoising-DAE [24]. (6) C-DAE: Contractive-DAE
[19].
(8) GR-
DNN(DAE): The proposed model built upon a standard
DAE. (9) GR-DNN(D-DAE): The proposed model built up-
on a D-DAE (Eq. (5)). (10) GR-DNN(C-DAE): The pro-
posed model built upon a C-DAE (Eq. (5)).

(7) LAE: Laplacian auto-encoders [10].

1https://github.com/ysjakking/GR-DNN

1207

Table 2: Clustering and Nearest-neighbor search results(%): NMI, ACC and mAP

Methods
KMEANS (Raw)
NMF
GNMF
DAE
D-DAE
C-DAE
LAE
GR-DNN(DAE)
GR-DNN(D-DAE)
GR-DNN(C-DAE)

YaleB

COIL20

MNIST

MNIST2

NMI ACC mAP NMI ACC mAP NMI ACC mAP NMI ACC mAP
63.72
70.69
64.24
70.72
68.92
75.43
74.39
85.53
75.71
90.66
75.82
91.32
76.47
91.71
76.89
92.21
77.43
92.55
77.31
92.51

70.56
71.14
75.25
81.21
82.61
81.70
82.29
83.32
83.73
83.52

47.92
48.90
52.85
58.75
59.22
61.12
64.46
65.75
65.86
65.73

73.43
72.68
83.51
83.05
83.78
83.70
84.13
84.95
85.73
84.70

70.46
72.59
75.17
76.54
77.61
77.49
80.18
81.12
82.23
81.18

49.78
50.82
59.27
65.65
68.87
68.69
69.76
70.61
70.94
70.32

53.70
53.76
61.09
62.36
64.10
63.78
65.22
65.76
66.02
65.90

65.47
66.80
67.81
86.34
87.71
86.94
88.21
89.97
89.77
90.56

63.78
64.81
71.33
71.53
72.04
71.58
71.71
71.88
72.02
72.11

66.21
67.97
69.52
74.91
75.82
76.12
77.82
78.98
79.15
79.20

46.74
46.49
53.70
57.36
59.87
58.81
60.63
60.85
60.76
61.94

Table 3: Summary of the network structures for GR-DNN
Dataset

Graph pathway

Data pathway

COIL20 1024−1200−500−250−20 1000−1200−500−100−20
YaleB 1200−1300−500−250−10 5000−5100−1000−100−10
MNIST 784−1000−500−250−10 1000−1200−500−100−10
MNIST2 784−1000−500−250−10 2000−2200−1000−100−10

4.1.2 Parameter Setting

Since GNMF, LAE and C-DAE share the framework of
Eq. (1), the trade-off parameter of the regularization ter-
m is set by searching the grid of {0.01, 0.1, 1, 10, 100}.
The K-NN and AG graphs with the bandwidth parameter
([S]ij/ log 0.5) are built for GNMF, LAE and
σ = mean

i,j

GR-DNN. The value of K is selected to be {20, 20, 30, 30}
respectively for COIL20, YaleB, MNIST and MNIST2 by
experimental search. Speciﬁcally, regular K-NN graphs are
built on COIL20 and YaleB, and we built AG graphs with
1000 and 2000 anchor points on MNIST and MNIST2 as
the input of GR-DNN. GR-DNN(*) share all the hyper-
parameter settings with LAE, D-DAE and C-DAE during
training.
In greedy layer-wise pre-training, each layer is
pre-trained for 50 epochs and the corruption rate is 20%
for denoising networks, For all networks, the SGD batch-
size and the learning rate are set by searching the grid of
{50, 100, 200} and {0.001, 0.005, 0.01, 0.05, 0.1}, respec-
tively.

Due to the large freedom of deep structures, we empiri-
cally design a series of 5-layer structures for all the datasets
shown in Table 3, and avoid dataset-speciﬁc tuning as much
as possible. As the work of [9], we put a bit more neurones
on the ﬁrst hidden layer than inputs, and decrease slowly
until the last hidden layer. All the last hidden layer’s size
is set to be the true number of classes of the datasets, and
all the baseline networks (i.e., D-DAE, C-DAE and LAE)
and the data-pathway network of GR-DNN share the same
structure at all the time. For GR-DNN, the output-size of
the graph-decoder equals to the node-volume of the anchor
graph, and the impact of its size will be further discussed.

1208

1

0.9

0.8

0.6

0.5

P
A
m

0.7

1

0.9

0.8

0.6

0.5

P
A
m

0.7

MNIST

Raw
NMF
GNMF
D−DAE
C−DAE
LAE
GR−DNN(D−DAE)
GR−DNN(C−DAE)

0.4
5

10

50 100 200 1k
Top #

2k

5k

Figure 3: The top # mAP score on MNIST.

MNIST2

Raw
NMF
GNMF
D−DAE
C−DAE
LAE
GR−DNN(D−DAE)
GR−DNN(C−DAE)

0.4
5

10

50 100 200 1k
Top #

2k

5k

Figure 4: The top # mAP score on MNIST2

0.8

0.79

0.78

0.77

0.76

k
1
@
P
A
m

Performance w.r.t. η

mAP@# w.r.t. the code dimension

1

0.95

0.9

0.85

0.8

0.75

#
@
P
A
m

D−DAE(@10)
D−DAE(@100)
D−DAE(@1k)
LAE(@10)
LAE(@100)
LAE(@1k)
GR−DNN(D−DAE)(@10)
GR−DNN(D−DAE)(@100)
GR−DNN(D−DAE)(@1k)

(cid:17)

(cid:16)

(cid:15)
(cid:14)

(cid:13)
(cid:12)

(cid:8)(cid:11)

(cid:8)(cid:10)

(cid:8)(cid:9)

(cid:5)(cid:7)

(cid:5)(cid:6)
(cid:5)

D−DAE
C−DAE
LAE
GR−DNN(D−DAE)
GR−DNN(C−DAE)

0.75

0.01

0.1

0.5

1

10

100

0.7
2

5

10

50

100

200

(cid:4)

(cid:18)(cid:19)(cid:20)(cid:22)(cid:23)(cid:24)(cid:25)(cid:26)(cid:24)(cid:22)(cid:23)(cid:19)(cid:24)
(cid:18)(cid:29)(cid:22)(cid:29)(cid:30)(cid:18)(cid:19)(cid:31)(cid:25)(cid:18)(cid:19)(cid:28)

(cid:3)

(cid:2)

(cid:2)

(cid:5)

(cid:4)
(cid:18)(cid:19)(cid:20)(cid:22)(cid:23)(cid:24)(cid:25)(cid:26)(cid:24)(cid:22)(cid:23)(cid:19)(cid:24)
(cid:27)(cid:28)(cid:29)(cid:20)(cid:23)(cid:30)(cid:18)(cid:19)(cid:31)(cid:25)(cid:18)(cid:19)(cid:28)

(cid:3)

(b)
Figure 5: (a) Parameter analysis on MNIST. (b) The mAP of different methods on MNIST. (c) Clustering results w.r.t. number
of layers.

(c)

(a)

4.2. K-NN Search Results

The K-NN search experiments aim to verify that the
proposed GR-DNN can preserve the local geometric struc-
ture of the data manifolds. We show the mAP score with
respect to different nearest-search scales in Fig. 3 and 4.
Compared with other methods, the mAP of GR-DNN(*)
decreases more slowly with the increase of retrieved sam-
ples, which indicates that cleaner neighborhoods within lo-
cal regions are better obtained. We present the statistics of
mAP@100,@100,@1000,@1000 on four datasets respec-
tively on Table 2. The mAP of GR-DNN(*) has an compre-
hensive improvement compared with all the baselines. For
example, the mAP scores of GR-DNN(C-DAE) are 0.8352,
0.7920 and 0.7731 on YaleB, MNIST and MNIST2 respec-
tively, while C-DAE achieves 0.8170, 0.7612 and 0.7582,
respectively. The relative improvements are 2.23%,4.05%
and 1.97%, which shows that the proposed graph regulariz-
er could be an effective module to enhance C-DAE. More-
over, GR-DNN(DAE) outperforms over C-DAE, D-DAE
and LAE. The superior performance indicates that the deep
graph regularizer provides more effective regularization in-
ﬂuence and a more compact way to enforce the local struc-
ture than existing regularizer.

4.3. Clustering Results

The clustering experiments are conducted to demonstrate
that GR-DNN not only can preserve the local geometric
structure but also can better extract the global high-level
semantics. Table 2 shows that the performance of GR-
DNN(*) has an comprehensive improvement in terms of
both NMI and ACC. Comparing GR-DNN(*) with DAE, D-
DAE and C-DAE, both the average NMI and ACC are im-
proved with a margin on YaleB, MNIST, and MNIST2. For
example, GR-DNN(D-DAE) achieves relatively 3.01% N-
MI improvement over D-DAE on MNIST, and 2.17% NMI
improvement over LAE on MNIST2. It reveals that better

semantic structures are captured with the help of the deep
graph regularizer, and the preserved local geometric struc-
ture gives rise to the better clustering quality and more dis-
criminative embedding space. Comparing GR-DNN(DAE)
with D-DAE and C-DAE, we see that explicitly perform-
ing afﬁnity propagation can better capture the geometric
structure than implicitly enforcing the insensitivity of the
code. The superior performance of GR-DNN(DAE) over
LAE shows that the proposed deep graph regularizer has
more merit in capturing complex geometric structure than
the shallow-structured Laplacian regularizer.

4.4. Discussions on the anchor graphs

Anchor graph (AG) is an approximation method for
building regular K-Nearest Neighbor
(K-NN) graphs.
When building an AG, the parameter K and the number of
anchor points Na have an impact on its “locality” property.
We formulate the improvement of mAP as ∆(mAP @#) =
mAP @#(GR-DNN)−mAP @#(D-DAE) to evaluate this
impact. First, as shown in Fig. 6a, we investigate different
Ks of K-NN graphs while ﬁxing Na = 1k. With the incre-
ment of K, ∆(mAP @10) and ∆(mAP @100) are gradu-
ally decreased while ∆(mAP @2k) and ∆(mAP @5k) are
increased a lot. It indicates that small K emphasizes more
on the local structure, and large value respects more on the
global structure. However, there is a trade-off between these
two impacts. Then we investigate different Nas while ﬁxing
K = 30 as illustrated in Fig. 6b. On the contrary, the more
local structure is captured as the increase of Na, and the
enforcement of the global structure is gradually lost. More-
over, both the overly small and overly large values of Na
show relatively poor performance of GR-DNN. Overly s-
mall value of Na overemphasizes the global structure, while
overly large value results in highly sparse AG, and the afﬁn-
ity information is lost too much.

1209

(cid:2)(cid:15)&'*+(cid:24),(cid:17)(cid:24)-%(cid:28)%(cid:22)%(cid:24)!(cid:24)/(cid:24)(cid:12)(cid:29)"(cid:10)$

(cid:2)(cid:15)&'*+(cid:24),(cid:17)(cid:24)-%(cid:28)%(cid:22)%(cid:24)(cid:12)(cid:29)(cid:24)/(cid:24)!"(cid:2)(cid:9)

(cid:17)
,
(cid:24)
+
*
'
&
(cid:15)
(cid:2)

(cid:9)%(cid:9)(cid:8)

(cid:9)%(cid:9)(cid:5)

(cid:9)%(cid:9)(cid:4)

(cid:9)%(cid:9)(cid:3)

(cid:9)%(cid:9)(cid:2)

(cid:9)%(cid:9)(cid:11)

(cid:9)%(cid:9)(cid:10)

(cid:9)

(cid:30)(cid:9)%(cid:9)(cid:10)

(cid:9)%(cid:9)(cid:8)

(cid:9)%(cid:9)(cid:5)

(cid:9)%(cid:9)(cid:4)

(cid:9)%(cid:9)(cid:3)

(cid:9)%(cid:9)(cid:2)

(cid:9)%(cid:9)(cid:11)

(cid:9)%(cid:9)(cid:10)

!"(cid:10)(cid:9) (cid:2)(cid:9) (cid:11)(cid:9)(cid:9) (cid:4)(cid:9)(cid:9) (cid:10)$
(cid:2)(cid:3)(cid:4)

(cid:9)
(cid:12)(cid:29)"

(cid:10)(cid:9)(cid:9) (cid:4)(cid:9)(cid:9) (cid:10)$
(cid:2)(cid:5)(cid:4)

(cid:4)$ (cid:10)(cid:9)$

Figure 6: (a) Relative mAP improvement w.r.t. K. (b) Rel-
ative mAP improvement w.r.t. Na.

4.5. Discussions on the graph regularizer depth

Here we give some discussion on how the depth of da-
ta and graph pathway affect the learning performance. For
this purpose, we empirically tune the number of layers for
each pathway with the searching grid of {3, 4, 5, 6} and the
corresponding performance is shown in Fig. 5c. We ob-
serve that more layers lead to a better performance. It is
also shown that the depth of the graph-decoder has stronger
impact on the performance than the data-decoder. This re-
conﬁrms the regularizing inﬂuence of the graph regularizer.

4.6. Parameter Analysis

For the parameters to be tuned for GR-DNN, we ana-
lyze the most crucial η and the code dimension due to the
space limit. From Fig. 5a, we see that both overly small and
overly large values of η show relatively poor performance
of GR-DNN. This is consistent with the impact of η in the
presented models. Overly small values of η eliminates the
inﬂuence of local invariance criterion, while too large val-
ues overemphasize the local correlations and ignores the in-
dividuality of the data. As a result, η can be chosen be-
tween interval of [0.5, 10] in practice. Fig. 5b shows that
GR-DNN consistently outperforms other methods w.r.t. d-
ifferent code dimensions. Unlike the stable mAP@10 and
mAP@100, the mAP@1k decreases signiﬁcantly as we in-
crease the code dimension. This indicates that large code
size introduces more noise, and additional codes tend to
model less discriminative visual information ( e.g., recon-
structing background pixels), which degrades the clustering
performance.

0
1
2
3
4
5
6
7
8
9

Figure 7: The left and right panel shows the 2-dimensional
codes produced by D-DAE and GR-DNN(D-DAE) on the
MNIST test data using a 784-1000-500-250-2 encoder re-
spectively.

Figure 8: The top, middle and bottom panel respectively
shows the original samples, the reconstructed samples by
D-DAE and GR-DNN(D-DAE).

within local regions, and thus a discriminative embedding
result can be achieved. Visualizations of the reconstructed
samples of different methods are presented in Fig. 8. Our
method achieves more clear and accurate reconstruction.

5. Conclusion

In this work, we propose a graph regularized deep neural
network (GR-DNN) to endow the DAEs with the ability of
retaining the local geometric structure. A robust and com-
pact embedding space is learned to simultaneously preserve
the high-level semantics and the geometric structure with-
in local manifolds. Theoretical analysis presents the close
relationship between the proposed graph regularizer and the
graph Laplacian regularizer in terms of the optimization ob-
jective. The proposed model achieves linear computational
complexity and empirical study shows the promising learn-
ing performance. In future work, we will focus on tailoring
the model to learn compact hash codes for retrieval task and
extending it to multi-view scenarios.

4.7. Visualization

Acknowledgment

We qualitatively investigate the learned embedding by
projecting them into a 2D space. The resulting visualiza-
tions are given in Fig. 7. In comparison, the proposed graph
regularizer exerts a force to repel or attract the mapped
points depending on whether they are geometrically close

This work was supported in part by National Natu-
ral Science Foundation of China: 61402431, 61332016,
61620106009, 61672497, 61650202, U1636214 and
61572488, and in part by Key Research Program of Frontier
Sciences, CAS: QYZDJ-SSW-SYS013.

1210

[18] X. Niyogi. Locality preserving projections.

In Neural in-
formation processing systems, volume 16, page 153. MIT,
2004.

[19] S. Rifai, P. Vincent, X. Muller, X. Glorot, and Y. Bengio.
Contractive auto-encoders: Explicit invariance during fea-
In Proceedings of the 28th International
ture extraction.
Conference on Machine Learning (ICML-11), pages 833–
840, 2011.

[20] S. T. Roweis and L. K. Saul. Nonlinear dimensionality reduc-
tion by locally linear embedding. Science, 290(5500):2323–
2326, 2000.

[21] C. Silberer and M. Lapata. Learning grounded meaning
representations with autoencoders. In Proceedings of ACL,
pages 721–732, 2014.

[22] Theano. Theano: A Python framework for fast compu-
arXiv e-prints, ab-

tation of mathematical expressions.
s/1605.02688, May 2016.

[23] F. Tian, B. Gao, Q. Cui, E. Chen, and T.-Y. Liu. Learning
deep representations for graph clustering. In Proceedings of
the AAAI Conference on Artiﬁcial Intelligence, pages 1293–
1299, 2014.

[24] P. Vincent, H. Larochelle, Y. Bengio, and P.-A. Manzagol.
Extracting and composing robust features with denoising au-
toencoders. In Proceedings of the 25th international confer-
ence on Machine learning, pages 1096–1103. ACM, 2008.

[25] D. Wang, P. Cui, M. Ou, and W. Zhu. Deep multimodal hash-
ing with orthogonal units. In International Joint Conference
on Artiﬁcial Intelligence,IJCAI, 2015.

[26] W. Wang, R. Arora, K. Livescu, and J. Bilmes. On deep
In Proceedings of the
multi-view representation learning.
international conference on Machine learning,ICML, 2015.
[27] J. Weston, F. Ratle, H. Mobahi, and R. Collobert. Deep learn-
In Neural Networks:

ing via semi-supervised embedding.
Tricks of the Trade, pages 639–655. Springer, 2012.

[28] X. Zhu and Z. Ghahramani. Learning from labeled and unla-
beled data with label propagation. Technical report, Citeseer,
2002.

References

[1] M. Belkin and P. Niyogi. Laplacian eigenmaps for dimen-
sionality reduction and data representation. Neural compu-
tation, 15(6):1373–1396, 2003.

[2] Y. Bengio, P. Lamblin, D. Popovici, H. Larochelle, et al.
Greedy layer-wise training of deep networks. Advances in
neural information processing systems, 19:153, 2007.
[3] D. Cai, X. He, and J. Han. Document clustering using lo-
cality preserving indexing. IEEE TKDE, 17(12):1624–1637,
2005.

[4] D. Cai, X. He, J. Han, and T. S. Huang. Graph regular-
ized nonnegative matrix factorization for data representation.
IEEE Transactions on Pattern Analysis and Machine Intelli-
gence, 33(8):1548–1560, 2011.

[5] S. Chopra, R. Hadsell, and Y. Lecun. Learning a similarity
metric discriminatively, with application to face veriﬁcation.
In IEEE Computer Society Conference on Computer Vision
and Pattern Recognition, pages 539–546 vol. 1, 2005.
[6] J. Deng, Z. Zhang, E. Marchi, and B. Schuller. Sparse
autoencoder-based feature transfer learning for speech emo-
tion recognition. In Affective Computing and Intelligent In-
teraction, pages 511–516, 2013.

[7] C. Eckart and G. Young. The approximation of one matrix by
another of lower rank. Psychometrika, 1(3):211–218, 1936.
[8] R. Hadsell, S. Chopra, and Y. LeCun. Dimensionality reduc-
In IEEE Computer
tion by learning an invariant mapping.
Society Conference on Computer Vision and Pattern Recog-
nition, volume 2, pages 1735–1742, 2006.
[9] G. E. Hinton and R. R. Salakhutdinov.

Reducing the
Science,

dimensionality of data with neural networks.
313(5786):504–507, 2006.

[10] K. Jia, L. Sun, S. Gao, Z. Song, and B. E. Shi. Laplacian
auto-encoders: An explicit learning of nonlinear data mani-
fold. Neurocomputing, 160:250–260, 2015.

[11] Y. LeCun, C. Cortes, and C. J. Burges. The mnist database

of handwritten digits, 1998.

[12] D. D. Lee and H. S. Seung. Algorithms for non-negative
matrix factorization. In Advances in neural information pro-
cessing systems, pages 556–562, 2001.

[13] Y. Li, F. Nie, H. Huang, and J. Huang. Large-scale multi-
view spectral clustering via bipartite graph. In Proceedings
of the AAAI Conference on Artiﬁcial Intelligence, 2015.
[14] Z. Li, Y. Yang, J. Liu, X. Zhou, and H. Lu. Unsupervised
feature selection using nonnegative spectral analysis. In Pro-
ceedings of the International Conference on Artiﬁcial Intel-
ligence, 2012.

[15] Y. Liao, Y. Wang, and Y. Liu. Image representation learn-
ing using graph regularized auto-encoders. arXiv preprint
arXiv:1312.0786, 2013.

[16] S. A. Nene, S. K. Nayar, H. Murase, et al. Columbia object
image library (coil-20). Technical report, technical report
CUCS-005-96, 1996.

[17] J. Ngiam, A. Khosla, M. Kim, J. Nam, H. Lee, and A. Y. Ng.
Multimodal deep learning. In Proceedings of the 28th inter-
national conference on machine learning (ICML-11), pages
689–696, 2011.

1211

