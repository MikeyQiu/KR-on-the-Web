8
1
0
2
 
l
u
J
 
2
 
 
]

G
L
.
s
c
[
 
 
1
v
1
0
8
0
0
.
7
0
8
1
:
v
i
X
r
a

Deepcode: Feedback Codes via Deep Learning

Hyeji Kim∗, Yihan Jiang†, Sreeram Kannan†, Sewoong Oh*, Pramod Viswanath*
University of Illinois at Urbana Champaign*, University of Washington†

Abstract

The design of codes for communicating reliably over a statistically well deﬁned channel is an
important endeavor involving deep mathematical research and wide-ranging practical applications.
In this work, we present the ﬁrst family of codes obtained via deep learning, which signiﬁcantly
beats state-of-the-art codes designed over several decades of research. The communication
channel under consideration is the Gaussian noise channel with feedback, whose study was
initiated by Shannon; feedback is known theoretically to improve reliability of communication,
but no practical codes that do so have ever been successfully constructed.

We break this logjam by integrating information theoretic insights harmoniously with
recurrent-neural-network based encoders and decoders to create novel codes that outperform
known codes by 3 orders of magnitude in reliability. We also demonstrate several desirable
properties of the codes: (a) generalization to larger block lengths, (b) composability with known
codes, (c) adaptation to practical constraints. This result also has broader ramiﬁcations for
coding theory: even when the channel has a clear mathematical model, deep learning methodolo-
gies, when combined with channel-speciﬁc information-theoretic insights, can potentially beat
state-of-the-art codes constructed over decades of mathematical research.

1

Introduction

The ubiquitous digital communication enabled via wireless (e.g. WiFi, mobile, satellite) and wired
(e.g. ethernet, storage media, computer buses) media has been the plumbing underlying the current
information age. The advances of reliable and eﬃcient digital communication have been primarily
driven by the design of codes which allow the receiver to recover messages reliably and eﬃciently
under noisy conditions. The discipline of coding theory has made signiﬁcant progress in the past
seven decades since Shannon’s celebrated work in 1948 [1]. As a result, we now have near optimal
codes in a canonical setting, namely, additive white Gaussian noise (AWGN) channel. However,
several channel models of great practical interest lack eﬃcient and practical coding schemes.

A channel with feedback (from the receiver to the transmitter) is an example of a long-standing
open problem and with signiﬁcant practical importance. Modern wireless communication includes
feedback in one form or the other; for example, the feedback can be the received value itself, or
quantization of the received value or an automatic repeat request (ARQ) [2]. Accordingly, there
are diﬀerent models for channels with feedback, and among them, the AWGN channel with output
feedback is a model that captures the essence of channels with feedback; this model is also classical,

∗H. Kim, S. Oh, and P. Viswanath are with Coordinated Science Lab at the University of Illinois at Urbana
Champaign. S. Oh and P. Viswanath are with the Department of Industrial and Enterprise Systems Engineering and
the Department of Electrical Engineering, respectively, at the University of Illinois at Urbana Champaign. Email:
{hyejikim,swoh,pramodv}@illinois.edu

†Y. Jiang and S. Kannan are with the Department of Electrical Engineering at the University of Washington.

Email: yihanrogerjiang@gmail.com (Y. Jiang), ksreeram@uw.edu (S. Kannan).

1

introduced by Shannon in 1956 [3]. In this channel model, the received value is fed back (with
unit time delay) to the transmitter without any processing (refer to Figure 1 for an illustration of
channel). Designing codes for this channel via deep learning approaches is the central focus of this
paper.

While the output feedback does not improve the Shannon capacity of the AWGN channel [3], it
is known to provide better reliability at ﬁnite block lengths [4]. On the other hand, practical coding
schemes have not been successful in harnessing the feedback gain thereby signiﬁcantly limiting the
use of feedback in practice. This state of the art is at odds with the theoretical predictions of the
gains in reliability via using feedback: the seminal work of Schalkwijk and Kailath [4] proposed
a (theoretically) achievable scheme (S-K scheme) with superior reliability guarantees, but which
suﬀers from extreme sensitivity to both the precision of the numerical computation and noise in the
feedback [5, 6]. Another competing scheme of [7] is designed for channels with noisy feedback, but
not only is the reliability poor, it is almost independent of the feedback quality, suggesting that the
feedback data is not being fully exploited. More generally, it has been proven that no linear code
incorporating the noisy output feedback can perform well [8]. This is especially troubling since all
practical codes are linear and linear codes are known to achieve capacity (without feedback) [9].

In this paper, we demonstrate new neural network-driven encoders (with matching decoders)
that operate signiﬁcantly better (100–1000 times) than state of the art on the AWGN channel with
(noisy) output feedback. We show that architectural insights from simple communication channels
with feedback, when coupled with recurrent neural network architectures, can discover novel codes.
We consider Recurrent Neural Network (RNN) parameterized encoders (and decoders), which are
inherently nonlinear and map information bits directly to real-valued transmissions in a sequential
manner.

This is the ﬁrst family of codes obtained via deep learning which beats state-of-the-art codes,
signaling a potential shift in code design, which historically has been driven by individual human
ingenuity with sporadic progress over the decades. Henceforth, we call this new family of codes
Deepcode. We also note that although there has been signiﬁcant recent interest in deep-learning
driven designs of decoders for known codes, or end-to-end designs with varying degrees of success [10,
11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22], none of these works are able to design novel codes
that can beat the state of the art. In a diﬀerent context, for distributed computation, where the
encoder adds redundant computations so that the decoder can reliably approximate the desired
computations under unavailabilities, [23] showed that neural network based codes can beat the
state-of-the-art codes. We also demonstrate the superior performance of variants of Deepcode under
a variety of practical constraints. Furthermore, Deepcode has complexity comparable to traditional
codes, even without any eﬀort at optimizing the storage and run-time complexity of the neural
network architectures. Our main contributions are as follows:

1. We demonstrate Deepcode – a new family of RNN-driven neural codes that have three orders
of magnitude better reliability than state of the art with both noiseless and noisy feedback.
Our results are signiﬁcantly driven by the intuition obtained from information and coding
theory, in designing a series of progressive improvements in the neural network architectures
(Section 3 and 4).

2. We show that variants of Deepcode signiﬁcantly outperform state-of-the art codes even under a
variety of practical constraints (example: delayed feedback, very noisy feedback link) (Section 4).

3. We show composability: Deepcode naturally concatenates with a traditional inner code and
demonstrates continued improvements in reliability as the block length increases (Section 4).

2

4. Our interpretation and analysis of Deepcode provide guidance on the fundamantal understand-
ing of how the feedback can be used and some information theoretic insights into designing
codes for channels with feedback (Section 5).

5. We discuss design decisions and demonstrate practical gains of Deepcode in practical cellular

communication systems (Section 6).

2 Problem formulation

The most canonical channel studied in the literature (example: textbook material [24]) and also
used in modeling practical scenarios (example: 5G LTE standards) is the additive white Gaussian
noise (AWGN) channel without feedback. Concretely, the encoder takes in K information bits jointly,
b = (b1, · · · , bK) ∈ {0, 1}K, and outputs n real valued signals to be transmitted over a noisy channel
(sequentially). At the i-th transmission for each i ∈ {1, . . . , n}, a transmitted symbol xi ∈ R is
corrupted by an independent Gaussian noise ni ∼ N (0, σ2), and the decoder receives yi = xi +ni ∈ R.
After receiving the n received symbols, the decoder makes a decision on which information bit b was
sent, out of 2K possible choices. The goal is to maximize the probability of correctly decoding the
received symbols and recover b.

Both the encoder and the decoder are functions, mapping b ∈ {0, 1}K to x ∈ Rn and y ∈ Rn
to ˆb ∈ {0, 1}K, respectively. The design of a good code (an encoder and a corresponding decoder)
addresses both (i) the statistical challenge of achieving a small error rate; and (ii) the computational
challenge of achieving the desired error rate with eﬃcient encoder and decoder. Almost a century
of progress in this domain of coding theory has produced several innovative codes that eﬃciently
achieve small error rate, including convolutional codes, Turbo codes, LDPC codes, and polar codes.
These codes are known to perform close to the fundamental limits on reliable communication [25].

Figure 1: AWGN channel with noisy output feedback

In a canonical AWGN channel with noisy feedback, the received symbol yi is transmitted back
to the encoder after one unit time of delay and via another additive white Gaussian noise feedback
channel (Figure 1). The encoder can use this feedback symbol to sequentially and adaptively decide
what symbol to transmit next. At time i the encoder receives a noisy view of what was received at
the receiver (in the past by one unit time), ˜yi−1 = yi−1 + wi−1 ∈ R, where the noise is independent
and distributed as wi−1 ∼ N (0, σ2
F ). Formally, an encoder is now a function that sequentially maps
the information bit vector b and the feedback symbols ˜yi−1
1 = (˜y1, · · · , ˜yi−1) received thus far to a
(b, ˜yi−1
i ∈ {1, · · · , n} and a decoder is a function that maps
transmit symbol xi: fi :
1
the received sequence yn

1 = (y1, · · · , yn) into estimated information bits: g :

1 (cid:55)→ ˆb ∈ {0, 1}K.
yn

) (cid:55)→ xi,

The standard measures of performance are the average bit error rate (BER) deﬁned as BER ≡
P(bi (cid:54)= ˆbi) and the block error rate (BLER) deﬁned as BLER ≡ P(b (cid:54)= ˆb), where the

(1/K) (cid:80)K
i=1

3

randomness comes from the forward and feedback channels and any other sources of randomness
that might be used in the encoding and decoding processes. It is standard (both theoretically and
practically) to have an average power constraint, i.e., (1/n)E[(cid:107)x(cid:107)2] ≤ 1, where x = (x1, · · · , xn) and
the expectation is over the randomness in choosing the information bits b uniformly at random, the
randomness in the noisy feedback symbols ˜yi’s, and any other randomness used in the encoder.

While the capacity of the channel remains the same in the presence of feedback [3], the reliability
can increase signiﬁcantly as demonstrated by the celebrated result of Schalkwijk and Kailath (S-K),
[4], which is described in detail in Appendix D. Although the optimal theoretical performance is
met by the S-K scheme, critical drawbacks make it fragile. Theoretically, the scheme critically relies
on exactly noiseless feedback (i.e. σ2
F = 0), and does not extend to channels with even arbitrarily
small amount of noise in the feedback (i.e. σ2
F > 0). Practically, the scheme is extremely sensitive to
numerical precisions; we see this in Figure 2, where the numerical errors dominate the performance
of the S-K scheme, with a practical choice of MATLAB implementation with a precision of 16 bits
to represent ﬂoating-point numbers.

Even with a noiseless feedback channel with σ2

F = 0, which the S-K scheme is designed for,
it is outperformed signiﬁcantly by our proposed Deepcode (described in detail in Section 3). At
moderate SNR of 2 dB, Deepcode can outperform S-K scheme by three orders of magnitude in BER.
In Figure 2 (left), the resulting BER is shown as a function of the Signal-to-Noise Ratio (SNR)
deﬁned as −10 log10 σ2, where we consider the setting of rate 1/3 and information block length of
K = 50 (hence, n = 150). Also shown as a baseline is an LTE turbo code which does not use any
feedback. Deepcode exploits the feedback symbols to achieve a signiﬁcant gain of two orders of
magnitude consistently over the Turbo code for all SNR. In Figure 2 (right), BLER of Deepcode is
shown as a function of the Signal-to-Noise Ratio (SNR), together with state-of-the art polar, LDPC,
and tail-bitting convolutional codes (TBCC) in a 3GPP document for the 5G meeting [26] (we refer
to Appendix A for the details of these codes used in the simulation). Deepcode signiﬁcantly improves
over all state-of-the-art codes of similar block-length and the same rate. Also plotted as a baseline
are the theoretically estimated performance of the best code with no eﬃcient decoding schemes. This
impractical baseline lies between approximate achievable BLER (labelled Normapx in the ﬁgure)
and a converse to the BLER (labelled Converse in the ﬁgure) from [25, 27]. We note that there
are schemes proposed more recently that address the sensitivity to noise in the feedback, a major
drawback of the S-K scheme. However, these schemes either still suﬀer from similar sensitivity to
numerical precisions at the decoder [28], or are incapable of exploiting the feedback information [7]
as we illustrate in Figure 5 in experiments with noisy feedback.

BER

BLER

SNR = −10 log10 σ2

SNR = −10 log10 σ2

Figure 2: Deepcode signiﬁcantly outperforms the baseline of S-K and Turbo code, on block-length
50 and noiseless feedback in BER (left) and BLER (right). Deepcode also outperforms all state-of-the
art codes (without feedback) in BLER (right).

4

3 Deepcode: neural encoder and decoder

A natural strategy to create a feedback code is to utilize a recurrent neural network (RNN) as an
encoder since (i) communication with feedback is naturally a sequential process and (ii) we can
exploit the sequential structure for eﬃcient decoding. We propose representing the encoder and the
decoder as RNNs, training them jointly under AWGN channels with noisy feedback, and minimizing
the error in decoding the information bits. However, in our experiments, we ﬁnd that this strategy
by itself is insuﬃcient to achieve any performance improvement with feedback.

We exploit information theoretic insights to enable improved performance, by considering the
erasure channel with feedback: here transmitted bits are either received perfectly or erased, and
whether the previous bit was erased or received perfectly is fed back to the transmitter. In such a
channel, the following two-phase scheme can be used: transmit a block of symbols, and then transmit
whichever symbols were erased in the ﬁrst block (and ad inﬁnitum). This motivates a two-phase
scheme, where uncoded bits are sent in the ﬁrst phase, and then based on the feedback in the ﬁrst
phase, coded bits are sent in the second phase; thus the code only needs to be designed for the
second phase. Even inside this two-phase paradigm, several architectural choices need to be made.
We show in this section that these intuitions can be critically employed to innovate neural network
architectures.

Our experiments focus on the setting of rate 1/3 and information block length of 50 for
concreteness.1 That is, the encoder maps K = 50 message bits to a codeword of length n = 150. We
discuss generalizations to longer block lengths in Section 4.

Encoder A: RNN feedback encoder

BER

Figure 3: Building upon a simple linear RNN encoder (left), we progressively improve the architecture.
Eventually with RNN(tanh)+ZP+W+A architecture formally described in Section 3, we signiﬁcantly
outperform the baseline of S-K scheme and Turbo code, by several orders of magnitude in the bit
error rate, on block-length 50 and noiseless feedback (σ2

F = 0).

SNR =−10 log10 σ2

A. RNN feedback encoder/decoder (RNN (linear) and RNN (tanh)). We propose an
encoding scheme that progresses in two phases. In the ﬁrst phase, the K information bits are sent
raw (uncoded) over the AWGN channel. In the second phase, 2K coded bits are generated based on
the information bits b and (delayed) output feedback and sequentially transmitted. We propose a
decoding scheme using two layers of bidirectional gated recurrent units (GRU). When jointly trained,
a linear RNN encoder achieves performance close to Turbo code that does not use the feedback

1Source codes are available under https://github.com/hyejikim1/Deepcode (Keras) and https://github.com/

yihanjiang/feedback_code (PyTorch)

5

information at all as shown in Figure 3. (To generate plots in Figure 3, we take an average bit error
rate over 108 bits for SNR = −1, 0dB and 109 bits for SNR= 1, 2dB.) With a non-linear activation
function of tanh(·), the performance improves, achieving BER close to the existing S-K scheme.
Such a gain of non-linear codes over linear ones is in-line with theory [28].

Encoding. The architecture of the encoder is shown in Figure 3. The encoding process has two
phases. In the ﬁrst phase, the encoder simply transmits the K raw message bits. That is, the encoder
maps bk to ck = 2bk − 1 for k ∈ {1, · · · , K}, and stores the feedback ˜y1, · · · , ˜yK for later use. In the
second phase, the encoder generates a coded sequence of length 2K (length (1/r − 1)K for general
rate r code) through a single directional RNN. In particular, each k-th RNN cell generates two coded
bits ck,1, ck,2 for k ∈ {1, . . . , K}, which uses both the information bits and (delayed) output feedback
from the earlier raw information bit transmissions. The input to the k-th RNN cell is of size four: bk,
˜yk − ck (the estimated noise added to the k-th message bit in phase 1) and the most recent two noisy
feedbacks from phase 2: ˜yk−1,1 − ck−1,1 and ˜yk−1,2 − ck−1,2. Note that we use ˜yk,j = ck,j + nk,j + wk,j
to denote the feedback received from the transmission of ck,j for k ∈ {1, · · · , K} and j ∈ {1, 2}, and
nk,j and wk,j are corresponding forward and feedback channel noises, respectively.

To generate codewords that satisfy power constraint, we put a normalization layer to the RNN
outputs so that each coded bit has a mean 0 and a variance 1. During training, the normalization
layer subtracts the batch mean from the output of RNN and divides by the standard deviation of
the batch. After training, we compute the mean and the variance of the RNN outputs over 106
examples. In testing, we use the precomputed means and variances. Further details on the encoder
are shown in Appendix B.1.

Decoding. Based on the received sequence y = (y1, · · · , yk, y1,1, y1,2, y2,1, y2,2, · · · , yK,1, yK,2) of
length 3K, the decoder estimates K information bits. For the decoder, we use a two-layered
bidirectional GRU, where the input to the k-th GRU cell is a tuple of three received symbols,
(yk, yk,1, yk,2). We refer to Appendix B.1 for detailed description of the decoder.

Training. Both the encoder and decoder are trained jointly using binary cross-entropy as the
loss function over 4 × 106 examples, with batch size 200. The input to the neural network is K
information bits and the output is K estimated bits (as in the autoencoder setting). AWGN channels
are simulated for the channels from the encoder to the decoder and from decoder to the encoder. In
training, we set the forward SNR to be test SNR and feedback SNR to be the test feedback SNR.
We randomly initialize weights of the encoder and the decoder. We observed that training with
random initialization of encoder-decoder gives a better encoder-decoder compared to initializing
with a pre-trained encoder/decoder by sequential channel codes for non-feedback AWGN channels
(e.g. convolutional codes). We also use a decaying learning rate and gradient clipping; we reduce the
learning rate by 10 times after training with 106 examples, starting from 0.02. Gradients are clipped
to 1 if L2 norm of the gradient exceeds 1, preventing gradients from becoming too large.

Typical error analysis. Due to the recurrent structure in generating coded bits (ck,1, ck,2), the
coded bit stream carries more information on the ﬁrst few bits than the last few bits (e.g. b1 than
bK). This results in more errors in the last information bits, as shown in Figure 4, where we plot the
average BER of bk for k = {1, · · · , K}.

B. RNN feedback code with zero padding (RNN (tanh) + ZP). In order to reduce high
errors in the last information bits, as shown in Figure 4, we apply the zero padding (ZP) technique;
we pad a zero in the end of information bits, and transmit a codeword for the padded information
bits (see Appendix B.2 for implementation details). By applying zero padding, the BER of the

6

BER of bk

σ2

Position (k)

Position (k)

Figure 4: (Left) A naive RNN(tanh) code gives a high BER in the last few information bits. With
the idea of zero padding and power allocation, the RNN(tanh)+ZP+W+A architecture gives a BER
that varies less across the bit position, and overall BER is signiﬁcantly improved over the naive
RNN(tanh) code. (Middle) Noise variance across bit position which results in a block error: High
noise variance on the second parity bit stream (c1,2, · · · , cK,2) causes a block error. (Right) Noise
covariance: Noise sequence which results in a block error does not have a signiﬁcant correlation
across position.

last information bits, as well as other bits, drops signiﬁcantly, as shown in Figure 4. Zero padding
requires a few extra channel usages (e.g. with one zero padding, we map 50 information bits to a
codeword of length 153). However, due to the signiﬁcant improvement in BER, it is widely used in
sequential codes (e.g. convolutional codes and turbo codes).

Typical error analysis. To see if there is a pattern in the noise sequence which makes the decoder
fail, we simulate the code and the channels and look at the ﬁrst and second order noise statistics
which result in the decoding error. In Figure 4 (Middle), we plot the average variance of noise added
to bk in the ﬁrst phase and ck,1 and ck,2 in the second phase, as a function of k, which results in the
(block) error in decoding. From the ﬁgure, we make two observations: (i) large noise in the last bits
causes an error, and (ii) large noise in ck,2 is likely to cause an error, which implies that the raw bit
stream and the coded bit streams are not equally robust to the noise – an observation that will be
exploited next. In Figure 4 (Right), we plot noise covariances that result in a decoding error. From
Figure 4 (Right), we see that there is no particular correlation within the noise sequence that makes
the decoder fail.

C. RNN feedback code with power allocation (RNN(tanh) + ZP + W). Based on the
observation that the raw bit ck and coded bit ck,1, ck,2 are not equally robust, as shown in Figure 4
(Middle), we introduce trainable weights which allow allocating diﬀerent amount of power to the raw
bit stream and coded bit streams (see Appendix B.3 for implementation details). By introducing
and training these weights, we achieve the improvement in BER as shown in Figures 3 and 4.

Typical error analysis. While the average BER is improved by about an order of magnitude for
most bit positions as shown in Figure 4 (Left), the BER of the last bit remains about the same. On
the other hand, the BER of the ﬁrst few bits is now smaller, suggesting the following bit-speciﬁc
power allocation method.

D. Deepcode: RNN feedback code with bit power allocation (RNN(tanh)+ZP+W+A).
One way to resolve the unbalanced error according to bit position is to use power allocation. Ideally,
we would like to reduce the power for the ﬁrst information bits and increase the power for the last
information bits so that we help transmission of the last few information bits more than the ﬁrst

7

information bits. However, it is not clear how much power to allow for the ﬁrst few information bits
and the last few information bits. Hence, we introduce a weight vector allowing the power of bits in
diﬀerent positions to be diﬀerent (as illustrated in Figure 13 in Appendix B.4). The resulting BER
curve is shown in Figure 3. We can see that the BER is noticeably decreased. In Figure 4, we can
also see that the BER in the last bits is reduced, and we can also see that the BER in the ﬁrst bits
is increased, as expected. Our use of unequal power allocation across information bits is in-line with
other approaches from information/coding theory [29], [30]. We call this neural code Deepcode.

Typical error analysis. As shown in Figure 4, the BER at each position remains about the same
except for the last few bits. This suggests a symmetry in our code and nearest-neighbor-like decoder.
For an AWGN channel without feedback, it is known that the optimal decoder (nearest neighbor
decoder) under a symmetric code (in particular, each coded bit follows a Gaussian distribution) is
robust to the distribution of noise [31]; the BER does not increase if we keep the power of noise
and only change the distribution. As an experiment demonstrating the robustness of Deepcode, in
Appendix E, we show that BER of Deepcode does not increase if we keep the power of noise and
change the distribution from i.i.d. Gaussian to bursty Gaussian noise.

Complexity. Complexity and latency, as well as reliability, are important metrics in practice, as
the encoder and decoder need to run in real time on mobile devices. Deepcode has computational
complexity and latency comparable to currently used codes (without feedback) that are already in
communication standards. Turbo decoder, for example, is a belief-propagation decoder with many
(e.g., 10 – 20) iterations, and each iteration is followed by a permutation. Turbo encoder also includes
a permutation of information bits (of length K). On the other hand, the proposed neural encoder in
Deepcode is a single layered RNN encoder with 50 hidden units, and the neural decoder in Deepcode
is a 2-layered GRU decoder, also with 50 hidden units, all of which are matrix multiplications that
can be parallelized. Ideas such as knowledge distillation [32] and network binarization [33] can be
used to potentially further reduce the complexity of the network.

4 Practical considerations: noise, delay, coding in feedback, and

blocklength

We considered so far the AWGN channel with noiseless output feedback with a unit time-step delay.
In this section, we demonstrate the robustness of Deepcode (and its variants) under two variations
on the feedback channel, noise and delay, and present generalization to longer block lengths. We
show that (a) Deepcode and its variant that allows a K-step delayed feedback are more reliable than
the state-of-the-art schemes in channels with noisy feedback; (b) by allowing the receiver to feed
back an RNN encoded output instead of its raw output, and learning this RNN encoder, we achieve
a further improvement in reliability, demonstrating the power of encoding in the feedback link; (c)
Deepcode concatenated with turbo code achieves superior error rate decay as block length increases
with noisy feedback.

Noisy feedback. We show that Deepcode, trained on AWGN channels with noisy output feedback,
achieves a signiﬁcantly smaller BER than both S-K and C-L schemes [7] in AWGN channels with
noisy output feedback. In Figure 5 (Left), we plot the BER as a function of the feedback SNR for
S-K scheme, C-L scheme, and Deepcode for a rate 1/3 code with 50 information bits, where we ﬁx
the forward channel SNR to be 0dB. As feedback SNR increases, we expect the BER to decrease.
However, as shown in Figure 5 (Left), both C-L scheme, designed for channels with noisy feedback,

8

and S-K scheme are sensitive to even a small amount of noise in the feedback, and reliability is
almost independent of feedback quality.

Deepcode outperforms these two baseline (linear) codes by a large margin, with decaying error
as feedback SNR increases, showing that Deepcode harnesses noisy feedback information to make
communication more reliable. This is highly promising as the performance with noisy feedback is
directly related to the practical communication channels. To achieve the performance shown in
Figure 5, for example the line in red, training with matched SNR is required. For each datapoint,
we use diﬀerent neural codes speciﬁcally trained at the same SNR at the test noise. In Section 5, we
discuss how Deepcode diﬀers depending on what SNR it was trained on, hence it is not universal.

BER

BER

BER

SNR of feedback channel

SNR

Blocklength

Figure 5: (Left) Deepcode (introduced in Section 3) and its variant code that allows K time-step
delay signiﬁcantly outperform the two baseline schemes in noisy feedback scenarios. Another variant
of Deepcode which allows the receiver to feed back an RNN encoded output (with K-step delay)
performs even better than Deepcode with raw output feedback (with unit-delay), demonstrating
the power of coding in the feedback. (Middle) By unrolling the RNN cells of Deepcode, the BER
of Deepcode remains unchanged for block lengths 50 to 500. (Right) Concatenation of Deepcode
and turbo code (with and without noise in the feedback) achieves BER that decays exponentially as
block length increases, faster than turbo codes (without feedback) at the same rate.

Noise feedback with delay. We model the practical constraint of delay in the feedback, by
introducing a variant of Deepcode that works with a K time-step delayed feedback (discussed in
detail in Appendix B.5); recall K is the number of information bits and this code tolerates a large
delay in the feedback. We see from Figure 5 (Left), that these neural codes are robust against delay
in the feedback for noisy feedback channels of SNR up to 12dB.

It is natural to allow the receiver to send back a
Noisy feedback with delay and coding.
general function of its past received values, i.e., receiver encodes its output and sends the coded
and real-valued symbol. Designing the code for this setting is challenging as it involves designing
two encoders (one at the transmitter and another at the receiver) and one decoder (at the receiver)
jointly in a sequential manner. Further, both the transmitter and the receiver are performing
encoding and decoding simultaneously and sequentially. We propose using RNN as a receiver
encoder that maps noisy channel output to the transmitted feedback, with implementation details
in Appendix B.5. Figure 5 demonstrates the feedback coding gain over Deepcode with uncoded
feedback. When feedback channel is less noisy, neural codes with coded feedback and K-step delays
can even outperform the neural code with uncoded feedback with one-step delays, overcoming the
challenges of larger delays in practice.

Generalization to longer block lengths. In wireless communications, a wide range of block-
lengths are of interest (e.g., 40 to 6144 information bits in LTE standards). In previous sections, we

9

considered block length of 50 information bits. Here we show how to generalize Deepcode to longer
block lengths and achieve an improved reliability as we increase the block length.

A natural generalization of the RNN-based Deepcode is to unroll the RNN cells. In Figure 5
(Middle), we plot the BER as a function of the SNR, for 50 information bits and length 500
information bits (with noiseless feedback) when we unroll the RNN cells. We can see that the BER
remains the same as we increase block lengths. This is not an entirely satisfying generalization
because, typically, it is possible to design a code for which error rate decays faster as block length
increases. For example, turbo codes have error rate decaying exponentially (log BER decades linearly)
in the block length as shown in Figure 5 (Right). This critically relies on the interleaver, which
creates long range dependencies between information bits that are far apart in the block. Given that
the neural encoder is a sequential code, there is no strong long range dependence. Each transmitted
bit depends on only a few past information bits and their feedback (we refer to Section 5 for a
detailed discussion).

To resolve this problem, we propose a new concatenated code which concatenates Deepcode
(as inner code) and turbo code as an outer code. The outer code is not restricted to a turbo code,
and we refer to Appendix C for a detailed discussion. In Figure 5 (Right), we plot the BERs of the
concatenated code, in channels with both noiseless and noisy feedback (of feedback SNR 10dB), and
turbo code, both at rate 1/9 at (forward) SNR −6.5dB. From the ﬁgure, we see that even with noisy
feedback, BER drops almost exponentially (log BER drops linearly) as block length increases, and
the slope is sharper than the one for turbo codes. We also note that in this setting, C-L scheme
suggests not using the feedback.

5

Interpretation

Thus far we have used information theoretic insights in driving our deep learning designs. Here, we
ask if the deep learning architectures we have learnt can provide an insight to the information theory
of communications with feedback. We aim to understand the behavior of Deepcode (i.e., how coded
bits are generated via RNN in Phase 2). We show that in the second phase, (a) the encoder focuses
on reﬁning information bits that were corrupted by large noise in the ﬁrst phase; and (b) the coded
bit depends on past as well as current information bits, i.e., coupling in the coding process.

Correcting noise from previous phase. The main motivation behind the proposed two-phase
encoding scheme is to use the Phase 2 to clean the noise added in Phase 1. The encoder at Phase
2 knows how much noise was added in Phase 1 (exactly if noiseless feedback and approximately
if noisy). Potentially, it could learn to send this information in the Phase 2, so that the decoder
can reﬁne the corrupted information bits sent in Phase 1. Interpreting the parity bits conﬁrms
this conjecture as shown in Figure 6. We show as a scatter plot multiple instances of the pairs of
random variables (nk, ck,1) (left) and (nk, ck,2) (right), where nk denotes the noise added to the
transmission of bk in the ﬁrst phase. We are plotting 1,000 sample points: 20 samples for each k
and for k ∈ {1, . . . , 50}. This illustrates how the encoder has learned to send rectiﬁed linear unit
(ReLU(x)=max{0, x} ) functional of the noise nk to send the noise information while eﬃciently
using the power. Precisely, the dominant term in the parity bit can be closely approximated by
ck,1 (cid:39) −(2bk − 1) × ReLU(−nk(2bk − 1)), and ck,2 (cid:39) (2bk − 1) × ReLU(−nk(2bk − 1)).

Consider the case when bk = 1. If the noise added to bit bk in Phase 1 is positive, then the bit
is likely to have been correctly decoded, and the parity chooses not to send any information about
nk. The encoder generates coded bits close to zero (i.e., does not further reﬁne bk). Otherwise, the
encoder generates coded bits proportional to the noise nk, and hence uses more power to reﬁne bk.

10

ck,1

ck,2

nk

nk

Figure 6: Noise in ﬁrst phase nk vs. ﬁrst parity bit ck,1 (left) and second parity bit ck,2 (right) under
noiseless feedback channel and forward AWGN channel of SNR 0dB. Blue ‘x’ data points correspond
to those samples conditioned on bk = 1 and red ‘o’ points correspond to those samples conditioned
on bk = 0.

Ideally, for practical use, we want to use the same code for a broad range of varying SNR, as we
might be uncertain about the condition of the channel we are operating on. This is particularly true
for code for non-feedback channels. For channels with output feedback, however, all known encoding
schemes adapt to the channel. For instance, in S-K scheme, in order to achieve the optimal error
rate, it is critical to choose the optimal power allocation across transmission symbols depending on
the (forward) channel SNR. Similarly, C-L scheme also requires pre-computation of optimal power
allocation across transmission depending on the forward and feedback SNRs. In the case of AWGN
channels with feedback, it is not even clear how one could meet the power constraints, if not adapting
to the channel SNR.

In Figure 7, we show how the trained Deepcode has learned to adapt to the channel conditions.
For various choices of forward channel SNRf and feedback channel SNRfb, each scatter plot is showing
5,000 sample points: 100 samples for each k and for k ∈ {1, . . . , 50}. On the top row, as forward
signal power decreases, the parity gradually changes from ck,1 (cid:39) −(2bk − 1) × ReLU(−nk(2bk − 1)) to
ck,1 (cid:39) (2bk − 1) − nk. On the bottom row, as feedback noise increases (i.e., feedback SNR decreases),
the parity gradually becomes less correlated with the sum of forward and feedback noises nk + wk.
Note that under noisy feedback, nk is not available to the encoder, but nk + wk is what is available
to the encoder (nk + wk = ˜yk − ck).

Coupling. A natural question is whether our feedback code is exploiting the memory of RNN and
coding information bits jointly. To answer this question, we look at the correlation between informa-
tion bits and the coded bits. If the memory of RNN were not used, we would expect the coded bits
(ck,1, ck,2) to depend only on bk. We ﬁnd that E[ck,1bk] = −0.42, E[ck,1bk−1] = −0.24, E[ck,1bk−2] =
−0.1, E[ck,1bk−3] = −0.05, and E[ck,2bk] = 0.57, E[ck,2bk−1] = −0.11, E[ck,2bk−2] = −0.05, E[ck,2bk−3]
= −0.02 (for the encoder for forward SNR 0dB and noiseless feedback). This result implies that the
RNN encoder does make use of the memory, of length two to three.

Overall, our analysis suggests that Deepcode exploits memory and selectively enhances bits
that were subject to larger noise - properties reminiscent of any good code. We also observe
that the relationship between the transmitted bit and previous feedback demonstrates a non-linear
relationship as expected. Thus our code has features requisite of a strong feedback code. Furthermore,
improvements can be obtained if instead of transmitting two coded symbols per bit during Phase
2, an attention-type mechanism can be used to zoom in on bits that were prone to high noise in
Phase 1. These insights suggest the following generic feedback code: it is a sequential code with
long cumulative memory but the importance of a given bit in the memory is dynamically weighted
based on the feedback.

11

SNRf =0 dB
SNRfb=noiseless

SNRf =1 dB
SNRfb=noiseless

SNRf =2 dB
SNRfb=noiseless

nk

SNRf =0 dB
SNRfb=23 dB

nk

SNRf =0 dB
SNRfb=13 dB

nk

SNRf =0 dB
SNRfb=6 dB

ck,1

ck,1

nk + wk

nk + wk

nk + wk

Figure 7: Noise in ﬁrst phase nk vs. ﬁrst parity bit ck,1 as forward SNR increases for noiseless
feedback (top) and sum of forward and feedback noises in ﬁrst phase nk + wk vs. ﬁrst parity bit ck,1
as feedback SNR decreases for ﬁxed forward SNR 0dB (bottom). Blue ‘x’ data points correspond to
those samples conditioned on bk = 1 and red ‘o’ points correspond to those samples conditioned on
bk = 0.

6 System and implementation issues

We began with the idealized Shannon model of feedback and have progressively considered practical
variants (delay, noise and active feedback). In this section we extend this progression by studying
design decisions in real-world implementations of Deepcode (our neural-network feedback-enabled
codes). We do this in the context of cellular wireless systems, with speciﬁc relevance to the upcoming
5G LTE standard.

LTE cellular standards prescribe separate uplink and downlink transmissions (usually in fre-
quency division duplex mode). Further, these transmissions are scheduled in a centralized manner
by the base station associated with the cell. In many scenarios, the traﬃc ﬂowing across uplink and
downlink could be asymmetric (example: more “downloads” than “uploads” leads to higher downlink
traﬃc than the combined uplink ones). In such cases, there could be more channel resources in the
uplink than the traﬃc demand. Given the sharp inﬂexible division among uplink and downlink,
these resources go unused. We propose to link, opportunistically, unused resources in one direction
to aid the reliability of transmission in the opposite direction – this is done via using the feedback
codes developed in this paper. Note that the availability of such unused channel resources is known
in advance to the base station which makes scheduling decisions on both directions of uplink and
downlink – thus such a synchronized cross uplink-downlink scheduling is readily possible.

The availability of the feedback traﬃc channel enables the usage of the codes designed in this
paper – leading to much stronger reliability than the feedforward codes alone. Combined with
automatic repeat request (ARQ), this leads to fewer retransmissions and smaller average transmission
time than the traditional scheme of feedforward codes combined with ARQ would achieve. In order

12

to numerically evaluate the expected beneﬁts of such a system design, in Figure 8, we plot BLER
as a function of number of (re)transmissions for Deepcode under noiseless and noisy feedback and
feedforward codes (for a rate 1/3 code with 50 information bits). From this ﬁgure, we can see
that combining Deepcode with ARQ allows fewer block transmissions to achieve the target BLER
compared to the state-of-the-art codes. The performance of Deepcode depends on the quality of the
feedback channel. As feedback channel becomes less noisy, Deepcode requires fewer retransmissions.
We note that in measuring the BLER of neural code under noisy feedback (10dB), we used a variant
of Deepcode, shown as Act-Deepcode, which allows an active feedback of rate 3/4; in Phase 1, the
decoder sends back RNN encoded bits at rate 1/2. Phase 2 works as in Deepcode. Hence, for a
rate 1/3 code with 50 information bits, the decoder makes 200 usages of the feedback channel (204
with zero padding). Improving further the performance of (active) Deepcode at realistic feedback
SNRs (such as 10dB or lower) is an important open problem. The improvements could come from
architectural or learning methodology innovations or a combination of both.

We propose using Deepcode when the feedback SNR is high. Practically, a user may not always
have a high SNR feedback channel, but when there are multiple users, it is possible that some of the
users have high SNR feedback channels. For example, in scenarios where a base station communicates
with multiple users, we propose scheduling users based on their feedback as well as forward channel
qualities, utilizing multiuser diversity. In Internet-of-Things (IoT) applications, feedback channel
SNR can be much higher than forward SNR; e.g., a small device with limited power communicates a
message to the router connected to the power source.

BLER

Number of transmissions

Figure 8: BLER as a function of number of transmissions for a rate 1/3 code with 50 information
bits where forward SNR is 0dB. Deepcode allows fewer transmissions than feedforward codes to
achieve the target BLER.

7 Conclusion

In this paper we have shown that appropriately designed and trained RNN codes (encoder and
decoder), which we call Deepcode, outperform the state-of-the-art codes by a signiﬁcant margin on
the challenging problem of communicating over AWGN channels with noisy output feedback, both
on the theoretical model and with practical considerations taken into account. By concatenating
Deepcode with a traditional outer code, the BER curve drops signiﬁcantly with increasing block
lengths, allowing generalizations of the learned neural network architectures. The encoding and
decoding capabilities of the RNN architectures suggest that new codes could be found in other open
problems in information theory (e.g., network settings), where practical codes are sorely missing.

13

Our work suggests several immediate avenues continue the research program begun by this paper,
solutions to which will have signiﬁcant practical impacts.

Learning to take advantage of the block lengths. The ﬁrst one is an interesting new challenge
for machine learning, that has not been posed before to the best of our knowledge. We proposed
concatenation in Section 4 to achieve the block-length gain. By concatenating Deepcode with a
traditional inner code, the BER curve drops signiﬁcantly with increasing block lengths, allowing
generalizations of the learned neural network architectures. However, concatenation comes at the
cost of reduced rate.

A more natural way to achieve the block-length gain is to incorporate structures of the modern
codes, in particular turbo codes. Turbo codes use inter-leavers to introduce long range dependency on
top of standard convolutional codes, achieving error rate that exponentially decays in block-lengths
as desired. In the encoder, we can easily include an inter-leaver with two neural encoders we proposed.
However, the major challenge is in decoding. Turbo decoder critically relies on BCJR decoder’s
accurate estimate of the posterior probability of each information bit. This is in turn fed into
the next phase of turbo decoder, which reﬁnes the likelihood iteratively. For the proposed neural
feedback code, there exists no decoder that can output accurate posterior likelihood. Further, there
exists no decoder that can take as part of the input the side information from the previous phase on
the prior likelihood of the information bit.

This poses an interesting challenge for deep learning. In machine learning terminology, we
consider a supervised learning setting with binary classiﬁcation, but instead of asking for accurate
classiﬁcation (as measured by average loss (1/n) (cid:80)n
i=1 (cid:96)(f (Xi), Yi)) of the example Xi to predict the
label Yi on some loss function (cid:96)(·, ·), we ask for accurate likelihood. We need an accurate estimate of
P(Yi = 1|Xi), which could be measured by (1/n) (cid:80)n
i=1 (cid:96)(f (Xi), P(Yi = 1|Xi)). This is a much more
challenging task than traditional supervised learning, which is necessitated because the supervision
we desire, i.e. P(Yi = 1|Xi), is not readily available. On the other hand, as an inﬁnite amount of
training data can be readily generated under the communication scenario, there is a hope that with
the right algorithm, the posterior probability can be predicted accurately. Such a solution will be
a signiﬁcant contribution not only to communication algorithms, but also to the broader machine
learning community.

Interpreting Deepcode. The second challenge is in using the lessons learned from the trained
Deepcode to contribute back to the communication theory. We identiﬁed in Section 5 some parts of
the parity symbols of the trained Deepcode. However, how Deepcode is able to exploit the feedback
symbols remains mysterious, despite our eﬀorts to interpret the trained neural network. It is an
interesting challenge to disentangle the neural encoder, and provide a guideline for designing simple
feedback encoders that enjoy some of the beneﬁts of the complex neural encoder. Manually designing
such simple encoders without training can provide a new family of feedback encoders that are simple
enough to be mathematically analyzed.

Rate beyond 1/3. The third challenge is to generalize Deepcode to rates beyond 1/3. Our neural
code structure can be immediately generalized to rates 1/r for r = 2, 3, 4, · · · . For example, we have
preliminary results showing that a rate-1/2 RNN based feedback code beats the state-of-the-art
codes for short block lengths (e.g., 64) under low SNRs (e.g., below 2dB). Extensive experiments
and simulations over various rates and comparison to state-of-the-art codes are yet to be explored.
On the other hand, generalization to rates higher than 1/2 requires a new architecture of encoders.
In this direction, we propose two potential approaches. One is to use a higher-order modulation
(e.g., pulse amplitude modulation) and generate parity bits for super symbols which are functions

14

of multiple information bits. The other is to use puncturing, a widely used technique to design
high rate codes from low rate codes (e.g., convolutional codes); the encoder ﬁrst generates a low
rate code and then throws away some of the coded bits and sends only a fraction of the coded bits.
Generalization to higher rate codes via these two approaches is of great practical interest.

Acknowledgement

We thank Shrinivas Kudekar and Saurabh Tavildar for helpful discussions and providing references
to the state-of-the-art feedforward codes. We thank Dina Katabi for a detailed discussion that
prompted the work on system implementation.

References

pp. 623–656, 1948.

[1] C. E. Shannon, “A mathematical theory of communication, part i, part ii,” Bell Syst. Tech. J., vol. 27,

[2] C. J. Il, J. Mayank, S. Kannan, L. Philip, and K. Sachin, “Achieving single channel, full duplex wireless
communication,” in Proceedings of the 16th Annual International Conference on Mobile Computing and
Networking, MOBICOM 2010, Chicago, Illinois, USA, September 20-24, 2010.

[3] C. Shannon, “The zero error capacity of a noisy channel,” IRE Transactions on Information Theory,

vol. 2, no. 3, pp. 8–19, 1956.

[4] J. Schalkwijk and T. Kailath, “A coding scheme for additive noise channels with feedback–i: No bandwidth

constraint,” IEEE Transactions on Information Theory, vol. 12, no. 2, pp. 172–182, 1966.

[5] J. Schalkwijk, “A coding scheme for additive noise channels with feedback–ii: Band-limited signals,”

IEEE Transactions on Information Theory, vol. 12, no. 2, pp. 183–189, April 1966.

[6] R. G. Gallager and B. Nakiboglu, “Variations on a theme by schalkwijk and kailath,” IEEE Transactions

on Information Theory, vol. 56, no. 1, pp. 6–17, Jan 2010.

[7] Z. Chance and D. J. Love, “Concatenated coding for the AWGN channel with noisy feedback,” IEEE

Transactions on Information Theory, vol. 57, no. 10, pp. 6633–6649, Oct 2011.

[8] Y.-H. Kim, A. Lapidoth, and T. Weissman, “The Gaussian channel with noisy feedback,” in Information

Theory, 2007. ISIT 2007. IEEE International Symposium on.

IEEE, 2007, pp. 1416–1420.

[9] P. Elias, “Coding for noisy channels,” in IRE Convention record, vol. 4, 1955, pp. 37–46.

[10] A. Felix, S. Cammerer, S. Dörner, J. Hoydis, and S. t. Brink, “OFDM-autoencoder for end-to-end

learning of communications systems,” arXiv preprint arXiv:1803.05815, 2018.

[11] S. Cammerer, S. Dörner, J. Hoydis, and S. ten Brink, “End-to-end learning for physical layer communica-
tions,” in The International Zurich Seminar on Information and Communication (IZS 2018) Proceedings.
ETH Zurich, 2018, pp. 51–52.

[12] T. J. O’Shea and J. Hoydis, “An introduction to deep learning for the physical layer,” arXiv preprint

[13] M. Ibnkahla, “Applications of neural networks to digital communications–a survey,” Signal processing,

arXiv:1702.00832, 2017.

vol. 80, no. 7, pp. 1185–1215, 2000.

[14] T. J. O’Shea, K. Karra, and T. C. Clancy, “Learning to communicate: Channel auto-encoders, domain
speciﬁc regularizers, and attention,” in Signal Processing and Information Technology (ISSPIT), 2016
IEEE, 2016, pp. 223–228.
IEEE International Symposium on.

15

[15] H. Kim, Y. Jiang, R. Rana, S. Kannan, S. Oh, and P. Viswanath, “Communication algorithms via
deep learning,” in The International Conference on Representation Learning (ICLR 2018) Proceedings.
Vancouver, 2018.

[16] E. Nachmani, Y. Be’ery, and D. Burshtein, “Learning to decode linear codes using deep learning,” in
IEEE,

Communication, Control, and Computing (Allerton), 2016 54th Annual Allerton Conference on.
2016, pp. 341–346.

[17] E. Nachmani, E. Marciano, L. Lugosch, W. J. Gross, D. Burshtein, and Y. Be’ery, “Deep learning
methods for improved decoding of linear codes,” IEEE Journal of Selected Topics in Signal Processing,
2018.

[18] X. Tan, W. Xu, Y. Be’ery, Z. Zhang, X. You, and C. Zhang, “Improving massive MIMO belief propagation

detector with deep neural network,” arXiv preprint arXiv:1804.01002, 2018.

[19] S. Dörner, S. Cammerer, J. Hoydis, and S. t. Brink, “Deep learning based communication over the air,”

IEEE Journal of Selected Topics in Signal Processing, vol. 12, no. 1, pp. 132–143, Feb 2018.

[20] F. A. Aoudia and J. Hoydis, “End-to-end learning of communications systems without a channel model,”

[21] N. Farsad, M. Rao, and A. Goldsmith, “Deep learning for joint source-channel coding of text,” arXiv

arXiv preprint arXiv:1804.02276, 2018.

preprint arXiv:1802.06832, 2018.

[22] M. Kim, W. Lee, and D. H. Cho, “A novel papr reduction scheme for OFDM system based on deep

learning,” IEEE Communications Letters, vol. 22, no. 3, pp. 510–513, March 2018.

[23] J. Kosaian, K. Rashmi, and S. Venkataraman, “Learning a code: Machine learning for approximate

non-linear coded computation,” arXiv preprint arXiv:1806.01259, 2018.

[24] T. M. Cover and J. A. Thomas, Elements of information theory. John Wiley & Sons, 2012.

[25] Y. Polyanskiy, H. V. Poor, and S. Verdú, “Channel coding rate in the ﬁnite blocklength regime,” IEEE

Transactions on Information Theory, vol. 56, no. 5, pp. 2307–2359, 2010.

[26] H. Huawei,

“Performance evaluation of channel codes

for control channel,”

RAN WG1 #87 Reno, U.S.A., November 14-18, 2016, vol. R1-1611257.
www.3gpp.org/ftp/tsg_ran/WG1_RL1/TSGR1_87/Docs/R1-1611257.zip

3GPP TSG-
[Online]. Available:

[27] T. Erseghe, “On the evaluation of the Polyanskiy-Poor-Verdu converse bound for ﬁnite block-length

coding in AWGN,” vol. 61, 01 2014.

[28] Y. H. Kim, A. Lapidoth, and T. Weissman, “The Gaussian channel with noisy feedback,” in 2007 IEEE

International Symposium on Information Theory, June 2007, pp. 1416–1420.

[29] T. Duman and M. Salehi, “On optimal power allocation for turbo codes,” in IEEE International

Symposium on Information Theory - Proceedings.

IEEE, 1997, p. 104.

[30] H. Qi, D. Malone, and V. Subramanian, “Does every bit need the same power? an investigation on
unequal power allocation for irregular LDPC codes,” in 2009 International Conference on Wireless
Communications Signal Processing, Nov 2009, pp. 1–5.

[31] A. Lapidoth, “Nearest neighbor decoding for additive non-Gaussian noise channels,” IEEE Transactions

on Information Theory, vol. 42, no. 5, pp. 1520–1529, Sep 1996.

[32] G. Hinton, O. Vinyals, and J. Dean, “Distilling the knowledge in a neural network,” arXiv preprint

arXiv:1503.02531, 2015.

[33] M. Rastegari, V. Ordonez, J. Redmon, and A. Farhadi, “Xnor-net: Imagenet classiﬁcation using binary
Springer, 2016, pp.

convolutional neural networks,” in European Conference on Computer Vision.
525–542.

[34] A. Ben-Yishai and O. Shayevitz, “Interactive schemes for the AWGN channel with noisy feedback,”

IEEE Transactions on Information Theory, vol. 63, no. 4, pp. 2409–2427, April 2017.

16

[35] G. D. Forney, Jr, MIT Press, Cambridge, MA., 1966.

[36] K. Miwa, N. Miki, T. Kawamura, and M. Sawahashi, “Performance of decision-directed channel estima-
tion using low-rate turbo codes for dft-precoded OFDMA,” in 2012 IEEE 75th Vehicular Technology
Conference (VTC Spring), May 2012, pp. 1–5.

17

Appendix

A State-of-the art codes used in comparison

In this section, we provide details on how to compute the BER and BLER of state-of-the art feedforward
codes. LTE turbo code used in the simulation uses trellis-([13, 15], 13) convolutional code (octal notation)
as a component code, and uses quadratic permutation polynomial (QPP) interleaver. Decoding is done by
8 iterations of Belief Propagation (BP) decoder that uses a posteriori probability (APP) decoder as the
constituent decoder. Tail-bitting convolutional codes (TBCC) used in the simulation has a constraint length
7 and trellis ([123,135,157]) (in octal notation), and uses Viterbi decoder. Polar code used in the simulation
uses success cancellation list decoding (SCL) with list size 8. LDPC code used in the simulation (Rate 1/3,
maps 64 bits to a length-196 codeword with sub-matrix dimension 16) uses the parity check matrix shown
below, and layered oﬀset min-sum decoder is used with oﬀset parameter 0.22 and (max) iteration 25.















0 −1 −1 −1 −1 −1 −1 −1
3
2
11
10
0 −1 −1 −1 −1 −1 −1
9
14
9
−1
15
0 −1 −1 −1 −1 −1
11
13 −1
5
6 −1
0 −1 −1 −1 −1
6
12 −1
8
5 −1
−1
0 −1 −1 −1
11
1 −1 −1
11 −1 −1
−1
0 −1 −1
7 −1
12 −1
14
2 −1 −1
−1
0 −1
−1
15
0
−1 −1 −1

11 −1
3 −1 −1 −1

10 −1 −1 −1 −1 −1

11 −1

7 −1















B Implementation details

In this section, we provide implementation details on the neural encoders and decoders, introduced in
Section 3, for the AWGN channels with feedback.

B.1

Illustration on Scheme A. RNN feedback encoder/decoder (RNN (linear)
and RNN (tanh)).

The details of neural encoder and decoder architectures for RNN feedback code are illustrated in Table 1 and
Figure 9. The architectures for RNN (tanh) and RNN (linear) feedback codes are equivalent except for the
activation function in RNN; RNN (tanh) encoder uses a tanh activation while RNN (linear) encoder uses a
linear activation (for both the recurrent and output activation).

Table 1: Architecture of RNN feedback encoder (left) and decoder (right) for AWGN channels with
noisy feedback.

Layer
Input
RNN (linear or tanh)
Dense (sigmoid)
Normalization

Output dimension
(K, 4)
(K, 50)
(K, 2)
(K, 2)

Layer
Input
bi-GRU
Batch Normalization
bi-GRU
Batch Normalization
Dense (sigmoid)

Output dimension
(K, 3)
(K, 100)
(K, 100)
(K, 100)
(K, 100)
(K, 1)

B.2

Illustration on Scheme B. RNN feedback code with zero padding (RNN
(tanh) + ZP).

The encoder and decoder structures with zero padding are shown in Figure 10 and Figure 11, respectively.
We maintain the encoder and decoder architecture same as Scheme A (RNN (tanh)) and simply replace the

18

Figure 9: RNN feedback encoder (left) and decoder (right)

input information bits by information bits padded by a zero; hence, we use K + 1 RNN cells in Phase 2
instead of K. In training, we use back-propagation with binary cross entropy loss as we did in Scheme A. A
slight modiﬁcation is that we measure binary crossentropy loss on the information bits of length K only (i.e.,
ignore the loss on the last bit which corresponds to a zero padding).

Figure 10: Encoder for scheme B.

Figure 11: Decoder for schemes B,C,D.

19

B.3

Illustration on Scheme C. RNN feedback code with power allocation
(RNN(tanh) + ZP + W).

The encoder and decoder architectures for scheme C are shown in Figure 12 and Figure 11, respectively.
Speciﬁcally, we introduce three trainable weights (w0, w1, w2) and let E[c2
k,2] = w2
2
for all k ∈ {1, · · · , K} where w2
k,2] = 1). In
training, we initialize wis by 1 and train the encoder and decoder jointly as we trained Schemes A and B.
The trained weights are (w1, w2, w3) = (1.13, 0.90, 0.96) (trained at -1dB). This implies that the encoder uses
more power in Phase I, to transmit (raw) information bits. In Phase II, the encoder uses more power on the
second parity bits than in the ﬁrst parity bits.

2 = 3 (c.f. in Encoder B, we let E[c2

k,1] = w2
k,1] = E[c2

0, E[c2
k] = E[c2

k] = w2

0 + w2

1 + w2

1, E[c2

Figure 12: Encoder C.

B.4 Scheme D. RNN feedback code with bit power allocation (RNN(tanh) +

ZP + W + A).

The encoder and decoder architectures for scheme D are shown in Figure 13 and Figure 11, respectively.
We introduce trainable weights a1, a2, · · · , aK, aK+1 for power allocation in each transmission. To the full
generality, we can train all these K + 1 weights. However, we let a5, · · · , aK−5 = 1 and only train ﬁrst 4
weights and the last 5 weights, a1, a2, a3, a4 and aK−4, aK−3, aK−2, aK−1, aK, aK+1, for two reasons. Firstly,
this way we can generalize the encoder to longer block lengths by maintaining the weights for ﬁrst four and
last ﬁve weights and ﬁxing the rest of weights as 1s, no matter how many rest weights we have. For example,
if we test our code for length 1000 information bits, we can let a5, · · · , c996 = 1. Secondly, the BERs of
middle bits do not depend much on the bit position; hence, power control is not needed as much as in the
ﬁrst and last few bits.

In training scheme D, we initialize the encoder and decoder as the ones in Scheme C, and then additionally
train the weight vectors a on top of the trained model, while allowing all weights in the encoder and decoder
to change as well. After training, we see that the trained weights are (a1, a2, a3, a4) = (0.87, 0.93, 0.96, 0.98)
and (aK−4, aK−3, aK−2, aK−1, aK, aK+1) = (1.009, 1.013, 1.056, 1.199, 0.935) (for −1dB trained model). As
we expected, the trained weights in the later bits are larger. Also, the weight at the K + 1th bit position
is small because last bit is always zero and does not convey any information. On the other hand, trained
weights in the beginning positions are small because these bits are naturally more robust to noise due to the
sequential structure in generation of parity bits in Phase 2.

B.5 Feedback with delay and coding

Practical feedback typically is delayed for a random time, thus the encoder cannot use immediate feedback to
encode. The feedback is randomly delayed up to block length K, we are restricted not to use feedback till K
bits are transmitted. Coding in both forward and feedback channel under noisy feedback will strengthen the
reliability of communication.

We propose an active and delayed feedback scheme to overcome noisy feedback and delaying eﬀect; the
1/3 code rate encoder is shown in Figure 14. In the ﬁrst phase, the K information bits can be encoded by
Bi-GRU, while the feedback is delayed and can only be used in the next phase. The second and third phases

20

Figure 13: Encoder D.

use uni-directional GRU to encode with K-delayed feedback, which means at index m of phase 2, the encoder
can only use the feedback before index m of phase 1. Receiver side encodes the feedback by unidirectional
GRU and sends through the delayed feedback channel back to the transmitter. The decoder is a Bi-GRU
which waits to decode until all information bits are received.

We can see from Figure 15 (Right) that passive feedback under delayed feedback still has better
performance compared to the turbo code, and beats S-K code under high SNR regimes. The delaying eﬀect is
enabled via our RNN feedback coding scheme. The gain is from: (1) adding an additional phase, which gives
the RNN more fault tolerance compared to 2-phase coding; (2) training the RNN to decode with delayed
feedback.

Figure 15 (Left) shows the performance under noisy feedback. The forward channel is under AWGN
0dB, while the x-axis shows the feedback SNR. The C-L and S-K codes fail to decode under noisy feedback
channel. Passive feedback code achieves better performance comparing to C-L and S-K code, while active
feedback code outperforms passive feedback code. The performance gain is from: (1) the coding gain of active
feedback, which gives the encoder RNN better robust representation of feedback code; (2) as the feedback is
noisy, delayed coding actually averages the noise, which leads to better performance.

Figure 14: Encoder for delayed feedback

Figure 15: Neural schemes for delay with feedback under noisy (left) and noiseless (right) feedback

21

Literature on coded feedback In [34], the authors show that active feedback can improve the reliability
under noisy feedback if the feedback SNR is suﬃciently larger than the forward SNR. Their coding scheme
assumes that the encoder and decoder share a common random i.i.d. sequence (of length equals to the coded
block length), mutually independent of the noise sequences and the message. We do not assume such a
common randomness for the encoder and decoder; hence, we cannot directly compare our scheme with theirs.

C Concatenation of neural code with existing codes

Concatenated codes are constructed from two or more codes, originally proposed by Forney [35]. We
concatenate forward error correcting codes (that do not use a feedback) with our neural code that makes
use of feedback. Encoding is performed in two steps; we ﬁrst map information bits into a turbo code, and
then encode the turbo code via an encoder for channels with feedback. Decoding is also performed in two
steps. In the ﬁrst step, the decoder recovers the estimates of turbo codes. In the second step, the decoder
recovers information bits based on the estimates of turbo codes. For the experiment in Section 4, for which
results are shown in Figure 5 (Right), we use the rate 1/3 LTE turbo code as an outer code; LTE turbo code
uses ([13, 15], 13) convolutional code (octal notation) as a component code. We compare the performance of
the concatenated code with a rate 1/9 turbo code, which uses ([13,17,16,15,11],13) convolutional code as a
component code (introduced in [36]). Besides turbo codes, any existing codes (e.g., LDPC, polar, convolutional
codes) can be used as an outer code. We also note that C-L scheme is based on the concatenation idea [7].

D Existing codes: C-L and S-K schemes

In this section, we provide an illustration of two baseline schemes, C-L scheme and S-K scheme, and the
connection between these schemes and our neural codes.

A simple scheme is to linearly encode each information bit separately using feedback. For each bit bk,
the encoder generates three coded bits (ck1, ck2, ck3). This is the Chance-Love scheme proposed in [7]. One
of the contributions of [7] is to empirically ﬁnd the optimal weights for the linear functions (there is no
closed-form solution). Another contribution is that they propose concatenating their code with an existing
forward error correction code such as turbo codes, i.e., instead of mapping the information bits b directly to
the codeword c, the encoder maps b to a turbo code d and then maps the turbo code d to a codeword c.

Figure 16: Illustration of encoding of k-th bit for a rate-1/3 linear encoder in Chance-Love scheme

Can we start with a neural architecture that includes the C-L as a special case and improve upon
it? Due to the sequential nature of feedback encoder, recurrent neural network (RNN) architectures are
natural candidates. A simple neural architecture that includes the C-L scheme as a special case is illustrated
in Figure 17. We consider various versions of RNN encoders –RNN with linear activation functions, and
nonlinear RNN, GRU, LSTM. We train the encoder and decoder jointly. For all architectures, we use 50
hidden units. The BERs of trained networks are shown in Table 2. We can see that the BER of nonlinear
RNN is smaller than that of a linear feedback scheme with weights optimized.

Although RNN has the capability to represent any linear bit-by-bit linear encoder/decoder, we can see
that the training is highly nontrivial, and for linear RNN, the neural network converges to a local optimum.

22

Figure 17: Encoding of k-th bit for a rate-1/3 RNN encoder

Scheme
Bit-by-bit linear (Shalkwijk-Kailath)
Bit-by-bit linear (Chance-Love)
Bit-by-bit linear RNN
Bit-by-bit RNN
Bit-by-bit GRU
Bit-by-bit LSTM

BER at 1dB (σ2
0.0023
7.83e-04
0.0046
1.56e-04
1.58e-04
1.88e-04

F = 0.01)

Table 2: BER of other RNN architectures. Rate 1/3

On the other hand, for nonlinear RNNs, the trained encoder performs better than the weight-optimized linear
scheme.

From coding theory, we know that the bit error rate should go down as block length gets longer. If
we use bit-by-bit encoding, the improvement can never be realized because BER remains the same now
matter how long the block is. In order to enable the bit error to decay faster as block length increases, the
encoder has to code information bits jointly. A celebrated feedback coding scheme, Shalkwijk–Kailath scheme,
simpliﬁed/illustrated in Figure 18, belongs to this category.

Figure 18: Illustration of S-K encoder

S-K scheme. Here all information bits are used only to generate the ﬁrst codeword. The rest of the
codewords depend only on the feedback (noise added to the previous transmission). Although S-K scheme
does encode all information bits jointly, transmitting all information bits in the ﬁrst phase requires a high
numerical precision as block length increases. For example, for 50 information bits, the transmitter transmits
(cid:80)K

k=1 bk2k (with a power normalization and subtracting a constant to set mean to be 0).

Our approach is diﬀerent from S-K scheme in that we aim to use the memory of RNN to design an
encoder that encodes the information bits jointly. Since RNN has a memory in it, naturally it allows encoding
bits jointly. The challenge is whether we can ﬁnd/train a neural network encoder which makes use of the
RNN memory. For example, Figure 19 illustrates a somewhat natural architecture we attempted. However,
after training, the BER performance is only as good as the BER of bit-by-bit encoding, which means that
the memory in the RNN is not being successfully used to jointly encode the information bits.

23

Figure 19: Bit-coupled RNN encoder

E Robustness under bursty Gaussian channels

Bursty Gaussian channel is a channel where there is a background Gaussian noise n1i, and occasionally, with
a small probability α, a Gaussian noise with high power (bursty noise, n2i) is added on top of the background
noise. Mathematically, we consider the following bursty Gaussian channel: yi = xi + ni, where

ni = n1i + ein2i,
n1i ∼ N (0, σ2

o), n2i ∼ N (0, σ2

1), ei ∼ Bern(α).

We test the robustness of our feedback code under bursty Gaussian channel. Figure 20 shows the BER
as a function of α (probability of having a burst noise), for −1dB, and two diﬀerent power of burst noise. We
0 = σ2 (i.e., we keep the total power of the noise). As we can see from the ﬁgure,
choose σ2
as α increases, the BER decreases, showing that the bit error rate is smaller for more bursty noise channels.

0 so that ασ2

1 + σ2

BER

Probability of burst noise (α)

Figure 20: Neural feedback code is robust to bursty noise.

24

