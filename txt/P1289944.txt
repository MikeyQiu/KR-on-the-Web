Addressee and Response Selection for Multilingual Conversation

Motoki Sato1∗

Hiroki Ouchi2,3
1Preferred Networks, Inc.,
2RIKEN Center for Advanced Intelligence Project
3Tohoku University
sato@preferred.jp, hiroki.ouchi@riken.jp, tsuboi@preferred.jp

Yuta Tsuboi1∗

Abstract

Developing conversational systems that can converse in many languages is an interesting chal-
lenge for natural language processing. In this paper, we introduce multilingual addressee and
response selection. In this task, a conversational system predicts an appropriate addressee and
response for an input message in multiple languages. A key to developing such multilingual re-
sponding systems is how to utilize high-resource language data to compensate for low-resource
language data. We present several knowledge transfer methods for conversational systems. To
evaluate our methods, we create a new multilingual conversation dataset. Experiments on the
dataset demonstrate the effectiveness of our methods.

1

Introduction

Open-domain conversational systems, such as chatbots, are attracting a vast amount of interest and play
their functional and entertainment roles in real-world applications. Recent conversational models are
often built in an end-to-end fashion using neural networks, which require a large amount of training data
(Vinyals and Le, 2015; Serban et al., 2016). However, it is challenging to collect enough data to build
such models for many languages. Consequently, most work has targeted high-resource languages, such
as English and Chinese (Shang et al., 2015; Serban et al., 2016).

In this work, we aim to develop multilingual conversational systems that can return appropriate re-
sponses in many languages. Speciﬁcally, we assume the two types of systems: (i) language-speciﬁc
systems and (ii) language-invariant systems. A language-speciﬁc system consists of multiple conver-
sational models, each of which returns responses in a corresponding language. By contrast, a language-
invariant system consists of a single uniﬁed model, which returns responses in all target languages. A
key to building these multilingual models is how to utilize high-resource language data to compensate for
low-resource language data. We present several knowledge-transfer methods. To the best of our knowl-
edge, this is the ﬁrst work focusing on low-resource language enablement of conversational systems.

One challenge when developing conversational systems is how to evaluate the system performance.
For generation-based conversational systems, which generate each word for a response one by one,
many studies adopt human judgments. However, it is costly and impractical to adopt this evaluation
method for multilingual systems, especially for minor-language systems. Thus, as a ﬁrst step, we develop
retrieval-based conversational systems and evaluate the ability to select appropriate responses from a set
of candidates.

Fig. 1 shows the overview of our multilingual responding systems.
This paper provides: (i) formal task deﬁnitions, (ii) several knowledge-transfer methods and (iii)
a multilingual conversation dataset. First, we introduce and formalize the two task settings: single-
language adaptation for language-speciﬁc systems and multi-language adaptation for language-invariant
systems (Sec. 4).

∗This work was conducted when the ﬁrst author worked at Nara Institute of Science and Technology, and portions of this

research were done while the third author was at IBM Research - Tokyo.

This work is licensed under a Creative Commons Attribution 4.0 International License. License details: http://

creativecommons.org/licenses/by/4.0/.

8
1
0
2
 
g
u
A
 
2
1
 
 
]
L
C
.
s
c
[
 
 
1
v
5
1
9
3
0
.
8
0
8
1
:
v
i
X
r
a

Figure 1: Example of multilingual response selection.

Second, we present several methods leveraging high-resource language data to compensate for low-
resource language in the two settings (Sec. 5). Our basic method uses multilingual word embeddings and
transfers source-language knowledge to target languages (Sec. 5.1 (a)). We also design three extended
methods. Among them, the ﬁne-tuning method builds a model speciﬁc to a single target language (Sec.
5.2 (b)). The joint loss training and the multi-language adversarial training methods build a uniﬁed model
invariant for multiple target languages (Sec. 5.2 (c) and (d)).

Third, we create a multilingual conversation corpus and dataset1 (Sec. 6).
From the Ubuntu IRC Logs2, we collect the logs in 12 languages.
To show benchmark results, we perform experiments on the created dataset (Sec. 7). The results

demonstrate that our methods allow models to effectively adapt to low-resource target languages.

In particular, our method using Wasserstein GAN (Arjovsky et al., 2017) achieves high-performance

for simultaneously dealing with multiple languages with a single uniﬁed model.

2 Related Work

Short Text Conversation

In short text conversation, a system predicts an appropriate response for an input message in single-turn,
two-party conversation (Ritter et al., 2011). One major approach to it is the generation-based approach,
which generates a response using a sequence-to-sequence model (Shang et al., 2015; Vinyals and Le,
2015; Serban et al., 2016; Li et al., 2016; Mei et al., 2017). Another popular approach is the retrieval-
based approach, which retrieves candidate responses from a repository and returns the highest scoring
one using a ranking model (Wang et al., 2013; Lu and Li, 2013; Ji et al., 2014; Wang et al., 2015). Lowe
et al. (2015) proposed next utterance classiﬁcation (NUC), in which a model has to select an appropriate
response from a ﬁxed set of candidates.

Evaluation for Conversational Systems

Evaluation methods for conversational systems are an open question (Lowe et al., 2015; Liu et al., 2016;
Lowe et al., 2017).

While many of previous studies on conversational systems used human judgements, automatic evalu-
ation methods are attractive because it is much easier and less costly to use. However, according to Liu
et al. (2016), for generation-based systems, automatic evaluation metrics, such as BLEU (Papineni et al.,
2002), correlate very weakly with human judgements.

For retrieval-based systems, some studies used ranking-based metrics, such as mean average precision
and accuracy (Ji et al., 2014; Wang et al., 2015). Lowe et al. (2016) conﬁrmed the feasibility of NUC
as a surrogate task for building conversational systems. Although there are controversial issues for these

1Our code and dataset are publicly available at https://github.com/aonotas/multilingual_ASR
2http://irclogs.ubuntu.com/

evaluation methods (Lowe et al., 2015), as a practical choice, we adopt the accuracy-based metric for
evaluating multilingual conversational systems.

Addressee and Response Selection

NUC focuses on two-party, multi-turn conversation. As an extension of it, Ouchi and Tsuboi (2016)
proposed addressee and response selection (ARS) for multi-party conversation. ARS integrates the ad-
dressee detection problem, which has been regarded as a problematic issue in multi-party conversation
(Traum, 2003; Jovanovi´c and Akker, 2004; Bohus and Horvitz, 2011; Uthus and Aha, 2013). Mainly,
this problem has been tackled in spoken/multimodal dialog systems (Jovanovi´c et al., 2006; Akker and
Traum, 2009; Nakano et al., 2013; Ravuri and Stolcke, 2014). While these systems largely rely on acous-
tic signal or gaze information, ARS focuses on text-based conversations. Extending these studies, we
tackle multilingual, multi-turn, and multi-party text conversation settings.

Cross-Lingual Conversation

The motivation of our task is similar with that of Kim et al. (2016). They tackled cross-lingual dialog
state tracking in English and Chinese. While they transfer knowledge from English to Chinese, we
transfer knowledge between a high-resource and several low-resource languages.

3 Addressee and Response Selection

Addressee and response selection (ARS)3, proposed by Ouchi and Tsuboi (2016), assumes the situation
where a responding agent returns a response to an addressee following a conversational context.

Formally, given an input conversational situation x ∈ X, a system predicts y ∈ Y , which consists of

an addressee a and a response r:

GIVEN : x = (ares, C, R),

PREDICT : y = (a, r)

where ares is a responding agent, C is a context (a sequence of previous utterances) and R is a set of
candidate responses. To predict an addressee a, we select an agent from a set of the agents appearing
in a context A(C). To predict a response r, we select a response from a set of candidate responses
R = {r1, · · · , r|R|}.

This task evaluates accuracy on the three aspects: addressee-response pair selection (ADR-RES), ad-
dressee selection (ADR), and response selection (RES). In ADR-RES, we regard the answer as correct if
both the addressee and response are correctly selected. In ADR/RES, we regard the answer as correct if
the addressee/response is correctly selected.

4 Multilingual Addressee and Response Selection

As an extension of monolingual ARS, we propose multilingual addressee and response selection (M-
ARS). In ARS, a system is given as input a set of candidate responses and a conversational context in
a single language. By contrast, in M-ARS, a system receives the inputs in one of multiple languages.
In the following, we ﬁrst explain our motivation for tackling M-ARS and then describe the formal task
deﬁnitions.

4.1 Motivative Situations

We assume the two multilingual conversational situations:

• You want to build language-speciﬁc systems, each of which responds in a single language.

• You want to build one language-invariant system, which responds in multiple languages.

The ﬁrst situation is that we build K models, each of which is specialized for one of K target languages.
The second one is that we build one uniﬁed model that can deal with all K target languages. Taking these
situations into account, we present the corresponding two tasks: (i) single-language adaptation and (ii)
multi-language adaptation.

3Due to the space limitation, we give a brief overview of ARS. For the complete task deﬁnition, please refer to Ouchi and

Tsuboi (2016).

4.2 Task Overview

The goal of single-language adaptation is to develop and evaluate a language-speciﬁc ARS model for a
single target language. For example, using English, German and Italian training data, we build a model
specialized for German conversation. The goal of multi-language adaptation is to develop and evaluate
a language-invariant ARS model for multiple target languages. For example, using English, German and
Italian training data, we build a model that can respond to not only German but also Italian and English
conversation. In the following subsections, we formalize each of these tasks.

4.3 Formal Task Deﬁnition

We assume that we have conversation data in each of a set of languages K.

Training
In the training phase, a training dataset is given for each language k ∈ K:

train = { x(k)
D(k)
Dtrain =

(cid:91)

i
D(k)
train

, y(k)
i

k

}N (k)
i=1 , k ∈ K

where x(k) and y(k) are a conversational situation and the target output in language k, respectively. We
train a model F : X → Y on these training samples.

Evaluation
In single-language adaptation, we evaluate a trained model for a single target language t ∈ K. The
trained model receives an input of the target language, x(t) ∼ D(t)
eval, and predicts ˆy(t). As evaluation
metrics, we use the three accuracies (ADR-RES, ADR and RES) used in ARS (Sec. 3).

In multi-language adaptation, given evaluation datasets for all the languages K, i.e., (cid:83)

trained model receives an input of each language x(k) ∼ D(k)
we use macro average over all the languages: ADR-RES =
computed in the same way.

eval, the
eval and predicts ˆy(k). As evaluation metrics,
. ADR and RES are also

k ADR-RES(k)
|K|

(cid:80)

k D(k)

5 Methods

In this section, we ﬁrstly describe a model used for addressee and response selection, and then explain
our proposed methods to train parameters of the model.

Our model F consists of a feature extractor f E, addressee scoring function f A and response scoring

function f R. f A and f R return relevance scores (probabilities) for an addressee and response:

f A(x, ai) = σ([ares, hc]T Wa ai)
f R(x, rj) = σ([ares, hc]T Wr rj)

(1)

(2)

where ares is a responding agent vector, hc is a conversational context vector, ai is an agent vector, and
rj is a candidate response vector. All these vectors are encoded by the feature extractor f E. We use the
dynamic model (Ouchi and Tsuboi, 2016) as f E. Fig. 2 shows the overview of the dynamic model. This
model represents each agent as a hidden state vector that dynamically changes along with time steps in
GRU (Cho et al., 2014). 4

A model F is parameterized by θ = {θE ∪ {Wa, Wr}}, where θE is parameters of f E. To train
these parameters, we present four methods. These methods assume that we have training sets for a set of
languages K: some of them are high-resource languages S ⊆ K and others are relatively low-resource
languages T = ¯S.

Figure 3: Overview of our W-GAN training method
for multiple target languages.

Figure 2: Overview of Dynamic Model.

5.1 A Basic Method

(a) Multilingual Embedding Replacement

This method trains a model F on high-resource language data D(s)
train, where s ∈ S, and uses the trained
model for responding conversations in other languages ¯S. To realize this transfer, we use multilingual
embeddings.

Consider the case where the high-resource language is English (En) and low-resource language is
German (De). In the training phase, we use English word embeddings to train model parameters.5 In
the testing phase, instead of the English embeddings, we use German embeddings:

Train: w = W(En)

emb w

Test: w = W(De)

emb w

where w is a one-hot vector. We just replace the English word embeddings W(En)
emb with the German
ones W(De)
emb. After looking up each word embedding w, the neural model computes the hidden states.
One advantage of this method is to require no target language data. As multilingual embeddings, we use
MultiCCA6 proposed by Ammar et al. (2016). In these embeddings, semantically similar words in the
same language or translationally equivalent words in different languages are projected onto nearby.

Besides multilingual embeddings, another option to build a conversational model without no conver-
sation data in a target language is to translate high-resource language data to low-resource one and train
a conversational model on the translations. One limitation of this approach is that it is costly to prepare
parallel corpora for building the translation model. We discuss this approach in Sec. 7.3.

5.2 Extended Methods

We present the two types of methods which use target language data for building (i) language-speciﬁc
models and (ii) language-invariant models.

5.2.1 Methods for Language-Speciﬁc Models

(b) Fine-Tuning with Target Language Data

To compensate for the lack of the low-resource language data, this method ﬁrstly trains a model Fθ on
high-resource language data (pre-training phase). Then, using the pre-trained parameters θ as the initial
values, this method re-trains them on low-resource language data (ﬁne-tuning phase). We can expect that
by gaining the better initial parameters, the tuning effectively adapts the model to the target language.

4In this example, a responding agent vector ares is a3. Note that the states of the agents that are not speaking at the time are

updated by zero vectors.

5The embeddings are ﬁxed, not ﬁne-tuned, during training.
6The pre-trained MultiCCA embeddings are provided at http://128.2.220.95/multilingual/data/

5.2.2 Methods for Language-Invariant Models
In order to build language-invariant models, it is critical to consider the two perspectives: (i) avoid-
ing catastrophic forgetting and (ii) learning language-invariant features. Catastrophic forgetting (Kirk-
patrick et al., 2017) is the phenomenon that a model forgets knowledge of previously trained tasks (lan-
guages) by incorporating knowledge of the current task (language). Language-invariant features are the
features that are common and unchanged in different languages. Taking these two perspectives into
account, we present the following two methods.

(c) Joint Loss Training

This method aims to avoid catastrophic forgetting by jointly training model parameters on all the lan-
guage data at a time. Assuming that we have a set of languages K, this method uses the joint loss
function: Jjoint(θ) = (cid:80)
k J (D(k), θ) where the loss function J is the cross-entropy loss used in Ouchi
and Tsuboi (2016).

(d) Multi-Language Adversarial Training

To learn language-invariant features, we use a framework of Wasserstein-GAN (W-GAN) (Arjovsky et
al., 2017), a recently proposed technique to improve stability for generative adversarial nets (GANs)
(Goodfellow et al., 2014). The aim of this method is to match the distributions of feature representations
in two languages.

Fig. 3 illustrates an example. English is the high-resource language s ∈ S, and German and Croatian
are low-resource languages t ∈ T . For each language, the feature extractor f E receives an input con-
versation x and computes the hidden features h = f E(x)7. Thus, by using f E, we obtain the hidden
feature h(s) and h(t) for English and the others, respectively.

A pair of the high- and low-resource language features h(s) and h(t) is given to a critic gπ to minimize

the Wasserstein distance between the distributions p(h(s)) and p(h(t)):

W( p(h(s)), p(h(t)) ) = max

h(s)∼p(h(s))[gπ(h(s))] − E
E

h(t)∼p(h(t))[gπ(h(t))]

(3)

π

where the maximum is taken over the set of all 1-Lipschitz functions gπ.8 By maximizing this equation,
the distributions of the feature representations, p(h(s)) and p(h(t)), are made as close as possible. In this
paper, as the critic gπ, we use multi-layer perceptron.

Eq. 3 is designed for the two distributions. Thus, we generalize this W-GAN equation to deal with |S|

high-resource languages and |T | low-resource languages:

Jwgan(θ) =

W( p(h(k)), p(h((cid:96))) )

(cid:88)

(cid:88)

s∈S

t∈T

This loss function Jwgan is integrated with the joint loss: Jadv(θ) = Jjoint(θ) + λ Jwgan(θ) where λ is a
hyper-parameter that balances these loss functions and we used λ = 0.5.

6 Corpus and Dataset

One of our goals is to provide a multilingual conversation corpus/dataset that can be used over a wide
range of conversation research. We follow the corpus and data creation method of Ouchi and Tsuboi
(2016). First, we crawl the Ubuntu IRC Logs9, and preprocess the logs in many languages. Each lan-
guage is identiﬁed by using a language detection library (Nakatani, 2010). The resulting corpus consists
of multilingual conversations in 12 languages, shown in Tab. 1.

Then, we create an M-ARS dataset. For each language, we set the ground-truth/false addressees and
responses following Ouchi and Tsuboi (2016). Note that the addressed usernames in utterances have been

7Hidden feature representation h is the concatenation of the responding speaker vector and context vector in Eqs. 1 and 2,

i.e. h = [ares, hc].

8A function g is 1-Lipschitz when |g(x) − g(y)| ≤ |x − y| for all x and y. To constrain the critic g to a 1-Lipschitz function,

the parameters of g are clipped to a ﬁxed range.

9We use a collection of the logs during one year (2015). We plan to expand it by collecting the logs over all the years.

Language

English (en)
Italian (it)
Croatian (hr)
German (de)
Portuguese (pt)
Slovenian (sl)
Polish(pl)
Dutch (nl)
Spanish (es)
Swedish (sv)
Russian (ru)
French (fr)

Corpus
Docs Utters Words

7355
357
254
248
211
179
67
57
36
26
5
3

2.4 M 27.0 M
1.1 M
165 k
630 k
80 k
335 k
38 k
285 k
52 k
357 k
59 k
51 k
8.8 k
75 k
7.2 k
49 k
7.1 k
6.8 k
1.7 k
1.5 k
0.3 k
3.0 k
0.5 k

Table 1: Statistics of M-ARS corpus.

Language

English (en)
Italian (it)
Croatian (hr)
German (de)
Portuguese (pt)

Dataset
Train

665.6 k
38,511
11,387
5,500
5,951

Dev

Test

45.1 k
2,561
512
354
285

51.9 k
3,873
1,145
569
975

Table 2: Statistics of the M-ARS dataset.

Setting

Method

ADR-RES

RES

ADR-RES

|R| = 2
ADR

|R| = 10
ADR

Single Language Adaptation

Two Language Adaptation

Five Language Adaptation

CHANCE
TF-IDF
TRGONLY
ENONLY
FINETUNE
JOINT
WGAN

CHANCE
TF-IDF
ENONLY
FINETUNE
JOINT
WGAN

TF-IDF
ENONLY
JOINT
WGAN

3.97
39.51
47.35
38.07
49.58
51.55
53.17

2.30
38.32
46.77
50.98
53.37
54.14

39.04
41.55
50.69
52.11

7.94
64.97
69.27
65.72
69.59
70.30
70.99

4.59
60.29
67.62
68.79
69.75
70.07

63.10
66.48
69.00
69.74

50.00
60.61
67.35
57.65
69.84
71.88
73.25

50.00
64.25
67.90
72.60
74.94
75.63

62.06
61.75
72.18
73.34

0.80
12.54
19.42
8.50
21.15
22.32
23.34

0.46
13.99
19.88
24.30
26.60
27.23

13.12
13.05
22.80
23.39

RES

10.00
18.50
26.13
13.75
28.15
29.38
30.39

10.00
23.84
27.83
32.96
35.59
36.11

20.64
19.38
31.11
31.88

7.94
64.97
69.73
62.38
70.33
70.36
70.20

4.59
60.29
65.86
68.89
69.75
69.76

63.10
63.77
69.18
69.35

Table 3: Results for Single-/Two-/Five- language adaptation. Each number represents accuracy on
addressee-response selection (ADR-RES), addressee selection (ADR) or response selection (RES).

removed for addressee selection. Thus, we have to predict the addressees without seeing the addressed
usernames. The number of candidate responses (|R|) is set to 2 or 10. The dataset is then randomly
partitioned into a training set (90%), a development set (5%) and a test set (5%). Tab. 2 shows the
statistics of the top 5 largest language sections of this resulting dataset.

7 Experiments

7.1 Experimental Setup

7.1.1 Task Settings
We use the following languages: (i) English (En) as the high-resource language, and (ii) Italian (It),
Croatian (Hr), German (De), Portuguese (Pt) as the low-resource languages.
In the following, we
describe the languages used in each task.

(a) Single-Language Adaptation

Train: English + 1 Low-Res. Language,

Dev & Test: 1 Low-Res. Language

For example, in the case that the target is Italian (It), we use the En and It training sets to train a
model, and evaluate the trained model on the It test set. As evaluation metrics, we use the three types

of accuracies, ADR-RES, ARD and RES (described in Sec. 3). We report the macro average accuracies
of all source-target language pairs (En-It, En-Hr, En-De, and En-Pt).

(b) Multi-Language Adaptation

Train: English + |T | Low-Res. Languages, Dev & Test: English + |T | Low-Res. Languages

We use the En, It, Hr, Pt and De training sets to train a uniﬁed model, and evaluate it on the test
sets for all the languages (En, It, Hr, Pt, De). As evaluation metrics, we use the macro averages of
ADR-RES, ARD and RES for all the languages. For example, for two language adaptation (|T | = 1),
we report the macro averages over all the language pairs (En-It, En-Hr, En-De, and En-Pt). For ﬁve
language adaptation (|T | = 4), we report the macro averages over all the ﬁve languages. Note that while
we evaluate the performance on only the test set of the target low-resource language in single-language
adaptation, we evaluate it on the test sets of English and the low-resource languages in multi-language
adaptation.

7.1.2 Comparative Methods

We compare several methods. Our proposed methods (Sec. 5) are orthogonal, so that we can combine a
method with others. In the following, we list the methods used in the comparison.

• TRGONLY: A dynamic model proposed by Ouchi and Tsuboi (2016) trained on only the low-

resource target language data.

• ENONLY: A model built by (a) multilingual embedding replacement in Sec. 5.1: training a model
on the English data and replacing the English word embeddings with the embeddings of the low-
resource language.

• FINETUNE: A model built by (b) ﬁne-tuning in Sec. 5.2: training a model on the high-resource

language (English), and retraining it on the low-resource language.

• JOINT: A model built by (b) ﬁne-tuning and (c) joint loss training: building a model by FINETUNE

as an initial model, and retraining it with the joint loss functions.

• WGAN: A model built by (b) ﬁne-tuning and (d) multi-language adversarial training: building a

model by FINETUNE as an initial model, and retraining it with W-GAN.

Besides the neural models, we also use the TF-IDF model used in Ouchi and Tsuboi (2016). This model
ﬁrstly creates TF-IDF vectors for the context and each candidate response. Then, it computes the cosine
similarity for each pair of the context vector and a response vector. Finally, it selects the candidate
response with the highest similarity.

We use stochastic gradient descent (SGD) with a mini-batch method. To update parameters, we use
Adam (Kingma and Ba, 2014). We describe the details of hyper-parameter settings in Supplementary
Material.

7.1.3 Optimization

7.2 Results

Tab. 3 shows the results of single-language and multi-language adaptation. Note that Tab. 6, Tab. 7, and
Tab. 8 shows the detailed results for each language.

Single-Language Adaptation

WGAN achieved the best scores for most of the metrics. This suggests that the W-GAN method suc-
cessfully transfers knowledge of high-resource language to a low-resource language. Also, FINETUNE
outperformed TRGONLY. This means that pre-training parameters on the high-resource language data
improves a model for a target low-resource language. Interestingly, ENONLY achieved higher scores than
chance-level without any target language data. One possible explanation is that the multilingual embed-
dings have good alignments to some extent between similar meaning words in different languages.

Figure 4: Effects of data augmentation with NMT.

Figure 5: Effects of the number of agents in the context. Left
axis: ADR-RES accuracy on test sets (drawn as lines). Right
axis: the average number of test samples (drawn as bars).

Multi-Language Adaptation
In both two- and ﬁve-language adaptation, WGAN achieved the best scores. Speciﬁcally, In ﬁve language
adaptation, regardless of using a single, uniﬁed model, JOINT and WGAN achieved high-performance.10
Also, WGAN outperformed JOINT in all the metrics. This suggests that WGAN learns language-

invariant features more effectively.

In NLP tasks, Chen et al. (2016) applied W-GAN to cross-lingual sentiment classiﬁcation and suc-
cessfully transferred the source-side knowledge to the target one. In this paper, we have extended the
adaptation of single source-target pair to the adaptation of multiple pairs. Our experimental results show
that our method works well for multi-language adaptation in conversation domain.

7.3 Data Augmentation with NMT

As we mentioned in Sec. 5.1 (a), as another approach to compensating for low-resource language, we use
data augmentation. To increase the amount of the training set of a low-resource language, we translate
high-resource language (English) samples to low-resource ones by using Neural Machine Translation
(NMT). Although some translations are noisy, we can obtain much more training samples for a low-
resource language. One limitation of this method is that it is costly to prepare parallel corpora, which
is often unavailable for low-resource languages. For reproducibility, we use publicly available NMT
models already trained on a parallel corpus. Since OpenNMT11 provides an English-German model, we
conduct experiments for the English-German pair.

We investigate the effects of translated German data for pre-training a model. Translating English
(En) training utterances to German (De) ones by using the trained NMT model, we can obtain translated
German training data (De’). We compare the two settings: (i) pre-training a model on English data and
(ii) pre-training a model on translated German data. After pre-training, we apply the methods used in
Sec. 7. We evaluate the performance with ADR-RES accuracy on the German test set.

Fig. 4 shows the results (|R| = 10). The red dotted line is the performance of the modes trained on
only original German training data (De). In each method, the blue bar at left hand is a model pre-trained
on English (En), and the green bar at right hand is a model pre-trained on (De’).

PRETRAINONLY, the left-most method in Fig.4, uses the pre-trained models. The results were almost
the same between models pre-trained on English or translated German data, and worse than the model
trained on only the original German training data (red dotted line). This suggests that only the translations
by NMT are not sufﬁcient for building good multilingual ARS models.

Furthermore, we re-train the pre-trained models by using the three methods, FINETUNE, JOINT and
WGAN. In other words, each method uses a pre-trained model as the initial model and re-trains the pa-
rameters. In all methods, the models re-trained from the De’ pre-trained model (green bars) were better

10Since FINETUNE builds a model for each target language, it cannot analyze multiple languages with a single model. That

is why there is no result of FINETUNE in ﬁve-language adaptation.

11http://opennmt.net/Models/

than the ones from the En pre-trained ones (blue bars). This suggests that by combining the NMT-based
data augmentation method with the knowledge-transfer methods, the performance is boosted. Another
point is that WGAN consistently outperformed the other methods, which supports the utility of WGAN.

7.4 Analysis of Number of Agents

We investigate how accuracy ﬂuctuates according to the number of agents in the context of length 15, as
shown in Fig. 5. Overall, as the number of agents increases, the accuracies of all the methods tend to
decline. Among them, WGAN achieved the best results in most of the cases. This suggests that WGAN
can stably predicts addressees and responses in conversations with many participants.

8 Conclusion and Future Work

We have introduced multilingual addressee and response selection by providing (i) formal task deﬁni-
tions, (ii) several knowledge-transfer methods and (iii) a multilingual conversation corpus and dataset.

Experimental results have demonstrated that our methods allow models to adapt multiple target lan-
In particular, methods for language-invariant models can simultaneously deal with multiple

guages.
languages with a single model.

Since our methods and dataset can apply to response generation, tackling the multilingual response
generation tasks is an interesting line of our future work. In addition, our language-invariant systems
can receive conversation in a language (e.g., English ) and reply to it in another language (e.g., German).
It can lead to interesting ﬁndings that our system is evaluated on code-mixing situations, where two or
more languages are used in the same context.

References

[Akker and Traum2009] Rieks Akker and David Traum. 2009. A comparison of addressee detection methods for

multiparty conversations. In Workshop on the Semantics and Pragmatics of Dialogue.

[Ammar et al.2016] Waleed Ammar, George Mulcaire, Yulia Tsvetkov, Guillaume Lample, Chris Dyer, and

Noah A. Smith. 2016. Massively multilingual word embeddings. CoRR.

[Arjovsky et al.2017] Martin Arjovsky, Soumith Chintala, and L´eon Bottou. 2017. Wasserstein gan. arXiv preprint

arXiv:1701.07875.

[Bohus and Horvitz2011] Dan Bohus and Eric Horvitz. 2011. Multiparty turn taking in situated dialog: Study,
In Proceedings of the SIGDIAL 2011 Conference, SIGDIAL ’11, pages 98–109,

lessons, and directions.
Stroudsburg, PA, USA. Association for Computational Linguistics.

[Chen et al.2016] Xilun Chen, Yu Sun, Ben Athiwaratkun, Claire Cardie, and Kilian Weinberger. 2016. Adversar-

ial deep averaging networks for cross-lingual sentiment classiﬁcation.

[Cho et al.2014] Kyunghyun Cho, Bart van Merrienboer, aglar G¨ulehre, Dzmitry Bahdanau, Fethi Bougares, Hol-
ger Schwenk, and Yoshua Bengio. 2014. Learning phrase representations using rnn encoder-decoder for statis-
tical machine translation. In EMNLP.

[Goodfellow et al.2014] Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil
Ozair, Aaron Courville, and Yoshua Bengio. 2014. Generative adversarial nets. In Proceedings of NIPS, pages
2672–2680.

[Ji et al.2014] Zongcheng Ji, Zhengdong Lu, and Hang Li. 2014. An information retrieval approach to short text

conversation. arXiv preprint arXiv: 1408.6988.

[Jovanovi´c and Akker2004] Natasa Jovanovi´c and op den Rieks Akker. 2004. Towards automatic addressee iden-

tiﬁcation in multi-party dialogues. In Proceedings of SIGDIAL.

[Jovanovi´c et al.2006] Natasa Jovanovi´c, op den Rieks Akker, and Anton Nijholt. 2006. Addressee identiﬁcation

in face-to-face meetings. In Proceedings of EACL.

[Kim et al.2016] Seokhwan Kim, Luis Fernando D’Haro, Rafael E Banchs, Jason D Williams, Matthew Henderson,
and Koichiro Yoshino. 2016. The ﬁfth dialog state tracking challenge. In Proceeding of Spoken Language
Technology Workshop (SLT), pages 511–517.

[Kingma and Ba2014] Diederik P. Kingma and Jimmy Lei Ba. 2014. Adam: A method for stochastic optimization.

arXiv preprint arXiv: 1412.6980.

[Kirkpatrick et al.2017] James Kirkpatrick, Razvan Pascanu, Neil Rabinowitz, Joel Veness, Guillaume Desjardins,
Andrei A Rusu, Kieran Milan, John Quan, Tiago Ramalho, Agnieszka Grabska-Barwinska, et al. 2017. Over-
coming catastrophic forgetting in neural networks. Proceedings of the National Academy of Sciences of the
United States of America, pages 3521–3526.

[Li et al.2016] Jiwei Li, Michel Galley, Chris Brockett, Jianfeng Gao, and Bill Dolan. 2016. A persona-based

neural conversation model. In Proceedings of ACL.

[Liu et al.2016] Chia-Wei Liu, Ryan Lowe, Iulian Serban, Mike Noseworthy, Laurent Charlin, and Joelle Pineau.
2016. How not to evaluate your dialogue system: An empirical study of unsupervised evaluation metrics for
dialogue response generation. In Proceedings of EMNLP, pages 2122–2132.

[Lowe et al.2015] Ryan Lowe, Nissan Pow, Iulian V. Serban, and Joelle Pineau. 2015. The ubuntu dialogue
corpus: A large dataset for research in unstructured multi-turn dialogue systems. In Proceedings of SIGDIAL,
pages 285–294.

[Lowe et al.2016] Ryan Lowe, Iulian Vlad Serban, Michael Noseworthy, Laurent Charlin, and Joelle Pineau. 2016.
On the evaluation of dialogue systems with next utterance classiﬁcation. In Proceedings of the 17th Annual
Meeting of the Special Interest Group on Discourse and Dialogue, pages 264–269, Los Angeles, September.
Association for Computational Linguistics.

[Lowe et al.2017] Ryan Lowe, Michael Noseworthy, Iulian Vlad Serban, Nicolas Angelard-Gontier, Yoshua Ben-
gio, and Joelle Pineau. 2017. Towards an automatic turing test: Learning to evaluate dialogue responses. In
Proceedings of ACL, pages 1116–1126.

[Lu and Li2013] Zhengdong Lu and Hang Li. 2013. A deep architecture for matching short texts. In Proceedings

of NIPS, pages 1367–1375.

[Mei et al.2017] Hongyuan Mei, Mohit Bansal, and Matthew R Walter. 2017. Coherent dialogue with attention-

based language models. In Proceedings of AAAI.

[Nakano et al.2013] Yukiko I. Nakano, Naoya Baba, Hung-Hsuan Huang, and Yuki Hayashi. 2013. Implementa-
tion and evaluation of a multimodal addressee identiﬁcation mechanism for multiparty conversation systems. In
Proceedings of the 15th ACM on International Conference on Multimodal Interaction, ICMI ’13, pages 35–42,
New York, NY, USA. ACM.

[Nakatani2010] Shuyo Nakatani. 2010. Language detection library for java.

[Ouchi and Tsuboi2016] Hiroki Ouchi and Yuta Tsuboi. 2016. Addressee and response selection for multi-party

conversation. In Proceedings of EMNLP, pages 2133–2143.

[Papineni et al.2002] Kishore Papineni, Salim E. Roucos, Todd Ward, and Wei-Jing Zhu. 2002. Bleu: a method

for automatic evaluation of machine translation. In ACL.

[Ravuri and Stolcke2014] Suman V Ravuri and Andreas Stolcke. 2014. Neural network models for lexical ad-

dressee detection. In Proceedings of INTERSPEECH, pages 298–302.

[Ritter et al.2011] Alan Ritter, Colin Cherry, and William B. Dolan. 2011. Data-driven response generation in

social media. In Proceedings of EMNL, pages 583–593.

[Serban et al.2016] Iulian Vlad Serban, Alessandro Sordoni, Yoshua Bengio, Aaron Courville, and Joelle Pineau.
2016. Building end-to-end dialogue systems using generative hierarchical neural network models. In Proceed-
ings of AAAI, pages 3776–3783.

[Shang et al.2015] Lifeng Shang, Zhengdong Lu, and Hang Li. 2015. Neural responding machine for short-text

conversation. In Proceedings of ACL/IJCNLP, pages 1577–1586.

[Traum2003] David Traum. 2003. Issues in multiparty dialogues. Advances in Agent communication, pages 201–

Intelligence, pages 106–121.

211.

1506.05869.

[Uthus and Aha2013] David C Uthus and David W Aha. 2013. Multiparticipant chat analysis: A survey. Artiﬁcial

[Vinyals and Le2015] Oriol Vinyals and V. Quoc Le. 2015. A neural conversational model. arXiv preprint arXiv:

[Wang et al.2013] Hao Wang, Zhengdong Lu, Hang Li, and Enhong Chen. 2013. A dataset for research on short-

text conversations. In Proceedings of EMNLP, pages 935–945.

[Wang et al.2015] Mingxuan Wang, Zhengdong Lu, Hang Li, and Qun Liu. 2015. Syntax-based deep matching of

short texts. In Proceedings of IJCAI, pages 1354–1361.

A Hyper-Parameters

Values
512
256
0.50
5
512

Hyper-parameter
Embedding size
GRU state size
WGAN λ
WGAN iterations
Critic hidden size
Critic activation function ReLU
Batch size
Max epoch
Adam alpha
L2 weight decay

32
30
{0.001, 0.0005, 0.0001}
{0.001, 0.0005, 0.0001}

Table 4: Hyper-parameters for our experiments.

B Statics of Dataset

Tab. 5 shows the details of our dataset. “Docs” is documents, “Utters” is utterances, “W. / U.” is the
number of words per utterance, “A. / D.” is the number of agents per document.

English (En)

Italian (It)

Croatian (Hr)

German (De)

Portuguese (Pt)

Dataset (Train / Dev / Test)

No. of Docs

No. of Utters

No. of Words

No. of Samples

Avg. W. / U.

Avg. A. / D.

7355
(6,606/ 367/ 382)
2.4 M
(2.1 M / 13.2 k / 15.1 k)
27.0 M
(23.8 M/ 1.5 M/ 1.7 M)
-
665.6 k/ 45.1 k/ 51.9 k
11.1
(11.1/ 11.2/ 11.3)
26.8
(26.3/ 30.68/ 32.1)

357
(306/ 17/ 34)
165 k
(144 k / 7 k / 14 k)
1.1 M
( 1.0 M/ 54 k/ 100 k)
-
38511 / 2561 / 3873
7.2
( 6.9/ 7.7/ 7.1)
25.6
(24.9/ 26.2/ 25.6)

254
(216/ 12/ 26)
80 k
( 71 k / 3.4 k / 6.9 k)
630 k
( 553 k/ 25 k/ 52 k)
-
11387 / 512 / 1145
7.5
( 7.7/ 7.3/ 7.5)
12.9
(12.7/ 13.5/ 12.7)

248
(216/ 12/ 20)
38 k
( 33 k / 1.9 / 2.9 k)
335 k
( 294 k/ 16 k/ 24 k)
-
5500 / 354 / 569
8.5
( 8.9/ 8.4/ 8.2)
16.4
(17.4/ 15.9/ 15.8)

211
(180/ 10/ 21)
52 k
( 44 k / 2.1 / 6.1 k )
285 k
( 243 k/ 11 k/ 30 k)
-
5951 / 285 / 975
5.2
( 5.5/ 5.2/ 4.9)
19.0
(19.7/ 18.6/ 18.8)

Table 5: Statistics of the multilingual dataset.

C Results for each language

Tab. 6 shows the detailed results of single-language adaptation. Tab. 7 shows the detailed results of
two-language adaptation. Tab. 8 shows the detailed results of ﬁve-language adaptation.

Target

#Train Method

ADR-RES

RES

ADR-RES

|R| = 2
ADR

|R| = 10
ADR

It

38,511

Hr

11,387

De

5,500

Pt

5,951

Avg.

-

CHANCE
TF-IDF
TRGONLY
ENONLY
FINETUNE
JOINT
WGAN

CHANCE
TF-IDF
TRGONLY
ENONLY
FINETUNE
JOINT
WGAN

CHANCE
TF-IDF
TRGONLY
ENONLY
FINETUNE
JOINT
WGAN

CHANCE
TF-IDF
TRGONLY
ENONLY
FINETUNE
JOINT
WGAN

CHANCE
TF-IDF
TRGONLY
ENONLY
FINETUNE
JOINT
WGAN

2.99
43.89
63.28
44.54
64.81
63.44
65.17

5.39
35.63
40.52
34.06
40.00
44.37
45.07

4.09
36.38
43.94
36.56
50.44
50.79
52.90

3.42
42.15
41.64
37.13
43.08
47.59
49.54

3.97
39.51
47.35
38.07
49.58
51.55
53.17

5.97
67.49
79.86
72.37
80.79
79.81
80.56

10.78
58.78
63.06
60.87
62.62
62.97
62.62

8.17
64.67
67.49
63.27
68.89
70.30
71.53

6.84
68.92
66.67
66.36
66.05
68.10
69.23

7.94
64.97
69.27
65.72
69.59
70.30
70.99

50.00
64.58
78.36
60.11
79.14
78.36
79.94

50.00
61.05
64.10
54.24
63.23
69.26
70.48

50.00
55.36
64.15
59.75
72.06
70.47
72.23

50.00
61.44
62.77
56.51
64.92
69.44
70.36

50.00
60.61
67.35
57.65
69.84
71.88
73.25

0.60
16.63
32.87
9.91
34.57
34.37
35.71

1.08
10.22
14.32
7.95
14.67
15.98
16.59

0.82
10.19
16.52
5.98
20.39
21.79
22.50

0.68
13.13
13.95
10.15
14.97
17.13
18.56

0.80
12.54
19.42
8.50
21.15
22.32
23.34

RES

10.00
23.42
38.73
16.29
41.26
40.82
42.14

10.00
17.29
22.97
12.31
22.79
24.54
25.68

10.00
14.41
22.50
12.13
26.71
27.94
28.30

10.00
18.87
20.31
14.26
21.85
24.21
25.44

10.00
18.50
26.13
13.75
28.15
29.38
30.39

5.97
67.49
80.92
66.74
81.44
80.30
80.76

10.78
58.78
63.23
60.52
64.72
62.97
63.76

8.17
64.67
66.96
57.12
68.19
69.24
68.89

6.84
68.92
67.79
65.13
66.97
68.92
67.38

7.94
64.97
69.73
62.38
70.33
70.36
70.20

Table 6: Results for single-language adaptation. Each number represents accuracy on addressee-
response selection (ADR-RES), addressee selection (ADR) or response selection (RES). #Train is the
number of training data.

Target Method

ADR-RES

ADR

RES

ADR-RES

ADR

RES

|R| = 2

|R| = 10

En, It

En, Hr

En, De

En, Pt

Avg.

CHANCE
TF-IDF
ENONLY
FINETUNE
JOINT
WGAN

CHANCE
TF-IDF
ENONLY
FINETUNE
JOINT
WGAN

CHANCE
TF-IDF
ENONLY
FINETUNE
JOINT
WGAN

CHANCE
TF-IDF
ENONLY
FINETUNE
JOINT
WGAN

CHANCE
TF-IDF
ENONLY
FINETUNE
JOINT
WGAN

1.80 ( 0.62, 2.95)
40.51 (37.13, 43.89)
50.01 (55.47, 44.54)
59.13 (53.44, 64.81)
59.56 (55.67, 63.44)
60.20 (55.23, 65.17)

2.35 ( 0.62, 5.39)
36.76 (37.13, 35.63)
44.77 (55.47, 34.06)
46.03 (52.06, 40.00)
49.49 (55.66, 43.32)
49.80 (54.53, 45.07)

3.01 ( 0.62, 4.08)
36.38 (37.13, 36.38)
46.02 (55.47, 36.56)
52.22 (53.99, 50.44)
53.04 (55.28, 50.79)
54.05 (55.20, 52.90)

2.02 ( 0.62, 3.42)
39.64 (37.13, 42.15)
46.30 (55.47, 37.13)
46.53 (49.98, 43.08)
51.39 (55.18, 47.59)
52.49 (55.44, 49.54)

2.30
38.32
46.77
50.98
53.37
54.14

3.61
61.56
70.95
74.71
74.63
74.94

4.71
60.15
65.20
65.29
65.98
65.70

6.01
57.20
66.40
68.79
69.73
70.35

4.04
62.27
67.94
66.39
68.66
69.31

4.59
60.29
67.62
68.79
69.75
70.07

50.00
66.24
69.13
77.78
78.50
79.10

50.00
61.63
66.20
69.15
73.14
73.96

50.00
64.47
68.95
74.52
74.30
75.19

50.00
64.67
67.33
68.97
73.81
74.29

50.00
64.25
67.90
72.60
74.94
75.63

0.36 ( 0.12, 0.60)
16.04 (15.44, 16.63)
20.59 (31.27, 9.91)
31.07 (27.56, 34.57)
33.04 (31.71, 34.37)
33.38 (31.04, 35.71)

0.47 ( 0.12, 1.08)
12.82 (15.44, 10.22)
19.61 (31.27, 7.95)
20.96 (27.24, 14.67)
22.95 (31.74, 14.15)
23.61 (30.62, 16.59)

0.60 ( 0.12, 0.82)
12.83 (15.44, 10.19)
18.63 (31.27, 5.98)
24.66 (28.93, 20.39)
26.09 (31.97, 20.21)
27.05 (31.42, 22.67)

0.40 ( 0.12, 0.68)
14.29 (15.44, 13.13)
20.71 (31.27, 10.15)
20.52 (26.06, 14.97)
24.32 (31.51, 17.13)
24.88 (31.19, 18.56)

0.46
13.99
19.88
24.30
26.60
27.23

3.61
61.56
68.05
74.62
74.77
75.09

4.71
60.15
64.94
66.01
66.15
66.38

6.01
57.20
63.24
68.20
68.98
69.43

4.04
62.27
67.24
66.74
69.11
68.16

4.59
60.29
65.86
68.89
69.75
69.76

10.00
26.31
29.11
39.34
41.72
41.87

10.00
21.80
27.12
30.28
32.23
33.52

10.00
23.24
27.03
33.09
35.14
35.31

10.00
24.03
28.09
29.13
33.28
33.75

10.00
23.84
27.83
32.96
35.59
36.11

Table 7: Results for two-language adaptation. Each number is macro average of the accuracies over all
the languages. Each of the parenthesized numbers in the ADR-RES column is ADR-RES accuracy for
each language.

Target

Method

ADR-RES

ADR

RES

ADR-RES

ADR

RES

|R| = 2

|R| = 10

TF-IDF

En, It

ENONLY

Hr, De, Pt

JOINT

WGAN

39.04
(37.13, 43.89, 35.63, 36.38, 42.15)
41.55
(55.47, 44.54, 34.06, 36.56, 37.13)
50.69
(54.49, 61.71, 43.41, 47.80, 46.05)
52.11
(53.88, 63.18, 44.19, 52.02, 47.28)

63.10

62.06

66.48

61.75

69.00

72.18

69.74

73.34

13.12
(15.44, 16.63, 10.22, 10.19, 13.13)
13.05
(31.27, 9.91, 7.95, 5.98, 10.15)
22.80
(31.26, 30.29, 14.59, 20.21, 17.64)
23.39
(30.6, 31.29, 14.67, 22.32, 18.05)

63.10

20.64

63.77

19.38

69.18

31.11

69.35

31.88

Table 8: Results for ﬁve-language adaptation. Each number is macro average of the accuracies over all
the languages. Each of the parenthesized numbers in the ADR-RES column is ADR-RES accuracy for
each language.

