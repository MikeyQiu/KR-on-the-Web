8
1
0
2
 
n
a
J
 
9
 
 
]
I

A
.
s
c
[
 
 
4
v
6
1
3
0
1
.
3
0
7
1
:
v
i
X
r
a

Efficient Parallel Translating Embedding For Knowledge Graphs

Denghui Zhang, Manling Li, Yantao Jia, Yuanzhuo Wang, Xueqi Cheng
Institute of Computing Technology, Chinese Academy of Sciences
No.6 Kexueyuan South Road, Zhongguancun, Haidian, Beijing, China 100190
zhangdenghui@ict.ac.cn,limanling@software.ict.ac.cn,jiayantao@ict.ac.cn,wangyuanzhuo@ict.ac.cn,cxq@ict.ac.cn

ABSTRACT
Knowledge graph embedding aims to embed entities and relations of
knowledge graphs into low-dimensional vector spaces. Translating
embedding methods regard relations as the translation from head
entities to tail entities, which achieve the state-of-the-art results
among knowledge graph embedding methods. However, a major
limitation of these methods is the time consuming training process,
which may take several days or even weeks for large knowledge
graphs, and result in great difficulty in practical applications. In this
paper, we propose an efficient parallel framework for translating
embedding methods, called ParTrans-X, which enables the methods
to be paralleled without locks by utilizing the distinguished struc-
tures of knowledge graphs. Experiments on two datasets with three
typical translating embedding methods, i.e., TransE [3], TransH
[19], and a more efficient variant TransE- AdaGrad [11] validate
that ParTrans-X can speed up the training process by more than an
order of magnitude.

CCS CONCEPTS
•Computing methodologies →Reasoning about belief and
knowledge;

KEYWORDS
Knowledge Graph Embedding, Translation-based, Parallel

ACM Reference format:
Denghui Zhang, Manling Li, Yantao Jia, Yuanzhuo Wang, Xueqi Cheng.
2017. Efficient Parallel Translating Embedding For Knowledge Graphs . In
Proceedings of WI ’17, Leipzig, Germany, August 23-26, 2017, 8 pages.
DOI: 10.1145/3106426.3106447

1 INTRODUCTION
Knowledge graphs are structured graphs with various entities as
nodes and relations as edges. They are usually in form of RDF-style
triples (h, r , t), where h represents a head entity, t a tail entity, and
r the relation between them. In the past decades, a quantity of large
scale knowledge graphs have sprung up, e.g., Freebase [2], WordNet
[14], YAGO [12], OpenKN [7], and have played a pivotal role in
supporting many applications, such as link prediction, question
answering, etc. Although these knowledge graphs are very large,
i.e., usually containing thousands of relation types, millions of

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
WI ’17, Leipzig, Germany
© 2017 ACM. 978-1-4503-4951-2/17/08. . . $15.00
DOI: 10.1145/3106426.3106447

entities and billions of triples, they are still far from complete.
As a result, knowledge graph completion (KGC) has been payed
much attention to, which mainly aims to predict missing relations
between entities under the supervision of existing triples.

Recent years have witnessed great advances of translating em-
bedding methods to tackle KGC problem. The methods represent
entities and relations as the embedding vectors by regarding re-
lations as translations from head entities to tail entities, such as
TransE [3], TransH [19], TransR[11], etc. However, the training
procedure is time consuming, since they all employ stochastic gra-
dient descent (SGD) to optimize a translation-based loss function,
which may require days to converge for large knowledge graphs.
For instance, Table11 shows the complexity of typical translating
stands for the total training
embedding methods, where Ttot al
for the time of each epoch, and one epoch is a
time with Tepoch
single pass over all triples. ne , nr and nt are the number of entities,
relations and triples in the knowledge graph respectively. d is the
embedding dimension which is the same for entities and relations in
this case, and ep is the minimum epochs which used to be set to 1000.
It can be seen that the time complexity of TransE is proportional to
nt , d and ep. When d is 100 and ep is 1000, it will take 78 minutes
for TransE to learn the embeddings of FB15k2, which is a subset of
Freebase with 483,142 training triples, and has been widely used
as experimental dataset in knowledge graph embedding methods
[3, 8, 11, 19]. Nevertheless, Freebase-rdf-latest3 is the latest public
available data dump of Freebase with 1.9 billion triples, which
results in approximately 3932 times the training time, namely, 212
days. Furthermore, the whole Freebase contains over 3 billion
triples4, and it will take about 357 days to learn the embeddings of
it. Despite its large size, Freebase still suffers from data incomplete
problem, e.g., 75% persons do not have nationalities in Freebase
[5]. On top of that, most improved variants of TransE employ more
complex loss function to better train the embedding vectors, thus
they possess higher time complexity or model complexity, and the
training time of them will be even unbearable. For example, it will
take more than 59 years for Freebase-rdf-latest when employing
TransR, which is one of the typical improved variants and achieves
far better performance than TransE.

There have been attempts to resolve the efficiency issue of trans-
lating embedding methods for knowledge graphs. Pasquale[15]
proposed TransE-AdaGrad to speed up the training process by
leveraging adaptive learning rates. However, TransE-AdaGrad es-
sentially reduces the number of epochs to converge, and still can

1The experiments are conducted on a dual Intel Xeon E5-2640 CPUs (10 cores each
× 2 hyperthreading, running at 2.4 GHz) machine with 128GB of RAM. The kernel is
Red Hat 4.4.7
2https://everest.hds.utc.fr/lib/exe/fetch.php?media=en:fb15k.tgz
3http://commondatastorage.googleapis.com/freebase-public/
4https://github.com/nchah/freebase-triples, there are 3,197,653,841 triples in Freebase
on May 2, 2016

WI ’17, August 23-26, 2017, Leipzig, Germany

D. Zhang et al.

Table 1: Complexity Analysis of Typical translating embedding Methods, with d = 100, ep = 1000
on FB15k

Time
Complexity

Model
Complexity

Tepoch
4.5s

6s
473s

Ttot al
4658s
≈ 78 minutes
100 minutes
5 days

on Freebase-rdf-latest
Tepoch
17,696s
≈ 5 hours
6.5 hours
21.5 days

Ttot al
18,323,395s
≈ 212 days
273 days
59 years

on the whole Freebase
Tepoch
29,781s
≈ 8 hours
11 hours
36 days

Ttot al
30,828,893s
≈ 357 days
459 days
99 years

TransE

O(nt × d × k)
TransH O(nt × d × k)
TransR O(nt × d

O(dne + dnr )
O(dne + 2dnr )
2 × k) O(dne + dnr + nr d

2)

not do well with large scale knowledge graphs. In fact, with more
and more computation resources available, it is natural and more
effective to parallel these embedding methods, which will lead to
significant improvement in training efficiency and can scale to quite
large knowledge graphs if given sufficient hardware resources.

However, it is challenging to parallel the translating embedding
methods, since the training processes mainly employ stochastic
gradient descent algorithm (SGD) or the variants of it. SGD is
inherently sequential, as a dependence exists between each iteration.
Parallelizing translating embedding methods straightforwardly will
result in collisions between different processors. For instance, an
entity embedding vector is updated by two processors at the same
time, and the gradients calculated by these processors are different.
In this case, the diverse gradients are called collisions. To avoid
collisions, some methods [9] lock embedding vectors, which will
slow the training process greatly as there are so many vectors. On
the contrary, updating vectors without locks leads to high efficiency,
but should be based on specific assumptions [4, 16]. Since the lock-
free training process may result in poor convergence if adopting
suboptimal strategy to resolve collisions.

Our key observation of translating embedding methods is that
the update performed in one iteration of SGD is based on only one
triple and its corrupted sample, which is not necessarily bound
up with other embedding vectors. This gives us chance to learn
the embedding vectors in parallel without being locked. In this
article, we analyze the distinguished data structure of knowledge
graphs, and propose an efficient parallel framework for translating
embedding methods, called ParTrans-X. It enables translating meth-
ods to update the embedding vectors efficiently in shared memory
without locks. Thus the training process is greatly speeded up with
multi-processors, which can be more than an order of magnitude
faster without lowering learning quality.
The contribution of this aritcle is:
1. We explore the law of collisions along with increasing number
of processors, by modelling the training data of knowledge graph
into hypergraphs.

2. We propose ParTrans-X framework to train translating meth-
ods efficiently in parallel. It utilizes the training data sparsity of
large scale knowledge graphs, and can be easily applied to many
translating embedding methods.

3. We apply ParTrans-X to typical translating embedding meth-
ods, i.e., TransE [3], TransH [19], and a more efficient variant
TransE-AdaGrad, and experiments validate the effectiveness of
ParTrans-X on two widely used datasets.

The paper is organized as follows. Related work is in Sec.2.
The collision formulation is introduced in Sec.3 and ParTrans-X
is proposed based on it in Sec.4. Then, experiments demonstrate
training efficiency of ParTrans-X in Sec.5, with conclusions in Sec.6.

2 RELATED WORK
In recent years, translating embedding methods have played a
pivotal role in Knowledge Graph Completion, which usually employ
stochastic gradient descent algorithm to optimize a translation-
based loss function, i.e.,
(cid:213)
L = (cid:213)
(h,r,t )

max (cid:2)0, fr (h, t) + M − fr (h(cid:48), t (cid:48))(cid:3) ,

where (h, r , t) represents the positive triple that exists in the knowl-
edge graph, while (h(cid:48), r , t (cid:48)) stands for the negative triple that is
not in the knowledge graph. max [0, ·] is the hinge loss , and M
is the margin between positive and negative triples. fr (h, t) is the
score function to determine whether the triple (h, r, t) should exist
in the knowledge graph, which varies from different translating
embedding methods.

(h(cid:48),r,t (cid:48))

(1)

A significant work is TransE [3], which heralds the start of
translating embedding methods. It looks upon a triple (h, r, t) as a
translation from the head entity h to the tail entity t, i.e., h + r ≈ t,
and the score function is fr (h, t) = ||h+r−t||, where || · || represents
L1-similarity or L2-similarity. The boldface suggests the vectors in
the embedding space, namely, h, t ∈ Rd , r ∈ Rd , where d = de = dr
is the dimension of embedding space, de the dimension for entities
and dr for relations. Moreover, TransH [19] assumes that it is the
projections of entities to a relation-specific hyperplane that satisfy
the translation constraint, i.e., fr (h, t) = ||h⊥ + r − t⊥||, where
h⊥ = h − w(cid:62)
r twr, with wr ∈ Rde as the
normal vector of the hyperplane related to r . Furthermore, TransR
[11] employs rotation transformation to project the entities to a
relation-specific space, i.e., fr (h, t) = ||hr + r − tr||, where hr = Mrh
and tr = Mrt, and Mr ∈ Rdr ×de is the projection matrix relation to
r . Some works also involves more information to better embedding,
e.g., paths [10], margins [8].

r hwr and t⊥ = t − w(cid:62)

Although this category of methods achieve the state-of-the-art
results, the main limitation is the computationally expensive train-
ing process when facing large scale knowledge graphs. Recently, a
method TransE-AdaGrad [15] was proposed to reduce the training
time of TransE by employing AdaGrad [6], an variant of SGD, to
adaptively modify the learning rate. Although the training time has
been reduced greatly, there is still some way to go when facing large
scale knowledge graphs. With the computation resources greatly
enriched, training in parallel seems to be a more reliable way to
relieve this issue. Actually, there are some works, e.g., [18], to
parallel some graph computation paradigms, such as online query
processing, offline analytics, etc. Nevertheless, it is not easy to
train translating embedding methods in parallel, since the main
optimation algorithm SGD is born to run in sequence. The major
obstacle to parallel SGD is the collisions between updates of dif-
ferent processors for the same parameter [17], to overcome which
there are two main brunches of methods.

Efficient Parallel Translating Embedding For Knowledge Graphs

WI ’17, August 23-26, 2017, Leipzig, Germany

The first brunch is to design a strategy to resolve collisions ac-
cording to specific data structure. For example, Hogwild! [16] is
a lock-free scheme works well for sparse data, which means that
there is only a small part of parameters to update by each iteration
of SGD. It has been proved that processors are unlikely to overwrite
each other’s progress, and the method can achieve a nearly optimal
rate of convergence. While the second brunch is to split the training
data to to reduce collisions. Downpour SGD [4] mainly employ Dist-
Belief [4] framework, which divides the training data into a number
of subsets, then the model replicas run independently on each of
these subsets, and do not communicate with each other. Inspired by
this, TensorFlow [1] splits a computation graph into a subgraph for
every worker and communication takes place using Send/Receive
node pairs. Motivated by training large-scale convolutional neural
networks for image classification, Elastic Averaging SGD (EASGD)
[20] reduces the amount of communication between local workers
and the master to allow the parameters of local workers to fluctuate
further from the center ones. There are also works to improve the
performance in parallel settings, e.g., Delay-tolerant Algorithms
for SGD [13] adapts not only to the sequence of gradients, but also
to the precise update delays that occur, inspired by AdaGrad.

However, these parallel framework are based on specific as-
sumptions, and can not directly apply to translating embedding
models without exploring distinguished data structures of knowl-
edge graphs. Therefore, we shall propose a parallel framework for
translating embedding models, called ParTrans-X, as knowledge
graphs are mainly in form of triples, and trained triple by triple, it
will lead to particular parallel framework.

3 LAW OF COLLISIONS EMERGING IN KG
As mentioned previously, there may exist collisions between pro-
cessors when they update the same embedding vector, which ends
up being one of the most challenging aspects of parallelizing trans-
lating embedding methods. Hence, we explore the law of collisions
emerging in this section. At first we formulate the training data of
knowledge graphs into hypergraphs. Then the collisions in training
process are further discussed based on this formulation.

3.1 Hypergraph Formulation
Firstly, we model the knowledge graph formally as G = (E, R,T ),
where E is the set of entities with R the set of relations, and T
is the set of triples (h, r , t), in which h, t ∈ E and r ∈ R. The
cardinalities of E, R and T are ne , nr and n respectively. In this
graph, nodes are entities, and edges are triples that connecting
nodes with a distinguished relation. For example, the knowledge
graph shown in Figure1(a), where black nodes stand for the entities
in knowledge graphs and lines for relations, can be represented as
G = (E, R,T ), where E = {e1, e2, e3, e4, e5}, R = {r1, r1, r3} and T =
{(e1, r2, e4), (e1, r1, e3), (e2, r3, e5), (e4, r3, e2)}. In this case, ne = 5,
nr = 3 and n = 4.

Secondly, the training data of knowledge graphs can be looked
upon as hypergraphs. Recall the loss function of translating em-
bedding methods in Eq.(1), which means in one iteration of SGD,
only one positive triple (h, r, t) and one negative triple (h(cid:48), r , t (cid:48))
are concerned. To be more clear, the data used in one iteration,
i.e., [(h, r , t), (h(cid:48), r , t (cid:48))], is called a sample. Note that (h(cid:48), r, t (cid:48)) is

Figure 1: A Knowledge Graph (a) and one of the Hyper-
graphs generated by its training data (b).

constructed by substituting one entity h(cid:48) ∈ E or t (cid:48) ∈ E for h or t
respectively, contributing to a corrupted triple (h(cid:48), r, t) or (h, r, t (cid:48)),
which is just simply denoted by (h(cid:48), r , t (cid:48)) following [3]. Conse-
quently, a sample corresponding to three entities, i.e., h, t, h(cid:48)or t (cid:48),
and one relation r . As a result, the training data can be formulated
in to a 4-uniform hypergraph, in which all the hyperedges have
the same cardinality 4. In this hypergraph, nodes are entities and
relations, and edges are training samples containing 4 nodes, i.e.,
three entities and one relation. More formally,

Definition 3.1. The training data to embed the knowledge graph
G = (E, R,T ) by translating embedding methods is organized as a
4-uniform hypergraph H = (V , S), where V = {E ∪ R} is the set of
entities or relations, and S is the set of training samples s, where
s = {h, r , t, h(cid:48)(or t (cid:48)) : h, r , t, h(cid:48), t (cid:48) ∈ E, r ∈ R}.

For example, the hypergraph in Figure1(b) is one of the hyper-
graphs generated by Figure1(a), where black nodes are entities and
colored nodes are relations, and the colored blocks represent hy-
peredges. Here, different colors are related to different relations.
For instance, for triple (e1, r1, e3), the negative triple sampled in
Figure1(b) is (e1, r1, e2), which contributes to a sample s1 = {e1,
r1,e2,e3}, thus the hyperedge colored by red contains e1, e2, e3 and
r1. Note that many other negative triples can be constucted, e.g.,
(e1, r1, e5) for triple (e1, r1, e3), and the hypergraph generated in Fig-
ure1(b) is just an example. Similarly, the other samples in Figure1(b)
are s2 = {e1, r2, e4, e5}, s3 = {e2, r3, e3, e5} and s4 = {e4, r3, e2, e3}.
To better analyze the collisions between processors, we define
the following statistics of the hypergraph H . Given a hyperedge s,
σ (s) = {s (cid:48) : ∃r ∈ s ∩ s (cid:48), r ∈ R}
denotes the set of hyperedges containing the same relations with
hyperedge s.

(2)

ˆσ = max
s ∈S
denotes the maximal number of hyperedges containing same rela-
tions, where | · | denotes the cardinality.

|σ (s)|

(3)

ρ(s) = {s (cid:48) : ∃e ∈ s ∩ s (cid:48), e ∈ E}
denotes the set of hyperedges containing one or more same entities
with hyperedge s.

(4)

ˆρ := max
s ∈S
denotes the maximal number of hyperedges containing same enti-
ties, where | · | denotes the cardinality the same as before.

|ρ(s)|.

(5)

WI ’17, August 23-26, 2017, Leipzig, Germany

D. Zhang et al.

3.2 Collision Formulation
In this section, we will verify that it is highly possible that few
collisions happen when training by p processors for large and sparse
knowledge graphs. Let Xsamp represent the event that p processors
select p different samples. Xr el
represents the event that there are
collisions between relations, i.e., different processors updates a same
relation vector, and Xent between entities similarly. The verification
is decomposed into two steps, 1) to prove it is quite likely that the
processors handle different samples, i.e., P(Xsamp = 1) ≈ 1, which
is the prerequisite to no collisions; 2) to prove it is unlikely that
these different samples correspond to the same relations or entities,
i.e., P(Xr el

= 0) ≈ 1 and P(Xent = 0) ≈ 1.

Supposing that for embedding methods and the knowledge graph,
the training samples S = {s1, s2, . . . , si , . . . , sn } of size n is drawn
independent and identically distributed (i.e., i.i.d.) from some un-
known distribution D. Therefore, the probability of si being se-
lected Pi is supposed to be

Pi =

1

n

.

Moreover, according to i.i.d., it is reasonable to assume that the
sample selecting process by p processors is an observation from a
Multinomial Distribution, i.e., selecting one sample from n samples
and repeated p times. Let xi denote the number of processors that
select si during the same iteration of SGD, then the possibility of
si being selected by c1 processors, . . ., sne
being selected by cne
processors is as follows,

= cne ) =
p!
c1!c2! · · · cne

P(x1 = c1, ...,xne




! Pc1

1 ...P

cne
ne ,

ne(cid:213)

ci = p

i=1
otherwise

0,

where (cid:205)ne
being selected in the same iteration of SGD.

i=1 ci = p indicates that there are p and only p samples

Theorem 3.2. For a knowledge graph with n triples and training
by p processors in parallel, when n is large and p is relatively small,
the possibility that p processors select p different samples is

P(Xsamp = 1) ≈ 1

with probability at least γ , where
p−1
(cid:214)

γ =

(1 −

i=1

i
n

).

(6)

(7)

(8)

(9)

= (1 −

)(1 −

) · · · (1 −

1

n

2

n

p − 1
n

)

=

(1 −

p−1
(cid:214)

i=1

i
n

)

When n is large and p is relatively small, P(Xsamp = 1) ≈ 1. (cid:3)

Theorem 3.3. For a knowledge graph with n triples and training
+ 1,

ˆσ
n is relatively small and p < n
ˆσ

in p processors in parallel, when
we have the possibility of no relation in a collision is

with probability at least γ , where

P(Xr el

= 0) ≈ 1

γ =

(1 −

p−1
(cid:214)

i=1

i ˆσ
n

).

(10)

(11)

Proof. Given that p processors select p different samples, the
posibility of relations in a collision can be deduced according to
conditional probability as follows,

(12)

= 0) = P(Xr el

= 0|Xsamp = 1) · P(Xsamp = 1),

P(Xr el
= 0|Xsamp = 1) is the possibility of p samples con-
where P(Xr el
taining distinct relations being selected, which is supposed to be
similar to sampling without replacement. More precisely, assuming
a sample s is selected randomly, then the next sample selected s (cid:48)
should be from S − σ (s), and the third sample s (cid:48)(cid:48) should be selected
from in S − σ (s) ∪ σ (s (cid:48)). Accordingly, P(Xr el
= 0|Xsamp = 1) is
deduced as follows when p < n
+ 1 is satisfied,
ˆσ

P(Xr el

= 0|Xsamp = 1)

= (cid:213)

s1,s2, ...,sp ∈S

1

n

·

|S − σ (s1)|
n − 1

·

|S − σ (s1) ∪ σ (s2)|
n − 2

. . .

|S − σ (s1) ∪ σ (s2) ∪ · · · ∪ σ (sp−1)|
n − (p − 1)
1

(cid:213)

≥

·

n − ˆσ
n − 1

·

n − 2 ˆσ
n − 2 . . .

n − (p − 1) ˆσ
n − (p − 1)

n

s1,s2, ...,sp ∈S

= (1 −

)(1 −

) · · · (1 −

ˆσ − 1
n − 1

2( ˆσ − 1)
n − 2

(p − 1)( ˆσ − 1)
n − (p − 1)

)

=

(1 −

p−1
(cid:214)

i=1

i( ˆσ − 1)
n − i

)

Proof. Provided that samples selected by processors are differ-
ent, it can be easily derived that ∀si ∈ S, xi ≤ 1. Then there are
only (cid:0)n
(cid:1) sampling circumstances satisfying no collisions between
p
samples, where p distinct samples are selected once, and other n −p
samples are not selected, e.g., x1 = 1, x2 = 1, · · · , xp = 1, xp+1 =
0, · · · , xn = 0. Therefore, according to Eq.(7) and Eq.(6),
(cid:19) p!
p
(cid:206)
i=1

P(Xsamp = 1) =

n!
(n − p)!

(Pi )1 =

(cid:18)n
p

p
(cid:214)

i=1

)p

1!

n

1

(

= n(n − 1)(n − 2) · · · (n − p + 1)
np

By Eq.(12), the possibility of no collisions between relations in
different processors is

P(Xr el

= 0) =

p−1
(cid:214)

(1 −

p−1
(cid:214)

i( ˆσ − 1)
n − i

) ·

i
n

p−1
(cid:214)

(1 −

) =

(1 −

). (13)

i ˆσ
n

i=1

i=1
+ 1 results in 1 − (p−1)( ˆσ −1)
Note that p > n
n−(p−1) < 0, which means
ˆσ
ˆσ is so large that one or more processors will definitely select
= 0) = 0.
the same relation among p processors, namely, P(Xr el
Furthermore, when ˆσ
n

is relatively small, P(Xr el

= 0) ≈ 1.

i=1

(cid:3)

Efficient Parallel Translating Embedding For Knowledge Graphs

WI ’17, August 23-26, 2017, Leipzig, Germany

Similarly, the possibility of no entities in a collision can be de-
rived as follows, and no more tautology here due to the limitation
of length.

Theorem 3.4. For a knowledge graph with n triples and training
+ 1,

ˆρ
n is relatively small and p < n
ˆρ

in p processors in parallel, when
the possibility of no collisions between entities is

with probability at least γ , where
p−1
(cid:214)

P(Xent = 0) ≈ 1

γ =

(1 −

i=1

i ˆρ
n

).

(14)

(15)

It is verified in Theorem3.2, Theorem3.3 and Theorem3.4 that if n
is large and ˆσ and ˆρ are relatively small, i.e., the knowledge graph
is large and sparse, the number of processors p can be very large
with supportable collisions, which enables the training process to
run in parallel. Motivated by this, we define sparsity of training
ˆρ
data in a knowledge graph by min( ˆσ
n ). The smaller its value is,
n ,
the more processors can be used to parallel the training process.
Actually, it is the large and sparse knowledge graphs that are in dire
need of parallel translating embedding methods. Since they are far
from completion, but are too large to train in serial. Besides, since
ˆσ and ˆρ is deduced by the worst case, it is reasonable to assume
that the average ¯σ and ¯ρ can better reflect the general structures
in knowledge graphs, and the collisions will be less in practice. As
a result, we suppose that it would still work well if the average
¯σ and ¯ρ are relatively small, as a few collisions will not affect the
consistency.

3.3 Special Insights on Parallelizing TransE
There is an interesting finding that TransE can be further paral-
lelized than other translating embedding methods, since there are
less collisions due to the distinguished score function fr (h, t) =
||h + r − t||. More precisely, the gradient calculation of TransE when
using L2-similarity is as follows,
+ rk − tk ), h(cid:48)
+ rk − tk ), rk
+ rk − tk ), t(cid:48)

:= hk − η · 2(hk
:= rk − η · 2(hk
+ η · 2(hk
:= tk

k
+ η · 2(h(cid:48)
k
k − η · 2(h(cid:48)

k
:= rk
:= t(cid:48)

k
+ r(cid:48)
+ r(cid:48)

k − t(cid:48)
+ r(cid:48)
k − t(cid:48)
k )
k − t(cid:48)
k )
(16)

+ η · 2(h(cid:48)

hk
rk
tk

:= h(cid:48)

k )

k

k

where hk
represents the k-th dimension of embedding vector h,
k ∈ {0, 1, · · · , d}, and d is the dimension of embedding space. It
can be seen that in TransE, the gradient of each dimension is in-
dependent of other dimensions, which means that the collisions
between different dimensions of the same embedding vector will
not disturb each other. That is to say, only the collisions between
the same dimension of the same embedding vector will matter in
the training process of TransE.

For example, Figure2 shows the updating of h by two processors
is the
(Processor1 and Processor2) at the same time, where ∇k
by Processor2.
gradient of hk
Normally, when Processor2 calculates the gradient ∇(cid:48)
, the whole
k
embedding vector h will be involved, which is half updated by
Processor1. Obviously, this will result in training errors. On the
contrary, if it is the training process of TransE in Figure2, the

calculated by Processor1, and ∇(cid:48)
k

Figure 2: Updating embedding vector h in parallel

calculation of ∇(cid:48)
by Processor2 only concerns the k-th dimension
k
. As a result, there will no disturbance between Processor1 and
hk
Processor2, as long as the two processors are not performing update
to the same dimension of the same embedding vector.

Consequently, the possibility of collisions emerging is greatly
decreased for TransE. Since not only the entities or relations are
the same one, but also the dimensions being updated are the same.
Namely, the maximal degree of parallelism is far larger than other
translating embedding methods. This indicates that parallelizing
without locks is ideally situated for TransE, and may scale well to
extremely large knowledge graphs by given sufficient computation
resources.

4 THE PARTRANS-X FRAMEWORK
Inspired by the findings that collisions between processors are
negligible when a knowledge graph is large and sparse, a parallel
framework for these methods is designed, called ParTrans-X, and
we will describe it in detail in this section.

4.1 Framework Description
The pseudocode for implementation of ParTrans-X is shown in
Algorithm 1. As the embedding vectors are updated frequently, they
are stored in shared memory and every processors can perform
updates to them freely.

The training process of ParTrans-X starts with initializing the
embedding vectors according to Uniform or Bernoulli Distribution,
where no parallel section is needed since it takes constant time.
However we can parallel the learning process of each epoch, which
is the most time consuming part. Running by p processors in par-
allel can decrease the training epochs by p times, i.e., the parallel
training epoch is ep (cid:48) = ep
. To do this, we first determine the
p
random sampling seed seed[i] by calling SEED RAN D for the i-th
processor. The random sampling seeds differ from each other to
avoid same pseudo-random sequence for different processors. Then,
each processor performs embedding learning procedure epoch by
epoch asynchronously (lines 5-12). One epoch is a loop over all
triples. Each loop is done by firstly normalizing the entity embed-
ding vectors following [3]. Then a positive triple P[i](j) = (h, r, t)
is sampled from shared memory, where i means that the current
processor is i-th processor, and superscript j stands for j-th epoch.
According to P[i](j), a negative triple N [i](j) = (h(cid:48), r , t (cid:48)) is gener-
ated by sampling a corrupted entity h(cid:48) (or t (cid:48)) from shared memory,
where i and j are the same as before. That is to say, a sample S[i](j)

WI ’17, August 23-26, 2017, Leipzig, Germany

D. Zhang et al.

is constructed by P[i](j) and N [i](j), which then be used to calculate
the gradient ∇[fr (h, t) + M − fr (h(cid:48), t (cid:48))] according to Eq.(1), and up-
date the embeddings of entities and relations (h, r, t, h(cid:48), t (cid:48))(j+1) ←
(h, r, t, h(cid:48), t (cid:48))(j) − η∇[i](j).

using our framework by only performing a learning rate calculation
procedure during the gradient update procedure, i.e., Line 12 of
the pseudocode in Algorithm 1. For example, to parallel TransE-
AdaGrad, the learning rate is determined adaptively by adding

Algorithm 1 ParTrans-X
Require:

Training triples T = {(h, r, t)}, entities and relations set E and
R, embedding dimension d, margin M, training epochs ep, the
number of processors p;

Ensure:

Embeddings of entities and relations;

1: Initialize r ∈ R and e ∈ E by uniform distribution and persist

(cid:46) In Parallel

them in the shared memory

2: for i ← 0 to p do
ep (cid:48) ← ep
3:
p
seed[i] ← SEED RAN D(i)
for j ← 0 to ep (cid:48) do

5:

4:

loop

6:

7:

8:

9:

10:

11:

12:

13:

e := e
for each entity e ∈ E
| |e | |
P[i](j) ← SAMPLE(T , seed[i])
N [i](j) ← SAMPLE N EG(P[i](j),T , E, seed[i])
S[i](j) ←
∇[i](j) ← ∇[fr (h, t) + M − fr (h(cid:48), t (cid:48))], where
h, r, t, h(cid:48), t (cid:48) ∈ S[i](j)
(h, r, t, h(cid:48), t (cid:48))(j+1) ← (h, r , t, h(cid:48), t (cid:48))(j) − η∇[i](j)

P[i](j), N [i](j)(cid:105)

(cid:104)

end loop

end for

14:
15: end for
16: Generate embeddings of E and R after all processors finish

4.2 Application to Typical translating

embedding Methods

The framework can be applied to many translating embedding
methods, which employ SGD or its variants to optimize the hinge
loss with similar algorithm framework, and are only different in the
score function fr (h, t) as mentioned in Sec.2, e.g., TransE, TransH
and so on. Hence, the parallel algorithm of them can be obtained
by applying the corresponding score function in Lines 11-12 of the
pseudocode in Algorithm 1.

For example, for TransE, the gradient updating procedure in
Lines 11 is performed according to Eq.(16). For TransH, which
employs the score function fr (h, t) = ||h⊥ + r − t⊥||, the gradient
updating procedure of h in Lines 11 is as follows,

hk

:= hk − η · 2 (cid:2)(hk − wr

(cid:62)hwrk ) + rk − (tk − wr

(cid:62)twrk )(cid:3) .

(17)

Namely, ParTrans-X has the flexibility to parallel many translating
embedding methods, since they possess similar training process.

Moreover, ParTrans-X can be directly applied to the improved
variant TransE-AdaGrad, since the training data sparsity of knowl-
edge graph still holds. In one iteration of AdaGrad, it updates the
embedding vectors according to the gradient from the previous
iteration. Highly similar to SGD, AdaGrad can be easily parallelled

η(j) :=

∇(j)
k =1(∇(k ))2

(cid:113)(cid:205)j

η∗

(18)

before Line 12 in Algorithm 1, where j is the current epoch, with
η(j) the learning rate of j-th epoch. ∇(k ), k < j represents all the
previous gradient before j-th epoch. η∗ is the initial learning rate.

5 EXPERIMENT
Firstly, we apply ParTrans-X to TransE, TransH and TransE-Adagrad
in Sec.5.1. In Sec.5.2, experiment results demonstrate excessive de-
cline in training time by ParTrans-X, with scaling performance
along with increasing number of processors shown in Sec.5.3.

5.1 Experimental Settings
The datasets employed are two representative datasets WN18 and
FB15k, which are subsets of well-known knowledge graphs Word-
Net and Freebase respectively, and have been widely used by trans-
lating embedding methods [3, 8, 11, 19]. Table2 shows the statistics
of them. Without loss of generality, ¯ρ
are also shown, and
n
they are both small on WN18 and FB15k. Furthermore, it can be
seen that the two datasets possess different characteristics. Namely,
WN18 possesses only 18 relations, which results in large possibil-
ity of collisions between relations. On the contrary, FB15k is less
unbalanced in the number of entities and relations.

and ¯σ
n

Table 2: Two widely used datasets in KGs.
¯σ /n
# Ent
40,943 141,442 5,000
1.7e-1
14,951 483,142 50,000 59,071 9.3e-3

#Train #Valid #Test
5,000

# Rel

Data
WN18 18
FB15k 1,345

¯ρ/n
5.6e-4
2.3e-3

To tackle the KGC problem, experiments are conducted on the
link prediction task which aims to predict the missing entities h or
t for a triple (h, r , t). Namely, it predicts t given (h, r ) or predict h
given (r, t). Similar to the setting in [3], the task returns a list of
candidate entities from the knowledge graph.

To evaluate the performance of link prediction, we adopt Mean
Rank and Hits@10 under “Raw” and “Filter” settings as evaluation
measure following [3]. Mean Rank is the average rank of the correct
entities, and Hits@10 is proportion of correct entities ranked in
top-10. It is clear that a good predictor has low mean rank and high
Hits@10. This is called “Raw” setting, and “Filter” setting filters out
the corrupted triples which are correct.

To evaluate the speed up performance, we adopt Training Time
and Speed-up Ratio as evaluation measures, where Training Time
is measured using wall-clock seconds. Speed-up Ratio is

Speedup Ratio = tser ial
tpar all el

,

(19)

where tser ial
training time under parallel methods.

is the training time in serial, and tpar all el

is the

Efficient Parallel Translating Embedding For Knowledge Graphs

WI ’17, August 23-26, 2017, Leipzig, Germany

Metric

TransE

Table 3: Link prediction performance with all time measured in wall-clock seconds.

WN18

FB15k

Mean Rank

Hits@10

Training

Speedup

Mean Rank

Hits@10

Training

Speedup

Raw Filter Raw Filter

Time(s)

Ratio

Raw Filter Raw Filter

Time(s)

Ratio

ParTransE
TransE-AdaGrad

ParTransE-AdaGrad
TransH

ParTransH

214

217

209

219

227

215

203

206

197

208

216

203

58.2

55.7

68.9

67.7

66.5

66.8

65.9

63.1

77.7

76.2

75.9

76.6

473

54
100

17
637

134

-

9
4.7
28 (4.7×6)
-

4.8

184

185

185

186

183

183

73

74

69

70

60

60

44.5

44.4

45.3

44.9

46.6

46.8

60.7

60.5

62.3

61.9

65.5

65.7

4658

364
496

42
6066

474

-

13
9
111 (9×12)
-

13

Baselines include typical translating embedding methods, TransE,
TransH and TransE-Adagrad, which can all be trained in parallel us-
ing the ParTrans-X framework, denoted by ParTransE, ParTransH
and ParTransE-Adagrad respectively in Table3. Note that TransE
and TransH adopt the programs publicly available5, which are
the most efficient serial versions to our knowledge, and TransE-
Adagrad is implemented based on TransE.

Each experiment is conducted 10 times and the average is taken
as results, with all time measured in wall-clock seconds. Our exper-
iments are carried out on dual Intel Xeon E5-2640 CPUs, and each
of them possesses 10 physical cores 20 logical cores and running at
2.4 GHz. The machine has 128 GB RAM and runs Red Hat 4.4.7. The
language used is C++ and the program is compiled with the gcc
compiler version 6.3.0. We use OpenMP for multithreading, each
thread binds a processor.

5.2 Link Prediction Peformance of ParTrans-X
Experiments on each baseline and its parallel implementation in
ParTrans-X employ the same hyper-parameters, which are decided
on the validation set. The learning rate η during the stochastic
gradient descent process is selected among {0.1,0.01,0.001}, the em-
bedding dimension de and dr are selected in {20,50,100}, the margin
M between positive and negative triples is selected among {1,2,3,4}.
For TransE and ParTransE, the parameters are η = 0.01, de = dr =
20, M = 3 on WN18, and η = 0.001, de = dr = 100, M = 4 on Fb15k.
For TransH and ParTransH, the parameters are η = 0.01, de =
dr = 20, M = 3 on WN18, and η = 0.001, de = dr = 100, M = 3
on Fb15k. For TransEAdaGrad and ParTransE-AdaGrad, the pa-
rameters are η∗ = 0.3, de = dr = 50, M = 4 on WN18, and
η∗ = 0.1, de = dr = 100, M = 3 on Fb15k. All the experiments em-
ploy L1-similarity. ParTransE, ParTransH and ParTransE-AdaGrad
all run in 20 processors for both datasets.
It can be observed from Table3 that:
1. Link prediction performance in parallel is as good as the serial
counterparts on both WN18 and FB15k, which demonstrates that
ParTrans-X will not affect embedding performance.

2. The training time is greatly reduced by ParTrans-X. On WN18,
TransE-AdaGrad only speeds up TransE by 4.7 times, compared to
our 28 times. On FB15k, the training time of TransE is reduced from
more than 1 hour to less than 1 minute by ParTransE-AdaGrad.

5https://github.com/thunlp/KB2E

3. ParTrans-X achieves higher speedup ratio on FB15k than on
WN18. Since FB15k has far more training triples than WN18, the
time of each epoch on FB15k is much longer than WN18. As a result,
the overhead of multi-threading is less important compared to the
whole training time on FB15k, which leads to a higher speedup
ratio. It further validates the superiority of ParTrans-X to handle
the data with large size.

4. ParTrans-X achieves enormous improvement on training time
when applying to TransEAdaGrad, especially on FB15k, where
the speedup ratio has been improve to 111 from 9. Since AdaGrad
decreases the total epochs needed by making the convergence come
earlier, and ParTrans-X reduce training time by running in parallel,
the two different strategies can achieve higher speedup ratio when
combined.

WN18

FB15k

Figure 3: The descent process of loss.

Moreover, the descent process of loss for the three algorithms
on WN18 and FB15k is shown in Figure3.
It can be seen that,
for both datasets, the loss optimizing by ParTrans-X has already
fallen sharply in the preceding epochs, and it yields sensibly lower
values of the loss than TransE-AdaGrad and TransE even after a
few iterations(< 5 epoches). Still, ParTrans-X performs better on
FB15k than WN18, shows that it is more effective on large data size.

5.3 Scaling Results for Multi-Processors
Furthermore, we carry out a number of experiments to test if the
implementations scale with increasing number of processors. We
mainly analyze two aspects of experiment results, i.e., the training
time and the link prediction performance.

Figure4 shows the log-log plot of the training time in wall-clock
seconds for different number of processors. We can observe that
the training time continue to decrease along with the increasing

WI ’17, August 23-26, 2017, Leipzig, Germany

D. Zhang et al.

ParTrans-X can speed up the training process by more than an
order of magnitude, without degrading embedding performance.
The source code of this paper can be obtained from here6.

7 ACKNOWLEDGE
We thank Jun Xu and the anonymous reviewers for valuable sugges-
tions. The work was funded by National Natural Science Foundation
of China (No. 61572469, 61402442, 91646120,61572473, 61402
022), the National Key R&D Program of China (No. 2016QY02D0405,
2016YFB1000902), and National Grand Fundamental Research 973
Program of China (No. 2013CB329602, 2014CB340401).

REFERENCES
[1] Martn Abadi, Ashish Agarwal, Paul Barham, Eugene Brevdo, Zhifeng Chen,
Craig Citro, Greg S. Corrado, Andy Davis, Jeffrey Dean, and Matthieu Devin.
2016. TensorFlow: Large-Scale Machine Learning on Heterogeneous Distributed
Systems. (2016).

[4]

[2] Kurt Bollacker, Colin Evans, Praveen Paritosh, Tim Sturge, and Jamie Taylor.
2008. Freebase: a collaboratively created graph database for structuring human
knowledge. In Proceedings of the 2008 ACM SIGMOD international conference on
Management of data. AcM, 1247–1250.

[3] Antoine Bordes, Nicolas Usunier, Alberto Garcia-Duran, Jason Weston, and
Oksana Yakhnenko. 2013. Translating embeddings for modeling multi-relational
data. In Advances in neural information processing systems. 2787–2795.
Jeffrey Dean, Greg S Corrado, Rajat Monga, Kai Chen, Matthieu Devin, Quoc V
Le, Mark Z Mao, Marc’Aurelio Ranzato, Andrew Senior, and Paul Tucker. 2012.
Large scale distributed deep networks. In International Conference on Neural
Information Processing Systems. 1223–1231.

[5] Xin Dong, Evgeniy Gabrilovich, Geremy Heitz, Wilko Horn, Ni Lao, Kevin
Murphy, Thomas Strohmann, Shaohua Sun, and Wei Zhang. 2014. Knowledge
vault: a web-scale approach to probabilistic knowledge fusion. ACM. 601–610
pages.
John Duchi, Elad Hazan, and Yoram Singer. 2011. Adaptive subgradient methods
for online learning and stochastic optimization. Journal of Machine Learning
Research 12, Jul (2011), 2121–2159.

[7] Yantao Jia, Yuanzhuo Wang, Xueqi Cheng, Xiaolong Jin, and Jiafeng Guo. 2014.
OpenKN: An open knowledge computational engine for network big data. In
Advances in Social Networks Analysis and Mining (ASONAM). IEEE, 657–664.
[8] Yantao Jia, Yuanzhuo Wang, Hailun Lin, Xiaolong Jin, and Xueqi Cheng. 2016.
Locally Adaptive Translation for Knowledge Graph Embedding. In AAAI.
John Langford, Alexander J Smola, and Martin Zinkevich. 2009. Slow learners
are fast. In International Conference on Neural Information Processing Systems.
2331–2339.

[9]

[6]

[10] Yankai Lin, Zhiyuan Liu, Huanbo Luan, Maosong Sun, Siwei Rao, and Song Liu.
2015. Modeling Relation Paths for Representation Learning of Knowledge Bases.
Computer Science (2015).

[11] Yankai Lin, Zhiyuan Liu, Maosong Sun, Yang Liu, and Xuan Zhu. 2015. Learning
entity and relation embeddings for knowledge graph completion. In Twenty-
Ninth AAAI Conference on Artificial Intelligence. 2181–2187.

[12] Farzaneh Mahdisoltani, Joanna Biega, and Fabian Suchanek. 2014. YAGO3: A

Knowledge Base from Multilingual Wikipedias. (2014).

[13] H. B. Mcmahan and M. Streeter. 2014. Delay-tolerant algorithms for asynchro-
nous distributed online learning. Advances in Neural Information Processing
Systems 4 (2014), 2915–2923.

[14] George A Miller. 1995. WordNet: a lexical database for English. Commun. ACM

38, 11 (1995), 39–41.

[15] Pasquale Minervini, Claudia d’Amato, Nicola Fanizzi, and Floriana Esposito. 2015.
Efficient Learning of Entity and Predicate Embeddings for Link Prediction in
Knowledge Graphs.. In URSW@ ISWC. 26–37.

[16] Benjamin Recht, Christopher Re, Stephen Wright, and Feng Niu. 2011. Hogwild:
A lock-free approach to parallelizing stochastic gradient descent. In Advances in
Neural Information Processing Systems. 693–701.

[17] Sebastian Ruder. 2016. An overview of gradient descent optimization algorithms.

[18] Bin Shao, Yatao Li, and Haixun Wang. 2015. Parallel Processing of Graphs.

(2016).

(2015).

[19] Zhen Wang, Jianwen Zhang, Jianlin Feng, and Zheng Chen. 2014. Knowledge
Graph Embedding by Translating on Hyperplanes. AAAI - Association for the
Advancement of Artificial Intelligence (2014).

[20] Sixin Zhang, Anna Choromanska, and Yann Lecun. 2015. Deep learning with

Elastic Averaging SGD. Computer Science (2015), 685–693.

6https://github.com/zdh2292390/ParTrans-X

WN18

FB15k

Figure 4: Log-log plot of Training Time along with number
of processors

number of mutli-processors on both WN18 and FB15k. While the ab-
solute training time of ParTransE-AdaGrad is better than ParTransE,
which is better than ParTransH, consistent with the previous re-
sult. Moreover, the total training time of ParTransE-AdaGrad drops
sharply when processor number is less than four, it is because the
training time of ParTransE-AdaGrad with few processors is fairly
short, the increase of communication time cost with the more pro-
cessors has larger effect on the total training time compared with
other methods, which leads to small decline.

WN18

FB15k

Figure 5: Hits@10 performance along with number of pro-
cessors

The predictive performance measured by Hits@10 along with
increasing number of processors is shown in Figure5. It can be
seen that ParTransE, ParTransE-AdaGrad and ParTransH always
maintain good performance, which validates the applicability and
superiority of ParTrans-X. Note that the performance on FB15k is
more stable than WN18, since there are more training triples in
FB15k, and the model will learn more sufficient so that the stability
of predictive performance is better on FB15k, which validates the
superiority of ParTrans-X on large data size.

6 CONCLUSION
In this paper, we explore the law of collisions emerging in knowl-
edge graphs by modelling training data to hypergraphs. Our key
observation is that one learning iteration only concerns few em-
beddings, which is not necessarily bound up with others, thus the
probability of collisions between different processors can be negli-
gible. Based on this assumption, we propose an efficient parallel
framework for translating embedding methods, called ParTrans-X.
It employs the intrinsic sparsity of training data in large knowl-
edge graphs, which enables the embedding vectors to be learnt
without locks and not inducing errors. Experiments validate that

