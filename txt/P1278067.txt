5
1
0
2
 
v
o
N
 
3
 
 
]
L
P
.
s
c
[
 
 
1
v
5
1
9
0
0
.
1
1
5
1
:
v
i
X
r
a

SWISH: SWI-Prolog for Sharing

Jan Wielemaker1 and Torbj¨orn Lager2 and Fabrizio Riguzzi3

1 Web and Media group, VU University Amsterdam, The Netherlands,
J.Wielemaker@vu.nl
2 Department of Philosophy, Linguistics and Theory of Science, University of Gothenburg,
Sweden
Torbjorn.Lager@ling.gu.se
3 Dipartimento di Matematica e Informatica, University of Ferrara, Italy
Fabrizio.Riguzzi@unife.it

Abstract. Recently, we see a new type of interfaces for programmers based on
web technology. For example, JSFiddle, IPython Notebook and R-studio. Web
technology enables cloud-based solutions, embedding in tutorial web pages, at-
tractive rendering of results, web-scale cooperative development, etc. This article
describes SWISH, a web front-end for Prolog. A public website exposes SWI-
Prolog using SWISH, which is used to run small Prolog programs for demon-
stration, experimentation and education. We connected SWISH to the ClioPatria
semantic web toolkit, where it allows for collaborative development of programs
and queries related to a dataset as well as performing maintenance tasks on the
running server and we embedded SWISH in the Learn Prolog Now! online Prolog
book.

1

Introduction

Web technology has emerged to a state where it becomes useable for implement-
ing programming development environments. All major modern browsers now imple-
ment HTML5 and JavaScript and there are mature components available such as the
CodeMirror4 and ACE5 code editors, the Bootstrap6 framework for styling and UI wid-
gets and vizualization libraries such as D3.js.7 Using web technology rather than tra-
ditional GUI based technology such as Eclipse,8 Microsoft Visual Studio,9 XEmacs,10
etc. has various advantages. Being network transparent, it allows for controlling cloud
hosted applications as well as Prolog processes running on headless devices. Web tech-
nology provides a great infrastructure for mashups, pages that integrate material from
several sources. For example, embedding Prolog in tutorial pages or embedding Prolog
queries that can be modiﬁed and re-evaluated in documents that describe data collec-
tions.

4 https://codemirror.net/
5 http://ace.c9.io
6 http://getbootstrap.com/
7 http://d3js.org/
8 https://eclipse.org/
9 https://www.visualstudio.com/
10 http://www.xemacs.org/

With SWISH (SWI-Prolog for Sharing), we provide this technology for (SWI-
)Prolog. SWISH consists of JavaScript client (browser) code and a number of Prolog
libraries that realise the server as a Prolog application. The client code consists of a
series of jQuery11 plugins that deal with editing source code, managing a shared source
repository, entering queries and rendering answers produced by Prolog. The server-side
libraries serve the overall web application, implement the source store and support the
editor with predicate documentation, templates, cross-reference results, etc. For exe-
cuting Prolog queries, SWISH relies on Pengines (Prolog engines, [3]). A pengine is
a Prolog engine that can be controlled similarly to Prolog running in a terminal using
HTTP requests. The SWISH infrastructure was originally developed as a Prolog ver-
sion of JSFiddle. It was later reimplemented as a modular jQuery based infrastructure
aiming at collaborative exploration of data hosted on a SQL or SPARQL server. This
use-case is described in section 5.2.

This article is organised as follows. Section 2 describes related work, which in our
case are the systems that have inspired us. Section 3 describes the architecture and
components of SWISH. In section 5 we describe four applications of the current system.
We conclude with future work and conclusions.

2 Related work

We are not aware of other initiatives that aim at developing a rich web-based develop-
ment environment for Prolog. We do not compare SWISH with traditional editor or GUI
based development environments for Prolog because web-based environments provide
new opportunities and pose new challenges. Instead, we discuss three applications that
have served as inspiration for SWISH: JSFiddle,12 R-Studio13 and IPython Notebook.14

– As stated, the initial inspiration for SWISH was JSFiddle. Unlike JSFiddle though,

Prolog is executed on the server rather than in the browser.

– R-Studio [2] is an interface to the R statistical package. Although not a web applica-
tion, it is based on the Qt webkit framework and uses web based technology in the
background. R-Studio came into the picture when the COMMIT/ project provided
a grant for developing SWISH as a toolkit for analysis of relational (SQL) data.
The R-studio interface has a similar layout as SWISH, providing a source window,
a console and an output plane that typically shows results in tables or charts.

– IPython Notebook [5] allows mixing markdown or HTML text with Python
sources. The rendered Notebook shows the text, sources and possible results in
the form of numbers, tables or charts.

SWISH embodies most of the ideas behind JSFiddle and R-Studio. Embedding of
SWISH in documents is demonstrated in section 5.3. Interactive editing of documents
that embed SWISH is discussed in future work (section 6).

11 https://jquery.com/
12 https://jsfiddle.net/
13 http://www.rstudio.com/
14 http://ipython.org/notebook.html

100

Both R-Studio and IPython Notebook work on the basis of authentication (either to
the OS or application), after which any command may be executed. SWISH can operate
both as a public service granting access to non-intrusive queries and as an authenticated
service to run arbitrary queries, for example for maintenance purposes. See section 5.2.

3 The SWISH application

SWISH consists of two parts. The client side, running in a browser, is implemented
as a series of jQuery plugins, using Bootstrap for styling and RequireJS15 for package
management. The server side is completely implemented in SWI-Prolog [7]. It builds on
top of the SWI-Prolog HTTP server libraries, the Pengines library and the IDE support
libraries that provide data for auto completion, documentation and highlighting.

In the following sections we describe SWISH in terms of interface components,
where we discuss the requirements, the user aspects, the client code and supporting
server functionality for each component. First, we provide a screendump that illustrates
the main components in ﬁgure 1.

Fig. 1. Screendump of SWISH. The left pane shows the source code, while the top-right pane
shows a query runner that exploits the current selected answer renderer and buttons on how to
continue after the ﬁrst answer. The bottom-right pane provides the query editor with access to
example queries stored in the source, query history, apply solution modiﬁers, result presentation
and a Run! button to start the query.

15 http://requirejs.org/

101

3.1 The code editor

A proper editor is the most important component of a usable programming environment.
The editor must support the language, including syntax highlighting, auto indentation,
code completion based on templates and already existing code and highlighting of errors
and warning from the compiler. The editor is used both for editing the source code and
editing queries.

Prolog is a difﬁcult language to support in code editors due to the lack of reserved
keywords, e.g., the word if in C starts an if-statement if not embedded in comment or
a string, but the word is in Prolog can refer to the built-in predicate is/2, but also some
predicate with a different arity, just a constant, etc. Another example is X-Y which can
both be an arithmetic expression or a pair as used with e.g., keysort/2. Next to the
lack of keywords the ability to extend the syntax using new operators complicates the
implementation of syntax support while editing. SWI-Prolog’s built-in Emacs oriented
editor resolves this problem by closely integrating Prolog with the editor. While typing,
the current term (clause or directive) is parsed and analysed in the context of the current
ﬁle and the ﬁle’s imports after each keystroke. If the term has valid syntax, all tokens
are coloured according to their syntactic role as well their relation to the remainder of
the program. For example, a call to a non-existing predicate is coloured red, a call to a
built-in or imported predicate is blue and a call to a locally deﬁned predicate is black.
The libraries that implement this analysis have been decoupled from the built-in editor,
both to support source colouring for the SWI-Prolog documentation system PlDoc [6]
and ProDT16

There are two dominant open source and actively maintained in-browser code edi-
tors available: ACE and CodeMirror. When we started SWISH, ACE had a very basic
Prolog mode and CodeMirror had none. We nevertheless opted for CodeMirror be-
cause its highlighting is based on raw JavaScript code rather than a regular expression
based template language as used for ACE. The low level implementation allows for
a novel highlighting implementation. The highlighter consists of a JavaScript imple-
mented Prolog tokeniser. Tokenizing Prolog is sufﬁcient to colour comments, quoted
material (strings, quoted atoms), variables and constants (atoms and numbers). It is
also sufﬁcient to support smart indentation. As discussed above, it is not sufﬁcient for
highlighting the role played by atoms and compound terms.17

We provide semantic highlighting as illustrated in ﬁgure 2 by (1) forwarding the
changes to the content of the editor to the server server which maintains a mirror of the
editor content and (2) asking the server to produce a list of semantically enriched tokens
for the source. The tokens are returned as a list-of-lists, where each inner list represents
the tokens for a source term (clause or directive). Grouping the tokens per source term
allows for incremental update (not yet implemented) as well as re-synchronisation (see
below). For example, a fragment of an enriched token list may look like this: [ functor,
(undeﬁned goal), variable (singleton), . . . ]. The JavaScript tokeniser matches its tokens

16 http://prodevtools.sourceforge.net, these libraries are not yet used by ProDT.
17 An additional complication is formed by CodeMirror’s token-based highlighting which does
not support look-ahead. As a consequence, we must decide on the colour of e.g., asserta(
while we do not know the arity of the term.

102

Fig. 2. The semantic highlighter classiﬁes, in addition to the syntactic category such as comment
or variable, terms that deﬁne or call predicates based on cross-referencing the source code.

with this list. If the basic type (e.g., ‘functor’ or ‘variable’) matches, it uses the enrich-
ment information (e.g., ‘singleton’) to decide on the style. If the basic token type does
not match, it highlights the token using the basic syntactical category and schedules a
request to the server for a new list of enriched tokens. This request is sent if the user
pauses typing for 2 seconds. The request is accompanied by the full source if this is
small or the list of changes since the last request if the source is large. While waiting
for up-to-date enriched tokens, the JavaScript highlighting code heuristically tries to
re-synchronise and either uses the uncertain results or falls back to the plain tokens.
Re-synchronisation checks whether a single added, deleted or modiﬁed token gets the
token stream in-sync. If this fails it tries to re-synchronise on a full-stop with the next
clause or directive.

A CodeMirror hover plugin is used to show basic information about tokens if the
pointer hovers over it. For goals, this includes where the goal is deﬁned (ISO, SWI-
Prolog built-in, a library, locally) and the documentation summary information if avail-
able. This information is requested from the server.

template

A CodeMirror

(e.g.,
is
atom length(+Atom, -Length)) extracted from the SWI-Prolog manual
and PlDoc documentation of imported libraries. This plugin shows a menu of
applicable predicates with their templates on Control-Space.

from templates

conﬁgured

plugin

Finally, if the user uses the Run! button to execute a query, the program is compiled.
If the compiler generates errors or warnings, these are inserted as notes in the source
code.

3.2 Source code and query management

As JSFiddle formed the initial inspiration for SWISH, SWISH has a facility to save the
program. The current version of SWISH explicitly targets the cooperative development

103

of Prolog programs and queries related to a dataset (see section 5.2). This triggered the
implementation of a more organised storage facility. The server-side storage module is
implemented in Prolog and inspired by GIT. Each ﬁle is versioned independently rather
than maintaining the version of a hierarchy of ﬁles. Files can be referenced by content
using their GIT compatible SHA1 hash or by name. The name can be considered a
version head and refers to the latest version with that name. The ﬁle save and load
interface provides the following operations:

– Saving a ﬁle anonymously, which produces a randomly generated URL similar to

– Saving a ﬁle by name.
– Saving a new version. The interface shows the available versions and the modiﬁca-

JSFiddle.

tions.

– Forking a ﬁle under a new name. The history remains linked to the original.

Prolog

source ﬁles

include
:- include(filename).,

other
using
including
:- include(hash). to include a speciﬁc version.

can

sources
the

on

the
latest

same
version

server
or

Prolog source ﬁles can embed example queries using structured comments, where
each sequence from ?- to the matching full stop token is added to the Examples menu
of the query panel (see ﬁgure 6). The comment below illustrates a call to append/3
embedded in the source window.

/** <examples>

?- append([one], [two,three], List).
*/

3.3 The query editor

The query editor is based on the same jQuery plugin that realises the code editor and
thus proﬁts from the syntax highlighting, template insertion and hovering plugins. In
addition, it provides three popup menus:

Examples This menu is ﬁlled from the structured comments described above. The ex-

amples menu is shown in ﬁgure 6.

History This menu provides earlier executed queries.
Solutions This menu embeds an existing query in a meta-call to alter the result. Cur-
rently provided operations are Aggregate (count all), Order by, Distinct, Limit, Time
and Debug (trace). Figure 3 shows how the menu is used to count the solutions of
a goal.

104

Fig. 3. The Solutions menu can be used to count results, order them, ﬁlter duplicates, etc. The
upper runner shows answers to the query as a table.

3.4 Running a query: runners in the answer pane

The answer pane is a placeholder for runners, where each runner represents a query. The
answer pane provides a menu for operations on all runners inside it. Provided actions are
Collapse all, Expand all, Stop all and Clear. The query may be completed, running
or waiting for user input. SWISH can manage multiple active queries at the same time,
up to an application deﬁned maximum (default 3).

Each runner provides its own set of commands to control the speciﬁc query. During
execution a runner provides an Abort button. After query evaluation completes with an
answer and more answers may be available the runner allows for asking the next 1, 10,
100 or 1,000 results or to Stop the query. In addition, the runner shows a text input ﬁeld
when the application wants to read input and may show debugger interaction buttons if
the tracer is being used (see section 3.4).

A runner can render answers in two modes, the classical Prolog mode or as a ta-
ble, similar to what many database interfaces provide. The ‘table’ mode is particularly
appealing for querying datasets (see ﬁgure 3), while the former is more suitable for ren-
dering small amounts of complex answers such as the chessboard position in ﬁgure 1.
By default, Prolog terms are rendered as structured HTML objects, where the rendered
text is the same as Prolog’s writeq/1 predicate.

The server can provide rendering libraries that render Prolog terms using
the ‘chess’ renderer is loaded due to the :-
dedicated HTML. In ﬁgure 1,
use rendering(chess) directive. The ‘chess’ renderer translates a list of length
N holding integers in the range 1..N as a chessboard with queens. In addition to the
chess rendering library, SWISH provides rendering libraries for sudoku puzzles, parse
trees and tables. The ClioPatria version adds a renderer for RDF resources that renders
the resource more compactly and provides a hyperlink for obtaining details. If a term

105

can be rendered in multiple ways, the interface provides a hover menu to select between
the alternatives. Figure 4 illustrates this functionality. The render facility is similar to the
Prolog portray/1 hook that allows changing the result printed for terms with a speciﬁc
shape. However, it can exploit the full potential of HTML (or SVG) and the interface
allow for switching the selected rendering.

A rendering library is a module that must deﬁne a non-terminal (grammar rule)
term rendering//3, calling html//118 to produce HTML from the Prolog input
term, a list of variable bindings (Name = Variable) and user provided options. In the
current version, new rendering modules must be loaded into the SWISH server and
cannot be created by the SWISH user.

Fig. 4. With the ‘chess’ render library, a list of integers is interpreted as queens on a chessboard.
The user can select rendering as a ‘Prolog term’ to see the actual term.

Server side execution of the query Server-side execution of a query is supported
by the Pengines [3] library. The Pengines library allows for creating a Prolog engine
represented by a Prolog thread. Optionally, the pengine is handed a Prolog program that
is loaded into the pengine’s workspace (program space). The workspace is a temporary
module that is disposed of after the pengine terminates. The pengine may be asked
questions through HTTP queries, similar to a traditional Prolog user interacting with
Prolog running in a terminal.19

If the SWISH user hits the Run! button, the content of the source pane is used to
create a new pengine. Subsequently, the content of the query pane is sent as the one and
only query that will be executed by the pengine.20 Before execution, the query is veriﬁed
to be safe, unless sandboxing is disabled (see section 5.2). The sandbox component is
discussed below.

18 http://www.swi-prolog.org/pldoc/doc for?object=html/3
19 https://www.youtube.com/watch?v=G_eYTctGZw8
20 Pengines can execute multiple queries. We do not use this facility because a fresh pengine

starts in a predictable state (standard operators, empty dynamic database).

106

The pengine’s default working module may be pre-loaded with code. SWISH uses
this facility to redeﬁne the Prolog I/O predicates such as read/1, write/1, format/1,2,3,
etc. The ClioPatria version (section 5.2) also preloads the RDF libraries, so users can
run queries on the RDF database without explicitly importing the required libraries.

Sandboxing queries A Prolog environment contains global state in the form of loaded
modules, deﬁned operators, dynamic predicates, etc. Prolog exposes a rich and poten-
tially dangerous interface to the operating system. For an anonymous services, we want
each query to start in a well deﬁned state and we must ensure that execution of the query
does not make unwanted changes to the hosting computer or leaks sensitive informa-
tion.

Both for education purposes and data analysis one can write meaningful programs
without making permanent changes to the server or the server’s ﬁlesystem. That is
where the sandbox library comes in. The sandbox library is active while loading the
source, where it refuses to add clauses to other modules than the pengine’s workspace
and where it only accepts a restricted set of directives, also aimed at keeping all changes
local to the workspace. Prior to execution, the sandbox unfolds the query and compares
all reachable goals with a whitelist. The whitelist contains all side-effect free built-in
Prolog predicates, safe meta-predicates (e.g., ﬁndall/3) and allows for using the dy-
namic database, provided that the head of the affected predicate is not module-qualiﬁed
(and thus the referenced predicate lives in the temporary program space of the Pengine)
and the body is safe. It does not allow for cross-module calls (Module:Goal) to private
predicates and does not provide access to object-enumeration predicates such as cur-
rent atom/1, current predicate/1, etc., both to avoid leaking sensitive information.

The sandbox test fails under one of these conditions:

– It discovers a (meta-) goal for which it cannot deduce the called code. The tradi-
tional example is read(X), call(X). If such a goal is encountered, it signals
an instantiation error, together with a trace that explains how the insufﬁciently
instantiated goal can be reached. Note that it can deal with normal high-order pred-
icates if the meta-argument is speciﬁed. For example, the following goal is accepted
as safe.

?- maplist(plus(1), [1,2,3])

– It discovers a goal that is not whitelisted. In this case it signals a permission error,
again accompanied with a trace that explains how the goal can be reached. Note that
pure Prolog predicates are unfolded, also if it concerns predicates from the libraries
or belonging to the set of built in predicates.

– It discovers a cross-module (M:Goal) call to a predicate that is not public. Nor-
mally, SWI-Prolog, in the tradition of Quintus Prolog, allows for this. Allowing it
in SWISH would imply that no data can be kept secret. With this limitation, libraries
can keep data in local dynamic predicates that remain invisible to non-authorised
users.

Debugging The SWISH debugger is based on the traditional 4-port debugging model
for Prolog. Figure 5 shows the tracer in action on sublist/2 from the Lists example

107

source. The debugger was triggered by a break-point on line 10 set by clicking on the
line-number in the code editor. The debugging interaction is deliberately kept simple
and similar to traditional programming environments. A retry button is added to the
commonly seen ‘step into’, ‘step over’ and ‘step out’ for highlighting the unique feature
of Prolog to re-evaluate a goal.

Fig. 5. Debugging applications in SWISH

4 Portability

The SWISH client libraries are based on mature and well maintained JavaScript li-
braries. The client runs all modern major browsers with HTML5, CSS and JavaScript
support. It is frequently tested on FireFox, Chrome, Safari and Internet Explorer 11.

The server code is basically non-portable. Many of the required libraries and fea-
tures are shared with at least one other Prolog implementation, but none is capable to
support the full range. Below we summarise the main problems.

– The scale of the involved Prolog libraries demands for a closely compatible Prolog
module system. Probably only SICStus and YAP can be used without signiﬁcant
rewrites.

108

– The HTTP server libraries are heavily based on C code that interacts with the SWI-
Prolog foreign language interface to Prolog streams. YAP has copied the low-level
libraries and is capable to run (an old version of) these libraries.

– The Pengines library depends on the HTTP library and the multi-thread interface.

The SWI-Prolog thread API is also provided by YAP and XSB.

– The sandbox library (section 3.4) assumes that whitelisted predicates are indeed
safe. This requires robust handling of invalid calls and resource overﬂows. Few
Prolog systems can satisfy this requirement. SICStus Prolog would be a candidate,
but SICStus does not support multi-threading.

– The semantic syntax highlighting depends on detailed source layout information
provided by read term/3. SWI-Prolog’s support for term layout is an extended
version of the Quintus Prolog term layout functionality.

– Signiﬁcant parts of the code rely on SWI-Prolog version 7 extensions, notably the
dict and string types that facilitate a natural mapping between Prolog and JSON
data.

From the above list it should be clear that a fully functional port of SWISH to
another Prolog system is not immediately feasible. YAP probably comes closest but
still requires a signiﬁcant amount of work.

There is a more realistic scenario though. In this setup, SWI-Prolog provides the
web interface and most of the development tools and another language, not even neces-
sarily Prolog, provides the query solving. The interface between the two can be based
on interprocess communication or, if the target system is robust, safe and capable of
supporting threads, by linking the target system into the process and using the C inter-
face for communication.

In this section we describe and evaluate four publicly available SWISH applications.
All these services are regularly updated to run the latest version of SWISH and SWI-
Prolog.

5 Applications

5.1 SWISH

SWISH21 runs a plain publicly accessible copy of SWISH that allows running sand-
boxed (see section 3.4) Prolog programs. The server has collected 10,800 programs
between September 29, 2014 and June 2, 2015. Over the month May 2015, it has exe-
cuted 258,809 Prolog queries. The web site is regularly used by users of the ##prolog
IRC channel to discuss programming solutions and is in active use for education.22

21 http://swish.swi-prolog.org
22 Steve Matuszek, UMBC (via e-mail: “Thank you very much for this fantastic resource! I used
it while teaching Prolog this semester, and it really helped tighten the loop for my students.
We spent zero time on tool installation and other overhead, and all the time on understanding
the concepts. I even had them turn their assignments in via SWISH, with their test queries in
the examples block.”

109

5.2 ClioPatria

ClioPatria is a semantic web (RDF) framework for SWI-Prolog. It consists of an RDF
triple store, a SPARQL server and a web frontend to manage the server and explore
the data in the RDF store. ClioPatria can be extended using cpacks (ClioPatria pack or
plugin). SWISH is available as a ClioPatria cpack23 and makes the Prolog shell avail-
able for querying as well as maintenance tasks. Without login, user can run side-effect
free queries over the RDF data stored in ClioPatria’s RDF database. After login with
administrative rights, the sandbox limitations are lifted and the Prolog shell can be used
to perform maintenance tasks on the RDF data such as data transformation, cleanup,
etc., as well as program maintenance tasks such as reloading modiﬁed source ﬁles.

SWISH has been used in the Talk Of Europe creative camp24 to explore data on the
speeches in the European parliament.25 Although still immature, users appreciated the
ability to deﬁne more efﬁcient and expressive queries than provided by the SPARQL
query interface. Above all, the ability to save and share programs that perform interest-
ing tasks on the data was frequently used, in particular to seek help ﬁxing queries.

5.3 Learn Prolog Now!

Learn Prolog Now!26 is an online version of a Prolog book by Patrick Blackburn, Johan
Bos, and Kristina Striegnitz [1]. We established a proof of concept that embeds SWISH
in the online course material.27 It is realised as a Prolog hosted proxy that fetches the
pages from the main site and serves the enhanced pages to the user. The proxy identiﬁes
and classiﬁes the code fragments in terms of ‘source code’ ‘queries’ and dependencies.
Next, it adds a button to the source fragments that, when pressed, replaces the HTML
<pre> element with in <iframe> running SWISH ﬁlled with the source while the
example queries are added to the Examples menu (ﬁgure 6). The queries are executed
by http://swish.swi-prolog.org. Program and queries are transferred using
the following HTTP parameters: code (the source code), background (source code
that is loaded into the pengine but not visible in the editor), examples (queries that ap-
pear in the Examples menu) and q (the initial query). The proxy server served 19,700
pages during May 2015.

5.4 cplint on SWISH

cplint on SWISH28 is a web application based on SWISH for reasoning with prob-
abilistic logic programs under the distribution semantics. The Prolog source window
is used to write a logic program with annotated disjunction. A query in the form of a
ground atom is answered by returning its probability of being true in the program. The
computation of the probability is done with the cplint system [4] in the server using

23 http://cliopatria.swi-prolog.org/packs/swish
24 http://www.talkofeurope.eu/
25 http://purl.org/linkedpolitics
26 http://www.learnprolognow.org
27 http://lpn.swi-prolog.org
28 http://cplint.lamping.unife.it/

110

Fig. 6. Screendump of Learn Prolog Now with opened SWISH instance that shows the collected
source as well as example queries from the subsequent text that are classiﬁed as relating to this
source. The embedded SWISH provides all functionality available in the stand-alone SWISH. If
the user presses the close button, SWISH will be removed and the original code re-appears.

Pengines. The input program is translated into an internal representation using source
to source transformation.

SWISH was modiﬁed only in the JavaScript code for the runner. The source code
is prepended code for loading the cplint library and enabling the source to source
transformation while the query is wrapped into a call of the inference predicate. This
call has a variable argument Prob which will hold the probability and will be shown to
the user in the answer pane.

5.5 TRILL on SWISH

TRILL on SWISH29 is a probabilistic OWL reasoner that reuses SWISH. As SWISH
for ClioPatria, described in section 5.2, it is a ClioPatria cpack. The Prolog source win-
dow is replaced by an RDF/XML editor window that can be used to upload an OWL
ontology while the query editor can be used to pose Prolog queries against the OWL

29 http://trill.lamping.unife.it/

111

ontology. The probability of queries is computed using TRILL [8], a reasoner in Prolog
that adopts the distribution semantics for probabilistic description logics.

Also for TRILL on SWISH we had only to modify the JavaScript code for the
runner. The source code sent to the Pengine is obtained by adding Prolog code for
parsing an RDF/XML string, by calling the parsing predicate and by wrapping the query
in a meta-call that performs syntactic checks for misspellings.

6 Future work

Although deﬁnitely usable in its current state, SWISH is work in progress. We are con-
ﬁdent that the basic component selection and organisation of the server and client code
are stable. More work is needed to improve the current system. Notably the semantic
highlighting is not yet perfect and often fails to degrade gradually if the server side an-
notation does not match the client tokens perfectly. The Pengine’s sandbox protection is
often too restrictive, while several security ﬂaws have been reported and ﬁxed already.
It is, and probably always will be, advised to run public SWISH-enabled services in
an operating system sandbox. The current server suffers from memory leaks and stabil-
ity problems. Although the situation has improved signiﬁcantly, the main demo server
needs to be restarted about once a week.30

We foresee several extensions to SWISH that will improve current applications and

enable new opportunities for deploying SWISH.

– ClioPatria’s authorised usage of SWISH shows some of the potential for control-
ling servers or embedded Prolog engines. In addition to small temporary Prolog
programs, we would like to be able to edit existing and create new Prolog mod-
ules as well as pages in other languages, such as JavaScript, HTML and CSS. Full
editing capabilities would allow for shared development of server software without
shell access to the server on which SWISH enabled software is running.

– Multi-document editing can enhance the sandboxed SWISH application by pro-
viding input and output documents. Compare this to TRILL (section 5.5) using an
RDF/XML document as input.

– We plan to provide a markdown-based format speciﬁcally for writing tutorials and
well as dataset analysis documents. The ﬁrst will look like the Learn Prolog Now!
example discussed in section 5.3. For the second, we envision a document with
embedded code and query fragments, where the query fragments produce tables or
charts. This is similar to IPython Notebook.

– Turn http://swish.swi-prolog.org into a reliable and scalable resource.
Examine the possibility for schools to instantiate a private version that is preloaded
with course material and assignments.

30 A restart of the server has only small consequences to active users. Open queries are killed.
The source code mirror is lost, but automatically recovered if the client asks for a new set of
semantically enriched tokens.

112

7 Conclusion

This article presented SWISH, SWI-Prolog for Sharing. SWISH provides a web-
enabled interface to Prolog that is based on ideas from JSFiddle, R-Studio and IPython
Notebook. It consists of a JavaScript client side, while the server side is based on SWI-
Prolog’s HTTP and Pengines (Prolog engines) libraries. SWISH can be deployed in
many settings, such as education, data analysis and server development and mainte-
nance. SWISH as a whole is tied to SWI-Prolog, but other languages, not even limited
to Prolog, could be controlled from SWI-Prolog. SWISH is made available as open
source and can be downloaded from github.31

The development of SWISH was supported by the Dutch national program COMMIT/.

Acknowledgements

References

Publications, 2006.

14(4-5):539–552, 2014.

1. Patrick Blackburn, Johan Bos, and Kristina Striegnitz. Learn prolog now!, volume 7. College

2. Christopher Gandrud. Reproducible Research with R and R Studio. CRC Press, 2013.
3. Torbj¨orn Lager and Jan Wielemaker. Pengines: Web logic programming made easy. TPLP,

4. Fabrizio Riguzzi and Terrance Swift. Well-deﬁnedness and efﬁcient inference for probabilistic
logic programming under the distribution semantics. Theory Pract. Log. Program., 13(Special
Issue 02 - 25th Annual GULP Conference):279–302, March 2013.

5. Cyrille Rossant. Learning IPython for interactive computing and data visualization. Packt

Publishing Ltd, 2013.

6. Jan Wielemaker and Anjo Anjewierden. PlDoc: Wiki style literate programming for Prolog.
In Patricia Hill and Wim Vanhoof, editors, Proceedings of the 17th Workshop on Logic-Based
methods in Programming Environments, pages 16–30, 2007.

7. Jan Wielemaker, Zhisheng Huang, and Lourens van der Meij. Swi-prolog and the web. TPLP,

8(3):363–392, 2008.

8. Riccardo Zese, Elena Bellodi, Evelina Lamma, Fabrizio Riguzzi, and Fabiano Aguiari. Se-
mantics and inference for probabilistic description logics. In Uncertainty Reasoning for the
Semantic Web III, volume 8816 of LNCS, pages 79–99. Springer, 2014.

31 https://github.com/SWI-Prolog/swish

113

5
1
0
2
 
v
o
N
 
3
 
 
]
L
P
.
s
c
[
 
 
1
v
5
1
9
0
0
.
1
1
5
1
:
v
i
X
r
a

SWISH: SWI-Prolog for Sharing

Jan Wielemaker1 and Torbj¨orn Lager2 and Fabrizio Riguzzi3

1 Web and Media group, VU University Amsterdam, The Netherlands,
J.Wielemaker@vu.nl
2 Department of Philosophy, Linguistics and Theory of Science, University of Gothenburg,
Sweden
Torbjorn.Lager@ling.gu.se
3 Dipartimento di Matematica e Informatica, University of Ferrara, Italy
Fabrizio.Riguzzi@unife.it

Abstract. Recently, we see a new type of interfaces for programmers based on
web technology. For example, JSFiddle, IPython Notebook and R-studio. Web
technology enables cloud-based solutions, embedding in tutorial web pages, at-
tractive rendering of results, web-scale cooperative development, etc. This article
describes SWISH, a web front-end for Prolog. A public website exposes SWI-
Prolog using SWISH, which is used to run small Prolog programs for demon-
stration, experimentation and education. We connected SWISH to the ClioPatria
semantic web toolkit, where it allows for collaborative development of programs
and queries related to a dataset as well as performing maintenance tasks on the
running server and we embedded SWISH in the Learn Prolog Now! online Prolog
book.

1

Introduction

Web technology has emerged to a state where it becomes useable for implement-
ing programming development environments. All major modern browsers now imple-
ment HTML5 and JavaScript and there are mature components available such as the
CodeMirror4 and ACE5 code editors, the Bootstrap6 framework for styling and UI wid-
gets and vizualization libraries such as D3.js.7 Using web technology rather than tra-
ditional GUI based technology such as Eclipse,8 Microsoft Visual Studio,9 XEmacs,10
etc. has various advantages. Being network transparent, it allows for controlling cloud
hosted applications as well as Prolog processes running on headless devices. Web tech-
nology provides a great infrastructure for mashups, pages that integrate material from
several sources. For example, embedding Prolog in tutorial pages or embedding Prolog
queries that can be modiﬁed and re-evaluated in documents that describe data collec-
tions.

4 https://codemirror.net/
5 http://ace.c9.io
6 http://getbootstrap.com/
7 http://d3js.org/
8 https://eclipse.org/
9 https://www.visualstudio.com/
10 http://www.xemacs.org/

With SWISH (SWI-Prolog for Sharing), we provide this technology for (SWI-
)Prolog. SWISH consists of JavaScript client (browser) code and a number of Prolog
libraries that realise the server as a Prolog application. The client code consists of a
series of jQuery11 plugins that deal with editing source code, managing a shared source
repository, entering queries and rendering answers produced by Prolog. The server-side
libraries serve the overall web application, implement the source store and support the
editor with predicate documentation, templates, cross-reference results, etc. For exe-
cuting Prolog queries, SWISH relies on Pengines (Prolog engines, [3]). A pengine is
a Prolog engine that can be controlled similarly to Prolog running in a terminal using
HTTP requests. The SWISH infrastructure was originally developed as a Prolog ver-
sion of JSFiddle. It was later reimplemented as a modular jQuery based infrastructure
aiming at collaborative exploration of data hosted on a SQL or SPARQL server. This
use-case is described in section 5.2.

This article is organised as follows. Section 2 describes related work, which in our
case are the systems that have inspired us. Section 3 describes the architecture and
components of SWISH. In section 5 we describe four applications of the current system.
We conclude with future work and conclusions.

2 Related work

We are not aware of other initiatives that aim at developing a rich web-based develop-
ment environment for Prolog. We do not compare SWISH with traditional editor or GUI
based development environments for Prolog because web-based environments provide
new opportunities and pose new challenges. Instead, we discuss three applications that
have served as inspiration for SWISH: JSFiddle,12 R-Studio13 and IPython Notebook.14

– As stated, the initial inspiration for SWISH was JSFiddle. Unlike JSFiddle though,

Prolog is executed on the server rather than in the browser.

– R-Studio [2] is an interface to the R statistical package. Although not a web applica-
tion, it is based on the Qt webkit framework and uses web based technology in the
background. R-Studio came into the picture when the COMMIT/ project provided
a grant for developing SWISH as a toolkit for analysis of relational (SQL) data.
The R-studio interface has a similar layout as SWISH, providing a source window,
a console and an output plane that typically shows results in tables or charts.

– IPython Notebook [5] allows mixing markdown or HTML text with Python
sources. The rendered Notebook shows the text, sources and possible results in
the form of numbers, tables or charts.

SWISH embodies most of the ideas behind JSFiddle and R-Studio. Embedding of
SWISH in documents is demonstrated in section 5.3. Interactive editing of documents
that embed SWISH is discussed in future work (section 6).

11 https://jquery.com/
12 https://jsfiddle.net/
13 http://www.rstudio.com/
14 http://ipython.org/notebook.html

100

Both R-Studio and IPython Notebook work on the basis of authentication (either to
the OS or application), after which any command may be executed. SWISH can operate
both as a public service granting access to non-intrusive queries and as an authenticated
service to run arbitrary queries, for example for maintenance purposes. See section 5.2.

3 The SWISH application

SWISH consists of two parts. The client side, running in a browser, is implemented
as a series of jQuery plugins, using Bootstrap for styling and RequireJS15 for package
management. The server side is completely implemented in SWI-Prolog [7]. It builds on
top of the SWI-Prolog HTTP server libraries, the Pengines library and the IDE support
libraries that provide data for auto completion, documentation and highlighting.

In the following sections we describe SWISH in terms of interface components,
where we discuss the requirements, the user aspects, the client code and supporting
server functionality for each component. First, we provide a screendump that illustrates
the main components in ﬁgure 1.

Fig. 1. Screendump of SWISH. The left pane shows the source code, while the top-right pane
shows a query runner that exploits the current selected answer renderer and buttons on how to
continue after the ﬁrst answer. The bottom-right pane provides the query editor with access to
example queries stored in the source, query history, apply solution modiﬁers, result presentation
and a Run! button to start the query.

15 http://requirejs.org/

101

3.1 The code editor

A proper editor is the most important component of a usable programming environment.
The editor must support the language, including syntax highlighting, auto indentation,
code completion based on templates and already existing code and highlighting of errors
and warning from the compiler. The editor is used both for editing the source code and
editing queries.

Prolog is a difﬁcult language to support in code editors due to the lack of reserved
keywords, e.g., the word if in C starts an if-statement if not embedded in comment or
a string, but the word is in Prolog can refer to the built-in predicate is/2, but also some
predicate with a different arity, just a constant, etc. Another example is X-Y which can
both be an arithmetic expression or a pair as used with e.g., keysort/2. Next to the
lack of keywords the ability to extend the syntax using new operators complicates the
implementation of syntax support while editing. SWI-Prolog’s built-in Emacs oriented
editor resolves this problem by closely integrating Prolog with the editor. While typing,
the current term (clause or directive) is parsed and analysed in the context of the current
ﬁle and the ﬁle’s imports after each keystroke. If the term has valid syntax, all tokens
are coloured according to their syntactic role as well their relation to the remainder of
the program. For example, a call to a non-existing predicate is coloured red, a call to a
built-in or imported predicate is blue and a call to a locally deﬁned predicate is black.
The libraries that implement this analysis have been decoupled from the built-in editor,
both to support source colouring for the SWI-Prolog documentation system PlDoc [6]
and ProDT16

There are two dominant open source and actively maintained in-browser code edi-
tors available: ACE and CodeMirror. When we started SWISH, ACE had a very basic
Prolog mode and CodeMirror had none. We nevertheless opted for CodeMirror be-
cause its highlighting is based on raw JavaScript code rather than a regular expression
based template language as used for ACE. The low level implementation allows for
a novel highlighting implementation. The highlighter consists of a JavaScript imple-
mented Prolog tokeniser. Tokenizing Prolog is sufﬁcient to colour comments, quoted
material (strings, quoted atoms), variables and constants (atoms and numbers). It is
also sufﬁcient to support smart indentation. As discussed above, it is not sufﬁcient for
highlighting the role played by atoms and compound terms.17

We provide semantic highlighting as illustrated in ﬁgure 2 by (1) forwarding the
changes to the content of the editor to the server server which maintains a mirror of the
editor content and (2) asking the server to produce a list of semantically enriched tokens
for the source. The tokens are returned as a list-of-lists, where each inner list represents
the tokens for a source term (clause or directive). Grouping the tokens per source term
allows for incremental update (not yet implemented) as well as re-synchronisation (see
below). For example, a fragment of an enriched token list may look like this: [ functor,
(undeﬁned goal), variable (singleton), . . . ]. The JavaScript tokeniser matches its tokens

16 http://prodevtools.sourceforge.net, these libraries are not yet used by ProDT.
17 An additional complication is formed by CodeMirror’s token-based highlighting which does
not support look-ahead. As a consequence, we must decide on the colour of e.g., asserta(
while we do not know the arity of the term.

102

Fig. 2. The semantic highlighter classiﬁes, in addition to the syntactic category such as comment
or variable, terms that deﬁne or call predicates based on cross-referencing the source code.

with this list. If the basic type (e.g., ‘functor’ or ‘variable’) matches, it uses the enrich-
ment information (e.g., ‘singleton’) to decide on the style. If the basic token type does
not match, it highlights the token using the basic syntactical category and schedules a
request to the server for a new list of enriched tokens. This request is sent if the user
pauses typing for 2 seconds. The request is accompanied by the full source if this is
small or the list of changes since the last request if the source is large. While waiting
for up-to-date enriched tokens, the JavaScript highlighting code heuristically tries to
re-synchronise and either uses the uncertain results or falls back to the plain tokens.
Re-synchronisation checks whether a single added, deleted or modiﬁed token gets the
token stream in-sync. If this fails it tries to re-synchronise on a full-stop with the next
clause or directive.

A CodeMirror hover plugin is used to show basic information about tokens if the
pointer hovers over it. For goals, this includes where the goal is deﬁned (ISO, SWI-
Prolog built-in, a library, locally) and the documentation summary information if avail-
able. This information is requested from the server.

template

A CodeMirror

(e.g.,
is
atom length(+Atom, -Length)) extracted from the SWI-Prolog manual
and PlDoc documentation of imported libraries. This plugin shows a menu of
applicable predicates with their templates on Control-Space.

from templates

conﬁgured

plugin

Finally, if the user uses the Run! button to execute a query, the program is compiled.
If the compiler generates errors or warnings, these are inserted as notes in the source
code.

3.2 Source code and query management

As JSFiddle formed the initial inspiration for SWISH, SWISH has a facility to save the
program. The current version of SWISH explicitly targets the cooperative development

103

of Prolog programs and queries related to a dataset (see section 5.2). This triggered the
implementation of a more organised storage facility. The server-side storage module is
implemented in Prolog and inspired by GIT. Each ﬁle is versioned independently rather
than maintaining the version of a hierarchy of ﬁles. Files can be referenced by content
using their GIT compatible SHA1 hash or by name. The name can be considered a
version head and refers to the latest version with that name. The ﬁle save and load
interface provides the following operations:

– Saving a ﬁle anonymously, which produces a randomly generated URL similar to

– Saving a ﬁle by name.
– Saving a new version. The interface shows the available versions and the modiﬁca-

JSFiddle.

tions.

– Forking a ﬁle under a new name. The history remains linked to the original.

Prolog

source ﬁles

include
:- include(filename).,

other
using
including
:- include(hash). to include a speciﬁc version.

can

sources
the

on

the
latest

same
version

server
or

Prolog source ﬁles can embed example queries using structured comments, where
each sequence from ?- to the matching full stop token is added to the Examples menu
of the query panel (see ﬁgure 6). The comment below illustrates a call to append/3
embedded in the source window.

/** <examples>

?- append([one], [two,three], List).
*/

3.3 The query editor

The query editor is based on the same jQuery plugin that realises the code editor and
thus proﬁts from the syntax highlighting, template insertion and hovering plugins. In
addition, it provides three popup menus:

Examples This menu is ﬁlled from the structured comments described above. The ex-

amples menu is shown in ﬁgure 6.

History This menu provides earlier executed queries.
Solutions This menu embeds an existing query in a meta-call to alter the result. Cur-
rently provided operations are Aggregate (count all), Order by, Distinct, Limit, Time
and Debug (trace). Figure 3 shows how the menu is used to count the solutions of
a goal.

104

Fig. 3. The Solutions menu can be used to count results, order them, ﬁlter duplicates, etc. The
upper runner shows answers to the query as a table.

3.4 Running a query: runners in the answer pane

The answer pane is a placeholder for runners, where each runner represents a query. The
answer pane provides a menu for operations on all runners inside it. Provided actions are
Collapse all, Expand all, Stop all and Clear. The query may be completed, running
or waiting for user input. SWISH can manage multiple active queries at the same time,
up to an application deﬁned maximum (default 3).

Each runner provides its own set of commands to control the speciﬁc query. During
execution a runner provides an Abort button. After query evaluation completes with an
answer and more answers may be available the runner allows for asking the next 1, 10,
100 or 1,000 results or to Stop the query. In addition, the runner shows a text input ﬁeld
when the application wants to read input and may show debugger interaction buttons if
the tracer is being used (see section 3.4).

A runner can render answers in two modes, the classical Prolog mode or as a ta-
ble, similar to what many database interfaces provide. The ‘table’ mode is particularly
appealing for querying datasets (see ﬁgure 3), while the former is more suitable for ren-
dering small amounts of complex answers such as the chessboard position in ﬁgure 1.
By default, Prolog terms are rendered as structured HTML objects, where the rendered
text is the same as Prolog’s writeq/1 predicate.

The server can provide rendering libraries that render Prolog terms using
the ‘chess’ renderer is loaded due to the :-
dedicated HTML. In ﬁgure 1,
use rendering(chess) directive. The ‘chess’ renderer translates a list of length
N holding integers in the range 1..N as a chessboard with queens. In addition to the
chess rendering library, SWISH provides rendering libraries for sudoku puzzles, parse
trees and tables. The ClioPatria version adds a renderer for RDF resources that renders
the resource more compactly and provides a hyperlink for obtaining details. If a term

105

can be rendered in multiple ways, the interface provides a hover menu to select between
the alternatives. Figure 4 illustrates this functionality. The render facility is similar to the
Prolog portray/1 hook that allows changing the result printed for terms with a speciﬁc
shape. However, it can exploit the full potential of HTML (or SVG) and the interface
allow for switching the selected rendering.

A rendering library is a module that must deﬁne a non-terminal (grammar rule)
term rendering//3, calling html//118 to produce HTML from the Prolog input
term, a list of variable bindings (Name = Variable) and user provided options. In the
current version, new rendering modules must be loaded into the SWISH server and
cannot be created by the SWISH user.

Fig. 4. With the ‘chess’ render library, a list of integers is interpreted as queens on a chessboard.
The user can select rendering as a ‘Prolog term’ to see the actual term.

Server side execution of the query Server-side execution of a query is supported
by the Pengines [3] library. The Pengines library allows for creating a Prolog engine
represented by a Prolog thread. Optionally, the pengine is handed a Prolog program that
is loaded into the pengine’s workspace (program space). The workspace is a temporary
module that is disposed of after the pengine terminates. The pengine may be asked
questions through HTTP queries, similar to a traditional Prolog user interacting with
Prolog running in a terminal.19

If the SWISH user hits the Run! button, the content of the source pane is used to
create a new pengine. Subsequently, the content of the query pane is sent as the one and
only query that will be executed by the pengine.20 Before execution, the query is veriﬁed
to be safe, unless sandboxing is disabled (see section 5.2). The sandbox component is
discussed below.

18 http://www.swi-prolog.org/pldoc/doc for?object=html/3
19 https://www.youtube.com/watch?v=G_eYTctGZw8
20 Pengines can execute multiple queries. We do not use this facility because a fresh pengine

starts in a predictable state (standard operators, empty dynamic database).

106

The pengine’s default working module may be pre-loaded with code. SWISH uses
this facility to redeﬁne the Prolog I/O predicates such as read/1, write/1, format/1,2,3,
etc. The ClioPatria version (section 5.2) also preloads the RDF libraries, so users can
run queries on the RDF database without explicitly importing the required libraries.

Sandboxing queries A Prolog environment contains global state in the form of loaded
modules, deﬁned operators, dynamic predicates, etc. Prolog exposes a rich and poten-
tially dangerous interface to the operating system. For an anonymous services, we want
each query to start in a well deﬁned state and we must ensure that execution of the query
does not make unwanted changes to the hosting computer or leaks sensitive informa-
tion.

Both for education purposes and data analysis one can write meaningful programs
without making permanent changes to the server or the server’s ﬁlesystem. That is
where the sandbox library comes in. The sandbox library is active while loading the
source, where it refuses to add clauses to other modules than the pengine’s workspace
and where it only accepts a restricted set of directives, also aimed at keeping all changes
local to the workspace. Prior to execution, the sandbox unfolds the query and compares
all reachable goals with a whitelist. The whitelist contains all side-effect free built-in
Prolog predicates, safe meta-predicates (e.g., ﬁndall/3) and allows for using the dy-
namic database, provided that the head of the affected predicate is not module-qualiﬁed
(and thus the referenced predicate lives in the temporary program space of the Pengine)
and the body is safe. It does not allow for cross-module calls (Module:Goal) to private
predicates and does not provide access to object-enumeration predicates such as cur-
rent atom/1, current predicate/1, etc., both to avoid leaking sensitive information.

The sandbox test fails under one of these conditions:

– It discovers a (meta-) goal for which it cannot deduce the called code. The tradi-
tional example is read(X), call(X). If such a goal is encountered, it signals
an instantiation error, together with a trace that explains how the insufﬁciently
instantiated goal can be reached. Note that it can deal with normal high-order pred-
icates if the meta-argument is speciﬁed. For example, the following goal is accepted
as safe.

?- maplist(plus(1), [1,2,3])

– It discovers a goal that is not whitelisted. In this case it signals a permission error,
again accompanied with a trace that explains how the goal can be reached. Note that
pure Prolog predicates are unfolded, also if it concerns predicates from the libraries
or belonging to the set of built in predicates.

– It discovers a cross-module (M:Goal) call to a predicate that is not public. Nor-
mally, SWI-Prolog, in the tradition of Quintus Prolog, allows for this. Allowing it
in SWISH would imply that no data can be kept secret. With this limitation, libraries
can keep data in local dynamic predicates that remain invisible to non-authorised
users.

Debugging The SWISH debugger is based on the traditional 4-port debugging model
for Prolog. Figure 5 shows the tracer in action on sublist/2 from the Lists example

107

source. The debugger was triggered by a break-point on line 10 set by clicking on the
line-number in the code editor. The debugging interaction is deliberately kept simple
and similar to traditional programming environments. A retry button is added to the
commonly seen ‘step into’, ‘step over’ and ‘step out’ for highlighting the unique feature
of Prolog to re-evaluate a goal.

Fig. 5. Debugging applications in SWISH

4 Portability

The SWISH client libraries are based on mature and well maintained JavaScript li-
braries. The client runs all modern major browsers with HTML5, CSS and JavaScript
support. It is frequently tested on FireFox, Chrome, Safari and Internet Explorer 11.

The server code is basically non-portable. Many of the required libraries and fea-
tures are shared with at least one other Prolog implementation, but none is capable to
support the full range. Below we summarise the main problems.

– The scale of the involved Prolog libraries demands for a closely compatible Prolog
module system. Probably only SICStus and YAP can be used without signiﬁcant
rewrites.

108

– The HTTP server libraries are heavily based on C code that interacts with the SWI-
Prolog foreign language interface to Prolog streams. YAP has copied the low-level
libraries and is capable to run (an old version of) these libraries.

– The Pengines library depends on the HTTP library and the multi-thread interface.

The SWI-Prolog thread API is also provided by YAP and XSB.

– The sandbox library (section 3.4) assumes that whitelisted predicates are indeed
safe. This requires robust handling of invalid calls and resource overﬂows. Few
Prolog systems can satisfy this requirement. SICStus Prolog would be a candidate,
but SICStus does not support multi-threading.

– The semantic syntax highlighting depends on detailed source layout information
provided by read term/3. SWI-Prolog’s support for term layout is an extended
version of the Quintus Prolog term layout functionality.

– Signiﬁcant parts of the code rely on SWI-Prolog version 7 extensions, notably the
dict and string types that facilitate a natural mapping between Prolog and JSON
data.

From the above list it should be clear that a fully functional port of SWISH to
another Prolog system is not immediately feasible. YAP probably comes closest but
still requires a signiﬁcant amount of work.

There is a more realistic scenario though. In this setup, SWI-Prolog provides the
web interface and most of the development tools and another language, not even neces-
sarily Prolog, provides the query solving. The interface between the two can be based
on interprocess communication or, if the target system is robust, safe and capable of
supporting threads, by linking the target system into the process and using the C inter-
face for communication.

In this section we describe and evaluate four publicly available SWISH applications.
All these services are regularly updated to run the latest version of SWISH and SWI-
Prolog.

5 Applications

5.1 SWISH

SWISH21 runs a plain publicly accessible copy of SWISH that allows running sand-
boxed (see section 3.4) Prolog programs. The server has collected 10,800 programs
between September 29, 2014 and June 2, 2015. Over the month May 2015, it has exe-
cuted 258,809 Prolog queries. The web site is regularly used by users of the ##prolog
IRC channel to discuss programming solutions and is in active use for education.22

21 http://swish.swi-prolog.org
22 Steve Matuszek, UMBC (via e-mail: “Thank you very much for this fantastic resource! I used
it while teaching Prolog this semester, and it really helped tighten the loop for my students.
We spent zero time on tool installation and other overhead, and all the time on understanding
the concepts. I even had them turn their assignments in via SWISH, with their test queries in
the examples block.”

109

5.2 ClioPatria

ClioPatria is a semantic web (RDF) framework for SWI-Prolog. It consists of an RDF
triple store, a SPARQL server and a web frontend to manage the server and explore
the data in the RDF store. ClioPatria can be extended using cpacks (ClioPatria pack or
plugin). SWISH is available as a ClioPatria cpack23 and makes the Prolog shell avail-
able for querying as well as maintenance tasks. Without login, user can run side-effect
free queries over the RDF data stored in ClioPatria’s RDF database. After login with
administrative rights, the sandbox limitations are lifted and the Prolog shell can be used
to perform maintenance tasks on the RDF data such as data transformation, cleanup,
etc., as well as program maintenance tasks such as reloading modiﬁed source ﬁles.

SWISH has been used in the Talk Of Europe creative camp24 to explore data on the
speeches in the European parliament.25 Although still immature, users appreciated the
ability to deﬁne more efﬁcient and expressive queries than provided by the SPARQL
query interface. Above all, the ability to save and share programs that perform interest-
ing tasks on the data was frequently used, in particular to seek help ﬁxing queries.

5.3 Learn Prolog Now!

Learn Prolog Now!26 is an online version of a Prolog book by Patrick Blackburn, Johan
Bos, and Kristina Striegnitz [1]. We established a proof of concept that embeds SWISH
in the online course material.27 It is realised as a Prolog hosted proxy that fetches the
pages from the main site and serves the enhanced pages to the user. The proxy identiﬁes
and classiﬁes the code fragments in terms of ‘source code’ ‘queries’ and dependencies.
Next, it adds a button to the source fragments that, when pressed, replaces the HTML
<pre> element with in <iframe> running SWISH ﬁlled with the source while the
example queries are added to the Examples menu (ﬁgure 6). The queries are executed
by http://swish.swi-prolog.org. Program and queries are transferred using
the following HTTP parameters: code (the source code), background (source code
that is loaded into the pengine but not visible in the editor), examples (queries that ap-
pear in the Examples menu) and q (the initial query). The proxy server served 19,700
pages during May 2015.

5.4 cplint on SWISH

cplint on SWISH28 is a web application based on SWISH for reasoning with prob-
abilistic logic programs under the distribution semantics. The Prolog source window
is used to write a logic program with annotated disjunction. A query in the form of a
ground atom is answered by returning its probability of being true in the program. The
computation of the probability is done with the cplint system [4] in the server using

23 http://cliopatria.swi-prolog.org/packs/swish
24 http://www.talkofeurope.eu/
25 http://purl.org/linkedpolitics
26 http://www.learnprolognow.org
27 http://lpn.swi-prolog.org
28 http://cplint.lamping.unife.it/

110

Fig. 6. Screendump of Learn Prolog Now with opened SWISH instance that shows the collected
source as well as example queries from the subsequent text that are classiﬁed as relating to this
source. The embedded SWISH provides all functionality available in the stand-alone SWISH. If
the user presses the close button, SWISH will be removed and the original code re-appears.

Pengines. The input program is translated into an internal representation using source
to source transformation.

SWISH was modiﬁed only in the JavaScript code for the runner. The source code
is prepended code for loading the cplint library and enabling the source to source
transformation while the query is wrapped into a call of the inference predicate. This
call has a variable argument Prob which will hold the probability and will be shown to
the user in the answer pane.

5.5 TRILL on SWISH

TRILL on SWISH29 is a probabilistic OWL reasoner that reuses SWISH. As SWISH
for ClioPatria, described in section 5.2, it is a ClioPatria cpack. The Prolog source win-
dow is replaced by an RDF/XML editor window that can be used to upload an OWL
ontology while the query editor can be used to pose Prolog queries against the OWL

29 http://trill.lamping.unife.it/

111

ontology. The probability of queries is computed using TRILL [8], a reasoner in Prolog
that adopts the distribution semantics for probabilistic description logics.

Also for TRILL on SWISH we had only to modify the JavaScript code for the
runner. The source code sent to the Pengine is obtained by adding Prolog code for
parsing an RDF/XML string, by calling the parsing predicate and by wrapping the query
in a meta-call that performs syntactic checks for misspellings.

6 Future work

Although deﬁnitely usable in its current state, SWISH is work in progress. We are con-
ﬁdent that the basic component selection and organisation of the server and client code
are stable. More work is needed to improve the current system. Notably the semantic
highlighting is not yet perfect and often fails to degrade gradually if the server side an-
notation does not match the client tokens perfectly. The Pengine’s sandbox protection is
often too restrictive, while several security ﬂaws have been reported and ﬁxed already.
It is, and probably always will be, advised to run public SWISH-enabled services in
an operating system sandbox. The current server suffers from memory leaks and stabil-
ity problems. Although the situation has improved signiﬁcantly, the main demo server
needs to be restarted about once a week.30

We foresee several extensions to SWISH that will improve current applications and

enable new opportunities for deploying SWISH.

– ClioPatria’s authorised usage of SWISH shows some of the potential for control-
ling servers or embedded Prolog engines. In addition to small temporary Prolog
programs, we would like to be able to edit existing and create new Prolog mod-
ules as well as pages in other languages, such as JavaScript, HTML and CSS. Full
editing capabilities would allow for shared development of server software without
shell access to the server on which SWISH enabled software is running.

– Multi-document editing can enhance the sandboxed SWISH application by pro-
viding input and output documents. Compare this to TRILL (section 5.5) using an
RDF/XML document as input.

– We plan to provide a markdown-based format speciﬁcally for writing tutorials and
well as dataset analysis documents. The ﬁrst will look like the Learn Prolog Now!
example discussed in section 5.3. For the second, we envision a document with
embedded code and query fragments, where the query fragments produce tables or
charts. This is similar to IPython Notebook.

– Turn http://swish.swi-prolog.org into a reliable and scalable resource.
Examine the possibility for schools to instantiate a private version that is preloaded
with course material and assignments.

30 A restart of the server has only small consequences to active users. Open queries are killed.
The source code mirror is lost, but automatically recovered if the client asks for a new set of
semantically enriched tokens.

112

7 Conclusion

This article presented SWISH, SWI-Prolog for Sharing. SWISH provides a web-
enabled interface to Prolog that is based on ideas from JSFiddle, R-Studio and IPython
Notebook. It consists of a JavaScript client side, while the server side is based on SWI-
Prolog’s HTTP and Pengines (Prolog engines) libraries. SWISH can be deployed in
many settings, such as education, data analysis and server development and mainte-
nance. SWISH as a whole is tied to SWI-Prolog, but other languages, not even limited
to Prolog, could be controlled from SWI-Prolog. SWISH is made available as open
source and can be downloaded from github.31

The development of SWISH was supported by the Dutch national program COMMIT/.

Acknowledgements

References

Publications, 2006.

14(4-5):539–552, 2014.

1. Patrick Blackburn, Johan Bos, and Kristina Striegnitz. Learn prolog now!, volume 7. College

2. Christopher Gandrud. Reproducible Research with R and R Studio. CRC Press, 2013.
3. Torbj¨orn Lager and Jan Wielemaker. Pengines: Web logic programming made easy. TPLP,

4. Fabrizio Riguzzi and Terrance Swift. Well-deﬁnedness and efﬁcient inference for probabilistic
logic programming under the distribution semantics. Theory Pract. Log. Program., 13(Special
Issue 02 - 25th Annual GULP Conference):279–302, March 2013.

5. Cyrille Rossant. Learning IPython for interactive computing and data visualization. Packt

Publishing Ltd, 2013.

6. Jan Wielemaker and Anjo Anjewierden. PlDoc: Wiki style literate programming for Prolog.
In Patricia Hill and Wim Vanhoof, editors, Proceedings of the 17th Workshop on Logic-Based
methods in Programming Environments, pages 16–30, 2007.

7. Jan Wielemaker, Zhisheng Huang, and Lourens van der Meij. Swi-prolog and the web. TPLP,

8(3):363–392, 2008.

8. Riccardo Zese, Elena Bellodi, Evelina Lamma, Fabrizio Riguzzi, and Fabiano Aguiari. Se-
mantics and inference for probabilistic description logics. In Uncertainty Reasoning for the
Semantic Web III, volume 8816 of LNCS, pages 79–99. Springer, 2014.

31 https://github.com/SWI-Prolog/swish

113

5
1
0
2
 
v
o
N
 
3
 
 
]
L
P
.
s
c
[
 
 
1
v
5
1
9
0
0
.
1
1
5
1
:
v
i
X
r
a

SWISH: SWI-Prolog for Sharing

Jan Wielemaker1 and Torbj¨orn Lager2 and Fabrizio Riguzzi3

1 Web and Media group, VU University Amsterdam, The Netherlands,
J.Wielemaker@vu.nl
2 Department of Philosophy, Linguistics and Theory of Science, University of Gothenburg,
Sweden
Torbjorn.Lager@ling.gu.se
3 Dipartimento di Matematica e Informatica, University of Ferrara, Italy
Fabrizio.Riguzzi@unife.it

Abstract. Recently, we see a new type of interfaces for programmers based on
web technology. For example, JSFiddle, IPython Notebook and R-studio. Web
technology enables cloud-based solutions, embedding in tutorial web pages, at-
tractive rendering of results, web-scale cooperative development, etc. This article
describes SWISH, a web front-end for Prolog. A public website exposes SWI-
Prolog using SWISH, which is used to run small Prolog programs for demon-
stration, experimentation and education. We connected SWISH to the ClioPatria
semantic web toolkit, where it allows for collaborative development of programs
and queries related to a dataset as well as performing maintenance tasks on the
running server and we embedded SWISH in the Learn Prolog Now! online Prolog
book.

1

Introduction

Web technology has emerged to a state where it becomes useable for implement-
ing programming development environments. All major modern browsers now imple-
ment HTML5 and JavaScript and there are mature components available such as the
CodeMirror4 and ACE5 code editors, the Bootstrap6 framework for styling and UI wid-
gets and vizualization libraries such as D3.js.7 Using web technology rather than tra-
ditional GUI based technology such as Eclipse,8 Microsoft Visual Studio,9 XEmacs,10
etc. has various advantages. Being network transparent, it allows for controlling cloud
hosted applications as well as Prolog processes running on headless devices. Web tech-
nology provides a great infrastructure for mashups, pages that integrate material from
several sources. For example, embedding Prolog in tutorial pages or embedding Prolog
queries that can be modiﬁed and re-evaluated in documents that describe data collec-
tions.

4 https://codemirror.net/
5 http://ace.c9.io
6 http://getbootstrap.com/
7 http://d3js.org/
8 https://eclipse.org/
9 https://www.visualstudio.com/
10 http://www.xemacs.org/

With SWISH (SWI-Prolog for Sharing), we provide this technology for (SWI-
)Prolog. SWISH consists of JavaScript client (browser) code and a number of Prolog
libraries that realise the server as a Prolog application. The client code consists of a
series of jQuery11 plugins that deal with editing source code, managing a shared source
repository, entering queries and rendering answers produced by Prolog. The server-side
libraries serve the overall web application, implement the source store and support the
editor with predicate documentation, templates, cross-reference results, etc. For exe-
cuting Prolog queries, SWISH relies on Pengines (Prolog engines, [3]). A pengine is
a Prolog engine that can be controlled similarly to Prolog running in a terminal using
HTTP requests. The SWISH infrastructure was originally developed as a Prolog ver-
sion of JSFiddle. It was later reimplemented as a modular jQuery based infrastructure
aiming at collaborative exploration of data hosted on a SQL or SPARQL server. This
use-case is described in section 5.2.

This article is organised as follows. Section 2 describes related work, which in our
case are the systems that have inspired us. Section 3 describes the architecture and
components of SWISH. In section 5 we describe four applications of the current system.
We conclude with future work and conclusions.

2 Related work

We are not aware of other initiatives that aim at developing a rich web-based develop-
ment environment for Prolog. We do not compare SWISH with traditional editor or GUI
based development environments for Prolog because web-based environments provide
new opportunities and pose new challenges. Instead, we discuss three applications that
have served as inspiration for SWISH: JSFiddle,12 R-Studio13 and IPython Notebook.14

– As stated, the initial inspiration for SWISH was JSFiddle. Unlike JSFiddle though,

Prolog is executed on the server rather than in the browser.

– R-Studio [2] is an interface to the R statistical package. Although not a web applica-
tion, it is based on the Qt webkit framework and uses web based technology in the
background. R-Studio came into the picture when the COMMIT/ project provided
a grant for developing SWISH as a toolkit for analysis of relational (SQL) data.
The R-studio interface has a similar layout as SWISH, providing a source window,
a console and an output plane that typically shows results in tables or charts.

– IPython Notebook [5] allows mixing markdown or HTML text with Python
sources. The rendered Notebook shows the text, sources and possible results in
the form of numbers, tables or charts.

SWISH embodies most of the ideas behind JSFiddle and R-Studio. Embedding of
SWISH in documents is demonstrated in section 5.3. Interactive editing of documents
that embed SWISH is discussed in future work (section 6).

11 https://jquery.com/
12 https://jsfiddle.net/
13 http://www.rstudio.com/
14 http://ipython.org/notebook.html

100

Both R-Studio and IPython Notebook work on the basis of authentication (either to
the OS or application), after which any command may be executed. SWISH can operate
both as a public service granting access to non-intrusive queries and as an authenticated
service to run arbitrary queries, for example for maintenance purposes. See section 5.2.

3 The SWISH application

SWISH consists of two parts. The client side, running in a browser, is implemented
as a series of jQuery plugins, using Bootstrap for styling and RequireJS15 for package
management. The server side is completely implemented in SWI-Prolog [7]. It builds on
top of the SWI-Prolog HTTP server libraries, the Pengines library and the IDE support
libraries that provide data for auto completion, documentation and highlighting.

In the following sections we describe SWISH in terms of interface components,
where we discuss the requirements, the user aspects, the client code and supporting
server functionality for each component. First, we provide a screendump that illustrates
the main components in ﬁgure 1.

Fig. 1. Screendump of SWISH. The left pane shows the source code, while the top-right pane
shows a query runner that exploits the current selected answer renderer and buttons on how to
continue after the ﬁrst answer. The bottom-right pane provides the query editor with access to
example queries stored in the source, query history, apply solution modiﬁers, result presentation
and a Run! button to start the query.

15 http://requirejs.org/

101

3.1 The code editor

A proper editor is the most important component of a usable programming environment.
The editor must support the language, including syntax highlighting, auto indentation,
code completion based on templates and already existing code and highlighting of errors
and warning from the compiler. The editor is used both for editing the source code and
editing queries.

Prolog is a difﬁcult language to support in code editors due to the lack of reserved
keywords, e.g., the word if in C starts an if-statement if not embedded in comment or
a string, but the word is in Prolog can refer to the built-in predicate is/2, but also some
predicate with a different arity, just a constant, etc. Another example is X-Y which can
both be an arithmetic expression or a pair as used with e.g., keysort/2. Next to the
lack of keywords the ability to extend the syntax using new operators complicates the
implementation of syntax support while editing. SWI-Prolog’s built-in Emacs oriented
editor resolves this problem by closely integrating Prolog with the editor. While typing,
the current term (clause or directive) is parsed and analysed in the context of the current
ﬁle and the ﬁle’s imports after each keystroke. If the term has valid syntax, all tokens
are coloured according to their syntactic role as well their relation to the remainder of
the program. For example, a call to a non-existing predicate is coloured red, a call to a
built-in or imported predicate is blue and a call to a locally deﬁned predicate is black.
The libraries that implement this analysis have been decoupled from the built-in editor,
both to support source colouring for the SWI-Prolog documentation system PlDoc [6]
and ProDT16

There are two dominant open source and actively maintained in-browser code edi-
tors available: ACE and CodeMirror. When we started SWISH, ACE had a very basic
Prolog mode and CodeMirror had none. We nevertheless opted for CodeMirror be-
cause its highlighting is based on raw JavaScript code rather than a regular expression
based template language as used for ACE. The low level implementation allows for
a novel highlighting implementation. The highlighter consists of a JavaScript imple-
mented Prolog tokeniser. Tokenizing Prolog is sufﬁcient to colour comments, quoted
material (strings, quoted atoms), variables and constants (atoms and numbers). It is
also sufﬁcient to support smart indentation. As discussed above, it is not sufﬁcient for
highlighting the role played by atoms and compound terms.17

We provide semantic highlighting as illustrated in ﬁgure 2 by (1) forwarding the
changes to the content of the editor to the server server which maintains a mirror of the
editor content and (2) asking the server to produce a list of semantically enriched tokens
for the source. The tokens are returned as a list-of-lists, where each inner list represents
the tokens for a source term (clause or directive). Grouping the tokens per source term
allows for incremental update (not yet implemented) as well as re-synchronisation (see
below). For example, a fragment of an enriched token list may look like this: [ functor,
(undeﬁned goal), variable (singleton), . . . ]. The JavaScript tokeniser matches its tokens

16 http://prodevtools.sourceforge.net, these libraries are not yet used by ProDT.
17 An additional complication is formed by CodeMirror’s token-based highlighting which does
not support look-ahead. As a consequence, we must decide on the colour of e.g., asserta(
while we do not know the arity of the term.

102

Fig. 2. The semantic highlighter classiﬁes, in addition to the syntactic category such as comment
or variable, terms that deﬁne or call predicates based on cross-referencing the source code.

with this list. If the basic type (e.g., ‘functor’ or ‘variable’) matches, it uses the enrich-
ment information (e.g., ‘singleton’) to decide on the style. If the basic token type does
not match, it highlights the token using the basic syntactical category and schedules a
request to the server for a new list of enriched tokens. This request is sent if the user
pauses typing for 2 seconds. The request is accompanied by the full source if this is
small or the list of changes since the last request if the source is large. While waiting
for up-to-date enriched tokens, the JavaScript highlighting code heuristically tries to
re-synchronise and either uses the uncertain results or falls back to the plain tokens.
Re-synchronisation checks whether a single added, deleted or modiﬁed token gets the
token stream in-sync. If this fails it tries to re-synchronise on a full-stop with the next
clause or directive.

A CodeMirror hover plugin is used to show basic information about tokens if the
pointer hovers over it. For goals, this includes where the goal is deﬁned (ISO, SWI-
Prolog built-in, a library, locally) and the documentation summary information if avail-
able. This information is requested from the server.

template

A CodeMirror

(e.g.,
is
atom length(+Atom, -Length)) extracted from the SWI-Prolog manual
and PlDoc documentation of imported libraries. This plugin shows a menu of
applicable predicates with their templates on Control-Space.

from templates

conﬁgured

plugin

Finally, if the user uses the Run! button to execute a query, the program is compiled.
If the compiler generates errors or warnings, these are inserted as notes in the source
code.

3.2 Source code and query management

As JSFiddle formed the initial inspiration for SWISH, SWISH has a facility to save the
program. The current version of SWISH explicitly targets the cooperative development

103

of Prolog programs and queries related to a dataset (see section 5.2). This triggered the
implementation of a more organised storage facility. The server-side storage module is
implemented in Prolog and inspired by GIT. Each ﬁle is versioned independently rather
than maintaining the version of a hierarchy of ﬁles. Files can be referenced by content
using their GIT compatible SHA1 hash or by name. The name can be considered a
version head and refers to the latest version with that name. The ﬁle save and load
interface provides the following operations:

– Saving a ﬁle anonymously, which produces a randomly generated URL similar to

– Saving a ﬁle by name.
– Saving a new version. The interface shows the available versions and the modiﬁca-

JSFiddle.

tions.

– Forking a ﬁle under a new name. The history remains linked to the original.

Prolog

source ﬁles

include
:- include(filename).,

other
using
including
:- include(hash). to include a speciﬁc version.

can

sources
the

on

the
latest

same
version

server
or

Prolog source ﬁles can embed example queries using structured comments, where
each sequence from ?- to the matching full stop token is added to the Examples menu
of the query panel (see ﬁgure 6). The comment below illustrates a call to append/3
embedded in the source window.

/** <examples>

?- append([one], [two,three], List).
*/

3.3 The query editor

The query editor is based on the same jQuery plugin that realises the code editor and
thus proﬁts from the syntax highlighting, template insertion and hovering plugins. In
addition, it provides three popup menus:

Examples This menu is ﬁlled from the structured comments described above. The ex-

amples menu is shown in ﬁgure 6.

History This menu provides earlier executed queries.
Solutions This menu embeds an existing query in a meta-call to alter the result. Cur-
rently provided operations are Aggregate (count all), Order by, Distinct, Limit, Time
and Debug (trace). Figure 3 shows how the menu is used to count the solutions of
a goal.

104

Fig. 3. The Solutions menu can be used to count results, order them, ﬁlter duplicates, etc. The
upper runner shows answers to the query as a table.

3.4 Running a query: runners in the answer pane

The answer pane is a placeholder for runners, where each runner represents a query. The
answer pane provides a menu for operations on all runners inside it. Provided actions are
Collapse all, Expand all, Stop all and Clear. The query may be completed, running
or waiting for user input. SWISH can manage multiple active queries at the same time,
up to an application deﬁned maximum (default 3).

Each runner provides its own set of commands to control the speciﬁc query. During
execution a runner provides an Abort button. After query evaluation completes with an
answer and more answers may be available the runner allows for asking the next 1, 10,
100 or 1,000 results or to Stop the query. In addition, the runner shows a text input ﬁeld
when the application wants to read input and may show debugger interaction buttons if
the tracer is being used (see section 3.4).

A runner can render answers in two modes, the classical Prolog mode or as a ta-
ble, similar to what many database interfaces provide. The ‘table’ mode is particularly
appealing for querying datasets (see ﬁgure 3), while the former is more suitable for ren-
dering small amounts of complex answers such as the chessboard position in ﬁgure 1.
By default, Prolog terms are rendered as structured HTML objects, where the rendered
text is the same as Prolog’s writeq/1 predicate.

The server can provide rendering libraries that render Prolog terms using
the ‘chess’ renderer is loaded due to the :-
dedicated HTML. In ﬁgure 1,
use rendering(chess) directive. The ‘chess’ renderer translates a list of length
N holding integers in the range 1..N as a chessboard with queens. In addition to the
chess rendering library, SWISH provides rendering libraries for sudoku puzzles, parse
trees and tables. The ClioPatria version adds a renderer for RDF resources that renders
the resource more compactly and provides a hyperlink for obtaining details. If a term

105

can be rendered in multiple ways, the interface provides a hover menu to select between
the alternatives. Figure 4 illustrates this functionality. The render facility is similar to the
Prolog portray/1 hook that allows changing the result printed for terms with a speciﬁc
shape. However, it can exploit the full potential of HTML (or SVG) and the interface
allow for switching the selected rendering.

A rendering library is a module that must deﬁne a non-terminal (grammar rule)
term rendering//3, calling html//118 to produce HTML from the Prolog input
term, a list of variable bindings (Name = Variable) and user provided options. In the
current version, new rendering modules must be loaded into the SWISH server and
cannot be created by the SWISH user.

Fig. 4. With the ‘chess’ render library, a list of integers is interpreted as queens on a chessboard.
The user can select rendering as a ‘Prolog term’ to see the actual term.

Server side execution of the query Server-side execution of a query is supported
by the Pengines [3] library. The Pengines library allows for creating a Prolog engine
represented by a Prolog thread. Optionally, the pengine is handed a Prolog program that
is loaded into the pengine’s workspace (program space). The workspace is a temporary
module that is disposed of after the pengine terminates. The pengine may be asked
questions through HTTP queries, similar to a traditional Prolog user interacting with
Prolog running in a terminal.19

If the SWISH user hits the Run! button, the content of the source pane is used to
create a new pengine. Subsequently, the content of the query pane is sent as the one and
only query that will be executed by the pengine.20 Before execution, the query is veriﬁed
to be safe, unless sandboxing is disabled (see section 5.2). The sandbox component is
discussed below.

18 http://www.swi-prolog.org/pldoc/doc for?object=html/3
19 https://www.youtube.com/watch?v=G_eYTctGZw8
20 Pengines can execute multiple queries. We do not use this facility because a fresh pengine

starts in a predictable state (standard operators, empty dynamic database).

106

The pengine’s default working module may be pre-loaded with code. SWISH uses
this facility to redeﬁne the Prolog I/O predicates such as read/1, write/1, format/1,2,3,
etc. The ClioPatria version (section 5.2) also preloads the RDF libraries, so users can
run queries on the RDF database without explicitly importing the required libraries.

Sandboxing queries A Prolog environment contains global state in the form of loaded
modules, deﬁned operators, dynamic predicates, etc. Prolog exposes a rich and poten-
tially dangerous interface to the operating system. For an anonymous services, we want
each query to start in a well deﬁned state and we must ensure that execution of the query
does not make unwanted changes to the hosting computer or leaks sensitive informa-
tion.

Both for education purposes and data analysis one can write meaningful programs
without making permanent changes to the server or the server’s ﬁlesystem. That is
where the sandbox library comes in. The sandbox library is active while loading the
source, where it refuses to add clauses to other modules than the pengine’s workspace
and where it only accepts a restricted set of directives, also aimed at keeping all changes
local to the workspace. Prior to execution, the sandbox unfolds the query and compares
all reachable goals with a whitelist. The whitelist contains all side-effect free built-in
Prolog predicates, safe meta-predicates (e.g., ﬁndall/3) and allows for using the dy-
namic database, provided that the head of the affected predicate is not module-qualiﬁed
(and thus the referenced predicate lives in the temporary program space of the Pengine)
and the body is safe. It does not allow for cross-module calls (Module:Goal) to private
predicates and does not provide access to object-enumeration predicates such as cur-
rent atom/1, current predicate/1, etc., both to avoid leaking sensitive information.

The sandbox test fails under one of these conditions:

– It discovers a (meta-) goal for which it cannot deduce the called code. The tradi-
tional example is read(X), call(X). If such a goal is encountered, it signals
an instantiation error, together with a trace that explains how the insufﬁciently
instantiated goal can be reached. Note that it can deal with normal high-order pred-
icates if the meta-argument is speciﬁed. For example, the following goal is accepted
as safe.

?- maplist(plus(1), [1,2,3])

– It discovers a goal that is not whitelisted. In this case it signals a permission error,
again accompanied with a trace that explains how the goal can be reached. Note that
pure Prolog predicates are unfolded, also if it concerns predicates from the libraries
or belonging to the set of built in predicates.

– It discovers a cross-module (M:Goal) call to a predicate that is not public. Nor-
mally, SWI-Prolog, in the tradition of Quintus Prolog, allows for this. Allowing it
in SWISH would imply that no data can be kept secret. With this limitation, libraries
can keep data in local dynamic predicates that remain invisible to non-authorised
users.

Debugging The SWISH debugger is based on the traditional 4-port debugging model
for Prolog. Figure 5 shows the tracer in action on sublist/2 from the Lists example

107

source. The debugger was triggered by a break-point on line 10 set by clicking on the
line-number in the code editor. The debugging interaction is deliberately kept simple
and similar to traditional programming environments. A retry button is added to the
commonly seen ‘step into’, ‘step over’ and ‘step out’ for highlighting the unique feature
of Prolog to re-evaluate a goal.

Fig. 5. Debugging applications in SWISH

4 Portability

The SWISH client libraries are based on mature and well maintained JavaScript li-
braries. The client runs all modern major browsers with HTML5, CSS and JavaScript
support. It is frequently tested on FireFox, Chrome, Safari and Internet Explorer 11.

The server code is basically non-portable. Many of the required libraries and fea-
tures are shared with at least one other Prolog implementation, but none is capable to
support the full range. Below we summarise the main problems.

– The scale of the involved Prolog libraries demands for a closely compatible Prolog
module system. Probably only SICStus and YAP can be used without signiﬁcant
rewrites.

108

– The HTTP server libraries are heavily based on C code that interacts with the SWI-
Prolog foreign language interface to Prolog streams. YAP has copied the low-level
libraries and is capable to run (an old version of) these libraries.

– The Pengines library depends on the HTTP library and the multi-thread interface.

The SWI-Prolog thread API is also provided by YAP and XSB.

– The sandbox library (section 3.4) assumes that whitelisted predicates are indeed
safe. This requires robust handling of invalid calls and resource overﬂows. Few
Prolog systems can satisfy this requirement. SICStus Prolog would be a candidate,
but SICStus does not support multi-threading.

– The semantic syntax highlighting depends on detailed source layout information
provided by read term/3. SWI-Prolog’s support for term layout is an extended
version of the Quintus Prolog term layout functionality.

– Signiﬁcant parts of the code rely on SWI-Prolog version 7 extensions, notably the
dict and string types that facilitate a natural mapping between Prolog and JSON
data.

From the above list it should be clear that a fully functional port of SWISH to
another Prolog system is not immediately feasible. YAP probably comes closest but
still requires a signiﬁcant amount of work.

There is a more realistic scenario though. In this setup, SWI-Prolog provides the
web interface and most of the development tools and another language, not even neces-
sarily Prolog, provides the query solving. The interface between the two can be based
on interprocess communication or, if the target system is robust, safe and capable of
supporting threads, by linking the target system into the process and using the C inter-
face for communication.

In this section we describe and evaluate four publicly available SWISH applications.
All these services are regularly updated to run the latest version of SWISH and SWI-
Prolog.

5 Applications

5.1 SWISH

SWISH21 runs a plain publicly accessible copy of SWISH that allows running sand-
boxed (see section 3.4) Prolog programs. The server has collected 10,800 programs
between September 29, 2014 and June 2, 2015. Over the month May 2015, it has exe-
cuted 258,809 Prolog queries. The web site is regularly used by users of the ##prolog
IRC channel to discuss programming solutions and is in active use for education.22

21 http://swish.swi-prolog.org
22 Steve Matuszek, UMBC (via e-mail: “Thank you very much for this fantastic resource! I used
it while teaching Prolog this semester, and it really helped tighten the loop for my students.
We spent zero time on tool installation and other overhead, and all the time on understanding
the concepts. I even had them turn their assignments in via SWISH, with their test queries in
the examples block.”

109

5.2 ClioPatria

ClioPatria is a semantic web (RDF) framework for SWI-Prolog. It consists of an RDF
triple store, a SPARQL server and a web frontend to manage the server and explore
the data in the RDF store. ClioPatria can be extended using cpacks (ClioPatria pack or
plugin). SWISH is available as a ClioPatria cpack23 and makes the Prolog shell avail-
able for querying as well as maintenance tasks. Without login, user can run side-effect
free queries over the RDF data stored in ClioPatria’s RDF database. After login with
administrative rights, the sandbox limitations are lifted and the Prolog shell can be used
to perform maintenance tasks on the RDF data such as data transformation, cleanup,
etc., as well as program maintenance tasks such as reloading modiﬁed source ﬁles.

SWISH has been used in the Talk Of Europe creative camp24 to explore data on the
speeches in the European parliament.25 Although still immature, users appreciated the
ability to deﬁne more efﬁcient and expressive queries than provided by the SPARQL
query interface. Above all, the ability to save and share programs that perform interest-
ing tasks on the data was frequently used, in particular to seek help ﬁxing queries.

5.3 Learn Prolog Now!

Learn Prolog Now!26 is an online version of a Prolog book by Patrick Blackburn, Johan
Bos, and Kristina Striegnitz [1]. We established a proof of concept that embeds SWISH
in the online course material.27 It is realised as a Prolog hosted proxy that fetches the
pages from the main site and serves the enhanced pages to the user. The proxy identiﬁes
and classiﬁes the code fragments in terms of ‘source code’ ‘queries’ and dependencies.
Next, it adds a button to the source fragments that, when pressed, replaces the HTML
<pre> element with in <iframe> running SWISH ﬁlled with the source while the
example queries are added to the Examples menu (ﬁgure 6). The queries are executed
by http://swish.swi-prolog.org. Program and queries are transferred using
the following HTTP parameters: code (the source code), background (source code
that is loaded into the pengine but not visible in the editor), examples (queries that ap-
pear in the Examples menu) and q (the initial query). The proxy server served 19,700
pages during May 2015.

5.4 cplint on SWISH

cplint on SWISH28 is a web application based on SWISH for reasoning with prob-
abilistic logic programs under the distribution semantics. The Prolog source window
is used to write a logic program with annotated disjunction. A query in the form of a
ground atom is answered by returning its probability of being true in the program. The
computation of the probability is done with the cplint system [4] in the server using

23 http://cliopatria.swi-prolog.org/packs/swish
24 http://www.talkofeurope.eu/
25 http://purl.org/linkedpolitics
26 http://www.learnprolognow.org
27 http://lpn.swi-prolog.org
28 http://cplint.lamping.unife.it/

110

Fig. 6. Screendump of Learn Prolog Now with opened SWISH instance that shows the collected
source as well as example queries from the subsequent text that are classiﬁed as relating to this
source. The embedded SWISH provides all functionality available in the stand-alone SWISH. If
the user presses the close button, SWISH will be removed and the original code re-appears.

Pengines. The input program is translated into an internal representation using source
to source transformation.

SWISH was modiﬁed only in the JavaScript code for the runner. The source code
is prepended code for loading the cplint library and enabling the source to source
transformation while the query is wrapped into a call of the inference predicate. This
call has a variable argument Prob which will hold the probability and will be shown to
the user in the answer pane.

5.5 TRILL on SWISH

TRILL on SWISH29 is a probabilistic OWL reasoner that reuses SWISH. As SWISH
for ClioPatria, described in section 5.2, it is a ClioPatria cpack. The Prolog source win-
dow is replaced by an RDF/XML editor window that can be used to upload an OWL
ontology while the query editor can be used to pose Prolog queries against the OWL

29 http://trill.lamping.unife.it/

111

ontology. The probability of queries is computed using TRILL [8], a reasoner in Prolog
that adopts the distribution semantics for probabilistic description logics.

Also for TRILL on SWISH we had only to modify the JavaScript code for the
runner. The source code sent to the Pengine is obtained by adding Prolog code for
parsing an RDF/XML string, by calling the parsing predicate and by wrapping the query
in a meta-call that performs syntactic checks for misspellings.

6 Future work

Although deﬁnitely usable in its current state, SWISH is work in progress. We are con-
ﬁdent that the basic component selection and organisation of the server and client code
are stable. More work is needed to improve the current system. Notably the semantic
highlighting is not yet perfect and often fails to degrade gradually if the server side an-
notation does not match the client tokens perfectly. The Pengine’s sandbox protection is
often too restrictive, while several security ﬂaws have been reported and ﬁxed already.
It is, and probably always will be, advised to run public SWISH-enabled services in
an operating system sandbox. The current server suffers from memory leaks and stabil-
ity problems. Although the situation has improved signiﬁcantly, the main demo server
needs to be restarted about once a week.30

We foresee several extensions to SWISH that will improve current applications and

enable new opportunities for deploying SWISH.

– ClioPatria’s authorised usage of SWISH shows some of the potential for control-
ling servers or embedded Prolog engines. In addition to small temporary Prolog
programs, we would like to be able to edit existing and create new Prolog mod-
ules as well as pages in other languages, such as JavaScript, HTML and CSS. Full
editing capabilities would allow for shared development of server software without
shell access to the server on which SWISH enabled software is running.

– Multi-document editing can enhance the sandboxed SWISH application by pro-
viding input and output documents. Compare this to TRILL (section 5.5) using an
RDF/XML document as input.

– We plan to provide a markdown-based format speciﬁcally for writing tutorials and
well as dataset analysis documents. The ﬁrst will look like the Learn Prolog Now!
example discussed in section 5.3. For the second, we envision a document with
embedded code and query fragments, where the query fragments produce tables or
charts. This is similar to IPython Notebook.

– Turn http://swish.swi-prolog.org into a reliable and scalable resource.
Examine the possibility for schools to instantiate a private version that is preloaded
with course material and assignments.

30 A restart of the server has only small consequences to active users. Open queries are killed.
The source code mirror is lost, but automatically recovered if the client asks for a new set of
semantically enriched tokens.

112

7 Conclusion

This article presented SWISH, SWI-Prolog for Sharing. SWISH provides a web-
enabled interface to Prolog that is based on ideas from JSFiddle, R-Studio and IPython
Notebook. It consists of a JavaScript client side, while the server side is based on SWI-
Prolog’s HTTP and Pengines (Prolog engines) libraries. SWISH can be deployed in
many settings, such as education, data analysis and server development and mainte-
nance. SWISH as a whole is tied to SWI-Prolog, but other languages, not even limited
to Prolog, could be controlled from SWI-Prolog. SWISH is made available as open
source and can be downloaded from github.31

The development of SWISH was supported by the Dutch national program COMMIT/.

Acknowledgements

References

Publications, 2006.

14(4-5):539–552, 2014.

1. Patrick Blackburn, Johan Bos, and Kristina Striegnitz. Learn prolog now!, volume 7. College

2. Christopher Gandrud. Reproducible Research with R and R Studio. CRC Press, 2013.
3. Torbj¨orn Lager and Jan Wielemaker. Pengines: Web logic programming made easy. TPLP,

4. Fabrizio Riguzzi and Terrance Swift. Well-deﬁnedness and efﬁcient inference for probabilistic
logic programming under the distribution semantics. Theory Pract. Log. Program., 13(Special
Issue 02 - 25th Annual GULP Conference):279–302, March 2013.

5. Cyrille Rossant. Learning IPython for interactive computing and data visualization. Packt

Publishing Ltd, 2013.

6. Jan Wielemaker and Anjo Anjewierden. PlDoc: Wiki style literate programming for Prolog.
In Patricia Hill and Wim Vanhoof, editors, Proceedings of the 17th Workshop on Logic-Based
methods in Programming Environments, pages 16–30, 2007.

7. Jan Wielemaker, Zhisheng Huang, and Lourens van der Meij. Swi-prolog and the web. TPLP,

8(3):363–392, 2008.

8. Riccardo Zese, Elena Bellodi, Evelina Lamma, Fabrizio Riguzzi, and Fabiano Aguiari. Se-
mantics and inference for probabilistic description logics. In Uncertainty Reasoning for the
Semantic Web III, volume 8816 of LNCS, pages 79–99. Springer, 2014.

31 https://github.com/SWI-Prolog/swish

113

5
1
0
2
 
v
o
N
 
3
 
 
]
L
P
.
s
c
[
 
 
1
v
5
1
9
0
0
.
1
1
5
1
:
v
i
X
r
a

SWISH: SWI-Prolog for Sharing

Jan Wielemaker1 and Torbj¨orn Lager2 and Fabrizio Riguzzi3

1 Web and Media group, VU University Amsterdam, The Netherlands,
J.Wielemaker@vu.nl
2 Department of Philosophy, Linguistics and Theory of Science, University of Gothenburg,
Sweden
Torbjorn.Lager@ling.gu.se
3 Dipartimento di Matematica e Informatica, University of Ferrara, Italy
Fabrizio.Riguzzi@unife.it

Abstract. Recently, we see a new type of interfaces for programmers based on
web technology. For example, JSFiddle, IPython Notebook and R-studio. Web
technology enables cloud-based solutions, embedding in tutorial web pages, at-
tractive rendering of results, web-scale cooperative development, etc. This article
describes SWISH, a web front-end for Prolog. A public website exposes SWI-
Prolog using SWISH, which is used to run small Prolog programs for demon-
stration, experimentation and education. We connected SWISH to the ClioPatria
semantic web toolkit, where it allows for collaborative development of programs
and queries related to a dataset as well as performing maintenance tasks on the
running server and we embedded SWISH in the Learn Prolog Now! online Prolog
book.

1

Introduction

Web technology has emerged to a state where it becomes useable for implement-
ing programming development environments. All major modern browsers now imple-
ment HTML5 and JavaScript and there are mature components available such as the
CodeMirror4 and ACE5 code editors, the Bootstrap6 framework for styling and UI wid-
gets and vizualization libraries such as D3.js.7 Using web technology rather than tra-
ditional GUI based technology such as Eclipse,8 Microsoft Visual Studio,9 XEmacs,10
etc. has various advantages. Being network transparent, it allows for controlling cloud
hosted applications as well as Prolog processes running on headless devices. Web tech-
nology provides a great infrastructure for mashups, pages that integrate material from
several sources. For example, embedding Prolog in tutorial pages or embedding Prolog
queries that can be modiﬁed and re-evaluated in documents that describe data collec-
tions.

4 https://codemirror.net/
5 http://ace.c9.io
6 http://getbootstrap.com/
7 http://d3js.org/
8 https://eclipse.org/
9 https://www.visualstudio.com/
10 http://www.xemacs.org/

With SWISH (SWI-Prolog for Sharing), we provide this technology for (SWI-
)Prolog. SWISH consists of JavaScript client (browser) code and a number of Prolog
libraries that realise the server as a Prolog application. The client code consists of a
series of jQuery11 plugins that deal with editing source code, managing a shared source
repository, entering queries and rendering answers produced by Prolog. The server-side
libraries serve the overall web application, implement the source store and support the
editor with predicate documentation, templates, cross-reference results, etc. For exe-
cuting Prolog queries, SWISH relies on Pengines (Prolog engines, [3]). A pengine is
a Prolog engine that can be controlled similarly to Prolog running in a terminal using
HTTP requests. The SWISH infrastructure was originally developed as a Prolog ver-
sion of JSFiddle. It was later reimplemented as a modular jQuery based infrastructure
aiming at collaborative exploration of data hosted on a SQL or SPARQL server. This
use-case is described in section 5.2.

This article is organised as follows. Section 2 describes related work, which in our
case are the systems that have inspired us. Section 3 describes the architecture and
components of SWISH. In section 5 we describe four applications of the current system.
We conclude with future work and conclusions.

2 Related work

We are not aware of other initiatives that aim at developing a rich web-based develop-
ment environment for Prolog. We do not compare SWISH with traditional editor or GUI
based development environments for Prolog because web-based environments provide
new opportunities and pose new challenges. Instead, we discuss three applications that
have served as inspiration for SWISH: JSFiddle,12 R-Studio13 and IPython Notebook.14

– As stated, the initial inspiration for SWISH was JSFiddle. Unlike JSFiddle though,

Prolog is executed on the server rather than in the browser.

– R-Studio [2] is an interface to the R statistical package. Although not a web applica-
tion, it is based on the Qt webkit framework and uses web based technology in the
background. R-Studio came into the picture when the COMMIT/ project provided
a grant for developing SWISH as a toolkit for analysis of relational (SQL) data.
The R-studio interface has a similar layout as SWISH, providing a source window,
a console and an output plane that typically shows results in tables or charts.

– IPython Notebook [5] allows mixing markdown or HTML text with Python
sources. The rendered Notebook shows the text, sources and possible results in
the form of numbers, tables or charts.

SWISH embodies most of the ideas behind JSFiddle and R-Studio. Embedding of
SWISH in documents is demonstrated in section 5.3. Interactive editing of documents
that embed SWISH is discussed in future work (section 6).

11 https://jquery.com/
12 https://jsfiddle.net/
13 http://www.rstudio.com/
14 http://ipython.org/notebook.html

100

Both R-Studio and IPython Notebook work on the basis of authentication (either to
the OS or application), after which any command may be executed. SWISH can operate
both as a public service granting access to non-intrusive queries and as an authenticated
service to run arbitrary queries, for example for maintenance purposes. See section 5.2.

3 The SWISH application

SWISH consists of two parts. The client side, running in a browser, is implemented
as a series of jQuery plugins, using Bootstrap for styling and RequireJS15 for package
management. The server side is completely implemented in SWI-Prolog [7]. It builds on
top of the SWI-Prolog HTTP server libraries, the Pengines library and the IDE support
libraries that provide data for auto completion, documentation and highlighting.

In the following sections we describe SWISH in terms of interface components,
where we discuss the requirements, the user aspects, the client code and supporting
server functionality for each component. First, we provide a screendump that illustrates
the main components in ﬁgure 1.

Fig. 1. Screendump of SWISH. The left pane shows the source code, while the top-right pane
shows a query runner that exploits the current selected answer renderer and buttons on how to
continue after the ﬁrst answer. The bottom-right pane provides the query editor with access to
example queries stored in the source, query history, apply solution modiﬁers, result presentation
and a Run! button to start the query.

15 http://requirejs.org/

101

3.1 The code editor

A proper editor is the most important component of a usable programming environment.
The editor must support the language, including syntax highlighting, auto indentation,
code completion based on templates and already existing code and highlighting of errors
and warning from the compiler. The editor is used both for editing the source code and
editing queries.

Prolog is a difﬁcult language to support in code editors due to the lack of reserved
keywords, e.g., the word if in C starts an if-statement if not embedded in comment or
a string, but the word is in Prolog can refer to the built-in predicate is/2, but also some
predicate with a different arity, just a constant, etc. Another example is X-Y which can
both be an arithmetic expression or a pair as used with e.g., keysort/2. Next to the
lack of keywords the ability to extend the syntax using new operators complicates the
implementation of syntax support while editing. SWI-Prolog’s built-in Emacs oriented
editor resolves this problem by closely integrating Prolog with the editor. While typing,
the current term (clause or directive) is parsed and analysed in the context of the current
ﬁle and the ﬁle’s imports after each keystroke. If the term has valid syntax, all tokens
are coloured according to their syntactic role as well their relation to the remainder of
the program. For example, a call to a non-existing predicate is coloured red, a call to a
built-in or imported predicate is blue and a call to a locally deﬁned predicate is black.
The libraries that implement this analysis have been decoupled from the built-in editor,
both to support source colouring for the SWI-Prolog documentation system PlDoc [6]
and ProDT16

There are two dominant open source and actively maintained in-browser code edi-
tors available: ACE and CodeMirror. When we started SWISH, ACE had a very basic
Prolog mode and CodeMirror had none. We nevertheless opted for CodeMirror be-
cause its highlighting is based on raw JavaScript code rather than a regular expression
based template language as used for ACE. The low level implementation allows for
a novel highlighting implementation. The highlighter consists of a JavaScript imple-
mented Prolog tokeniser. Tokenizing Prolog is sufﬁcient to colour comments, quoted
material (strings, quoted atoms), variables and constants (atoms and numbers). It is
also sufﬁcient to support smart indentation. As discussed above, it is not sufﬁcient for
highlighting the role played by atoms and compound terms.17

We provide semantic highlighting as illustrated in ﬁgure 2 by (1) forwarding the
changes to the content of the editor to the server server which maintains a mirror of the
editor content and (2) asking the server to produce a list of semantically enriched tokens
for the source. The tokens are returned as a list-of-lists, where each inner list represents
the tokens for a source term (clause or directive). Grouping the tokens per source term
allows for incremental update (not yet implemented) as well as re-synchronisation (see
below). For example, a fragment of an enriched token list may look like this: [ functor,
(undeﬁned goal), variable (singleton), . . . ]. The JavaScript tokeniser matches its tokens

16 http://prodevtools.sourceforge.net, these libraries are not yet used by ProDT.
17 An additional complication is formed by CodeMirror’s token-based highlighting which does
not support look-ahead. As a consequence, we must decide on the colour of e.g., asserta(
while we do not know the arity of the term.

102

Fig. 2. The semantic highlighter classiﬁes, in addition to the syntactic category such as comment
or variable, terms that deﬁne or call predicates based on cross-referencing the source code.

with this list. If the basic type (e.g., ‘functor’ or ‘variable’) matches, it uses the enrich-
ment information (e.g., ‘singleton’) to decide on the style. If the basic token type does
not match, it highlights the token using the basic syntactical category and schedules a
request to the server for a new list of enriched tokens. This request is sent if the user
pauses typing for 2 seconds. The request is accompanied by the full source if this is
small or the list of changes since the last request if the source is large. While waiting
for up-to-date enriched tokens, the JavaScript highlighting code heuristically tries to
re-synchronise and either uses the uncertain results or falls back to the plain tokens.
Re-synchronisation checks whether a single added, deleted or modiﬁed token gets the
token stream in-sync. If this fails it tries to re-synchronise on a full-stop with the next
clause or directive.

A CodeMirror hover plugin is used to show basic information about tokens if the
pointer hovers over it. For goals, this includes where the goal is deﬁned (ISO, SWI-
Prolog built-in, a library, locally) and the documentation summary information if avail-
able. This information is requested from the server.

template

A CodeMirror

(e.g.,
is
atom length(+Atom, -Length)) extracted from the SWI-Prolog manual
and PlDoc documentation of imported libraries. This plugin shows a menu of
applicable predicates with their templates on Control-Space.

from templates

conﬁgured

plugin

Finally, if the user uses the Run! button to execute a query, the program is compiled.
If the compiler generates errors or warnings, these are inserted as notes in the source
code.

3.2 Source code and query management

As JSFiddle formed the initial inspiration for SWISH, SWISH has a facility to save the
program. The current version of SWISH explicitly targets the cooperative development

103

of Prolog programs and queries related to a dataset (see section 5.2). This triggered the
implementation of a more organised storage facility. The server-side storage module is
implemented in Prolog and inspired by GIT. Each ﬁle is versioned independently rather
than maintaining the version of a hierarchy of ﬁles. Files can be referenced by content
using their GIT compatible SHA1 hash or by name. The name can be considered a
version head and refers to the latest version with that name. The ﬁle save and load
interface provides the following operations:

– Saving a ﬁle anonymously, which produces a randomly generated URL similar to

– Saving a ﬁle by name.
– Saving a new version. The interface shows the available versions and the modiﬁca-

JSFiddle.

tions.

– Forking a ﬁle under a new name. The history remains linked to the original.

Prolog

source ﬁles

include
:- include(filename).,

other
using
including
:- include(hash). to include a speciﬁc version.

can

sources
the

on

the
latest

same
version

server
or

Prolog source ﬁles can embed example queries using structured comments, where
each sequence from ?- to the matching full stop token is added to the Examples menu
of the query panel (see ﬁgure 6). The comment below illustrates a call to append/3
embedded in the source window.

/** <examples>

?- append([one], [two,three], List).
*/

3.3 The query editor

The query editor is based on the same jQuery plugin that realises the code editor and
thus proﬁts from the syntax highlighting, template insertion and hovering plugins. In
addition, it provides three popup menus:

Examples This menu is ﬁlled from the structured comments described above. The ex-

amples menu is shown in ﬁgure 6.

History This menu provides earlier executed queries.
Solutions This menu embeds an existing query in a meta-call to alter the result. Cur-
rently provided operations are Aggregate (count all), Order by, Distinct, Limit, Time
and Debug (trace). Figure 3 shows how the menu is used to count the solutions of
a goal.

104

Fig. 3. The Solutions menu can be used to count results, order them, ﬁlter duplicates, etc. The
upper runner shows answers to the query as a table.

3.4 Running a query: runners in the answer pane

The answer pane is a placeholder for runners, where each runner represents a query. The
answer pane provides a menu for operations on all runners inside it. Provided actions are
Collapse all, Expand all, Stop all and Clear. The query may be completed, running
or waiting for user input. SWISH can manage multiple active queries at the same time,
up to an application deﬁned maximum (default 3).

Each runner provides its own set of commands to control the speciﬁc query. During
execution a runner provides an Abort button. After query evaluation completes with an
answer and more answers may be available the runner allows for asking the next 1, 10,
100 or 1,000 results or to Stop the query. In addition, the runner shows a text input ﬁeld
when the application wants to read input and may show debugger interaction buttons if
the tracer is being used (see section 3.4).

A runner can render answers in two modes, the classical Prolog mode or as a ta-
ble, similar to what many database interfaces provide. The ‘table’ mode is particularly
appealing for querying datasets (see ﬁgure 3), while the former is more suitable for ren-
dering small amounts of complex answers such as the chessboard position in ﬁgure 1.
By default, Prolog terms are rendered as structured HTML objects, where the rendered
text is the same as Prolog’s writeq/1 predicate.

The server can provide rendering libraries that render Prolog terms using
the ‘chess’ renderer is loaded due to the :-
dedicated HTML. In ﬁgure 1,
use rendering(chess) directive. The ‘chess’ renderer translates a list of length
N holding integers in the range 1..N as a chessboard with queens. In addition to the
chess rendering library, SWISH provides rendering libraries for sudoku puzzles, parse
trees and tables. The ClioPatria version adds a renderer for RDF resources that renders
the resource more compactly and provides a hyperlink for obtaining details. If a term

105

can be rendered in multiple ways, the interface provides a hover menu to select between
the alternatives. Figure 4 illustrates this functionality. The render facility is similar to the
Prolog portray/1 hook that allows changing the result printed for terms with a speciﬁc
shape. However, it can exploit the full potential of HTML (or SVG) and the interface
allow for switching the selected rendering.

A rendering library is a module that must deﬁne a non-terminal (grammar rule)
term rendering//3, calling html//118 to produce HTML from the Prolog input
term, a list of variable bindings (Name = Variable) and user provided options. In the
current version, new rendering modules must be loaded into the SWISH server and
cannot be created by the SWISH user.

Fig. 4. With the ‘chess’ render library, a list of integers is interpreted as queens on a chessboard.
The user can select rendering as a ‘Prolog term’ to see the actual term.

Server side execution of the query Server-side execution of a query is supported
by the Pengines [3] library. The Pengines library allows for creating a Prolog engine
represented by a Prolog thread. Optionally, the pengine is handed a Prolog program that
is loaded into the pengine’s workspace (program space). The workspace is a temporary
module that is disposed of after the pengine terminates. The pengine may be asked
questions through HTTP queries, similar to a traditional Prolog user interacting with
Prolog running in a terminal.19

If the SWISH user hits the Run! button, the content of the source pane is used to
create a new pengine. Subsequently, the content of the query pane is sent as the one and
only query that will be executed by the pengine.20 Before execution, the query is veriﬁed
to be safe, unless sandboxing is disabled (see section 5.2). The sandbox component is
discussed below.

18 http://www.swi-prolog.org/pldoc/doc for?object=html/3
19 https://www.youtube.com/watch?v=G_eYTctGZw8
20 Pengines can execute multiple queries. We do not use this facility because a fresh pengine

starts in a predictable state (standard operators, empty dynamic database).

106

The pengine’s default working module may be pre-loaded with code. SWISH uses
this facility to redeﬁne the Prolog I/O predicates such as read/1, write/1, format/1,2,3,
etc. The ClioPatria version (section 5.2) also preloads the RDF libraries, so users can
run queries on the RDF database without explicitly importing the required libraries.

Sandboxing queries A Prolog environment contains global state in the form of loaded
modules, deﬁned operators, dynamic predicates, etc. Prolog exposes a rich and poten-
tially dangerous interface to the operating system. For an anonymous services, we want
each query to start in a well deﬁned state and we must ensure that execution of the query
does not make unwanted changes to the hosting computer or leaks sensitive informa-
tion.

Both for education purposes and data analysis one can write meaningful programs
without making permanent changes to the server or the server’s ﬁlesystem. That is
where the sandbox library comes in. The sandbox library is active while loading the
source, where it refuses to add clauses to other modules than the pengine’s workspace
and where it only accepts a restricted set of directives, also aimed at keeping all changes
local to the workspace. Prior to execution, the sandbox unfolds the query and compares
all reachable goals with a whitelist. The whitelist contains all side-effect free built-in
Prolog predicates, safe meta-predicates (e.g., ﬁndall/3) and allows for using the dy-
namic database, provided that the head of the affected predicate is not module-qualiﬁed
(and thus the referenced predicate lives in the temporary program space of the Pengine)
and the body is safe. It does not allow for cross-module calls (Module:Goal) to private
predicates and does not provide access to object-enumeration predicates such as cur-
rent atom/1, current predicate/1, etc., both to avoid leaking sensitive information.

The sandbox test fails under one of these conditions:

– It discovers a (meta-) goal for which it cannot deduce the called code. The tradi-
tional example is read(X), call(X). If such a goal is encountered, it signals
an instantiation error, together with a trace that explains how the insufﬁciently
instantiated goal can be reached. Note that it can deal with normal high-order pred-
icates if the meta-argument is speciﬁed. For example, the following goal is accepted
as safe.

?- maplist(plus(1), [1,2,3])

– It discovers a goal that is not whitelisted. In this case it signals a permission error,
again accompanied with a trace that explains how the goal can be reached. Note that
pure Prolog predicates are unfolded, also if it concerns predicates from the libraries
or belonging to the set of built in predicates.

– It discovers a cross-module (M:Goal) call to a predicate that is not public. Nor-
mally, SWI-Prolog, in the tradition of Quintus Prolog, allows for this. Allowing it
in SWISH would imply that no data can be kept secret. With this limitation, libraries
can keep data in local dynamic predicates that remain invisible to non-authorised
users.

Debugging The SWISH debugger is based on the traditional 4-port debugging model
for Prolog. Figure 5 shows the tracer in action on sublist/2 from the Lists example

107

source. The debugger was triggered by a break-point on line 10 set by clicking on the
line-number in the code editor. The debugging interaction is deliberately kept simple
and similar to traditional programming environments. A retry button is added to the
commonly seen ‘step into’, ‘step over’ and ‘step out’ for highlighting the unique feature
of Prolog to re-evaluate a goal.

Fig. 5. Debugging applications in SWISH

4 Portability

The SWISH client libraries are based on mature and well maintained JavaScript li-
braries. The client runs all modern major browsers with HTML5, CSS and JavaScript
support. It is frequently tested on FireFox, Chrome, Safari and Internet Explorer 11.

The server code is basically non-portable. Many of the required libraries and fea-
tures are shared with at least one other Prolog implementation, but none is capable to
support the full range. Below we summarise the main problems.

– The scale of the involved Prolog libraries demands for a closely compatible Prolog
module system. Probably only SICStus and YAP can be used without signiﬁcant
rewrites.

108

– The HTTP server libraries are heavily based on C code that interacts with the SWI-
Prolog foreign language interface to Prolog streams. YAP has copied the low-level
libraries and is capable to run (an old version of) these libraries.

– The Pengines library depends on the HTTP library and the multi-thread interface.

The SWI-Prolog thread API is also provided by YAP and XSB.

– The sandbox library (section 3.4) assumes that whitelisted predicates are indeed
safe. This requires robust handling of invalid calls and resource overﬂows. Few
Prolog systems can satisfy this requirement. SICStus Prolog would be a candidate,
but SICStus does not support multi-threading.

– The semantic syntax highlighting depends on detailed source layout information
provided by read term/3. SWI-Prolog’s support for term layout is an extended
version of the Quintus Prolog term layout functionality.

– Signiﬁcant parts of the code rely on SWI-Prolog version 7 extensions, notably the
dict and string types that facilitate a natural mapping between Prolog and JSON
data.

From the above list it should be clear that a fully functional port of SWISH to
another Prolog system is not immediately feasible. YAP probably comes closest but
still requires a signiﬁcant amount of work.

There is a more realistic scenario though. In this setup, SWI-Prolog provides the
web interface and most of the development tools and another language, not even neces-
sarily Prolog, provides the query solving. The interface between the two can be based
on interprocess communication or, if the target system is robust, safe and capable of
supporting threads, by linking the target system into the process and using the C inter-
face for communication.

In this section we describe and evaluate four publicly available SWISH applications.
All these services are regularly updated to run the latest version of SWISH and SWI-
Prolog.

5 Applications

5.1 SWISH

SWISH21 runs a plain publicly accessible copy of SWISH that allows running sand-
boxed (see section 3.4) Prolog programs. The server has collected 10,800 programs
between September 29, 2014 and June 2, 2015. Over the month May 2015, it has exe-
cuted 258,809 Prolog queries. The web site is regularly used by users of the ##prolog
IRC channel to discuss programming solutions and is in active use for education.22

21 http://swish.swi-prolog.org
22 Steve Matuszek, UMBC (via e-mail: “Thank you very much for this fantastic resource! I used
it while teaching Prolog this semester, and it really helped tighten the loop for my students.
We spent zero time on tool installation and other overhead, and all the time on understanding
the concepts. I even had them turn their assignments in via SWISH, with their test queries in
the examples block.”

109

5.2 ClioPatria

ClioPatria is a semantic web (RDF) framework for SWI-Prolog. It consists of an RDF
triple store, a SPARQL server and a web frontend to manage the server and explore
the data in the RDF store. ClioPatria can be extended using cpacks (ClioPatria pack or
plugin). SWISH is available as a ClioPatria cpack23 and makes the Prolog shell avail-
able for querying as well as maintenance tasks. Without login, user can run side-effect
free queries over the RDF data stored in ClioPatria’s RDF database. After login with
administrative rights, the sandbox limitations are lifted and the Prolog shell can be used
to perform maintenance tasks on the RDF data such as data transformation, cleanup,
etc., as well as program maintenance tasks such as reloading modiﬁed source ﬁles.

SWISH has been used in the Talk Of Europe creative camp24 to explore data on the
speeches in the European parliament.25 Although still immature, users appreciated the
ability to deﬁne more efﬁcient and expressive queries than provided by the SPARQL
query interface. Above all, the ability to save and share programs that perform interest-
ing tasks on the data was frequently used, in particular to seek help ﬁxing queries.

5.3 Learn Prolog Now!

Learn Prolog Now!26 is an online version of a Prolog book by Patrick Blackburn, Johan
Bos, and Kristina Striegnitz [1]. We established a proof of concept that embeds SWISH
in the online course material.27 It is realised as a Prolog hosted proxy that fetches the
pages from the main site and serves the enhanced pages to the user. The proxy identiﬁes
and classiﬁes the code fragments in terms of ‘source code’ ‘queries’ and dependencies.
Next, it adds a button to the source fragments that, when pressed, replaces the HTML
<pre> element with in <iframe> running SWISH ﬁlled with the source while the
example queries are added to the Examples menu (ﬁgure 6). The queries are executed
by http://swish.swi-prolog.org. Program and queries are transferred using
the following HTTP parameters: code (the source code), background (source code
that is loaded into the pengine but not visible in the editor), examples (queries that ap-
pear in the Examples menu) and q (the initial query). The proxy server served 19,700
pages during May 2015.

5.4 cplint on SWISH

cplint on SWISH28 is a web application based on SWISH for reasoning with prob-
abilistic logic programs under the distribution semantics. The Prolog source window
is used to write a logic program with annotated disjunction. A query in the form of a
ground atom is answered by returning its probability of being true in the program. The
computation of the probability is done with the cplint system [4] in the server using

23 http://cliopatria.swi-prolog.org/packs/swish
24 http://www.talkofeurope.eu/
25 http://purl.org/linkedpolitics
26 http://www.learnprolognow.org
27 http://lpn.swi-prolog.org
28 http://cplint.lamping.unife.it/

110

Fig. 6. Screendump of Learn Prolog Now with opened SWISH instance that shows the collected
source as well as example queries from the subsequent text that are classiﬁed as relating to this
source. The embedded SWISH provides all functionality available in the stand-alone SWISH. If
the user presses the close button, SWISH will be removed and the original code re-appears.

Pengines. The input program is translated into an internal representation using source
to source transformation.

SWISH was modiﬁed only in the JavaScript code for the runner. The source code
is prepended code for loading the cplint library and enabling the source to source
transformation while the query is wrapped into a call of the inference predicate. This
call has a variable argument Prob which will hold the probability and will be shown to
the user in the answer pane.

5.5 TRILL on SWISH

TRILL on SWISH29 is a probabilistic OWL reasoner that reuses SWISH. As SWISH
for ClioPatria, described in section 5.2, it is a ClioPatria cpack. The Prolog source win-
dow is replaced by an RDF/XML editor window that can be used to upload an OWL
ontology while the query editor can be used to pose Prolog queries against the OWL

29 http://trill.lamping.unife.it/

111

ontology. The probability of queries is computed using TRILL [8], a reasoner in Prolog
that adopts the distribution semantics for probabilistic description logics.

Also for TRILL on SWISH we had only to modify the JavaScript code for the
runner. The source code sent to the Pengine is obtained by adding Prolog code for
parsing an RDF/XML string, by calling the parsing predicate and by wrapping the query
in a meta-call that performs syntactic checks for misspellings.

6 Future work

Although deﬁnitely usable in its current state, SWISH is work in progress. We are con-
ﬁdent that the basic component selection and organisation of the server and client code
are stable. More work is needed to improve the current system. Notably the semantic
highlighting is not yet perfect and often fails to degrade gradually if the server side an-
notation does not match the client tokens perfectly. The Pengine’s sandbox protection is
often too restrictive, while several security ﬂaws have been reported and ﬁxed already.
It is, and probably always will be, advised to run public SWISH-enabled services in
an operating system sandbox. The current server suffers from memory leaks and stabil-
ity problems. Although the situation has improved signiﬁcantly, the main demo server
needs to be restarted about once a week.30

We foresee several extensions to SWISH that will improve current applications and

enable new opportunities for deploying SWISH.

– ClioPatria’s authorised usage of SWISH shows some of the potential for control-
ling servers or embedded Prolog engines. In addition to small temporary Prolog
programs, we would like to be able to edit existing and create new Prolog mod-
ules as well as pages in other languages, such as JavaScript, HTML and CSS. Full
editing capabilities would allow for shared development of server software without
shell access to the server on which SWISH enabled software is running.

– Multi-document editing can enhance the sandboxed SWISH application by pro-
viding input and output documents. Compare this to TRILL (section 5.5) using an
RDF/XML document as input.

– We plan to provide a markdown-based format speciﬁcally for writing tutorials and
well as dataset analysis documents. The ﬁrst will look like the Learn Prolog Now!
example discussed in section 5.3. For the second, we envision a document with
embedded code and query fragments, where the query fragments produce tables or
charts. This is similar to IPython Notebook.

– Turn http://swish.swi-prolog.org into a reliable and scalable resource.
Examine the possibility for schools to instantiate a private version that is preloaded
with course material and assignments.

30 A restart of the server has only small consequences to active users. Open queries are killed.
The source code mirror is lost, but automatically recovered if the client asks for a new set of
semantically enriched tokens.

112

7 Conclusion

This article presented SWISH, SWI-Prolog for Sharing. SWISH provides a web-
enabled interface to Prolog that is based on ideas from JSFiddle, R-Studio and IPython
Notebook. It consists of a JavaScript client side, while the server side is based on SWI-
Prolog’s HTTP and Pengines (Prolog engines) libraries. SWISH can be deployed in
many settings, such as education, data analysis and server development and mainte-
nance. SWISH as a whole is tied to SWI-Prolog, but other languages, not even limited
to Prolog, could be controlled from SWI-Prolog. SWISH is made available as open
source and can be downloaded from github.31

The development of SWISH was supported by the Dutch national program COMMIT/.

Acknowledgements

References

Publications, 2006.

14(4-5):539–552, 2014.

1. Patrick Blackburn, Johan Bos, and Kristina Striegnitz. Learn prolog now!, volume 7. College

2. Christopher Gandrud. Reproducible Research with R and R Studio. CRC Press, 2013.
3. Torbj¨orn Lager and Jan Wielemaker. Pengines: Web logic programming made easy. TPLP,

4. Fabrizio Riguzzi and Terrance Swift. Well-deﬁnedness and efﬁcient inference for probabilistic
logic programming under the distribution semantics. Theory Pract. Log. Program., 13(Special
Issue 02 - 25th Annual GULP Conference):279–302, March 2013.

5. Cyrille Rossant. Learning IPython for interactive computing and data visualization. Packt

Publishing Ltd, 2013.

6. Jan Wielemaker and Anjo Anjewierden. PlDoc: Wiki style literate programming for Prolog.
In Patricia Hill and Wim Vanhoof, editors, Proceedings of the 17th Workshop on Logic-Based
methods in Programming Environments, pages 16–30, 2007.

7. Jan Wielemaker, Zhisheng Huang, and Lourens van der Meij. Swi-prolog and the web. TPLP,

8(3):363–392, 2008.

8. Riccardo Zese, Elena Bellodi, Evelina Lamma, Fabrizio Riguzzi, and Fabiano Aguiari. Se-
mantics and inference for probabilistic description logics. In Uncertainty Reasoning for the
Semantic Web III, volume 8816 of LNCS, pages 79–99. Springer, 2014.

31 https://github.com/SWI-Prolog/swish

113

