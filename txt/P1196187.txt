COUNTERPOINT BY CONVOLUTION

Cheng-Zhi Anna Huang(cid:63)†(cid:93)

Tim Cooijmans(cid:63)†

Adam Roberts(cid:93)

(cid:63) Equal contributions

Aaron Courville†

Douglas Eck(cid:93)
† MILA, Universit´e de Montr´eal

(cid:93) Google Brain

chengzhiannahuang@gmail.com, cooijmans.tim@umontreal.ca

9
1
0
2
 
r
a

M
 
8
1
 
 
]

G
L
.
s
c
[
 
 
1
v
7
2
2
7
0
.
3
0
9
1
:
v
i
X
r
a

ABSTRACT

Machine learning models of music typically break up the
task of composition into a chronological process, compos-
ing a piece of music in a single pass from beginning to
end. On the contrary, human composers write music in
a nonlinear fashion, scribbling motifs here and there, of-
ten revisiting choices previously made. In order to better
approximate this process, we train a convolutional neural
network to complete partial musical scores, and explore the
use of blocked Gibbs sampling as an analogue to rewriting.
Neither the model nor the generative procedure are tied to
a particular causal direction of composition.

Our model is an instance of orderless NADE [36],
which allows more direct ancestral sampling. However,
we ﬁnd that Gibbs sampling greatly improves sample qual-
ity, which we demonstrate to be due to some conditional
distributions being poorly modeled. Moreover, we show
that even the cheap approximate blocked Gibbs procedure
from [40] yields better samples than ancestral sampling,
based on both log-likelihood and human evaluation.

1. INTRODUCTION

Counterpoint is the process of placing notes against notes
to construct a polyphonic musical piece. [9] This is a chal-
lenging task, as each note has strong musical inﬂuences
on its neighbors and notes beyond. Human composers
have developed systems of rules to guide their composi-
tional decisions. However, these rules sometimes contra-
dict each other, and can fail to prevent their users from
going down musical dead ends. Statistical models of mu-
sic, which is our current focus, is one of the many compu-
tational approaches that can help composers try out ideas
more quickly, thus reducing the cost of exploration [8].

Whereas previous work in statistical music modeling
has relied mainly on sequence models such as Hidden
Markov Models (HMMs [2]) and Recurrent Neural Net-
works (RNNs [31]), we instead employ convolutional neu-
ral networks due to their invariance properties and em-

c(cid:13) Cheng-Zhi Anna Huang, Tim Cooijmans, Adam
Roberts, Aaron Courville, Douglas Eck. Licensed under a Creative
Commons Attribution 4.0 International License (CC BY 4.0). Attribu-
tion: Cheng-Zhi Anna Huang, Tim Cooijmans, Adam Roberts, Aaron
Courville, Douglas Eck.
“Counterpoint by Convolution”, 18th Inter-
national Society for Music Information Retrieval Conference, Suzhou,
China, 2017.

Figure 1. Blocked Gibbs inpainting of a corrupted Bach
chorale by COCONET. At each step, a random subset of
notes is removed, and the model is asked to infer their val-
ues. New values are sampled from the probability distribu-
tion put out by the model, and the process is repeated. Left:
annealed masks show resampled variables. Colors distin-
guish the four voices. Middle: grayscale heatmaps show
predictions p(xj | xC) summed across instruments. Right:
complete pianorolls after resampling the masked variables.
Bottom: a sample from NADE (left) and the original Bach
chorale fragment (right).

phasis on capturing local structure. Nevertheless, they
have also been shown to successfully model large-scale
structure [37, 38]. Moreover, convolutional neural net-
works have shown to be extremely versatile once trained,
as demonstrated by a variety of creative uses such as Deep-
Dream [29] and style transfer [10].

We introduce COCONET, a deep convolutional model
trained to reconstruct partial scores. Once trained, CO-
CONET provides direct access to all conditionals of the
form p(xi | xC) where C selects a fragment of a musi-
cal score x and i /∈ C is in its complement. COCONET
is an instance of deep orderless NADE [36], which learns
an ensemble of factorizations of the joint p(x), each cor-
responding to a different ordering. A related approach is
the multi-prediction training of deep Boltzmann machines
(MP-DBM) [12], which also gives a model that can predict
any subset of variables given its complement.

However, the sampling procedure for orderless NADE
treats the ensemble as a mixture and relies heavily on or-
dering. Sampling from an orderless NADE involves (ran-
domly) choosing an ordering, and sampling variables one
by one according to the chosen ordering. This process is
called ancestral sampling, as the order of sampling follows
the directed structure of the model. We have found that this
produces poor results for the highly structured and com-
plex domain of musical counterpoint.

Instead, we propose to use blocked-Gibbs sampling, a
Markov Chain Monte Carlo method to sample from a joint
probability distribution by repeatedly resampling subsets
of variables using conditional distributions derived from
the joint probability distribution. An instance of this was
previously explored by [40] who employed a NADE in the
transition operator for a Markov Chain, yielding a Gen-
erative Stochastic Network (GSN). The transition consists
of a corruption process that masks out a subset x¬C of
variables, followed by a process that independently resam-
ples variables xi (with i /∈ C) according to the distribu-
tion pθ(xi | xC) emitted by the model with parameters θ.
Crucially, the effects of independent sampling are amor-
tized by annealing the probability with which variables are
masked out. Whereas [40] treat their procedure as a cheap
approximation to ancestral sampling, we ﬁnd that it pro-
duces superior samples. Intuitively, the resampling process
allows the model to iteratively rewrite the score, giving it
the opportunity to correct its own mistakes.

COCONET addresses the general task of completing par-
tial scores; special cases of this task include ”bridging” two
musical fragments, and temporal upsampling and extrapo-
lation. Figure 1 shows an example of COCONET popu-
lating a partial piano roll using blocked-Gibbs sampling.
Code and samples are publically available. 1 Our samples
on a variety of generative tasks such as rewriting, melodic
harmonization and unconditioned polyphonic music gen-
eration show the versatility of our model. In this work we
focus on Bach chorales, and assume four voices are active
at all times. However, our model can be easily adapted to

1

Code:
Data:
Samples:

https://github.com/czhuang/coconet

https://github.com/czhuang/JSB-Chorales-dataset
https://coconets.github.io/

the more general, arbitrarily polyphonic representation as
used in [4].

Section 2 discusses related work in modeling music
composition, with a focus on counterpoint. The details of
our model and training procedure are laid out in Section 3.
We discuss evaluation under the model in Section 4, and
sampling from the model in Section 5. Results of quantita-
tive and qualitative evaluations are reported in Section 6.

2. RELATED WORK

Computers have been used since their early days for ex-
periments in music composition. A notable composition
is Hiller and Issacson’s string quartet Illiac Suite [18],
which experiments with statistical sequence models such
as Markov chains. One challenge in adapting such models
is that music consists of multiple interdependent streams
of events. Compare this to typical sequence domains such
as speech and language, which involve modeling a sin-
gle stream of events: a single speaker or a single stream
of words.
In music, extensive theories in counterpoint
have been developed to address the challenge of compos-
ing multiple streams of notes that coordinate. One notable
theory is due to Fux [9] from the Baroque period, which in-
troduces species counterpoint as a pedagogical scheme to
gradually introduce students to the complexity of counter-
point. In ﬁrst species counterpoint only one note is com-
posed against every note in a given ﬁxed melody (cantus
ﬁrmus), with all notes bearing equal durations and the re-
sulting vertical intervals consisting of only consonances.

Computer music researchers have taken inspiration
from this pedagogical scheme by ﬁrst teaching comput-
ers to write species counterpoint as opposed to full-ﬂedged
counterpoint. Farbood [7] uses Markov chains to capture
transition probabilities of different melodic and harmonic
transitions rules. Herremans [16, 17] takes an optimization
approach by writing down an objective function that con-
sists of existing rules of counterpoint and using a variable
neighbourhood search (VNS) algorithm to optimize it.

J.S. Bach chorales has been the main corpus in com-
puter music that serves as a starting point to tackle full-
ﬂedged counterpoint. A wide range of approaches have
been used to generate music in the style of Bach chorales,
for example rule-based and instance-based approaches
such as Cope’s recombinancy method [6]. This method in-
volves ﬁrst segmenting existing Bach chorales into smaller
chunks based on music theory, analyzing their function and
stylistic signatures and then re-concatenating the chunks
into new coherent works. Other approaches range from
constraint-based [30] to statistical methods [5]. In addi-
tion, [8] gives a comprehensive survey of AI methods used
not just for generating Bach chorales, but also algorithmic
composition in general.

Sequence models such as HMMs and RNNs are nat-
ural choices for modeling music. Successful application
of such models to polyphonic music often requires serial-
izing or otherwise re-representing the music to ﬁt the se-
quence paradigm. For instance, Liang in BachBot [27] se-
rializes four-part Bach chorales by interleaving the parts,

while Allan and Williams [1] construct a chord vocabu-
lary. Boulanger et al. [4] adopt a piano roll representation,
a binary matrix x where xit = 1 iff some instrument is
playing pitch i at time t. To model the joint probability
distribution of the multi-hot pitch vector xt, they employ
a Restricted Boltzmann Machine (RBM [19, 32]) or Neu-
ral Autoregressive Distribution Estimator (NADE [25]) at
each time step. Similarly Goel et al. [11] employ a Deep
Belief Network [19] on top of an RNN.

Hadjeres et al. [14] instead employ an undirected
Markov model to learn pairwise relationships between
neighboring notes up to a speciﬁed number of steps away
in a score. Sampling involves Markov Chain Monte Carlo
(MCMC) using the model as a Metropolis-Hastings (MH)
objective. The model permits constraints on the state space
to support tasks such as melody harmonization. However,
the Markov assumption can limit the expressivity of the
model.

Hadjeres and Pachet in DeepBach [13] model note pre-
dictions by breaking down its full context into three parts,
with the past and the future modeled by stacked LSTMs
going in the forward and backward directions respectively,
and the present harmonic context modeled by a third neural
network. The three are then combined by a fourth neural
network and used in Gibbs sampling for generation.

Lattner et al.

imposes higher-level structure by in-
terleaving selective Gibbs sampling on a convolutional
RBM [26] and gradient descent that minimizes cost to tem-
plate piece on features such as self-similarity. This pro-
cedure itself is wrapped in simulated annealing to ensure
steps do not lower the solution quality too much.

We opt for an orderless NADE training procedure which
enables us to train a mixture of all possible directed mod-
els simultaneously. Finally, an approximate blocked Gibbs
sampling procedure [40] allows fast generation from the
model.

3. MODEL

We employ machine learning techniques to obtain a gen-
erative model of musical counterpoint in the form of pi-
ano rolls. Given a dataset of observed musical pieces
x(1) . . . x(n) posited to come from some true distribution
p(x), we introduce a model pθ(x) with parameters θ.
In order to make pθ(x) close to p(x), we maximize the
data log-likelihood (cid:80)
i log pθ(x(i)) (an approximation of
Ex∼p(x) log pθ(x)) by stochastic gradient descent.

The joint distribution p(x) over D variables x1 . . . xD
is often difﬁcult to model directly and hence we construct
our model pθ(x) from simpler factors. In the NADE [25]
framework, the joint pθ(x) is factorized autoregressively,
one variable at a time, according to some ordering o =
o1 . . . oD, such that

pθ(x) =

pθ(xod | xo<d ).

(1)

(cid:89)

d

For example, it can be factorized in chronological order:

In general, NADE permits any one ﬁxed ordering, and al-
though all orderings are equivalent from a theoretical per-
spective, they differ in practice due to effects of optimiza-
tion and approximation.

Instead, we can train NADE for all orderings o simulta-
neously using the orderless NADE [36] training procedure.
This procedure relies on the observation that, thanks to pa-
rameter sharing, computing pθ(xod(cid:48) | xo<d) for all d(cid:48) ≥ d
is no more expensive than computing it only for d(cid:48) = d. 2
Hence for a given o and d we can simultaneously obtain
partial losses for all orderings that agree with o up to d:

L(x; o<d, θ) = −

log pθ(xod | xo<d, o<d, od)

(3)

(cid:88)

od

An orderless NADE model offers direct access to all dis-
tributions of the form pθ(xi|xC) conditioned on any set
of contextual variables xC = xo<d that might already be
known. This gives us a very ﬂexible generative model;
in particular, we can use these conditional distributions to
complete arbitrarily partial musical scores.

To train the model, we sample a training example x and
context C such that |C| ∼ U (1, D), and update θ based
on the gradient of the loss given by Equation 3. This loss
consists of D − d + 1 terms, each of which corresponds
to one ordering. To ensure all orderings are trained evenly
we must reweight the gradients by 1/(D − d + 1). This
correction, due to [36], ensures consistent estimation of the
joint negative log-likelihood log pθ(x).

In this work, the model pθ(x) is implemented by a deep
convolutional neural network [23]. This choice is moti-
vated by the locality of contrapuntal rules and their near-
invariance to translation, both in time and in pitch space.

We represent the music as a stack of piano rolls encoded
in a binary three-dimensional tensor x ∈ {0, 1}I×T ×P .
Here I denotes the number of instruments, T the number
of time steps, P the number of pitches, and xi,t,p = 1 iff
the ith instrument plays pitch p at time t. We will assume
each instrument plays exactly one pitch at a time, that is,
(cid:80)

p xi,t,p = 1 for all i, t.
Our focus is on four-part Bach chorales as used in prior
work [1,4,11,14,27]. Hence we assume I = 4 throughout.
We constrain ourselves to only the range that appears in
our training data (MIDI pitches 36 through 88). Time is
discretized at the level of 16th notes for similar reasons.
To curb memory requirements, we enforce T = 128 by
randomly cropping the training examples.

Given a training example x ∼ p(x), we present the
model with values of only a strict subset of its elements
xC = {x(i,t) | (i, t) ∈ C} and ask it to reconstruct its
complement x¬C. The input h0 ∈ {0, 1}2I×T ×P is ob-
tained by masking the piano rolls x to obtain the context
xC and concatenating this with the corresponding mask:

i,t,p = 1(i,t)∈Cxi,t,p
h0
I+i,t,p = 1(i,t)∈C
h0

(4)

(5)

pθ(x) = pθ(x1)pθ(x2|x1) . . . pθ(xD|xD−1 . . . x1)

(2)

2 Here xo<d is used as shorthand for variables xo1 . . . xod−1 that

occur earlier in the ordering.

where the time and pitch dimensions are treated as spa-
tial dimensions to convolve over. Each instrument’s piano
i and mask h0
roll h0
I+i is treated as a separate channel and
convolved independently.

With the exception of the ﬁrst and ﬁnal layers, all con-
volutions preserve the size of the hidden representation.
That is, we use “same” padding throughout and all acti-
vations have the same number of channels H, such that
hl ∈ RH×T ×P for all 1 < l < L. Throughout our ex-
periments we used L = 64 layers and H = 128 chan-
nels. After each convolution we apply batch normaliza-
tion [21] (denoted by BN(·)) with statistics tied across
time and pitch. Batch normalization rescales activations
at each layer to have mean β and standard deviation γ,
which greatly improves optimization. After every second
convolution, we introduce a skip connection from the hid-
den state two levels below to reap the beneﬁts of residual
learning [15].

al = BN(Wl ∗ hl−1; γl, βl)
ReLU(al + hl−2)

hl =






hL = aL

if 3 < l < L − 1 and l mod 2 = 0

ReLU(al) otherwise

The ﬁnal activations hL ∈ RI×T ×P are passed through
the softmax function to obtain predictions for the pitch at
each instrument/time pair:

pθ(xi,t,p | xC, C) =

exp(hL
i,t,p)
p exp(hL

i,t,p)

(cid:80)

The loss function from Equation 3 is then given by

L(x; C, θ) = −

log pθ(xi,t | xC, C)

(9)

(6)

(7)

(8)

= −

xi,t,p log pθ(xi,t,p | xC, C)

(cid:88)

(i,t) /∈C
(cid:88)

(cid:88)

(i,t) /∈C

p

where pθ denotes the probability under the model with pa-
rameters θ = W1, γ1, β1, . . . , WL−1, γL−1, βL−1. We
train the model by minimizing

Ex∼p(x)EC∼p(C)

L(x; C, θ)

(10)

1
|¬C|

with respect to θ using stochastic gradient descent with
step size determined by Adam [22]. The expectations are
estimated by sampling piano rolls x from the training set
and drawing a single context C per sample.

4. EVALUATION

The log-likelihood of a given example is computed ac-
cording to Algorithm 1 by repeated application of Equa-
tion 8. Evaluation occurs one frame at a time, within which
the model conditions on its own predictions and does not
see the ground truth. Unlike notewise teacher-forcing,
where the ground truth is injected after each prediction,
the framewise evaluation is thus sensitive to accumulation

of error. This gives a more representative measure of qual-
ity of the generative model. For each example, we repeat
the evaluation process a number of times to average over
multiple orderings, and ﬁnally average across frames and
examples. For chronological evaluation, we draw only or-
derings that have the tls in increasing order.

Algorithm 1 Framewise log-likelihood evaluation

Given a piano roll x
Lm,i,t ← 0 for all m, i, t
for multiple orderings m = 0 . . . M do

C ← ∅, (cid:98)x ← x
Sample an ordering t1, t2 . . . tT over frames
for l = 0 . . . T do

Sample an ordering i1, i2 . . . iI over instruments
for k = 0 . . . I do

πp ← pθ(xik,tl,p | (cid:98)xC, C) for all p
Lm,ik,tl ← (cid:80)
(cid:98)xik,tl ∼ Cat(P, π)
C ← C ∪ (ik, tl)

p xik,tl,p log πp

end for
(cid:98)xC ← xC

end for

end for
return − 1
T

(cid:80)

t log 1
M

(cid:80)

m exp (cid:80)

i Lm,i,t

5. SAMPLING

We can sample from the model using the orderless NADE
ancestral sampling procedure, in which we ﬁrst sample an
ordering and then sample variables one by one according
to the ordering. However, we ﬁnd that this yields poor
samples, and we propose instead to use Gibbs sampling.

5.1 Orderless NADE Sampling

Sampling according to orderless NADE involves ﬁrst ran-
domly choosing an ordering and then sampling variables
one by one according to the chosen ordering. We use an
equivalent procedure in which we arrive at a random or-
dering by at each step randomly choosing the next variable
to sample. We start with an empty (zero everywhere) pi-
ano roll x0 and empty context C 0 and populate them itera-
tively by the following process. We feed the piano roll xs
and context C s into the model to obtain a set of categori-
cal distributions pθ(xi,t|xs
Cs , C s) for (i, t) /∈ C s. As the
xi,t are not conditionally independent, we cannot simply
sample from these distributions independently. However,
if we sample from one of them, we can compute new con-
ditional distributions for the others. Hence we randomly
choose one (i, t)s+1 /∈ C s to sample from, and let xs+1
i,t
equal the one-hot realization. Augment the context with
C s+1 = C s ∪ (i, t)s+1 and repeat until the piano roll is
populated. This procedure is easily generalized to tasks
such as melody harmonization and partial score comple-
tion by starting with a nonempty piano roll.

Unfortunately, samples thus generated are of low qual-
ity, which we surmise is due to accumulation of errors.

Model

Temporal resolution
eighth

quarter

sixteenth

NADE [4]
RNN-RBM [4]
RNN-NADE [4]
RNN-NADE (our implementation)
COCONET (chronological)
COCONET (random)

7.19
6.27
5.56
5.03
7.79 ± 0.09
5.03 ± 0.06

3.78
4.21 ± 0.05
1.84 ± 0.02

2.05
2.22 ± 0.03
0.57 ± 0.01

Table 1. Framewise negative log-likelihoods (NLLs) on the Bach corpus. We compare against [4], who used quarter-note
resolution. We also compare on higher temporal resolutions (eighth notes, sixteenth notes), against our own reimplemen-
tation of RNN-NADE. COCONET is an instance of orderless NADE, and as such we evaluate it on random orderings.
However, the baselines support only chronological frame ordering, and hence we evaluate our model in this setting as well.

This is a well-known weakness of autoregressive mod-
els. [3, 20, 24, 39] While the model provides condition-
als pθ(xi,t|xC, C) for all (i, t) /∈ C, some of these con-
ditionals may be better modeled than others. We sus-
pect in particular those conditionals used early on in the
procedure, for which the context C consists of very few
variables. Moreover, although the model is trained to be
order-agnostic, different orderings invoke different distri-
butions, which is another indication that some conditionals
are poorly learned. We test this hypothesis in Section 6.2.

IT ; it can be set lower than that to save computation at a
slight loss of sample quality.

[40] treat independent blocked Gibbs as a cheap ap-
proximation to ancestral sampling. Whereas plain an-
cestral sampling (5.1) requires O(IT ) model evaluations,
ancestral blocked Gibbs requires a prohibitive O(IT N )
model evaluations and independent Gibbs requires only
O(N ), where N can be chosen to be less than IT . More-
over, we ﬁnd that independent blocked Gibbs sampling in
fact yields better samples than plain ancestral sampling.

5.2 Gibbs Sampling

To remedy this, we allow the model to revisit its choices:
we repeatedly mask out some part of the piano roll and
then repopulate it. This is a form of blocked Gibbs sam-
pling [28]. Blocked sampling is crucial for mixing, as
the high temporal resolution of our representation causes
strong correlations between consecutive notes. For in-
stance, without blocked sampling, it would take many steps
to snap out of a long-held note. Similar considerations hold
for the Ising model from statistical mechanics, leading to
the Swendsen-Wang algorithm [33] in which large clusters
of variables are resampled at once.

We consider two strategies for resampling a given
ancestral sampling and indepen-
block of variables:
dent sampling. Ancestral sampling invokes the orderless
NADE sampling procedure described in Section 5.1 on the
Independent sam-
masked-out portion of the piano roll.
pling simply treats the masked-out variables x¬C as inde-
pendent given the context xC.

Using independent blocked Gibbs to sample from a
NADE model has been studied by [40], who propose to use
an annealed masking probability αn = max(αmin, αmax −
n(αmax −αmin)/(ηN )) for some minimum and maximum
probabilities αmin, αmax, total number of Gibbs steps N
and fraction η of time spent before settling onto the mini-
mum probability αmin. Initially, when the masking proba-
bility is high, the chain mixes fast but samples are poor due
to independent sampling. As αn decreases, the blocked
Gibbs process with independent resampling approaches
standard Gibbs where one variable at a time is resampled,
thus amortizing the effects of independent sampling. N is
a hyperparameter which as a rule of thumb we set equal to

6. EXPERIMENTS

We evaluate our approach on a popular corpus of four-part
Bach chorales. While the literature features many variants
of this dataset [1, 4, 14, 27], we report results on that used
by [4]. As the quarter-note temporal resolution used by [4]
is frankly too coarse to accurately convey counterpoint, we
also evaluate on eighth-note and sixteenth-note quantiza-
tions of the same data.

It should be noted that quantitative evaluation of gener-
ative models is fundamentally hard [34]. The gold standard
for evaluation is qualitative comparison by humans, and we
therefore report human evaluation results as well.

6.1 Data Log-likelihood

Table 4 compares the framewise log-likelihood of the test
data under variants of our model and those reported in [4].
We ﬁnd that the temporal resolution has a dramatic inﬂu-
ence on the performance, which we suspect is an artifact
of the performance metric. The log-likelihood is evalu-
ated by teacher-forcing, that is, the prediction of a frame is
conditioned on the ground truth of all previously predicted
frames. As temporal resolution increases, chord changes
become increasingly rare, and the model is increasingly
rewarded for simply holding notes over time.

We evaluate COCONET on both chronological and ran-
dom orderings, in both cases averaging likelihoods across
an ensemble of M = 5 orderings. The chronological or-
derings differ only in the ordering of instruments within
each frame. We see in Table 4 that fully random orderings
lead to signiﬁcantly better performance. We believe the
members of the more diverse random ensemble are more

mutually complementary. For example, a forward ordering
is uncertain at the beginning of a piece and more certain to-
ward the end, whereas a backward ordering is more certain
at the beginning and less certain toward the end.

6.2 Sample Quality

In Section 5 we conjectured that
the low quality of
NADE samples is due to poorly modeled conditionals
pθ(xi,t | xC, C) where C is small. We test this hypoth-
esis by evaluating the likelihood under the model of sam-
ples generated by the ancestral blocked Gibbs procedure
with C chosen according to independent Bernoulli vari-
ables. When we set the inclusion probability ρ to 0, we
obtain NADE. Increasing ρ increases the expected context
size |C|, which should yield better samples if our hypothe-
sis is true. The results shown in Table 6.2 conﬁrm that this
is the case. For these experiments, we used sample length
T = 32 time steps and number of Gibbs steps N = 100.

Sampling scheme
Ancestral Gibbs, ρ = 0.00 (NADE)
Ancestral Gibbs, ρ = 0.05
Ancestral Gibbs, ρ = 0.10
Ancestral Gibbs, ρ = 0.25
Ancestral Gibbs, ρ = 0.50
Independent Gibbs [40]

Framewise NLL
1.09 ± 0.06
1.08 ± 0.06
0.97 ± 0.05
0.80 ± 0.04
0.74 ± 0.04
0.52 ± 0.01

Table 2. Mean (± SEM) NLL under model of uncondi-
tioned samples generated from model by various schemes.

Figure 2 shows the convergence behavior of the various
Gibbs procedures, averaged over 100 runs. We see that for
low values of ρ (small C), the chains hardly make progress
beyond NADE in terms of likelihood. Higher values of ρ
(large C) enable the model to get off the ground and reach
signiﬁcantly better likelihood.

Figure 2. Likelihood under the model for ancestral Gibbs
samples obtained with various context distributions p(C).
NADE (Bernoulli(0.00)) is included for reference.

Figure 3. Human evaluations from MTurk on how many
times a sampling procedure or Bach is perceived as more
Bach-like. Error bars show the standard deviation of a bi-
nomial distribution ﬁtted to each’s binary win/loss counts.

6.3 Human Evaluations

To further compare the sample quality of different sam-
pling procedures, we carried out a listening test on Ama-
zon’s Mechanical Turk (MTurk). The procedures in-
clude orderless NADE ancestral sampling and indepen-
dent Gibbs [40], with each we generate four uncondi-
tioned samples of eight-measure lengths from empty piano
rolls. To have an absolute reference for the quality of sam-
ples, we include ﬁrst eight measures of four random Bach
chorale pieces from the validation set. Each fragment lasts
thirty-four seconds after synthesis.

For each MTurk hit, participants are asked to rate on a
Likert scale which of the two random samples they per-
ceive as more Bach-like. A total of 96 ratings were col-
lected, with each source involved in 64 (=96*2/3) pair-
wise comparisons. Figure 3 shows the number of times
each source was perceived as closer to Bach’s style. We
perform a Kruskal-Wallis H test on the ratings, χ2(2) =
12.23, p < 0.001, showing there are statistically signiﬁ-
cant differences between models. A post-hoc analysis us-
ing the Wilcoxon signed-rank test with Bonferroni correc-
tion showed that participants perceived samples from in-
dependent Gibbs as more Bach-like than ancestral sam-
pling (NADE), p < 0.05/3. This conﬁrms the loglikeli-
hood comparisons on sample quality in 6.2 that indepen-
dent Gibbs produces better samples. There was also a sig-
niﬁcance difference between Bach and ancestral samples
but not between Bach and independent Gibbs.

7. CONCLUSION

We introduced a convolutional approach to modeling mu-
sical scores based on the orderless NADE [35] framework.
Our experiments show that the NADE ancestral sampling
procedure yields poor samples, which we have argued is
because some conditionals are not captured well by the
model. We have shown that sample quality improves sig-
niﬁcantly when we use blocked Gibbs sampling to itera-
tively rewrite parts of the score. Moreover, annealed in-
dependent blocked Gibbs sampling as proposed by [40] is
not only faster but in fact produces better samples.

Acknowledgments

We thank Kyle Kastner, Guillaume Alain, Gabriel Huang,
the Google Brain Magenta
Curtis (Fjord) Hawthorne,
team, as well as Jason Freidenfelds for helpful feedback,
discussions, suggestions and support. We also thank Cal-
cul Qu´ebec and Compute Canada for computational sup-
port.

8. REFERENCES

[1] Moray Allan and Christopher KI Williams. Harmon-
ising chorales by probabilistic inference. Advances
in neural information processing systems, 17:25–32,
2005.

[2] Leonard E Baum and Ted Petrie. Statistical inference
for probabilistic functions of ﬁnite state markov chains.
The annals of mathematical statistics, 37(6):1554–
1563, 1966.

[3] Samy Bengio, Oriol Vinyals, Navdeep Jaitly, and
Noam Shazeer. Scheduled sampling for sequence pre-
diction with recurrent neural networks. In Advances in
Neural Information Processing Systems, pages 1171–
1179, 2015.

[4] Nicolas Boulanger-Lewandowski, Yoshua Bengio, and
Pascal Vincent. Modeling temporal dependencies in
high-dimensional sequences: Application to poly-
phonic music generation and transcription. Interna-
tional Conference on Machine Learning, 2012.

[5] Darrell Conklin. Music generation from statistical
models. In Proceedings of the AISB 2003 Symposium
on Artiﬁcial Intelligence and Creativity in the Arts and
Sciences, pages 30–35. Citeseer, 2003.

[6] David Cope. Computers and musical style. 1991.

[7] Mary Farbood and Bernd Sch¨oner. Analysis and syn-
thesis of palestrina-style counterpoint using markov
chains. In ICMC, 2001.

[8] Jose D Fern´andez and Francisco Vico. Ai methods
in algorithmic composition: A comprehensive survey.
Journal of Artiﬁcial Intelligence Research, 48:513–
582, 2013.

[9] Johann Joseph Fux. The study of counterpoint from
Johann Joseph Fux’s Gradus ad Parnassum. Number
277. WW Norton & Company, 1965.

[10] Leon A Gatys, Alexander S Ecker, and Matthias
Bethge. A neural algorithm of artistic style. arXiv
preprint arXiv:1508.06576, 2015.

[11] Kratarth Goel, Raunaq Vohra, and JK Sahoo. Poly-
phonic music generation by modeling temporal de-
pendencies using a rnn-dbn. In International Confer-
ence on Artiﬁcial Neural Networks, pages 217–224.
Springer, 2014.

[12] Ian Goodfellow, Mehdi Mirza, Aaron Courville, and
Yoshua Bengio. Multi-prediction deep boltzmann ma-
chines. In Advances in Neural Information Processing
Systems, pages 548–556, 2013.

[13] Ga¨etan Hadjeres and Franc¸ois Pachet. Deepbach: a
steerable model for bach chorales generation. arXiv
preprint arXiv:1612.01010, 2016.

[14] Ga¨etan Hadjeres, Jason Sakellariou, and Franc¸ois Pa-
chet. Style imitation and chord invention in poly-
phonic music with exponential families. arXiv preprint
arXiv:1609.05152, 2016.

[15] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian
Sun. Deep residual learning for image recognition.
arXiv preprint arXiv:1512.03385, 2015.

[16] Dorien Herremans and Kenneth S¨orensen. Composing
ﬁrst species counterpoint with a variable neighbour-
hood search algorithm. Journal of Mathematics and the
Arts, 6(4):169–189, 2012.

[17] Dorien Herremans and Kenneth S¨orensen. Composing
ﬁfth species counterpoint music with a variable neigh-
borhood search algorithm. Expert systems with appli-
cations, 40(16):6427–6437, 2013.

[18] Lejaren A Hiller Jr and Leonard M Isaacson. Musi-
cal composition with a high speed digital computer. In
Audio Engineering Society Convention 9. Audio Engi-
neering Society, 1957.

[19] Geoffrey E Hinton, Simon Osindero, and Yee-Whye
Teh. A fast learning algorithm for deep belief nets.
Neural computation, 18(7):1527–1554, 2006.

[20] Ferenc Husz´ar. How (not) to train your generative
model: Scheduled sampling, likelihood, adversary?
arXiv preprint arXiv:1511.05101, 2015.

[21] Sergey Ioffe and Christian Szegedy. Batch nor-
malization: Accelerating deep network training by
reducing internal covariate shift. arXiv preprint
arXiv:1502.03167, 2015.

[22] Diederik Kingma

A
method for stochastic optimization. arXiv preprint
arXiv:1412.6980, 2014.

and Jimmy Ba. Adam:

[23] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hin-
ton. Imagenet classiﬁcation with deep convolutional
neural networks. In Advances in neural information
processing systems, pages 1097–1105, 2012.

[24] Alex M Lamb, Anirudh Goyal ALIAS PARTH
GOYAL, Ying Zhang, Saizheng Zhang, Aaron C
Courville, and Yoshua Bengio. Professor forcing: A
new algorithm for training recurrent networks. In Ad-
vances In Neural Information Processing Systems,
pages 4601–4609, 2016.

[25] Hugo Larochelle and Iain Murray. The neural autore-
gressive distribution estimator. In AISTATS, volume 1,
page 2, 2011.

[39] Arun Venkatraman, Martial Hebert, and J Andrew Bag-
nell. Improving multi-step prediction of learned time
series models. In AAAI, pages 3024–3030, 2015.

[26] Stefan Lattner, Maarten Grachten,

and Gerhard
Widmer.
Imposing higher-level structure in poly-
phonic music generation using convolutional restricted
boltzmann machines and constraints. arXiv preprint
arXiv:1612.04742, 2016.

[40] Li Yao, Sherjil Ozair, Kyunghyun Cho, and Yoshua
Bengio. On the equivalence between deep nade and
generative stochastic networks. In Joint European Con-
ference on Machine Learning and Knowledge Discov-
ery in Databases, pages 322–336. Springer, 2014.

[27] Feynman Liang. Bachbot: Automatic composition in
the style of bach chorales. Masters thesis, University
of Cambridge, 2016.

[28] Jun S Liu. The collapsed gibbs sampler in bayesian
computations with applications to a gene regulation
problem. Journal of the American Statistical Associ-
ation, 89(427):958–966, 1994.

[29] Alexander Mordvintsev, Christopher Olah, and Mike
Tyka. Inceptionism: Going deeper into neural net-
works, 2015.

[30] Franc¸ois Pachet and Pierre Roy. Musical harmoniza-
tion with constraints: A survey. Constraints, 6(1):7–19,
2001.

[31] David E Rumelhart, Geoffrey E Hinton,

and
Ronald J Williams. Learning representations by back-
propagating errors. Cognitive modeling, 5(3):1, 1988.

[32] Paul Smolensky. Information processing in dynamical
systems: Foundations of harmony theory. Technical re-
port, DTIC Document, 1986.

[33] Robert H Swendsen and Jian-Sheng Wang. Nonuniver-
sal critical dynamics in monte carlo simulations. Phys-
ical review letters, 58(2):86, 1987.

[34] Lucas Theis, A¨aron van den Oord, and Matthias
Bethge. A note on the evaluation of generative mod-
els. arXiv preprint arXiv:1511.01844, 2015.

[35] Benigno Uria, Marc-Alexandre Cˆot´e, Karol Gre-
gor, Iain Murray, and Hugo Larochelle. Neural au-
toregressive distribution estimation. arXiv preprint
arXiv:1605.02226, 2016.

[36] Benigno Uria, Iain Murray, and Hugo Larochelle. A
deep and tractable density estimator. In ICML, pages
467–475, 2014.

[37] Aaron van den Oord, Sander Dieleman, Heiga
Zen, Karen Simonyan, Oriol Vinyals, Alex Graves,
and Koray
Nal Kalchbrenner, Andrew Senior,
Kavukcuoglu. Wavenet: A generative model for raw
audio. arXiv preprint arXiv:1609.03499, 2016.

[38] Aaron van den Oord, Nal Kalchbrenner, and Koray
Kavukcuoglu. Pixel recurrent neural networks. In Pro-
ceedings of The 33rd International Conference on Ma-
chine Learning, pages 1747–1756, 2016.

COUNTERPOINT BY CONVOLUTION

Cheng-Zhi Anna Huang(cid:63)†(cid:93)

Tim Cooijmans(cid:63)†

Adam Roberts(cid:93)

(cid:63) Equal contributions

Aaron Courville†

Douglas Eck(cid:93)
† MILA, Universit´e de Montr´eal

(cid:93) Google Brain

chengzhiannahuang@gmail.com, cooijmans.tim@umontreal.ca

9
1
0
2
 
r
a

M
 
8
1
 
 
]

G
L
.
s
c
[
 
 
1
v
7
2
2
7
0
.
3
0
9
1
:
v
i
X
r
a

ABSTRACT

Machine learning models of music typically break up the
task of composition into a chronological process, compos-
ing a piece of music in a single pass from beginning to
end. On the contrary, human composers write music in
a nonlinear fashion, scribbling motifs here and there, of-
ten revisiting choices previously made. In order to better
approximate this process, we train a convolutional neural
network to complete partial musical scores, and explore the
use of blocked Gibbs sampling as an analogue to rewriting.
Neither the model nor the generative procedure are tied to
a particular causal direction of composition.

Our model is an instance of orderless NADE [36],
which allows more direct ancestral sampling. However,
we ﬁnd that Gibbs sampling greatly improves sample qual-
ity, which we demonstrate to be due to some conditional
distributions being poorly modeled. Moreover, we show
that even the cheap approximate blocked Gibbs procedure
from [40] yields better samples than ancestral sampling,
based on both log-likelihood and human evaluation.

1. INTRODUCTION

Counterpoint is the process of placing notes against notes
to construct a polyphonic musical piece. [9] This is a chal-
lenging task, as each note has strong musical inﬂuences
on its neighbors and notes beyond. Human composers
have developed systems of rules to guide their composi-
tional decisions. However, these rules sometimes contra-
dict each other, and can fail to prevent their users from
going down musical dead ends. Statistical models of mu-
sic, which is our current focus, is one of the many compu-
tational approaches that can help composers try out ideas
more quickly, thus reducing the cost of exploration [8].

Whereas previous work in statistical music modeling
has relied mainly on sequence models such as Hidden
Markov Models (HMMs [2]) and Recurrent Neural Net-
works (RNNs [31]), we instead employ convolutional neu-
ral networks due to their invariance properties and em-

c(cid:13) Cheng-Zhi Anna Huang, Tim Cooijmans, Adam
Roberts, Aaron Courville, Douglas Eck. Licensed under a Creative
Commons Attribution 4.0 International License (CC BY 4.0). Attribu-
tion: Cheng-Zhi Anna Huang, Tim Cooijmans, Adam Roberts, Aaron
Courville, Douglas Eck.
“Counterpoint by Convolution”, 18th Inter-
national Society for Music Information Retrieval Conference, Suzhou,
China, 2017.

Figure 1. Blocked Gibbs inpainting of a corrupted Bach
chorale by COCONET. At each step, a random subset of
notes is removed, and the model is asked to infer their val-
ues. New values are sampled from the probability distribu-
tion put out by the model, and the process is repeated. Left:
annealed masks show resampled variables. Colors distin-
guish the four voices. Middle: grayscale heatmaps show
predictions p(xj | xC) summed across instruments. Right:
complete pianorolls after resampling the masked variables.
Bottom: a sample from NADE (left) and the original Bach
chorale fragment (right).

phasis on capturing local structure. Nevertheless, they
have also been shown to successfully model large-scale
structure [37, 38]. Moreover, convolutional neural net-
works have shown to be extremely versatile once trained,
as demonstrated by a variety of creative uses such as Deep-
Dream [29] and style transfer [10].

We introduce COCONET, a deep convolutional model
trained to reconstruct partial scores. Once trained, CO-
CONET provides direct access to all conditionals of the
form p(xi | xC) where C selects a fragment of a musi-
cal score x and i /∈ C is in its complement. COCONET
is an instance of deep orderless NADE [36], which learns
an ensemble of factorizations of the joint p(x), each cor-
responding to a different ordering. A related approach is
the multi-prediction training of deep Boltzmann machines
(MP-DBM) [12], which also gives a model that can predict
any subset of variables given its complement.

However, the sampling procedure for orderless NADE
treats the ensemble as a mixture and relies heavily on or-
dering. Sampling from an orderless NADE involves (ran-
domly) choosing an ordering, and sampling variables one
by one according to the chosen ordering. This process is
called ancestral sampling, as the order of sampling follows
the directed structure of the model. We have found that this
produces poor results for the highly structured and com-
plex domain of musical counterpoint.

Instead, we propose to use blocked-Gibbs sampling, a
Markov Chain Monte Carlo method to sample from a joint
probability distribution by repeatedly resampling subsets
of variables using conditional distributions derived from
the joint probability distribution. An instance of this was
previously explored by [40] who employed a NADE in the
transition operator for a Markov Chain, yielding a Gen-
erative Stochastic Network (GSN). The transition consists
of a corruption process that masks out a subset x¬C of
variables, followed by a process that independently resam-
ples variables xi (with i /∈ C) according to the distribu-
tion pθ(xi | xC) emitted by the model with parameters θ.
Crucially, the effects of independent sampling are amor-
tized by annealing the probability with which variables are
masked out. Whereas [40] treat their procedure as a cheap
approximation to ancestral sampling, we ﬁnd that it pro-
duces superior samples. Intuitively, the resampling process
allows the model to iteratively rewrite the score, giving it
the opportunity to correct its own mistakes.

COCONET addresses the general task of completing par-
tial scores; special cases of this task include ”bridging” two
musical fragments, and temporal upsampling and extrapo-
lation. Figure 1 shows an example of COCONET popu-
lating a partial piano roll using blocked-Gibbs sampling.
Code and samples are publically available. 1 Our samples
on a variety of generative tasks such as rewriting, melodic
harmonization and unconditioned polyphonic music gen-
eration show the versatility of our model. In this work we
focus on Bach chorales, and assume four voices are active
at all times. However, our model can be easily adapted to

1

Code:
Data:
Samples:

https://github.com/czhuang/coconet

https://github.com/czhuang/JSB-Chorales-dataset
https://coconets.github.io/

the more general, arbitrarily polyphonic representation as
used in [4].

Section 2 discusses related work in modeling music
composition, with a focus on counterpoint. The details of
our model and training procedure are laid out in Section 3.
We discuss evaluation under the model in Section 4, and
sampling from the model in Section 5. Results of quantita-
tive and qualitative evaluations are reported in Section 6.

2. RELATED WORK

Computers have been used since their early days for ex-
periments in music composition. A notable composition
is Hiller and Issacson’s string quartet Illiac Suite [18],
which experiments with statistical sequence models such
as Markov chains. One challenge in adapting such models
is that music consists of multiple interdependent streams
of events. Compare this to typical sequence domains such
as speech and language, which involve modeling a sin-
gle stream of events: a single speaker or a single stream
of words.
In music, extensive theories in counterpoint
have been developed to address the challenge of compos-
ing multiple streams of notes that coordinate. One notable
theory is due to Fux [9] from the Baroque period, which in-
troduces species counterpoint as a pedagogical scheme to
gradually introduce students to the complexity of counter-
point. In ﬁrst species counterpoint only one note is com-
posed against every note in a given ﬁxed melody (cantus
ﬁrmus), with all notes bearing equal durations and the re-
sulting vertical intervals consisting of only consonances.

Computer music researchers have taken inspiration
from this pedagogical scheme by ﬁrst teaching comput-
ers to write species counterpoint as opposed to full-ﬂedged
counterpoint. Farbood [7] uses Markov chains to capture
transition probabilities of different melodic and harmonic
transitions rules. Herremans [16, 17] takes an optimization
approach by writing down an objective function that con-
sists of existing rules of counterpoint and using a variable
neighbourhood search (VNS) algorithm to optimize it.

J.S. Bach chorales has been the main corpus in com-
puter music that serves as a starting point to tackle full-
ﬂedged counterpoint. A wide range of approaches have
been used to generate music in the style of Bach chorales,
for example rule-based and instance-based approaches
such as Cope’s recombinancy method [6]. This method in-
volves ﬁrst segmenting existing Bach chorales into smaller
chunks based on music theory, analyzing their function and
stylistic signatures and then re-concatenating the chunks
into new coherent works. Other approaches range from
constraint-based [30] to statistical methods [5]. In addi-
tion, [8] gives a comprehensive survey of AI methods used
not just for generating Bach chorales, but also algorithmic
composition in general.

Sequence models such as HMMs and RNNs are nat-
ural choices for modeling music. Successful application
of such models to polyphonic music often requires serial-
izing or otherwise re-representing the music to ﬁt the se-
quence paradigm. For instance, Liang in BachBot [27] se-
rializes four-part Bach chorales by interleaving the parts,

while Allan and Williams [1] construct a chord vocabu-
lary. Boulanger et al. [4] adopt a piano roll representation,
a binary matrix x where xit = 1 iff some instrument is
playing pitch i at time t. To model the joint probability
distribution of the multi-hot pitch vector xt, they employ
a Restricted Boltzmann Machine (RBM [19, 32]) or Neu-
ral Autoregressive Distribution Estimator (NADE [25]) at
each time step. Similarly Goel et al. [11] employ a Deep
Belief Network [19] on top of an RNN.

Hadjeres et al. [14] instead employ an undirected
Markov model to learn pairwise relationships between
neighboring notes up to a speciﬁed number of steps away
in a score. Sampling involves Markov Chain Monte Carlo
(MCMC) using the model as a Metropolis-Hastings (MH)
objective. The model permits constraints on the state space
to support tasks such as melody harmonization. However,
the Markov assumption can limit the expressivity of the
model.

Hadjeres and Pachet in DeepBach [13] model note pre-
dictions by breaking down its full context into three parts,
with the past and the future modeled by stacked LSTMs
going in the forward and backward directions respectively,
and the present harmonic context modeled by a third neural
network. The three are then combined by a fourth neural
network and used in Gibbs sampling for generation.

Lattner et al.

imposes higher-level structure by in-
terleaving selective Gibbs sampling on a convolutional
RBM [26] and gradient descent that minimizes cost to tem-
plate piece on features such as self-similarity. This pro-
cedure itself is wrapped in simulated annealing to ensure
steps do not lower the solution quality too much.

We opt for an orderless NADE training procedure which
enables us to train a mixture of all possible directed mod-
els simultaneously. Finally, an approximate blocked Gibbs
sampling procedure [40] allows fast generation from the
model.

3. MODEL

We employ machine learning techniques to obtain a gen-
erative model of musical counterpoint in the form of pi-
ano rolls. Given a dataset of observed musical pieces
x(1) . . . x(n) posited to come from some true distribution
p(x), we introduce a model pθ(x) with parameters θ.
In order to make pθ(x) close to p(x), we maximize the
data log-likelihood (cid:80)
i log pθ(x(i)) (an approximation of
Ex∼p(x) log pθ(x)) by stochastic gradient descent.

The joint distribution p(x) over D variables x1 . . . xD
is often difﬁcult to model directly and hence we construct
our model pθ(x) from simpler factors. In the NADE [25]
framework, the joint pθ(x) is factorized autoregressively,
one variable at a time, according to some ordering o =
o1 . . . oD, such that

pθ(x) =

pθ(xod | xo<d ).

(1)

(cid:89)

d

For example, it can be factorized in chronological order:

In general, NADE permits any one ﬁxed ordering, and al-
though all orderings are equivalent from a theoretical per-
spective, they differ in practice due to effects of optimiza-
tion and approximation.

Instead, we can train NADE for all orderings o simulta-
neously using the orderless NADE [36] training procedure.
This procedure relies on the observation that, thanks to pa-
rameter sharing, computing pθ(xod(cid:48) | xo<d) for all d(cid:48) ≥ d
is no more expensive than computing it only for d(cid:48) = d. 2
Hence for a given o and d we can simultaneously obtain
partial losses for all orderings that agree with o up to d:

L(x; o<d, θ) = −

log pθ(xod | xo<d, o<d, od)

(3)

(cid:88)

od

An orderless NADE model offers direct access to all dis-
tributions of the form pθ(xi|xC) conditioned on any set
of contextual variables xC = xo<d that might already be
known. This gives us a very ﬂexible generative model;
in particular, we can use these conditional distributions to
complete arbitrarily partial musical scores.

To train the model, we sample a training example x and
context C such that |C| ∼ U (1, D), and update θ based
on the gradient of the loss given by Equation 3. This loss
consists of D − d + 1 terms, each of which corresponds
to one ordering. To ensure all orderings are trained evenly
we must reweight the gradients by 1/(D − d + 1). This
correction, due to [36], ensures consistent estimation of the
joint negative log-likelihood log pθ(x).

In this work, the model pθ(x) is implemented by a deep
convolutional neural network [23]. This choice is moti-
vated by the locality of contrapuntal rules and their near-
invariance to translation, both in time and in pitch space.

We represent the music as a stack of piano rolls encoded
in a binary three-dimensional tensor x ∈ {0, 1}I×T ×P .
Here I denotes the number of instruments, T the number
of time steps, P the number of pitches, and xi,t,p = 1 iff
the ith instrument plays pitch p at time t. We will assume
each instrument plays exactly one pitch at a time, that is,
(cid:80)

p xi,t,p = 1 for all i, t.
Our focus is on four-part Bach chorales as used in prior
work [1,4,11,14,27]. Hence we assume I = 4 throughout.
We constrain ourselves to only the range that appears in
our training data (MIDI pitches 36 through 88). Time is
discretized at the level of 16th notes for similar reasons.
To curb memory requirements, we enforce T = 128 by
randomly cropping the training examples.

Given a training example x ∼ p(x), we present the
model with values of only a strict subset of its elements
xC = {x(i,t) | (i, t) ∈ C} and ask it to reconstruct its
complement x¬C. The input h0 ∈ {0, 1}2I×T ×P is ob-
tained by masking the piano rolls x to obtain the context
xC and concatenating this with the corresponding mask:

i,t,p = 1(i,t)∈Cxi,t,p
h0
I+i,t,p = 1(i,t)∈C
h0

(4)

(5)

pθ(x) = pθ(x1)pθ(x2|x1) . . . pθ(xD|xD−1 . . . x1)

(2)

2 Here xo<d is used as shorthand for variables xo1 . . . xod−1 that

occur earlier in the ordering.

where the time and pitch dimensions are treated as spa-
tial dimensions to convolve over. Each instrument’s piano
i and mask h0
roll h0
I+i is treated as a separate channel and
convolved independently.

With the exception of the ﬁrst and ﬁnal layers, all con-
volutions preserve the size of the hidden representation.
That is, we use “same” padding throughout and all acti-
vations have the same number of channels H, such that
hl ∈ RH×T ×P for all 1 < l < L. Throughout our ex-
periments we used L = 64 layers and H = 128 chan-
nels. After each convolution we apply batch normaliza-
tion [21] (denoted by BN(·)) with statistics tied across
time and pitch. Batch normalization rescales activations
at each layer to have mean β and standard deviation γ,
which greatly improves optimization. After every second
convolution, we introduce a skip connection from the hid-
den state two levels below to reap the beneﬁts of residual
learning [15].

al = BN(Wl ∗ hl−1; γl, βl)
ReLU(al + hl−2)

hl =






hL = aL

if 3 < l < L − 1 and l mod 2 = 0

ReLU(al) otherwise

The ﬁnal activations hL ∈ RI×T ×P are passed through
the softmax function to obtain predictions for the pitch at
each instrument/time pair:

pθ(xi,t,p | xC, C) =

exp(hL
i,t,p)
p exp(hL

i,t,p)

(cid:80)

The loss function from Equation 3 is then given by

L(x; C, θ) = −

log pθ(xi,t | xC, C)

(9)

(6)

(7)

(8)

= −

xi,t,p log pθ(xi,t,p | xC, C)

(cid:88)

(i,t) /∈C
(cid:88)

(cid:88)

(i,t) /∈C

p

where pθ denotes the probability under the model with pa-
rameters θ = W1, γ1, β1, . . . , WL−1, γL−1, βL−1. We
train the model by minimizing

Ex∼p(x)EC∼p(C)

L(x; C, θ)

(10)

1
|¬C|

with respect to θ using stochastic gradient descent with
step size determined by Adam [22]. The expectations are
estimated by sampling piano rolls x from the training set
and drawing a single context C per sample.

4. EVALUATION

The log-likelihood of a given example is computed ac-
cording to Algorithm 1 by repeated application of Equa-
tion 8. Evaluation occurs one frame at a time, within which
the model conditions on its own predictions and does not
see the ground truth. Unlike notewise teacher-forcing,
where the ground truth is injected after each prediction,
the framewise evaluation is thus sensitive to accumulation

of error. This gives a more representative measure of qual-
ity of the generative model. For each example, we repeat
the evaluation process a number of times to average over
multiple orderings, and ﬁnally average across frames and
examples. For chronological evaluation, we draw only or-
derings that have the tls in increasing order.

Algorithm 1 Framewise log-likelihood evaluation

Given a piano roll x
Lm,i,t ← 0 for all m, i, t
for multiple orderings m = 0 . . . M do

C ← ∅, (cid:98)x ← x
Sample an ordering t1, t2 . . . tT over frames
for l = 0 . . . T do

Sample an ordering i1, i2 . . . iI over instruments
for k = 0 . . . I do

πp ← pθ(xik,tl,p | (cid:98)xC, C) for all p
Lm,ik,tl ← (cid:80)
(cid:98)xik,tl ∼ Cat(P, π)
C ← C ∪ (ik, tl)

p xik,tl,p log πp

end for
(cid:98)xC ← xC

end for

end for
return − 1
T

(cid:80)

t log 1
M

(cid:80)

m exp (cid:80)

i Lm,i,t

5. SAMPLING

We can sample from the model using the orderless NADE
ancestral sampling procedure, in which we ﬁrst sample an
ordering and then sample variables one by one according
to the ordering. However, we ﬁnd that this yields poor
samples, and we propose instead to use Gibbs sampling.

5.1 Orderless NADE Sampling

Sampling according to orderless NADE involves ﬁrst ran-
domly choosing an ordering and then sampling variables
one by one according to the chosen ordering. We use an
equivalent procedure in which we arrive at a random or-
dering by at each step randomly choosing the next variable
to sample. We start with an empty (zero everywhere) pi-
ano roll x0 and empty context C 0 and populate them itera-
tively by the following process. We feed the piano roll xs
and context C s into the model to obtain a set of categori-
cal distributions pθ(xi,t|xs
Cs , C s) for (i, t) /∈ C s. As the
xi,t are not conditionally independent, we cannot simply
sample from these distributions independently. However,
if we sample from one of them, we can compute new con-
ditional distributions for the others. Hence we randomly
choose one (i, t)s+1 /∈ C s to sample from, and let xs+1
i,t
equal the one-hot realization. Augment the context with
C s+1 = C s ∪ (i, t)s+1 and repeat until the piano roll is
populated. This procedure is easily generalized to tasks
such as melody harmonization and partial score comple-
tion by starting with a nonempty piano roll.

Unfortunately, samples thus generated are of low qual-
ity, which we surmise is due to accumulation of errors.

Model

Temporal resolution
eighth

quarter

sixteenth

NADE [4]
RNN-RBM [4]
RNN-NADE [4]
RNN-NADE (our implementation)
COCONET (chronological)
COCONET (random)

7.19
6.27
5.56
5.03
7.79 ± 0.09
5.03 ± 0.06

3.78
4.21 ± 0.05
1.84 ± 0.02

2.05
2.22 ± 0.03
0.57 ± 0.01

Table 1. Framewise negative log-likelihoods (NLLs) on the Bach corpus. We compare against [4], who used quarter-note
resolution. We also compare on higher temporal resolutions (eighth notes, sixteenth notes), against our own reimplemen-
tation of RNN-NADE. COCONET is an instance of orderless NADE, and as such we evaluate it on random orderings.
However, the baselines support only chronological frame ordering, and hence we evaluate our model in this setting as well.

This is a well-known weakness of autoregressive mod-
els. [3, 20, 24, 39] While the model provides condition-
als pθ(xi,t|xC, C) for all (i, t) /∈ C, some of these con-
ditionals may be better modeled than others. We sus-
pect in particular those conditionals used early on in the
procedure, for which the context C consists of very few
variables. Moreover, although the model is trained to be
order-agnostic, different orderings invoke different distri-
butions, which is another indication that some conditionals
are poorly learned. We test this hypothesis in Section 6.2.

IT ; it can be set lower than that to save computation at a
slight loss of sample quality.

[40] treat independent blocked Gibbs as a cheap ap-
proximation to ancestral sampling. Whereas plain an-
cestral sampling (5.1) requires O(IT ) model evaluations,
ancestral blocked Gibbs requires a prohibitive O(IT N )
model evaluations and independent Gibbs requires only
O(N ), where N can be chosen to be less than IT . More-
over, we ﬁnd that independent blocked Gibbs sampling in
fact yields better samples than plain ancestral sampling.

5.2 Gibbs Sampling

To remedy this, we allow the model to revisit its choices:
we repeatedly mask out some part of the piano roll and
then repopulate it. This is a form of blocked Gibbs sam-
pling [28]. Blocked sampling is crucial for mixing, as
the high temporal resolution of our representation causes
strong correlations between consecutive notes. For in-
stance, without blocked sampling, it would take many steps
to snap out of a long-held note. Similar considerations hold
for the Ising model from statistical mechanics, leading to
the Swendsen-Wang algorithm [33] in which large clusters
of variables are resampled at once.

We consider two strategies for resampling a given
ancestral sampling and indepen-
block of variables:
dent sampling. Ancestral sampling invokes the orderless
NADE sampling procedure described in Section 5.1 on the
Independent sam-
masked-out portion of the piano roll.
pling simply treats the masked-out variables x¬C as inde-
pendent given the context xC.

Using independent blocked Gibbs to sample from a
NADE model has been studied by [40], who propose to use
an annealed masking probability αn = max(αmin, αmax −
n(αmax −αmin)/(ηN )) for some minimum and maximum
probabilities αmin, αmax, total number of Gibbs steps N
and fraction η of time spent before settling onto the mini-
mum probability αmin. Initially, when the masking proba-
bility is high, the chain mixes fast but samples are poor due
to independent sampling. As αn decreases, the blocked
Gibbs process with independent resampling approaches
standard Gibbs where one variable at a time is resampled,
thus amortizing the effects of independent sampling. N is
a hyperparameter which as a rule of thumb we set equal to

6. EXPERIMENTS

We evaluate our approach on a popular corpus of four-part
Bach chorales. While the literature features many variants
of this dataset [1, 4, 14, 27], we report results on that used
by [4]. As the quarter-note temporal resolution used by [4]
is frankly too coarse to accurately convey counterpoint, we
also evaluate on eighth-note and sixteenth-note quantiza-
tions of the same data.

It should be noted that quantitative evaluation of gener-
ative models is fundamentally hard [34]. The gold standard
for evaluation is qualitative comparison by humans, and we
therefore report human evaluation results as well.

6.1 Data Log-likelihood

Table 4 compares the framewise log-likelihood of the test
data under variants of our model and those reported in [4].
We ﬁnd that the temporal resolution has a dramatic inﬂu-
ence on the performance, which we suspect is an artifact
of the performance metric. The log-likelihood is evalu-
ated by teacher-forcing, that is, the prediction of a frame is
conditioned on the ground truth of all previously predicted
frames. As temporal resolution increases, chord changes
become increasingly rare, and the model is increasingly
rewarded for simply holding notes over time.

We evaluate COCONET on both chronological and ran-
dom orderings, in both cases averaging likelihoods across
an ensemble of M = 5 orderings. The chronological or-
derings differ only in the ordering of instruments within
each frame. We see in Table 4 that fully random orderings
lead to signiﬁcantly better performance. We believe the
members of the more diverse random ensemble are more

mutually complementary. For example, a forward ordering
is uncertain at the beginning of a piece and more certain to-
ward the end, whereas a backward ordering is more certain
at the beginning and less certain toward the end.

6.2 Sample Quality

In Section 5 we conjectured that
the low quality of
NADE samples is due to poorly modeled conditionals
pθ(xi,t | xC, C) where C is small. We test this hypoth-
esis by evaluating the likelihood under the model of sam-
ples generated by the ancestral blocked Gibbs procedure
with C chosen according to independent Bernoulli vari-
ables. When we set the inclusion probability ρ to 0, we
obtain NADE. Increasing ρ increases the expected context
size |C|, which should yield better samples if our hypothe-
sis is true. The results shown in Table 6.2 conﬁrm that this
is the case. For these experiments, we used sample length
T = 32 time steps and number of Gibbs steps N = 100.

Sampling scheme
Ancestral Gibbs, ρ = 0.00 (NADE)
Ancestral Gibbs, ρ = 0.05
Ancestral Gibbs, ρ = 0.10
Ancestral Gibbs, ρ = 0.25
Ancestral Gibbs, ρ = 0.50
Independent Gibbs [40]

Framewise NLL
1.09 ± 0.06
1.08 ± 0.06
0.97 ± 0.05
0.80 ± 0.04
0.74 ± 0.04
0.52 ± 0.01

Table 2. Mean (± SEM) NLL under model of uncondi-
tioned samples generated from model by various schemes.

Figure 2 shows the convergence behavior of the various
Gibbs procedures, averaged over 100 runs. We see that for
low values of ρ (small C), the chains hardly make progress
beyond NADE in terms of likelihood. Higher values of ρ
(large C) enable the model to get off the ground and reach
signiﬁcantly better likelihood.

Figure 2. Likelihood under the model for ancestral Gibbs
samples obtained with various context distributions p(C).
NADE (Bernoulli(0.00)) is included for reference.

Figure 3. Human evaluations from MTurk on how many
times a sampling procedure or Bach is perceived as more
Bach-like. Error bars show the standard deviation of a bi-
nomial distribution ﬁtted to each’s binary win/loss counts.

6.3 Human Evaluations

To further compare the sample quality of different sam-
pling procedures, we carried out a listening test on Ama-
zon’s Mechanical Turk (MTurk). The procedures in-
clude orderless NADE ancestral sampling and indepen-
dent Gibbs [40], with each we generate four uncondi-
tioned samples of eight-measure lengths from empty piano
rolls. To have an absolute reference for the quality of sam-
ples, we include ﬁrst eight measures of four random Bach
chorale pieces from the validation set. Each fragment lasts
thirty-four seconds after synthesis.

For each MTurk hit, participants are asked to rate on a
Likert scale which of the two random samples they per-
ceive as more Bach-like. A total of 96 ratings were col-
lected, with each source involved in 64 (=96*2/3) pair-
wise comparisons. Figure 3 shows the number of times
each source was perceived as closer to Bach’s style. We
perform a Kruskal-Wallis H test on the ratings, χ2(2) =
12.23, p < 0.001, showing there are statistically signiﬁ-
cant differences between models. A post-hoc analysis us-
ing the Wilcoxon signed-rank test with Bonferroni correc-
tion showed that participants perceived samples from in-
dependent Gibbs as more Bach-like than ancestral sam-
pling (NADE), p < 0.05/3. This conﬁrms the loglikeli-
hood comparisons on sample quality in 6.2 that indepen-
dent Gibbs produces better samples. There was also a sig-
niﬁcance difference between Bach and ancestral samples
but not between Bach and independent Gibbs.

7. CONCLUSION

We introduced a convolutional approach to modeling mu-
sical scores based on the orderless NADE [35] framework.
Our experiments show that the NADE ancestral sampling
procedure yields poor samples, which we have argued is
because some conditionals are not captured well by the
model. We have shown that sample quality improves sig-
niﬁcantly when we use blocked Gibbs sampling to itera-
tively rewrite parts of the score. Moreover, annealed in-
dependent blocked Gibbs sampling as proposed by [40] is
not only faster but in fact produces better samples.

Acknowledgments

We thank Kyle Kastner, Guillaume Alain, Gabriel Huang,
the Google Brain Magenta
Curtis (Fjord) Hawthorne,
team, as well as Jason Freidenfelds for helpful feedback,
discussions, suggestions and support. We also thank Cal-
cul Qu´ebec and Compute Canada for computational sup-
port.

8. REFERENCES

[1] Moray Allan and Christopher KI Williams. Harmon-
ising chorales by probabilistic inference. Advances
in neural information processing systems, 17:25–32,
2005.

[2] Leonard E Baum and Ted Petrie. Statistical inference
for probabilistic functions of ﬁnite state markov chains.
The annals of mathematical statistics, 37(6):1554–
1563, 1966.

[3] Samy Bengio, Oriol Vinyals, Navdeep Jaitly, and
Noam Shazeer. Scheduled sampling for sequence pre-
diction with recurrent neural networks. In Advances in
Neural Information Processing Systems, pages 1171–
1179, 2015.

[4] Nicolas Boulanger-Lewandowski, Yoshua Bengio, and
Pascal Vincent. Modeling temporal dependencies in
high-dimensional sequences: Application to poly-
phonic music generation and transcription. Interna-
tional Conference on Machine Learning, 2012.

[5] Darrell Conklin. Music generation from statistical
models. In Proceedings of the AISB 2003 Symposium
on Artiﬁcial Intelligence and Creativity in the Arts and
Sciences, pages 30–35. Citeseer, 2003.

[6] David Cope. Computers and musical style. 1991.

[7] Mary Farbood and Bernd Sch¨oner. Analysis and syn-
thesis of palestrina-style counterpoint using markov
chains. In ICMC, 2001.

[8] Jose D Fern´andez and Francisco Vico. Ai methods
in algorithmic composition: A comprehensive survey.
Journal of Artiﬁcial Intelligence Research, 48:513–
582, 2013.

[9] Johann Joseph Fux. The study of counterpoint from
Johann Joseph Fux’s Gradus ad Parnassum. Number
277. WW Norton & Company, 1965.

[10] Leon A Gatys, Alexander S Ecker, and Matthias
Bethge. A neural algorithm of artistic style. arXiv
preprint arXiv:1508.06576, 2015.

[11] Kratarth Goel, Raunaq Vohra, and JK Sahoo. Poly-
phonic music generation by modeling temporal de-
pendencies using a rnn-dbn. In International Confer-
ence on Artiﬁcial Neural Networks, pages 217–224.
Springer, 2014.

[12] Ian Goodfellow, Mehdi Mirza, Aaron Courville, and
Yoshua Bengio. Multi-prediction deep boltzmann ma-
chines. In Advances in Neural Information Processing
Systems, pages 548–556, 2013.

[13] Ga¨etan Hadjeres and Franc¸ois Pachet. Deepbach: a
steerable model for bach chorales generation. arXiv
preprint arXiv:1612.01010, 2016.

[14] Ga¨etan Hadjeres, Jason Sakellariou, and Franc¸ois Pa-
chet. Style imitation and chord invention in poly-
phonic music with exponential families. arXiv preprint
arXiv:1609.05152, 2016.

[15] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian
Sun. Deep residual learning for image recognition.
arXiv preprint arXiv:1512.03385, 2015.

[16] Dorien Herremans and Kenneth S¨orensen. Composing
ﬁrst species counterpoint with a variable neighbour-
hood search algorithm. Journal of Mathematics and the
Arts, 6(4):169–189, 2012.

[17] Dorien Herremans and Kenneth S¨orensen. Composing
ﬁfth species counterpoint music with a variable neigh-
borhood search algorithm. Expert systems with appli-
cations, 40(16):6427–6437, 2013.

[18] Lejaren A Hiller Jr and Leonard M Isaacson. Musi-
cal composition with a high speed digital computer. In
Audio Engineering Society Convention 9. Audio Engi-
neering Society, 1957.

[19] Geoffrey E Hinton, Simon Osindero, and Yee-Whye
Teh. A fast learning algorithm for deep belief nets.
Neural computation, 18(7):1527–1554, 2006.

[20] Ferenc Husz´ar. How (not) to train your generative
model: Scheduled sampling, likelihood, adversary?
arXiv preprint arXiv:1511.05101, 2015.

[21] Sergey Ioffe and Christian Szegedy. Batch nor-
malization: Accelerating deep network training by
reducing internal covariate shift. arXiv preprint
arXiv:1502.03167, 2015.

[22] Diederik Kingma

A
method for stochastic optimization. arXiv preprint
arXiv:1412.6980, 2014.

and Jimmy Ba. Adam:

[23] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hin-
ton. Imagenet classiﬁcation with deep convolutional
neural networks. In Advances in neural information
processing systems, pages 1097–1105, 2012.

[24] Alex M Lamb, Anirudh Goyal ALIAS PARTH
GOYAL, Ying Zhang, Saizheng Zhang, Aaron C
Courville, and Yoshua Bengio. Professor forcing: A
new algorithm for training recurrent networks. In Ad-
vances In Neural Information Processing Systems,
pages 4601–4609, 2016.

[25] Hugo Larochelle and Iain Murray. The neural autore-
gressive distribution estimator. In AISTATS, volume 1,
page 2, 2011.

[39] Arun Venkatraman, Martial Hebert, and J Andrew Bag-
nell. Improving multi-step prediction of learned time
series models. In AAAI, pages 3024–3030, 2015.

[26] Stefan Lattner, Maarten Grachten,

and Gerhard
Widmer.
Imposing higher-level structure in poly-
phonic music generation using convolutional restricted
boltzmann machines and constraints. arXiv preprint
arXiv:1612.04742, 2016.

[40] Li Yao, Sherjil Ozair, Kyunghyun Cho, and Yoshua
Bengio. On the equivalence between deep nade and
generative stochastic networks. In Joint European Con-
ference on Machine Learning and Knowledge Discov-
ery in Databases, pages 322–336. Springer, 2014.

[27] Feynman Liang. Bachbot: Automatic composition in
the style of bach chorales. Masters thesis, University
of Cambridge, 2016.

[28] Jun S Liu. The collapsed gibbs sampler in bayesian
computations with applications to a gene regulation
problem. Journal of the American Statistical Associ-
ation, 89(427):958–966, 1994.

[29] Alexander Mordvintsev, Christopher Olah, and Mike
Tyka. Inceptionism: Going deeper into neural net-
works, 2015.

[30] Franc¸ois Pachet and Pierre Roy. Musical harmoniza-
tion with constraints: A survey. Constraints, 6(1):7–19,
2001.

[31] David E Rumelhart, Geoffrey E Hinton,

and
Ronald J Williams. Learning representations by back-
propagating errors. Cognitive modeling, 5(3):1, 1988.

[32] Paul Smolensky. Information processing in dynamical
systems: Foundations of harmony theory. Technical re-
port, DTIC Document, 1986.

[33] Robert H Swendsen and Jian-Sheng Wang. Nonuniver-
sal critical dynamics in monte carlo simulations. Phys-
ical review letters, 58(2):86, 1987.

[34] Lucas Theis, A¨aron van den Oord, and Matthias
Bethge. A note on the evaluation of generative mod-
els. arXiv preprint arXiv:1511.01844, 2015.

[35] Benigno Uria, Marc-Alexandre Cˆot´e, Karol Gre-
gor, Iain Murray, and Hugo Larochelle. Neural au-
toregressive distribution estimation. arXiv preprint
arXiv:1605.02226, 2016.

[36] Benigno Uria, Iain Murray, and Hugo Larochelle. A
deep and tractable density estimator. In ICML, pages
467–475, 2014.

[37] Aaron van den Oord, Sander Dieleman, Heiga
Zen, Karen Simonyan, Oriol Vinyals, Alex Graves,
and Koray
Nal Kalchbrenner, Andrew Senior,
Kavukcuoglu. Wavenet: A generative model for raw
audio. arXiv preprint arXiv:1609.03499, 2016.

[38] Aaron van den Oord, Nal Kalchbrenner, and Koray
Kavukcuoglu. Pixel recurrent neural networks. In Pro-
ceedings of The 33rd International Conference on Ma-
chine Learning, pages 1747–1756, 2016.

