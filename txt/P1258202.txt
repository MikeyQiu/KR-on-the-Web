MoCoGAN: Decomposing Motion and Content for Video Generation

Sergey Tulyakov,
Snap Research
stulyakov@snap.com

Ming-Yu Liu, Xiaodong Yang,

Jan Kautz

NVIDIA
{mingyul,xiaodongy,jkautz}@nvidia.com

7
1
0
2
 
c
e
D
 
4
1
 
 
]

V
C
.
s
c
[
 
 
2
v
3
9
9
4
0
.
7
0
7
1
:
v
i
X
r
a

Abstract

Visual signals in a video can be divided into content and
motion. While content speciﬁes which objects are in the
video, motion describes their dynamics. Based on this prior,
we propose the Motion and Content decomposed Genera-
tive Adversarial Network (MoCoGAN) framework for video
generation. The proposed framework generates a video by
mapping a sequence of random vectors to a sequence of
video frames. Each random vector consists of a content
part and a motion part. While the content part is kept
ﬁxed, the motion part is realized as a stochastic process. To
learn motion and content decomposition in an unsupervised
manner, we introduce a novel adversarial learning scheme
utilizing both image and video discriminators. Extensive
experimental results on several challenging datasets with
qualitative and quantitative comparison to the state-of-the-
art approaches, verify effectiveness of the proposed frame-
work. In addition, we show that MoCoGAN allows one to
generate videos with same content but different motion as
well as videos with different content and same motion.

1. Introduction

Deep generative models have recently received an in-
creasing amount of attention, not only because they provide
a means to learn deep feature representations in an unsuper-
vised manner that can potentially leverage all the unlabeled
images on the Internet for training, but also because they
can be used to generate novel images necessary for various
vision applications. As steady progress toward better image
generation is made, it is also important to study the video
generation problem. However, the extension from gener-
ating images to generating videos turns out to be a highly
challenging task, although the generated data has just one
more dimension – the time dimension.

We argue video generation is much harder for the fol-
lowing reasons. First, since a video is a spatio-temporal
recording of visual information of objects performing var-
ious actions, a generative model needs to learn the plausi-
ble physical motion models of objects in addition to learn-
ing their appearance models. If the learned object motion

Figure 1: MoCoGAN adopts a motion and content decom-
posed representation for video generation. It uses an image
latent space (each latent code represents an image) and di-
vides the latent space into content and motion subspaces.
By sampling a point in the content subspace and sampling
different trajectories in the motion subspace, it generates
videos of the same object performing different motion. By
sampling different points in the content subspace and the
same motion trajectory in the motion subspace, it generates
videos of different objects performing the same motion.

model is incorrect, the generated video may contain objects
performing physically impossible motion. Second, the time
dimension brings in a huge amount of variations. Consider
the amount of speed variations that a person can have when
performing a squat movement. Each speed pattern results
in a different video, although the appearances of the human
in the videos are the same. Third, as human beings have
evolved to be sensitive to motion, motion artifacts are par-
ticularly perceptible.

Recently, a few attempts to approach the video genera-
tion problem were made through generative adversarial net-
works (GANs) [12]. Vondrick et al. [40] hypothesize that a
video clip is a point in a latent space and proposed a VGAN
framework for learning a mapping from the latent space to

1

video clips. A similar approach was proposed in the TGAN
work [30]. We argue that assuming a video clip is a point
in the latent space unnecessarily increases the complexity
of the problem, because videos of the same action with dif-
ferent execution speed are represented by different points
in the latent space. Moreover, this assumption forces ev-
ery generated video clip to have the same length, while the
length of real-world video clips varies. An alternative (and
likely more intuitive and efﬁcient) approach would assume
a latent space of images and consider that a video clip is
generated by traversing the points in the latent space. Video
clips of different lengths correspond to latent space trajec-
tories of different lengths.

In addition, as videos are about objects (content) per-
forming actions (motion), the latent space of images should
be further decomposed into two subspaces, where the devi-
ation of a point in the ﬁrst subspace (the content subspace)
leads content changes in a video clip and the deviation in
the second subspace (the motion subspace) results in tem-
poral motions. Through this modeling, videos of an action
with different execution speeds will only result in different
traversal speeds of a trajectory in the motion space. Decom-
posing motion and content allows a more controlled video
generation process. By changing the content representation
while ﬁxing the motion trajectory, we have videos of dif-
ferent objects performing the same motion. By changing
motion trajectories while ﬁxing the content representation,
we have videos of the same object performing different mo-
tion as illustrated in Fig. 1.

In this paper, we propose the Motion and Content de-
composed Generative Adversarial Network (MoCoGAN)
framework for video generation. It generates a video clip
by sequentially generating video frames. At each time step,
an image generative network maps a random vector to an
image. The random vector consists of two parts where the
ﬁrst is sampled from a content subspace and the second is
sampled from a motion subspace. Since content in a short
video clip usually remains the same, we model the content
space using a Gaussian distribution and use the same real-
ization to generate each frame in a video clip. On the other
hand, sampling from the motion space is achieved through
a recurrent neural network where the network parameters
are learned during training. Despite lacking supervision re-
garding the decomposition of motion and content in nat-
ural videos, we show that MoCoGAN can learn to disen-
tangle these two factors through a novel adversarial train-
ing scheme. Through extensive qualitative and quantitative
experimental validations with comparison to the state-of-
the-art approaches including VGAN [40] and TGAN [30],
as well as the future frame prediction methods including
Conditional-VGAN (C-VGAN) [40] and Motion and Con-
tent Network (MCNET) [39], we verify the effectiveness of
MoCoGAN.

1.1. Related Work

Video generation is not a new problem. Due to limita-
tions in computation, data, and modeling tools, early video
generation works focused on generating dynamic texture
patterns [34, 41, 9]. In the recent years, with the availability
of GPUs, Internet videos, and deep neural networks, we are
now better positioned to tackle this intriguing problem.

Various deep generative models were recently proposed
for image generation including GANs [12], variational au-
toencoders (VAEs) [20, 28, 36], and PixelCNNs [38]. In
this paper, we propose the MoCoGAN framework for video
generation, which is based on GANs.

Multiple GAN-based image generation frameworks
were proposed. Denton et al. [8] showed a Laplacian pyra-
mid implementation. Radford et al. [27] used a deeper con-
volution network. Zhang et al. [43] stacked two generative
networks to progressively render realistic images. Coupled
GANs [22] learned to generate corresponding images in dif-
ferent domains, later extended to translate an image from
one domain to a different domain in an unsupervised fash-
ion [21]. InfoGAN [5] learned a more interpretable latent
representation. Salimans et al. [31] proposed several GAN
training tricks. The WGAN [3] and LSGAN [23] frame-
works adopted alternative distribution distance metrics for
more stable adversarial training. Roth et al. [29] proposed
a special gradient penalty to further stabilize training. Kar-
ras et al. [18] used progressive growing of the discriminator
and the generator to generate high resolution images. The
proposed MoCoGAN framework generates a video clip by
sequentially generating images using an image generator.
The framework can easily leverage advances in image gen-
eration in the GAN framework for improving the quality of
the generated videos. As discussed in Section 1, [40, 30]
extended the GAN framework to the video generation prob-
lem by assuming a latent space of video clips where all the
clips have the same length.

Recurrent neural networks for image generation were
previously explored in [14, 16]. Speciﬁcally, some works
used recurrent mechanisms to iteratively reﬁne a generated
image. Our work is different to [14, 16] in that we use
the recurrent mechanism to generate motion embeddings
of video frames in a video clip. The image generation is
achieved through a convolutional neural network.

The future frame prediction problem studied in [33, 26,
24, 17, 10, 37, 42, 39, 7] is different to the video gen-
eration problem.
In future frame prediction, the goal is
to predict future frames in a video given the observed
frames in the video. Previous works on future frame pre-
diction can be roughly divided into two categories where
one focuses on generating raw pixel values in future frames
based on the observed ones [33, 26, 24, 17, 42, 39], while
the other focuses on generating transformations for reshuf-
ﬂing the pixels in the previous frames to construct fu-

2

ture frames [10, 37]. The availability of previous frames
makes future frame prediction a conditional image gener-
ation problem, which is different to the video generation
problem where the input to the generative network is only a
vector drawn from a latent space. We note that [39] used a
convolutional LSTM [15] encoder to encode temporal dif-
ferences between consecutive previous frames for extract-
ing motion information and a convolutional encoder to ex-
tract content information from the current image. The con-
catenation of the motion and content information was then
fed to a decoder to predict future frames.

1.2. Contributions

Our contributions are as follows:

1. We propose a novel GAN framework for unconditional
video generation, mapping noise vectors to videos.

2. We show the proposed framework provides a means to
control content and motion in video generation, which is
absent in the existing video generation frameworks.

3. We conduct extensive experimental validation on bench-
mark datasets with both quantitative and subjective com-
parison to the state-of-the-art video generation algo-
rithms including VGAN[40] and TGAN [30] to verify
the effectiveness of the proposed algorithm.

2. Generative Adversarial Networks

GANs [12] consist of a generator and a discriminator.
The objective of the generator is to generate images resem-
bling real images, while the objective of the discriminator
is to distinguish real images from generated ones.

Let x be a real image drawn from an image distribution,
pX , and z be a random vector in ZI ≡ Rd. Let GI and DI
be the image generator and the image discriminator. The
generator takes z as input and outputs an image, ˜x = GI(z),
that has the same support as x. We denote the distribution
of GI(z) as pGI . The discriminator estimates the probability
that an input image is drawn from pX . Ideally, DI(x) = 1
if x ∼ pX and DI(˜x) = 0 if ˜x ∼ pGI. Training of GI and
DI is achieved via solving a minimax problem given by

max
GI

min
DI

FI(DI, GI)

where the functional FI is given by

FI(DI, GI) = Ex∼pX [− log DI(x)] +
Ez∼pZI

[− log(1 − DI(GI(z)))].

In practice, (1) is solved by alternating gradient update.

Goodfellow et al. [12] show that, given enough capacity
to DI and GI and sufﬁcient training iterations, the distri-
bution pGI converges to pX . As a result, from a random
vector input z, the network GI can synthesize an image that
resembles one drawn from the true distribution, pX .

(1)

(2)

3

2.1. Extension to Fixed-length Video Generation

Recently, [40] extended the GAN framework to video
generation by proposing a Video GAN (VGAN) framework.
Let vL = [x(1), ..., x(L)] be a video clip with L frames.
The video generation in VGAN is achieved by replacing
the vanilla CNN-based image generator and discriminator,
GI and DI, with a spatio-temporal CNN-based video gener-
ator and discriminator, GVL and DVL. The video generator
GVL maps a random vector z ∈ ZVL ≡ Rd to a ﬁxed-length
video clip, ˜vL = [˜x(1), ..., ˜x(L)] = GVL (z) and the video
discriminator DVL differentiates real video clips from gen-
erated ones. Ideally, DVL (vL) = 1 if vL is sampled from
pV L and DVL (˜vL) = 0 if ˜vL is sampled from the video
generator distribution pGVL . The TGAN framework [30]
also maps a random vector to a ﬁxed length clip. The dif-
ference is that TGAN maps the random vector, representing
a ﬁxed-length video, to a ﬁxed number of random vectors,
representing individual frames in the video clip and uses an
image generator for generation. Instead of using the vanilla
GAN framework for minimizing the Jensen-Shannon diver-
gence, the TGAN training is based on the WGAN frame-
work [3] and minimizes the earth mover distance.

3. Motion and Content Decomposed GAN

In MoCoGAN, we assume a latent space of images ZI ≡
Rd where each point z ∈ ZI represents an image, and a
video of K frames is represented by a path of length K in
the latent space, [z(1), ..., z(K)]. By adopting this formula-
tion, videos of different lengths can be generated by paths of
different lengths. Moreover, videos of the same action ex-
ecuted with different speeds can be generated by traversing
the same path in the latent space with different speeds.

We further assume ZI is decomposed into the content
ZC and motion ZM subspaces: ZI = ZC × ZM where
ZC = RdC , ZM = RdM , and d = dC + dM. The content
subspace models motion-independent appearance in videos,
while the motion subspace models motion-dependent ap-
pearance in videos. For example, in a video of a person
smiling, content represents the identity of the person, while
motion represents the changes of facial muscle conﬁgura-
tions of the person. A pair of the person’s identity and the
facial muscle conﬁguration represents a face image of the
person. A sequence of these pairs represents a video clip
of the person smiling. By swapping the look of the person
with the look of another person, a video of a different person
smiling is represented.

We model the content subspace using a Gaussian distri-
bution: zC ∼ pZC ≡ N (z|0, IdC ) where IdC is an identity
matrix of size dC × dC. Based on the observation that the
content remains largely the same in a short video clip, we
use the same realization, zC, for generating different frames
in a video clip. Motion in the video clip is modeled by a

GI, the image discriminator, DI, and the video discrimi-
nator, DV. The image generator generates a video clip by
sequentially mapping vectors in ZI to images, from a se-
(cid:3)] to a sequence of im-
(cid:3), ..., (cid:2) zC
quence of vectors [(cid:2) zC
z(K)
z(1)
M
M
(cid:3)) and
ages, ˜v = [˜x(1), ..., ˜x(K)], where ˜x(k) = GI((cid:2) zC
z(k)
M
z(k)
M ’s are from the recurrent neural network, RM. We note
that the video length K can vary for each video generation.
Both DI and DV play the judge role, providing criticisms
to GI and RM. The image discriminator DI is specialized
in criticizing GI based on individual images. It is trained to
determine if a frame is sampled from a real video clip, v,
or from ˜v. On the other hand, DV provides criticisms to GI
based on the generated video clip. DV takes a ﬁxed length
video clip, say T frames, and decides if a video clip was
sampled from a real video or from ˜v. Different from DI,
which is based on vanilla CNN architecture, DV is based on
a spatio-temporal CNN architecture. We note that the clip
length T is a hyperparameter, which is set to 16 throughout
our experiments. We also note that T can be smaller than
the generated video length K. A video of length K can be
divided into K − T + 1 clips in a sliding-window fashion,
and each of the clips can be fed into DV.

The video discriminator DV also evaluates the generated
motion. Since GI has no concept of motion, the criticisms
on the motion part go directly to the recurrent neural net-
work, RM. In order to generate a video with realistic dy-
namics that fools DV, RM has to learn to generate a se-
quence of motion codes [z(1)
M ] from a sequence of
i.i.d. noise inputs [(cid:15)(1), ..., (cid:15)(K)] in a way such that GI can
map z(k) = [zC, z(k)

M ] to consecutive frames in a video.

M , ..., z(K)

Ideally, DV alone should be sufﬁcient for training GI
and RM, because DV provides feedback on both static im-
age appearance and video dynamics. However, we found
that using DI signiﬁcantly improves the convergence of the
adversarial training. This is because training DI is simpler,
as it only needs to focus on static appearances. Fig. 2 shows
visual representation of the MoCoGAN framework.

Learning. Let pV be the distribution of video clips of
variable lengths. Let κ be a discrete random variable denot-
ing the length of a video clip sampled from pV. (In practice,
we can estimate the distribution of κ, termed pK, by com-
puting a histogram of video clip length from training data).
To generate a video, we ﬁrst sample a content vector, zC,
and a length, κ. We then run RM for κ steps and, at each
time step, RM takes a random variable (cid:15) as the input. A
generated video is then given by

(cid:34)

˜v =

GI(

(cid:20) zC
RM(1)

(cid:21)
), ..., GI(

(cid:20) zC
RM(κ)

(cid:21)
)

(cid:35)
.

(4)

For a video,

M , ..., z(K)

the content vector, zC,

Figure 2: The MoCoGAN framework for video gener-
ation.
is sam-
pled once and ﬁxed. Then, a series of random variables
[(cid:15)(1), ..., (cid:15)(K)] is sampled and mapped to a series of motion
codes [z(1)
M ] via the recurrent neural network RM.
A generator GI produces a frame, ˜x(k), using the content
and the motion vectors {zC, z(k)
M }. The discriminators, DI
and DV, are trained on real and fake images and videos,
respectively, sampled from the training set v and the gener-
ated set ˜v. The function S1 samples a single frame from a
video, ST samples T consequtive frames.

path in the motion subspace ZM. The sequence of vectors
for generating a video is represented by

[z(1), ..., z(K)] =

(cid:104)(cid:2) zC
z(1)
M

(cid:3), ..., (cid:2) zC
z(K)
M

(cid:3)(cid:105)

(3)

where zC ∈ ZC and z(k)
M ∈ ZM for all k’s. Since not all
paths in ZM correspond to physically plausible motion, we
need to learn to generate valid paths. We model the path
generation process using a recurrent neural network.

Let RM to be a recurrent neural network. At each time
step, it takes a vector sampled from a Gaussian distribu-
tion as input: (cid:15)(k) ∼ pE ≡ N ((cid:15)|0, IdE ) and outputs a
vector in ZM, which is used as the motion representation.
Let RM(k) be the output of the recurrent neural network at
time k. Then, z(k)
M = RM(k). Intuitively, the function of
the recurrent neural network is to map a sequence of inde-
pendent and identically distributed (i.i.d.) random variables
[(cid:15)(1), ..., (cid:15)(K)] to a sequence of correlated random variables
[RM(1), ..., RM(K)] representing the dynamics in a video.
Injecting noise at every iteration models uncertainty of the
future motion at each timestep. We implement RM using a
one-layer GRU network [6].

Networks. MoCoGAN consists of 4 sub-networks, which
are the recurrent neural network, RM, the image generator,

Recall that our DI and DV take one frame and T con-
secutive frames in a video as input, respectively. In order

4

to represent these sampling mechanisms, we introduce two
random access functions S1 and ST. The function S1 takes
a video clip (either v ∼ pV or ˜v ∼ p ˜V) and outputs a
random frame from the clip, while the function ST takes a
video clip and randomly returns T consecutive frames from
the clip. With this notation, the MoCoGAN learning prob-
lem is

max
GI,RM

min
DI,DV

FV(DI, DV, GI, RM)

(5)

(6)

where the objective function FV(DI, DV, GI, RM) is
Ev[− log DI(S1(v))] + E˜v[− log(1 − DI(S1(˜v)))] +
Ev[− log DV(ST(v))] + E˜v[− log(1 − DV(ST(˜v)))],
where Ev is a shorthand for Ev∼pV , and E˜v for E˜v∼p ˜V
.
In (6), the ﬁrst and second terms encourage DI to output
1 for a video frame from a real video clip v and 0 for a
video frame from a generated one ˜v. Similarly, the third
and fourth terms encourage DV to output 1 for T consec-
utive frames in a real video clip v and 0 for T consecutive
frames in a generated one ˜v. The second and fourth terms
encourage the image generator and the recurrent neural net-
work to produce realistic images and video sequences of
T-consecutive frames, such that no discriminator can dis-
tinguish them from real images and videos.

We train MoCoGAN using the alternating gradient up-
date algorithm as in [11]. Speciﬁcally, in one step, we up-
date DI and DV while ﬁxing GI and RM. In the alternating
step, we update GI and RM while ﬁxing DI and DV.

3.1. Categorical Dynamics

Dynamics in videos are often categorical (e.g., discrete
action categories: walking, running, jumping, etc.). To
model this categorical signal, we augment the input to RM
with a categorical random variable, zA, where each realiza-
tion is a one-hot vector. We keep the realization ﬁxed since
the action category in a short video remains the same. The
input to RM is then given by

(cid:34)(cid:20) zA
(cid:15)(1)

(cid:21)

, ...,

(cid:20) zA
(cid:15)(K)

(cid:21)(cid:35)
,

(7)

To relate zA to the true action category, we adopt the In-
foGAN learning [5] and augment the objective function in
(6) to FV(DI, DV, GI, RM) + λLI (GI, Q) where LI is a
lower bound of the mutual information between the gener-
ated video clip and zA, λ is a hyperparameter, and the auxil-
iary distribution Q (which approximates the distribution of
the action category variable conditioning on the video clip)
is implemented by adding a softmax layer to the last feature
layer of DV. We use λ = 1. We note that when the labeled
training data are available, we can train Q to output the cat-
egory label for a real input video clip to further improve the
performance [25].

4. Experiments

We conducted extensive experimental validation to eval-
uate MoCoGAN. In addition to comparing to VGAN [40]
and TGAN [30], both quantitatively and qualitatively, we
evaluated the ability of MoCoGAN to generate 1) videos
of the same object performing different motions by using a
ﬁxed content vector and varying motion trajectories and 2)
videos of different objects performing the same motion by
using different content vectors and the same motion trajec-
tory. We then compared a variant of the MoCoGAN frame-
work with state-of-the-art next frame prediction methods:
VGAN and MCNET [39]. Evaluating generative models is
known to be a challenging task [35]. Hence, we report ex-
perimental results on several datasets, where we can obtain
reliable performance metrics:

• Shape motion. The dataset contained two types of
shapes (circles and squares) with varying sizes and col-
ors, performing two types of motion: one moving from
left to right, and the other moving from top to bot-
tom. The motion trajectories were sampled from Bezier
curves. There were 4, 000 videos in the dataset; the im-
age resolution was 64 × 64 and video length was 16.

• Facial expression. We used the MUG Facial Expression
Database [1] for this experiment. The dataset consisted
of 86 subjects. Each video consisted of 50 to 160 frames.
We cropped the face regions and scaled to 96 × 96. We
discarded videos containing fewer than 64 frames and
used only the sequences representing one of the six fa-
cial expressions: anger, fear, disgust, happiness, sadness,
and surprise. In total, we trained on 1, 254 videos.

• Tai-Chi. We downloaded 4, 500 Tai Chi video clips from
YouTube. For each clip, we applied a human pose esti-
mator [4] and cropped the clip so that the performer is in
the center. Videos were scaled to 64 × 64 pixels.

• Human actions. We used the Weizmann Action data-
base [13], containing 81 videos of 9 people performing
9 actions, including jumping-jack and waving-hands. We
scaled the videos to 96×96. Due to the small size, we did
not conduct a quantitative evaluation using the dataset.
Instead, we provide visual results in Fig. 1 and Fig. 4a.

• UCF101 [32]. The database is commonly used for video
action recognition. It includes 13, 220 videos of 101 dif-
ferent action categories. Similarly to the TGAN work
[30], we scaled each frame to 85 × 64 and cropped the
central 64 × 64 regions for learning.

Implementation. The details of the network designs are
given in the supplementary materials. We used ADAM [19]
for training, with a learning rate of 0.0002 and momentums
of 0.5 and 0.999. Our code will be made public.

5

(a) Generated by MoCoGAN

(b) Generated by VGAN [40]

(c) Generated by TGAN [30]

Figure 3: Generated video clips used in the user study. The video clips were randomly selected. The ﬁgure is best viewed via
the Acrobat Reader on a desktop. Click each image to play the video clip.

Table 1: Video generation content consistency comparison.
A smaller ACD means the generated frames in a video are
perceptually more similar. We also compute the ACD for
the training set, which is the reference.

ACD

Shape Motion

Facial Expressions

Reference
VGAN [40]
TGAN [30]
MoCoGAN

0
5.02
2.08
1.79

0.116
0.322
0.305
0.201

4.1. Video Generation Performance

Quantitative comparison. We compared MoCoGAN to
VGAN and TGAN1 using the shape motion and facial ex-
pression datasets. For each dataset, we trained a video
generation model and generated 256 videos for evaluation.
The VGAN and TGAN implementations can only generate
ﬁxed-length videos (32 frames and 16 frames correspond-
ingly). For a fair comparison, we generated 16 frames us-
ing MoCoGAN, and selected every second frame from the
videos generated by VGAN, such that each video has 16
frames in total.

For quantitative comparison, we measured content con-
sistency of a generated video using the Average Content
Distance (ACD) metric. For shape motion, we ﬁrst com-
puted the average color of the generated shape in each
frame. Each frame was then represented by a 3-dimensional
vector. The ACD is then given by the average pairwise L2
distance of the per-frame average color vectors. For facial
expression videos, we employed OpenFace [2], which out-
performs human performance in the face recognition task,
for measuring video content consistency. OpenFace pro-
duced a feature vector for each frame in a face video. The
ACD was then computed using the average pairwise L2 dis-

1The VGAN and TGAN implementations are provided by their authors.

Table 2: Inception score for models trained on UCF101. All
values except MoCoGAN’s are taken from [30].

VGAN

TGAN

MoCoGAN

UCF101

8.18 ± .05

11.85 ± .07

12.42 ± .03

Table 3: User preference score on video generation quality.

User preference, %

Facial Exp.

Tai-Chi

MoCoGAN / VGAN 84.2 / 15.8
MoCoGAN / TGAN 54.7 / 45.3

75.4 / 24.6
68.0 / 32.0

tance of the per-frame feature vectors.

We computed the average ACD scores for the 256 videos
generated by the competing algorithms for comparison. The
results are given in Table 1. From the table, we found
that the content of the videos generated by MoCoGAN was
more consistent, especially for the facial expression video
generation task: MoCoGAN achieved an ACD score of
0.201, which was almost 40% better than 0.322 of VGAN
and 34% better than 0.305 of TGAN. Fig. 3 shows examples
of facial expression videos for competing algorithms.

Furthermore, we compared with TGAN and VGAN by
training on the UCF101 database and computing the in-
ception score similarly to [30]. Table 2 shows comparison
results. In this experiment we used the same MoCoGAN
model as in all other experiments. We observed that MoCo-
GAN was able to learn temporal dynamics better, due to
the decomposed representation, as it generated more realis-
tic temporal sequences. We also noted that TGAN reached
the inception score of 11.85 with WGAN training proce-
dure and Singular Value Clipping (SVC), while MoCoGAN
showed a higher inception score 12.42 without such tricks,
supporting that the proposed framework is more stable than
and superior to the TGAN approach.

6

(a) Samples from the model trained on the Weizmann database.

(b) Examples of changing the motion code while ﬁxing the content
code. Every row has ﬁxed content, every column has ﬁxed motion.

(c) Image-to-video translation. In each block: input image (left),
video generated by MoCoGAN (right).
Figure 4: The ﬁgure is best viewed with Acrobat Reader on
a desktop. Click each image to play the video clip.

User study. We conducted a user study to quantitatively
compare MoCoGAN to VGAN and TGAN using the facial
expression and Tai-Chi datasets. For each algorithm, we
used the trained model to randomly generate 80 videos for
each task. We then randomly paired the videos generated
by the MoCoGAN with the videos from one of the compet-
ing algorithms to form 80 questions. These questions were
sent to the workers on Amazon Mechanical Turk (AMT)
for evaluation. The videos from different algorithms were
shown in random order for a fair comparison. Each ques-
tion was answered by 3 different workers. The workers
were instructed to choose the video that looks more real-
istic. Only the workers with a lifetime HIT (Human Intel-
ligent Task) approval rate greater than 95% participated in
the user study.

We report the average preference scores (the average
number of times, a worker prefers an algorithm) in Table 3.
From the table, we ﬁnd that the workers considered the
videos generated by MoCoGAN more realistic most of the
times. Compared to VGAN, MoCoGAN achieved a prefer-
ence score of 84.2% and 75.4% for the facial expression and
Tai-Chi datasets, respectively. Compared to TGAN, MoCo-
GAN achieved a preference score of 54.7% and 68.0% for
the facial expression and Tai-Chi datasets, respectively. In
Fig. 3, we visualize the facial expression and Tai-Chi videos
generated by the competing algorithms. We ﬁnd that the
videos generated by MoCoGAN are more realistic and con-
tained less content and motion artifacts.

Qualitative evaluation. We conducted a qualitative ex-
periment to demonstrate our motion and content decom-

7

Table 4: Performance on categorical facial expression video
generation with various MoCoGAN settings.

Settings

MCS

ACD

DI
DI
DI
DI

zA → GI
0.472
zA → RM 0.491
zA → GI
0.355
zA → RM 0.581

1.115
1.073
0.738
0.606

posed representation. We sampled two content codes and
seven motion codes, giving us 14 videos. Fig. 4b shows an
example randomly selected from this experiment. Each row
has the same content code, and each column has the same
motion code. We observed that MoCoGAN generated the
same motion sequences for two different content samples.

4.2. Categorical Video Generation

We augmented MoCoGAN with categorical variables
and trained it for facial expression video generation as de-
scribed in Section 3.1. The MUG dataset contains 6 differ-
ent facial expressions and hence zA is realized as a 6 dimen-
sional one-hot vector. We then generated 96 frames of fa-
cial expression videos. During generation, we changed the
action category, zA, every 16 frames to cover all 6 expres-
sions. Hence, a generated video corresponded to a person
performing 6 different facial expressions, one after another.
To evaluate the performance, we computed the ACD of
the generated videos. A smaller ACD means the generated
faces over the 96 frames were more likely to be from the
same person. Note that the ACD reported in this subsec-
tion are generally larger than the ACD reported in Table 1,
because the generated videos in this experiment are 6 times
longer and contain 6 facial expressions versus 1. We also
used the motion control score (MCS) to evaluate MoCo-
GAN’s capability in motion generation control. To compute
MCS, we ﬁrst trained a spatio-temporal CNN classiﬁer for
action recognition using the labeled training dataset. During
test time, we used the classiﬁer to verify whether the gener-
ated video contained the action. The MCS is then given by
testing accuracy of the classiﬁer. A model with larger MCS
offers better control over the action category.

In this experiment, we also evaluated the impact of dif-
ferent conditioning schemes to the categorical video gener-
ation performance. The ﬁrst scheme is our default scheme
where zA → RM. The second scheme, termed zA → GI,
was to feed the category variable directly to the image gen-
erator. In addition, to show the impact of the image discrim-
inative network DI, we considered training the MoCoGAN
framework without DI.

Table 4 shows experimental results. We ﬁnd that the
models trained with DI consistently yield better perfor-
mances on various metrics. We also ﬁnd that zA → RM

Figure 5: Generated videos of changing facial expressions. We changed the expression from smile to fear through surprise.

Table 5: User preference score on the quality of the image-
to-video-translation results.

User preference, %

Tai-Chi

MoCoGAN / C-VGAN 66.9 / 33.1
65.6 / 34.4
MoCoGAN / MCNET

model using the Tai-Chi dataset. In test time, we sampled
random images from a withheld test set to generate video
sequences.
In addition to the MoCoGAN loss, we have
added the L1 reconstruction loss for training the encoder-
decoder architecture similar to [21]. Under this setting,
MoCoGAN generated a video sequence starting from the
ﬁrst frame (see Fig. 4c). We compared with two state-of-
the-art approaches on this task: a Conditional-VGAN (C-
VGAN) and Motion Content Network (MCNET) [39] and
performed a user study to compare the competing methods.
We note that MCNET used 4 frames to predict a video,
while C-VGAN and MoCoGAN required a single frame
only. Table 5 shows the user preference scores. The results
support that MoCoGAN was able to generate more realistic
videos than C-VGAN and MCNET.

5. Conclusion

We presented the MoCoGAN framework for motion and
content decomposed video generation. Given sufﬁcient
video training data, MoCoGAN automatically learns to dis-
entangle motion from content in an unsupervised manner.
For instance, given videos of people performing different
facial expressions, MoCoGAN learns to separate a person’s
identity from their expression, thus allowing us to synthe-
size a new video of a person performing different expres-
sions, or ﬁxing the expression and generating various iden-
tities. This is enabled by a new generative adversarial net-
work, which generates a video clip by sequentially gener-
ating video frames. Each video frame is generated from
a random vector, which consists of two parts, one signify-
ing content and one signifying motion. The content sub-
space is modeled with a Gaussian distribution, whereas the
motion subspace is modeled with a recurrent neural net-
work. We sample this space in order to synthesize each
video frame. Our experimental evaluation supports that the
proposed framework is superior to current state-of-the-art
video generation and next frame prediction methods.

Figure 6: MoCoGAN models with varying (dC, dM) set-
tings on facial expression generation.

yields better performance. Fig. 5 shows two videos from
the best model in Table 4. We observe that by ﬁxing the
content vector but changing the expression label, it gener-
ates videos of the same person performing different expres-
sions. And similarly, by changing the content vector and
providing the same motion trajectory, we generate videos
of different people showing the same expression sequence.
We conducted an experiment to empirically analyze the
impact of the dimensions of the content and motion vectors
zC and z(t)
M (referred to as dC and dM) to the categorical
video generation performance. In the experiment, we ﬁxed
the sum of the dimensions to 60 (i.e., dC + dM = 60) and
changed the value of dC from 10 to 50, with a step size of
10. Fig. 6 shows the results.

We found when dC was large, MoCoGAN had a small
ACD. This meant a video generated by the MoCoGAN re-
sembled the same person performing different expressions.
We were expecting a larger zM would lead to a larger MCS
but found the contrary. Inspecting the generated videos, we
found when dM was large (i.e. dC was small), MoCoGAN
failed to generate recognizable faces, resulting in a poor
MCS. In this case, given poor image quality, the facial ex-
pression recognition network could only perform a random
guess on the expression and scored poorly. Based on this,
we set dC = 50 and dM = 10 in all the experiments.

4.3. Image-to-video Translation

We trained a variant of the MoCoGAN framework, in
which the generator is realized as an encoder-decoder archi-
tecture [21], where the encoder produced the content code
zC and the initial motion code z(0)
m . Subsequent motion
codes were produced by RM and concatenated with the con-
tent code to generate each frame. That is the input was an
image and the output was a video. We trained a MoCoGAN

8

References

[1] N. Aifanti, C. Papachristou, and A. Delopoulos. The mug
facial expression database. In Image Analysis for Multime-
dia Interactive Services (WIAMIS), 2010 11th International
Workshop on, pages 1–4, 2010.

[2] B. Amos, B. Ludwiczuk, and M. Satyanarayanan. Openface:
A general-purpose face recognition library with mobile ap-
plications. Technical report, CMU-CS-16-118, CMU School
of Computer Science, 2016.

[3] M. Arjovsky, S. Chintala, and L. Bottou. Wasserstein gan.

arXiv preprint arXiv:1701.07875, 2017.

[4] Z. Cao, T. Simon, S.-E. Wei, and Y. Sheikh. Realtime multi-
person 2d pose estimation using part afﬁnity ﬁelds. In IEEE
Conference on Computer Vision and Pattern Recognition
(CVPR), 2017.

[5] X. Chen, Y. Duan, R. Houthooft, J. Schulman, I. Sutskever,
and P. Abbeel. Infogan: Interpretable representation learning
by information maximizing generative adversarial nets.
In
Advances in Neural Information Processing Systems (NIPS),
2016.

[6] J. Chung, C. Gulcehre, K. Cho, and Y. Bengio. Empirical
evaluation of gated recurrent neural networks on sequence
In Advances in Neural Information Processing
modeling.
Systems (NIPS) Workshop, 2014.

[7] E. Denton and V. Birodkar. Unsupervised learning of dis-
entangled representations from video. Advances in Neural
Information Processing Systems (NIPS), 2017.

[8] E. L. Denton, S. Chintala, R. Fergus, et al. Deep genera-
tive image models using a laplacian pyramid of adversarial
In Advances in Neural Information Processing
networks.
Systems (NIPS), 2015.

[9] G. Doretto, A. Chiuso, Y. N. Wu, and S. Soatto. Dynamic
textures. International Journal of Computer Vision (IJCV),
2003.

[10] C. Finn, I. Goodfellow, and S. Levine. Unsupervised learn-
ing for physical interaction through video prediction. In Ad-
vances in Neural Information Processing Systems (NIPS),
2016.

[11] I. Goodfellow. Nips 2016 tutorial: Generative adversarial

networks. arXiv preprint arXiv:1701.00160, 2016.

[12] I. Goodfellow,

J. Pouget-Abadie, M. Mirza, B. Xu,
D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio. Gen-
erative adversarial nets. In Advances in Neural Information
Processing Systems (NIPS), 2014.

[13] L. Gorelick, M. Blank, E. Shechtman, M. Irani, and R. Basri.
Actions as space-time shapes. IEEE Transactions on Pattern
Analysis and Machine Intelligence (TPAMI), 29(12):2247–
2253, 2007.

[14] K. Gregor, I. Danihelka, A. Graves, D. J. Rezende, and
D. Wierstra. Draw: A recurrent neural network for image
generation. In International Conference on Machine Learn-
ing (ICML), 2015.

[15] S. Hochreiter and J. Schmidhuber. Long short-term memory.

Neural computation, 1997.

[16] D. J. Im, C. D. Kim, H. Jiang, and R. Memisevic. Generating
images with recurrent adversarial networks. arXiv preprint
arXiv:1602.05110, 2016.

[17] N. Kalchbrenner, A. v. d. Oord, K. Simonyan, I. Danihelka,
O. Vinyals, A. Graves, and K. Kavukcuoglu. Video pixel

networks. arXiv preprint arXiv:1610.00527, 2016.

[18] T. Karras, T. Aila, S. Laine, and J. Lehtinen. Progressive
growing of gans for improved quality, stability, and variation.
arXiv preprint arXiv:1710.10196, 2017.

[19] D. Kingma and J. Ba. Adam: A method for stochastic op-
timization. In International Conference on Learning Repre-
sentations (ICLR), 2015.

[20] D. P. Kingma and M. Welling. Auto-encoding variational
bayes. In International Conference on Learning Representa-
tions (ICLR), 2014.

[21] M.-Y. Liu, T. Breuel, and J. Kautz. Unsupervised image-to-
image translation networks. In Advances in Neural Informa-
tion Processing Systems (NIPS), 2017.

[22] M.-Y. Liu and O. Tuzel. Coupled generative adversarial net-
works. In Advances in Neural Information Processing Sys-
tems (NIPS), 2016.

[23] X. Mao, Q. Li, H. Xie, R. Y. Lau, Z. Wang, and S. P. Smolley.
Least squares generative adversarial networks. IEEE Inter-
national Conference on Computer Vision (ICCV), 2017.
[24] M. Mathieu, C. Couprie, and Y. LeCun. Deep multi-scale
video prediction beyond mean square error. In International
Conference on Learning Representations (ICLR), 2016.
[25] A. Odena, C. Olah, and J. Shlens. Conditional image synthe-
sis with auxiliary classiﬁer gans. In International Conference
on Machine Learning (ICML), 2017.

[26] J. Oh, X. Guo, H. Lee, R. L. Lewis, and S. Singh. Action-
conditional video prediction using deep networks in atari
games. In Advances in Neural Information Processing Sys-
tems (NIPS), 2015.

[27] A. Radford, L. Metz, and S. Chintala. Unsupervised rep-
resentation learning with deep convolutional generative ad-
versarial networks. In International Conference on Learning
Representations (ICLR), 2016.

[28] D. J. Rezende, S. Mohamed, and D. Wierstra. Stochas-
tic backpropagation and variational inference in deep latent
gaussian models. In International Conference on Machine
Learning (ICML), 2014.

[29] K. Roth, A. Lucchi, S. Nowozin, and T. Hofmann. Stabiliz-
ing training of generative adversarial networks through reg-
ularization. In Advances in Neural Information Processing
Systems (NIPS), 2017.

[30] M. Saito, E. Matsumoto, and S. Saito. Temporal generative
adversarial nets with singular value clipping. In IEEE Inter-
national Conference on Computer Vision (ICCV), 2017.
[31] T. Salimans, I. Goodfellow, W. Zaremba, V. Cheung, A. Rad-
ford, and X. Chen. Improved techniques for training gans. In
Advances in Neural Information Processing Systems (NIPS),
2016.

[32] K. Soomro, A. R. Zamir, and M. Shah. Ucf101: A dataset
of 101 human actions classes from videos in the wild. arXiv
preprint arXiv:1212.0402, 2012.

[33] N. Srivastava, E. Mansimov, and R. Salakhutdinov. Unsuper-
vised learning of video representations using lstms. In Inter-
national Conference on Machine Learning (ICML), 2015.

[34] M. Szummer and R. W. Picard. Temporal texture modeling.
In International Conference on Image Processing (ICIP),
1996.

[35] L. Theis, A. v. d. Oord, and M. Bethge. A note on the eval-
uation of generative models. In International Conference on
Learning Representations (ICLR), 2016.

9

[36] S. Tulyakov, A. Fitzgibbon, and S. Nowozin. Hybrid vae:
Improving deep generative models using partial observa-
tions. Advances in Neural Information Processing Systems
(NIPS) Workshop, 2017.

[37] J. van Amersfoort, A. Kannan, M. Ranzato, A. Szlam,
D. Tran, and S. Chintala. Transformation-based models of
video sequences. arXiv preprint arXiv:1701.08435, 2017.

[38] A. van den Oord, N. Kalchbrenner, L. Espeholt, O. Vinyals,
A. Graves, et al. Conditional image generation with pixel-
cnn decoders. In Advances in Neural Information Processing
Systems (NIPS), 2016.

[39] R. Villegas, J. Yang, S. Hong, X. Lin, and H. Lee. Decom-
posing motion and content for natural video sequence pre-
diction. In International Conference on Learning Represen-
tations (ICLR), 2017.

[40] C. Vondrick, H. Pirsiavash, and A. Torralba. Generating
videos with scene dynamics. In Advances in Neural Infor-
mation Processing Systems (NIPS), 2016.

[41] L.-Y. Wei and M. Levoy. Fast texture synthesis using tree-

structured vector quantization. In ACM SIGGRAPH, 2000.

[42] T. Xue, J. Wu, K. Bouman, and B. Freeman. Probabilistic
modeling of future frames from a single image. In Advances
in Neural Information Processing Systems (NIPS), 2016.
[43] H. Zhang, T. Xu, H. Li, S. Zhang, X. Huang, X. Wang, and
D. Metaxas. Stackgan: Text to photo-realistic image synthe-
sis with stacked generative adversarial networks. IEEE In-
ternational Conference on Computer Vision (ICCV), 2016.

10

0

1

2

3

4

0

1

2

3

0

1

2

3

A. Network Architecture

Table 6: Network architectures of the image generative net-
work GI, the image discriminative network DI, and the
video generative network DV used in the experiments.

Conﬁguration

GI

Input

[za ∼ N (0, I), zm ∼ RM]
DCONV-(N512, K6, S0, P0), BN, LeakyReLU

DCONV-(N256, K4, S2, P1), BN, LeakyReLU

DCONV-(N128, K4, S2, P1), BN, LeakyReLU

DCONV-(N64, K4, S2, P1), BN, LeakyReLU

DCONV-(N3, K4, S2, P1), BN, LeakyReLU

DI

Conﬁguration

Input

height × width × 3

CONV-(N64, K4, S2, P1), BN, LeakyReLU

CONV-(N128, K4, S2, P1), BN, LeakyReLU

CONV-(N256, K4, S2, P1), BN, LeakyReLU

CONV-(N1, K4, S2, P1), Sigmoid

DV

Conﬁguration

Input

16 × height × width × 3

CONV3D-(N64, K4, S1, P0), BN, LeakyReLU

CONV3D-(N128, K4, S1, P0), BN, LeakyReLU

CONV3D-(N256, K4, S1, P0), BN, LeakyReLU

CONV3D-(N1, K4, S1, P0), Sigmoid

Table 6 detailed the network architecture used in the
main paper. We used several different type of layers. A
convolutional layer with N output channels, kernel size K,
stride S, and padding P is denoted in the table as CONV-
(N , K, S, P ) and similarly for 3D convolutional layers
CONV3D-(N , K, S, P ). Kernel size, padding, and stride
are equal for all the dimensions in each layer. Batch normal-
ization layers are followed by the LeakyReLU nonlinearity
in our case. The RM consisted of a single GRU module.

B. Additional Qualitative Results

Figures 7 and 8 show categorical facial expression and
categorical human actions video generation results, respec-
tively. In each ﬁgure, every group of three rows was gener-
ated with a ﬁxed content vector zC, but random action vec-
tor zA and motion vectors z(t)
M ’s. We found that the identity
was kept ﬁxed throughout a video. We noted that the length
of the generated videos were longer than those in the train-
ing data. This showed that the MoCoGAN can generalize
the video generation along the time dimension.

11

Figure 7: Facial expression video generation results. Every three rows have the same identity but different zA.

12

Figure 8: Human action video generation results. Every three rows have the same identity but different zA.

13

MoCoGAN: Decomposing Motion and Content for Video Generation

Sergey Tulyakov,
Snap Research
stulyakov@snap.com

Ming-Yu Liu, Xiaodong Yang,

Jan Kautz

NVIDIA
{mingyul,xiaodongy,jkautz}@nvidia.com

7
1
0
2
 
c
e
D
 
4
1
 
 
]

V
C
.
s
c
[
 
 
2
v
3
9
9
4
0
.
7
0
7
1
:
v
i
X
r
a

Abstract

Visual signals in a video can be divided into content and
motion. While content speciﬁes which objects are in the
video, motion describes their dynamics. Based on this prior,
we propose the Motion and Content decomposed Genera-
tive Adversarial Network (MoCoGAN) framework for video
generation. The proposed framework generates a video by
mapping a sequence of random vectors to a sequence of
video frames. Each random vector consists of a content
part and a motion part. While the content part is kept
ﬁxed, the motion part is realized as a stochastic process. To
learn motion and content decomposition in an unsupervised
manner, we introduce a novel adversarial learning scheme
utilizing both image and video discriminators. Extensive
experimental results on several challenging datasets with
qualitative and quantitative comparison to the state-of-the-
art approaches, verify effectiveness of the proposed frame-
work. In addition, we show that MoCoGAN allows one to
generate videos with same content but different motion as
well as videos with different content and same motion.

1. Introduction

Deep generative models have recently received an in-
creasing amount of attention, not only because they provide
a means to learn deep feature representations in an unsuper-
vised manner that can potentially leverage all the unlabeled
images on the Internet for training, but also because they
can be used to generate novel images necessary for various
vision applications. As steady progress toward better image
generation is made, it is also important to study the video
generation problem. However, the extension from gener-
ating images to generating videos turns out to be a highly
challenging task, although the generated data has just one
more dimension – the time dimension.

We argue video generation is much harder for the fol-
lowing reasons. First, since a video is a spatio-temporal
recording of visual information of objects performing var-
ious actions, a generative model needs to learn the plausi-
ble physical motion models of objects in addition to learn-
ing their appearance models. If the learned object motion

Figure 1: MoCoGAN adopts a motion and content decom-
posed representation for video generation. It uses an image
latent space (each latent code represents an image) and di-
vides the latent space into content and motion subspaces.
By sampling a point in the content subspace and sampling
different trajectories in the motion subspace, it generates
videos of the same object performing different motion. By
sampling different points in the content subspace and the
same motion trajectory in the motion subspace, it generates
videos of different objects performing the same motion.

model is incorrect, the generated video may contain objects
performing physically impossible motion. Second, the time
dimension brings in a huge amount of variations. Consider
the amount of speed variations that a person can have when
performing a squat movement. Each speed pattern results
in a different video, although the appearances of the human
in the videos are the same. Third, as human beings have
evolved to be sensitive to motion, motion artifacts are par-
ticularly perceptible.

Recently, a few attempts to approach the video genera-
tion problem were made through generative adversarial net-
works (GANs) [12]. Vondrick et al. [40] hypothesize that a
video clip is a point in a latent space and proposed a VGAN
framework for learning a mapping from the latent space to

1

video clips. A similar approach was proposed in the TGAN
work [30]. We argue that assuming a video clip is a point
in the latent space unnecessarily increases the complexity
of the problem, because videos of the same action with dif-
ferent execution speed are represented by different points
in the latent space. Moreover, this assumption forces ev-
ery generated video clip to have the same length, while the
length of real-world video clips varies. An alternative (and
likely more intuitive and efﬁcient) approach would assume
a latent space of images and consider that a video clip is
generated by traversing the points in the latent space. Video
clips of different lengths correspond to latent space trajec-
tories of different lengths.

In addition, as videos are about objects (content) per-
forming actions (motion), the latent space of images should
be further decomposed into two subspaces, where the devi-
ation of a point in the ﬁrst subspace (the content subspace)
leads content changes in a video clip and the deviation in
the second subspace (the motion subspace) results in tem-
poral motions. Through this modeling, videos of an action
with different execution speeds will only result in different
traversal speeds of a trajectory in the motion space. Decom-
posing motion and content allows a more controlled video
generation process. By changing the content representation
while ﬁxing the motion trajectory, we have videos of dif-
ferent objects performing the same motion. By changing
motion trajectories while ﬁxing the content representation,
we have videos of the same object performing different mo-
tion as illustrated in Fig. 1.

In this paper, we propose the Motion and Content de-
composed Generative Adversarial Network (MoCoGAN)
framework for video generation. It generates a video clip
by sequentially generating video frames. At each time step,
an image generative network maps a random vector to an
image. The random vector consists of two parts where the
ﬁrst is sampled from a content subspace and the second is
sampled from a motion subspace. Since content in a short
video clip usually remains the same, we model the content
space using a Gaussian distribution and use the same real-
ization to generate each frame in a video clip. On the other
hand, sampling from the motion space is achieved through
a recurrent neural network where the network parameters
are learned during training. Despite lacking supervision re-
garding the decomposition of motion and content in nat-
ural videos, we show that MoCoGAN can learn to disen-
tangle these two factors through a novel adversarial train-
ing scheme. Through extensive qualitative and quantitative
experimental validations with comparison to the state-of-
the-art approaches including VGAN [40] and TGAN [30],
as well as the future frame prediction methods including
Conditional-VGAN (C-VGAN) [40] and Motion and Con-
tent Network (MCNET) [39], we verify the effectiveness of
MoCoGAN.

1.1. Related Work

Video generation is not a new problem. Due to limita-
tions in computation, data, and modeling tools, early video
generation works focused on generating dynamic texture
patterns [34, 41, 9]. In the recent years, with the availability
of GPUs, Internet videos, and deep neural networks, we are
now better positioned to tackle this intriguing problem.

Various deep generative models were recently proposed
for image generation including GANs [12], variational au-
toencoders (VAEs) [20, 28, 36], and PixelCNNs [38]. In
this paper, we propose the MoCoGAN framework for video
generation, which is based on GANs.

Multiple GAN-based image generation frameworks
were proposed. Denton et al. [8] showed a Laplacian pyra-
mid implementation. Radford et al. [27] used a deeper con-
volution network. Zhang et al. [43] stacked two generative
networks to progressively render realistic images. Coupled
GANs [22] learned to generate corresponding images in dif-
ferent domains, later extended to translate an image from
one domain to a different domain in an unsupervised fash-
ion [21]. InfoGAN [5] learned a more interpretable latent
representation. Salimans et al. [31] proposed several GAN
training tricks. The WGAN [3] and LSGAN [23] frame-
works adopted alternative distribution distance metrics for
more stable adversarial training. Roth et al. [29] proposed
a special gradient penalty to further stabilize training. Kar-
ras et al. [18] used progressive growing of the discriminator
and the generator to generate high resolution images. The
proposed MoCoGAN framework generates a video clip by
sequentially generating images using an image generator.
The framework can easily leverage advances in image gen-
eration in the GAN framework for improving the quality of
the generated videos. As discussed in Section 1, [40, 30]
extended the GAN framework to the video generation prob-
lem by assuming a latent space of video clips where all the
clips have the same length.

Recurrent neural networks for image generation were
previously explored in [14, 16]. Speciﬁcally, some works
used recurrent mechanisms to iteratively reﬁne a generated
image. Our work is different to [14, 16] in that we use
the recurrent mechanism to generate motion embeddings
of video frames in a video clip. The image generation is
achieved through a convolutional neural network.

The future frame prediction problem studied in [33, 26,
24, 17, 10, 37, 42, 39, 7] is different to the video gen-
eration problem.
In future frame prediction, the goal is
to predict future frames in a video given the observed
frames in the video. Previous works on future frame pre-
diction can be roughly divided into two categories where
one focuses on generating raw pixel values in future frames
based on the observed ones [33, 26, 24, 17, 42, 39], while
the other focuses on generating transformations for reshuf-
ﬂing the pixels in the previous frames to construct fu-

2

ture frames [10, 37]. The availability of previous frames
makes future frame prediction a conditional image gener-
ation problem, which is different to the video generation
problem where the input to the generative network is only a
vector drawn from a latent space. We note that [39] used a
convolutional LSTM [15] encoder to encode temporal dif-
ferences between consecutive previous frames for extract-
ing motion information and a convolutional encoder to ex-
tract content information from the current image. The con-
catenation of the motion and content information was then
fed to a decoder to predict future frames.

1.2. Contributions

Our contributions are as follows:

1. We propose a novel GAN framework for unconditional
video generation, mapping noise vectors to videos.

2. We show the proposed framework provides a means to
control content and motion in video generation, which is
absent in the existing video generation frameworks.

3. We conduct extensive experimental validation on bench-
mark datasets with both quantitative and subjective com-
parison to the state-of-the-art video generation algo-
rithms including VGAN[40] and TGAN [30] to verify
the effectiveness of the proposed algorithm.

2. Generative Adversarial Networks

GANs [12] consist of a generator and a discriminator.
The objective of the generator is to generate images resem-
bling real images, while the objective of the discriminator
is to distinguish real images from generated ones.

Let x be a real image drawn from an image distribution,
pX , and z be a random vector in ZI ≡ Rd. Let GI and DI
be the image generator and the image discriminator. The
generator takes z as input and outputs an image, ˜x = GI(z),
that has the same support as x. We denote the distribution
of GI(z) as pGI . The discriminator estimates the probability
that an input image is drawn from pX . Ideally, DI(x) = 1
if x ∼ pX and DI(˜x) = 0 if ˜x ∼ pGI. Training of GI and
DI is achieved via solving a minimax problem given by

max
GI

min
DI

FI(DI, GI)

where the functional FI is given by

FI(DI, GI) = Ex∼pX [− log DI(x)] +
Ez∼pZI

[− log(1 − DI(GI(z)))].

In practice, (1) is solved by alternating gradient update.

Goodfellow et al. [12] show that, given enough capacity
to DI and GI and sufﬁcient training iterations, the distri-
bution pGI converges to pX . As a result, from a random
vector input z, the network GI can synthesize an image that
resembles one drawn from the true distribution, pX .

(1)

(2)

3

2.1. Extension to Fixed-length Video Generation

Recently, [40] extended the GAN framework to video
generation by proposing a Video GAN (VGAN) framework.
Let vL = [x(1), ..., x(L)] be a video clip with L frames.
The video generation in VGAN is achieved by replacing
the vanilla CNN-based image generator and discriminator,
GI and DI, with a spatio-temporal CNN-based video gener-
ator and discriminator, GVL and DVL. The video generator
GVL maps a random vector z ∈ ZVL ≡ Rd to a ﬁxed-length
video clip, ˜vL = [˜x(1), ..., ˜x(L)] = GVL (z) and the video
discriminator DVL differentiates real video clips from gen-
erated ones. Ideally, DVL (vL) = 1 if vL is sampled from
pV L and DVL (˜vL) = 0 if ˜vL is sampled from the video
generator distribution pGVL . The TGAN framework [30]
also maps a random vector to a ﬁxed length clip. The dif-
ference is that TGAN maps the random vector, representing
a ﬁxed-length video, to a ﬁxed number of random vectors,
representing individual frames in the video clip and uses an
image generator for generation. Instead of using the vanilla
GAN framework for minimizing the Jensen-Shannon diver-
gence, the TGAN training is based on the WGAN frame-
work [3] and minimizes the earth mover distance.

3. Motion and Content Decomposed GAN

In MoCoGAN, we assume a latent space of images ZI ≡
Rd where each point z ∈ ZI represents an image, and a
video of K frames is represented by a path of length K in
the latent space, [z(1), ..., z(K)]. By adopting this formula-
tion, videos of different lengths can be generated by paths of
different lengths. Moreover, videos of the same action ex-
ecuted with different speeds can be generated by traversing
the same path in the latent space with different speeds.

We further assume ZI is decomposed into the content
ZC and motion ZM subspaces: ZI = ZC × ZM where
ZC = RdC , ZM = RdM , and d = dC + dM. The content
subspace models motion-independent appearance in videos,
while the motion subspace models motion-dependent ap-
pearance in videos. For example, in a video of a person
smiling, content represents the identity of the person, while
motion represents the changes of facial muscle conﬁgura-
tions of the person. A pair of the person’s identity and the
facial muscle conﬁguration represents a face image of the
person. A sequence of these pairs represents a video clip
of the person smiling. By swapping the look of the person
with the look of another person, a video of a different person
smiling is represented.

We model the content subspace using a Gaussian distri-
bution: zC ∼ pZC ≡ N (z|0, IdC ) where IdC is an identity
matrix of size dC × dC. Based on the observation that the
content remains largely the same in a short video clip, we
use the same realization, zC, for generating different frames
in a video clip. Motion in the video clip is modeled by a

GI, the image discriminator, DI, and the video discrimi-
nator, DV. The image generator generates a video clip by
sequentially mapping vectors in ZI to images, from a se-
(cid:3)] to a sequence of im-
(cid:3), ..., (cid:2) zC
quence of vectors [(cid:2) zC
z(K)
z(1)
M
M
(cid:3)) and
ages, ˜v = [˜x(1), ..., ˜x(K)], where ˜x(k) = GI((cid:2) zC
z(k)
M
z(k)
M ’s are from the recurrent neural network, RM. We note
that the video length K can vary for each video generation.
Both DI and DV play the judge role, providing criticisms
to GI and RM. The image discriminator DI is specialized
in criticizing GI based on individual images. It is trained to
determine if a frame is sampled from a real video clip, v,
or from ˜v. On the other hand, DV provides criticisms to GI
based on the generated video clip. DV takes a ﬁxed length
video clip, say T frames, and decides if a video clip was
sampled from a real video or from ˜v. Different from DI,
which is based on vanilla CNN architecture, DV is based on
a spatio-temporal CNN architecture. We note that the clip
length T is a hyperparameter, which is set to 16 throughout
our experiments. We also note that T can be smaller than
the generated video length K. A video of length K can be
divided into K − T + 1 clips in a sliding-window fashion,
and each of the clips can be fed into DV.

The video discriminator DV also evaluates the generated
motion. Since GI has no concept of motion, the criticisms
on the motion part go directly to the recurrent neural net-
work, RM. In order to generate a video with realistic dy-
namics that fools DV, RM has to learn to generate a se-
quence of motion codes [z(1)
M ] from a sequence of
i.i.d. noise inputs [(cid:15)(1), ..., (cid:15)(K)] in a way such that GI can
map z(k) = [zC, z(k)

M ] to consecutive frames in a video.

M , ..., z(K)

Ideally, DV alone should be sufﬁcient for training GI
and RM, because DV provides feedback on both static im-
age appearance and video dynamics. However, we found
that using DI signiﬁcantly improves the convergence of the
adversarial training. This is because training DI is simpler,
as it only needs to focus on static appearances. Fig. 2 shows
visual representation of the MoCoGAN framework.

Learning. Let pV be the distribution of video clips of
variable lengths. Let κ be a discrete random variable denot-
ing the length of a video clip sampled from pV. (In practice,
we can estimate the distribution of κ, termed pK, by com-
puting a histogram of video clip length from training data).
To generate a video, we ﬁrst sample a content vector, zC,
and a length, κ. We then run RM for κ steps and, at each
time step, RM takes a random variable (cid:15) as the input. A
generated video is then given by

(cid:34)

˜v =

GI(

(cid:20) zC
RM(1)

(cid:21)
), ..., GI(

(cid:20) zC
RM(κ)

(cid:21)
)

(cid:35)
.

(4)

For a video,

M , ..., z(K)

the content vector, zC,

Figure 2: The MoCoGAN framework for video gener-
ation.
is sam-
pled once and ﬁxed. Then, a series of random variables
[(cid:15)(1), ..., (cid:15)(K)] is sampled and mapped to a series of motion
codes [z(1)
M ] via the recurrent neural network RM.
A generator GI produces a frame, ˜x(k), using the content
and the motion vectors {zC, z(k)
M }. The discriminators, DI
and DV, are trained on real and fake images and videos,
respectively, sampled from the training set v and the gener-
ated set ˜v. The function S1 samples a single frame from a
video, ST samples T consequtive frames.

path in the motion subspace ZM. The sequence of vectors
for generating a video is represented by

[z(1), ..., z(K)] =

(cid:104)(cid:2) zC
z(1)
M

(cid:3), ..., (cid:2) zC
z(K)
M

(cid:3)(cid:105)

(3)

where zC ∈ ZC and z(k)
M ∈ ZM for all k’s. Since not all
paths in ZM correspond to physically plausible motion, we
need to learn to generate valid paths. We model the path
generation process using a recurrent neural network.

Let RM to be a recurrent neural network. At each time
step, it takes a vector sampled from a Gaussian distribu-
tion as input: (cid:15)(k) ∼ pE ≡ N ((cid:15)|0, IdE ) and outputs a
vector in ZM, which is used as the motion representation.
Let RM(k) be the output of the recurrent neural network at
time k. Then, z(k)
M = RM(k). Intuitively, the function of
the recurrent neural network is to map a sequence of inde-
pendent and identically distributed (i.i.d.) random variables
[(cid:15)(1), ..., (cid:15)(K)] to a sequence of correlated random variables
[RM(1), ..., RM(K)] representing the dynamics in a video.
Injecting noise at every iteration models uncertainty of the
future motion at each timestep. We implement RM using a
one-layer GRU network [6].

Networks. MoCoGAN consists of 4 sub-networks, which
are the recurrent neural network, RM, the image generator,

Recall that our DI and DV take one frame and T con-
secutive frames in a video as input, respectively. In order

4

to represent these sampling mechanisms, we introduce two
random access functions S1 and ST. The function S1 takes
a video clip (either v ∼ pV or ˜v ∼ p ˜V) and outputs a
random frame from the clip, while the function ST takes a
video clip and randomly returns T consecutive frames from
the clip. With this notation, the MoCoGAN learning prob-
lem is

max
GI,RM

min
DI,DV

FV(DI, DV, GI, RM)

(5)

(6)

where the objective function FV(DI, DV, GI, RM) is
Ev[− log DI(S1(v))] + E˜v[− log(1 − DI(S1(˜v)))] +
Ev[− log DV(ST(v))] + E˜v[− log(1 − DV(ST(˜v)))],
where Ev is a shorthand for Ev∼pV , and E˜v for E˜v∼p ˜V
.
In (6), the ﬁrst and second terms encourage DI to output
1 for a video frame from a real video clip v and 0 for a
video frame from a generated one ˜v. Similarly, the third
and fourth terms encourage DV to output 1 for T consec-
utive frames in a real video clip v and 0 for T consecutive
frames in a generated one ˜v. The second and fourth terms
encourage the image generator and the recurrent neural net-
work to produce realistic images and video sequences of
T-consecutive frames, such that no discriminator can dis-
tinguish them from real images and videos.

We train MoCoGAN using the alternating gradient up-
date algorithm as in [11]. Speciﬁcally, in one step, we up-
date DI and DV while ﬁxing GI and RM. In the alternating
step, we update GI and RM while ﬁxing DI and DV.

3.1. Categorical Dynamics

Dynamics in videos are often categorical (e.g., discrete
action categories: walking, running, jumping, etc.). To
model this categorical signal, we augment the input to RM
with a categorical random variable, zA, where each realiza-
tion is a one-hot vector. We keep the realization ﬁxed since
the action category in a short video remains the same. The
input to RM is then given by

(cid:34)(cid:20) zA
(cid:15)(1)

(cid:21)

, ...,

(cid:20) zA
(cid:15)(K)

(cid:21)(cid:35)
,

(7)

To relate zA to the true action category, we adopt the In-
foGAN learning [5] and augment the objective function in
(6) to FV(DI, DV, GI, RM) + λLI (GI, Q) where LI is a
lower bound of the mutual information between the gener-
ated video clip and zA, λ is a hyperparameter, and the auxil-
iary distribution Q (which approximates the distribution of
the action category variable conditioning on the video clip)
is implemented by adding a softmax layer to the last feature
layer of DV. We use λ = 1. We note that when the labeled
training data are available, we can train Q to output the cat-
egory label for a real input video clip to further improve the
performance [25].

4. Experiments

We conducted extensive experimental validation to eval-
uate MoCoGAN. In addition to comparing to VGAN [40]
and TGAN [30], both quantitatively and qualitatively, we
evaluated the ability of MoCoGAN to generate 1) videos
of the same object performing different motions by using a
ﬁxed content vector and varying motion trajectories and 2)
videos of different objects performing the same motion by
using different content vectors and the same motion trajec-
tory. We then compared a variant of the MoCoGAN frame-
work with state-of-the-art next frame prediction methods:
VGAN and MCNET [39]. Evaluating generative models is
known to be a challenging task [35]. Hence, we report ex-
perimental results on several datasets, where we can obtain
reliable performance metrics:

• Shape motion. The dataset contained two types of
shapes (circles and squares) with varying sizes and col-
ors, performing two types of motion: one moving from
left to right, and the other moving from top to bot-
tom. The motion trajectories were sampled from Bezier
curves. There were 4, 000 videos in the dataset; the im-
age resolution was 64 × 64 and video length was 16.

• Facial expression. We used the MUG Facial Expression
Database [1] for this experiment. The dataset consisted
of 86 subjects. Each video consisted of 50 to 160 frames.
We cropped the face regions and scaled to 96 × 96. We
discarded videos containing fewer than 64 frames and
used only the sequences representing one of the six fa-
cial expressions: anger, fear, disgust, happiness, sadness,
and surprise. In total, we trained on 1, 254 videos.

• Tai-Chi. We downloaded 4, 500 Tai Chi video clips from
YouTube. For each clip, we applied a human pose esti-
mator [4] and cropped the clip so that the performer is in
the center. Videos were scaled to 64 × 64 pixels.

• Human actions. We used the Weizmann Action data-
base [13], containing 81 videos of 9 people performing
9 actions, including jumping-jack and waving-hands. We
scaled the videos to 96×96. Due to the small size, we did
not conduct a quantitative evaluation using the dataset.
Instead, we provide visual results in Fig. 1 and Fig. 4a.

• UCF101 [32]. The database is commonly used for video
action recognition. It includes 13, 220 videos of 101 dif-
ferent action categories. Similarly to the TGAN work
[30], we scaled each frame to 85 × 64 and cropped the
central 64 × 64 regions for learning.

Implementation. The details of the network designs are
given in the supplementary materials. We used ADAM [19]
for training, with a learning rate of 0.0002 and momentums
of 0.5 and 0.999. Our code will be made public.

5

(a) Generated by MoCoGAN

(b) Generated by VGAN [40]

(c) Generated by TGAN [30]

Figure 3: Generated video clips used in the user study. The video clips were randomly selected. The ﬁgure is best viewed via
the Acrobat Reader on a desktop. Click each image to play the video clip.

Table 1: Video generation content consistency comparison.
A smaller ACD means the generated frames in a video are
perceptually more similar. We also compute the ACD for
the training set, which is the reference.

ACD

Shape Motion

Facial Expressions

Reference
VGAN [40]
TGAN [30]
MoCoGAN

0
5.02
2.08
1.79

0.116
0.322
0.305
0.201

4.1. Video Generation Performance

Quantitative comparison. We compared MoCoGAN to
VGAN and TGAN1 using the shape motion and facial ex-
pression datasets. For each dataset, we trained a video
generation model and generated 256 videos for evaluation.
The VGAN and TGAN implementations can only generate
ﬁxed-length videos (32 frames and 16 frames correspond-
ingly). For a fair comparison, we generated 16 frames us-
ing MoCoGAN, and selected every second frame from the
videos generated by VGAN, such that each video has 16
frames in total.

For quantitative comparison, we measured content con-
sistency of a generated video using the Average Content
Distance (ACD) metric. For shape motion, we ﬁrst com-
puted the average color of the generated shape in each
frame. Each frame was then represented by a 3-dimensional
vector. The ACD is then given by the average pairwise L2
distance of the per-frame average color vectors. For facial
expression videos, we employed OpenFace [2], which out-
performs human performance in the face recognition task,
for measuring video content consistency. OpenFace pro-
duced a feature vector for each frame in a face video. The
ACD was then computed using the average pairwise L2 dis-

1The VGAN and TGAN implementations are provided by their authors.

Table 2: Inception score for models trained on UCF101. All
values except MoCoGAN’s are taken from [30].

VGAN

TGAN

MoCoGAN

UCF101

8.18 ± .05

11.85 ± .07

12.42 ± .03

Table 3: User preference score on video generation quality.

User preference, %

Facial Exp.

Tai-Chi

MoCoGAN / VGAN 84.2 / 15.8
MoCoGAN / TGAN 54.7 / 45.3

75.4 / 24.6
68.0 / 32.0

tance of the per-frame feature vectors.

We computed the average ACD scores for the 256 videos
generated by the competing algorithms for comparison. The
results are given in Table 1. From the table, we found
that the content of the videos generated by MoCoGAN was
more consistent, especially for the facial expression video
generation task: MoCoGAN achieved an ACD score of
0.201, which was almost 40% better than 0.322 of VGAN
and 34% better than 0.305 of TGAN. Fig. 3 shows examples
of facial expression videos for competing algorithms.

Furthermore, we compared with TGAN and VGAN by
training on the UCF101 database and computing the in-
ception score similarly to [30]. Table 2 shows comparison
results. In this experiment we used the same MoCoGAN
model as in all other experiments. We observed that MoCo-
GAN was able to learn temporal dynamics better, due to
the decomposed representation, as it generated more realis-
tic temporal sequences. We also noted that TGAN reached
the inception score of 11.85 with WGAN training proce-
dure and Singular Value Clipping (SVC), while MoCoGAN
showed a higher inception score 12.42 without such tricks,
supporting that the proposed framework is more stable than
and superior to the TGAN approach.

6

(a) Samples from the model trained on the Weizmann database.

(b) Examples of changing the motion code while ﬁxing the content
code. Every row has ﬁxed content, every column has ﬁxed motion.

(c) Image-to-video translation. In each block: input image (left),
video generated by MoCoGAN (right).
Figure 4: The ﬁgure is best viewed with Acrobat Reader on
a desktop. Click each image to play the video clip.

User study. We conducted a user study to quantitatively
compare MoCoGAN to VGAN and TGAN using the facial
expression and Tai-Chi datasets. For each algorithm, we
used the trained model to randomly generate 80 videos for
each task. We then randomly paired the videos generated
by the MoCoGAN with the videos from one of the compet-
ing algorithms to form 80 questions. These questions were
sent to the workers on Amazon Mechanical Turk (AMT)
for evaluation. The videos from different algorithms were
shown in random order for a fair comparison. Each ques-
tion was answered by 3 different workers. The workers
were instructed to choose the video that looks more real-
istic. Only the workers with a lifetime HIT (Human Intel-
ligent Task) approval rate greater than 95% participated in
the user study.

We report the average preference scores (the average
number of times, a worker prefers an algorithm) in Table 3.
From the table, we ﬁnd that the workers considered the
videos generated by MoCoGAN more realistic most of the
times. Compared to VGAN, MoCoGAN achieved a prefer-
ence score of 84.2% and 75.4% for the facial expression and
Tai-Chi datasets, respectively. Compared to TGAN, MoCo-
GAN achieved a preference score of 54.7% and 68.0% for
the facial expression and Tai-Chi datasets, respectively. In
Fig. 3, we visualize the facial expression and Tai-Chi videos
generated by the competing algorithms. We ﬁnd that the
videos generated by MoCoGAN are more realistic and con-
tained less content and motion artifacts.

Qualitative evaluation. We conducted a qualitative ex-
periment to demonstrate our motion and content decom-

7

Table 4: Performance on categorical facial expression video
generation with various MoCoGAN settings.

Settings

MCS

ACD

DI
DI
DI
DI

zA → GI
0.472
zA → RM 0.491
zA → GI
0.355
zA → RM 0.581

1.115
1.073
0.738
0.606

posed representation. We sampled two content codes and
seven motion codes, giving us 14 videos. Fig. 4b shows an
example randomly selected from this experiment. Each row
has the same content code, and each column has the same
motion code. We observed that MoCoGAN generated the
same motion sequences for two different content samples.

4.2. Categorical Video Generation

We augmented MoCoGAN with categorical variables
and trained it for facial expression video generation as de-
scribed in Section 3.1. The MUG dataset contains 6 differ-
ent facial expressions and hence zA is realized as a 6 dimen-
sional one-hot vector. We then generated 96 frames of fa-
cial expression videos. During generation, we changed the
action category, zA, every 16 frames to cover all 6 expres-
sions. Hence, a generated video corresponded to a person
performing 6 different facial expressions, one after another.
To evaluate the performance, we computed the ACD of
the generated videos. A smaller ACD means the generated
faces over the 96 frames were more likely to be from the
same person. Note that the ACD reported in this subsec-
tion are generally larger than the ACD reported in Table 1,
because the generated videos in this experiment are 6 times
longer and contain 6 facial expressions versus 1. We also
used the motion control score (MCS) to evaluate MoCo-
GAN’s capability in motion generation control. To compute
MCS, we ﬁrst trained a spatio-temporal CNN classiﬁer for
action recognition using the labeled training dataset. During
test time, we used the classiﬁer to verify whether the gener-
ated video contained the action. The MCS is then given by
testing accuracy of the classiﬁer. A model with larger MCS
offers better control over the action category.

In this experiment, we also evaluated the impact of dif-
ferent conditioning schemes to the categorical video gener-
ation performance. The ﬁrst scheme is our default scheme
where zA → RM. The second scheme, termed zA → GI,
was to feed the category variable directly to the image gen-
erator. In addition, to show the impact of the image discrim-
inative network DI, we considered training the MoCoGAN
framework without DI.

Table 4 shows experimental results. We ﬁnd that the
models trained with DI consistently yield better perfor-
mances on various metrics. We also ﬁnd that zA → RM

Figure 5: Generated videos of changing facial expressions. We changed the expression from smile to fear through surprise.

Table 5: User preference score on the quality of the image-
to-video-translation results.

User preference, %

Tai-Chi

MoCoGAN / C-VGAN 66.9 / 33.1
65.6 / 34.4
MoCoGAN / MCNET

model using the Tai-Chi dataset. In test time, we sampled
random images from a withheld test set to generate video
sequences.
In addition to the MoCoGAN loss, we have
added the L1 reconstruction loss for training the encoder-
decoder architecture similar to [21]. Under this setting,
MoCoGAN generated a video sequence starting from the
ﬁrst frame (see Fig. 4c). We compared with two state-of-
the-art approaches on this task: a Conditional-VGAN (C-
VGAN) and Motion Content Network (MCNET) [39] and
performed a user study to compare the competing methods.
We note that MCNET used 4 frames to predict a video,
while C-VGAN and MoCoGAN required a single frame
only. Table 5 shows the user preference scores. The results
support that MoCoGAN was able to generate more realistic
videos than C-VGAN and MCNET.

5. Conclusion

We presented the MoCoGAN framework for motion and
content decomposed video generation. Given sufﬁcient
video training data, MoCoGAN automatically learns to dis-
entangle motion from content in an unsupervised manner.
For instance, given videos of people performing different
facial expressions, MoCoGAN learns to separate a person’s
identity from their expression, thus allowing us to synthe-
size a new video of a person performing different expres-
sions, or ﬁxing the expression and generating various iden-
tities. This is enabled by a new generative adversarial net-
work, which generates a video clip by sequentially gener-
ating video frames. Each video frame is generated from
a random vector, which consists of two parts, one signify-
ing content and one signifying motion. The content sub-
space is modeled with a Gaussian distribution, whereas the
motion subspace is modeled with a recurrent neural net-
work. We sample this space in order to synthesize each
video frame. Our experimental evaluation supports that the
proposed framework is superior to current state-of-the-art
video generation and next frame prediction methods.

Figure 6: MoCoGAN models with varying (dC, dM) set-
tings on facial expression generation.

yields better performance. Fig. 5 shows two videos from
the best model in Table 4. We observe that by ﬁxing the
content vector but changing the expression label, it gener-
ates videos of the same person performing different expres-
sions. And similarly, by changing the content vector and
providing the same motion trajectory, we generate videos
of different people showing the same expression sequence.
We conducted an experiment to empirically analyze the
impact of the dimensions of the content and motion vectors
zC and z(t)
M (referred to as dC and dM) to the categorical
video generation performance. In the experiment, we ﬁxed
the sum of the dimensions to 60 (i.e., dC + dM = 60) and
changed the value of dC from 10 to 50, with a step size of
10. Fig. 6 shows the results.

We found when dC was large, MoCoGAN had a small
ACD. This meant a video generated by the MoCoGAN re-
sembled the same person performing different expressions.
We were expecting a larger zM would lead to a larger MCS
but found the contrary. Inspecting the generated videos, we
found when dM was large (i.e. dC was small), MoCoGAN
failed to generate recognizable faces, resulting in a poor
MCS. In this case, given poor image quality, the facial ex-
pression recognition network could only perform a random
guess on the expression and scored poorly. Based on this,
we set dC = 50 and dM = 10 in all the experiments.

4.3. Image-to-video Translation

We trained a variant of the MoCoGAN framework, in
which the generator is realized as an encoder-decoder archi-
tecture [21], where the encoder produced the content code
zC and the initial motion code z(0)
m . Subsequent motion
codes were produced by RM and concatenated with the con-
tent code to generate each frame. That is the input was an
image and the output was a video. We trained a MoCoGAN

8

References

[1] N. Aifanti, C. Papachristou, and A. Delopoulos. The mug
facial expression database. In Image Analysis for Multime-
dia Interactive Services (WIAMIS), 2010 11th International
Workshop on, pages 1–4, 2010.

[2] B. Amos, B. Ludwiczuk, and M. Satyanarayanan. Openface:
A general-purpose face recognition library with mobile ap-
plications. Technical report, CMU-CS-16-118, CMU School
of Computer Science, 2016.

[3] M. Arjovsky, S. Chintala, and L. Bottou. Wasserstein gan.

arXiv preprint arXiv:1701.07875, 2017.

[4] Z. Cao, T. Simon, S.-E. Wei, and Y. Sheikh. Realtime multi-
person 2d pose estimation using part afﬁnity ﬁelds. In IEEE
Conference on Computer Vision and Pattern Recognition
(CVPR), 2017.

[5] X. Chen, Y. Duan, R. Houthooft, J. Schulman, I. Sutskever,
and P. Abbeel. Infogan: Interpretable representation learning
by information maximizing generative adversarial nets.
In
Advances in Neural Information Processing Systems (NIPS),
2016.

[6] J. Chung, C. Gulcehre, K. Cho, and Y. Bengio. Empirical
evaluation of gated recurrent neural networks on sequence
In Advances in Neural Information Processing
modeling.
Systems (NIPS) Workshop, 2014.

[7] E. Denton and V. Birodkar. Unsupervised learning of dis-
entangled representations from video. Advances in Neural
Information Processing Systems (NIPS), 2017.

[8] E. L. Denton, S. Chintala, R. Fergus, et al. Deep genera-
tive image models using a laplacian pyramid of adversarial
In Advances in Neural Information Processing
networks.
Systems (NIPS), 2015.

[9] G. Doretto, A. Chiuso, Y. N. Wu, and S. Soatto. Dynamic
textures. International Journal of Computer Vision (IJCV),
2003.

[10] C. Finn, I. Goodfellow, and S. Levine. Unsupervised learn-
ing for physical interaction through video prediction. In Ad-
vances in Neural Information Processing Systems (NIPS),
2016.

[11] I. Goodfellow. Nips 2016 tutorial: Generative adversarial

networks. arXiv preprint arXiv:1701.00160, 2016.

[12] I. Goodfellow,

J. Pouget-Abadie, M. Mirza, B. Xu,
D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio. Gen-
erative adversarial nets. In Advances in Neural Information
Processing Systems (NIPS), 2014.

[13] L. Gorelick, M. Blank, E. Shechtman, M. Irani, and R. Basri.
Actions as space-time shapes. IEEE Transactions on Pattern
Analysis and Machine Intelligence (TPAMI), 29(12):2247–
2253, 2007.

[14] K. Gregor, I. Danihelka, A. Graves, D. J. Rezende, and
D. Wierstra. Draw: A recurrent neural network for image
generation. In International Conference on Machine Learn-
ing (ICML), 2015.

[15] S. Hochreiter and J. Schmidhuber. Long short-term memory.

Neural computation, 1997.

[16] D. J. Im, C. D. Kim, H. Jiang, and R. Memisevic. Generating
images with recurrent adversarial networks. arXiv preprint
arXiv:1602.05110, 2016.

[17] N. Kalchbrenner, A. v. d. Oord, K. Simonyan, I. Danihelka,
O. Vinyals, A. Graves, and K. Kavukcuoglu. Video pixel

networks. arXiv preprint arXiv:1610.00527, 2016.

[18] T. Karras, T. Aila, S. Laine, and J. Lehtinen. Progressive
growing of gans for improved quality, stability, and variation.
arXiv preprint arXiv:1710.10196, 2017.

[19] D. Kingma and J. Ba. Adam: A method for stochastic op-
timization. In International Conference on Learning Repre-
sentations (ICLR), 2015.

[20] D. P. Kingma and M. Welling. Auto-encoding variational
bayes. In International Conference on Learning Representa-
tions (ICLR), 2014.

[21] M.-Y. Liu, T. Breuel, and J. Kautz. Unsupervised image-to-
image translation networks. In Advances in Neural Informa-
tion Processing Systems (NIPS), 2017.

[22] M.-Y. Liu and O. Tuzel. Coupled generative adversarial net-
works. In Advances in Neural Information Processing Sys-
tems (NIPS), 2016.

[23] X. Mao, Q. Li, H. Xie, R. Y. Lau, Z. Wang, and S. P. Smolley.
Least squares generative adversarial networks. IEEE Inter-
national Conference on Computer Vision (ICCV), 2017.
[24] M. Mathieu, C. Couprie, and Y. LeCun. Deep multi-scale
video prediction beyond mean square error. In International
Conference on Learning Representations (ICLR), 2016.
[25] A. Odena, C. Olah, and J. Shlens. Conditional image synthe-
sis with auxiliary classiﬁer gans. In International Conference
on Machine Learning (ICML), 2017.

[26] J. Oh, X. Guo, H. Lee, R. L. Lewis, and S. Singh. Action-
conditional video prediction using deep networks in atari
games. In Advances in Neural Information Processing Sys-
tems (NIPS), 2015.

[27] A. Radford, L. Metz, and S. Chintala. Unsupervised rep-
resentation learning with deep convolutional generative ad-
versarial networks. In International Conference on Learning
Representations (ICLR), 2016.

[28] D. J. Rezende, S. Mohamed, and D. Wierstra. Stochas-
tic backpropagation and variational inference in deep latent
gaussian models. In International Conference on Machine
Learning (ICML), 2014.

[29] K. Roth, A. Lucchi, S. Nowozin, and T. Hofmann. Stabiliz-
ing training of generative adversarial networks through reg-
ularization. In Advances in Neural Information Processing
Systems (NIPS), 2017.

[30] M. Saito, E. Matsumoto, and S. Saito. Temporal generative
adversarial nets with singular value clipping. In IEEE Inter-
national Conference on Computer Vision (ICCV), 2017.
[31] T. Salimans, I. Goodfellow, W. Zaremba, V. Cheung, A. Rad-
ford, and X. Chen. Improved techniques for training gans. In
Advances in Neural Information Processing Systems (NIPS),
2016.

[32] K. Soomro, A. R. Zamir, and M. Shah. Ucf101: A dataset
of 101 human actions classes from videos in the wild. arXiv
preprint arXiv:1212.0402, 2012.

[33] N. Srivastava, E. Mansimov, and R. Salakhutdinov. Unsuper-
vised learning of video representations using lstms. In Inter-
national Conference on Machine Learning (ICML), 2015.

[34] M. Szummer and R. W. Picard. Temporal texture modeling.
In International Conference on Image Processing (ICIP),
1996.

[35] L. Theis, A. v. d. Oord, and M. Bethge. A note on the eval-
uation of generative models. In International Conference on
Learning Representations (ICLR), 2016.

9

[36] S. Tulyakov, A. Fitzgibbon, and S. Nowozin. Hybrid vae:
Improving deep generative models using partial observa-
tions. Advances in Neural Information Processing Systems
(NIPS) Workshop, 2017.

[37] J. van Amersfoort, A. Kannan, M. Ranzato, A. Szlam,
D. Tran, and S. Chintala. Transformation-based models of
video sequences. arXiv preprint arXiv:1701.08435, 2017.

[38] A. van den Oord, N. Kalchbrenner, L. Espeholt, O. Vinyals,
A. Graves, et al. Conditional image generation with pixel-
cnn decoders. In Advances in Neural Information Processing
Systems (NIPS), 2016.

[39] R. Villegas, J. Yang, S. Hong, X. Lin, and H. Lee. Decom-
posing motion and content for natural video sequence pre-
diction. In International Conference on Learning Represen-
tations (ICLR), 2017.

[40] C. Vondrick, H. Pirsiavash, and A. Torralba. Generating
videos with scene dynamics. In Advances in Neural Infor-
mation Processing Systems (NIPS), 2016.

[41] L.-Y. Wei and M. Levoy. Fast texture synthesis using tree-

structured vector quantization. In ACM SIGGRAPH, 2000.

[42] T. Xue, J. Wu, K. Bouman, and B. Freeman. Probabilistic
modeling of future frames from a single image. In Advances
in Neural Information Processing Systems (NIPS), 2016.
[43] H. Zhang, T. Xu, H. Li, S. Zhang, X. Huang, X. Wang, and
D. Metaxas. Stackgan: Text to photo-realistic image synthe-
sis with stacked generative adversarial networks. IEEE In-
ternational Conference on Computer Vision (ICCV), 2016.

10

0

1

2

3

4

0

1

2

3

0

1

2

3

A. Network Architecture

Table 6: Network architectures of the image generative net-
work GI, the image discriminative network DI, and the
video generative network DV used in the experiments.

Conﬁguration

GI

Input

[za ∼ N (0, I), zm ∼ RM]
DCONV-(N512, K6, S0, P0), BN, LeakyReLU

DCONV-(N256, K4, S2, P1), BN, LeakyReLU

DCONV-(N128, K4, S2, P1), BN, LeakyReLU

DCONV-(N64, K4, S2, P1), BN, LeakyReLU

DCONV-(N3, K4, S2, P1), BN, LeakyReLU

DI

Conﬁguration

Input

height × width × 3

CONV-(N64, K4, S2, P1), BN, LeakyReLU

CONV-(N128, K4, S2, P1), BN, LeakyReLU

CONV-(N256, K4, S2, P1), BN, LeakyReLU

CONV-(N1, K4, S2, P1), Sigmoid

DV

Conﬁguration

Input

16 × height × width × 3

CONV3D-(N64, K4, S1, P0), BN, LeakyReLU

CONV3D-(N128, K4, S1, P0), BN, LeakyReLU

CONV3D-(N256, K4, S1, P0), BN, LeakyReLU

CONV3D-(N1, K4, S1, P0), Sigmoid

Table 6 detailed the network architecture used in the
main paper. We used several different type of layers. A
convolutional layer with N output channels, kernel size K,
stride S, and padding P is denoted in the table as CONV-
(N , K, S, P ) and similarly for 3D convolutional layers
CONV3D-(N , K, S, P ). Kernel size, padding, and stride
are equal for all the dimensions in each layer. Batch normal-
ization layers are followed by the LeakyReLU nonlinearity
in our case. The RM consisted of a single GRU module.

B. Additional Qualitative Results

Figures 7 and 8 show categorical facial expression and
categorical human actions video generation results, respec-
tively. In each ﬁgure, every group of three rows was gener-
ated with a ﬁxed content vector zC, but random action vec-
tor zA and motion vectors z(t)
M ’s. We found that the identity
was kept ﬁxed throughout a video. We noted that the length
of the generated videos were longer than those in the train-
ing data. This showed that the MoCoGAN can generalize
the video generation along the time dimension.

11

Figure 7: Facial expression video generation results. Every three rows have the same identity but different zA.

12

Figure 8: Human action video generation results. Every three rows have the same identity but different zA.

13

MoCoGAN: Decomposing Motion and Content for Video Generation

Sergey Tulyakov,
Snap Research
stulyakov@snap.com

Ming-Yu Liu, Xiaodong Yang,

Jan Kautz

NVIDIA
{mingyul,xiaodongy,jkautz}@nvidia.com

7
1
0
2
 
c
e
D
 
4
1
 
 
]

V
C
.
s
c
[
 
 
2
v
3
9
9
4
0
.
7
0
7
1
:
v
i
X
r
a

Abstract

Visual signals in a video can be divided into content and
motion. While content speciﬁes which objects are in the
video, motion describes their dynamics. Based on this prior,
we propose the Motion and Content decomposed Genera-
tive Adversarial Network (MoCoGAN) framework for video
generation. The proposed framework generates a video by
mapping a sequence of random vectors to a sequence of
video frames. Each random vector consists of a content
part and a motion part. While the content part is kept
ﬁxed, the motion part is realized as a stochastic process. To
learn motion and content decomposition in an unsupervised
manner, we introduce a novel adversarial learning scheme
utilizing both image and video discriminators. Extensive
experimental results on several challenging datasets with
qualitative and quantitative comparison to the state-of-the-
art approaches, verify effectiveness of the proposed frame-
work. In addition, we show that MoCoGAN allows one to
generate videos with same content but different motion as
well as videos with different content and same motion.

1. Introduction

Deep generative models have recently received an in-
creasing amount of attention, not only because they provide
a means to learn deep feature representations in an unsuper-
vised manner that can potentially leverage all the unlabeled
images on the Internet for training, but also because they
can be used to generate novel images necessary for various
vision applications. As steady progress toward better image
generation is made, it is also important to study the video
generation problem. However, the extension from gener-
ating images to generating videos turns out to be a highly
challenging task, although the generated data has just one
more dimension – the time dimension.

We argue video generation is much harder for the fol-
lowing reasons. First, since a video is a spatio-temporal
recording of visual information of objects performing var-
ious actions, a generative model needs to learn the plausi-
ble physical motion models of objects in addition to learn-
ing their appearance models. If the learned object motion

Figure 1: MoCoGAN adopts a motion and content decom-
posed representation for video generation. It uses an image
latent space (each latent code represents an image) and di-
vides the latent space into content and motion subspaces.
By sampling a point in the content subspace and sampling
different trajectories in the motion subspace, it generates
videos of the same object performing different motion. By
sampling different points in the content subspace and the
same motion trajectory in the motion subspace, it generates
videos of different objects performing the same motion.

model is incorrect, the generated video may contain objects
performing physically impossible motion. Second, the time
dimension brings in a huge amount of variations. Consider
the amount of speed variations that a person can have when
performing a squat movement. Each speed pattern results
in a different video, although the appearances of the human
in the videos are the same. Third, as human beings have
evolved to be sensitive to motion, motion artifacts are par-
ticularly perceptible.

Recently, a few attempts to approach the video genera-
tion problem were made through generative adversarial net-
works (GANs) [12]. Vondrick et al. [40] hypothesize that a
video clip is a point in a latent space and proposed a VGAN
framework for learning a mapping from the latent space to

1

video clips. A similar approach was proposed in the TGAN
work [30]. We argue that assuming a video clip is a point
in the latent space unnecessarily increases the complexity
of the problem, because videos of the same action with dif-
ferent execution speed are represented by different points
in the latent space. Moreover, this assumption forces ev-
ery generated video clip to have the same length, while the
length of real-world video clips varies. An alternative (and
likely more intuitive and efﬁcient) approach would assume
a latent space of images and consider that a video clip is
generated by traversing the points in the latent space. Video
clips of different lengths correspond to latent space trajec-
tories of different lengths.

In addition, as videos are about objects (content) per-
forming actions (motion), the latent space of images should
be further decomposed into two subspaces, where the devi-
ation of a point in the ﬁrst subspace (the content subspace)
leads content changes in a video clip and the deviation in
the second subspace (the motion subspace) results in tem-
poral motions. Through this modeling, videos of an action
with different execution speeds will only result in different
traversal speeds of a trajectory in the motion space. Decom-
posing motion and content allows a more controlled video
generation process. By changing the content representation
while ﬁxing the motion trajectory, we have videos of dif-
ferent objects performing the same motion. By changing
motion trajectories while ﬁxing the content representation,
we have videos of the same object performing different mo-
tion as illustrated in Fig. 1.

In this paper, we propose the Motion and Content de-
composed Generative Adversarial Network (MoCoGAN)
framework for video generation. It generates a video clip
by sequentially generating video frames. At each time step,
an image generative network maps a random vector to an
image. The random vector consists of two parts where the
ﬁrst is sampled from a content subspace and the second is
sampled from a motion subspace. Since content in a short
video clip usually remains the same, we model the content
space using a Gaussian distribution and use the same real-
ization to generate each frame in a video clip. On the other
hand, sampling from the motion space is achieved through
a recurrent neural network where the network parameters
are learned during training. Despite lacking supervision re-
garding the decomposition of motion and content in nat-
ural videos, we show that MoCoGAN can learn to disen-
tangle these two factors through a novel adversarial train-
ing scheme. Through extensive qualitative and quantitative
experimental validations with comparison to the state-of-
the-art approaches including VGAN [40] and TGAN [30],
as well as the future frame prediction methods including
Conditional-VGAN (C-VGAN) [40] and Motion and Con-
tent Network (MCNET) [39], we verify the effectiveness of
MoCoGAN.

1.1. Related Work

Video generation is not a new problem. Due to limita-
tions in computation, data, and modeling tools, early video
generation works focused on generating dynamic texture
patterns [34, 41, 9]. In the recent years, with the availability
of GPUs, Internet videos, and deep neural networks, we are
now better positioned to tackle this intriguing problem.

Various deep generative models were recently proposed
for image generation including GANs [12], variational au-
toencoders (VAEs) [20, 28, 36], and PixelCNNs [38]. In
this paper, we propose the MoCoGAN framework for video
generation, which is based on GANs.

Multiple GAN-based image generation frameworks
were proposed. Denton et al. [8] showed a Laplacian pyra-
mid implementation. Radford et al. [27] used a deeper con-
volution network. Zhang et al. [43] stacked two generative
networks to progressively render realistic images. Coupled
GANs [22] learned to generate corresponding images in dif-
ferent domains, later extended to translate an image from
one domain to a different domain in an unsupervised fash-
ion [21]. InfoGAN [5] learned a more interpretable latent
representation. Salimans et al. [31] proposed several GAN
training tricks. The WGAN [3] and LSGAN [23] frame-
works adopted alternative distribution distance metrics for
more stable adversarial training. Roth et al. [29] proposed
a special gradient penalty to further stabilize training. Kar-
ras et al. [18] used progressive growing of the discriminator
and the generator to generate high resolution images. The
proposed MoCoGAN framework generates a video clip by
sequentially generating images using an image generator.
The framework can easily leverage advances in image gen-
eration in the GAN framework for improving the quality of
the generated videos. As discussed in Section 1, [40, 30]
extended the GAN framework to the video generation prob-
lem by assuming a latent space of video clips where all the
clips have the same length.

Recurrent neural networks for image generation were
previously explored in [14, 16]. Speciﬁcally, some works
used recurrent mechanisms to iteratively reﬁne a generated
image. Our work is different to [14, 16] in that we use
the recurrent mechanism to generate motion embeddings
of video frames in a video clip. The image generation is
achieved through a convolutional neural network.

The future frame prediction problem studied in [33, 26,
24, 17, 10, 37, 42, 39, 7] is different to the video gen-
eration problem.
In future frame prediction, the goal is
to predict future frames in a video given the observed
frames in the video. Previous works on future frame pre-
diction can be roughly divided into two categories where
one focuses on generating raw pixel values in future frames
based on the observed ones [33, 26, 24, 17, 42, 39], while
the other focuses on generating transformations for reshuf-
ﬂing the pixels in the previous frames to construct fu-

2

ture frames [10, 37]. The availability of previous frames
makes future frame prediction a conditional image gener-
ation problem, which is different to the video generation
problem where the input to the generative network is only a
vector drawn from a latent space. We note that [39] used a
convolutional LSTM [15] encoder to encode temporal dif-
ferences between consecutive previous frames for extract-
ing motion information and a convolutional encoder to ex-
tract content information from the current image. The con-
catenation of the motion and content information was then
fed to a decoder to predict future frames.

1.2. Contributions

Our contributions are as follows:

1. We propose a novel GAN framework for unconditional
video generation, mapping noise vectors to videos.

2. We show the proposed framework provides a means to
control content and motion in video generation, which is
absent in the existing video generation frameworks.

3. We conduct extensive experimental validation on bench-
mark datasets with both quantitative and subjective com-
parison to the state-of-the-art video generation algo-
rithms including VGAN[40] and TGAN [30] to verify
the effectiveness of the proposed algorithm.

2. Generative Adversarial Networks

GANs [12] consist of a generator and a discriminator.
The objective of the generator is to generate images resem-
bling real images, while the objective of the discriminator
is to distinguish real images from generated ones.

Let x be a real image drawn from an image distribution,
pX , and z be a random vector in ZI ≡ Rd. Let GI and DI
be the image generator and the image discriminator. The
generator takes z as input and outputs an image, ˜x = GI(z),
that has the same support as x. We denote the distribution
of GI(z) as pGI . The discriminator estimates the probability
that an input image is drawn from pX . Ideally, DI(x) = 1
if x ∼ pX and DI(˜x) = 0 if ˜x ∼ pGI. Training of GI and
DI is achieved via solving a minimax problem given by

max
GI

min
DI

FI(DI, GI)

where the functional FI is given by

FI(DI, GI) = Ex∼pX [− log DI(x)] +
Ez∼pZI

[− log(1 − DI(GI(z)))].

In practice, (1) is solved by alternating gradient update.

Goodfellow et al. [12] show that, given enough capacity
to DI and GI and sufﬁcient training iterations, the distri-
bution pGI converges to pX . As a result, from a random
vector input z, the network GI can synthesize an image that
resembles one drawn from the true distribution, pX .

(1)

(2)

3

2.1. Extension to Fixed-length Video Generation

Recently, [40] extended the GAN framework to video
generation by proposing a Video GAN (VGAN) framework.
Let vL = [x(1), ..., x(L)] be a video clip with L frames.
The video generation in VGAN is achieved by replacing
the vanilla CNN-based image generator and discriminator,
GI and DI, with a spatio-temporal CNN-based video gener-
ator and discriminator, GVL and DVL. The video generator
GVL maps a random vector z ∈ ZVL ≡ Rd to a ﬁxed-length
video clip, ˜vL = [˜x(1), ..., ˜x(L)] = GVL (z) and the video
discriminator DVL differentiates real video clips from gen-
erated ones. Ideally, DVL (vL) = 1 if vL is sampled from
pV L and DVL (˜vL) = 0 if ˜vL is sampled from the video
generator distribution pGVL . The TGAN framework [30]
also maps a random vector to a ﬁxed length clip. The dif-
ference is that TGAN maps the random vector, representing
a ﬁxed-length video, to a ﬁxed number of random vectors,
representing individual frames in the video clip and uses an
image generator for generation. Instead of using the vanilla
GAN framework for minimizing the Jensen-Shannon diver-
gence, the TGAN training is based on the WGAN frame-
work [3] and minimizes the earth mover distance.

3. Motion and Content Decomposed GAN

In MoCoGAN, we assume a latent space of images ZI ≡
Rd where each point z ∈ ZI represents an image, and a
video of K frames is represented by a path of length K in
the latent space, [z(1), ..., z(K)]. By adopting this formula-
tion, videos of different lengths can be generated by paths of
different lengths. Moreover, videos of the same action ex-
ecuted with different speeds can be generated by traversing
the same path in the latent space with different speeds.

We further assume ZI is decomposed into the content
ZC and motion ZM subspaces: ZI = ZC × ZM where
ZC = RdC , ZM = RdM , and d = dC + dM. The content
subspace models motion-independent appearance in videos,
while the motion subspace models motion-dependent ap-
pearance in videos. For example, in a video of a person
smiling, content represents the identity of the person, while
motion represents the changes of facial muscle conﬁgura-
tions of the person. A pair of the person’s identity and the
facial muscle conﬁguration represents a face image of the
person. A sequence of these pairs represents a video clip
of the person smiling. By swapping the look of the person
with the look of another person, a video of a different person
smiling is represented.

We model the content subspace using a Gaussian distri-
bution: zC ∼ pZC ≡ N (z|0, IdC ) where IdC is an identity
matrix of size dC × dC. Based on the observation that the
content remains largely the same in a short video clip, we
use the same realization, zC, for generating different frames
in a video clip. Motion in the video clip is modeled by a

GI, the image discriminator, DI, and the video discrimi-
nator, DV. The image generator generates a video clip by
sequentially mapping vectors in ZI to images, from a se-
(cid:3)] to a sequence of im-
(cid:3), ..., (cid:2) zC
quence of vectors [(cid:2) zC
z(K)
z(1)
M
M
(cid:3)) and
ages, ˜v = [˜x(1), ..., ˜x(K)], where ˜x(k) = GI((cid:2) zC
z(k)
M
z(k)
M ’s are from the recurrent neural network, RM. We note
that the video length K can vary for each video generation.
Both DI and DV play the judge role, providing criticisms
to GI and RM. The image discriminator DI is specialized
in criticizing GI based on individual images. It is trained to
determine if a frame is sampled from a real video clip, v,
or from ˜v. On the other hand, DV provides criticisms to GI
based on the generated video clip. DV takes a ﬁxed length
video clip, say T frames, and decides if a video clip was
sampled from a real video or from ˜v. Different from DI,
which is based on vanilla CNN architecture, DV is based on
a spatio-temporal CNN architecture. We note that the clip
length T is a hyperparameter, which is set to 16 throughout
our experiments. We also note that T can be smaller than
the generated video length K. A video of length K can be
divided into K − T + 1 clips in a sliding-window fashion,
and each of the clips can be fed into DV.

The video discriminator DV also evaluates the generated
motion. Since GI has no concept of motion, the criticisms
on the motion part go directly to the recurrent neural net-
work, RM. In order to generate a video with realistic dy-
namics that fools DV, RM has to learn to generate a se-
quence of motion codes [z(1)
M ] from a sequence of
i.i.d. noise inputs [(cid:15)(1), ..., (cid:15)(K)] in a way such that GI can
map z(k) = [zC, z(k)

M ] to consecutive frames in a video.

M , ..., z(K)

Ideally, DV alone should be sufﬁcient for training GI
and RM, because DV provides feedback on both static im-
age appearance and video dynamics. However, we found
that using DI signiﬁcantly improves the convergence of the
adversarial training. This is because training DI is simpler,
as it only needs to focus on static appearances. Fig. 2 shows
visual representation of the MoCoGAN framework.

Learning. Let pV be the distribution of video clips of
variable lengths. Let κ be a discrete random variable denot-
ing the length of a video clip sampled from pV. (In practice,
we can estimate the distribution of κ, termed pK, by com-
puting a histogram of video clip length from training data).
To generate a video, we ﬁrst sample a content vector, zC,
and a length, κ. We then run RM for κ steps and, at each
time step, RM takes a random variable (cid:15) as the input. A
generated video is then given by

(cid:34)

˜v =

GI(

(cid:20) zC
RM(1)

(cid:21)
), ..., GI(

(cid:20) zC
RM(κ)

(cid:21)
)

(cid:35)
.

(4)

For a video,

M , ..., z(K)

the content vector, zC,

Figure 2: The MoCoGAN framework for video gener-
ation.
is sam-
pled once and ﬁxed. Then, a series of random variables
[(cid:15)(1), ..., (cid:15)(K)] is sampled and mapped to a series of motion
codes [z(1)
M ] via the recurrent neural network RM.
A generator GI produces a frame, ˜x(k), using the content
and the motion vectors {zC, z(k)
M }. The discriminators, DI
and DV, are trained on real and fake images and videos,
respectively, sampled from the training set v and the gener-
ated set ˜v. The function S1 samples a single frame from a
video, ST samples T consequtive frames.

path in the motion subspace ZM. The sequence of vectors
for generating a video is represented by

[z(1), ..., z(K)] =

(cid:104)(cid:2) zC
z(1)
M

(cid:3), ..., (cid:2) zC
z(K)
M

(cid:3)(cid:105)

(3)

where zC ∈ ZC and z(k)
M ∈ ZM for all k’s. Since not all
paths in ZM correspond to physically plausible motion, we
need to learn to generate valid paths. We model the path
generation process using a recurrent neural network.

Let RM to be a recurrent neural network. At each time
step, it takes a vector sampled from a Gaussian distribu-
tion as input: (cid:15)(k) ∼ pE ≡ N ((cid:15)|0, IdE ) and outputs a
vector in ZM, which is used as the motion representation.
Let RM(k) be the output of the recurrent neural network at
time k. Then, z(k)
M = RM(k). Intuitively, the function of
the recurrent neural network is to map a sequence of inde-
pendent and identically distributed (i.i.d.) random variables
[(cid:15)(1), ..., (cid:15)(K)] to a sequence of correlated random variables
[RM(1), ..., RM(K)] representing the dynamics in a video.
Injecting noise at every iteration models uncertainty of the
future motion at each timestep. We implement RM using a
one-layer GRU network [6].

Networks. MoCoGAN consists of 4 sub-networks, which
are the recurrent neural network, RM, the image generator,

Recall that our DI and DV take one frame and T con-
secutive frames in a video as input, respectively. In order

4

to represent these sampling mechanisms, we introduce two
random access functions S1 and ST. The function S1 takes
a video clip (either v ∼ pV or ˜v ∼ p ˜V) and outputs a
random frame from the clip, while the function ST takes a
video clip and randomly returns T consecutive frames from
the clip. With this notation, the MoCoGAN learning prob-
lem is

max
GI,RM

min
DI,DV

FV(DI, DV, GI, RM)

(5)

(6)

where the objective function FV(DI, DV, GI, RM) is
Ev[− log DI(S1(v))] + E˜v[− log(1 − DI(S1(˜v)))] +
Ev[− log DV(ST(v))] + E˜v[− log(1 − DV(ST(˜v)))],
where Ev is a shorthand for Ev∼pV , and E˜v for E˜v∼p ˜V
.
In (6), the ﬁrst and second terms encourage DI to output
1 for a video frame from a real video clip v and 0 for a
video frame from a generated one ˜v. Similarly, the third
and fourth terms encourage DV to output 1 for T consec-
utive frames in a real video clip v and 0 for T consecutive
frames in a generated one ˜v. The second and fourth terms
encourage the image generator and the recurrent neural net-
work to produce realistic images and video sequences of
T-consecutive frames, such that no discriminator can dis-
tinguish them from real images and videos.

We train MoCoGAN using the alternating gradient up-
date algorithm as in [11]. Speciﬁcally, in one step, we up-
date DI and DV while ﬁxing GI and RM. In the alternating
step, we update GI and RM while ﬁxing DI and DV.

3.1. Categorical Dynamics

Dynamics in videos are often categorical (e.g., discrete
action categories: walking, running, jumping, etc.). To
model this categorical signal, we augment the input to RM
with a categorical random variable, zA, where each realiza-
tion is a one-hot vector. We keep the realization ﬁxed since
the action category in a short video remains the same. The
input to RM is then given by

(cid:34)(cid:20) zA
(cid:15)(1)

(cid:21)

, ...,

(cid:20) zA
(cid:15)(K)

(cid:21)(cid:35)
,

(7)

To relate zA to the true action category, we adopt the In-
foGAN learning [5] and augment the objective function in
(6) to FV(DI, DV, GI, RM) + λLI (GI, Q) where LI is a
lower bound of the mutual information between the gener-
ated video clip and zA, λ is a hyperparameter, and the auxil-
iary distribution Q (which approximates the distribution of
the action category variable conditioning on the video clip)
is implemented by adding a softmax layer to the last feature
layer of DV. We use λ = 1. We note that when the labeled
training data are available, we can train Q to output the cat-
egory label for a real input video clip to further improve the
performance [25].

4. Experiments

We conducted extensive experimental validation to eval-
uate MoCoGAN. In addition to comparing to VGAN [40]
and TGAN [30], both quantitatively and qualitatively, we
evaluated the ability of MoCoGAN to generate 1) videos
of the same object performing different motions by using a
ﬁxed content vector and varying motion trajectories and 2)
videos of different objects performing the same motion by
using different content vectors and the same motion trajec-
tory. We then compared a variant of the MoCoGAN frame-
work with state-of-the-art next frame prediction methods:
VGAN and MCNET [39]. Evaluating generative models is
known to be a challenging task [35]. Hence, we report ex-
perimental results on several datasets, where we can obtain
reliable performance metrics:

• Shape motion. The dataset contained two types of
shapes (circles and squares) with varying sizes and col-
ors, performing two types of motion: one moving from
left to right, and the other moving from top to bot-
tom. The motion trajectories were sampled from Bezier
curves. There were 4, 000 videos in the dataset; the im-
age resolution was 64 × 64 and video length was 16.

• Facial expression. We used the MUG Facial Expression
Database [1] for this experiment. The dataset consisted
of 86 subjects. Each video consisted of 50 to 160 frames.
We cropped the face regions and scaled to 96 × 96. We
discarded videos containing fewer than 64 frames and
used only the sequences representing one of the six fa-
cial expressions: anger, fear, disgust, happiness, sadness,
and surprise. In total, we trained on 1, 254 videos.

• Tai-Chi. We downloaded 4, 500 Tai Chi video clips from
YouTube. For each clip, we applied a human pose esti-
mator [4] and cropped the clip so that the performer is in
the center. Videos were scaled to 64 × 64 pixels.

• Human actions. We used the Weizmann Action data-
base [13], containing 81 videos of 9 people performing
9 actions, including jumping-jack and waving-hands. We
scaled the videos to 96×96. Due to the small size, we did
not conduct a quantitative evaluation using the dataset.
Instead, we provide visual results in Fig. 1 and Fig. 4a.

• UCF101 [32]. The database is commonly used for video
action recognition. It includes 13, 220 videos of 101 dif-
ferent action categories. Similarly to the TGAN work
[30], we scaled each frame to 85 × 64 and cropped the
central 64 × 64 regions for learning.

Implementation. The details of the network designs are
given in the supplementary materials. We used ADAM [19]
for training, with a learning rate of 0.0002 and momentums
of 0.5 and 0.999. Our code will be made public.

5

(a) Generated by MoCoGAN

(b) Generated by VGAN [40]

(c) Generated by TGAN [30]

Figure 3: Generated video clips used in the user study. The video clips were randomly selected. The ﬁgure is best viewed via
the Acrobat Reader on a desktop. Click each image to play the video clip.

Table 1: Video generation content consistency comparison.
A smaller ACD means the generated frames in a video are
perceptually more similar. We also compute the ACD for
the training set, which is the reference.

ACD

Shape Motion

Facial Expressions

Reference
VGAN [40]
TGAN [30]
MoCoGAN

0
5.02
2.08
1.79

0.116
0.322
0.305
0.201

4.1. Video Generation Performance

Quantitative comparison. We compared MoCoGAN to
VGAN and TGAN1 using the shape motion and facial ex-
pression datasets. For each dataset, we trained a video
generation model and generated 256 videos for evaluation.
The VGAN and TGAN implementations can only generate
ﬁxed-length videos (32 frames and 16 frames correspond-
ingly). For a fair comparison, we generated 16 frames us-
ing MoCoGAN, and selected every second frame from the
videos generated by VGAN, such that each video has 16
frames in total.

For quantitative comparison, we measured content con-
sistency of a generated video using the Average Content
Distance (ACD) metric. For shape motion, we ﬁrst com-
puted the average color of the generated shape in each
frame. Each frame was then represented by a 3-dimensional
vector. The ACD is then given by the average pairwise L2
distance of the per-frame average color vectors. For facial
expression videos, we employed OpenFace [2], which out-
performs human performance in the face recognition task,
for measuring video content consistency. OpenFace pro-
duced a feature vector for each frame in a face video. The
ACD was then computed using the average pairwise L2 dis-

1The VGAN and TGAN implementations are provided by their authors.

Table 2: Inception score for models trained on UCF101. All
values except MoCoGAN’s are taken from [30].

VGAN

TGAN

MoCoGAN

UCF101

8.18 ± .05

11.85 ± .07

12.42 ± .03

Table 3: User preference score on video generation quality.

User preference, %

Facial Exp.

Tai-Chi

MoCoGAN / VGAN 84.2 / 15.8
MoCoGAN / TGAN 54.7 / 45.3

75.4 / 24.6
68.0 / 32.0

tance of the per-frame feature vectors.

We computed the average ACD scores for the 256 videos
generated by the competing algorithms for comparison. The
results are given in Table 1. From the table, we found
that the content of the videos generated by MoCoGAN was
more consistent, especially for the facial expression video
generation task: MoCoGAN achieved an ACD score of
0.201, which was almost 40% better than 0.322 of VGAN
and 34% better than 0.305 of TGAN. Fig. 3 shows examples
of facial expression videos for competing algorithms.

Furthermore, we compared with TGAN and VGAN by
training on the UCF101 database and computing the in-
ception score similarly to [30]. Table 2 shows comparison
results. In this experiment we used the same MoCoGAN
model as in all other experiments. We observed that MoCo-
GAN was able to learn temporal dynamics better, due to
the decomposed representation, as it generated more realis-
tic temporal sequences. We also noted that TGAN reached
the inception score of 11.85 with WGAN training proce-
dure and Singular Value Clipping (SVC), while MoCoGAN
showed a higher inception score 12.42 without such tricks,
supporting that the proposed framework is more stable than
and superior to the TGAN approach.

6

(a) Samples from the model trained on the Weizmann database.

(b) Examples of changing the motion code while ﬁxing the content
code. Every row has ﬁxed content, every column has ﬁxed motion.

(c) Image-to-video translation. In each block: input image (left),
video generated by MoCoGAN (right).
Figure 4: The ﬁgure is best viewed with Acrobat Reader on
a desktop. Click each image to play the video clip.

User study. We conducted a user study to quantitatively
compare MoCoGAN to VGAN and TGAN using the facial
expression and Tai-Chi datasets. For each algorithm, we
used the trained model to randomly generate 80 videos for
each task. We then randomly paired the videos generated
by the MoCoGAN with the videos from one of the compet-
ing algorithms to form 80 questions. These questions were
sent to the workers on Amazon Mechanical Turk (AMT)
for evaluation. The videos from different algorithms were
shown in random order for a fair comparison. Each ques-
tion was answered by 3 different workers. The workers
were instructed to choose the video that looks more real-
istic. Only the workers with a lifetime HIT (Human Intel-
ligent Task) approval rate greater than 95% participated in
the user study.

We report the average preference scores (the average
number of times, a worker prefers an algorithm) in Table 3.
From the table, we ﬁnd that the workers considered the
videos generated by MoCoGAN more realistic most of the
times. Compared to VGAN, MoCoGAN achieved a prefer-
ence score of 84.2% and 75.4% for the facial expression and
Tai-Chi datasets, respectively. Compared to TGAN, MoCo-
GAN achieved a preference score of 54.7% and 68.0% for
the facial expression and Tai-Chi datasets, respectively. In
Fig. 3, we visualize the facial expression and Tai-Chi videos
generated by the competing algorithms. We ﬁnd that the
videos generated by MoCoGAN are more realistic and con-
tained less content and motion artifacts.

Qualitative evaluation. We conducted a qualitative ex-
periment to demonstrate our motion and content decom-

7

Table 4: Performance on categorical facial expression video
generation with various MoCoGAN settings.

Settings

MCS

ACD

DI
DI
DI
DI

zA → GI
0.472
zA → RM 0.491
zA → GI
0.355
zA → RM 0.581

1.115
1.073
0.738
0.606

posed representation. We sampled two content codes and
seven motion codes, giving us 14 videos. Fig. 4b shows an
example randomly selected from this experiment. Each row
has the same content code, and each column has the same
motion code. We observed that MoCoGAN generated the
same motion sequences for two different content samples.

4.2. Categorical Video Generation

We augmented MoCoGAN with categorical variables
and trained it for facial expression video generation as de-
scribed in Section 3.1. The MUG dataset contains 6 differ-
ent facial expressions and hence zA is realized as a 6 dimen-
sional one-hot vector. We then generated 96 frames of fa-
cial expression videos. During generation, we changed the
action category, zA, every 16 frames to cover all 6 expres-
sions. Hence, a generated video corresponded to a person
performing 6 different facial expressions, one after another.
To evaluate the performance, we computed the ACD of
the generated videos. A smaller ACD means the generated
faces over the 96 frames were more likely to be from the
same person. Note that the ACD reported in this subsec-
tion are generally larger than the ACD reported in Table 1,
because the generated videos in this experiment are 6 times
longer and contain 6 facial expressions versus 1. We also
used the motion control score (MCS) to evaluate MoCo-
GAN’s capability in motion generation control. To compute
MCS, we ﬁrst trained a spatio-temporal CNN classiﬁer for
action recognition using the labeled training dataset. During
test time, we used the classiﬁer to verify whether the gener-
ated video contained the action. The MCS is then given by
testing accuracy of the classiﬁer. A model with larger MCS
offers better control over the action category.

In this experiment, we also evaluated the impact of dif-
ferent conditioning schemes to the categorical video gener-
ation performance. The ﬁrst scheme is our default scheme
where zA → RM. The second scheme, termed zA → GI,
was to feed the category variable directly to the image gen-
erator. In addition, to show the impact of the image discrim-
inative network DI, we considered training the MoCoGAN
framework without DI.

Table 4 shows experimental results. We ﬁnd that the
models trained with DI consistently yield better perfor-
mances on various metrics. We also ﬁnd that zA → RM

Figure 5: Generated videos of changing facial expressions. We changed the expression from smile to fear through surprise.

Table 5: User preference score on the quality of the image-
to-video-translation results.

User preference, %

Tai-Chi

MoCoGAN / C-VGAN 66.9 / 33.1
65.6 / 34.4
MoCoGAN / MCNET

model using the Tai-Chi dataset. In test time, we sampled
random images from a withheld test set to generate video
sequences.
In addition to the MoCoGAN loss, we have
added the L1 reconstruction loss for training the encoder-
decoder architecture similar to [21]. Under this setting,
MoCoGAN generated a video sequence starting from the
ﬁrst frame (see Fig. 4c). We compared with two state-of-
the-art approaches on this task: a Conditional-VGAN (C-
VGAN) and Motion Content Network (MCNET) [39] and
performed a user study to compare the competing methods.
We note that MCNET used 4 frames to predict a video,
while C-VGAN and MoCoGAN required a single frame
only. Table 5 shows the user preference scores. The results
support that MoCoGAN was able to generate more realistic
videos than C-VGAN and MCNET.

5. Conclusion

We presented the MoCoGAN framework for motion and
content decomposed video generation. Given sufﬁcient
video training data, MoCoGAN automatically learns to dis-
entangle motion from content in an unsupervised manner.
For instance, given videos of people performing different
facial expressions, MoCoGAN learns to separate a person’s
identity from their expression, thus allowing us to synthe-
size a new video of a person performing different expres-
sions, or ﬁxing the expression and generating various iden-
tities. This is enabled by a new generative adversarial net-
work, which generates a video clip by sequentially gener-
ating video frames. Each video frame is generated from
a random vector, which consists of two parts, one signify-
ing content and one signifying motion. The content sub-
space is modeled with a Gaussian distribution, whereas the
motion subspace is modeled with a recurrent neural net-
work. We sample this space in order to synthesize each
video frame. Our experimental evaluation supports that the
proposed framework is superior to current state-of-the-art
video generation and next frame prediction methods.

Figure 6: MoCoGAN models with varying (dC, dM) set-
tings on facial expression generation.

yields better performance. Fig. 5 shows two videos from
the best model in Table 4. We observe that by ﬁxing the
content vector but changing the expression label, it gener-
ates videos of the same person performing different expres-
sions. And similarly, by changing the content vector and
providing the same motion trajectory, we generate videos
of different people showing the same expression sequence.
We conducted an experiment to empirically analyze the
impact of the dimensions of the content and motion vectors
zC and z(t)
M (referred to as dC and dM) to the categorical
video generation performance. In the experiment, we ﬁxed
the sum of the dimensions to 60 (i.e., dC + dM = 60) and
changed the value of dC from 10 to 50, with a step size of
10. Fig. 6 shows the results.

We found when dC was large, MoCoGAN had a small
ACD. This meant a video generated by the MoCoGAN re-
sembled the same person performing different expressions.
We were expecting a larger zM would lead to a larger MCS
but found the contrary. Inspecting the generated videos, we
found when dM was large (i.e. dC was small), MoCoGAN
failed to generate recognizable faces, resulting in a poor
MCS. In this case, given poor image quality, the facial ex-
pression recognition network could only perform a random
guess on the expression and scored poorly. Based on this,
we set dC = 50 and dM = 10 in all the experiments.

4.3. Image-to-video Translation

We trained a variant of the MoCoGAN framework, in
which the generator is realized as an encoder-decoder archi-
tecture [21], where the encoder produced the content code
zC and the initial motion code z(0)
m . Subsequent motion
codes were produced by RM and concatenated with the con-
tent code to generate each frame. That is the input was an
image and the output was a video. We trained a MoCoGAN

8

References

[1] N. Aifanti, C. Papachristou, and A. Delopoulos. The mug
facial expression database. In Image Analysis for Multime-
dia Interactive Services (WIAMIS), 2010 11th International
Workshop on, pages 1–4, 2010.

[2] B. Amos, B. Ludwiczuk, and M. Satyanarayanan. Openface:
A general-purpose face recognition library with mobile ap-
plications. Technical report, CMU-CS-16-118, CMU School
of Computer Science, 2016.

[3] M. Arjovsky, S. Chintala, and L. Bottou. Wasserstein gan.

arXiv preprint arXiv:1701.07875, 2017.

[4] Z. Cao, T. Simon, S.-E. Wei, and Y. Sheikh. Realtime multi-
person 2d pose estimation using part afﬁnity ﬁelds. In IEEE
Conference on Computer Vision and Pattern Recognition
(CVPR), 2017.

[5] X. Chen, Y. Duan, R. Houthooft, J. Schulman, I. Sutskever,
and P. Abbeel. Infogan: Interpretable representation learning
by information maximizing generative adversarial nets.
In
Advances in Neural Information Processing Systems (NIPS),
2016.

[6] J. Chung, C. Gulcehre, K. Cho, and Y. Bengio. Empirical
evaluation of gated recurrent neural networks on sequence
In Advances in Neural Information Processing
modeling.
Systems (NIPS) Workshop, 2014.

[7] E. Denton and V. Birodkar. Unsupervised learning of dis-
entangled representations from video. Advances in Neural
Information Processing Systems (NIPS), 2017.

[8] E. L. Denton, S. Chintala, R. Fergus, et al. Deep genera-
tive image models using a laplacian pyramid of adversarial
In Advances in Neural Information Processing
networks.
Systems (NIPS), 2015.

[9] G. Doretto, A. Chiuso, Y. N. Wu, and S. Soatto. Dynamic
textures. International Journal of Computer Vision (IJCV),
2003.

[10] C. Finn, I. Goodfellow, and S. Levine. Unsupervised learn-
ing for physical interaction through video prediction. In Ad-
vances in Neural Information Processing Systems (NIPS),
2016.

[11] I. Goodfellow. Nips 2016 tutorial: Generative adversarial

networks. arXiv preprint arXiv:1701.00160, 2016.

[12] I. Goodfellow,

J. Pouget-Abadie, M. Mirza, B. Xu,
D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio. Gen-
erative adversarial nets. In Advances in Neural Information
Processing Systems (NIPS), 2014.

[13] L. Gorelick, M. Blank, E. Shechtman, M. Irani, and R. Basri.
Actions as space-time shapes. IEEE Transactions on Pattern
Analysis and Machine Intelligence (TPAMI), 29(12):2247–
2253, 2007.

[14] K. Gregor, I. Danihelka, A. Graves, D. J. Rezende, and
D. Wierstra. Draw: A recurrent neural network for image
generation. In International Conference on Machine Learn-
ing (ICML), 2015.

[15] S. Hochreiter and J. Schmidhuber. Long short-term memory.

Neural computation, 1997.

[16] D. J. Im, C. D. Kim, H. Jiang, and R. Memisevic. Generating
images with recurrent adversarial networks. arXiv preprint
arXiv:1602.05110, 2016.

[17] N. Kalchbrenner, A. v. d. Oord, K. Simonyan, I. Danihelka,
O. Vinyals, A. Graves, and K. Kavukcuoglu. Video pixel

networks. arXiv preprint arXiv:1610.00527, 2016.

[18] T. Karras, T. Aila, S. Laine, and J. Lehtinen. Progressive
growing of gans for improved quality, stability, and variation.
arXiv preprint arXiv:1710.10196, 2017.

[19] D. Kingma and J. Ba. Adam: A method for stochastic op-
timization. In International Conference on Learning Repre-
sentations (ICLR), 2015.

[20] D. P. Kingma and M. Welling. Auto-encoding variational
bayes. In International Conference on Learning Representa-
tions (ICLR), 2014.

[21] M.-Y. Liu, T. Breuel, and J. Kautz. Unsupervised image-to-
image translation networks. In Advances in Neural Informa-
tion Processing Systems (NIPS), 2017.

[22] M.-Y. Liu and O. Tuzel. Coupled generative adversarial net-
works. In Advances in Neural Information Processing Sys-
tems (NIPS), 2016.

[23] X. Mao, Q. Li, H. Xie, R. Y. Lau, Z. Wang, and S. P. Smolley.
Least squares generative adversarial networks. IEEE Inter-
national Conference on Computer Vision (ICCV), 2017.
[24] M. Mathieu, C. Couprie, and Y. LeCun. Deep multi-scale
video prediction beyond mean square error. In International
Conference on Learning Representations (ICLR), 2016.
[25] A. Odena, C. Olah, and J. Shlens. Conditional image synthe-
sis with auxiliary classiﬁer gans. In International Conference
on Machine Learning (ICML), 2017.

[26] J. Oh, X. Guo, H. Lee, R. L. Lewis, and S. Singh. Action-
conditional video prediction using deep networks in atari
games. In Advances in Neural Information Processing Sys-
tems (NIPS), 2015.

[27] A. Radford, L. Metz, and S. Chintala. Unsupervised rep-
resentation learning with deep convolutional generative ad-
versarial networks. In International Conference on Learning
Representations (ICLR), 2016.

[28] D. J. Rezende, S. Mohamed, and D. Wierstra. Stochas-
tic backpropagation and variational inference in deep latent
gaussian models. In International Conference on Machine
Learning (ICML), 2014.

[29] K. Roth, A. Lucchi, S. Nowozin, and T. Hofmann. Stabiliz-
ing training of generative adversarial networks through reg-
ularization. In Advances in Neural Information Processing
Systems (NIPS), 2017.

[30] M. Saito, E. Matsumoto, and S. Saito. Temporal generative
adversarial nets with singular value clipping. In IEEE Inter-
national Conference on Computer Vision (ICCV), 2017.
[31] T. Salimans, I. Goodfellow, W. Zaremba, V. Cheung, A. Rad-
ford, and X. Chen. Improved techniques for training gans. In
Advances in Neural Information Processing Systems (NIPS),
2016.

[32] K. Soomro, A. R. Zamir, and M. Shah. Ucf101: A dataset
of 101 human actions classes from videos in the wild. arXiv
preprint arXiv:1212.0402, 2012.

[33] N. Srivastava, E. Mansimov, and R. Salakhutdinov. Unsuper-
vised learning of video representations using lstms. In Inter-
national Conference on Machine Learning (ICML), 2015.

[34] M. Szummer and R. W. Picard. Temporal texture modeling.
In International Conference on Image Processing (ICIP),
1996.

[35] L. Theis, A. v. d. Oord, and M. Bethge. A note on the eval-
uation of generative models. In International Conference on
Learning Representations (ICLR), 2016.

9

[36] S. Tulyakov, A. Fitzgibbon, and S. Nowozin. Hybrid vae:
Improving deep generative models using partial observa-
tions. Advances in Neural Information Processing Systems
(NIPS) Workshop, 2017.

[37] J. van Amersfoort, A. Kannan, M. Ranzato, A. Szlam,
D. Tran, and S. Chintala. Transformation-based models of
video sequences. arXiv preprint arXiv:1701.08435, 2017.

[38] A. van den Oord, N. Kalchbrenner, L. Espeholt, O. Vinyals,
A. Graves, et al. Conditional image generation with pixel-
cnn decoders. In Advances in Neural Information Processing
Systems (NIPS), 2016.

[39] R. Villegas, J. Yang, S. Hong, X. Lin, and H. Lee. Decom-
posing motion and content for natural video sequence pre-
diction. In International Conference on Learning Represen-
tations (ICLR), 2017.

[40] C. Vondrick, H. Pirsiavash, and A. Torralba. Generating
videos with scene dynamics. In Advances in Neural Infor-
mation Processing Systems (NIPS), 2016.

[41] L.-Y. Wei and M. Levoy. Fast texture synthesis using tree-

structured vector quantization. In ACM SIGGRAPH, 2000.

[42] T. Xue, J. Wu, K. Bouman, and B. Freeman. Probabilistic
modeling of future frames from a single image. In Advances
in Neural Information Processing Systems (NIPS), 2016.
[43] H. Zhang, T. Xu, H. Li, S. Zhang, X. Huang, X. Wang, and
D. Metaxas. Stackgan: Text to photo-realistic image synthe-
sis with stacked generative adversarial networks. IEEE In-
ternational Conference on Computer Vision (ICCV), 2016.

10

0

1

2

3

4

0

1

2

3

0

1

2

3

A. Network Architecture

Table 6: Network architectures of the image generative net-
work GI, the image discriminative network DI, and the
video generative network DV used in the experiments.

Conﬁguration

GI

Input

[za ∼ N (0, I), zm ∼ RM]
DCONV-(N512, K6, S0, P0), BN, LeakyReLU

DCONV-(N256, K4, S2, P1), BN, LeakyReLU

DCONV-(N128, K4, S2, P1), BN, LeakyReLU

DCONV-(N64, K4, S2, P1), BN, LeakyReLU

DCONV-(N3, K4, S2, P1), BN, LeakyReLU

DI

Conﬁguration

Input

height × width × 3

CONV-(N64, K4, S2, P1), BN, LeakyReLU

CONV-(N128, K4, S2, P1), BN, LeakyReLU

CONV-(N256, K4, S2, P1), BN, LeakyReLU

CONV-(N1, K4, S2, P1), Sigmoid

DV

Conﬁguration

Input

16 × height × width × 3

CONV3D-(N64, K4, S1, P0), BN, LeakyReLU

CONV3D-(N128, K4, S1, P0), BN, LeakyReLU

CONV3D-(N256, K4, S1, P0), BN, LeakyReLU

CONV3D-(N1, K4, S1, P0), Sigmoid

Table 6 detailed the network architecture used in the
main paper. We used several different type of layers. A
convolutional layer with N output channels, kernel size K,
stride S, and padding P is denoted in the table as CONV-
(N , K, S, P ) and similarly for 3D convolutional layers
CONV3D-(N , K, S, P ). Kernel size, padding, and stride
are equal for all the dimensions in each layer. Batch normal-
ization layers are followed by the LeakyReLU nonlinearity
in our case. The RM consisted of a single GRU module.

B. Additional Qualitative Results

Figures 7 and 8 show categorical facial expression and
categorical human actions video generation results, respec-
tively. In each ﬁgure, every group of three rows was gener-
ated with a ﬁxed content vector zC, but random action vec-
tor zA and motion vectors z(t)
M ’s. We found that the identity
was kept ﬁxed throughout a video. We noted that the length
of the generated videos were longer than those in the train-
ing data. This showed that the MoCoGAN can generalize
the video generation along the time dimension.

11

Figure 7: Facial expression video generation results. Every three rows have the same identity but different zA.

12

Figure 8: Human action video generation results. Every three rows have the same identity but different zA.

13

MoCoGAN: Decomposing Motion and Content for Video Generation

Sergey Tulyakov,
Snap Research
stulyakov@snap.com

Ming-Yu Liu, Xiaodong Yang,

Jan Kautz

NVIDIA
{mingyul,xiaodongy,jkautz}@nvidia.com

7
1
0
2
 
c
e
D
 
4
1
 
 
]

V
C
.
s
c
[
 
 
2
v
3
9
9
4
0
.
7
0
7
1
:
v
i
X
r
a

Abstract

Visual signals in a video can be divided into content and
motion. While content speciﬁes which objects are in the
video, motion describes their dynamics. Based on this prior,
we propose the Motion and Content decomposed Genera-
tive Adversarial Network (MoCoGAN) framework for video
generation. The proposed framework generates a video by
mapping a sequence of random vectors to a sequence of
video frames. Each random vector consists of a content
part and a motion part. While the content part is kept
ﬁxed, the motion part is realized as a stochastic process. To
learn motion and content decomposition in an unsupervised
manner, we introduce a novel adversarial learning scheme
utilizing both image and video discriminators. Extensive
experimental results on several challenging datasets with
qualitative and quantitative comparison to the state-of-the-
art approaches, verify effectiveness of the proposed frame-
work. In addition, we show that MoCoGAN allows one to
generate videos with same content but different motion as
well as videos with different content and same motion.

1. Introduction

Deep generative models have recently received an in-
creasing amount of attention, not only because they provide
a means to learn deep feature representations in an unsuper-
vised manner that can potentially leverage all the unlabeled
images on the Internet for training, but also because they
can be used to generate novel images necessary for various
vision applications. As steady progress toward better image
generation is made, it is also important to study the video
generation problem. However, the extension from gener-
ating images to generating videos turns out to be a highly
challenging task, although the generated data has just one
more dimension – the time dimension.

We argue video generation is much harder for the fol-
lowing reasons. First, since a video is a spatio-temporal
recording of visual information of objects performing var-
ious actions, a generative model needs to learn the plausi-
ble physical motion models of objects in addition to learn-
ing their appearance models. If the learned object motion

Figure 1: MoCoGAN adopts a motion and content decom-
posed representation for video generation. It uses an image
latent space (each latent code represents an image) and di-
vides the latent space into content and motion subspaces.
By sampling a point in the content subspace and sampling
different trajectories in the motion subspace, it generates
videos of the same object performing different motion. By
sampling different points in the content subspace and the
same motion trajectory in the motion subspace, it generates
videos of different objects performing the same motion.

model is incorrect, the generated video may contain objects
performing physically impossible motion. Second, the time
dimension brings in a huge amount of variations. Consider
the amount of speed variations that a person can have when
performing a squat movement. Each speed pattern results
in a different video, although the appearances of the human
in the videos are the same. Third, as human beings have
evolved to be sensitive to motion, motion artifacts are par-
ticularly perceptible.

Recently, a few attempts to approach the video genera-
tion problem were made through generative adversarial net-
works (GANs) [12]. Vondrick et al. [40] hypothesize that a
video clip is a point in a latent space and proposed a VGAN
framework for learning a mapping from the latent space to

1

video clips. A similar approach was proposed in the TGAN
work [30]. We argue that assuming a video clip is a point
in the latent space unnecessarily increases the complexity
of the problem, because videos of the same action with dif-
ferent execution speed are represented by different points
in the latent space. Moreover, this assumption forces ev-
ery generated video clip to have the same length, while the
length of real-world video clips varies. An alternative (and
likely more intuitive and efﬁcient) approach would assume
a latent space of images and consider that a video clip is
generated by traversing the points in the latent space. Video
clips of different lengths correspond to latent space trajec-
tories of different lengths.

In addition, as videos are about objects (content) per-
forming actions (motion), the latent space of images should
be further decomposed into two subspaces, where the devi-
ation of a point in the ﬁrst subspace (the content subspace)
leads content changes in a video clip and the deviation in
the second subspace (the motion subspace) results in tem-
poral motions. Through this modeling, videos of an action
with different execution speeds will only result in different
traversal speeds of a trajectory in the motion space. Decom-
posing motion and content allows a more controlled video
generation process. By changing the content representation
while ﬁxing the motion trajectory, we have videos of dif-
ferent objects performing the same motion. By changing
motion trajectories while ﬁxing the content representation,
we have videos of the same object performing different mo-
tion as illustrated in Fig. 1.

In this paper, we propose the Motion and Content de-
composed Generative Adversarial Network (MoCoGAN)
framework for video generation. It generates a video clip
by sequentially generating video frames. At each time step,
an image generative network maps a random vector to an
image. The random vector consists of two parts where the
ﬁrst is sampled from a content subspace and the second is
sampled from a motion subspace. Since content in a short
video clip usually remains the same, we model the content
space using a Gaussian distribution and use the same real-
ization to generate each frame in a video clip. On the other
hand, sampling from the motion space is achieved through
a recurrent neural network where the network parameters
are learned during training. Despite lacking supervision re-
garding the decomposition of motion and content in nat-
ural videos, we show that MoCoGAN can learn to disen-
tangle these two factors through a novel adversarial train-
ing scheme. Through extensive qualitative and quantitative
experimental validations with comparison to the state-of-
the-art approaches including VGAN [40] and TGAN [30],
as well as the future frame prediction methods including
Conditional-VGAN (C-VGAN) [40] and Motion and Con-
tent Network (MCNET) [39], we verify the effectiveness of
MoCoGAN.

1.1. Related Work

Video generation is not a new problem. Due to limita-
tions in computation, data, and modeling tools, early video
generation works focused on generating dynamic texture
patterns [34, 41, 9]. In the recent years, with the availability
of GPUs, Internet videos, and deep neural networks, we are
now better positioned to tackle this intriguing problem.

Various deep generative models were recently proposed
for image generation including GANs [12], variational au-
toencoders (VAEs) [20, 28, 36], and PixelCNNs [38]. In
this paper, we propose the MoCoGAN framework for video
generation, which is based on GANs.

Multiple GAN-based image generation frameworks
were proposed. Denton et al. [8] showed a Laplacian pyra-
mid implementation. Radford et al. [27] used a deeper con-
volution network. Zhang et al. [43] stacked two generative
networks to progressively render realistic images. Coupled
GANs [22] learned to generate corresponding images in dif-
ferent domains, later extended to translate an image from
one domain to a different domain in an unsupervised fash-
ion [21]. InfoGAN [5] learned a more interpretable latent
representation. Salimans et al. [31] proposed several GAN
training tricks. The WGAN [3] and LSGAN [23] frame-
works adopted alternative distribution distance metrics for
more stable adversarial training. Roth et al. [29] proposed
a special gradient penalty to further stabilize training. Kar-
ras et al. [18] used progressive growing of the discriminator
and the generator to generate high resolution images. The
proposed MoCoGAN framework generates a video clip by
sequentially generating images using an image generator.
The framework can easily leverage advances in image gen-
eration in the GAN framework for improving the quality of
the generated videos. As discussed in Section 1, [40, 30]
extended the GAN framework to the video generation prob-
lem by assuming a latent space of video clips where all the
clips have the same length.

Recurrent neural networks for image generation were
previously explored in [14, 16]. Speciﬁcally, some works
used recurrent mechanisms to iteratively reﬁne a generated
image. Our work is different to [14, 16] in that we use
the recurrent mechanism to generate motion embeddings
of video frames in a video clip. The image generation is
achieved through a convolutional neural network.

The future frame prediction problem studied in [33, 26,
24, 17, 10, 37, 42, 39, 7] is different to the video gen-
eration problem.
In future frame prediction, the goal is
to predict future frames in a video given the observed
frames in the video. Previous works on future frame pre-
diction can be roughly divided into two categories where
one focuses on generating raw pixel values in future frames
based on the observed ones [33, 26, 24, 17, 42, 39], while
the other focuses on generating transformations for reshuf-
ﬂing the pixels in the previous frames to construct fu-

2

ture frames [10, 37]. The availability of previous frames
makes future frame prediction a conditional image gener-
ation problem, which is different to the video generation
problem where the input to the generative network is only a
vector drawn from a latent space. We note that [39] used a
convolutional LSTM [15] encoder to encode temporal dif-
ferences between consecutive previous frames for extract-
ing motion information and a convolutional encoder to ex-
tract content information from the current image. The con-
catenation of the motion and content information was then
fed to a decoder to predict future frames.

1.2. Contributions

Our contributions are as follows:

1. We propose a novel GAN framework for unconditional
video generation, mapping noise vectors to videos.

2. We show the proposed framework provides a means to
control content and motion in video generation, which is
absent in the existing video generation frameworks.

3. We conduct extensive experimental validation on bench-
mark datasets with both quantitative and subjective com-
parison to the state-of-the-art video generation algo-
rithms including VGAN[40] and TGAN [30] to verify
the effectiveness of the proposed algorithm.

2. Generative Adversarial Networks

GANs [12] consist of a generator and a discriminator.
The objective of the generator is to generate images resem-
bling real images, while the objective of the discriminator
is to distinguish real images from generated ones.

Let x be a real image drawn from an image distribution,
pX , and z be a random vector in ZI ≡ Rd. Let GI and DI
be the image generator and the image discriminator. The
generator takes z as input and outputs an image, ˜x = GI(z),
that has the same support as x. We denote the distribution
of GI(z) as pGI . The discriminator estimates the probability
that an input image is drawn from pX . Ideally, DI(x) = 1
if x ∼ pX and DI(˜x) = 0 if ˜x ∼ pGI. Training of GI and
DI is achieved via solving a minimax problem given by

max
GI

min
DI

FI(DI, GI)

where the functional FI is given by

FI(DI, GI) = Ex∼pX [− log DI(x)] +
Ez∼pZI

[− log(1 − DI(GI(z)))].

In practice, (1) is solved by alternating gradient update.

Goodfellow et al. [12] show that, given enough capacity
to DI and GI and sufﬁcient training iterations, the distri-
bution pGI converges to pX . As a result, from a random
vector input z, the network GI can synthesize an image that
resembles one drawn from the true distribution, pX .

(1)

(2)

3

2.1. Extension to Fixed-length Video Generation

Recently, [40] extended the GAN framework to video
generation by proposing a Video GAN (VGAN) framework.
Let vL = [x(1), ..., x(L)] be a video clip with L frames.
The video generation in VGAN is achieved by replacing
the vanilla CNN-based image generator and discriminator,
GI and DI, with a spatio-temporal CNN-based video gener-
ator and discriminator, GVL and DVL. The video generator
GVL maps a random vector z ∈ ZVL ≡ Rd to a ﬁxed-length
video clip, ˜vL = [˜x(1), ..., ˜x(L)] = GVL (z) and the video
discriminator DVL differentiates real video clips from gen-
erated ones. Ideally, DVL (vL) = 1 if vL is sampled from
pV L and DVL (˜vL) = 0 if ˜vL is sampled from the video
generator distribution pGVL . The TGAN framework [30]
also maps a random vector to a ﬁxed length clip. The dif-
ference is that TGAN maps the random vector, representing
a ﬁxed-length video, to a ﬁxed number of random vectors,
representing individual frames in the video clip and uses an
image generator for generation. Instead of using the vanilla
GAN framework for minimizing the Jensen-Shannon diver-
gence, the TGAN training is based on the WGAN frame-
work [3] and minimizes the earth mover distance.

3. Motion and Content Decomposed GAN

In MoCoGAN, we assume a latent space of images ZI ≡
Rd where each point z ∈ ZI represents an image, and a
video of K frames is represented by a path of length K in
the latent space, [z(1), ..., z(K)]. By adopting this formula-
tion, videos of different lengths can be generated by paths of
different lengths. Moreover, videos of the same action ex-
ecuted with different speeds can be generated by traversing
the same path in the latent space with different speeds.

We further assume ZI is decomposed into the content
ZC and motion ZM subspaces: ZI = ZC × ZM where
ZC = RdC , ZM = RdM , and d = dC + dM. The content
subspace models motion-independent appearance in videos,
while the motion subspace models motion-dependent ap-
pearance in videos. For example, in a video of a person
smiling, content represents the identity of the person, while
motion represents the changes of facial muscle conﬁgura-
tions of the person. A pair of the person’s identity and the
facial muscle conﬁguration represents a face image of the
person. A sequence of these pairs represents a video clip
of the person smiling. By swapping the look of the person
with the look of another person, a video of a different person
smiling is represented.

We model the content subspace using a Gaussian distri-
bution: zC ∼ pZC ≡ N (z|0, IdC ) where IdC is an identity
matrix of size dC × dC. Based on the observation that the
content remains largely the same in a short video clip, we
use the same realization, zC, for generating different frames
in a video clip. Motion in the video clip is modeled by a

GI, the image discriminator, DI, and the video discrimi-
nator, DV. The image generator generates a video clip by
sequentially mapping vectors in ZI to images, from a se-
(cid:3)] to a sequence of im-
(cid:3), ..., (cid:2) zC
quence of vectors [(cid:2) zC
z(K)
z(1)
M
M
(cid:3)) and
ages, ˜v = [˜x(1), ..., ˜x(K)], where ˜x(k) = GI((cid:2) zC
z(k)
M
z(k)
M ’s are from the recurrent neural network, RM. We note
that the video length K can vary for each video generation.
Both DI and DV play the judge role, providing criticisms
to GI and RM. The image discriminator DI is specialized
in criticizing GI based on individual images. It is trained to
determine if a frame is sampled from a real video clip, v,
or from ˜v. On the other hand, DV provides criticisms to GI
based on the generated video clip. DV takes a ﬁxed length
video clip, say T frames, and decides if a video clip was
sampled from a real video or from ˜v. Different from DI,
which is based on vanilla CNN architecture, DV is based on
a spatio-temporal CNN architecture. We note that the clip
length T is a hyperparameter, which is set to 16 throughout
our experiments. We also note that T can be smaller than
the generated video length K. A video of length K can be
divided into K − T + 1 clips in a sliding-window fashion,
and each of the clips can be fed into DV.

The video discriminator DV also evaluates the generated
motion. Since GI has no concept of motion, the criticisms
on the motion part go directly to the recurrent neural net-
work, RM. In order to generate a video with realistic dy-
namics that fools DV, RM has to learn to generate a se-
quence of motion codes [z(1)
M ] from a sequence of
i.i.d. noise inputs [(cid:15)(1), ..., (cid:15)(K)] in a way such that GI can
map z(k) = [zC, z(k)

M ] to consecutive frames in a video.

M , ..., z(K)

Ideally, DV alone should be sufﬁcient for training GI
and RM, because DV provides feedback on both static im-
age appearance and video dynamics. However, we found
that using DI signiﬁcantly improves the convergence of the
adversarial training. This is because training DI is simpler,
as it only needs to focus on static appearances. Fig. 2 shows
visual representation of the MoCoGAN framework.

Learning. Let pV be the distribution of video clips of
variable lengths. Let κ be a discrete random variable denot-
ing the length of a video clip sampled from pV. (In practice,
we can estimate the distribution of κ, termed pK, by com-
puting a histogram of video clip length from training data).
To generate a video, we ﬁrst sample a content vector, zC,
and a length, κ. We then run RM for κ steps and, at each
time step, RM takes a random variable (cid:15) as the input. A
generated video is then given by

(cid:34)

˜v =

GI(

(cid:20) zC
RM(1)

(cid:21)
), ..., GI(

(cid:20) zC
RM(κ)

(cid:21)
)

(cid:35)
.

(4)

For a video,

M , ..., z(K)

the content vector, zC,

Figure 2: The MoCoGAN framework for video gener-
ation.
is sam-
pled once and ﬁxed. Then, a series of random variables
[(cid:15)(1), ..., (cid:15)(K)] is sampled and mapped to a series of motion
codes [z(1)
M ] via the recurrent neural network RM.
A generator GI produces a frame, ˜x(k), using the content
and the motion vectors {zC, z(k)
M }. The discriminators, DI
and DV, are trained on real and fake images and videos,
respectively, sampled from the training set v and the gener-
ated set ˜v. The function S1 samples a single frame from a
video, ST samples T consequtive frames.

path in the motion subspace ZM. The sequence of vectors
for generating a video is represented by

[z(1), ..., z(K)] =

(cid:104)(cid:2) zC
z(1)
M

(cid:3), ..., (cid:2) zC
z(K)
M

(cid:3)(cid:105)

(3)

where zC ∈ ZC and z(k)
M ∈ ZM for all k’s. Since not all
paths in ZM correspond to physically plausible motion, we
need to learn to generate valid paths. We model the path
generation process using a recurrent neural network.

Let RM to be a recurrent neural network. At each time
step, it takes a vector sampled from a Gaussian distribu-
tion as input: (cid:15)(k) ∼ pE ≡ N ((cid:15)|0, IdE ) and outputs a
vector in ZM, which is used as the motion representation.
Let RM(k) be the output of the recurrent neural network at
time k. Then, z(k)
M = RM(k). Intuitively, the function of
the recurrent neural network is to map a sequence of inde-
pendent and identically distributed (i.i.d.) random variables
[(cid:15)(1), ..., (cid:15)(K)] to a sequence of correlated random variables
[RM(1), ..., RM(K)] representing the dynamics in a video.
Injecting noise at every iteration models uncertainty of the
future motion at each timestep. We implement RM using a
one-layer GRU network [6].

Networks. MoCoGAN consists of 4 sub-networks, which
are the recurrent neural network, RM, the image generator,

Recall that our DI and DV take one frame and T con-
secutive frames in a video as input, respectively. In order

4

to represent these sampling mechanisms, we introduce two
random access functions S1 and ST. The function S1 takes
a video clip (either v ∼ pV or ˜v ∼ p ˜V) and outputs a
random frame from the clip, while the function ST takes a
video clip and randomly returns T consecutive frames from
the clip. With this notation, the MoCoGAN learning prob-
lem is

max
GI,RM

min
DI,DV

FV(DI, DV, GI, RM)

(5)

(6)

where the objective function FV(DI, DV, GI, RM) is
Ev[− log DI(S1(v))] + E˜v[− log(1 − DI(S1(˜v)))] +
Ev[− log DV(ST(v))] + E˜v[− log(1 − DV(ST(˜v)))],
where Ev is a shorthand for Ev∼pV , and E˜v for E˜v∼p ˜V
.
In (6), the ﬁrst and second terms encourage DI to output
1 for a video frame from a real video clip v and 0 for a
video frame from a generated one ˜v. Similarly, the third
and fourth terms encourage DV to output 1 for T consec-
utive frames in a real video clip v and 0 for T consecutive
frames in a generated one ˜v. The second and fourth terms
encourage the image generator and the recurrent neural net-
work to produce realistic images and video sequences of
T-consecutive frames, such that no discriminator can dis-
tinguish them from real images and videos.

We train MoCoGAN using the alternating gradient up-
date algorithm as in [11]. Speciﬁcally, in one step, we up-
date DI and DV while ﬁxing GI and RM. In the alternating
step, we update GI and RM while ﬁxing DI and DV.

3.1. Categorical Dynamics

Dynamics in videos are often categorical (e.g., discrete
action categories: walking, running, jumping, etc.). To
model this categorical signal, we augment the input to RM
with a categorical random variable, zA, where each realiza-
tion is a one-hot vector. We keep the realization ﬁxed since
the action category in a short video remains the same. The
input to RM is then given by

(cid:34)(cid:20) zA
(cid:15)(1)

(cid:21)

, ...,

(cid:20) zA
(cid:15)(K)

(cid:21)(cid:35)
,

(7)

To relate zA to the true action category, we adopt the In-
foGAN learning [5] and augment the objective function in
(6) to FV(DI, DV, GI, RM) + λLI (GI, Q) where LI is a
lower bound of the mutual information between the gener-
ated video clip and zA, λ is a hyperparameter, and the auxil-
iary distribution Q (which approximates the distribution of
the action category variable conditioning on the video clip)
is implemented by adding a softmax layer to the last feature
layer of DV. We use λ = 1. We note that when the labeled
training data are available, we can train Q to output the cat-
egory label for a real input video clip to further improve the
performance [25].

4. Experiments

We conducted extensive experimental validation to eval-
uate MoCoGAN. In addition to comparing to VGAN [40]
and TGAN [30], both quantitatively and qualitatively, we
evaluated the ability of MoCoGAN to generate 1) videos
of the same object performing different motions by using a
ﬁxed content vector and varying motion trajectories and 2)
videos of different objects performing the same motion by
using different content vectors and the same motion trajec-
tory. We then compared a variant of the MoCoGAN frame-
work with state-of-the-art next frame prediction methods:
VGAN and MCNET [39]. Evaluating generative models is
known to be a challenging task [35]. Hence, we report ex-
perimental results on several datasets, where we can obtain
reliable performance metrics:

• Shape motion. The dataset contained two types of
shapes (circles and squares) with varying sizes and col-
ors, performing two types of motion: one moving from
left to right, and the other moving from top to bot-
tom. The motion trajectories were sampled from Bezier
curves. There were 4, 000 videos in the dataset; the im-
age resolution was 64 × 64 and video length was 16.

• Facial expression. We used the MUG Facial Expression
Database [1] for this experiment. The dataset consisted
of 86 subjects. Each video consisted of 50 to 160 frames.
We cropped the face regions and scaled to 96 × 96. We
discarded videos containing fewer than 64 frames and
used only the sequences representing one of the six fa-
cial expressions: anger, fear, disgust, happiness, sadness,
and surprise. In total, we trained on 1, 254 videos.

• Tai-Chi. We downloaded 4, 500 Tai Chi video clips from
YouTube. For each clip, we applied a human pose esti-
mator [4] and cropped the clip so that the performer is in
the center. Videos were scaled to 64 × 64 pixels.

• Human actions. We used the Weizmann Action data-
base [13], containing 81 videos of 9 people performing
9 actions, including jumping-jack and waving-hands. We
scaled the videos to 96×96. Due to the small size, we did
not conduct a quantitative evaluation using the dataset.
Instead, we provide visual results in Fig. 1 and Fig. 4a.

• UCF101 [32]. The database is commonly used for video
action recognition. It includes 13, 220 videos of 101 dif-
ferent action categories. Similarly to the TGAN work
[30], we scaled each frame to 85 × 64 and cropped the
central 64 × 64 regions for learning.

Implementation. The details of the network designs are
given in the supplementary materials. We used ADAM [19]
for training, with a learning rate of 0.0002 and momentums
of 0.5 and 0.999. Our code will be made public.

5

(a) Generated by MoCoGAN

(b) Generated by VGAN [40]

(c) Generated by TGAN [30]

Figure 3: Generated video clips used in the user study. The video clips were randomly selected. The ﬁgure is best viewed via
the Acrobat Reader on a desktop. Click each image to play the video clip.

Table 1: Video generation content consistency comparison.
A smaller ACD means the generated frames in a video are
perceptually more similar. We also compute the ACD for
the training set, which is the reference.

ACD

Shape Motion

Facial Expressions

Reference
VGAN [40]
TGAN [30]
MoCoGAN

0
5.02
2.08
1.79

0.116
0.322
0.305
0.201

4.1. Video Generation Performance

Quantitative comparison. We compared MoCoGAN to
VGAN and TGAN1 using the shape motion and facial ex-
pression datasets. For each dataset, we trained a video
generation model and generated 256 videos for evaluation.
The VGAN and TGAN implementations can only generate
ﬁxed-length videos (32 frames and 16 frames correspond-
ingly). For a fair comparison, we generated 16 frames us-
ing MoCoGAN, and selected every second frame from the
videos generated by VGAN, such that each video has 16
frames in total.

For quantitative comparison, we measured content con-
sistency of a generated video using the Average Content
Distance (ACD) metric. For shape motion, we ﬁrst com-
puted the average color of the generated shape in each
frame. Each frame was then represented by a 3-dimensional
vector. The ACD is then given by the average pairwise L2
distance of the per-frame average color vectors. For facial
expression videos, we employed OpenFace [2], which out-
performs human performance in the face recognition task,
for measuring video content consistency. OpenFace pro-
duced a feature vector for each frame in a face video. The
ACD was then computed using the average pairwise L2 dis-

1The VGAN and TGAN implementations are provided by their authors.

Table 2: Inception score for models trained on UCF101. All
values except MoCoGAN’s are taken from [30].

VGAN

TGAN

MoCoGAN

UCF101

8.18 ± .05

11.85 ± .07

12.42 ± .03

Table 3: User preference score on video generation quality.

User preference, %

Facial Exp.

Tai-Chi

MoCoGAN / VGAN 84.2 / 15.8
MoCoGAN / TGAN 54.7 / 45.3

75.4 / 24.6
68.0 / 32.0

tance of the per-frame feature vectors.

We computed the average ACD scores for the 256 videos
generated by the competing algorithms for comparison. The
results are given in Table 1. From the table, we found
that the content of the videos generated by MoCoGAN was
more consistent, especially for the facial expression video
generation task: MoCoGAN achieved an ACD score of
0.201, which was almost 40% better than 0.322 of VGAN
and 34% better than 0.305 of TGAN. Fig. 3 shows examples
of facial expression videos for competing algorithms.

Furthermore, we compared with TGAN and VGAN by
training on the UCF101 database and computing the in-
ception score similarly to [30]. Table 2 shows comparison
results. In this experiment we used the same MoCoGAN
model as in all other experiments. We observed that MoCo-
GAN was able to learn temporal dynamics better, due to
the decomposed representation, as it generated more realis-
tic temporal sequences. We also noted that TGAN reached
the inception score of 11.85 with WGAN training proce-
dure and Singular Value Clipping (SVC), while MoCoGAN
showed a higher inception score 12.42 without such tricks,
supporting that the proposed framework is more stable than
and superior to the TGAN approach.

6

(a) Samples from the model trained on the Weizmann database.

(b) Examples of changing the motion code while ﬁxing the content
code. Every row has ﬁxed content, every column has ﬁxed motion.

(c) Image-to-video translation. In each block: input image (left),
video generated by MoCoGAN (right).
Figure 4: The ﬁgure is best viewed with Acrobat Reader on
a desktop. Click each image to play the video clip.

User study. We conducted a user study to quantitatively
compare MoCoGAN to VGAN and TGAN using the facial
expression and Tai-Chi datasets. For each algorithm, we
used the trained model to randomly generate 80 videos for
each task. We then randomly paired the videos generated
by the MoCoGAN with the videos from one of the compet-
ing algorithms to form 80 questions. These questions were
sent to the workers on Amazon Mechanical Turk (AMT)
for evaluation. The videos from different algorithms were
shown in random order for a fair comparison. Each ques-
tion was answered by 3 different workers. The workers
were instructed to choose the video that looks more real-
istic. Only the workers with a lifetime HIT (Human Intel-
ligent Task) approval rate greater than 95% participated in
the user study.

We report the average preference scores (the average
number of times, a worker prefers an algorithm) in Table 3.
From the table, we ﬁnd that the workers considered the
videos generated by MoCoGAN more realistic most of the
times. Compared to VGAN, MoCoGAN achieved a prefer-
ence score of 84.2% and 75.4% for the facial expression and
Tai-Chi datasets, respectively. Compared to TGAN, MoCo-
GAN achieved a preference score of 54.7% and 68.0% for
the facial expression and Tai-Chi datasets, respectively. In
Fig. 3, we visualize the facial expression and Tai-Chi videos
generated by the competing algorithms. We ﬁnd that the
videos generated by MoCoGAN are more realistic and con-
tained less content and motion artifacts.

Qualitative evaluation. We conducted a qualitative ex-
periment to demonstrate our motion and content decom-

7

Table 4: Performance on categorical facial expression video
generation with various MoCoGAN settings.

Settings

MCS

ACD

DI
DI
DI
DI

zA → GI
0.472
zA → RM 0.491
zA → GI
0.355
zA → RM 0.581

1.115
1.073
0.738
0.606

posed representation. We sampled two content codes and
seven motion codes, giving us 14 videos. Fig. 4b shows an
example randomly selected from this experiment. Each row
has the same content code, and each column has the same
motion code. We observed that MoCoGAN generated the
same motion sequences for two different content samples.

4.2. Categorical Video Generation

We augmented MoCoGAN with categorical variables
and trained it for facial expression video generation as de-
scribed in Section 3.1. The MUG dataset contains 6 differ-
ent facial expressions and hence zA is realized as a 6 dimen-
sional one-hot vector. We then generated 96 frames of fa-
cial expression videos. During generation, we changed the
action category, zA, every 16 frames to cover all 6 expres-
sions. Hence, a generated video corresponded to a person
performing 6 different facial expressions, one after another.
To evaluate the performance, we computed the ACD of
the generated videos. A smaller ACD means the generated
faces over the 96 frames were more likely to be from the
same person. Note that the ACD reported in this subsec-
tion are generally larger than the ACD reported in Table 1,
because the generated videos in this experiment are 6 times
longer and contain 6 facial expressions versus 1. We also
used the motion control score (MCS) to evaluate MoCo-
GAN’s capability in motion generation control. To compute
MCS, we ﬁrst trained a spatio-temporal CNN classiﬁer for
action recognition using the labeled training dataset. During
test time, we used the classiﬁer to verify whether the gener-
ated video contained the action. The MCS is then given by
testing accuracy of the classiﬁer. A model with larger MCS
offers better control over the action category.

In this experiment, we also evaluated the impact of dif-
ferent conditioning schemes to the categorical video gener-
ation performance. The ﬁrst scheme is our default scheme
where zA → RM. The second scheme, termed zA → GI,
was to feed the category variable directly to the image gen-
erator. In addition, to show the impact of the image discrim-
inative network DI, we considered training the MoCoGAN
framework without DI.

Table 4 shows experimental results. We ﬁnd that the
models trained with DI consistently yield better perfor-
mances on various metrics. We also ﬁnd that zA → RM

Figure 5: Generated videos of changing facial expressions. We changed the expression from smile to fear through surprise.

Table 5: User preference score on the quality of the image-
to-video-translation results.

User preference, %

Tai-Chi

MoCoGAN / C-VGAN 66.9 / 33.1
65.6 / 34.4
MoCoGAN / MCNET

model using the Tai-Chi dataset. In test time, we sampled
random images from a withheld test set to generate video
sequences.
In addition to the MoCoGAN loss, we have
added the L1 reconstruction loss for training the encoder-
decoder architecture similar to [21]. Under this setting,
MoCoGAN generated a video sequence starting from the
ﬁrst frame (see Fig. 4c). We compared with two state-of-
the-art approaches on this task: a Conditional-VGAN (C-
VGAN) and Motion Content Network (MCNET) [39] and
performed a user study to compare the competing methods.
We note that MCNET used 4 frames to predict a video,
while C-VGAN and MoCoGAN required a single frame
only. Table 5 shows the user preference scores. The results
support that MoCoGAN was able to generate more realistic
videos than C-VGAN and MCNET.

5. Conclusion

We presented the MoCoGAN framework for motion and
content decomposed video generation. Given sufﬁcient
video training data, MoCoGAN automatically learns to dis-
entangle motion from content in an unsupervised manner.
For instance, given videos of people performing different
facial expressions, MoCoGAN learns to separate a person’s
identity from their expression, thus allowing us to synthe-
size a new video of a person performing different expres-
sions, or ﬁxing the expression and generating various iden-
tities. This is enabled by a new generative adversarial net-
work, which generates a video clip by sequentially gener-
ating video frames. Each video frame is generated from
a random vector, which consists of two parts, one signify-
ing content and one signifying motion. The content sub-
space is modeled with a Gaussian distribution, whereas the
motion subspace is modeled with a recurrent neural net-
work. We sample this space in order to synthesize each
video frame. Our experimental evaluation supports that the
proposed framework is superior to current state-of-the-art
video generation and next frame prediction methods.

Figure 6: MoCoGAN models with varying (dC, dM) set-
tings on facial expression generation.

yields better performance. Fig. 5 shows two videos from
the best model in Table 4. We observe that by ﬁxing the
content vector but changing the expression label, it gener-
ates videos of the same person performing different expres-
sions. And similarly, by changing the content vector and
providing the same motion trajectory, we generate videos
of different people showing the same expression sequence.
We conducted an experiment to empirically analyze the
impact of the dimensions of the content and motion vectors
zC and z(t)
M (referred to as dC and dM) to the categorical
video generation performance. In the experiment, we ﬁxed
the sum of the dimensions to 60 (i.e., dC + dM = 60) and
changed the value of dC from 10 to 50, with a step size of
10. Fig. 6 shows the results.

We found when dC was large, MoCoGAN had a small
ACD. This meant a video generated by the MoCoGAN re-
sembled the same person performing different expressions.
We were expecting a larger zM would lead to a larger MCS
but found the contrary. Inspecting the generated videos, we
found when dM was large (i.e. dC was small), MoCoGAN
failed to generate recognizable faces, resulting in a poor
MCS. In this case, given poor image quality, the facial ex-
pression recognition network could only perform a random
guess on the expression and scored poorly. Based on this,
we set dC = 50 and dM = 10 in all the experiments.

4.3. Image-to-video Translation

We trained a variant of the MoCoGAN framework, in
which the generator is realized as an encoder-decoder archi-
tecture [21], where the encoder produced the content code
zC and the initial motion code z(0)
m . Subsequent motion
codes were produced by RM and concatenated with the con-
tent code to generate each frame. That is the input was an
image and the output was a video. We trained a MoCoGAN

8

References

[1] N. Aifanti, C. Papachristou, and A. Delopoulos. The mug
facial expression database. In Image Analysis for Multime-
dia Interactive Services (WIAMIS), 2010 11th International
Workshop on, pages 1–4, 2010.

[2] B. Amos, B. Ludwiczuk, and M. Satyanarayanan. Openface:
A general-purpose face recognition library with mobile ap-
plications. Technical report, CMU-CS-16-118, CMU School
of Computer Science, 2016.

[3] M. Arjovsky, S. Chintala, and L. Bottou. Wasserstein gan.

arXiv preprint arXiv:1701.07875, 2017.

[4] Z. Cao, T. Simon, S.-E. Wei, and Y. Sheikh. Realtime multi-
person 2d pose estimation using part afﬁnity ﬁelds. In IEEE
Conference on Computer Vision and Pattern Recognition
(CVPR), 2017.

[5] X. Chen, Y. Duan, R. Houthooft, J. Schulman, I. Sutskever,
and P. Abbeel. Infogan: Interpretable representation learning
by information maximizing generative adversarial nets.
In
Advances in Neural Information Processing Systems (NIPS),
2016.

[6] J. Chung, C. Gulcehre, K. Cho, and Y. Bengio. Empirical
evaluation of gated recurrent neural networks on sequence
In Advances in Neural Information Processing
modeling.
Systems (NIPS) Workshop, 2014.

[7] E. Denton and V. Birodkar. Unsupervised learning of dis-
entangled representations from video. Advances in Neural
Information Processing Systems (NIPS), 2017.

[8] E. L. Denton, S. Chintala, R. Fergus, et al. Deep genera-
tive image models using a laplacian pyramid of adversarial
In Advances in Neural Information Processing
networks.
Systems (NIPS), 2015.

[9] G. Doretto, A. Chiuso, Y. N. Wu, and S. Soatto. Dynamic
textures. International Journal of Computer Vision (IJCV),
2003.

[10] C. Finn, I. Goodfellow, and S. Levine. Unsupervised learn-
ing for physical interaction through video prediction. In Ad-
vances in Neural Information Processing Systems (NIPS),
2016.

[11] I. Goodfellow. Nips 2016 tutorial: Generative adversarial

networks. arXiv preprint arXiv:1701.00160, 2016.

[12] I. Goodfellow,

J. Pouget-Abadie, M. Mirza, B. Xu,
D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio. Gen-
erative adversarial nets. In Advances in Neural Information
Processing Systems (NIPS), 2014.

[13] L. Gorelick, M. Blank, E. Shechtman, M. Irani, and R. Basri.
Actions as space-time shapes. IEEE Transactions on Pattern
Analysis and Machine Intelligence (TPAMI), 29(12):2247–
2253, 2007.

[14] K. Gregor, I. Danihelka, A. Graves, D. J. Rezende, and
D. Wierstra. Draw: A recurrent neural network for image
generation. In International Conference on Machine Learn-
ing (ICML), 2015.

[15] S. Hochreiter and J. Schmidhuber. Long short-term memory.

Neural computation, 1997.

[16] D. J. Im, C. D. Kim, H. Jiang, and R. Memisevic. Generating
images with recurrent adversarial networks. arXiv preprint
arXiv:1602.05110, 2016.

[17] N. Kalchbrenner, A. v. d. Oord, K. Simonyan, I. Danihelka,
O. Vinyals, A. Graves, and K. Kavukcuoglu. Video pixel

networks. arXiv preprint arXiv:1610.00527, 2016.

[18] T. Karras, T. Aila, S. Laine, and J. Lehtinen. Progressive
growing of gans for improved quality, stability, and variation.
arXiv preprint arXiv:1710.10196, 2017.

[19] D. Kingma and J. Ba. Adam: A method for stochastic op-
timization. In International Conference on Learning Repre-
sentations (ICLR), 2015.

[20] D. P. Kingma and M. Welling. Auto-encoding variational
bayes. In International Conference on Learning Representa-
tions (ICLR), 2014.

[21] M.-Y. Liu, T. Breuel, and J. Kautz. Unsupervised image-to-
image translation networks. In Advances in Neural Informa-
tion Processing Systems (NIPS), 2017.

[22] M.-Y. Liu and O. Tuzel. Coupled generative adversarial net-
works. In Advances in Neural Information Processing Sys-
tems (NIPS), 2016.

[23] X. Mao, Q. Li, H. Xie, R. Y. Lau, Z. Wang, and S. P. Smolley.
Least squares generative adversarial networks. IEEE Inter-
national Conference on Computer Vision (ICCV), 2017.
[24] M. Mathieu, C. Couprie, and Y. LeCun. Deep multi-scale
video prediction beyond mean square error. In International
Conference on Learning Representations (ICLR), 2016.
[25] A. Odena, C. Olah, and J. Shlens. Conditional image synthe-
sis with auxiliary classiﬁer gans. In International Conference
on Machine Learning (ICML), 2017.

[26] J. Oh, X. Guo, H. Lee, R. L. Lewis, and S. Singh. Action-
conditional video prediction using deep networks in atari
games. In Advances in Neural Information Processing Sys-
tems (NIPS), 2015.

[27] A. Radford, L. Metz, and S. Chintala. Unsupervised rep-
resentation learning with deep convolutional generative ad-
versarial networks. In International Conference on Learning
Representations (ICLR), 2016.

[28] D. J. Rezende, S. Mohamed, and D. Wierstra. Stochas-
tic backpropagation and variational inference in deep latent
gaussian models. In International Conference on Machine
Learning (ICML), 2014.

[29] K. Roth, A. Lucchi, S. Nowozin, and T. Hofmann. Stabiliz-
ing training of generative adversarial networks through reg-
ularization. In Advances in Neural Information Processing
Systems (NIPS), 2017.

[30] M. Saito, E. Matsumoto, and S. Saito. Temporal generative
adversarial nets with singular value clipping. In IEEE Inter-
national Conference on Computer Vision (ICCV), 2017.
[31] T. Salimans, I. Goodfellow, W. Zaremba, V. Cheung, A. Rad-
ford, and X. Chen. Improved techniques for training gans. In
Advances in Neural Information Processing Systems (NIPS),
2016.

[32] K. Soomro, A. R. Zamir, and M. Shah. Ucf101: A dataset
of 101 human actions classes from videos in the wild. arXiv
preprint arXiv:1212.0402, 2012.

[33] N. Srivastava, E. Mansimov, and R. Salakhutdinov. Unsuper-
vised learning of video representations using lstms. In Inter-
national Conference on Machine Learning (ICML), 2015.

[34] M. Szummer and R. W. Picard. Temporal texture modeling.
In International Conference on Image Processing (ICIP),
1996.

[35] L. Theis, A. v. d. Oord, and M. Bethge. A note on the eval-
uation of generative models. In International Conference on
Learning Representations (ICLR), 2016.

9

[36] S. Tulyakov, A. Fitzgibbon, and S. Nowozin. Hybrid vae:
Improving deep generative models using partial observa-
tions. Advances in Neural Information Processing Systems
(NIPS) Workshop, 2017.

[37] J. van Amersfoort, A. Kannan, M. Ranzato, A. Szlam,
D. Tran, and S. Chintala. Transformation-based models of
video sequences. arXiv preprint arXiv:1701.08435, 2017.

[38] A. van den Oord, N. Kalchbrenner, L. Espeholt, O. Vinyals,
A. Graves, et al. Conditional image generation with pixel-
cnn decoders. In Advances in Neural Information Processing
Systems (NIPS), 2016.

[39] R. Villegas, J. Yang, S. Hong, X. Lin, and H. Lee. Decom-
posing motion and content for natural video sequence pre-
diction. In International Conference on Learning Represen-
tations (ICLR), 2017.

[40] C. Vondrick, H. Pirsiavash, and A. Torralba. Generating
videos with scene dynamics. In Advances in Neural Infor-
mation Processing Systems (NIPS), 2016.

[41] L.-Y. Wei and M. Levoy. Fast texture synthesis using tree-

structured vector quantization. In ACM SIGGRAPH, 2000.

[42] T. Xue, J. Wu, K. Bouman, and B. Freeman. Probabilistic
modeling of future frames from a single image. In Advances
in Neural Information Processing Systems (NIPS), 2016.
[43] H. Zhang, T. Xu, H. Li, S. Zhang, X. Huang, X. Wang, and
D. Metaxas. Stackgan: Text to photo-realistic image synthe-
sis with stacked generative adversarial networks. IEEE In-
ternational Conference on Computer Vision (ICCV), 2016.

10

0

1

2

3

4

0

1

2

3

0

1

2

3

A. Network Architecture

Table 6: Network architectures of the image generative net-
work GI, the image discriminative network DI, and the
video generative network DV used in the experiments.

Conﬁguration

GI

Input

[za ∼ N (0, I), zm ∼ RM]
DCONV-(N512, K6, S0, P0), BN, LeakyReLU

DCONV-(N256, K4, S2, P1), BN, LeakyReLU

DCONV-(N128, K4, S2, P1), BN, LeakyReLU

DCONV-(N64, K4, S2, P1), BN, LeakyReLU

DCONV-(N3, K4, S2, P1), BN, LeakyReLU

DI

Conﬁguration

Input

height × width × 3

CONV-(N64, K4, S2, P1), BN, LeakyReLU

CONV-(N128, K4, S2, P1), BN, LeakyReLU

CONV-(N256, K4, S2, P1), BN, LeakyReLU

CONV-(N1, K4, S2, P1), Sigmoid

DV

Conﬁguration

Input

16 × height × width × 3

CONV3D-(N64, K4, S1, P0), BN, LeakyReLU

CONV3D-(N128, K4, S1, P0), BN, LeakyReLU

CONV3D-(N256, K4, S1, P0), BN, LeakyReLU

CONV3D-(N1, K4, S1, P0), Sigmoid

Table 6 detailed the network architecture used in the
main paper. We used several different type of layers. A
convolutional layer with N output channels, kernel size K,
stride S, and padding P is denoted in the table as CONV-
(N , K, S, P ) and similarly for 3D convolutional layers
CONV3D-(N , K, S, P ). Kernel size, padding, and stride
are equal for all the dimensions in each layer. Batch normal-
ization layers are followed by the LeakyReLU nonlinearity
in our case. The RM consisted of a single GRU module.

B. Additional Qualitative Results

Figures 7 and 8 show categorical facial expression and
categorical human actions video generation results, respec-
tively. In each ﬁgure, every group of three rows was gener-
ated with a ﬁxed content vector zC, but random action vec-
tor zA and motion vectors z(t)
M ’s. We found that the identity
was kept ﬁxed throughout a video. We noted that the length
of the generated videos were longer than those in the train-
ing data. This showed that the MoCoGAN can generalize
the video generation along the time dimension.

11

Figure 7: Facial expression video generation results. Every three rows have the same identity but different zA.

12

Figure 8: Human action video generation results. Every three rows have the same identity but different zA.

13

