7
1
0
2
 
t
c
O
 
9
 
 
]

O
R
.
s
c
[
 
 
1
v
9
2
0
3
0
.
0
1
7
1
:
v
i
X
r
a

SGD for robot motion? The effectiveness of stochastic optimization on a
new benchmark for biped locomotion tasks

Martim Brand˜ao, Kenji Hashimoto and Atsuo Takanishi

Abstract— Trajectory optimization and posture generation
are hard problems in robot locomotion, which can be non-
convex and have multiple local optima. Progress on these
problems is further hindered by a lack of open benchmarks,
since comparisons of different solutions are difﬁcult to make.
In this paper we introduce a new benchmark for trajectory
optimization and posture generation of legged robots, using a
pre-deﬁned scenario, robot and constraints, as well as evalua-
tion criteria. We evaluate state-of-the-art trajectory optimiza-
tion algorithms based on sequential quadratic programming
(SQP) on the benchmark, as well as new stochastic and
incremental optimization methods borrowed from the large-
scale machine learning literature. Interestingly we show that
some of these stochastic and incremental methods, which are
based on stochastic gradient descent (SGD), achieve higher
success rates than SQP on tough initializations. Inspired by this
observation we also propose a new incremental variant of SQP
which updates only a random subset of the costs and constraints
at each iteration. The algorithm is the best performing in both
success rate and convergence speed, improving over SQP by up
to 30% in both criteria.

The benchmark’s resources and a solution evaluation script

are made openly available.

I. INTRODUCTION

Optimization of robot postures and trajectories is an im-
portant problem in robotics, with applications to efﬁcient
robot locomotion and manipulation. The problem is hard
because posture and trajectory optimization problems are
often non-convex and have several local optima, especially
in the presence of collision constraints. For example when a
robot model is in collision, the collision gradient might pull
different links in different directions - and the optimization
get stuck at an infeasible local optima [1]. While several
algorithms have been proposed for posture generation and
trajectory optimization [2], [3], [1], [4], [5], [6], [7], com-
paring them is also difﬁcult since each researcher opts for
a different evaluation scenario which was chosen by chance
or to showcase the advantages of the algorithm.

This paper is a step towards solving these two issues: 1)
of the lack of a benchmark, and 2) of avoiding infeasible
local optima. The contributions of the paper are as follows.

*This work was supported by ImPACT TRC Program of Council for
Science, Technology and Innovation (Cabinet Ofﬁce, Government of Japan).
M. Brand˜ao is with the Research Institute for Science and Engineering,
Waseda University: #41-304, 17 Kikui-cho, Shinjuku-ku, Tokyo 162-0044,
JAPAN.

K. Hashimoto is with the Waseda Institute for Advanced Study, and is a

researcher at the Humanoid Robotics Institute (HRI).

A. Takanishi is with the Department of Modern Mechanical Engineering,
Waseda University; and the director of the Humanoid Robotics Institute
(HRI), Waseda University.

• We develop a new robotics challenge, open to the pub-
lic, which consists of a set of problems for benchmark-
ing static posture and trajectory optimization algorithms
on a legged humanoid robot

• We evaluate different optimization algorithms at solving

the problems

• We show that new stochastic optimization algorithms
developed for the (highly non-convex) training of deep
neural networks also lead to high success rates in
posture/trajectory optimization with tough collision con-
straints and initializations. To the best of our knowledge
this is the ﬁrst time these methods are applied to posture
generation and trajectory optimization.

• We propose a stochastic incremental variant of Sequen-
tial Quadratic Programming for trajectory optimization
based on the principles of recent large-scale non-convex
optimization methods. We show it
leads to higher
success rates and speed than SQP on ill-initialized
trajectory optimization problems.

II. RELATED WORK

Robot motion planning has been tackled with search,
sampling and optimization methods. Recently, optimization
algorithms have gained popularity, due to the existence of
fast general-purpose software and the possibility to easily
integrate many different constraints in the problem. One of
the state-of-the-art algorithms is sequential quadratic pro-
gramming, which is used by SNOPT [8] for general-purpose
optimization, but also by trajectory-optimization libraries [1],
and trajectory optimization research on legged robots [3].
Projected conjugate-gradient methods such as CHOMP [4]
have also been proposed for the problem. The gradient-
descent methods we evaluate in this paper are related to
CHOMP in the sense that they also do (pre-conditioned)
gradient descent. However, as in [1] we use penalties for
constraints, thus being able to consider general non-linear
constraints on robot postures or motion.

In this paper we explore the use of stochastic methods
for posture generation and trajectory optimization. The mo-
tivation behind it is to improve success rates by successfully
avoiding local minima through random perturbations. The
idea has also been explored in stochastic variants of CHOMP
[5] which increased success rates. Here we instead make
use of progress in the stochastic optimization literature,
which has recently gained attention in part because of the
problem of local minima, saddle points and non-convexities
which pervade deep neural network training landscapes. The
large-scale optimization and deep learning communities have

recently come up with different algorithms to deal with these
optimization landscapes, such as variants of stochastic gra-
dient descent with pre-conditioning [9], incremental gradient
descent methods [10], noise injection [11] and others. Some
of these algorithms have provable convergence guarantees
[10] and saddle-escaping guarantees [12]. Our assumption
in this paper is that these methods and insights which work
on the highly-nonconvex optimization landscapes of neural
networks will transfer to the (also non-convex) landscapes of
legged robot posture generation and trajectory optimization.
Results of state-of-the-art robot motion planning algo-
rithms are impressive [3], [2], [13], but it is arguably dif-
ﬁcult to compare each planner’s performance, advantages
and disadvantages. This is partly because each algorithm
is evaluated on a different environment, or using different
cost functions, constraints or robot models. For results to
be comparable and veriﬁable, the evaluation criteria must
be the same and largely sampled, while all
inputs (i.e.
scenario, robot, constraints) must be available. Recently,
veriﬁability and comparability have been strongly pursued in
ﬁelds such as computer vision through an investment in open
benchmarks [14], [15] and open source - which has arguably
been a strong factor in fostering research progress. This
paper tries to follow this trend and make public a benchmark
with pre-deﬁned robot, environment, costs, constraints and
evaluation criteria.

III. THE LEGOPT BENCHMARK

A. The environment

The LegOpt Benchmark (Legged-robot posture and tra-
jectory Optimization Benchmark), which we propose in this
paper, is based on the “Destruction Scenario Dataset” (DSD)1
[16]. DSD is a set of challenging 3D scenarios intended
for testing robot search and rescue missions. They were
created in Blender using simple shape primitives, unions and
differences, followed by shattering and collapsing by running
a physics simulation. The scenarios also include 3D models
of cars and people for realism. Snapshots of the ﬁrst frames
were taken as different “difﬁculty levels” of the scenarios
according to an empirical measure of difﬁculty of traversing
the terrain. Models and code to generate them are openly
available2.

The current version of the LegOpt Benchmark is built
on top of
the easiest difﬁculty garage scenario (i.e.
“garage easier”). We show an image of the scenario in Figure
1. This scenario is already challenging enough for current
motion planning and optimization algorithms.

B. Task deﬁnitions

The LegOpt Benchmark consists of two tasks: posture
generation and trajectory optimization. Each task is evaluated
in 50 different problem instances (i.e. different regions of the
scenario). Each posture generation problem is speciﬁed by a
single stance with given 6D poses for the robot’s feet. Each

1The ﬁrst author of this paper collaborated with µRoboptics, Inc. on the

development of the Destruction Scenarios Dataset.

Fig. 1. The “garage easier” scenario: a damaged garage scenario of the
Destruction Scenarios Dataset, used as the environment of our benchmark.

trajectory optimization problem is speciﬁed by a sequence
of stances with given feet poses.

Both tasks use Atlas as the robot model and DSD’s
“garage easier” scenario as the environment. The following
constraints need to be satisﬁed for both tasks:

• Given feet positions and orientations must be respected,
• The center-of-mass (COM) of the robot should lie inside
the support polygon, given by a 2D convex hull of the
horizontal projection of the feet in contact,

• The robot model should not collide with itself or the

environment,

• Robot joint angle limits should be respected.

Each of these constraints is to be enforced with tolerance
10−3 (meters for distances, radians for angles). We compute
collision as the penetration distance in meters, as imple-
mented in the OpenRAVE library [17] using ODE [18]
for collision computations3. We provide an evaluation script
which computes the costs and constraint violations of JSON-
formatted solutions on a website4. We also provide JSON
ﬁles describing the feet poses of each problem instance.

We evaluate an algorithm’s performance at the tasks using
the following criteria: 1) Success rate, i.e. number of problem
instances solved to tolerance; 2) Cost; and 3) Computation
time. The cost function is different for the two tasks.

1) Posture generation: The posture generation task is to
obtain a single full-body conﬁguration q∗ that respects given
feet poses, static stability, no-collision, joint limits, and leads
to the minimum (squared) static torques possible. Basically,
the task is to solve

q∗ =argmin

q

s.t.

τ 2
k (q)

K
(cid:80)
k=1
footi(q) = bi ∀i
COM(q) ∈ Psupport
sd(q) ≥ 0
qmin ≤ q ≤ qmax.

(1)

(2)

(3)

(4)

(5)

3We ignore collisions between the pelvis and upper-torso, since their
convex hulls are always in collision and most collision checkers make use
of convex hulls.

2https://github.com/roboptics/destruction_scenarios

4https://github.com/martimbrandao/legopt-benchmark

where K is the number of the robot’s joints, bi are the
problem’s given feet poses, Psupport is the convex support
polygon, sd(q) represents a signed-distance function between
the robot, itself and the environment.

IV. BENCHMARKED ALGORITHMS

Posture generation and motion planning can be formulated

as optimization problems of the form

2) Trajectory optimization: The trajectory optimization
task is to obtain a sequence of full-body conﬁgurations x∗ =
q∗
1, ..., q∗
T (two conﬁgurations per stance) which respects
given feet poses, static stability, no-collision, joint limits,
and leads to the minimum (squared) joint velocity possible.
Basically, the task is to solve

1, ..., q∗
q∗

T =argmin
q1,...,qT
s.t.

||qt+1 − qt||2

T −1
(cid:80)
t=1
footi,t(qt) = bi,t ∀i, t
COMt(q) ∈ Psupportt
sd(qt) ≥ 0 ∀t
qmin ≤ qt ≤ qmax ∀t.

∀t

(6)

(7)

(8)

(9)

(10)

C. Generation of problem instances

For completeness we will now describe the procedure we
used to arrive at the deﬁnition of all problem instances.
We ﬁrst sampled points uniformly from the scenario’s mesh
triangles to obtain positions for a left foot, then we uni-
formly sampled yaw orientations, which together with the
mesh’s normal vector make an orientation constraint. We
then searched for a right foot position and orientation in
the same way, in a radius around the left foot. We checked
for feasibility and collision of the stance using TrajOpt. This
was done until we had 100 stances scattered throughout the
scenario. We then selected random pairs of stances (50 pairs
on the same ﬂoor, 50 on different ﬂoors), and ran an ARA*-
based [19] footstep planner [20] to obtain a sequence of
stances which connects the pair. The sequence of stances
from the ﬁrst 25 successful same-ﬂoor footstep plans, and
the ﬁrst 25 successful different-ﬂoor footstep plans were
selected as the problem instances for trajectory optimization.
Regarding posture generation, we used K-means clustering
to pick 50 stances out of the set of all stances in all footstep
plans (using stance length, stance height and trunk collision
distance as features).

We show the distribution of problem deﬁnition features in
Figure 2 and 3. The collision distance feature is computed by
a signed-distance function between the trunk (approximated
by a box) and the environment. Notice that many postures
in both tasks are close to collision, and some will actually
be in collision depending on the initialization - since only
the trunk and not the arms were checked for collision while
building the problem deﬁnitions.

min
x∈Rd
s.t.

nf(cid:80)

fi(x)

i=1
gi(x) ≤ 0, i = 1, 2, ..., ng
hi(x) = 0, i = 1, 2, ..., nh
linear constraints,

(11a)

(11b)

(11c)

(11d)

where x are the full-body postures of the robot at one or
more instants of time (i.e. d = D ×T where D is the number
of the degrees of freedom of the robot and T the number
of instants of time a.k.a. waypoints). Each fi, gi, hi is a
function which describes part of the costs or constraints on
the robot, for example a full-body posture cost or a link pose
constraint at a certain waypoint. In this paper we turn (11)
into a sequence of problems of the form

min
x∈Rd

nf(cid:80)

i=1

ng(cid:80)

i=1

fi(x) + µ

pg(gi(x)) + µ

ph(hi(x))

nh(cid:80)
i=1

(12a)

(12b)

s.t.

x ∈ C (convex linear constraints),

which are solved with successively higher µ until all
constraints are satisﬁed (or progress is no longer possible).
The functions pg(.) and ph(.) are called penalty functions
and measure constraint violation. We use pg(.) = max(0, .)
and ph(.) = |.|, which are exact - meaning that they can lead
to the exact solution to the original problem (11) for certain
choices of µ [21].

A. Sequential quadratic programming (SQP)

One of the state-of-the-art methods for solving (11) is Tra-
jOpt [1]. The method uses sequential quadratic programming,
by alternating between

1) building convexiﬁcations ˜fi, ˜gi, ˜hi, where ˜fi are

quadratic and ˜gi, ˜hi are linear

2) solving (12) with the convexiﬁed ˜fi, ˜gi, ˜hi instead of
the original fi, gi, hi functions using a trust-region
method (i.e. constraining x at each iteration to be
within a narrow range where convexiﬁcation is valid).
TrajOpt also uses pg(.) = max(0, .) and ph(.) = |.|

An implementation of this algorithm is openly available5 and
achieves both a high success rate and computation speed
when compared to other recent optimization-based planners
[4] and sampling-based planners.

B. Gradient descent

A simpler way to solve (12) is to use gradient descent. For
convenience, let us simplify the notation of the optimization
problem (12) as

min
x∈C

n
(cid:80)
i=1

Fi(x),

(13)

5http://rll.berkeley.edu/trajopt/

Fig. 2. Statistics of the posture generation task: histograms of stance deﬁnitions and collision distances on all 50 problems.

Fig. 3. Statistics of the trajectory optimization task: histograms of stance deﬁnitions and collision distances on all 50 problems.

where n = nf + ng + nh, and where the terms Fi(x) gather
all cost functions and penalties in (12a):

Fi(x) =






1 ≤ i ≤ nf
fi(x),
pg(gi−nf (x)),
nf < i ≤ nf + ng
ph(hi−nf −ng (x)), nf + ng < i ≤ n.

(14)

Gradient descent solves (13) by iterating

(cid:32)

(cid:33)(cid:33)

xk+1 = πC

xk − αk

∇Fi(xk)

,

(15)

(cid:32) n
(cid:88)

i=1

where πC projects points onto the feasible space C, and αk
is called the step length. The step length is usually ﬁxed
or computed through line search [21]. The iterations are
repeated until some termination criteria is met, usually a
threshold on gradient norm or function improvement. Notice
that the gradient of max(0, y) and |y| is not deﬁned at y = 0,
and so computing (15) with these penalty functions is not
straightforward. In this paper we use smooth approximators6
for the penalty functions such that:
(cid:18)

(cid:19)(cid:19)

(cid:18) ewhi(x)

∇˜ph(hi(x)) =

−1 + 2

∇hi(x)

(16a)

∇˜pg(gi(x)) =

(16b)

1 + ewhi(x)

(cid:40)

0,
gi(x) ≤ 0
∇˜ph(gi(x)), otherwise.

Note that as w → ∞, (16a) tends to −∇hi(x) for hi(x) < 0
and tends to ∇hi(x) for hi(x) > 0, thus approximating the
gradient of the exact penalty |hi(x)|; and similarly (16b) also
approximates the gradient of max(0, gi(x)).

C. Popular algorithms in large-scale optimization and deep
learning

1) Stochastic gradient descent: Stochastic gradient de-
scent (SGD) is gradient descent where the gradients are
noisy. In this situation an estimator ˜∇F (xk) is used that is
equal to the real gradient in expectation, i.e. E[ ˜∇F (xk)] =
∇F (xk). A common choice for this estimator is the use of

6Another option is to use slack variables [21] as done in TrajOpt [1]. We

chose to use smooth approximators as it made debugging more intuitive.

mini-batches, which basically evaluates the gradient at only
a subset of the functions at each iteration. So the sum over
Fi is made not for i = 1, ..., n, but only for a subset Fk
of those indices chosen randomly at iteration k. An SGD
iteration to solve (13) then consists of

(cid:32)

(cid:33)(cid:33)

xk+1 = πC

xk − αk

∇Fi(xk)

.

(17)

(cid:32)

(cid:88)

i∈Fk

The size of a mini-batch (|Fk|≤ n) is usually called “sample-
size”, and for |Fk|= n SGD reduces to full deterministic
gradient descent (15). SGD has low complexity (i.e. low total
number of gradient evaluations) and provable convergence
in probability even on non-convex functions [22], while its
noise actually helps avoid sharp local minima [23]. Due to
these advantages the method has inspired the development
of a number of different variants, which try to deal with
important disadvantages such as slow convergence and hard-
to-tune step lengths.

2) Adam: In this paper we will consider one of those
variants which has become widely popular in the deep
learning community: Adam [9]. Adam basically does SGD
where the step length is adapted to each dimension of x,
similarly in purpose to conjugate gradient descent. In a
nutshell, Adam iterates:

(cid:18)

xk+1 = πC

xk − αk

ˆmk√

ˆvk + (cid:15)

(cid:19)

,

(18)

where the division is element-wise, and ˆmk, ˆvk are un-
biased running averages of the ﬁrst and second moments
of ˜∇F (xk), accumulated at each iteration the following way

ˆmk =mk/(1 − βk
1 )
ˆvk =vt/(1 − βk
2 )
mk =β1mk−1 + (1 − β1)gk
vk =β2vk−1 + (1 − β2)g2
k
gk =

∇Fi(xk).

(cid:88)

i∈Fk

(19a)

(19b)

(19c)

(19d)

(19e)

The constants β1 and β2 are parameters. We refer the
interested reader to the original publication for details.

3) Nadam: We also consider an accelerated version of
Adam, Nadam [24], which uses Nesterov momentum in an
attempt to increase convergence rate. The algorithm uses a
slightly different deﬁnition for ˆmk,

ˆm(Nadam)
k

= β1mk/(1 − βk+1

) + (1 − β1)gk/(1 − βk

1 ). (20)

1

4) Incremental SGD (a.k.a. stochastic average gradient):
Stochastic average gradient, proposed in [10], is an incre-
mental variant of SGD. The gradients of all functions are
used at each iteration, but only a subset of them is actually
computed: the rest are kept unchanged from the previous
iteration. The method has faster convergence properties in
convex functions than SGD, at the cost of increased memory
usage. It iterates

(cid:32)

xk+1 = πC

xk − αk

(cid:32) n
(cid:88)

(cid:33)(cid:33)

yk
i

,

i=1

where

(cid:40)

yk
i =

∇Fi(xk),
yk−1
,
i

i ∈ Fk
otherwise.

(22)

As before, the set Fk is chosen randomly at each iteration.
In the experimental section we will also consider in-
cremental versions of Adam and Nadam (i.e. by keeping
previous gradients in memory). For a shared and readable
naming, we will refer to all these variants by the preﬁx ”I-”,
for incremental: I-SGD, I-Adam, I-Nadam.7

D. A new, incremental SQP (I-SQP)

In the spirit of I-SGD, we propose to use an incremental
version of SQP. The motivation is to observe that a large
part of the computational time of SQP goes into building
convexiﬁcations (i.e. basically taking the gradients of fi, gi,
hi), and so convergence rate can hypothetically be increased
by re-using them from previous iterations - as long as the
convexiﬁcations remain valid within tolerance. Another pos-
sible motivation is that noise arising from re-using previous
convexiﬁcations may help avoid infeasible stationary points,
as happens with SGD.

We show the pseudo-code for I-SQP in the following
Algorithm 1. It is basically TrajOpt [1] with incremental
convexiﬁcations of costs and penalties.

V. RESULTS

A. Experimental setup and implementation

Performance of each optimization method varies greatly
with the choice of initialization, especially in the presence
of non-convex constraints such as obstacle avoidance. Opti-
mizer behavior close and far from collision may also vary
greatly, and therefore be informative of the advantages and
disadvantages of each method. Because of this, in this paper
we obtain results for two different initializations:

7Note that I-SGD and stochastic average gradient refer to the same

method in this paper.

Algorithm 1 I-SQP

input: x; tolerance, penalty and trust region parameters
for PenaltyIteration µ ← µ1, µ2, ... do

for ConvexifyIteration k ← 1, 2, ... do

if k = 1 then

˜F k

else

i ← Convexify(Fi) ∀i = 1, ..., n

Fk ← SampleMiniBatch()
˜F k
i ← Convexify(Fi), ∀i ∈ Fk
i ← ˜F k−1
˜F k
, ∀i /∈ Fk
end if
Using a trust-region algorithm, solve:
˜F k

x ← argmin

i

i (x)

n
(cid:80)
i=1

x∈C

if constraints satisﬁed to tolerance then

break

end if
end for

(21)

end for

1) “Good” initialization: the robot’s base is placed such
that its feet are above their target pose (hence not in
collision with the ground). In particular, the optimiza-
tion will start from q such that the feet soles’ height
will be equal to the maximum target foot sole height
plus a margin of 0.20 meters. The joints are always
set to a nominal posture (knees bent 50 degrees), and
the base’s XY position is set to the center of the active
contacts.

2) Initialization “in-collision”: the robot’s base is placed
such that its feet are in collision with the ground. In
particular, the optimization will start from q such that
the feet soles’ height will be equal to the minimum
target foot sole height minus a margin of 0.05 meters.
The joints are always set to a nominal posture (knees
bent 50 degrees), and the base’s XY position is set to
the center of the active contacts.

As is common in optimization methods for robotics, we
use “multi-starts” (a.k.a. restarts) to deal with optimization
failure. This means that in case the optimization does not
converge from a certain initialization, we restart it from
scratch using a slightly perturbed initial condition. In our
experiments we restart the optimization up to 10 times, and
each time perturb all joint angles using a uniform distribution
in the interval of [−5, 5] degrees. We also report results
without using multi-starts, although they have expectedly
lower success rates.

We solved all problems with full, stochastic and incremen-
tal gradients, with sample sizes 20, 40, ..., 100% of n. On
average we obtained best-performing results using 80%n for
stochastic methods, 40%n for incremental gradient methods
and 80%n for I-SQP. For brevity we report results using these
sample sizes only. Method SQP with 80%n is equivalent to
I-SQP but without memory (i.e. not incremental). Although
we do not expect
the algorithm to score high, because
each QP will be very different from the next as certain

constraints are removed, we still include it in the comparison
for thoroughness.

We used cost and constraint

implementations directly
from the TrajOpt library [1]. Although it is not part of the
trajectory optimization task’s requirements, we also included
a continuous collision constraint between waypoints to obtain
trajectories that are closer to interpolation-feasible.

Due to the large number of variables on the trajectory
optimization task, we solve each trajectory optimization
problem as a sequence of optimization problems which
consider only 6 stances (12 waypoints), with an overlap of
1 stance that is re-planned. The ﬁrst of those waypoints is
ﬁxed (planned in the previous window).

We implemented all optimization methods in C++ as
extensions to the TrajOpt library. The same implementation
for the costs, constraints and respective gradient computa-
tions is used for all optimization methods - thus making
success rates and computation times directly comparable.
The only exception is the implementation of penalty function
gradients, which in the case of SQP and I-SQP uses slack
variables, while other methods use (16).

We compute the step-size of each step in gradient-based
methods through line-search, using a zoom function and
Wolfe’s conditions (c1 = 10−4, c2 = 0.9), as in [21]. For
Adam and Nadam we use standard parameters β1 = 0.9
and β2 = 0.999. The termination criteria is as in [1]
for SQP methods, and is based on proportional-decrease
monitoring for gradient descent methods (i.e. terminate after
10 epochs without improvement in the objective function).
Problems are solved successively with penalty coefﬁcients
µ = 102, 103, ..., 1012. We use Bullet for mesh-collision, and
solve QPs and feasible-space projections πC using Gurobi.

B. Algorithm comparison

We show all results for both tasks condensed in Table
I. As expected, the use of multi-starts greatly improves
performance on all methods and conditions. In general,
success rates are higher for the posture generation than the
trajectory optimization task. This is understandable because
trajectory problems consist of hundreds of postures (see
Figure 3), while posture generation problems consist of
only one. Success is also higher for the “good-initialization”
condition compared to the “in-collision” condition, which
proves the difﬁculty of optimization methods in dealing with
collision constraints. Most of the failures in this condition
consist of the optimization method getting stuck at an
infeasible stationary point where no progress is made in any
degree of freedom (i.e. collision’s signed distance gradient
is inconsistent between links or cancels out the gradient of
other constraints). We show an example of such a case in
Figure 5.

Stochastic and incremental gradient-descent methods, as
well as our I-SQP, consistently lead to higher success rates
than their full-gradient counterparts. SQP and I-SQP have
the lowest computation times, of 1 second per waypoint on
average. In fact, I-SQP is 20 to 30% faster than SQP on
average. Gradient-descent variants are slower. I-Adam takes

1 to 3 seconds per waypoint on average, while the Nesterov-
accelerated I-Nadam is around 15% faster on average. When
it succeeds in ﬁnding a solution, SQP consistently obtains
the lowest-cost postures and trajectories, which we assume
to be due to the nonexistence of noise as well as an efﬁcient
use of second order information and conditioning employed
by the QP solver (Gurobi). The best performing method in
both success rate and computation speed is always I-SQP. Its
cost values are similar but slightly higher than SQP.

For the posture generation task, on average all 50 problems
are successfully solved by all methods. Computation speed
is understandably faster for SQP and I-SQP. This is because
they use second-order information and only recompute gra-
dients after convergence of each QP, while gradient methods
recompute gradients after each step (i.e. after each line
search). In their stochastic and incremental versions, both
SGD- and SQP-based methods decrease computation time
on average, some methods obtaining up to 50% speedups
(I-Adam).

The most common reason for algorithm failure is due
to collision constraints, an example of which is shown in
Figure 6. In this situation, SQP fails and requires several
random restarts until it ﬁnds a feasible solution. I-SQP and all
stochastic and incremental gradient methods succeed at ﬁrst
try. The reason is that SQP gets stuck on an infeasible local
minimum when a foot is in collision, while noisy gradients
in the incremental/stochastic methods help move the robot
out of collision (i.e. out of the local minimum).

For the trajectory optimization task, I-SQP is the best
performing in both the well-initialized and in-collision con-
ditions, solving 42 and 38 problems respectively. I-SQP con-
siderably improves the success rate with respect to traditional
SQP when initialized in-collision (38 vs 29 successes). I-
Adam performs similarly, although slightly worse than SQP
on well-initialized problems (40 vs 42). However, I-Adam
is better than traditional SQP when started in-collision (34
vs 29). In fact, all stochastic and incremental gradient-based
methods outperform traditional SQP in-collision, except for
I-Nadam.

Figure 4 shows a sequence of waypoints from a trajectory
optimization problem where SQP fails, but I-SQP succeeds,
and Adam (sample-size 80%) also succeeds. SQP gets stuck
on a local minimum where the left arm is in collision with
a wall. However, I-SQP successfully ﬁnds a posture which
brings the arm out of collision, and Adam does so with a
simpler posture closer to its nominal value (i.e. straight body
with bent knees).

VI. CONCLUSIONS

In this paper we introduced a new challenge - LegOpt -
for benchmarking different algorithms at the tasks of legged
robot posture generation and trajectory optimization. LegOpt
is open to public and deﬁnes a robot model, scenario, con-
straints and cost functions. Evaluation scripts are also made
public for ease of use. LegOpt will hopefully help the legged
and humanoid robotics communities to better compare the

TABLE I
ALGORITHM COMPARISON ON THE POSTURE AND MOTION TASKS

Method Multi
starts

Sample
size

Success
rate

Time
(s)

Success
rate

Cost

Time
(s)

Success
rate

Time
(s)

Success
rate

Posture generation

Init-in-collision

Trajectory optimization

Init-in-collision

Good-init

Cost

SQP
SGD
Adam
Nadam

SQP
SGD
Adam
Nadam

SQP
SGD
Adam
Nadam

I-SQP
I-SGD
I-Adam
I-Nadam

0
0
0
0

10
10
10
10

10
10
10
10

10
10
10
10

100
100
100
100

100
100
100
100

80
80
80
80

80
40
40
40

49/50
44/50
42/50
39/50

50/50
49/50
49/50
49/50

16/50
50/50
50/50
50/50

50/50
49/50
50/50
50/50

427
720
606
590

427
798
643
642

298
788
629
620

461
833
661
667

1.32
3.76
4.15
2.83

1.44
6.30
5.97
5.67

2.74
5.82
4.18
2.90

1.00
4.13
3.27
2.66

43/50
41/50
46/50
48/50

50/50
48/50
50/50
50/50

20/50
49/50
50/50
50/50

50/50
49/50
50/50
50/50

416
770
616
645

429
783
672
679

279
775
642
638

468
810
668
684

1.43
3.55
3.78
2.33

1.74
5.11
4.30
3.20

4.00
4.44
3.91
2.70

1.34
5.17
3.66
3.44

Good-init

Cost

19/50
4 /50
18/50
16/50

42/50
27/50
31/50
35/50

0 /50
26/50
35/50
33/50

42/50
30/50
40/50
41/50

0.13
0.20
0.14
0.14

0.13
0.17
0.14
0.15

0.00
0.16
0.14
0.14

0.13
0.15
0.14
0.15

0.63
1.38
1.22
0.81

0.62
2.17
1.50
1.19

0.00
1.99
2.05
1.10

0.53
1.30
1.07
0.73

Cost

0.12
0.18
0.14
0.11

0.12
0.16
0.15
0.15

0.00
0.16
0.15
0.14

0.14
0.15
0.15
0.14

Time
(s)

0.67
1.26
1.27
0.92

0.84
3.04
2.10
1.96

0.00
2.49
2.12
1.47

0.71
1.40
1.34
1.64

11/50
2 /50
2 /50
1 /50

29/50
29/50
32/50
30/50

0 /50
30/50
36/50
34/50

38/50
30/50
34/50
28/50

Note: Costs and times are averaged over successfully solved problems.

Fig. 4. A sequence of waypoints from a trajectory optimization problem. The sequence runs from left to right. Each row corresponds to a different
method. From top to bottom: SQP, I-SQP, Adam (80% batch size).

advantages and disadvantages of planning algorithms on
common problems.

We evaluated not only state-of-the-art algorithms based
on sequential convex optimization (SQPs), but also recent
stochastic and incremental algorithms introduced for large-
scale optimization in general and deep learning in particular.
The assumption was that their robustness to local minima
and saddle points would transfer to the optimization land-
scapes of robot optimization tasks as well. The experimental
results showed that stochastic and incremental methods are

indeed effective in the LegOpt Benchmark, especially on the
presence of complex obstacle geometries or on initializations
that are in collision. In particular, stochastic and incremental
variants of SGD and Adam surpassed SQP when initialized
in-collision. Inspired by these algorithms we proposed an in-
cremental version of SQP for optimizing robot motion, which
updates only a random subset of the costs and constraints
at each iteration. The algorithm obtained the highest success
rates on tough initializations, and was consistently faster than
traditional SQP.

[2] S. Kuindersma, R. Deits, M. Fallon, A. Valenzuela, H. Dai, F. Per-
menter, T. Koolen, P. Marion, and R. Tedrake, “Optimization-based
locomotion planning, estimation, and control design for the atlas
humanoid robot,” Autonomous Robots, vol. 40, no. 3, pp. 429–455,
2016.

[3] M. Posa, C. Cantu, and R. Tedrake, “A direct method for trajectory
optimization of rigid bodies through contact,” Int. J. Rob. Res., vol. 33,
no. 1, pp. 69–81, Jan. 2014.

[4] M. Zucker, N. Ratliff, A. D. Dragan, M. Pivtoraiko, M. Klingensmith,
C. M. Dellin, J. A. Bagnell, and S. S. Srinivasa, “Chomp: Covariant
hamiltonian optimization for motion planning,” The International
Journal of Robotics Research, vol. 32, no. 9-10, pp. 1164–1193, 2013.
[5] M. Kalakrishnan, S. Chitta, E. Theodorou, P. Pastor, and S. Schaal,
“Stomp: Stochastic trajectory optimization for motion planning,” in
2011 IEEE International Conference on Robotics and Automation,
May 2011, pp. 4569–4574.

[6] S. Lengagne, J. Vaillant, E. Yoshida, and A. Kheddar, “Generation
of whole-body optimal dynamic multi-contact motions,” The Interna-
tional Journal of Robotics Research, vol. 32, no. 9-10, pp. 1104–1119,
2013.

[7] A. Escande, S. Brossette, and A. Kheddar, “Parametrization of catmull-
clark subdivision surfaces for posture generation,” in 2016 IEEE
International Conference on Robotics and Automation (ICRA), May
2016, pp. 1608–1614.

[8] P. E. Gill, W. Murray, and M. A. Saunders, “Snopt: An sqp algorithm
for large-scale constrained optimization,” SIAM J. on Optimization,
vol. 12, no. 4, pp. 979–1006, Apr. 2002.

[9] D. Kingma and J. Ba, “Adam: A method for stochastic optimization,”

arXiv preprint arXiv:1412.6980, 2014.

[10] M. Schmidt, N. Le Roux, and F. Bach, “Minimizing ﬁnite sums
with the stochastic average gradient,” Mathematical Programming,
[Online]. Available:
vol. 162, no. 1, pp. 83–112, Mar 2017.
http://dx.doi.org/10.1007/s10107-016-1030-6

[11] A. Neelakantan, L. Vilnis, Q. V. Le, I. Sutskever, L. Kaiser, K. Kurach,
and J. Martens, “Adding gradient noise improves learning for very
deep networks,” arXiv preprint arXiv:1511.06807, 2015.

[12] A. Anandkumar and R. Ge, “Efﬁcient approaches for escaping higher
order saddle points in non-convex optimization,” in Conference on
Learning Theory, 2016, pp. 81–102.

[13] M. Brandao, Y. M. Shiguematsu, K. Hashimoto, and A. Takanishi,
“Material recognition cnns and hierarchical planning for biped robot
locomotion on slippery terrain,” in 2016 IEEE-RAS International
Conference on Humanoid Robots, Nov 2016.

[14] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma,
Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, A. C. Berg, and
L. Fei-Fei, “ImageNet Large Scale Visual Recognition Challenge,”
International Journal of Computer Vision (IJCV), vol. 115, no. 3, pp.
211–252, 2015.

[15] M. Everingham, L. Gool, C. K. Williams, J. Winn, and A. Zisserman,
“The pascal visual object classes (voc) challenge,” Int. J. Comput.
Vision, vol. 88, no. 2, pp. 303–338, June 2010.

[16] Destruction scenario dataset.

[Online]. Available: http://www.

roboptics.pt/

[17] R. Diankov, “Automated construction of robotic manipulation pro-
grams,” Ph.D. dissertation, Carnegie Mellon University, Robotics
Institute, August 2010.

[18] Open dynamics engine. [Online]. Available: http://www.ode.org/
[19] M. Likhachev, G. J. Gordon, and S. Thrun, “Ara*: Anytime a*
with provable bounds on sub-optimality,” in Advances in Neural
Information Processing Systems, 2003, pp. 767–774.

[20] M. Brandao, K. Hashimoto, J. Santos-Victor, and A. Takanishi, “Foot-
step planning for slippery and slanted terrain using human-inspired
models,” IEEE Transactions on Robotics, vol. 32, no. 4, pp. 868–879,
Aug 2016.

[21] J. Nocedal and S. Wright, Numerical optimization. Springer Science

& Business Media, 2006.

[22] L. Bottou, F. E. Curtis, and J. Nocedal, “Optimization methods for
large-scale machine learning,” arXiv preprint arXiv:1606.04838, 2016.
[23] N. S. Keskar, D. Mudigere, J. Nocedal, M. Smelyanskiy, and P. T. P.
Tang, “On large-batch training for deep learning: Generalization gap
and sharp minima,” arXiv preprint arXiv:1609.04836, 2016.

[24] T. Dozat, “Incorporating nesterov momentum into adam,” Technical

Report, Stanford University, 2015.

Fig. 5. A tough initial condition corresponding to a local minimum.

Fig. 6. A posture generation problem where SQP fails (left foot is in
collision) but I-SQP and incremental/stochastic gradient methods converge.
From left to right: SQP, I-SQP.

Traditional and incremental SQP each performed better in
different criteria. SQP arrived at better cost values when it
found a solution, while I-SQP was better regarding success
rates by avoiding infeasible local minima. We believe results
can be improved further by the use of continuation methods
or more elaborate stochastic methods.

We realize many algorithms have been left out of this
benchmark, of notice for example CHOMP and its variants.
We hope the community will step forward and report the
performance of different algorithms on LegOpt. We will also
pursue the evaluation of new methods, with a special interest
in stochastic methods. Although in this paper we deﬁne tasks
and benchmark algorithms for a biped robot on the easiest-
difﬁculty scenario from DSD [16], we envision the extension
of the benchmark to multi-contact tasks and tougher DSD
scenarios. An extension to locomotion with dynamics is
also important future work. The pace of these extensions
will depend on progress made in this current version of the
benchmark.

ACKNOWLEDGMENT

We would like to thank µRoboptics, Inc. for developing
and opening the Destruction Scenarios Dataset, as well as
helping us adapt it to our needs.

REFERENCES

[1] J. Schulman, Y. Duan, J. Ho, A. Lee, I. Awwal, H. Bradlow, J. Pan,
S. Patil, K. Goldberg, and P. Abbeel, “Motion planning with sequential
convex optimization and convex collision checking,” The International
Journal of Robotics Research, vol. 33, no. 9, pp. 1251–1270, 2014.

7
1
0
2
 
t
c
O
 
9
 
 
]

O
R
.
s
c
[
 
 
1
v
9
2
0
3
0
.
0
1
7
1
:
v
i
X
r
a

SGD for robot motion? The effectiveness of stochastic optimization on a
new benchmark for biped locomotion tasks

Martim Brand˜ao, Kenji Hashimoto and Atsuo Takanishi

Abstract— Trajectory optimization and posture generation
are hard problems in robot locomotion, which can be non-
convex and have multiple local optima. Progress on these
problems is further hindered by a lack of open benchmarks,
since comparisons of different solutions are difﬁcult to make.
In this paper we introduce a new benchmark for trajectory
optimization and posture generation of legged robots, using a
pre-deﬁned scenario, robot and constraints, as well as evalua-
tion criteria. We evaluate state-of-the-art trajectory optimiza-
tion algorithms based on sequential quadratic programming
(SQP) on the benchmark, as well as new stochastic and
incremental optimization methods borrowed from the large-
scale machine learning literature. Interestingly we show that
some of these stochastic and incremental methods, which are
based on stochastic gradient descent (SGD), achieve higher
success rates than SQP on tough initializations. Inspired by this
observation we also propose a new incremental variant of SQP
which updates only a random subset of the costs and constraints
at each iteration. The algorithm is the best performing in both
success rate and convergence speed, improving over SQP by up
to 30% in both criteria.

The benchmark’s resources and a solution evaluation script

are made openly available.

I. INTRODUCTION

Optimization of robot postures and trajectories is an im-
portant problem in robotics, with applications to efﬁcient
robot locomotion and manipulation. The problem is hard
because posture and trajectory optimization problems are
often non-convex and have several local optima, especially
in the presence of collision constraints. For example when a
robot model is in collision, the collision gradient might pull
different links in different directions - and the optimization
get stuck at an infeasible local optima [1]. While several
algorithms have been proposed for posture generation and
trajectory optimization [2], [3], [1], [4], [5], [6], [7], com-
paring them is also difﬁcult since each researcher opts for
a different evaluation scenario which was chosen by chance
or to showcase the advantages of the algorithm.

This paper is a step towards solving these two issues: 1)
of the lack of a benchmark, and 2) of avoiding infeasible
local optima. The contributions of the paper are as follows.

*This work was supported by ImPACT TRC Program of Council for
Science, Technology and Innovation (Cabinet Ofﬁce, Government of Japan).
M. Brand˜ao is with the Research Institute for Science and Engineering,
Waseda University: #41-304, 17 Kikui-cho, Shinjuku-ku, Tokyo 162-0044,
JAPAN.

K. Hashimoto is with the Waseda Institute for Advanced Study, and is a

researcher at the Humanoid Robotics Institute (HRI).

A. Takanishi is with the Department of Modern Mechanical Engineering,
Waseda University; and the director of the Humanoid Robotics Institute
(HRI), Waseda University.

• We develop a new robotics challenge, open to the pub-
lic, which consists of a set of problems for benchmark-
ing static posture and trajectory optimization algorithms
on a legged humanoid robot

• We evaluate different optimization algorithms at solving

the problems

• We show that new stochastic optimization algorithms
developed for the (highly non-convex) training of deep
neural networks also lead to high success rates in
posture/trajectory optimization with tough collision con-
straints and initializations. To the best of our knowledge
this is the ﬁrst time these methods are applied to posture
generation and trajectory optimization.

• We propose a stochastic incremental variant of Sequen-
tial Quadratic Programming for trajectory optimization
based on the principles of recent large-scale non-convex
optimization methods. We show it
leads to higher
success rates and speed than SQP on ill-initialized
trajectory optimization problems.

II. RELATED WORK

Robot motion planning has been tackled with search,
sampling and optimization methods. Recently, optimization
algorithms have gained popularity, due to the existence of
fast general-purpose software and the possibility to easily
integrate many different constraints in the problem. One of
the state-of-the-art algorithms is sequential quadratic pro-
gramming, which is used by SNOPT [8] for general-purpose
optimization, but also by trajectory-optimization libraries [1],
and trajectory optimization research on legged robots [3].
Projected conjugate-gradient methods such as CHOMP [4]
have also been proposed for the problem. The gradient-
descent methods we evaluate in this paper are related to
CHOMP in the sense that they also do (pre-conditioned)
gradient descent. However, as in [1] we use penalties for
constraints, thus being able to consider general non-linear
constraints on robot postures or motion.

In this paper we explore the use of stochastic methods
for posture generation and trajectory optimization. The mo-
tivation behind it is to improve success rates by successfully
avoiding local minima through random perturbations. The
idea has also been explored in stochastic variants of CHOMP
[5] which increased success rates. Here we instead make
use of progress in the stochastic optimization literature,
which has recently gained attention in part because of the
problem of local minima, saddle points and non-convexities
which pervade deep neural network training landscapes. The
large-scale optimization and deep learning communities have

recently come up with different algorithms to deal with these
optimization landscapes, such as variants of stochastic gra-
dient descent with pre-conditioning [9], incremental gradient
descent methods [10], noise injection [11] and others. Some
of these algorithms have provable convergence guarantees
[10] and saddle-escaping guarantees [12]. Our assumption
in this paper is that these methods and insights which work
on the highly-nonconvex optimization landscapes of neural
networks will transfer to the (also non-convex) landscapes of
legged robot posture generation and trajectory optimization.
Results of state-of-the-art robot motion planning algo-
rithms are impressive [3], [2], [13], but it is arguably dif-
ﬁcult to compare each planner’s performance, advantages
and disadvantages. This is partly because each algorithm
is evaluated on a different environment, or using different
cost functions, constraints or robot models. For results to
be comparable and veriﬁable, the evaluation criteria must
be the same and largely sampled, while all
inputs (i.e.
scenario, robot, constraints) must be available. Recently,
veriﬁability and comparability have been strongly pursued in
ﬁelds such as computer vision through an investment in open
benchmarks [14], [15] and open source - which has arguably
been a strong factor in fostering research progress. This
paper tries to follow this trend and make public a benchmark
with pre-deﬁned robot, environment, costs, constraints and
evaluation criteria.

III. THE LEGOPT BENCHMARK

A. The environment

The LegOpt Benchmark (Legged-robot posture and tra-
jectory Optimization Benchmark), which we propose in this
paper, is based on the “Destruction Scenario Dataset” (DSD)1
[16]. DSD is a set of challenging 3D scenarios intended
for testing robot search and rescue missions. They were
created in Blender using simple shape primitives, unions and
differences, followed by shattering and collapsing by running
a physics simulation. The scenarios also include 3D models
of cars and people for realism. Snapshots of the ﬁrst frames
were taken as different “difﬁculty levels” of the scenarios
according to an empirical measure of difﬁculty of traversing
the terrain. Models and code to generate them are openly
available2.

The current version of the LegOpt Benchmark is built
on top of
the easiest difﬁculty garage scenario (i.e.
“garage easier”). We show an image of the scenario in Figure
1. This scenario is already challenging enough for current
motion planning and optimization algorithms.

B. Task deﬁnitions

The LegOpt Benchmark consists of two tasks: posture
generation and trajectory optimization. Each task is evaluated
in 50 different problem instances (i.e. different regions of the
scenario). Each posture generation problem is speciﬁed by a
single stance with given 6D poses for the robot’s feet. Each

1The ﬁrst author of this paper collaborated with µRoboptics, Inc. on the

development of the Destruction Scenarios Dataset.

Fig. 1. The “garage easier” scenario: a damaged garage scenario of the
Destruction Scenarios Dataset, used as the environment of our benchmark.

trajectory optimization problem is speciﬁed by a sequence
of stances with given feet poses.

Both tasks use Atlas as the robot model and DSD’s
“garage easier” scenario as the environment. The following
constraints need to be satisﬁed for both tasks:

• Given feet positions and orientations must be respected,
• The center-of-mass (COM) of the robot should lie inside
the support polygon, given by a 2D convex hull of the
horizontal projection of the feet in contact,

• The robot model should not collide with itself or the

environment,

• Robot joint angle limits should be respected.

Each of these constraints is to be enforced with tolerance
10−3 (meters for distances, radians for angles). We compute
collision as the penetration distance in meters, as imple-
mented in the OpenRAVE library [17] using ODE [18]
for collision computations3. We provide an evaluation script
which computes the costs and constraint violations of JSON-
formatted solutions on a website4. We also provide JSON
ﬁles describing the feet poses of each problem instance.

We evaluate an algorithm’s performance at the tasks using
the following criteria: 1) Success rate, i.e. number of problem
instances solved to tolerance; 2) Cost; and 3) Computation
time. The cost function is different for the two tasks.

1) Posture generation: The posture generation task is to
obtain a single full-body conﬁguration q∗ that respects given
feet poses, static stability, no-collision, joint limits, and leads
to the minimum (squared) static torques possible. Basically,
the task is to solve

q∗ =argmin

q

s.t.

τ 2
k (q)

K
(cid:80)
k=1
footi(q) = bi ∀i
COM(q) ∈ Psupport
sd(q) ≥ 0
qmin ≤ q ≤ qmax.

(1)

(2)

(3)

(4)

(5)

3We ignore collisions between the pelvis and upper-torso, since their
convex hulls are always in collision and most collision checkers make use
of convex hulls.

2https://github.com/roboptics/destruction_scenarios

4https://github.com/martimbrandao/legopt-benchmark

where K is the number of the robot’s joints, bi are the
problem’s given feet poses, Psupport is the convex support
polygon, sd(q) represents a signed-distance function between
the robot, itself and the environment.

IV. BENCHMARKED ALGORITHMS

Posture generation and motion planning can be formulated

as optimization problems of the form

2) Trajectory optimization: The trajectory optimization
task is to obtain a sequence of full-body conﬁgurations x∗ =
q∗
1, ..., q∗
T (two conﬁgurations per stance) which respects
given feet poses, static stability, no-collision, joint limits,
and leads to the minimum (squared) joint velocity possible.
Basically, the task is to solve

1, ..., q∗
q∗

T =argmin
q1,...,qT
s.t.

||qt+1 − qt||2

T −1
(cid:80)
t=1
footi,t(qt) = bi,t ∀i, t
COMt(q) ∈ Psupportt
sd(qt) ≥ 0 ∀t
qmin ≤ qt ≤ qmax ∀t.

∀t

(6)

(7)

(8)

(9)

(10)

C. Generation of problem instances

For completeness we will now describe the procedure we
used to arrive at the deﬁnition of all problem instances.
We ﬁrst sampled points uniformly from the scenario’s mesh
triangles to obtain positions for a left foot, then we uni-
formly sampled yaw orientations, which together with the
mesh’s normal vector make an orientation constraint. We
then searched for a right foot position and orientation in
the same way, in a radius around the left foot. We checked
for feasibility and collision of the stance using TrajOpt. This
was done until we had 100 stances scattered throughout the
scenario. We then selected random pairs of stances (50 pairs
on the same ﬂoor, 50 on different ﬂoors), and ran an ARA*-
based [19] footstep planner [20] to obtain a sequence of
stances which connects the pair. The sequence of stances
from the ﬁrst 25 successful same-ﬂoor footstep plans, and
the ﬁrst 25 successful different-ﬂoor footstep plans were
selected as the problem instances for trajectory optimization.
Regarding posture generation, we used K-means clustering
to pick 50 stances out of the set of all stances in all footstep
plans (using stance length, stance height and trunk collision
distance as features).

We show the distribution of problem deﬁnition features in
Figure 2 and 3. The collision distance feature is computed by
a signed-distance function between the trunk (approximated
by a box) and the environment. Notice that many postures
in both tasks are close to collision, and some will actually
be in collision depending on the initialization - since only
the trunk and not the arms were checked for collision while
building the problem deﬁnitions.

min
x∈Rd
s.t.

nf(cid:80)

fi(x)

i=1
gi(x) ≤ 0, i = 1, 2, ..., ng
hi(x) = 0, i = 1, 2, ..., nh
linear constraints,

(11a)

(11b)

(11c)

(11d)

where x are the full-body postures of the robot at one or
more instants of time (i.e. d = D ×T where D is the number
of the degrees of freedom of the robot and T the number
of instants of time a.k.a. waypoints). Each fi, gi, hi is a
function which describes part of the costs or constraints on
the robot, for example a full-body posture cost or a link pose
constraint at a certain waypoint. In this paper we turn (11)
into a sequence of problems of the form

min
x∈Rd

nf(cid:80)

i=1

ng(cid:80)

i=1

fi(x) + µ

pg(gi(x)) + µ

ph(hi(x))

nh(cid:80)
i=1

(12a)

(12b)

s.t.

x ∈ C (convex linear constraints),

which are solved with successively higher µ until all
constraints are satisﬁed (or progress is no longer possible).
The functions pg(.) and ph(.) are called penalty functions
and measure constraint violation. We use pg(.) = max(0, .)
and ph(.) = |.|, which are exact - meaning that they can lead
to the exact solution to the original problem (11) for certain
choices of µ [21].

A. Sequential quadratic programming (SQP)

One of the state-of-the-art methods for solving (11) is Tra-
jOpt [1]. The method uses sequential quadratic programming,
by alternating between

1) building convexiﬁcations ˜fi, ˜gi, ˜hi, where ˜fi are

quadratic and ˜gi, ˜hi are linear

2) solving (12) with the convexiﬁed ˜fi, ˜gi, ˜hi instead of
the original fi, gi, hi functions using a trust-region
method (i.e. constraining x at each iteration to be
within a narrow range where convexiﬁcation is valid).
TrajOpt also uses pg(.) = max(0, .) and ph(.) = |.|

An implementation of this algorithm is openly available5 and
achieves both a high success rate and computation speed
when compared to other recent optimization-based planners
[4] and sampling-based planners.

B. Gradient descent

A simpler way to solve (12) is to use gradient descent. For
convenience, let us simplify the notation of the optimization
problem (12) as

min
x∈C

n
(cid:80)
i=1

Fi(x),

(13)

5http://rll.berkeley.edu/trajopt/

Fig. 2. Statistics of the posture generation task: histograms of stance deﬁnitions and collision distances on all 50 problems.

Fig. 3. Statistics of the trajectory optimization task: histograms of stance deﬁnitions and collision distances on all 50 problems.

where n = nf + ng + nh, and where the terms Fi(x) gather
all cost functions and penalties in (12a):

Fi(x) =






1 ≤ i ≤ nf
fi(x),
pg(gi−nf (x)),
nf < i ≤ nf + ng
ph(hi−nf −ng (x)), nf + ng < i ≤ n.

(14)

Gradient descent solves (13) by iterating

(cid:32)

(cid:33)(cid:33)

xk+1 = πC

xk − αk

∇Fi(xk)

,

(15)

(cid:32) n
(cid:88)

i=1

where πC projects points onto the feasible space C, and αk
is called the step length. The step length is usually ﬁxed
or computed through line search [21]. The iterations are
repeated until some termination criteria is met, usually a
threshold on gradient norm or function improvement. Notice
that the gradient of max(0, y) and |y| is not deﬁned at y = 0,
and so computing (15) with these penalty functions is not
straightforward. In this paper we use smooth approximators6
for the penalty functions such that:
(cid:18)

(cid:19)(cid:19)

(cid:18) ewhi(x)

∇˜ph(hi(x)) =

−1 + 2

∇hi(x)

(16a)

∇˜pg(gi(x)) =

(16b)

1 + ewhi(x)

(cid:40)

0,
gi(x) ≤ 0
∇˜ph(gi(x)), otherwise.

Note that as w → ∞, (16a) tends to −∇hi(x) for hi(x) < 0
and tends to ∇hi(x) for hi(x) > 0, thus approximating the
gradient of the exact penalty |hi(x)|; and similarly (16b) also
approximates the gradient of max(0, gi(x)).

C. Popular algorithms in large-scale optimization and deep
learning

1) Stochastic gradient descent: Stochastic gradient de-
scent (SGD) is gradient descent where the gradients are
noisy. In this situation an estimator ˜∇F (xk) is used that is
equal to the real gradient in expectation, i.e. E[ ˜∇F (xk)] =
∇F (xk). A common choice for this estimator is the use of

6Another option is to use slack variables [21] as done in TrajOpt [1]. We

chose to use smooth approximators as it made debugging more intuitive.

mini-batches, which basically evaluates the gradient at only
a subset of the functions at each iteration. So the sum over
Fi is made not for i = 1, ..., n, but only for a subset Fk
of those indices chosen randomly at iteration k. An SGD
iteration to solve (13) then consists of

(cid:32)

(cid:33)(cid:33)

xk+1 = πC

xk − αk

∇Fi(xk)

.

(17)

(cid:32)

(cid:88)

i∈Fk

The size of a mini-batch (|Fk|≤ n) is usually called “sample-
size”, and for |Fk|= n SGD reduces to full deterministic
gradient descent (15). SGD has low complexity (i.e. low total
number of gradient evaluations) and provable convergence
in probability even on non-convex functions [22], while its
noise actually helps avoid sharp local minima [23]. Due to
these advantages the method has inspired the development
of a number of different variants, which try to deal with
important disadvantages such as slow convergence and hard-
to-tune step lengths.

2) Adam: In this paper we will consider one of those
variants which has become widely popular in the deep
learning community: Adam [9]. Adam basically does SGD
where the step length is adapted to each dimension of x,
similarly in purpose to conjugate gradient descent. In a
nutshell, Adam iterates:

(cid:18)

xk+1 = πC

xk − αk

ˆmk√

ˆvk + (cid:15)

(cid:19)

,

(18)

where the division is element-wise, and ˆmk, ˆvk are un-
biased running averages of the ﬁrst and second moments
of ˜∇F (xk), accumulated at each iteration the following way

ˆmk =mk/(1 − βk
1 )
ˆvk =vt/(1 − βk
2 )
mk =β1mk−1 + (1 − β1)gk
vk =β2vk−1 + (1 − β2)g2
k
gk =

∇Fi(xk).

(cid:88)

i∈Fk

(19a)

(19b)

(19c)

(19d)

(19e)

The constants β1 and β2 are parameters. We refer the
interested reader to the original publication for details.

3) Nadam: We also consider an accelerated version of
Adam, Nadam [24], which uses Nesterov momentum in an
attempt to increase convergence rate. The algorithm uses a
slightly different deﬁnition for ˆmk,

ˆm(Nadam)
k

= β1mk/(1 − βk+1

) + (1 − β1)gk/(1 − βk

1 ). (20)

1

4) Incremental SGD (a.k.a. stochastic average gradient):
Stochastic average gradient, proposed in [10], is an incre-
mental variant of SGD. The gradients of all functions are
used at each iteration, but only a subset of them is actually
computed: the rest are kept unchanged from the previous
iteration. The method has faster convergence properties in
convex functions than SGD, at the cost of increased memory
usage. It iterates

(cid:32)

xk+1 = πC

xk − αk

(cid:32) n
(cid:88)

(cid:33)(cid:33)

yk
i

,

i=1

where

(cid:40)

yk
i =

∇Fi(xk),
yk−1
,
i

i ∈ Fk
otherwise.

(22)

As before, the set Fk is chosen randomly at each iteration.
In the experimental section we will also consider in-
cremental versions of Adam and Nadam (i.e. by keeping
previous gradients in memory). For a shared and readable
naming, we will refer to all these variants by the preﬁx ”I-”,
for incremental: I-SGD, I-Adam, I-Nadam.7

D. A new, incremental SQP (I-SQP)

In the spirit of I-SGD, we propose to use an incremental
version of SQP. The motivation is to observe that a large
part of the computational time of SQP goes into building
convexiﬁcations (i.e. basically taking the gradients of fi, gi,
hi), and so convergence rate can hypothetically be increased
by re-using them from previous iterations - as long as the
convexiﬁcations remain valid within tolerance. Another pos-
sible motivation is that noise arising from re-using previous
convexiﬁcations may help avoid infeasible stationary points,
as happens with SGD.

We show the pseudo-code for I-SQP in the following
Algorithm 1. It is basically TrajOpt [1] with incremental
convexiﬁcations of costs and penalties.

V. RESULTS

A. Experimental setup and implementation

Performance of each optimization method varies greatly
with the choice of initialization, especially in the presence
of non-convex constraints such as obstacle avoidance. Opti-
mizer behavior close and far from collision may also vary
greatly, and therefore be informative of the advantages and
disadvantages of each method. Because of this, in this paper
we obtain results for two different initializations:

7Note that I-SGD and stochastic average gradient refer to the same

method in this paper.

Algorithm 1 I-SQP

input: x; tolerance, penalty and trust region parameters
for PenaltyIteration µ ← µ1, µ2, ... do

for ConvexifyIteration k ← 1, 2, ... do

if k = 1 then

˜F k

else

i ← Convexify(Fi) ∀i = 1, ..., n

Fk ← SampleMiniBatch()
˜F k
i ← Convexify(Fi), ∀i ∈ Fk
i ← ˜F k−1
˜F k
, ∀i /∈ Fk
end if
Using a trust-region algorithm, solve:
˜F k

x ← argmin

i

i (x)

n
(cid:80)
i=1

x∈C

if constraints satisﬁed to tolerance then

break

end if
end for

(21)

end for

1) “Good” initialization: the robot’s base is placed such
that its feet are above their target pose (hence not in
collision with the ground). In particular, the optimiza-
tion will start from q such that the feet soles’ height
will be equal to the maximum target foot sole height
plus a margin of 0.20 meters. The joints are always
set to a nominal posture (knees bent 50 degrees), and
the base’s XY position is set to the center of the active
contacts.

2) Initialization “in-collision”: the robot’s base is placed
such that its feet are in collision with the ground. In
particular, the optimization will start from q such that
the feet soles’ height will be equal to the minimum
target foot sole height minus a margin of 0.05 meters.
The joints are always set to a nominal posture (knees
bent 50 degrees), and the base’s XY position is set to
the center of the active contacts.

As is common in optimization methods for robotics, we
use “multi-starts” (a.k.a. restarts) to deal with optimization
failure. This means that in case the optimization does not
converge from a certain initialization, we restart it from
scratch using a slightly perturbed initial condition. In our
experiments we restart the optimization up to 10 times, and
each time perturb all joint angles using a uniform distribution
in the interval of [−5, 5] degrees. We also report results
without using multi-starts, although they have expectedly
lower success rates.

We solved all problems with full, stochastic and incremen-
tal gradients, with sample sizes 20, 40, ..., 100% of n. On
average we obtained best-performing results using 80%n for
stochastic methods, 40%n for incremental gradient methods
and 80%n for I-SQP. For brevity we report results using these
sample sizes only. Method SQP with 80%n is equivalent to
I-SQP but without memory (i.e. not incremental). Although
we do not expect
the algorithm to score high, because
each QP will be very different from the next as certain

constraints are removed, we still include it in the comparison
for thoroughness.

We used cost and constraint

implementations directly
from the TrajOpt library [1]. Although it is not part of the
trajectory optimization task’s requirements, we also included
a continuous collision constraint between waypoints to obtain
trajectories that are closer to interpolation-feasible.

Due to the large number of variables on the trajectory
optimization task, we solve each trajectory optimization
problem as a sequence of optimization problems which
consider only 6 stances (12 waypoints), with an overlap of
1 stance that is re-planned. The ﬁrst of those waypoints is
ﬁxed (planned in the previous window).

We implemented all optimization methods in C++ as
extensions to the TrajOpt library. The same implementation
for the costs, constraints and respective gradient computa-
tions is used for all optimization methods - thus making
success rates and computation times directly comparable.
The only exception is the implementation of penalty function
gradients, which in the case of SQP and I-SQP uses slack
variables, while other methods use (16).

We compute the step-size of each step in gradient-based
methods through line-search, using a zoom function and
Wolfe’s conditions (c1 = 10−4, c2 = 0.9), as in [21]. For
Adam and Nadam we use standard parameters β1 = 0.9
and β2 = 0.999. The termination criteria is as in [1]
for SQP methods, and is based on proportional-decrease
monitoring for gradient descent methods (i.e. terminate after
10 epochs without improvement in the objective function).
Problems are solved successively with penalty coefﬁcients
µ = 102, 103, ..., 1012. We use Bullet for mesh-collision, and
solve QPs and feasible-space projections πC using Gurobi.

B. Algorithm comparison

We show all results for both tasks condensed in Table
I. As expected, the use of multi-starts greatly improves
performance on all methods and conditions. In general,
success rates are higher for the posture generation than the
trajectory optimization task. This is understandable because
trajectory problems consist of hundreds of postures (see
Figure 3), while posture generation problems consist of
only one. Success is also higher for the “good-initialization”
condition compared to the “in-collision” condition, which
proves the difﬁculty of optimization methods in dealing with
collision constraints. Most of the failures in this condition
consist of the optimization method getting stuck at an
infeasible stationary point where no progress is made in any
degree of freedom (i.e. collision’s signed distance gradient
is inconsistent between links or cancels out the gradient of
other constraints). We show an example of such a case in
Figure 5.

Stochastic and incremental gradient-descent methods, as
well as our I-SQP, consistently lead to higher success rates
than their full-gradient counterparts. SQP and I-SQP have
the lowest computation times, of 1 second per waypoint on
average. In fact, I-SQP is 20 to 30% faster than SQP on
average. Gradient-descent variants are slower. I-Adam takes

1 to 3 seconds per waypoint on average, while the Nesterov-
accelerated I-Nadam is around 15% faster on average. When
it succeeds in ﬁnding a solution, SQP consistently obtains
the lowest-cost postures and trajectories, which we assume
to be due to the nonexistence of noise as well as an efﬁcient
use of second order information and conditioning employed
by the QP solver (Gurobi). The best performing method in
both success rate and computation speed is always I-SQP. Its
cost values are similar but slightly higher than SQP.

For the posture generation task, on average all 50 problems
are successfully solved by all methods. Computation speed
is understandably faster for SQP and I-SQP. This is because
they use second-order information and only recompute gra-
dients after convergence of each QP, while gradient methods
recompute gradients after each step (i.e. after each line
search). In their stochastic and incremental versions, both
SGD- and SQP-based methods decrease computation time
on average, some methods obtaining up to 50% speedups
(I-Adam).

The most common reason for algorithm failure is due
to collision constraints, an example of which is shown in
Figure 6. In this situation, SQP fails and requires several
random restarts until it ﬁnds a feasible solution. I-SQP and all
stochastic and incremental gradient methods succeed at ﬁrst
try. The reason is that SQP gets stuck on an infeasible local
minimum when a foot is in collision, while noisy gradients
in the incremental/stochastic methods help move the robot
out of collision (i.e. out of the local minimum).

For the trajectory optimization task, I-SQP is the best
performing in both the well-initialized and in-collision con-
ditions, solving 42 and 38 problems respectively. I-SQP con-
siderably improves the success rate with respect to traditional
SQP when initialized in-collision (38 vs 29 successes). I-
Adam performs similarly, although slightly worse than SQP
on well-initialized problems (40 vs 42). However, I-Adam
is better than traditional SQP when started in-collision (34
vs 29). In fact, all stochastic and incremental gradient-based
methods outperform traditional SQP in-collision, except for
I-Nadam.

Figure 4 shows a sequence of waypoints from a trajectory
optimization problem where SQP fails, but I-SQP succeeds,
and Adam (sample-size 80%) also succeeds. SQP gets stuck
on a local minimum where the left arm is in collision with
a wall. However, I-SQP successfully ﬁnds a posture which
brings the arm out of collision, and Adam does so with a
simpler posture closer to its nominal value (i.e. straight body
with bent knees).

VI. CONCLUSIONS

In this paper we introduced a new challenge - LegOpt -
for benchmarking different algorithms at the tasks of legged
robot posture generation and trajectory optimization. LegOpt
is open to public and deﬁnes a robot model, scenario, con-
straints and cost functions. Evaluation scripts are also made
public for ease of use. LegOpt will hopefully help the legged
and humanoid robotics communities to better compare the

TABLE I
ALGORITHM COMPARISON ON THE POSTURE AND MOTION TASKS

Method Multi
starts

Sample
size

Success
rate

Time
(s)

Success
rate

Cost

Time
(s)

Success
rate

Time
(s)

Success
rate

Posture generation

Init-in-collision

Trajectory optimization

Init-in-collision

Good-init

Cost

SQP
SGD
Adam
Nadam

SQP
SGD
Adam
Nadam

SQP
SGD
Adam
Nadam

I-SQP
I-SGD
I-Adam
I-Nadam

0
0
0
0

10
10
10
10

10
10
10
10

10
10
10
10

100
100
100
100

100
100
100
100

80
80
80
80

80
40
40
40

49/50
44/50
42/50
39/50

50/50
49/50
49/50
49/50

16/50
50/50
50/50
50/50

50/50
49/50
50/50
50/50

427
720
606
590

427
798
643
642

298
788
629
620

461
833
661
667

1.32
3.76
4.15
2.83

1.44
6.30
5.97
5.67

2.74
5.82
4.18
2.90

1.00
4.13
3.27
2.66

43/50
41/50
46/50
48/50

50/50
48/50
50/50
50/50

20/50
49/50
50/50
50/50

50/50
49/50
50/50
50/50

416
770
616
645

429
783
672
679

279
775
642
638

468
810
668
684

1.43
3.55
3.78
2.33

1.74
5.11
4.30
3.20

4.00
4.44
3.91
2.70

1.34
5.17
3.66
3.44

Good-init

Cost

19/50
4 /50
18/50
16/50

42/50
27/50
31/50
35/50

0 /50
26/50
35/50
33/50

42/50
30/50
40/50
41/50

0.13
0.20
0.14
0.14

0.13
0.17
0.14
0.15

0.00
0.16
0.14
0.14

0.13
0.15
0.14
0.15

0.63
1.38
1.22
0.81

0.62
2.17
1.50
1.19

0.00
1.99
2.05
1.10

0.53
1.30
1.07
0.73

Cost

0.12
0.18
0.14
0.11

0.12
0.16
0.15
0.15

0.00
0.16
0.15
0.14

0.14
0.15
0.15
0.14

Time
(s)

0.67
1.26
1.27
0.92

0.84
3.04
2.10
1.96

0.00
2.49
2.12
1.47

0.71
1.40
1.34
1.64

11/50
2 /50
2 /50
1 /50

29/50
29/50
32/50
30/50

0 /50
30/50
36/50
34/50

38/50
30/50
34/50
28/50

Note: Costs and times are averaged over successfully solved problems.

Fig. 4. A sequence of waypoints from a trajectory optimization problem. The sequence runs from left to right. Each row corresponds to a different
method. From top to bottom: SQP, I-SQP, Adam (80% batch size).

advantages and disadvantages of planning algorithms on
common problems.

We evaluated not only state-of-the-art algorithms based
on sequential convex optimization (SQPs), but also recent
stochastic and incremental algorithms introduced for large-
scale optimization in general and deep learning in particular.
The assumption was that their robustness to local minima
and saddle points would transfer to the optimization land-
scapes of robot optimization tasks as well. The experimental
results showed that stochastic and incremental methods are

indeed effective in the LegOpt Benchmark, especially on the
presence of complex obstacle geometries or on initializations
that are in collision. In particular, stochastic and incremental
variants of SGD and Adam surpassed SQP when initialized
in-collision. Inspired by these algorithms we proposed an in-
cremental version of SQP for optimizing robot motion, which
updates only a random subset of the costs and constraints
at each iteration. The algorithm obtained the highest success
rates on tough initializations, and was consistently faster than
traditional SQP.

[2] S. Kuindersma, R. Deits, M. Fallon, A. Valenzuela, H. Dai, F. Per-
menter, T. Koolen, P. Marion, and R. Tedrake, “Optimization-based
locomotion planning, estimation, and control design for the atlas
humanoid robot,” Autonomous Robots, vol. 40, no. 3, pp. 429–455,
2016.

[3] M. Posa, C. Cantu, and R. Tedrake, “A direct method for trajectory
optimization of rigid bodies through contact,” Int. J. Rob. Res., vol. 33,
no. 1, pp. 69–81, Jan. 2014.

[4] M. Zucker, N. Ratliff, A. D. Dragan, M. Pivtoraiko, M. Klingensmith,
C. M. Dellin, J. A. Bagnell, and S. S. Srinivasa, “Chomp: Covariant
hamiltonian optimization for motion planning,” The International
Journal of Robotics Research, vol. 32, no. 9-10, pp. 1164–1193, 2013.
[5] M. Kalakrishnan, S. Chitta, E. Theodorou, P. Pastor, and S. Schaal,
“Stomp: Stochastic trajectory optimization for motion planning,” in
2011 IEEE International Conference on Robotics and Automation,
May 2011, pp. 4569–4574.

[6] S. Lengagne, J. Vaillant, E. Yoshida, and A. Kheddar, “Generation
of whole-body optimal dynamic multi-contact motions,” The Interna-
tional Journal of Robotics Research, vol. 32, no. 9-10, pp. 1104–1119,
2013.

[7] A. Escande, S. Brossette, and A. Kheddar, “Parametrization of catmull-
clark subdivision surfaces for posture generation,” in 2016 IEEE
International Conference on Robotics and Automation (ICRA), May
2016, pp. 1608–1614.

[8] P. E. Gill, W. Murray, and M. A. Saunders, “Snopt: An sqp algorithm
for large-scale constrained optimization,” SIAM J. on Optimization,
vol. 12, no. 4, pp. 979–1006, Apr. 2002.

[9] D. Kingma and J. Ba, “Adam: A method for stochastic optimization,”

arXiv preprint arXiv:1412.6980, 2014.

[10] M. Schmidt, N. Le Roux, and F. Bach, “Minimizing ﬁnite sums
with the stochastic average gradient,” Mathematical Programming,
[Online]. Available:
vol. 162, no. 1, pp. 83–112, Mar 2017.
http://dx.doi.org/10.1007/s10107-016-1030-6

[11] A. Neelakantan, L. Vilnis, Q. V. Le, I. Sutskever, L. Kaiser, K. Kurach,
and J. Martens, “Adding gradient noise improves learning for very
deep networks,” arXiv preprint arXiv:1511.06807, 2015.

[12] A. Anandkumar and R. Ge, “Efﬁcient approaches for escaping higher
order saddle points in non-convex optimization,” in Conference on
Learning Theory, 2016, pp. 81–102.

[13] M. Brandao, Y. M. Shiguematsu, K. Hashimoto, and A. Takanishi,
“Material recognition cnns and hierarchical planning for biped robot
locomotion on slippery terrain,” in 2016 IEEE-RAS International
Conference on Humanoid Robots, Nov 2016.

[14] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma,
Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, A. C. Berg, and
L. Fei-Fei, “ImageNet Large Scale Visual Recognition Challenge,”
International Journal of Computer Vision (IJCV), vol. 115, no. 3, pp.
211–252, 2015.

[15] M. Everingham, L. Gool, C. K. Williams, J. Winn, and A. Zisserman,
“The pascal visual object classes (voc) challenge,” Int. J. Comput.
Vision, vol. 88, no. 2, pp. 303–338, June 2010.

[16] Destruction scenario dataset.

[Online]. Available: http://www.

roboptics.pt/

[17] R. Diankov, “Automated construction of robotic manipulation pro-
grams,” Ph.D. dissertation, Carnegie Mellon University, Robotics
Institute, August 2010.

[18] Open dynamics engine. [Online]. Available: http://www.ode.org/
[19] M. Likhachev, G. J. Gordon, and S. Thrun, “Ara*: Anytime a*
with provable bounds on sub-optimality,” in Advances in Neural
Information Processing Systems, 2003, pp. 767–774.

[20] M. Brandao, K. Hashimoto, J. Santos-Victor, and A. Takanishi, “Foot-
step planning for slippery and slanted terrain using human-inspired
models,” IEEE Transactions on Robotics, vol. 32, no. 4, pp. 868–879,
Aug 2016.

[21] J. Nocedal and S. Wright, Numerical optimization. Springer Science

& Business Media, 2006.

[22] L. Bottou, F. E. Curtis, and J. Nocedal, “Optimization methods for
large-scale machine learning,” arXiv preprint arXiv:1606.04838, 2016.
[23] N. S. Keskar, D. Mudigere, J. Nocedal, M. Smelyanskiy, and P. T. P.
Tang, “On large-batch training for deep learning: Generalization gap
and sharp minima,” arXiv preprint arXiv:1609.04836, 2016.

[24] T. Dozat, “Incorporating nesterov momentum into adam,” Technical

Report, Stanford University, 2015.

Fig. 5. A tough initial condition corresponding to a local minimum.

Fig. 6. A posture generation problem where SQP fails (left foot is in
collision) but I-SQP and incremental/stochastic gradient methods converge.
From left to right: SQP, I-SQP.

Traditional and incremental SQP each performed better in
different criteria. SQP arrived at better cost values when it
found a solution, while I-SQP was better regarding success
rates by avoiding infeasible local minima. We believe results
can be improved further by the use of continuation methods
or more elaborate stochastic methods.

We realize many algorithms have been left out of this
benchmark, of notice for example CHOMP and its variants.
We hope the community will step forward and report the
performance of different algorithms on LegOpt. We will also
pursue the evaluation of new methods, with a special interest
in stochastic methods. Although in this paper we deﬁne tasks
and benchmark algorithms for a biped robot on the easiest-
difﬁculty scenario from DSD [16], we envision the extension
of the benchmark to multi-contact tasks and tougher DSD
scenarios. An extension to locomotion with dynamics is
also important future work. The pace of these extensions
will depend on progress made in this current version of the
benchmark.

ACKNOWLEDGMENT

We would like to thank µRoboptics, Inc. for developing
and opening the Destruction Scenarios Dataset, as well as
helping us adapt it to our needs.

REFERENCES

[1] J. Schulman, Y. Duan, J. Ho, A. Lee, I. Awwal, H. Bradlow, J. Pan,
S. Patil, K. Goldberg, and P. Abbeel, “Motion planning with sequential
convex optimization and convex collision checking,” The International
Journal of Robotics Research, vol. 33, no. 9, pp. 1251–1270, 2014.

