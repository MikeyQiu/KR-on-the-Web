8
1
0
2
 
b
e
F
 
3
1
 
 
]

G
L
.
s
c
[
 
 
2
v
1
4
1
0
0
.
1
1
7
1
:
v
i
X
r
a

TRAINING GANS WITH OPTIMISM

Constantinos Daskalakis∗
MIT, EECS
costis@mit.edu

Andrew Ilyas∗
MIT, EECS
ailyas@mit.edu

Vasilis Syrgkanis∗
Microsoft Research
vasy@microsoft.com

Haoyang Zeng∗
MIT, EECS
haoyangz@mit.edu

ABSTRACT

We address the issue of limit cycling behavior in training Generative Adversarial
Networks and propose the use of Optimistic Mirror Decent (OMD) for training
Wasserstein GANs. Recent theoretical results have shown that optimistic mirror
decent (OMD) can enjoy faster regret rates in the context of zero-sum games.
WGANs is exactly a context of solving a zero-sum game with simultaneous no-
regret dynamics. Moreover, we show that optimistic mirror decent addresses the
limit cycling problem in training WGANs. We formally show that in the case of
bi-linear zero-sum games the last iterate of OMD dynamics converges to an equi-
librium, in contrast to GD dynamics which are bound to cycle. We also portray the
huge qualitative difference between GD and OMD dynamics with toy examples,
even when GD is modiﬁed with many adaptations proposed in the recent litera-
ture, such as gradient penalty or momentum. We apply OMD WGAN training to
a bioinformatics problem of generating DNA sequences. We observe that mod-
els trained with OMD achieve consistently smaller KL divergence with respect to
the true underlying distribution, than models trained with GD variants. Finally,
we introduce a new algorithm, Optimistic Adam, which is an optimistic variant
of Adam. We apply it to WGAN training on CIFAR10 and observe improved
performance in terms of inception score as compared to Adam.

1

INTRODUCTION

Generative Adversarial Networks (GANs) (Goodfellow et al., 2014) have proven a very successful
approach for ﬁtting generative models in complex structured spaces, such as distributions over im-
ages. GANs frame the question of ﬁtting a generative model from a data set of samples from some
distribution as a zero-sum game between a Generator (G) and a discriminator (D). The Generator is
represented as a deep neural network which takes as input random noise and outputs a sample in the
same space of the sampled data set, trying to approximate a sample from the underlying distribution
of data. The discriminator, also modeled as a deep neural network is attempting to discriminate be-
tween a true sample and a sample generated by the generator. The hope is that at the equilibrium of
this zero-sum game the generator will learn to generate samples in a manner that is indistinguishable
from the true samples and hence has essentially learned the underlying data distribution.

Despite their success at generating visually appealing samples when applied to image generation
tasks, GANs are very ﬁnicky to train. One particular problem, raised for instance in a recent survey
as a major issue (Goodfellow, 2017) is the instability of the training process. Typically training of
GANs is achieved by solving the zero-sum game via running simultaneously a variant of a Stochastic
Gradient Descent algorithm for both players (potentially training the discriminator more frequently
than the generator).

1Code for our models is available at https://github.com/vsyrgkanis/optimistic_GAN_

training

∗These authors contribute equally to this work.

1

The latter amounts essentially to solving the zero-sum game via running no-regret dynamics for
each player. However, it is known from results in game theory, that no-regret dynamics in zero-
sum games can very often lead to limit oscillatory behavior, rather than converge to an equilibrium.
Even in convex-concave zero-sum games it is only the average of the weights of the two players that
constitutes an equilibrium and not the last-iterate. In fact recent theoretical results of Mertikopoulos
et al. (2017) show the strong result that no variant of GD that falls in the large class of Follow-the-
Regularized-Leader (FTRL) algorithms can converge to an equilibrium in terms of the last-iterate
and are bound to converge to limit cycles around the equilibrium.

Averaging the weights of neural nets is a prohibitive approach in particular because the zero-sum
game that is deﬁned by training one deep net against another is not a convex-concave zero-sum
game. Thus it seems essential to identify training algorithms that make the last iterate of the training
be very close to the equilibrium, rather than only the average.

Contributions.
In this paper we propose training GANs, and in particular Wasserstein GANs
Arjovsky et al. (2017), via a variant of gradient descent known as Optimistic Mirror Descent. Op-
timistic Mirror Descent (OMD) takes advantage of the fact that the opponent in a zero-sum game
is also training via a similar algorithm and uses the predictability of the strategy of the opponent
to achieve faster regret rates. It has been shown in the recent literature that Optimistic Mirror De-
scent and its generalization of Optimistic Follow-the-Regularized-Leader (OFTRL), achieve faster
convergence rates than gradient descent in convex-concave zero-sum games (Rakhlin & Sridharan,
2013a;b) and even in general normal form games (Syrgkanis et al., 2015). Hence, even from the per-
spective of faster training, OMD should be preferred over GD due to its better worst-case guarantees
and since it is a very small change over GD.

Moreover, we prove the surprising theoretical result that for a large class of zero-sum games (namely
bi-linear games), OMD actually converges to an equilibrium in terms of the last iterate. Hence, we
give strong theoretical evidence that OMD can help in achieving the long sought-after stability and
last-iterate convergence required for GAN training. The latter theoretical result is of independent
interest, since solving zero-sum games via no-regret dynamics has found applications in many areas
of machine learning, such as boosting (Freund & Schapire, 1996). Avoiding limit cycles in such
approaches could help improve the performance of the resulting solutions.

We complement our theoretical result with toy simulations that portray exactly the large qualitative
difference between OMD as opposed to GD (and its many variants, including gradient penalty,
momentum, adaptive step size etc.). We show that even in a simple distribution learning setting
where the generator simply needs to learn the mean of a multi-variate distribution, GD leads to limit
cycles, while OMD converges pointwise.

Moreover, we give a more complex application to the problem of learning to generate distributions
of DNA sequences of the same cellular function. DNA sequences that carry out the same func-
tion in the genome, such as binding to a speciﬁc transcription factor, follow the same nucleotide
distribution. Characterizing the DNA distribution of different cellular functions is essential for un-
derstanding the functional landscape of the human genome and predicting the clinical consequence
of DNA mutations (Zeng et al., 2015; 2016; Zeng & Gifford, 2017). We perform a simulation study
where we generate samples of DNA sequences from a known distribution. Subsequently we train
a GAN to attempt to learn this underlying distribution. We show that OMD achieves consistently
better performance than GD variants in terms of the Kullback-Leibler (KL) divergence between the
distribution learned by the Generator and the true distribution.

Finally, we apply optimism to training GANs for images and introduce the Optimistic Adam algo-
rithm. We show that it achieves better performance than Adam, in terms of inception score, when
trained on CIFAR10.

2 PRELIMINARIES: WGANS AND OPTIMISTIC MIRROR DESCENT

We consider the problem of learning a generative model of a distribution of data points Q ∈ ∆(X).
Our goal is given a set of samples from D, to learn an approximation to the distribution Q in the
form of a deep neural network Gθ(·), with weight parameters θ, that takes as input random noise

2

z ∈ F (from some simple distribution F ) and outputs a sample Gθ(z) ∈ X. We will focus on
addressing this problem via a Generative Adversarial Network (GAN) training strategy.

The GAN training strategy deﬁnes as a zero-sum game between a generator deep neural network
Gθ(·) and a discriminator neural network Dw(·). The generator takes as input random noise z ∼ F ,
and outputs a sample Gθ(z) ∈ X. A discriminator takes as input a sample x (either drawn from the
true distribution Q or from the generator) and attempts to classify it as real or fake. The goal of the
generator is to fool the discriminator.

In the original GAN training strategy Goodfellow et al. (2014), the discriminator of the zero sum
game was formulated as a classiﬁer, i.e. Dw(x) ∈ [0, 1] with a multinomial logistic loss. The latter
boils down to the following expected zero-sum game (ignoring sampling noise).
Ex∼Q [log(Dw(x))] + Ez∼F [log(1 − Dw(Gθ(z)))]

(1)

inf
θ

sup
w

If the discriminator is very powerful and learns to accurately classify all samples, then the problem
of the generator amounts to minimizing the Jensen-Shannon divergence between the true distribution
and the generators distribution. However, if the discriminator is very powerful, then in practice the
latter leads to vainishing gradients for the generator and inability to train in a stable manner.

The latter problem lead to the formulation of Wasserstein GANs (WGANs) Arjovsky et al. (2017),
where the discriminator rather than being treated as a classiﬁer (equiv. approximating the JS diver-
gence) is instead trying to approximate the Wasserstein−1 or earth-mover metric between the true
distribution and the distribution of the generator. In this case, the function Dw(x) is not constrained
to being a probability in [0, 1] but rather is an arbitrary 1-Lipschitz function of x. This reasoning
leads to the following zero-sum game:

inf
θ

sup
w

Ex∼Q [Dw(x)] − Ez∼F [Dw(Gθ(z))]

(2)

If the function space of the discriminator covers all 1-Lipschitz functions of x, then the quantity
Ex∼D [Dw(x)] − Ez∼F [Dw(Gθ(z))] that the generator is trying to minimize corresponds to
supw
the earth-mover distance between the true distribution Q and the distribution of the generator. Given
the success of WGANs we will focus on WGANs in this paper.

2.1 GRADIENT DESCENT VS OPTIMISTIC MIRROR DESCENT

The standard approach to training WGANs is to train simultaneously the parameters of both net-
works via stochastic gradient descent. We begin by presenting the most basic version of adversarial
training via stochastic gradient descent and then comment on the multiple variants that have been
proposed in the literature in the following section, where we compare their performance with our
proposed algorithm for a simple example.

Let us start how training a GAN with gradient descent would look like in the absence of sampling
error, i.e. if we had access to the true distribution Q. For simplicity of notation, let:

L(θ, w) = Ex∼Q [Dw(x)] − Ez∼F [Dw(Gθ(z))]

(3)

denote the loss in the expected zero-sum game of WGAN, as deﬁned in Equation (2),
i.e.
inf θ supw L(θ, w). The classic WGAN approach is to solve this game by running gradient de-
for t ∈ {1, . . . , T − 1}: with ∇w,t = ∇wL(θt, wt) and
scent (GD) for each player, i.e.
∇θ,t = ∇θL(θt, wt)

wt+1 = wt + η · ∇w,t
θt+1 = θt − η · ∇θ,t
If the loss function L(θ, w) was convex in θ and concave w, θ and w lie in some bounded convex
set and the step size η is chosen of the order 1√
, then standard results in game theory and no-regret
T
learning (see e.g. Freund & Schapire (1999)) imply that the pair (¯θ, ¯w) of average parameters, i.e.
(cid:17)
¯w = 1
.
T
However, no guarantees are known beyond the convex-concave setting and, more importantly for the
paper, even in convex-concave games, no guarantees are known for the last-iterate pair (θT , wT ).

t=1 θt is an (cid:15)-equilibrium of the zero-sum game, for (cid:15) = O

t=1 wt and ¯θ = 1

(cid:16) 1√

(cid:80)T

(cid:80)T

(4)

T

T

Rakhlin and Sridharan (Rakhlin & Sridharan, 2013a) proposed an alternative algorithm for solving
zero-sum games in a decentralized manner, namely Optimistic Mirror Descent (OMD), that achieves

3

faster convergence rates to equilibrium of (cid:15) = O (cid:0) 1
(cid:1) for the average of parameters. The algorithm
essentially uses the last iterations gradient as a predictor for the next iteration’s gradient. This
follows from the intuition that if the opponent in the game is using a stable (or regularized) algorithm,
then the gradients between the two iterations will not change much. Later Syrgkanis et al. (2015)
showed that this intuition extends to show faster convergence of each individual player’s regret in
general normal form games.

T

Given these favorable properties of OMD when learning in games, we propose replacing GD with
OMD when training WGANs. The update rule of a OMD is a small adaptation to GD. OMD is
parameterized by a predictor of the next iteration’s gradient which could either be simply last itera-
tion’s gradient or an average of a window of last gradient or a discounted average of past gradients.
In the case where the predictor is simply the last iteration gradient, then the update rule for OMD
boils down to the following simple form:

wt+1 = wt + 2η · ∇w,t − η · ∇w,t−1
θt+1 = θt − 2η · ∇θ.t + η · ∇θ,t−1

The simple modiﬁcation in the GD update rule, is inherently different than any of the existing adap-
tations used in GAN training, such as Nesterov’s momentum, or gradient penalty.

General OMD and intuition. The intuition behind OMD can be more easily understood when
GD is viewed through the lens of the Follow-the-Regularized-Leader formulation. In particular,
it is well known that GD is equivalent to the Follow-the-Regularized-Leader algorithm with an (cid:96)2
regularizer (see e.g. Shalev-Shwartz (2012)), i.e.:

wt+1 = arg max

η

(cid:104)w, ∇w,τ (cid:105) − (cid:107)w(cid:107)2
2

θt+1 = arg min

η

(cid:104)θ, ∇θ,τ (cid:105) + (cid:107)θ(cid:107)2
2

t
(cid:88)

τ =1
t
(cid:88)

τ =1

w

θ

It is known that if the learner knew in advance the gradient at the next iteration, then by adding that
to the above optimization would lead to constant regret that comes solely from the regularization
term1. OMD essentially augments FTRL by adding a predictor Mt+1 of the next iterations gradient,
i.e.:

wt+1 = arg max

η

(cid:104)w, ∇w,τ (cid:105) + (cid:104)w, Mw,t+1(cid:105)

θt+1 = arg min

η

(cid:104)θ, ∇θ,τ (cid:105) + (cid:104)θ, Mθ,t+1(cid:105)

(cid:32) t

(cid:88)

τ =1

(cid:32) t

(cid:88)

τ =1

w

θ

(cid:33)

− (cid:107)w(cid:107)2
2

(cid:33)

+ (cid:107)θ(cid:107)2
2

wt+1 = wt + η · (∇w,t + Mw,t+1 − Mw,t)
θt+1 = θt − η · (∇θ,t + Mθ,t+1 − Mθ,t)

For an arbitrary set of predictors, the latter boils down to the following set of update rules:

In the theoretical part of the paper we will focus on the case where the predictor is simply the last
iteration gradient, leading to update rules in Equation (5). In the experimental section we will also
explore performance of other alternatives for predictors.

2.2 STOCHASTIC GRADIENT DESCENT AND STOCHASTIC OPTIMISTIC MIRROR DESCENT

In practice we don’t really have access to the true distribution Q and hence we replace Q with an
empirical distribution Qn over samples {x1, . . . , xn} and Fn of random noise samples {z1, . . . , zn},
leading to empirical loss for the zero-sum game of:

Ln(θ, w) = Ex∼Qn [Dw(x)] − Ez∼Fn [Dw(Gθ(z))]
Even in this setting it might be impractical to compute the gradient of the expected loss with respect
to Qn or Fn, e.g. Ex∼Qn [∇wDw(x)].

(9)

1The latter is a consequence of the be-the-leader lemma Kalai & Vempala (2005); Rigollet (2015)

4

(5)

(6)

(7)

(8)

(10)

(11)

(12)

(13)

However, GD and OMD still leads to small loss if we replace gradients with unbiased estimators
of them. Hence, we can replace expectation with respect to Qn or Fn, by simply evaluating the
gradients at a single sample or on a small batch of B samples. Hence, we can replace the gradients
at each iteration with the variants:
1
|B|

(∇wDwt(xi) − ∇wDwt(Gθt(zi)))

ˆ∇w,t =

(cid:88)

ˆ∇θ,t = −

∇θ(Dwt(Gθt(zi)))

i∈B
1
|B|

(cid:88)

i∈B

Replacing ∇w,t and ∇θ,t with the above estimates in Equation (4) and (5), leads to Stochastic
Gradient Descent (SGD) and Stochastic Optimistic Mirror Decent (SOMD) correspondingly.

3 AN ILLUSTRATIVE EXAMPLE: LEARNING THE MEAN OF A DISTRIBUTION

We consider the following very simple WGAN example: The data are generated by a multivariate
normal distribution, i.e. Q (cid:44) N (v, I) for some v ∈ Rd. The goal is for the generator to learn
the unknown parameter v. In Appendix C we also consider a more complex example where the
generator is trying to learn a co-variance matrix.

We consider a WGAN, where the discriminator is a linear function and the generator is a simple
additive displacement of the input noise z, which is drawn from F (cid:44) N (0, I), i.e:

Dw(x) = (cid:104)w, x(cid:105)
Gθ(z) = z + θ

The goal of the generator is to ﬁgure out the true distribution, i.e. to converge to θ = v. The WGAN
loss then takes the simple form:

L(θ, w) = Ex∼N (v,I) [(cid:104)w, x(cid:105)] − Ez∼N (0,I) [(cid:104)w, z + θ(cid:105)]

We ﬁrst consider the case where we optimize the true expectations above rather than assuming that
we only get samples of x and samples of z. Due to linearity of expectation, the expected zero-sum
game takes the form:

inf
θ

sup
w

(cid:104)w, v − θ(cid:105)

We see here that the unique equilibrium of the above game is for the generator to choose θ = v and
for the discriminator to choose w = 0. For this simple zero sum game, we have ∇w,t = v − θt and
∇θ,t = −wt. Hence, the GD dynamics take the form:

wt+1 =wt + η(v − θt)
θt+1 =θt + ηwt

(GD Dynamics for Learning Means)

while the OMD dynamics take the form:

wt+1 =wt + 2η · (v − θt) − η · (v − θt−1)
θt+1 =θt + 2η · wt − η · wt−1

(OMD Dynamics for Learning Means)

We simulated simultaneous training in this zero-sum game under the GD and under OMD dynamics
and we ﬁnd that GD dynamics always lead to a limit cycle irrespective of the step size or other
modiﬁcations. In Figure 1 we present the behavior of the GD vs OMD dynamics in this game for
v = (3, 4). We see that even though GD dynamics leads to a limit cycle (whose average does indeed
equal to the true vector), the OMD dynamics converge to v in terms of the last iterate. In Figure 2
we see that the stability of OMD even carries over to the case of Stochastic Gradients, as long as the
batch size is of decent size.

In the appendix we also portray the behavior of the GD dynamics even when we add gradient penalty
(Gulrajani et al., 2017) to the game loss (instead of weight clipping), adding Nesterov momentum to
the GD update rule (Nesterov, 1983) or when we train the discriminator multiple times in between a
train iteration of the generator. We see that even though these modiﬁcations do improve the stability

5

(a) GD dynamics.

(b) OMD dynamics.

Figure 1: Training GAN with GD converges to a limit cycle that oscilates around the equilibrium (we applied
weight-clipping at 10 for the discriminator). On the contrary training with OMD converges to equilibrium in
terms of last-iterate convergence.

(a) Stochastic OMD dynamics with mini-batch of 50.

(b) Stochastic OMD dynamics with mini-batch of 200.

Figure 2: Robustness of last-iterate convergence of OMD to stochastic gradients.

of the GD dynamics, in the sense that they narrow the band of the limit cycle, they still lead to a
non-vanishing limit cycle, unlike OMD.

In the next section, we will in fact prove formally that for a large class of zero-sum games including
the one presented in this section, OMD dynamics converge to equilibrium in the sense of last-iterate
convergence, as opposed to average-iterate convergence.

4 LAST-ITERATE CONVERGENCE OF OPTIMISTIC ADVERSARIAL TRAINING

In this section, we show that Optimistic Mirror Descent exhibits ﬁnal-iterate, rather than only
average-iterate convergence to min-max solutions for bilinear functions. More precisely, we con-
sider the problem minx maxy xT Ay, for some matrix A, where x and y are unconstrained.
In
Appendix D, we also show that our convergence result appropriately extends to the general case,
where the bi-linear game also contains terms that are linear in the players’ individual strategies,
i.e. games of the form:

(cid:0)xT Ay + bT x + cT y + d(cid:1) .

inf
x

sup
y

In the simpler minx maxy xT Ay problem, Optimistic Mirror Descent takes the following form, for
all t ≥ 1:

xt = xt−1 − 2ηAyt−1 + ηAyt−2
yt = yt−1 + 2ηAT xt−1 − ηAT xt−2

Initialization: For the above iteration to be meaningful we need to specify x0, x−1, y0, y−1. We
choose any x0 ∈ R(A), and y0 ∈ R(AT ), and set x−1 = 2x0 and y−1 = 2y0, where R(·)
represents the column space of A. In particular, our initialization means that the ﬁrst step taken by
the dynamics gives x1 = x0 and y1 = y0.

We will analyze Optimistic Mirror Descent under the assumption λ∞ ≤ 1, where λ∞ =
max{||A||, ||AT ||} and || · || denotes spectral norm of matrices. We can always enforce that λ∞ ≤ 1
by appropriately scaling A. Scaling A by some positive factor clearly does not change the min-max
solutions (x∗, y∗), only scales the optimal value x∗T Ay∗ by the same factor.

We remark that the set of equilibrium solutions of this minimax problem are pairs (x, y) such that
x is in the null space of AT and y is in the null space of A. In this section we rigorously show
that Optimistic Mirror Descent converges to the set of such min-max solutions. This is interesting
in light of the fact that Gradient Descent actually diverges, even in the special case where A is the
identity matrix, as per the following proposition whose proof is provided in Appendix D.3.

(14)

(15)

(16)

6

Proposition 1. Gradient descent applied to the problem minx maxy xT y diverges starting from any
initialization x0, y0 such that x0, y0 (cid:54)= 0.

Next, we state our main result of this section, whose proof can be found in Appendix D, where we
also state its appropriate generalization to the general case (14).

Theorem 1 (Last Iterate Convergence of OMD). Consider the dynamics of Eq. (15) and (16) and
any initialization 1

2 x−1 = x0 ∈ R(A), and 1

2 y−1 = y0 ∈ R(AT ). Let also
(cid:0)AAT (cid:1)+(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13) ,
(cid:13)

γ =

where for a matrix X we denote by X + its generalized inverse and by ||X|| its spectral norm.
Suppose that (cid:107)A(cid:107) ≡ λ∞ ≤ 1 and that η is a small enough constant satisfying η < 1/(3γ2). Letting
∆t = (cid:12)
(cid:12)

2, the OMD dynamics satisfy the following:

(cid:12)
2
2 + ||Ayt||2
(cid:12)

(cid:12)
(cid:12)AT xt

(cid:12)
(cid:12)

∆1 = ∆0 ≥

(cid:18)

1
(1 + η)2 ∆2
η2
γ2

(cid:19)

∀t ≥ 3 : ∆t ≤

1 −

∆t−1 + 16η3∆0.

√

√

In particular, ∆t → O(ηγ2∆0), as t → +∞, and for large enough t, the last iterate of OMD is
within O(
∆0 is the
distance of the initial point (x0, y0) from the equilibrium space, and where both distances are taken
with respect to the norm (cid:112)xT AAT x + yT AT Ay.

∆0) distance from the space of equilibrium points of the game, where

η · γ

√

5 EXPERIMENTAL RESULTS FOR GENERATING DNA SEQUENCES

We take our theoretical intuition to practice, applying OMD to the problem of generating DNA
sequences from an observed distribution of sequences. DNA sequences that carry out the same
function can be viewed as samples from some distribution. For many important cellular functions,
this distribution can be well modeled by a position-weight matrix (PWM) that speciﬁes the proba-
bility of different nucleotides occuring at each position (Stormo, 2000). Thus, training GANs from
DNA sequences sampled from a PWM distribution serves as a practically motivated problem where
we know the ground truth and can thus quantify the performance of different training methods in
terms of the KL divergence between the trained generator distribution and the true distribution.

In our experiments, we generated 40,000 DNA sequences of six nucleotides according to a given
position weight matrix. A random 10% of the sequences were held out as the validation set. Each
sequence was then embedded into a 4 × 6 matrix by encoding each of the four nucleotides with an
one-hot vector. On this dataset, we trained WGANs with different variants of OMD and SGD and
evaluated their performance in terms of the KL divergence between the empirical distribution of the
WGAN-generated samples and the true distribution described by the position weight matrix. Both
the discriminator and generator of the WGAN used in this analysis were chosen to be convolutional
neural networks (CNN), given the recent success of CNNs in modeling DNA-protein binding (Zeng
et al., 2016; Alipanahi et al., 2015). The detailed structure of the chosen CNNs can be found in
Appendix E.

To account for the impact of learning rate and training epochs, we explored two different ways
of model selection when comparing different optimization strategies: (1) using the iteration and
learning rate that yields the lowest discriminator loss on the held out test set. This is inspired by
the observation in Arjovsky et al. (2017) that the discriminator loss negatively correlates with the
quality of the generated samples. (2) using the model obtained after the last epoch of the training.
To account for the stochastic nature of the initialization and optimizers, we trained 50 independent
models for each learning rate and optimizer, and compared the optimizer strategies by the resulting
distribution of KL divergences across 50 runs.

For GD, we used variants of Equation (4) to examine the effect of using momentum and an adaptive
step size. Speciﬁcally, we considered momentum, Nesterov momentum and Adagrad. The speciﬁc
form of all these modiﬁcations is given for reference in Appendix A.

7

For OMD we used the general predictor version of Equation (10) with a ﬁxed step size and with the
following variants of the next iteration predictor Mt+1: (v1) Last iteration gradient: Mt+1 = ∇ft,
(v2) Running average of past gradients: Mt+1 = 1
i=1 ∇fi, (v3) Hyperbolic discounted average
t
of past gradients: Mt+1 = λMt + (1 − λ)∇ft, λ ∈ (0, 1). We explored two training schemes: (1)
training the discriminator 5 times for each generator training as suggest in Arjovsky et al. (2017).
(2) training the discriminator once for each generator training. The latter is inline with the intuition
behind the use of optimism: optimism hinges on the fact that the gradient at the next iteration is very
predictable since it is coming from another regularized algorithm, and if we train the other algorithm
multiple times, then the gradient is not that predictable and the beneﬁts of optimism are lost.

(cid:80)t

(a) WGAN with the lowest validation discriminator loss

(b) WGAN at the last epoch

Figure 3: KL divergence of WGAN trained with different optimization strategies. Methods are ordered by the
median KL divergence. Methods in (a) are named by the category and version of the method. “ratio 1” denotes
training the discriminator once for every generator training. Otherwise, we performed 5 iterations. For (b)
where we don’t combine the models trained with different learning rates, the learning rate is appended at the
end of the method name. For momentum and Nesterov momentum, we used γ = 0.9. For Adagrad, we used
the default (cid:15) = 1e−8.

For all afore-described algorithms, we experimented with their stochastic variants. Figure 3 shows
the KL divergence between the WGAN-generated samples and the true distribution. When evaluated
by the epoch and learning rate that yields the lowest discriminator loss on the validation set, WGAN
trained with Stochastic OMD (SOMD) achieves lower KL divergence than the competing SGD
variants. Evaluated by the last epoch, the best performance across different learning rates is achieved
by optimistic Adam (see Section 6). We note that in both metrics, SOMD with 1:1 generator-
discriminator training ratio yields better KL divergence than the alternative training scheme (1:5
ratio), which validates the intuition behind the use of optimism.

6 GENERATING IMAGES FROM CIFAR10 WITH OPTIMISTIC ADAM
In this section we applying optimistic WGAN training to generating images, after training on CI-
FAR10. Given the success of Adam on training image WGANs we will use an optimistic version
of the Adam algorithm, rather than vanilla OMD. We denote the latter by Optimistic Adam. Opti-
mistic Adam could be of independent interest even beyond training WGANs. We present Optimistic
Adam for (G) but the analog is also used for training (D). We trained on CIFAR10 images with

Algorithm 1 Optimistic ADAM, proposed algorithm for training WGANs on images.

Parameters: stepsize η, exponential decay rates for moment estimates β1, β2 ∈ [0, 1), stochastic
loss as a function of weights (cid:96)t(θ), initial parameters θ0
for each iteration t ∈ {1, . . . , T } do

Compute stochastic gradient: ∇θ,t = ∇θ(cid:96)t(θ)
Update biased estimate of ﬁrst moment: mt = β1mt−1 + (1 − β1) · ∇θ,t
Update biased estimate of second moment: vt = β2vt−1 + (1 − β2) · ∇2
θ,t
Compute bias corrected ﬁrst moment: ˆmt = mt/(1 − βt
1)
Compute bias corrected second moment: ˆvt = vt/(1 − βt
2)
Perform optimistic gradient step: θt = θt−1 − 2η ·
+ η

ˆmt−1√

ˆmt√

ˆvt+(cid:15)

ˆvt−1+(cid:15)

Return θT

Optimistic Adam with the hyper-parameters matched to Gulrajani et al. (2017), and we observe that

8

it outperforms Adam in terms of inception score (see Figure 14), a standard metric of quality of
WGANs (Gulrajani et al., 2017; Salimans et al., 2016). In particular we see that optimistic Adam
achieves high numbers of inception scores after very few epochs of training. We observe that for
Optimistic Adam, training the discriminator once after one iteration of the generator training, which
matches the intuition behind the use of optimism, outperforms the 1:5 generator-discriminator train-
ing scheme. We see that vanilla Adam performs poorly when the discriminator is trained only once
in between iterations of the generator training. Moreover, even if we use vanilla Adam and train 5
times (D) in between a training of (G), as proposed by Arjovsky et al. (2017), then performance is
again worse than Optimistic Adam with a 1:1 ratio of training. The same learning rate 0.0001 and
betas (β1 = 0.5, β2 = 0.9) as in Appendix B of Gulrajani et al. (2017) were used for all the methods
compared. We also matched other hyper-parameters such as gradient penalty coefﬁcient λ and batch
size. For a larger sample of images see Appendix G.

(a) Inception score on CIFAR10, when training with Adam and Optimistic
Adam. “ratio1” means we performed 1 iteration of training of (D) in be-
tween 1 iteration of (G). Otherwise we performed 5 iterations. We further
test (averaging over 35 trials) the two top-performing optimizers, Adam
(ratio 5) and Optimistic Adam with ratio 1, in Appendix H.

(b) Sample of images from Gen-
erator of Epoch 94, which had
the highest inception score.

Figure 4: Comparison of Adam and Optimistic Adam on CIFAR10.

REFERENCES

Babak Alipanahi, Andrew Delong, Matthew T Weirauch, and Brendan J Frey. Predicting the se-
quence speciﬁcities of dna-and rna-binding proteins by deep learning. Nature biotechnology, 33
(8):831–838, 2015.

Martin Arjovsky, Soumith Chintala, and L´eon Bottou. Wasserstein gan.

arXiv preprint

arXiv:1701.07875, 2017.

Yoav Freund and Robert E. Schapire. Game theory, on-line prediction and boosting. In Proceedings
of the Ninth Annual Conference on Computational Learning Theory, COLT ’96, pp. 325–332,
New York, NY, USA, 1996. ACM. ISBN 0-89791-811-8. doi: 10.1145/238061.238163. URL
http://doi.acm.org/10.1145/238061.238163.

Yoav Freund and Robert E. Schapire. Adaptive game playing using multiplicative weights. Games
and Economic Behavior, 29(1):79 – 103, 1999. ISSN 0899-8256. doi: https://doi.org/10.1006/
game.1999.0738. URL http://www.sciencedirect.com/science/article/pii/
S0899825699907388.

Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair,
Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In Z. Ghahramani, M. Welling,
C. Cortes, N. D. Lawrence, and K. Q. Weinberger (eds.), Advances in Neural Information Pro-
cessing Systems 27, pp. 2672–2680. Curran Associates, Inc., 2014. URL http://papers.
nips.cc/paper/5423-generative-adversarial-nets.pdf.

Ian J. Goodfellow. NIPS 2016 tutorial: Generative adversarial networks. CoRR, abs/1701.00160,

2017. URL http://arxiv.org/abs/1701.00160.

9

Ishaan Gulrajani, Faruk Ahmed, Mart´ın Arjovsky, Vincent Dumoulin, and Aaron C. Courville. Im-
proved training of wasserstein gans. CoRR, abs/1704.00028, 2017. URL http://arxiv.
org/abs/1704.00028.

Adam Kalai and Santosh Vempala. Efﬁcient algorithms for online decision problems. Journal
of Computer and System Sciences, 71(3):291 – 307, 2005. ISSN 0022-0000. doi: https://doi.
org/10.1016/j.jcss.2004.10.016. URL http://www.sciencedirect.com/science/
article/pii/S0022000004001394. Learning Theory 2003.

Panayotis Mertikopoulos, Christos Papadimitriou, and Georgios Piliouras. Cycles in adversarial

regularized learning. arXiv preprint arXiv:1709.02738, 2017.

Yurii Nesterov. A method of solving a convex programming problem with convergence rate o (1/k2).

In Soviet Mathematics Doklady, volume 27, pp. 372–376, 1983.

Alexander Rakhlin and Karthik Sridharan. Online learning with predictable sequences. In COLT,

pp. 993–1019, 2013a.

Alexander Rakhlin and Karthik Sridharan. Optimization, learning, and games with predictable se-
quences. In Proceedings of the 26th International Conference on Neural Information Process-
ing Systems - Volume 2, NIPS’13, pp. 3066–3074, USA, 2013b. Curran Associates Inc. URL
http://dl.acm.org/citation.cfm?id=2999792.2999954.

Philippe Rigollet. Mit 18.657: Mathematics of machine learning, lecture 16. 2015.

Tim Salimans, Ian Goodfellow, Wojciech Zaremba, Vicki Cheung, Alec Radford, and Xi Chen.
Improved techniques for training gans. In Advances in Neural Information Processing Systems,
pp. 2234–2242, 2016.

Shai Shalev-Shwartz. Online learning and online convex optimization. Found. Trends Mach. Learn.,
4(2):107–194, February 2012. ISSN 1935-8237. doi: 10.1561/2200000018. URL http://dx.
doi.org/10.1561/2200000018.

Gary D Stormo. Dna binding sites: representation and discovery. Bioinformatics, 16(1):16–23,

2000.

Vasilis Syrgkanis, Alekh Agarwal, Haipeng Luo, and Robert E Schapire. Fast convergence of regu-
larized learning in games. In Advances in Neural Information Processing Systems, pp. 2989–2997,
2015.

Haoyang Zeng and David K Gifford. Predicting the impact of non-coding variants on dna methyla-

tion. Nucleic Acids Research, 2017.

Haoyang Zeng, Tatsunori Hashimoto, Daniel D Kang, and David K Gifford. Gerv: a statistical
method for generative evaluation of regulatory variants for transcription factor binding. Bioinfor-
matics, 32(4):490–496, 2015.

Haoyang Zeng, Matthew D Edwards, Ge Liu, and David K Gifford. Convolutional neural network

architectures for predicting dna–protein binding. Bioinformatics, 32(12):i121–i127, 2016.

10

A VARIANTS OF GD TRAINING

For ease of reference we brieﬂy describe the exact form of update rules for several modiﬁcations of
GD training that we have used in our experimental results.

Adagrad:

Momentum:

ηw,t =

(cid:113)(cid:80)t

η

i=1 ∇2

w,i + (cid:15)

ηθ,t =

(cid:113)(cid:80)t

η

i=1 ∇2

θ,i + (cid:15)

wt+1 = wt + ηw,t · ∇w,t

θt+1 = θt − ηθ,t · ∇θ,t

vw,t+1 = γ · vw,t + η · ∇w,t

vθ,t+1 = γ · vθ,t + η · ∇θ,t

wt+1 = wt + vw,t+1

θt+1 = θt − vθ,t+1

Nesterov momentum:

wahead = wt + γ · vw,t
vw,t+1 = γ · vw,t + η · ∇wL(θt, wahead)

θahead = θt − γ · vθ,t
vθ,t+1 = γ · vθ,t + η · ∇θL(θahead, wt)

(19)

wt+1 = wt + vw,t+1

θt+1 = θt − vθ,t+1

B PERSISTENCE OF LIMIT CYCLES IN GD TRAINING

In Figure 5 we portray example Gradient Descent dynamics in the illustrative example described in
Section 3 under multiple adaptations proposed in the literature. We observe that oscillations persist
in all such modiﬁed GD dynamics, though alleviated by some. We brieﬂy describe the modiﬁcations
in detail ﬁrst.

Gradient penalty. The Wasserstein GAN is based on the idea that the discriminator is approximat-
ing all 1-Lipschitz functions of the data. Hence, when training the discriminator we need to make
sure that the function Dw(x) has a bounded gradient with respect to x. One approach to achieving
this is weight-clipping, i.e. clipping the weights to lie in some interval. However, the latter might
introduce extra instability during training. Gulrajani et al. (2017) introduce an alternative approach
by adding a penalty to the loss function of the zero-sum game that is essentially the (cid:96)2 norm of the
gradient of Dw(x) with respect to x. In particular they propose the following regularized WGAN
loss:

Lλ(θ, w) = Ex∼Q [Dw(x)] − Ez∼F [Dw(Gθ(z))] − λEˆx∼Q(cid:15)

((cid:107)∇xDw(ˆx)(cid:107) − 1)2(cid:105)
(cid:104)

where Q(cid:15) is the distribution of the random vector (cid:15)x + (1 − (cid:15))G(z) when x ∼ Q and z ∼ F . The
expectations in the latter can also be replaced with sample estimates in stochastic variants of the
training algorithms.

For our simple example, ∇xDw(x) = w. Hence, we get the gradient penalty modiﬁed WGAN:

Lλ(θ, w) = (cid:104)w, v − θ(cid:105) − λ ((cid:107)w(cid:107) − 1)2

Hence, the gradient of the modiﬁed loss function with respect to θ remains unchanged, but the
gradient with respect to w becomes:

∇wt = v − θt − 2λwt

(cid:107)wt(cid:107)2 − 1
(cid:107)wt(cid:107)2

Momentum. GD with momentum was deﬁned in Equation (18). For the case of the simple illus-
trative example, these dynamics boil down to:

mw,t+1 =γ · mw,t + η · (v − θt)

wt+1 =wt + mw,t+1

mθ,t+1 =γ · mθ,t − η · wt
θt+1 =θt − mθ,t+1

(17)

(18)

(20)

(21)

(22)

11

Nesterov momentum. GD with Nesterov’s momentum was deﬁned in Equation (19). For the
illustrative example, we see that Nesterov’s momentum is identical to momentum in the absence of
gradient penalty. The reason being that the function is bi-linear. However, with a gradient penalty,
Nesterov’s momentum boils down to the following update rule.

ˆwt =wt + γ · mw,t

mw,t+1 =γ · mw,t + η · (v − θt) − 2η · λ ˆwt

mθ,t+1 =γ · mw,t − η · wt

(23)

(cid:107) ˆwt(cid:107)2 − 1
(cid:107) ˆwt(cid:107)2

wt+1 =wt + mw,t+1

θt+1 =θt − mθ,t+1

Asymmetric training. Another approach to reducing cycling is to train the discriminator more
frequently than the generator. Observe that if we could exactly solve the supremum problem of
the discriminator after every iteration of the generator, then the generator would be simply solving a
convex minimization problem and GD should converge point-wise. The latter approach could lead to
slow convergence given the ﬁniteness of samples in the case of stochastic training. Hence, we cannot
really afford completely solving the discriminators problem. However, training the discriminator for
multiple iterations, brings the problem faced by the generator closer to convex minimization rather
than solving an equilibrium problem. Hence, asymmetric training could help with cycling. We
observe below that asymmetric training is the most effective modiﬁcation in reducing the range of
the cycles and hence making the last-iterate be close to the equilibrium. However, it does not really
eliminate the cycles, rather it simply makes their range smaller.

12

(a) GD dynamics with a gradient penalty added to the loss. η = 0.1 and λ = 0.1.

(b) GD dynamics with momentum. η = 0.1 and γ = 0.5.

(c) GD dynamics with momentum and gradient penalty. η = .1, γ = 0.2 and λ = 0.1.

(d) GD dynamics with momentum and gradient penalty, training generator every 15 training iterations of the
discriminator. η = .1, γ = 0.2 and λ = 0.1.

(e) GD dynamics with Nesterov momentum and gradient penalty, training generator every 15 training iterations
of the discriminator. η = .1, γ = 0.2 and λ = 0.1.

Figure 5: Persistence of limit cycles in multiple variants of GD training.

13

C ANOTHER EXAMPLE: LEARNING A CO-VARIANCE MATRIX

We demonstrate the beneﬁts of using OMD over GD in another simple illustrative example. In this
case, the example is does not boil down to a bi-linear game and therefore, the simulation results
portray that the theoretical results we provided for bi-linear games, carry over qualitatively beyond
the linear case.

Consider the case where the data distribution is a mean zero multi-variate normal with an unknown
co-variance matrix, i.e., x ∼ N (0, Σ). We will consider the case where the discriminator is the set
of all quadratic functions:

The generator is a linear function of the random input noise z ∼ N (0, I), of the form:

DW (x) =

Wijxixj = xT W x

(cid:88)

ij

GV (z) = V z

The parameters W and V are both d × d matrices. The WGAN game loss associated with these
functions is then:

L(V, W ) = Ex∼N (0,Σ)

(cid:2)xT W x(cid:3) − Ez∼N (0,I)

(cid:2)zT V T W V z(cid:3)

Expanding the latter we get:

L(V, W ) =Ex∼N (0,Σ)

Wijxixj









(cid:88)

ij

(cid:88)

ij


 − Ez∼N (0,I)






 − Ez∼N (0,I)





(cid:88)

ij

(cid:88)

ijkm

(cid:88)

Wij

Vikzk

k



Vjmzm



(cid:88)

m

WijVikVjmzkzm





=Ex∼N (0,Σ)

Wijxixj

WijEx∼N (0,Σ) [xixj] −

WijVikVjmEz∼N (0,I) [zkzm]

(cid:88)

ijkm

(cid:88)

ij
(cid:88)

ij
(cid:88)

=

=

=

ij

ij

(cid:88)

=

WijΣij −

WijVikVjm1{k = m}

(cid:88)

ijkm
(cid:88)

ijk

WijΣij −

WijVikVjk

(cid:32)

(cid:33)

Wij

Σij −

VikVjk

(cid:88)

k

Given that the covariance matrix is symmetric positive deﬁnite, we can write it as Σ = U U T . Then
the loss simpliﬁes to:

L(V, W ) =

Wij

Σij −

VikVjk

=

Wij (UikUjk − VikVjk)

(27)

(cid:88)

ij

(cid:32)

(cid:33)

(cid:88)

k

(cid:88)

ijk

The equilibrium of this game is for the generator to choose Vik = Uik for all i, k, and for the
discriminator to pick Wij = 0. For instance, in the case of a single dimension we have L(V, W ) =
W · (σ2 − V 2), where σ2 is the variance of the Gaussian. Hence, the equilibrium is for the generator
to pick V = σ and the discriminator to pick W = 0.

Dynamics without sampling noise. For the mean GD dynamics the update rules are as follows:

(24)

(25)

(26)

(28)

W t

ij =W t−1

ij + η

Σij −

ik V t−1
V t−1

jk

(cid:88)

k

ij =V t−1
V t

ij + η

(cid:0)W t−1

ik + W t−1

ki

(cid:1) V t−1

kj

(cid:33)

(cid:32)

(cid:88)

k

14

We can write the latter updates in a simpler matrix form:

Wt =Wt−1 + η (cid:0)Σ − Vt−1V T
Vt =Vt−1 + η(Wt−1 + W T

t−1
t−1)Vt−1

(cid:1)

Similarly the OMD dynamics are:

(GD for Covariance)

Wt =Wt−1 + 2η (cid:0)Σ − Vt−1V T
Vt =Vt−1 + 2η(Wt−1 + W T

(cid:1) − η (cid:0)Σ − Vt−2V T
t−1
t−2
t−1)Vt−1 − η(Wt−2 + W T

(cid:1)

t−2)Vt−2

(OMD for Covariance)

Due to the non-convexity of the generators problem and because there might be multiple optimal
solutions (e.g. if Σ is not strictly positive deﬁnite), it is helpful in this setting to also help dynamics
by adding (cid:96)2 regularization to the loss of the game. The latter simply adds an extra 2λWt at each
gradient term ∇W L(Vt, Wt) for the discriminator and a 2λVt at each gradient term ∇V L(Vt, Wt)
for the generator. In Figures 7 and 6 we give the weights and the implied covariance matrix ΣG =
V V T of the generator’s distribution for each of the dynamics for an example setting of the step-size
and regularization parameters and for two and three dimensional gaussians respectively. We again
see how OMD can stabilize the dynamics to converge pointwise.

Stochastic dynamics.
In Figure 8 and 9 we also portray the instability of GD and the robustness
of the stability of OMD under stochastic dynamics. In the case of stochastic dynamics the gradients
are replaced with unbiased estimates or with averages of unbiased estimates over a small minibatch.
In the case of a mini-batch of one, the unbiased estimates of the gradients in this setting take the
following form:

ˆ∇W,t = xtxT

t − VtztzT

t V T
t
t )VtztzT
t
where xt, zt are samples drawn from the true distribution and from the random noise distribution
respectively. Hence, the stochastic dynamics simply follow by replacing gradients with unbiased
estimates:

ˆ∇V,t = −(Wt + W T

(Stochastic Gradients)

Wt =Wt−1 + η ˆ∇W,t−1
Vt =Vt−1 − η ˆ∇V,t−1
Wt =Wt−1 + 2η ˆ∇W,t−1 − η ˆ∇W,t−2
Vt =Vt−1 − 2η ˆ∇V,t−1 + η ˆ∇V,t−2

(SGD for Covariance)

(SOMD for Covariance)

15

(a) GD dynamics. η = 0.1, T = 500, λ = 0.3.

(b) OMD dynamics. η = 0.1, T = 500, λ = 0.3.

Figure 6: Stability of OMD vs GD in the co-variance learning problem for a two-dimensional gaussian (d = 2).
Weight clipping in [−1, 1] was applied in both dynamics.

(a) GD dynamics. η = 0.1, T = 500, λ = 0.3.

(b) OMD dynamics. η = 0.1, T = 500, λ = 0.3.

Figure 7: Stability of OMD vs GD in the co-variance learning problem for a three-dimensional gaussian (d =
3). Weight clipping in [−1, 1] was applied in both dynamics.

16

(a) Stochastic GD dynamics with mini-batch size 50. η = 0.02, T = 1000, λ = 0.1.

(b) True Distribution (c) Iterate T − 50

(d) Iterate T − 35

(e) Iterate T − 20

(f) Iterate T

(g) Comparison of true distribution and distribution of generator at various points closer to the end of training.

Figure 8: Stochastic GD dynamics for covariance learning of a two-dimensional gaussian (d = 2). Weight
clipping in [−1, 1] was applied to the discriminator weights.

(a) Stochastic OMD dynamics with mini-batch size 50. η = 0.02, T = 1000, λ = 0.1.

(b) True Distribution (c) Iterate T − 50

(d) Iterate T − 35

(e) Iterate T − 20

(f) Iterate T

(g) Comparison of true distribution and distribution of generator at various points closer to the end of training.

Figure 9: Stability of OMD with stochastic gradients for covariance learning of a two-dimensional gaussian
(d = 2). Weight clipping in [−1, 1] was applied to the discriminator weights.

17

(29)

(30)

(31)

(32)

D LAST ITERATE CONVERGENCE OF OMD IN BILINEAR CASE

The goal of this section is to show that Optimistic Mirror Descent exhibits last iterate convergence
to min-max solutions for bilinear functions. In Section D.1, we provide the proof of Theorem 1, that
OMD exhibits last iterate convergence to min-max solutions of the following min-max problem

where A is an abitrary matrix and x and y are unconstrained. In Section D.2, we state the appropriate
extension of our theorem to the general case:

min
x

max
y

xT Ay,

(cid:0)xT Ay + bT x + cT y + d(cid:1) .

inf
x

sup
y

D.1 PROOF OF THEOREM 1

As stated in Section 4, for the min-max problem (29) Optimistic Mirror Descent takes the following
form, for all t ≥ 1:

xt = xt−1 − 2ηAyt−1 + ηAyt−2
yt = yt−1 + 2ηAT xt−1 − ηAT xt−2

where for the above iterations to be meaningful we need to specify x0, x−1, y0, y−1.

As stated in Section 4 we allow any initialization x0 ∈ R(A), and y0 ∈ R(AT ), and set x−1 = 2x0
and y−1 = 2y0, where R(·) represents column space. In particular, our initialization means that the
ﬁrst step taken by the dynamics gives x1 = x0 and y1 = y0.
Before giving our proof of Theorem 1, we need some further notation. For all i ∈ N, we set:

t = ||NiAyt||2

Mi = Aj(AT A)k, Ni = (cid:0)AT (cid:1)j (cid:0)AAT (cid:1)k
(cid:12)
(cid:12)MiAT xt
∆i

2 + (cid:12)
(cid:12)
where k ∈ Z and j ∈ {0, 1} are such that: i = 2k + j.
(cid:12)
t = (cid:12)
(cid:12)AT xt
(cid:12)
(cid:12)
(cid:12)
(cid:12)
2
(cid:12)AAT Ayt
2, etc.
(cid:12)
(cid:12)

2 + ||Ayt||2

(cid:12)
(cid:12)AAT xt

t = (cid:12)
(cid:12)

2, ∆1

2
2

(cid:12)
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2

2

2

(cid:12)
(cid:12)

2 + (cid:12)
(cid:12)

With this notation, ∆0
(cid:12)
(cid:12)
(cid:12)
(cid:12)AT AAT xt
(cid:12)
(cid:12)
We also use the notation (cid:104)u, v(cid:105)X = uT XX T v, for vectors u, v ∈ Rd and square d × d matrices
X. We similarly deﬁne the norm notation ||u||X = (cid:112)(cid:104)u, u(cid:105)X . Given our notation, we have the
following claim, shown in Appendix D.3.
Claim 1. For all matrices A and vectors u, v of the appropriate dimensions:

2, ∆2

t =

2 + (cid:12)
(cid:12)

(cid:12)
(cid:12)AT Ayt

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2

(cid:104)Au, Av(cid:105)AM T

= (cid:104)u, v(cid:105)AT N T

i

; (cid:104)AT u, AT v(cid:105)AT N T

i

i+1

= (cid:104)u, v(cid:105)AM T

; (cid:104)u, Av(cid:105)AM T

i+1

= (cid:104)v, AT u(cid:105)AT N T

.

i

i

With our notation in place, we show (through iterated expansion of the update rule), the following
lemma, proved in Appendix D.3:
Lemma 2. For the dynamics of Eq. (31) and (32) and any initialization 1
2 y−1 = y0 ∈ R(AT ) we have the following for all i, t ∈ N such that i ≥ 0 and t ≥ 2:
1
t−2 − 2η3 (cid:16)

2 x−1 = x0 ∈ R(A), and

− (cid:104)yt−2, AT xt−4(cid:105)AT N T

(cid:104)xt−2, Ayt−4(cid:105)AM T

t−1 = 4η2∆i+1

t−1 − 5η2∆i+1

t − ∆i

∆i

(cid:17)

.

i+1

i+1

We are ready to prove Theorem 1.
Corollary 7.
Theorem 3. Consider the dynamics of Eq. (31) and (32) and any initialization 1
and 1

2 y−1 = y0 ∈ R(AT ). Let

Its proof is implied by the following stronger theorem, and

2 x−1 = x0 ∈ R(A),

γ = max

(cid:16)(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:0)AAT (cid:1)+(cid:12)
(cid:12)
(cid:12)
(cid:12) ,
(cid:12)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:0)AT A(cid:1)+(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:17)

,

18

where for a matrix X we denote by X + its generalized inverse and by ||X|| its spectral norm.
Suppose that max{||A||, ||AT ||} ≡ λ∞ ≤ 1 and η is a small enough constant satisfying η <
1/(3γ2). Then, for all i ∈ N:

1 = ∆i
∆i
0,
2 ≤ (1 + η)2∆i
0,

∆i

and, for all i, t ∈ N such that t ≥ 3, the following condition holds:

H(i, t) : ∆i

t ≤

1 −

∆i

t−1 + 16η3∆0
0.

(cid:18)

(cid:19)

η2
γ2

Proof. Eq. (33) holds trivially as under our initialization x1 = x0 and y1 = y0. Eq. (34) is also easy
to show by noticing the following. Given our initialization:

x2 = x0 − ηAy0
y2 = y0 + ηAx0

Hence (using j = i mod 2):

MiAT x2 = MiAT x0 − ηMiAT Ay0

⇒ ||MiAT x2||2 ≤ ||MiAT x0||2 + η||MiAT Ay0||2

= ||MiAT x0||2 + η||Aj(AT )1−jNiAy0||2
≤ ||MiAT x0||2 + ηλ∞||NiAy0||2
≤ ||MiAT x0||2 + η||NiAy0||2

Similarly:

||NiAy2||2 ≤ ||NiAy0||2 + η||MiAT x0||2

It follows from (40) and (41) that

∆i

2 ≤ (1 + η)2∆i
0.

We use induction on t to prove (35). We start our proof by showing the inductive step, and postpone
establishing the basis of our induction to the end of this proof. For the inductive step, we assume
that H(i, τ ) holds for all i ≥ 0 and 1 ≤ τ < t, for some t > 3. Assuming this, we show next
that H(i, t) holds for all i. To do this, we make use of a few lemmas, whose proofs are given in
Appendix D.3.

(33)

(34)

(35)

(36)

(37)

(38)

(39)

(40)

(41)

Lemma 4. Under the conditions of the theorem, for all i ≥ 0, t ≥ 2:

∆i

t − ∆i

t−1 ≤ 4η2∆i+1

t−1 − 5η2∆i+1

t−2 + η3(∆i+1

t−2 + ∆i+1

t−4).

Lemma 5. Under the conditions of the theorem, for all i, t ≥ 0: ∆i+1

t ≤ ∆i
t.

Lemma 6. Under the conditions of the theorem, for all i ≥ 0, t ≥ 0:

∆i+2

t ≥

1
γ2 ∆i
t.

19

Given these lemmas, we show our inductive step. So for t ≥ 4:

∆i

t − ∆i

t−1 − 5η2∆i+1
t−1 + η3(∆i+1

t−2 + η3(∆i+1
t−2 + ∆i+1

t−2 + ∆i+1
t−4)
t−4) + 80η5∆0
0

t−1 + η3(∆i+1

t−2 + ∆i+1

t−4) + 80η5∆0
0

≤ −

≤ −

≤ −

t−1 ≤ 4η2∆i+1
≤ −η2∆i+1
1
γ2 η2∆i−1
1
γ2 η2∆i−1
1
γ2 η2∆i−1
1
γ2 η2∆i−1
1
γ2 η2∆i−1
1
γ2 η2∆i−1
1
γ2 η2∆i

≤ −

≤ −

≤ −

≤ −

t−1 + 16η3∆0
0

t−1 + 16η3∆0
0

t−1 + η3(∆0
(cid:18)

t−1 +

2η3∆0

t−4) + 80η5∆0
0
(cid:19)

t−2 + ∆0
2 + 2η3 γ2
η2 16η3∆0
2η3(1 + η)2 + 32η3 γ2

0

t−1 +

η2 η3 + 80η5
t−1 + (cid:0)2η3(1 + η)2 + 11η3 + 80η5(cid:1) ∆0

0

(cid:18)

+ 80η5∆0
0

(cid:19)

∆0
0

t−2 + 16η3∆0

where for the ﬁrst inequality we used Lemma 4, for the second inequality we used that ∆i+1
t−1 ≤
∆i+1
0 (which is implied by the induction hypothesis), for the third inequality we used
Lemma 6, for the fourth inequality we used Lemma 5, for the ﬁfth inequality we applied the in-
duction hypothesis iteratively, for the sixth inequality we used Eq. (34), for the seventh and eighth
inequality we used that η is small enough, and for the last inequality we used Lemma 5. Hence:

(cid:18)

∆i

t ≤

1 −

(cid:19)

η2
γ2

∆i

t−1 + 16η3∆0
0.

This completes the proof of our inductive step.
It remains to show the basis of the induction, namely that H(i, 3) holds for all i ∈ N. From Lemma 4
we have:

∆i

3 − ∆i

1 + ∆i+1
−1 )

) + 5η3∆i+1

0
0 + 5η3∆i+1

0

1 + η3(∆i+1
0 + 5η3∆i+1
0
2 − ∆i+1

2 − 5η2∆i+1
2 − 5η2∆i+1
2 + 5η2(∆i+1
0
2 + 5η3(2 + η)∆i+1
2 + 5η3(3 + η)∆i+1
2 + 15η3(1 + η/3)∆0
0

0

2 + 15η3(1 + η/3)∆0
0

2 ≤ 4η2∆i+1
≤ 4η2∆i+1
= −η2∆i+1
≤ −η2∆i+1
= −η2∆i+1
≤ −η2∆i+1
η2
γ2 ∆i−1
η2
γ2 ∆i

≤ −

≤ −

2 + 15η3(1 + η/3)∆0
0,

∆i

3 ≤

1 −

∆i

2 + 16η3∆0
0.

(cid:18)

(cid:19)

η2
γ2

20

where for the second equality we used that 0.5x−1 = x0 = x1 and 0.5y−1 = y0 = y1 (which follow
from our initialization), for the third inequality we used that (34), for the fourth inequality we used
Lemma 5, for the ﬁfth inequality we used Lemma 6, and for the last inequality we used Lemma 5.
Hence, for small enough η, we have:

(42)

(43)

(44)

(45)

(46)

(47)

(48)

(49)

(50)

(51)

(52)

(53)

(54)

(55)

(56)

(57)

(58)

Corollary 7. Under the conditions of Theorem 3, ∆0

0) as
(cid:17)
η · γ(cid:112)∆0
t → +∞. In particular, for large enough t, the last iterate of OMD is within O
distance from the space of equilibrium points of the game, where (cid:112)∆0
0 is the distance of the initial
point (x0, y0) from the equilibrium space, and where both distances are taken with respect to the
norm (cid:112)xT AAT x + yT AT Ay.

2 → O(ηγ2∆0
(cid:16)√

2 + ||Ayt||2

(cid:12)
t ≡ (cid:12)
(cid:12)AT xt
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2

0

Proof of Corollary 7: It follows from (33), (34) and (35) that:
∞
(cid:88)

(cid:19)t−2

(cid:18)

(cid:18)

∆0

t ≤

1 −

(1 + η)2∆0

0 + 16

1 −

(cid:19)t

η2
γ2

η3∆0
0

t=0

(cid:18)

=

1 −

(cid:19)t−2

(1 + η)2∆0

0 + O (cid:0)ηγ2∆0

0

(cid:1) ,

η2
γ2

η2
γ2

which shows the ﬁrst part of our claim. For the second part of our claim recall that the solutions
to (29) are all pairs (x, y) such that x is in the null space of AT and y is in the null space of A.

D.2 GENERAL BILINEAR CASE

Theorem 8. Consider OMD for the min-max problem (30):

(cid:0)xT Ay + bT x + cT y + d(cid:1) .

inf
x

sup
y

(cid:16)√

Under the same conditions as Corollary 7 and whenever (30) is ﬁnite, OMD exhibits last iterate
convergence in the same sense as in Corollary 7. In particular, for large enough t, the last iterate of
OMD is within O
distance from the space of equilibrium points of the game, where
√
∆0 is the distance of the point (x0 + (AT )+c, y0 + A+b) from the equilibrium space, and where
both distances are taken with respect to the norm (cid:112)xT AAT x + yT AT Ay. Whenever (30) is inﬁnite
or undeﬁned, the OMD dynamics travels to inﬁnity and we characterize its motion.

η · γ(cid:112)∆0

(cid:17)

0

Proof of Theorem 8: Trivially, we need only consider functions of the form xT Ay + bT x + cT y. We
consider the following decompositions of b and c:
b = b1 + b2
c = c1 + c2

where b1 ∈ R(A), b2 ∈ N (AT )
where c1 ∈ R(AT ), c2 ∈ N (A)

Given the above we can also deﬁne b3 and c3 as follows:

Ac3 = b1
AT b3 = c1

feasible since b1 ∈ R(A)
feasible since c1 ∈ R(AT )

Then, we can make the following variable substition:
αt = xt + ηtb2 + b3
βt = yt − ηtc2 + c3

so that:

We also state the OMD dynamics for xt and yt for problem (30):

AT αt = AT xt + ηtAT b2 + AT b3

= AT xt + c1

since b2 ∈ N (AT )

Aβt = Ayt − ηtAc2 + Ac3

= Ayt + b1

since c2 ∈ N (A)

xt = xt−1 − 2η(Ayt−1 + b) + η(Ayt−2 + b)

= xt−1 − 2ηAyt−1 + ηAyt−2 − ηb

yt = yt−1 + 2η(AT xt−1 + c) − η(AT xt−2 + c)

= yt−1 + 2ηAT xt−1 − ηAT xt−2 + ηc

21

Note that given this update step:

xt+1 = xt − 2ηAyt + ηAyt−1 − ηb
xt+1 = xt − ηb2 − 2ηAyt + ηAyt−1 − ηAc3
xt+1 = xt − ηb2 − 2ηA(yt + c3) + ηA(yt−1 + c3)
xt+1 = xt − ηb2 − 2ηA(yt − ηc2t + c3) + ηA(yt−1 − ηc2(t − 1) + c3)
xt+1 + ηb2(t + 1) = xt + ηb2t − 2ηA(yt − ηc2t + c3) + ηA(yt−1 − ηc2(t − 1) + c3)
xt+1 + ηb2(t + 1) + b3 = xt + ηb2t + b3 − 2ηA(yt − ηc2t + c3) + ηA(yt−1 − ηc2(t − 1) + c3)

αt+1 = αt − 2ηAβt + ηAβt−1

Analogously:

βt+1 = βt + 2ηAT αt − ηAT αt−1

Note that these are precisely the dynamics for which we proved convergence in Theorem 1. Thus,
by invoking Theorem 3 and Corollary 7 on the sequence (αt, βt) and then substituting back (xt, yt),
we have that for all large enough t:

xt = −ηb2t − b3 + (cid:15)x(t)
yt = ηc2t − c3 + (cid:15)y(t)

such that ||AT (cid:15)x(t)||2, ||A(cid:15)y(t)||2 ∈ O

(cid:18)√

(cid:113)

(cid:19)

∆0
0

,

η · γ

where ∆0

0 = ||AT (x0 + b3)||2

2 + ||A(y0 + c3)||2
2.
In particular, this shows that, whenever (30) is ﬁnite (i.e. b2 = c2 = 0), OMD exhibits last iterate
η · γ(cid:112)∆0
convergence. For large enough t, the last iterate of OMD is within O
distance from
the space of equilibrium points of the game, where (cid:112)∆0
0 is the distance of (x0 + b3, y0 + c3) from
(cid:112)xT AAT x + yT AT Ay. Whenever (30) is inﬁnite or undeﬁned,
the equilibrium space in the norm
the OMD dynamics travels to inﬁnity linearly, with ﬂuctuations around the divergence speciﬁed as
above.

(cid:16)√

(cid:17)

0

D.3 OMITTED PROOFS

Proof of Proposition 1: To show this, we consider the (cid:96)2 distance of the solution at time t. First,
recall the GD update step in the special case of f (x, y) = xT y:

Then, note that the squared (cid:96)2 distance of the running iterate (xt, yt) to the unique equilibrium
solution (0, 0) is given by d(t) := ||xt||2

2 + ||yt||2

xt = xt−1 − ηyt−1
yt = yt−1 + ηxt−1

||xt||2
||yt−1||2

2 = ||xt−1||2
2 = ||yt−1||2

2, which we can calculate:
t−1yt−1 + η2||yt−1||2
2
t−1xt−1 + η2||xt−1||2
2

2 − 2ηxT
2 + 2ηyT

∴ d(t) = d(t − 1) + η2d(t − 1)
= (1 + η2)d(t − 1)

This indicates that for any value of η > 0, the running iterate of GD diverges from the equilibrium.

Proof of Claim 1: For our ﬁrst claim, observe that:
(cid:104)Au, Av(cid:105)AM T

= uT AT AM T

i MiAT Av

i

= uT AT A(AT A)k(Aj)T Aj(AT A)kAT Av
= uT AT (AAT )kA(Aj)T AjAT (AAT )kAv
= uT AT [(AAT )kA(Aj)T ][AjAT (AAT )k]Av
= uT AT N T
= (cid:104)u, v(cid:105)AT N T

i+1Ni+1Av

i+1

22

Our second claim, (cid:104)AT u, AT v(cid:105)AT N T

= (cid:104)u, v(cid:105)AM T

i

i+1

, is proven analogously.

For our third claim:

(cid:104)u, Av(cid:105)AM T

i

= uT AM T

i MiAT Av

= uT A(AT A)k(AT A)j(AT A)kAT Av

if j = 0:

otherwise:

= uT A(AT A)k(AT A)kAT Av
= uT A[AT (AAT )k][(AAT )kA]v
= uT A[AT N T
= (cid:104)v, AT u(cid:105)AT N T

i ][NiA]v

i

= uT A(AT A)kAT A(AT A)kAT Av
= uT A[(AT A)kAT A][(AT A)kAT A]v
= uT A[AT (AAT )kA][AT (AAT )kA]v
= uT A[AT N T
= (cid:104)v, AT u(cid:105)AT N T

i ][NiA]v

i

Proof of Lemma 2: First, we note the following scaled update rule:

MiAT xt = Mi
NiAyt = Ni

(cid:0)AT xt−1 − 2ηAT Ayt−1 + ηAT Ayt−2
(cid:1)
(cid:0)Ayt−1 + 2ηAAT xt−1 − ηAAT xt−2

(cid:1)

Then, taking the norm of both sides, and using the statements of Claim 1:
+ 4η2 ||yt−1||2

+ η2 ||yt−2||2

= ||xt−1||2

||xt||2

AM T
i

AM T
i

+ 2η(cid:104)xt−1, Ayt−2(cid:105)AM T

i

i+1

AT N T
− 4η2(cid:104)yt−1, yt−2(cid:105)AT N T

AT N T

i+1

i+1

− 4η(cid:104)xt−1, Ayt−1(cid:105)AM T

i

||yt||2

AT N T
i

= ||yt−1||2

AT N T
i

+ 4η2 ||xt−1||2
+ 2η(cid:104)yt−1, AT xt−2(cid:105)AT N T

+ η2 ||xt−2||2
AM T
AM T
− 4η2(cid:104)xt−1, xt−2(cid:105)AM T

i+1

i+1

i

i+1

+ 4η(cid:104)yt−1, AT xt−1(cid:105)AT N T

i

∴ ∆i

t = ||xt||2
= ∆i

+ ||yt||2
t−1 + 4η2∆i+1

AT N T
i
t−1 + η2∆i+1

AM T
i

− 4η2((cid:104)xt−1, xt−2(cid:105)AM T

t−2 + 2η((cid:104)xt−1, Ayt−2(cid:105)AM T
+ (cid:104)yt−1, yt−2(cid:105)AT N T

i

i+1

i+1

− (cid:104)yt−1, Axt−2(cid:105)AT N T
)

i

)

Expanding the ﬁrst pair of inner products above and using Claim 1 again:

(cid:104)xt−1, Ayt−2(cid:105)AM T

i

− (cid:104)yt−1, AT xt−2(cid:105)AT N T

i

= (cid:104)xt−2 − 2ηAyt−2 + ηAyt−3, Ayt−2(cid:105)AM T

i

− (cid:104)yt−2 + 2ηAT xt−2 − ηAT xt−3, AT xt−2(cid:105)AT N T

i

= −2η(||yt−2||2

AT N T

i+1

+ ||xt−2||2

AM T

i+1

) + η((cid:104)xt−2, xt−3(cid:105)AM T

+ (cid:104)yt−2, yt−3(cid:105)AT N T

)

i+1

i+1

Then, multiplying by 2η and substituting into the previous derivation yields:

∆i

t − ∆i

t−1 = 4η2∆i+1

t−2 + 2η2((cid:104)xt−2, xt−3(cid:105)AM T

+ (cid:104)yt−2, yt−3(cid:105)AT N T

)

i+1

i+1

t−1 − 3η2∆i+1
− 4η2((cid:104)xt−1, xt−2(cid:105)AM T

+ (cid:104)yt−1, yt−2(cid:105)AT N T

)

i+1

i+1

23

Now, consider the following inner product:

(cid:104)xt−2, xt−1(cid:105)AM T

+ (cid:104)yt−2, yt−1(cid:105)AT N T

= (cid:104)xt−2, xt−2 − 2ηAyt−2 + ηAyt−3(cid:105)AM T

i+1

i+1

i+1

+ (cid:104)yt−2, yt−2 + 2ηAT xt−2 − ηAT xt−3(cid:105)AT N T

i+1

= ∆i+1

t−2 + η

(cid:104)xt−2, Ayt−3(cid:105)AM T

i+1

− (cid:104)yt−2, AT xt−3(cid:105)AT N T

i+1

(cid:16)

(cid:17)

Once again, we multiply by −4η2 and substitute:

∆i

t − ∆i

t−1 = 4η2∆i+1

t−1 − 7η2∆i+1

t−2 + 2η2((cid:104)xt−2, xt−3(cid:105)AM T

+ (cid:104)yt−2, yt−3(cid:105)AT N T

)

i+1

i+1

+ 4η3((cid:104)yt−2, AT xt−3(cid:105)AT N T

− (cid:104)xt−2, Ayt−3(cid:105)AM T

)

i+1

i+1

Now, we use the update step for time t − 2. For all t ≥ 1, this is well-deﬁned, since x−1 and y−1
are deﬁned. To ensure that this step is sound for t = 0 requires we deﬁne the following, where X +
denotes the generalized inverse:

We deﬁne these such that: AT x−2 = 4AT x0 + y0
y0 ∈ R(AT ), and thus the following equalities hold:

η and Ay−2 = 4Ay0 − x0

η (since x0 ∈ R(A) and

x−2 = 4x0 +

(AT )+y0

y−2 = 4y0 −

A+x0

1
η

1
η

x0 = x−1 − 2ηAy−1 + ηAy−2
y0 = y−1 + 2ηAT x−1 − ηAT x−2

This allows us to use the following expansion freely for all t ≥ 2:

xt−2 = xt−3 − 2ηAyt−3 + ηAyt−4
yt−2 = yt−3 + 2ηAT xt−3 − ηAT xt−4

=⇒ xt−3 − 2ηAyt−3 = xt−2 − ηAyt−4
=⇒ yt−3 + 2ηAT xt−3 = yy−2 + ηAT xt−4

We can gather the inner product terms and use this update rule to get our ﬁnal desired result:

∆i

t − ∆i

t−1 = 4η2∆i+1

t−1 − 7η2∆i+1

t−2 + 2η2((cid:104)xt−2, xt−3 − 2ηAyt−3(cid:105)AM T

+ (cid:104)yt−2, yt−3 + 2ηAT xt−3(cid:105)AT N T

)

i+1

i+1

= 4η2∆i+1

t−1 − 5η2∆i+1

t−2 − 2η3((cid:104)xt−2, Ayt−4(cid:105)AM T

− (cid:104)yt−2, AT xt−4(cid:105)AT N T

)

i+1

i+1

Proof of Lemma 4: To prove this, ﬁrst consider the following trivial inequality:

(cid:12)
(cid:12)

(cid:12)
(cid:12)yt−2 − AT xt−4

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2
AT N T

i+1

+ ||xt−2 + Ayt−4||2

AM T

i+1

= ||yt−2||2

AT N T
+ ||xt−2||2

i+1

≥ 0

− 2(cid:104)yt−2, AT xt−4(cid:105)AT N T

i+1

AM T

i+1

+ 2(cid:104)xt−2, Ayt−4(cid:105)AM T

i+1

+ (cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)AT xt−4
(cid:12)
(cid:12)
(cid:12)
+ ||Ayt−4||2

2
AT N T

i+1

AM T

i+1

Rearranging:

2(cid:104)yt−2, AT xt−4(cid:105)AT N T

− 2(cid:104)xt−2, Ayt−4(cid:105)AM T

i+1

i+1

≤ ∆i+1

t−2 +

(cid:16)(cid:12)
(cid:12)
(cid:12)AT xt−4
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2
AT N T

i+1

+ ||Ayt−4||2

(cid:17)

AM T

i+1

(cid:17)

AM T

i+1

+ ||yt−4||2

AT N T

i+1

(cid:16)

≤ ∆i+1

||xt−4||2
(cid:1)

t−2 + λ2
∞
t−2 + (cid:0)λ2
∞∆i+1
t−4
t−2 + ∆i+1
t−4

≤ ∆i+1
≤ ∆i+1

24

Now, we can apply this bound to the result of Lemma 2:

∆i

t − ∆i

t−1 = 4η2∆i+1
≤ 4η2∆i+1

t−1 − 5η2∆i+1
t−1 − 5η2∆i+1

t−2 − 2η3((cid:104)xt−2, Ayt−4(cid:105)AM T
t−2 + η3(∆i+1

t−2 + ∆i+1
t−4)

i+1

− (cid:104)yt−2, AT xt−4(cid:105)AT N T

)

i+1

Which is what we sought out to prove.

Proof of Lemma 5: Suppose j = i mod 2 and k = (i − j)/2. Notice the following identities:

Mi = Aj(AT A)k, Ni = (cid:0)AT (cid:1)j (cid:0)AAT (cid:1)k
Mi+1 = (AT )jA(AT A)k, Ni+1 = AjAT (cid:0)AAT (cid:1)k

Now:

∆i+1

t = ||Ni+1Ayt||2

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2
2

Ayt

2 + (cid:12)
(cid:12)
(cid:12)Mi+1AT xt
(cid:12)
(cid:12)
(cid:12)
(cid:12)
2
(cid:12)
+ (cid:12)
(cid:12)AjAT (cid:0)AAT (cid:1)k
(cid:12)(AT )jA(AT A)kAT xt
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
2
(cid:12)
(cid:12)
(cid:12)
(cid:12)(AT )j (cid:0)AAT (cid:1)k
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
||NiAyt||2
(cid:12)MiAT xt

(cid:12)
(cid:12)Aj(AT A)kAT xt

(cid:18)(cid:12)
(cid:12)
(cid:12)

+ (cid:12)
(cid:12)

Ayt

2
(cid:12)
(cid:12)

2 + (cid:12)
(cid:12)

(cid:17)

(cid:16)

2

(cid:12)
2
(cid:12)
2

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2

2

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2

2

(cid:19)

=

(cid:12)
(cid:12)
(cid:12)

≤ λ2
∞

≤ λ2
∞
≤ ∆i
t,

where for the last inequality we used that λ∞ ≤ 1.

Proof of Lemma 6: Given our initialization, x0 ∈ R(A). This implies xt ∈ R(A), ∀ t, due to the
update step of the dynamics. Recalling key properties of the matrix pseudoinverse, this implies:
xt ≡ AA+xt = AAT (AAT )+xt, for all t. Similarly, given our initialization, yt ∈ R(AT ), for
all t, which implies yt ≡ AT (AT )+yt = AT A(AT A)+yt, for all t. Letting Q = (AAT )+ and
P = (AT A)+, we get the following (where j = i mod 2 and k = (i − j)/2):

∆i

2

2

(cid:12)
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2
2

2 + (cid:12)
(cid:12)

t = (cid:12)
(cid:12)
2 + ||NiAyt||2
(cid:12)MiAT xt
(cid:12)
2
= (cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)MiAT AAT Qxt
(cid:12)NiAAT AP yt
(cid:12)
(cid:12)
(cid:12)
= (cid:12)
(cid:12)
(cid:12)
(cid:12)
2
2 + ||Ni+2AP yt||2
(cid:12)Mi+2AT Qxt
(cid:12)
(cid:12)
(cid:12)
= (cid:12)
(cid:12)
2 + (cid:12)
(cid:12)
(cid:12)
(cid:12)Aj(AT A)k+1AT (AAT )+xt
(cid:12)
(cid:12)
(cid:12)
(cid:12)
= (cid:12)
(cid:12)
2 + (cid:12)
(cid:12)
(cid:12)
(cid:12)Aj(AT A)+AT (AAT )k+1xt
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:40)(cid:12)
2 + (cid:12)
(cid:12)
(cid:12)(AAT )+Ni+2Ayt
(cid:12)
(cid:12)
(cid:12)
2 + (cid:12)
(cid:12)
(cid:12)(AT A)+Ni+2Ayt
(cid:12)
(cid:12)
,

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
≤ max (||Q||, ||P ||)2 · ∆i+2

(cid:12)
(cid:12)(AT A)+Mi+2AT xt
(cid:12)
(cid:12)(AAT )+Mi+2AT xt

=

2

2

2

2

2

t

(cid:12)
(cid:12)(AT )j(AAT )k+1A(AT A)+yt
(cid:12)
(cid:12)(AT )j(AAT )+A(AT A)k+1yt
(cid:12)
(cid:12)
2
(cid:12)
(cid:12)
2
(cid:12)
(cid:12)
2
(cid:12)
(cid:12)
2

if j = 0

if j = 1

(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)
(cid:12)

2

2
2

2

where for the fourth and ﬁfth equality we used the following key property of pseudo-inverses: A+ =
(AT A)+AT = AT (AAT )+.

25

E DNA-GENERATION WGAN ARCHITECTURE

Operation

Kernel

Output Shape BatchNorm? Nonlinearity

Length of DNA sequence: L = 6
Gradient penalty: λ = 1e−4
Batch size: 512
G(z) :
z
Fully connected
Fully connected
Reshape
Upsampling by 2
Convolution
D(x) :
x
Convolution
Fully connected
Fully connected

-
-
-
-
-
[1 × 3] × 4

50
128
16 × L
2
16 × 1 × L
2
16 × 1 × L
4 × 1 × L

-
[1 × 3] × 16
-
-

4 × 1 × L
16 × 1 × L
32
1

-
no
yes
-
-
no

-
no
no
no

-
tanh
tanh
-
-
tanh

-
tanh
tanh
linear

F CIFAR10 WGAN ARCHITECTURE

Operation

Kernel

Output Shape BatchNorm? Nonlinearity

Gradient penalty: λ = 10
Batch size: 64
G(z) :
z
Fully connected
Fully connected
Reshape
TransposedConv
Convolution
TransposedConv
Convolution
D(x) :
x
Convolution
Convolution
Convolution
Fully connected
Fully connected

-
-
-
-
[5 × 5] × 128
[5 × 5] × 64
[5 × 5] × 64
[5 × 5] × 3

-
[5 × 5] × 64
[5 × 5] × 128
[5 × 5] × 128
-
-

100
1024
8192
128 × 8 × 8
128 × 16 × 16
64 × 16 × 16
64 × 32 × 32
3 × 32 × 32

3 × 32 × 32
64 × 32 × 32
128 × 14 × 14
128 × 7 × 7
1024
1

-
no
yes
-
yes
yes
yes
no

-
no
no
no
no
no

-
LeakyReLU
LeakyReLU
-
LeakyReLU
LeakyReLU
LeakyReLU
tanh

-
LeakyReLU
LeakyReLU
LeakyReLU
LeakyReLU
linear

26

G CIFAR10 GENERATOR IMAGE SAMPLES

(a) Sample of images from Generator of Epoch 94, which had the highest inception score.

Figure 10: Samples of images from Generator trained via Optimistic Adam on CIFAR10.

G.1 COMPARISON OF EARLY EPOCH IMAGES OF OPTIMISTIC ADAM VS ADAM

Below we give samples of images from an early epoch 19 Generator trained via Optimistic Adam
with 1:1 training ratio, Adam with 1:1 and Adam with 5:1 ratio on CIFAR10. We see that Optimistic
Adam has already achieved visually appealing results unlike the latter two vanilla Adam based
versions.

27

Figure 11: Sample of images from Generator of Epoch 19 trained via Optimistic Adam and 1:1 training ratio.

Figure 12: Sample of images from Generator of Epoch 19 trained via Adam and 1:1 training ratio.

28

Figure 13: Sample of images from Generator of Epoch 19 trained via Adam and 5:1 training ratio.

29

H CIFAR10 ADAM VS. OPTIMISTIC ADAM COMPARISON

Figure 14: The inception scores across epochs for GANs trained with Optimistic Adam (ratio 1) and Adam (ra-
tio 5) on CIFAR10 (the two top-performing optimizers found in Section 6, with 10%-90% conﬁdence intervals.
The GANs were trained for 30 epochs and results gathered across 35 runs.

30

8
1
0
2
 
b
e
F
 
3
1
 
 
]

G
L
.
s
c
[
 
 
2
v
1
4
1
0
0
.
1
1
7
1
:
v
i
X
r
a

TRAINING GANS WITH OPTIMISM

Constantinos Daskalakis∗
MIT, EECS
costis@mit.edu

Andrew Ilyas∗
MIT, EECS
ailyas@mit.edu

Vasilis Syrgkanis∗
Microsoft Research
vasy@microsoft.com

Haoyang Zeng∗
MIT, EECS
haoyangz@mit.edu

ABSTRACT

We address the issue of limit cycling behavior in training Generative Adversarial
Networks and propose the use of Optimistic Mirror Decent (OMD) for training
Wasserstein GANs. Recent theoretical results have shown that optimistic mirror
decent (OMD) can enjoy faster regret rates in the context of zero-sum games.
WGANs is exactly a context of solving a zero-sum game with simultaneous no-
regret dynamics. Moreover, we show that optimistic mirror decent addresses the
limit cycling problem in training WGANs. We formally show that in the case of
bi-linear zero-sum games the last iterate of OMD dynamics converges to an equi-
librium, in contrast to GD dynamics which are bound to cycle. We also portray the
huge qualitative difference between GD and OMD dynamics with toy examples,
even when GD is modiﬁed with many adaptations proposed in the recent litera-
ture, such as gradient penalty or momentum. We apply OMD WGAN training to
a bioinformatics problem of generating DNA sequences. We observe that mod-
els trained with OMD achieve consistently smaller KL divergence with respect to
the true underlying distribution, than models trained with GD variants. Finally,
we introduce a new algorithm, Optimistic Adam, which is an optimistic variant
of Adam. We apply it to WGAN training on CIFAR10 and observe improved
performance in terms of inception score as compared to Adam.

1

INTRODUCTION

Generative Adversarial Networks (GANs) (Goodfellow et al., 2014) have proven a very successful
approach for ﬁtting generative models in complex structured spaces, such as distributions over im-
ages. GANs frame the question of ﬁtting a generative model from a data set of samples from some
distribution as a zero-sum game between a Generator (G) and a discriminator (D). The Generator is
represented as a deep neural network which takes as input random noise and outputs a sample in the
same space of the sampled data set, trying to approximate a sample from the underlying distribution
of data. The discriminator, also modeled as a deep neural network is attempting to discriminate be-
tween a true sample and a sample generated by the generator. The hope is that at the equilibrium of
this zero-sum game the generator will learn to generate samples in a manner that is indistinguishable
from the true samples and hence has essentially learned the underlying data distribution.

Despite their success at generating visually appealing samples when applied to image generation
tasks, GANs are very ﬁnicky to train. One particular problem, raised for instance in a recent survey
as a major issue (Goodfellow, 2017) is the instability of the training process. Typically training of
GANs is achieved by solving the zero-sum game via running simultaneously a variant of a Stochastic
Gradient Descent algorithm for both players (potentially training the discriminator more frequently
than the generator).

1Code for our models is available at https://github.com/vsyrgkanis/optimistic_GAN_

training

∗These authors contribute equally to this work.

1

The latter amounts essentially to solving the zero-sum game via running no-regret dynamics for
each player. However, it is known from results in game theory, that no-regret dynamics in zero-
sum games can very often lead to limit oscillatory behavior, rather than converge to an equilibrium.
Even in convex-concave zero-sum games it is only the average of the weights of the two players that
constitutes an equilibrium and not the last-iterate. In fact recent theoretical results of Mertikopoulos
et al. (2017) show the strong result that no variant of GD that falls in the large class of Follow-the-
Regularized-Leader (FTRL) algorithms can converge to an equilibrium in terms of the last-iterate
and are bound to converge to limit cycles around the equilibrium.

Averaging the weights of neural nets is a prohibitive approach in particular because the zero-sum
game that is deﬁned by training one deep net against another is not a convex-concave zero-sum
game. Thus it seems essential to identify training algorithms that make the last iterate of the training
be very close to the equilibrium, rather than only the average.

Contributions.
In this paper we propose training GANs, and in particular Wasserstein GANs
Arjovsky et al. (2017), via a variant of gradient descent known as Optimistic Mirror Descent. Op-
timistic Mirror Descent (OMD) takes advantage of the fact that the opponent in a zero-sum game
is also training via a similar algorithm and uses the predictability of the strategy of the opponent
to achieve faster regret rates. It has been shown in the recent literature that Optimistic Mirror De-
scent and its generalization of Optimistic Follow-the-Regularized-Leader (OFTRL), achieve faster
convergence rates than gradient descent in convex-concave zero-sum games (Rakhlin & Sridharan,
2013a;b) and even in general normal form games (Syrgkanis et al., 2015). Hence, even from the per-
spective of faster training, OMD should be preferred over GD due to its better worst-case guarantees
and since it is a very small change over GD.

Moreover, we prove the surprising theoretical result that for a large class of zero-sum games (namely
bi-linear games), OMD actually converges to an equilibrium in terms of the last iterate. Hence, we
give strong theoretical evidence that OMD can help in achieving the long sought-after stability and
last-iterate convergence required for GAN training. The latter theoretical result is of independent
interest, since solving zero-sum games via no-regret dynamics has found applications in many areas
of machine learning, such as boosting (Freund & Schapire, 1996). Avoiding limit cycles in such
approaches could help improve the performance of the resulting solutions.

We complement our theoretical result with toy simulations that portray exactly the large qualitative
difference between OMD as opposed to GD (and its many variants, including gradient penalty,
momentum, adaptive step size etc.). We show that even in a simple distribution learning setting
where the generator simply needs to learn the mean of a multi-variate distribution, GD leads to limit
cycles, while OMD converges pointwise.

Moreover, we give a more complex application to the problem of learning to generate distributions
of DNA sequences of the same cellular function. DNA sequences that carry out the same func-
tion in the genome, such as binding to a speciﬁc transcription factor, follow the same nucleotide
distribution. Characterizing the DNA distribution of different cellular functions is essential for un-
derstanding the functional landscape of the human genome and predicting the clinical consequence
of DNA mutations (Zeng et al., 2015; 2016; Zeng & Gifford, 2017). We perform a simulation study
where we generate samples of DNA sequences from a known distribution. Subsequently we train
a GAN to attempt to learn this underlying distribution. We show that OMD achieves consistently
better performance than GD variants in terms of the Kullback-Leibler (KL) divergence between the
distribution learned by the Generator and the true distribution.

Finally, we apply optimism to training GANs for images and introduce the Optimistic Adam algo-
rithm. We show that it achieves better performance than Adam, in terms of inception score, when
trained on CIFAR10.

2 PRELIMINARIES: WGANS AND OPTIMISTIC MIRROR DESCENT

We consider the problem of learning a generative model of a distribution of data points Q ∈ ∆(X).
Our goal is given a set of samples from D, to learn an approximation to the distribution Q in the
form of a deep neural network Gθ(·), with weight parameters θ, that takes as input random noise

2

z ∈ F (from some simple distribution F ) and outputs a sample Gθ(z) ∈ X. We will focus on
addressing this problem via a Generative Adversarial Network (GAN) training strategy.

The GAN training strategy deﬁnes as a zero-sum game between a generator deep neural network
Gθ(·) and a discriminator neural network Dw(·). The generator takes as input random noise z ∼ F ,
and outputs a sample Gθ(z) ∈ X. A discriminator takes as input a sample x (either drawn from the
true distribution Q or from the generator) and attempts to classify it as real or fake. The goal of the
generator is to fool the discriminator.

In the original GAN training strategy Goodfellow et al. (2014), the discriminator of the zero sum
game was formulated as a classiﬁer, i.e. Dw(x) ∈ [0, 1] with a multinomial logistic loss. The latter
boils down to the following expected zero-sum game (ignoring sampling noise).
Ex∼Q [log(Dw(x))] + Ez∼F [log(1 − Dw(Gθ(z)))]

(1)

inf
θ

sup
w

If the discriminator is very powerful and learns to accurately classify all samples, then the problem
of the generator amounts to minimizing the Jensen-Shannon divergence between the true distribution
and the generators distribution. However, if the discriminator is very powerful, then in practice the
latter leads to vainishing gradients for the generator and inability to train in a stable manner.

The latter problem lead to the formulation of Wasserstein GANs (WGANs) Arjovsky et al. (2017),
where the discriminator rather than being treated as a classiﬁer (equiv. approximating the JS diver-
gence) is instead trying to approximate the Wasserstein−1 or earth-mover metric between the true
distribution and the distribution of the generator. In this case, the function Dw(x) is not constrained
to being a probability in [0, 1] but rather is an arbitrary 1-Lipschitz function of x. This reasoning
leads to the following zero-sum game:

inf
θ

sup
w

Ex∼Q [Dw(x)] − Ez∼F [Dw(Gθ(z))]

(2)

If the function space of the discriminator covers all 1-Lipschitz functions of x, then the quantity
Ex∼D [Dw(x)] − Ez∼F [Dw(Gθ(z))] that the generator is trying to minimize corresponds to
supw
the earth-mover distance between the true distribution Q and the distribution of the generator. Given
the success of WGANs we will focus on WGANs in this paper.

2.1 GRADIENT DESCENT VS OPTIMISTIC MIRROR DESCENT

The standard approach to training WGANs is to train simultaneously the parameters of both net-
works via stochastic gradient descent. We begin by presenting the most basic version of adversarial
training via stochastic gradient descent and then comment on the multiple variants that have been
proposed in the literature in the following section, where we compare their performance with our
proposed algorithm for a simple example.

Let us start how training a GAN with gradient descent would look like in the absence of sampling
error, i.e. if we had access to the true distribution Q. For simplicity of notation, let:

L(θ, w) = Ex∼Q [Dw(x)] − Ez∼F [Dw(Gθ(z))]

(3)

denote the loss in the expected zero-sum game of WGAN, as deﬁned in Equation (2),
i.e.
inf θ supw L(θ, w). The classic WGAN approach is to solve this game by running gradient de-
for t ∈ {1, . . . , T − 1}: with ∇w,t = ∇wL(θt, wt) and
scent (GD) for each player, i.e.
∇θ,t = ∇θL(θt, wt)

wt+1 = wt + η · ∇w,t
θt+1 = θt − η · ∇θ,t
If the loss function L(θ, w) was convex in θ and concave w, θ and w lie in some bounded convex
set and the step size η is chosen of the order 1√
, then standard results in game theory and no-regret
T
learning (see e.g. Freund & Schapire (1999)) imply that the pair (¯θ, ¯w) of average parameters, i.e.
(cid:17)
¯w = 1
.
T
However, no guarantees are known beyond the convex-concave setting and, more importantly for the
paper, even in convex-concave games, no guarantees are known for the last-iterate pair (θT , wT ).

t=1 θt is an (cid:15)-equilibrium of the zero-sum game, for (cid:15) = O

t=1 wt and ¯θ = 1

(cid:16) 1√

(cid:80)T

(cid:80)T

(4)

T

T

Rakhlin and Sridharan (Rakhlin & Sridharan, 2013a) proposed an alternative algorithm for solving
zero-sum games in a decentralized manner, namely Optimistic Mirror Descent (OMD), that achieves

3

faster convergence rates to equilibrium of (cid:15) = O (cid:0) 1
(cid:1) for the average of parameters. The algorithm
essentially uses the last iterations gradient as a predictor for the next iteration’s gradient. This
follows from the intuition that if the opponent in the game is using a stable (or regularized) algorithm,
then the gradients between the two iterations will not change much. Later Syrgkanis et al. (2015)
showed that this intuition extends to show faster convergence of each individual player’s regret in
general normal form games.

T

Given these favorable properties of OMD when learning in games, we propose replacing GD with
OMD when training WGANs. The update rule of a OMD is a small adaptation to GD. OMD is
parameterized by a predictor of the next iteration’s gradient which could either be simply last itera-
tion’s gradient or an average of a window of last gradient or a discounted average of past gradients.
In the case where the predictor is simply the last iteration gradient, then the update rule for OMD
boils down to the following simple form:

wt+1 = wt + 2η · ∇w,t − η · ∇w,t−1
θt+1 = θt − 2η · ∇θ.t + η · ∇θ,t−1

The simple modiﬁcation in the GD update rule, is inherently different than any of the existing adap-
tations used in GAN training, such as Nesterov’s momentum, or gradient penalty.

General OMD and intuition. The intuition behind OMD can be more easily understood when
GD is viewed through the lens of the Follow-the-Regularized-Leader formulation. In particular,
it is well known that GD is equivalent to the Follow-the-Regularized-Leader algorithm with an (cid:96)2
regularizer (see e.g. Shalev-Shwartz (2012)), i.e.:

wt+1 = arg max

η

(cid:104)w, ∇w,τ (cid:105) − (cid:107)w(cid:107)2
2

θt+1 = arg min

η

(cid:104)θ, ∇θ,τ (cid:105) + (cid:107)θ(cid:107)2
2

t
(cid:88)

τ =1
t
(cid:88)

τ =1

w

θ

It is known that if the learner knew in advance the gradient at the next iteration, then by adding that
to the above optimization would lead to constant regret that comes solely from the regularization
term1. OMD essentially augments FTRL by adding a predictor Mt+1 of the next iterations gradient,
i.e.:

wt+1 = arg max

η

(cid:104)w, ∇w,τ (cid:105) + (cid:104)w, Mw,t+1(cid:105)

θt+1 = arg min

η

(cid:104)θ, ∇θ,τ (cid:105) + (cid:104)θ, Mθ,t+1(cid:105)

(cid:32) t

(cid:88)

τ =1

(cid:32) t

(cid:88)

τ =1

w

θ

(cid:33)

− (cid:107)w(cid:107)2
2

(cid:33)

+ (cid:107)θ(cid:107)2
2

wt+1 = wt + η · (∇w,t + Mw,t+1 − Mw,t)
θt+1 = θt − η · (∇θ,t + Mθ,t+1 − Mθ,t)

For an arbitrary set of predictors, the latter boils down to the following set of update rules:

In the theoretical part of the paper we will focus on the case where the predictor is simply the last
iteration gradient, leading to update rules in Equation (5). In the experimental section we will also
explore performance of other alternatives for predictors.

2.2 STOCHASTIC GRADIENT DESCENT AND STOCHASTIC OPTIMISTIC MIRROR DESCENT

In practice we don’t really have access to the true distribution Q and hence we replace Q with an
empirical distribution Qn over samples {x1, . . . , xn} and Fn of random noise samples {z1, . . . , zn},
leading to empirical loss for the zero-sum game of:

Ln(θ, w) = Ex∼Qn [Dw(x)] − Ez∼Fn [Dw(Gθ(z))]
Even in this setting it might be impractical to compute the gradient of the expected loss with respect
to Qn or Fn, e.g. Ex∼Qn [∇wDw(x)].

(9)

1The latter is a consequence of the be-the-leader lemma Kalai & Vempala (2005); Rigollet (2015)

4

(5)

(6)

(7)

(8)

(10)

(11)

(12)

(13)

However, GD and OMD still leads to small loss if we replace gradients with unbiased estimators
of them. Hence, we can replace expectation with respect to Qn or Fn, by simply evaluating the
gradients at a single sample or on a small batch of B samples. Hence, we can replace the gradients
at each iteration with the variants:
1
|B|

(∇wDwt(xi) − ∇wDwt(Gθt(zi)))

ˆ∇w,t =

(cid:88)

ˆ∇θ,t = −

∇θ(Dwt(Gθt(zi)))

i∈B
1
|B|

(cid:88)

i∈B

Replacing ∇w,t and ∇θ,t with the above estimates in Equation (4) and (5), leads to Stochastic
Gradient Descent (SGD) and Stochastic Optimistic Mirror Decent (SOMD) correspondingly.

3 AN ILLUSTRATIVE EXAMPLE: LEARNING THE MEAN OF A DISTRIBUTION

We consider the following very simple WGAN example: The data are generated by a multivariate
normal distribution, i.e. Q (cid:44) N (v, I) for some v ∈ Rd. The goal is for the generator to learn
the unknown parameter v. In Appendix C we also consider a more complex example where the
generator is trying to learn a co-variance matrix.

We consider a WGAN, where the discriminator is a linear function and the generator is a simple
additive displacement of the input noise z, which is drawn from F (cid:44) N (0, I), i.e:

Dw(x) = (cid:104)w, x(cid:105)
Gθ(z) = z + θ

The goal of the generator is to ﬁgure out the true distribution, i.e. to converge to θ = v. The WGAN
loss then takes the simple form:

L(θ, w) = Ex∼N (v,I) [(cid:104)w, x(cid:105)] − Ez∼N (0,I) [(cid:104)w, z + θ(cid:105)]

We ﬁrst consider the case where we optimize the true expectations above rather than assuming that
we only get samples of x and samples of z. Due to linearity of expectation, the expected zero-sum
game takes the form:

inf
θ

sup
w

(cid:104)w, v − θ(cid:105)

We see here that the unique equilibrium of the above game is for the generator to choose θ = v and
for the discriminator to choose w = 0. For this simple zero sum game, we have ∇w,t = v − θt and
∇θ,t = −wt. Hence, the GD dynamics take the form:

wt+1 =wt + η(v − θt)
θt+1 =θt + ηwt

(GD Dynamics for Learning Means)

while the OMD dynamics take the form:

wt+1 =wt + 2η · (v − θt) − η · (v − θt−1)
θt+1 =θt + 2η · wt − η · wt−1

(OMD Dynamics for Learning Means)

We simulated simultaneous training in this zero-sum game under the GD and under OMD dynamics
and we ﬁnd that GD dynamics always lead to a limit cycle irrespective of the step size or other
modiﬁcations. In Figure 1 we present the behavior of the GD vs OMD dynamics in this game for
v = (3, 4). We see that even though GD dynamics leads to a limit cycle (whose average does indeed
equal to the true vector), the OMD dynamics converge to v in terms of the last iterate. In Figure 2
we see that the stability of OMD even carries over to the case of Stochastic Gradients, as long as the
batch size is of decent size.

In the appendix we also portray the behavior of the GD dynamics even when we add gradient penalty
(Gulrajani et al., 2017) to the game loss (instead of weight clipping), adding Nesterov momentum to
the GD update rule (Nesterov, 1983) or when we train the discriminator multiple times in between a
train iteration of the generator. We see that even though these modiﬁcations do improve the stability

5

(a) GD dynamics.

(b) OMD dynamics.

Figure 1: Training GAN with GD converges to a limit cycle that oscilates around the equilibrium (we applied
weight-clipping at 10 for the discriminator). On the contrary training with OMD converges to equilibrium in
terms of last-iterate convergence.

(a) Stochastic OMD dynamics with mini-batch of 50.

(b) Stochastic OMD dynamics with mini-batch of 200.

Figure 2: Robustness of last-iterate convergence of OMD to stochastic gradients.

of the GD dynamics, in the sense that they narrow the band of the limit cycle, they still lead to a
non-vanishing limit cycle, unlike OMD.

In the next section, we will in fact prove formally that for a large class of zero-sum games including
the one presented in this section, OMD dynamics converge to equilibrium in the sense of last-iterate
convergence, as opposed to average-iterate convergence.

4 LAST-ITERATE CONVERGENCE OF OPTIMISTIC ADVERSARIAL TRAINING

In this section, we show that Optimistic Mirror Descent exhibits ﬁnal-iterate, rather than only
average-iterate convergence to min-max solutions for bilinear functions. More precisely, we con-
sider the problem minx maxy xT Ay, for some matrix A, where x and y are unconstrained.
In
Appendix D, we also show that our convergence result appropriately extends to the general case,
where the bi-linear game also contains terms that are linear in the players’ individual strategies,
i.e. games of the form:

(cid:0)xT Ay + bT x + cT y + d(cid:1) .

inf
x

sup
y

In the simpler minx maxy xT Ay problem, Optimistic Mirror Descent takes the following form, for
all t ≥ 1:

xt = xt−1 − 2ηAyt−1 + ηAyt−2
yt = yt−1 + 2ηAT xt−1 − ηAT xt−2

Initialization: For the above iteration to be meaningful we need to specify x0, x−1, y0, y−1. We
choose any x0 ∈ R(A), and y0 ∈ R(AT ), and set x−1 = 2x0 and y−1 = 2y0, where R(·)
represents the column space of A. In particular, our initialization means that the ﬁrst step taken by
the dynamics gives x1 = x0 and y1 = y0.

We will analyze Optimistic Mirror Descent under the assumption λ∞ ≤ 1, where λ∞ =
max{||A||, ||AT ||} and || · || denotes spectral norm of matrices. We can always enforce that λ∞ ≤ 1
by appropriately scaling A. Scaling A by some positive factor clearly does not change the min-max
solutions (x∗, y∗), only scales the optimal value x∗T Ay∗ by the same factor.

We remark that the set of equilibrium solutions of this minimax problem are pairs (x, y) such that
x is in the null space of AT and y is in the null space of A. In this section we rigorously show
that Optimistic Mirror Descent converges to the set of such min-max solutions. This is interesting
in light of the fact that Gradient Descent actually diverges, even in the special case where A is the
identity matrix, as per the following proposition whose proof is provided in Appendix D.3.

(14)

(15)

(16)

6

Proposition 1. Gradient descent applied to the problem minx maxy xT y diverges starting from any
initialization x0, y0 such that x0, y0 (cid:54)= 0.

Next, we state our main result of this section, whose proof can be found in Appendix D, where we
also state its appropriate generalization to the general case (14).

Theorem 1 (Last Iterate Convergence of OMD). Consider the dynamics of Eq. (15) and (16) and
any initialization 1

2 x−1 = x0 ∈ R(A), and 1

2 y−1 = y0 ∈ R(AT ). Let also
(cid:0)AAT (cid:1)+(cid:13)
(cid:13)
(cid:13)
(cid:13)
(cid:13) ,
(cid:13)

γ =

where for a matrix X we denote by X + its generalized inverse and by ||X|| its spectral norm.
Suppose that (cid:107)A(cid:107) ≡ λ∞ ≤ 1 and that η is a small enough constant satisfying η < 1/(3γ2). Letting
∆t = (cid:12)
(cid:12)

2, the OMD dynamics satisfy the following:

(cid:12)
2
2 + ||Ayt||2
(cid:12)

(cid:12)
(cid:12)AT xt

(cid:12)
(cid:12)

∆1 = ∆0 ≥

(cid:18)

1
(1 + η)2 ∆2
η2
γ2

(cid:19)

∀t ≥ 3 : ∆t ≤

1 −

∆t−1 + 16η3∆0.

√

√

In particular, ∆t → O(ηγ2∆0), as t → +∞, and for large enough t, the last iterate of OMD is
within O(
∆0 is the
distance of the initial point (x0, y0) from the equilibrium space, and where both distances are taken
with respect to the norm (cid:112)xT AAT x + yT AT Ay.

∆0) distance from the space of equilibrium points of the game, where

η · γ

√

5 EXPERIMENTAL RESULTS FOR GENERATING DNA SEQUENCES

We take our theoretical intuition to practice, applying OMD to the problem of generating DNA
sequences from an observed distribution of sequences. DNA sequences that carry out the same
function can be viewed as samples from some distribution. For many important cellular functions,
this distribution can be well modeled by a position-weight matrix (PWM) that speciﬁes the proba-
bility of different nucleotides occuring at each position (Stormo, 2000). Thus, training GANs from
DNA sequences sampled from a PWM distribution serves as a practically motivated problem where
we know the ground truth and can thus quantify the performance of different training methods in
terms of the KL divergence between the trained generator distribution and the true distribution.

In our experiments, we generated 40,000 DNA sequences of six nucleotides according to a given
position weight matrix. A random 10% of the sequences were held out as the validation set. Each
sequence was then embedded into a 4 × 6 matrix by encoding each of the four nucleotides with an
one-hot vector. On this dataset, we trained WGANs with different variants of OMD and SGD and
evaluated their performance in terms of the KL divergence between the empirical distribution of the
WGAN-generated samples and the true distribution described by the position weight matrix. Both
the discriminator and generator of the WGAN used in this analysis were chosen to be convolutional
neural networks (CNN), given the recent success of CNNs in modeling DNA-protein binding (Zeng
et al., 2016; Alipanahi et al., 2015). The detailed structure of the chosen CNNs can be found in
Appendix E.

To account for the impact of learning rate and training epochs, we explored two different ways
of model selection when comparing different optimization strategies: (1) using the iteration and
learning rate that yields the lowest discriminator loss on the held out test set. This is inspired by
the observation in Arjovsky et al. (2017) that the discriminator loss negatively correlates with the
quality of the generated samples. (2) using the model obtained after the last epoch of the training.
To account for the stochastic nature of the initialization and optimizers, we trained 50 independent
models for each learning rate and optimizer, and compared the optimizer strategies by the resulting
distribution of KL divergences across 50 runs.

For GD, we used variants of Equation (4) to examine the effect of using momentum and an adaptive
step size. Speciﬁcally, we considered momentum, Nesterov momentum and Adagrad. The speciﬁc
form of all these modiﬁcations is given for reference in Appendix A.

7

For OMD we used the general predictor version of Equation (10) with a ﬁxed step size and with the
following variants of the next iteration predictor Mt+1: (v1) Last iteration gradient: Mt+1 = ∇ft,
(v2) Running average of past gradients: Mt+1 = 1
i=1 ∇fi, (v3) Hyperbolic discounted average
t
of past gradients: Mt+1 = λMt + (1 − λ)∇ft, λ ∈ (0, 1). We explored two training schemes: (1)
training the discriminator 5 times for each generator training as suggest in Arjovsky et al. (2017).
(2) training the discriminator once for each generator training. The latter is inline with the intuition
behind the use of optimism: optimism hinges on the fact that the gradient at the next iteration is very
predictable since it is coming from another regularized algorithm, and if we train the other algorithm
multiple times, then the gradient is not that predictable and the beneﬁts of optimism are lost.

(cid:80)t

(a) WGAN with the lowest validation discriminator loss

(b) WGAN at the last epoch

Figure 3: KL divergence of WGAN trained with different optimization strategies. Methods are ordered by the
median KL divergence. Methods in (a) are named by the category and version of the method. “ratio 1” denotes
training the discriminator once for every generator training. Otherwise, we performed 5 iterations. For (b)
where we don’t combine the models trained with different learning rates, the learning rate is appended at the
end of the method name. For momentum and Nesterov momentum, we used γ = 0.9. For Adagrad, we used
the default (cid:15) = 1e−8.

For all afore-described algorithms, we experimented with their stochastic variants. Figure 3 shows
the KL divergence between the WGAN-generated samples and the true distribution. When evaluated
by the epoch and learning rate that yields the lowest discriminator loss on the validation set, WGAN
trained with Stochastic OMD (SOMD) achieves lower KL divergence than the competing SGD
variants. Evaluated by the last epoch, the best performance across different learning rates is achieved
by optimistic Adam (see Section 6). We note that in both metrics, SOMD with 1:1 generator-
discriminator training ratio yields better KL divergence than the alternative training scheme (1:5
ratio), which validates the intuition behind the use of optimism.

6 GENERATING IMAGES FROM CIFAR10 WITH OPTIMISTIC ADAM
In this section we applying optimistic WGAN training to generating images, after training on CI-
FAR10. Given the success of Adam on training image WGANs we will use an optimistic version
of the Adam algorithm, rather than vanilla OMD. We denote the latter by Optimistic Adam. Opti-
mistic Adam could be of independent interest even beyond training WGANs. We present Optimistic
Adam for (G) but the analog is also used for training (D). We trained on CIFAR10 images with

Algorithm 1 Optimistic ADAM, proposed algorithm for training WGANs on images.

Parameters: stepsize η, exponential decay rates for moment estimates β1, β2 ∈ [0, 1), stochastic
loss as a function of weights (cid:96)t(θ), initial parameters θ0
for each iteration t ∈ {1, . . . , T } do

Compute stochastic gradient: ∇θ,t = ∇θ(cid:96)t(θ)
Update biased estimate of ﬁrst moment: mt = β1mt−1 + (1 − β1) · ∇θ,t
Update biased estimate of second moment: vt = β2vt−1 + (1 − β2) · ∇2
θ,t
Compute bias corrected ﬁrst moment: ˆmt = mt/(1 − βt
1)
Compute bias corrected second moment: ˆvt = vt/(1 − βt
2)
Perform optimistic gradient step: θt = θt−1 − 2η ·
+ η

ˆmt−1√

ˆmt√

ˆvt+(cid:15)

ˆvt−1+(cid:15)

Return θT

Optimistic Adam with the hyper-parameters matched to Gulrajani et al. (2017), and we observe that

8

it outperforms Adam in terms of inception score (see Figure 14), a standard metric of quality of
WGANs (Gulrajani et al., 2017; Salimans et al., 2016). In particular we see that optimistic Adam
achieves high numbers of inception scores after very few epochs of training. We observe that for
Optimistic Adam, training the discriminator once after one iteration of the generator training, which
matches the intuition behind the use of optimism, outperforms the 1:5 generator-discriminator train-
ing scheme. We see that vanilla Adam performs poorly when the discriminator is trained only once
in between iterations of the generator training. Moreover, even if we use vanilla Adam and train 5
times (D) in between a training of (G), as proposed by Arjovsky et al. (2017), then performance is
again worse than Optimistic Adam with a 1:1 ratio of training. The same learning rate 0.0001 and
betas (β1 = 0.5, β2 = 0.9) as in Appendix B of Gulrajani et al. (2017) were used for all the methods
compared. We also matched other hyper-parameters such as gradient penalty coefﬁcient λ and batch
size. For a larger sample of images see Appendix G.

(a) Inception score on CIFAR10, when training with Adam and Optimistic
Adam. “ratio1” means we performed 1 iteration of training of (D) in be-
tween 1 iteration of (G). Otherwise we performed 5 iterations. We further
test (averaging over 35 trials) the two top-performing optimizers, Adam
(ratio 5) and Optimistic Adam with ratio 1, in Appendix H.

(b) Sample of images from Gen-
erator of Epoch 94, which had
the highest inception score.

Figure 4: Comparison of Adam and Optimistic Adam on CIFAR10.

REFERENCES

Babak Alipanahi, Andrew Delong, Matthew T Weirauch, and Brendan J Frey. Predicting the se-
quence speciﬁcities of dna-and rna-binding proteins by deep learning. Nature biotechnology, 33
(8):831–838, 2015.

Martin Arjovsky, Soumith Chintala, and L´eon Bottou. Wasserstein gan.

arXiv preprint

arXiv:1701.07875, 2017.

Yoav Freund and Robert E. Schapire. Game theory, on-line prediction and boosting. In Proceedings
of the Ninth Annual Conference on Computational Learning Theory, COLT ’96, pp. 325–332,
New York, NY, USA, 1996. ACM. ISBN 0-89791-811-8. doi: 10.1145/238061.238163. URL
http://doi.acm.org/10.1145/238061.238163.

Yoav Freund and Robert E. Schapire. Adaptive game playing using multiplicative weights. Games
and Economic Behavior, 29(1):79 – 103, 1999. ISSN 0899-8256. doi: https://doi.org/10.1006/
game.1999.0738. URL http://www.sciencedirect.com/science/article/pii/
S0899825699907388.

Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair,
Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In Z. Ghahramani, M. Welling,
C. Cortes, N. D. Lawrence, and K. Q. Weinberger (eds.), Advances in Neural Information Pro-
cessing Systems 27, pp. 2672–2680. Curran Associates, Inc., 2014. URL http://papers.
nips.cc/paper/5423-generative-adversarial-nets.pdf.

Ian J. Goodfellow. NIPS 2016 tutorial: Generative adversarial networks. CoRR, abs/1701.00160,

2017. URL http://arxiv.org/abs/1701.00160.

9

Ishaan Gulrajani, Faruk Ahmed, Mart´ın Arjovsky, Vincent Dumoulin, and Aaron C. Courville. Im-
proved training of wasserstein gans. CoRR, abs/1704.00028, 2017. URL http://arxiv.
org/abs/1704.00028.

Adam Kalai and Santosh Vempala. Efﬁcient algorithms for online decision problems. Journal
of Computer and System Sciences, 71(3):291 – 307, 2005. ISSN 0022-0000. doi: https://doi.
org/10.1016/j.jcss.2004.10.016. URL http://www.sciencedirect.com/science/
article/pii/S0022000004001394. Learning Theory 2003.

Panayotis Mertikopoulos, Christos Papadimitriou, and Georgios Piliouras. Cycles in adversarial

regularized learning. arXiv preprint arXiv:1709.02738, 2017.

Yurii Nesterov. A method of solving a convex programming problem with convergence rate o (1/k2).

In Soviet Mathematics Doklady, volume 27, pp. 372–376, 1983.

Alexander Rakhlin and Karthik Sridharan. Online learning with predictable sequences. In COLT,

pp. 993–1019, 2013a.

Alexander Rakhlin and Karthik Sridharan. Optimization, learning, and games with predictable se-
quences. In Proceedings of the 26th International Conference on Neural Information Process-
ing Systems - Volume 2, NIPS’13, pp. 3066–3074, USA, 2013b. Curran Associates Inc. URL
http://dl.acm.org/citation.cfm?id=2999792.2999954.

Philippe Rigollet. Mit 18.657: Mathematics of machine learning, lecture 16. 2015.

Tim Salimans, Ian Goodfellow, Wojciech Zaremba, Vicki Cheung, Alec Radford, and Xi Chen.
Improved techniques for training gans. In Advances in Neural Information Processing Systems,
pp. 2234–2242, 2016.

Shai Shalev-Shwartz. Online learning and online convex optimization. Found. Trends Mach. Learn.,
4(2):107–194, February 2012. ISSN 1935-8237. doi: 10.1561/2200000018. URL http://dx.
doi.org/10.1561/2200000018.

Gary D Stormo. Dna binding sites: representation and discovery. Bioinformatics, 16(1):16–23,

2000.

Vasilis Syrgkanis, Alekh Agarwal, Haipeng Luo, and Robert E Schapire. Fast convergence of regu-
larized learning in games. In Advances in Neural Information Processing Systems, pp. 2989–2997,
2015.

Haoyang Zeng and David K Gifford. Predicting the impact of non-coding variants on dna methyla-

tion. Nucleic Acids Research, 2017.

Haoyang Zeng, Tatsunori Hashimoto, Daniel D Kang, and David K Gifford. Gerv: a statistical
method for generative evaluation of regulatory variants for transcription factor binding. Bioinfor-
matics, 32(4):490–496, 2015.

Haoyang Zeng, Matthew D Edwards, Ge Liu, and David K Gifford. Convolutional neural network

architectures for predicting dna–protein binding. Bioinformatics, 32(12):i121–i127, 2016.

10

A VARIANTS OF GD TRAINING

For ease of reference we brieﬂy describe the exact form of update rules for several modiﬁcations of
GD training that we have used in our experimental results.

Adagrad:

Momentum:

ηw,t =

(cid:113)(cid:80)t

η

i=1 ∇2

w,i + (cid:15)

ηθ,t =

(cid:113)(cid:80)t

η

i=1 ∇2

θ,i + (cid:15)

wt+1 = wt + ηw,t · ∇w,t

θt+1 = θt − ηθ,t · ∇θ,t

vw,t+1 = γ · vw,t + η · ∇w,t

vθ,t+1 = γ · vθ,t + η · ∇θ,t

wt+1 = wt + vw,t+1

θt+1 = θt − vθ,t+1

Nesterov momentum:

wahead = wt + γ · vw,t
vw,t+1 = γ · vw,t + η · ∇wL(θt, wahead)

θahead = θt − γ · vθ,t
vθ,t+1 = γ · vθ,t + η · ∇θL(θahead, wt)

(19)

wt+1 = wt + vw,t+1

θt+1 = θt − vθ,t+1

B PERSISTENCE OF LIMIT CYCLES IN GD TRAINING

In Figure 5 we portray example Gradient Descent dynamics in the illustrative example described in
Section 3 under multiple adaptations proposed in the literature. We observe that oscillations persist
in all such modiﬁed GD dynamics, though alleviated by some. We brieﬂy describe the modiﬁcations
in detail ﬁrst.

Gradient penalty. The Wasserstein GAN is based on the idea that the discriminator is approximat-
ing all 1-Lipschitz functions of the data. Hence, when training the discriminator we need to make
sure that the function Dw(x) has a bounded gradient with respect to x. One approach to achieving
this is weight-clipping, i.e. clipping the weights to lie in some interval. However, the latter might
introduce extra instability during training. Gulrajani et al. (2017) introduce an alternative approach
by adding a penalty to the loss function of the zero-sum game that is essentially the (cid:96)2 norm of the
gradient of Dw(x) with respect to x. In particular they propose the following regularized WGAN
loss:

Lλ(θ, w) = Ex∼Q [Dw(x)] − Ez∼F [Dw(Gθ(z))] − λEˆx∼Q(cid:15)

((cid:107)∇xDw(ˆx)(cid:107) − 1)2(cid:105)
(cid:104)

where Q(cid:15) is the distribution of the random vector (cid:15)x + (1 − (cid:15))G(z) when x ∼ Q and z ∼ F . The
expectations in the latter can also be replaced with sample estimates in stochastic variants of the
training algorithms.

For our simple example, ∇xDw(x) = w. Hence, we get the gradient penalty modiﬁed WGAN:

Lλ(θ, w) = (cid:104)w, v − θ(cid:105) − λ ((cid:107)w(cid:107) − 1)2

Hence, the gradient of the modiﬁed loss function with respect to θ remains unchanged, but the
gradient with respect to w becomes:

∇wt = v − θt − 2λwt

(cid:107)wt(cid:107)2 − 1
(cid:107)wt(cid:107)2

Momentum. GD with momentum was deﬁned in Equation (18). For the case of the simple illus-
trative example, these dynamics boil down to:

mw,t+1 =γ · mw,t + η · (v − θt)

wt+1 =wt + mw,t+1

mθ,t+1 =γ · mθ,t − η · wt
θt+1 =θt − mθ,t+1

(17)

(18)

(20)

(21)

(22)

11

Nesterov momentum. GD with Nesterov’s momentum was deﬁned in Equation (19). For the
illustrative example, we see that Nesterov’s momentum is identical to momentum in the absence of
gradient penalty. The reason being that the function is bi-linear. However, with a gradient penalty,
Nesterov’s momentum boils down to the following update rule.

ˆwt =wt + γ · mw,t

mw,t+1 =γ · mw,t + η · (v − θt) − 2η · λ ˆwt

mθ,t+1 =γ · mw,t − η · wt

(23)

(cid:107) ˆwt(cid:107)2 − 1
(cid:107) ˆwt(cid:107)2

wt+1 =wt + mw,t+1

θt+1 =θt − mθ,t+1

Asymmetric training. Another approach to reducing cycling is to train the discriminator more
frequently than the generator. Observe that if we could exactly solve the supremum problem of
the discriminator after every iteration of the generator, then the generator would be simply solving a
convex minimization problem and GD should converge point-wise. The latter approach could lead to
slow convergence given the ﬁniteness of samples in the case of stochastic training. Hence, we cannot
really afford completely solving the discriminators problem. However, training the discriminator for
multiple iterations, brings the problem faced by the generator closer to convex minimization rather
than solving an equilibrium problem. Hence, asymmetric training could help with cycling. We
observe below that asymmetric training is the most effective modiﬁcation in reducing the range of
the cycles and hence making the last-iterate be close to the equilibrium. However, it does not really
eliminate the cycles, rather it simply makes their range smaller.

12

(a) GD dynamics with a gradient penalty added to the loss. η = 0.1 and λ = 0.1.

(b) GD dynamics with momentum. η = 0.1 and γ = 0.5.

(c) GD dynamics with momentum and gradient penalty. η = .1, γ = 0.2 and λ = 0.1.

(d) GD dynamics with momentum and gradient penalty, training generator every 15 training iterations of the
discriminator. η = .1, γ = 0.2 and λ = 0.1.

(e) GD dynamics with Nesterov momentum and gradient penalty, training generator every 15 training iterations
of the discriminator. η = .1, γ = 0.2 and λ = 0.1.

Figure 5: Persistence of limit cycles in multiple variants of GD training.

13

C ANOTHER EXAMPLE: LEARNING A CO-VARIANCE MATRIX

We demonstrate the beneﬁts of using OMD over GD in another simple illustrative example. In this
case, the example is does not boil down to a bi-linear game and therefore, the simulation results
portray that the theoretical results we provided for bi-linear games, carry over qualitatively beyond
the linear case.

Consider the case where the data distribution is a mean zero multi-variate normal with an unknown
co-variance matrix, i.e., x ∼ N (0, Σ). We will consider the case where the discriminator is the set
of all quadratic functions:

The generator is a linear function of the random input noise z ∼ N (0, I), of the form:

DW (x) =

Wijxixj = xT W x

(cid:88)

ij

GV (z) = V z

The parameters W and V are both d × d matrices. The WGAN game loss associated with these
functions is then:

L(V, W ) = Ex∼N (0,Σ)

(cid:2)xT W x(cid:3) − Ez∼N (0,I)

(cid:2)zT V T W V z(cid:3)

Expanding the latter we get:

L(V, W ) =Ex∼N (0,Σ)

Wijxixj









(cid:88)

ij

(cid:88)

ij


 − Ez∼N (0,I)






 − Ez∼N (0,I)





(cid:88)

ij

(cid:88)

ijkm

(cid:88)

Wij

Vikzk

k



Vjmzm



(cid:88)

m

WijVikVjmzkzm





=Ex∼N (0,Σ)

Wijxixj

WijEx∼N (0,Σ) [xixj] −

WijVikVjmEz∼N (0,I) [zkzm]

(cid:88)

ijkm

(cid:88)

ij
(cid:88)

ij
(cid:88)

=

=

=

ij

ij

(cid:88)

=

WijΣij −

WijVikVjm1{k = m}

(cid:88)

ijkm
(cid:88)

ijk

WijΣij −

WijVikVjk

(cid:32)

(cid:33)

Wij

Σij −

VikVjk

(cid:88)

k

Given that the covariance matrix is symmetric positive deﬁnite, we can write it as Σ = U U T . Then
the loss simpliﬁes to:

L(V, W ) =

Wij

Σij −

VikVjk

=

Wij (UikUjk − VikVjk)

(27)

(cid:88)

ij

(cid:32)

(cid:33)

(cid:88)

k

(cid:88)

ijk

The equilibrium of this game is for the generator to choose Vik = Uik for all i, k, and for the
discriminator to pick Wij = 0. For instance, in the case of a single dimension we have L(V, W ) =
W · (σ2 − V 2), where σ2 is the variance of the Gaussian. Hence, the equilibrium is for the generator
to pick V = σ and the discriminator to pick W = 0.

Dynamics without sampling noise. For the mean GD dynamics the update rules are as follows:

(24)

(25)

(26)

(28)

W t

ij =W t−1

ij + η

Σij −

ik V t−1
V t−1

jk

(cid:88)

k

ij =V t−1
V t

ij + η

(cid:0)W t−1

ik + W t−1

ki

(cid:1) V t−1

kj

(cid:33)

(cid:32)

(cid:88)

k

14

We can write the latter updates in a simpler matrix form:

Wt =Wt−1 + η (cid:0)Σ − Vt−1V T
Vt =Vt−1 + η(Wt−1 + W T

t−1
t−1)Vt−1

(cid:1)

Similarly the OMD dynamics are:

(GD for Covariance)

Wt =Wt−1 + 2η (cid:0)Σ − Vt−1V T
Vt =Vt−1 + 2η(Wt−1 + W T

(cid:1) − η (cid:0)Σ − Vt−2V T
t−1
t−2
t−1)Vt−1 − η(Wt−2 + W T

(cid:1)

t−2)Vt−2

(OMD for Covariance)

Due to the non-convexity of the generators problem and because there might be multiple optimal
solutions (e.g. if Σ is not strictly positive deﬁnite), it is helpful in this setting to also help dynamics
by adding (cid:96)2 regularization to the loss of the game. The latter simply adds an extra 2λWt at each
gradient term ∇W L(Vt, Wt) for the discriminator and a 2λVt at each gradient term ∇V L(Vt, Wt)
for the generator. In Figures 7 and 6 we give the weights and the implied covariance matrix ΣG =
V V T of the generator’s distribution for each of the dynamics for an example setting of the step-size
and regularization parameters and for two and three dimensional gaussians respectively. We again
see how OMD can stabilize the dynamics to converge pointwise.

Stochastic dynamics.
In Figure 8 and 9 we also portray the instability of GD and the robustness
of the stability of OMD under stochastic dynamics. In the case of stochastic dynamics the gradients
are replaced with unbiased estimates or with averages of unbiased estimates over a small minibatch.
In the case of a mini-batch of one, the unbiased estimates of the gradients in this setting take the
following form:

ˆ∇W,t = xtxT

t − VtztzT

t V T
t
t )VtztzT
t
where xt, zt are samples drawn from the true distribution and from the random noise distribution
respectively. Hence, the stochastic dynamics simply follow by replacing gradients with unbiased
estimates:

ˆ∇V,t = −(Wt + W T

(Stochastic Gradients)

Wt =Wt−1 + η ˆ∇W,t−1
Vt =Vt−1 − η ˆ∇V,t−1
Wt =Wt−1 + 2η ˆ∇W,t−1 − η ˆ∇W,t−2
Vt =Vt−1 − 2η ˆ∇V,t−1 + η ˆ∇V,t−2

(SGD for Covariance)

(SOMD for Covariance)

15

(a) GD dynamics. η = 0.1, T = 500, λ = 0.3.

(b) OMD dynamics. η = 0.1, T = 500, λ = 0.3.

Figure 6: Stability of OMD vs GD in the co-variance learning problem for a two-dimensional gaussian (d = 2).
Weight clipping in [−1, 1] was applied in both dynamics.

(a) GD dynamics. η = 0.1, T = 500, λ = 0.3.

(b) OMD dynamics. η = 0.1, T = 500, λ = 0.3.

Figure 7: Stability of OMD vs GD in the co-variance learning problem for a three-dimensional gaussian (d =
3). Weight clipping in [−1, 1] was applied in both dynamics.

16

(a) Stochastic GD dynamics with mini-batch size 50. η = 0.02, T = 1000, λ = 0.1.

(b) True Distribution (c) Iterate T − 50

(d) Iterate T − 35

(e) Iterate T − 20

(f) Iterate T

(g) Comparison of true distribution and distribution of generator at various points closer to the end of training.

Figure 8: Stochastic GD dynamics for covariance learning of a two-dimensional gaussian (d = 2). Weight
clipping in [−1, 1] was applied to the discriminator weights.

(a) Stochastic OMD dynamics with mini-batch size 50. η = 0.02, T = 1000, λ = 0.1.

(b) True Distribution (c) Iterate T − 50

(d) Iterate T − 35

(e) Iterate T − 20

(f) Iterate T

(g) Comparison of true distribution and distribution of generator at various points closer to the end of training.

Figure 9: Stability of OMD with stochastic gradients for covariance learning of a two-dimensional gaussian
(d = 2). Weight clipping in [−1, 1] was applied to the discriminator weights.

17

(29)

(30)

(31)

(32)

D LAST ITERATE CONVERGENCE OF OMD IN BILINEAR CASE

The goal of this section is to show that Optimistic Mirror Descent exhibits last iterate convergence
to min-max solutions for bilinear functions. In Section D.1, we provide the proof of Theorem 1, that
OMD exhibits last iterate convergence to min-max solutions of the following min-max problem

where A is an abitrary matrix and x and y are unconstrained. In Section D.2, we state the appropriate
extension of our theorem to the general case:

min
x

max
y

xT Ay,

(cid:0)xT Ay + bT x + cT y + d(cid:1) .

inf
x

sup
y

D.1 PROOF OF THEOREM 1

As stated in Section 4, for the min-max problem (29) Optimistic Mirror Descent takes the following
form, for all t ≥ 1:

xt = xt−1 − 2ηAyt−1 + ηAyt−2
yt = yt−1 + 2ηAT xt−1 − ηAT xt−2

where for the above iterations to be meaningful we need to specify x0, x−1, y0, y−1.

As stated in Section 4 we allow any initialization x0 ∈ R(A), and y0 ∈ R(AT ), and set x−1 = 2x0
and y−1 = 2y0, where R(·) represents column space. In particular, our initialization means that the
ﬁrst step taken by the dynamics gives x1 = x0 and y1 = y0.
Before giving our proof of Theorem 1, we need some further notation. For all i ∈ N, we set:

t = ||NiAyt||2

Mi = Aj(AT A)k, Ni = (cid:0)AT (cid:1)j (cid:0)AAT (cid:1)k
(cid:12)
(cid:12)MiAT xt
∆i

2 + (cid:12)
(cid:12)
where k ∈ Z and j ∈ {0, 1} are such that: i = 2k + j.
(cid:12)
t = (cid:12)
(cid:12)AT xt
(cid:12)
(cid:12)
(cid:12)
(cid:12)
2
(cid:12)AAT Ayt
2, etc.
(cid:12)
(cid:12)

2 + ||Ayt||2

(cid:12)
(cid:12)AAT xt

t = (cid:12)
(cid:12)

2, ∆1

2
2

(cid:12)
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2

2

2

(cid:12)
(cid:12)

2 + (cid:12)
(cid:12)

With this notation, ∆0
(cid:12)
(cid:12)
(cid:12)
(cid:12)AT AAT xt
(cid:12)
(cid:12)
We also use the notation (cid:104)u, v(cid:105)X = uT XX T v, for vectors u, v ∈ Rd and square d × d matrices
X. We similarly deﬁne the norm notation ||u||X = (cid:112)(cid:104)u, u(cid:105)X . Given our notation, we have the
following claim, shown in Appendix D.3.
Claim 1. For all matrices A and vectors u, v of the appropriate dimensions:

2, ∆2

t =

2 + (cid:12)
(cid:12)

(cid:12)
(cid:12)AT Ayt

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2

(cid:104)Au, Av(cid:105)AM T

= (cid:104)u, v(cid:105)AT N T

i

; (cid:104)AT u, AT v(cid:105)AT N T

i

i+1

= (cid:104)u, v(cid:105)AM T

; (cid:104)u, Av(cid:105)AM T

i+1

= (cid:104)v, AT u(cid:105)AT N T

.

i

i

With our notation in place, we show (through iterated expansion of the update rule), the following
lemma, proved in Appendix D.3:
Lemma 2. For the dynamics of Eq. (31) and (32) and any initialization 1
2 y−1 = y0 ∈ R(AT ) we have the following for all i, t ∈ N such that i ≥ 0 and t ≥ 2:
1
t−2 − 2η3 (cid:16)

2 x−1 = x0 ∈ R(A), and

− (cid:104)yt−2, AT xt−4(cid:105)AT N T

(cid:104)xt−2, Ayt−4(cid:105)AM T

t−1 = 4η2∆i+1

t−1 − 5η2∆i+1

t − ∆i

∆i

(cid:17)

.

i+1

i+1

We are ready to prove Theorem 1.
Corollary 7.
Theorem 3. Consider the dynamics of Eq. (31) and (32) and any initialization 1
and 1

2 y−1 = y0 ∈ R(AT ). Let

Its proof is implied by the following stronger theorem, and

2 x−1 = x0 ∈ R(A),

γ = max

(cid:16)(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:0)AAT (cid:1)+(cid:12)
(cid:12)
(cid:12)
(cid:12) ,
(cid:12)

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:0)AT A(cid:1)+(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

(cid:17)

,

18

where for a matrix X we denote by X + its generalized inverse and by ||X|| its spectral norm.
Suppose that max{||A||, ||AT ||} ≡ λ∞ ≤ 1 and η is a small enough constant satisfying η <
1/(3γ2). Then, for all i ∈ N:

1 = ∆i
∆i
0,
2 ≤ (1 + η)2∆i
0,

∆i

and, for all i, t ∈ N such that t ≥ 3, the following condition holds:

H(i, t) : ∆i

t ≤

1 −

∆i

t−1 + 16η3∆0
0.

(cid:18)

(cid:19)

η2
γ2

Proof. Eq. (33) holds trivially as under our initialization x1 = x0 and y1 = y0. Eq. (34) is also easy
to show by noticing the following. Given our initialization:

x2 = x0 − ηAy0
y2 = y0 + ηAx0

Hence (using j = i mod 2):

MiAT x2 = MiAT x0 − ηMiAT Ay0

⇒ ||MiAT x2||2 ≤ ||MiAT x0||2 + η||MiAT Ay0||2

= ||MiAT x0||2 + η||Aj(AT )1−jNiAy0||2
≤ ||MiAT x0||2 + ηλ∞||NiAy0||2
≤ ||MiAT x0||2 + η||NiAy0||2

Similarly:

||NiAy2||2 ≤ ||NiAy0||2 + η||MiAT x0||2

It follows from (40) and (41) that

∆i

2 ≤ (1 + η)2∆i
0.

We use induction on t to prove (35). We start our proof by showing the inductive step, and postpone
establishing the basis of our induction to the end of this proof. For the inductive step, we assume
that H(i, τ ) holds for all i ≥ 0 and 1 ≤ τ < t, for some t > 3. Assuming this, we show next
that H(i, t) holds for all i. To do this, we make use of a few lemmas, whose proofs are given in
Appendix D.3.

(33)

(34)

(35)

(36)

(37)

(38)

(39)

(40)

(41)

Lemma 4. Under the conditions of the theorem, for all i ≥ 0, t ≥ 2:

∆i

t − ∆i

t−1 ≤ 4η2∆i+1

t−1 − 5η2∆i+1

t−2 + η3(∆i+1

t−2 + ∆i+1

t−4).

Lemma 5. Under the conditions of the theorem, for all i, t ≥ 0: ∆i+1

t ≤ ∆i
t.

Lemma 6. Under the conditions of the theorem, for all i ≥ 0, t ≥ 0:

∆i+2

t ≥

1
γ2 ∆i
t.

19

Given these lemmas, we show our inductive step. So for t ≥ 4:

∆i

t − ∆i

t−1 − 5η2∆i+1
t−1 + η3(∆i+1

t−2 + η3(∆i+1
t−2 + ∆i+1

t−2 + ∆i+1
t−4)
t−4) + 80η5∆0
0

t−1 + η3(∆i+1

t−2 + ∆i+1

t−4) + 80η5∆0
0

≤ −

≤ −

≤ −

t−1 ≤ 4η2∆i+1
≤ −η2∆i+1
1
γ2 η2∆i−1
1
γ2 η2∆i−1
1
γ2 η2∆i−1
1
γ2 η2∆i−1
1
γ2 η2∆i−1
1
γ2 η2∆i−1
1
γ2 η2∆i

≤ −

≤ −

≤ −

≤ −

t−1 + 16η3∆0
0

t−1 + 16η3∆0
0

t−1 + η3(∆0
(cid:18)

t−1 +

2η3∆0

t−4) + 80η5∆0
0
(cid:19)

t−2 + ∆0
2 + 2η3 γ2
η2 16η3∆0
2η3(1 + η)2 + 32η3 γ2

0

t−1 +

η2 η3 + 80η5
t−1 + (cid:0)2η3(1 + η)2 + 11η3 + 80η5(cid:1) ∆0

0

(cid:18)

+ 80η5∆0
0

(cid:19)

∆0
0

t−2 + 16η3∆0

where for the ﬁrst inequality we used Lemma 4, for the second inequality we used that ∆i+1
t−1 ≤
∆i+1
0 (which is implied by the induction hypothesis), for the third inequality we used
Lemma 6, for the fourth inequality we used Lemma 5, for the ﬁfth inequality we applied the in-
duction hypothesis iteratively, for the sixth inequality we used Eq. (34), for the seventh and eighth
inequality we used that η is small enough, and for the last inequality we used Lemma 5. Hence:

(cid:18)

∆i

t ≤

1 −

(cid:19)

η2
γ2

∆i

t−1 + 16η3∆0
0.

This completes the proof of our inductive step.
It remains to show the basis of the induction, namely that H(i, 3) holds for all i ∈ N. From Lemma 4
we have:

∆i

3 − ∆i

1 + ∆i+1
−1 )

) + 5η3∆i+1

0
0 + 5η3∆i+1

0

1 + η3(∆i+1
0 + 5η3∆i+1
0
2 − ∆i+1

2 − 5η2∆i+1
2 − 5η2∆i+1
2 + 5η2(∆i+1
0
2 + 5η3(2 + η)∆i+1
2 + 5η3(3 + η)∆i+1
2 + 15η3(1 + η/3)∆0
0

0

2 + 15η3(1 + η/3)∆0
0

2 ≤ 4η2∆i+1
≤ 4η2∆i+1
= −η2∆i+1
≤ −η2∆i+1
= −η2∆i+1
≤ −η2∆i+1
η2
γ2 ∆i−1
η2
γ2 ∆i

≤ −

≤ −

2 + 15η3(1 + η/3)∆0
0,

∆i

3 ≤

1 −

∆i

2 + 16η3∆0
0.

(cid:18)

(cid:19)

η2
γ2

20

where for the second equality we used that 0.5x−1 = x0 = x1 and 0.5y−1 = y0 = y1 (which follow
from our initialization), for the third inequality we used that (34), for the fourth inequality we used
Lemma 5, for the ﬁfth inequality we used Lemma 6, and for the last inequality we used Lemma 5.
Hence, for small enough η, we have:

(42)

(43)

(44)

(45)

(46)

(47)

(48)

(49)

(50)

(51)

(52)

(53)

(54)

(55)

(56)

(57)

(58)

Corollary 7. Under the conditions of Theorem 3, ∆0

0) as
(cid:17)
η · γ(cid:112)∆0
t → +∞. In particular, for large enough t, the last iterate of OMD is within O
distance from the space of equilibrium points of the game, where (cid:112)∆0
0 is the distance of the initial
point (x0, y0) from the equilibrium space, and where both distances are taken with respect to the
norm (cid:112)xT AAT x + yT AT Ay.

2 → O(ηγ2∆0
(cid:16)√

2 + ||Ayt||2

(cid:12)
t ≡ (cid:12)
(cid:12)AT xt
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2

0

Proof of Corollary 7: It follows from (33), (34) and (35) that:
∞
(cid:88)

(cid:19)t−2

(cid:18)

(cid:18)

∆0

t ≤

1 −

(1 + η)2∆0

0 + 16

1 −

(cid:19)t

η2
γ2

η3∆0
0

t=0

(cid:18)

=

1 −

(cid:19)t−2

(1 + η)2∆0

0 + O (cid:0)ηγ2∆0

0

(cid:1) ,

η2
γ2

η2
γ2

which shows the ﬁrst part of our claim. For the second part of our claim recall that the solutions
to (29) are all pairs (x, y) such that x is in the null space of AT and y is in the null space of A.

D.2 GENERAL BILINEAR CASE

Theorem 8. Consider OMD for the min-max problem (30):

(cid:0)xT Ay + bT x + cT y + d(cid:1) .

inf
x

sup
y

(cid:16)√

Under the same conditions as Corollary 7 and whenever (30) is ﬁnite, OMD exhibits last iterate
convergence in the same sense as in Corollary 7. In particular, for large enough t, the last iterate of
OMD is within O
distance from the space of equilibrium points of the game, where
√
∆0 is the distance of the point (x0 + (AT )+c, y0 + A+b) from the equilibrium space, and where
both distances are taken with respect to the norm (cid:112)xT AAT x + yT AT Ay. Whenever (30) is inﬁnite
or undeﬁned, the OMD dynamics travels to inﬁnity and we characterize its motion.

η · γ(cid:112)∆0

(cid:17)

0

Proof of Theorem 8: Trivially, we need only consider functions of the form xT Ay + bT x + cT y. We
consider the following decompositions of b and c:
b = b1 + b2
c = c1 + c2

where b1 ∈ R(A), b2 ∈ N (AT )
where c1 ∈ R(AT ), c2 ∈ N (A)

Given the above we can also deﬁne b3 and c3 as follows:

Ac3 = b1
AT b3 = c1

feasible since b1 ∈ R(A)
feasible since c1 ∈ R(AT )

Then, we can make the following variable substition:
αt = xt + ηtb2 + b3
βt = yt − ηtc2 + c3

so that:

We also state the OMD dynamics for xt and yt for problem (30):

AT αt = AT xt + ηtAT b2 + AT b3

= AT xt + c1

since b2 ∈ N (AT )

Aβt = Ayt − ηtAc2 + Ac3

= Ayt + b1

since c2 ∈ N (A)

xt = xt−1 − 2η(Ayt−1 + b) + η(Ayt−2 + b)

= xt−1 − 2ηAyt−1 + ηAyt−2 − ηb

yt = yt−1 + 2η(AT xt−1 + c) − η(AT xt−2 + c)

= yt−1 + 2ηAT xt−1 − ηAT xt−2 + ηc

21

Note that given this update step:

xt+1 = xt − 2ηAyt + ηAyt−1 − ηb
xt+1 = xt − ηb2 − 2ηAyt + ηAyt−1 − ηAc3
xt+1 = xt − ηb2 − 2ηA(yt + c3) + ηA(yt−1 + c3)
xt+1 = xt − ηb2 − 2ηA(yt − ηc2t + c3) + ηA(yt−1 − ηc2(t − 1) + c3)
xt+1 + ηb2(t + 1) = xt + ηb2t − 2ηA(yt − ηc2t + c3) + ηA(yt−1 − ηc2(t − 1) + c3)
xt+1 + ηb2(t + 1) + b3 = xt + ηb2t + b3 − 2ηA(yt − ηc2t + c3) + ηA(yt−1 − ηc2(t − 1) + c3)

αt+1 = αt − 2ηAβt + ηAβt−1

Analogously:

βt+1 = βt + 2ηAT αt − ηAT αt−1

Note that these are precisely the dynamics for which we proved convergence in Theorem 1. Thus,
by invoking Theorem 3 and Corollary 7 on the sequence (αt, βt) and then substituting back (xt, yt),
we have that for all large enough t:

xt = −ηb2t − b3 + (cid:15)x(t)
yt = ηc2t − c3 + (cid:15)y(t)

such that ||AT (cid:15)x(t)||2, ||A(cid:15)y(t)||2 ∈ O

(cid:18)√

(cid:113)

(cid:19)

∆0
0

,

η · γ

where ∆0

0 = ||AT (x0 + b3)||2

2 + ||A(y0 + c3)||2
2.
In particular, this shows that, whenever (30) is ﬁnite (i.e. b2 = c2 = 0), OMD exhibits last iterate
η · γ(cid:112)∆0
convergence. For large enough t, the last iterate of OMD is within O
distance from
the space of equilibrium points of the game, where (cid:112)∆0
0 is the distance of (x0 + b3, y0 + c3) from
(cid:112)xT AAT x + yT AT Ay. Whenever (30) is inﬁnite or undeﬁned,
the equilibrium space in the norm
the OMD dynamics travels to inﬁnity linearly, with ﬂuctuations around the divergence speciﬁed as
above.

(cid:16)√

(cid:17)

0

D.3 OMITTED PROOFS

Proof of Proposition 1: To show this, we consider the (cid:96)2 distance of the solution at time t. First,
recall the GD update step in the special case of f (x, y) = xT y:

Then, note that the squared (cid:96)2 distance of the running iterate (xt, yt) to the unique equilibrium
solution (0, 0) is given by d(t) := ||xt||2

2 + ||yt||2

xt = xt−1 − ηyt−1
yt = yt−1 + ηxt−1

||xt||2
||yt−1||2

2 = ||xt−1||2
2 = ||yt−1||2

2, which we can calculate:
t−1yt−1 + η2||yt−1||2
2
t−1xt−1 + η2||xt−1||2
2

2 − 2ηxT
2 + 2ηyT

∴ d(t) = d(t − 1) + η2d(t − 1)
= (1 + η2)d(t − 1)

This indicates that for any value of η > 0, the running iterate of GD diverges from the equilibrium.

Proof of Claim 1: For our ﬁrst claim, observe that:
(cid:104)Au, Av(cid:105)AM T

= uT AT AM T

i MiAT Av

i

= uT AT A(AT A)k(Aj)T Aj(AT A)kAT Av
= uT AT (AAT )kA(Aj)T AjAT (AAT )kAv
= uT AT [(AAT )kA(Aj)T ][AjAT (AAT )k]Av
= uT AT N T
= (cid:104)u, v(cid:105)AT N T

i+1Ni+1Av

i+1

22

Our second claim, (cid:104)AT u, AT v(cid:105)AT N T

= (cid:104)u, v(cid:105)AM T

i

i+1

, is proven analogously.

For our third claim:

(cid:104)u, Av(cid:105)AM T

i

= uT AM T

i MiAT Av

= uT A(AT A)k(AT A)j(AT A)kAT Av

if j = 0:

otherwise:

= uT A(AT A)k(AT A)kAT Av
= uT A[AT (AAT )k][(AAT )kA]v
= uT A[AT N T
= (cid:104)v, AT u(cid:105)AT N T

i ][NiA]v

i

= uT A(AT A)kAT A(AT A)kAT Av
= uT A[(AT A)kAT A][(AT A)kAT A]v
= uT A[AT (AAT )kA][AT (AAT )kA]v
= uT A[AT N T
= (cid:104)v, AT u(cid:105)AT N T

i ][NiA]v

i

Proof of Lemma 2: First, we note the following scaled update rule:

MiAT xt = Mi
NiAyt = Ni

(cid:0)AT xt−1 − 2ηAT Ayt−1 + ηAT Ayt−2
(cid:1)
(cid:0)Ayt−1 + 2ηAAT xt−1 − ηAAT xt−2

(cid:1)

Then, taking the norm of both sides, and using the statements of Claim 1:
+ 4η2 ||yt−1||2

+ η2 ||yt−2||2

= ||xt−1||2

||xt||2

AM T
i

AM T
i

+ 2η(cid:104)xt−1, Ayt−2(cid:105)AM T

i

i+1

AT N T
− 4η2(cid:104)yt−1, yt−2(cid:105)AT N T

AT N T

i+1

i+1

− 4η(cid:104)xt−1, Ayt−1(cid:105)AM T

i

||yt||2

AT N T
i

= ||yt−1||2

AT N T
i

+ 4η2 ||xt−1||2
+ 2η(cid:104)yt−1, AT xt−2(cid:105)AT N T

+ η2 ||xt−2||2
AM T
AM T
− 4η2(cid:104)xt−1, xt−2(cid:105)AM T

i+1

i+1

i

i+1

+ 4η(cid:104)yt−1, AT xt−1(cid:105)AT N T

i

∴ ∆i

t = ||xt||2
= ∆i

+ ||yt||2
t−1 + 4η2∆i+1

AT N T
i
t−1 + η2∆i+1

AM T
i

− 4η2((cid:104)xt−1, xt−2(cid:105)AM T

t−2 + 2η((cid:104)xt−1, Ayt−2(cid:105)AM T
+ (cid:104)yt−1, yt−2(cid:105)AT N T

i

i+1

i+1

− (cid:104)yt−1, Axt−2(cid:105)AT N T
)

i

)

Expanding the ﬁrst pair of inner products above and using Claim 1 again:

(cid:104)xt−1, Ayt−2(cid:105)AM T

i

− (cid:104)yt−1, AT xt−2(cid:105)AT N T

i

= (cid:104)xt−2 − 2ηAyt−2 + ηAyt−3, Ayt−2(cid:105)AM T

i

− (cid:104)yt−2 + 2ηAT xt−2 − ηAT xt−3, AT xt−2(cid:105)AT N T

i

= −2η(||yt−2||2

AT N T

i+1

+ ||xt−2||2

AM T

i+1

) + η((cid:104)xt−2, xt−3(cid:105)AM T

+ (cid:104)yt−2, yt−3(cid:105)AT N T

)

i+1

i+1

Then, multiplying by 2η and substituting into the previous derivation yields:

∆i

t − ∆i

t−1 = 4η2∆i+1

t−2 + 2η2((cid:104)xt−2, xt−3(cid:105)AM T

+ (cid:104)yt−2, yt−3(cid:105)AT N T

)

i+1

i+1

t−1 − 3η2∆i+1
− 4η2((cid:104)xt−1, xt−2(cid:105)AM T

+ (cid:104)yt−1, yt−2(cid:105)AT N T

)

i+1

i+1

23

Now, consider the following inner product:

(cid:104)xt−2, xt−1(cid:105)AM T

+ (cid:104)yt−2, yt−1(cid:105)AT N T

= (cid:104)xt−2, xt−2 − 2ηAyt−2 + ηAyt−3(cid:105)AM T

i+1

i+1

i+1

+ (cid:104)yt−2, yt−2 + 2ηAT xt−2 − ηAT xt−3(cid:105)AT N T

i+1

= ∆i+1

t−2 + η

(cid:104)xt−2, Ayt−3(cid:105)AM T

i+1

− (cid:104)yt−2, AT xt−3(cid:105)AT N T

i+1

(cid:16)

(cid:17)

Once again, we multiply by −4η2 and substitute:

∆i

t − ∆i

t−1 = 4η2∆i+1

t−1 − 7η2∆i+1

t−2 + 2η2((cid:104)xt−2, xt−3(cid:105)AM T

+ (cid:104)yt−2, yt−3(cid:105)AT N T

)

i+1

i+1

+ 4η3((cid:104)yt−2, AT xt−3(cid:105)AT N T

− (cid:104)xt−2, Ayt−3(cid:105)AM T

)

i+1

i+1

Now, we use the update step for time t − 2. For all t ≥ 1, this is well-deﬁned, since x−1 and y−1
are deﬁned. To ensure that this step is sound for t = 0 requires we deﬁne the following, where X +
denotes the generalized inverse:

We deﬁne these such that: AT x−2 = 4AT x0 + y0
y0 ∈ R(AT ), and thus the following equalities hold:

η and Ay−2 = 4Ay0 − x0

η (since x0 ∈ R(A) and

x−2 = 4x0 +

(AT )+y0

y−2 = 4y0 −

A+x0

1
η

1
η

x0 = x−1 − 2ηAy−1 + ηAy−2
y0 = y−1 + 2ηAT x−1 − ηAT x−2

This allows us to use the following expansion freely for all t ≥ 2:

xt−2 = xt−3 − 2ηAyt−3 + ηAyt−4
yt−2 = yt−3 + 2ηAT xt−3 − ηAT xt−4

=⇒ xt−3 − 2ηAyt−3 = xt−2 − ηAyt−4
=⇒ yt−3 + 2ηAT xt−3 = yy−2 + ηAT xt−4

We can gather the inner product terms and use this update rule to get our ﬁnal desired result:

∆i

t − ∆i

t−1 = 4η2∆i+1

t−1 − 7η2∆i+1

t−2 + 2η2((cid:104)xt−2, xt−3 − 2ηAyt−3(cid:105)AM T

+ (cid:104)yt−2, yt−3 + 2ηAT xt−3(cid:105)AT N T

)

i+1

i+1

= 4η2∆i+1

t−1 − 5η2∆i+1

t−2 − 2η3((cid:104)xt−2, Ayt−4(cid:105)AM T

− (cid:104)yt−2, AT xt−4(cid:105)AT N T

)

i+1

i+1

Proof of Lemma 4: To prove this, ﬁrst consider the following trivial inequality:

(cid:12)
(cid:12)

(cid:12)
(cid:12)yt−2 − AT xt−4

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2
AT N T

i+1

+ ||xt−2 + Ayt−4||2

AM T

i+1

= ||yt−2||2

AT N T
+ ||xt−2||2

i+1

≥ 0

− 2(cid:104)yt−2, AT xt−4(cid:105)AT N T

i+1

AM T

i+1

+ 2(cid:104)xt−2, Ayt−4(cid:105)AM T

i+1

+ (cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)AT xt−4
(cid:12)
(cid:12)
(cid:12)
+ ||Ayt−4||2

2
AT N T

i+1

AM T

i+1

Rearranging:

2(cid:104)yt−2, AT xt−4(cid:105)AT N T

− 2(cid:104)xt−2, Ayt−4(cid:105)AM T

i+1

i+1

≤ ∆i+1

t−2 +

(cid:16)(cid:12)
(cid:12)
(cid:12)AT xt−4
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2
AT N T

i+1

+ ||Ayt−4||2

(cid:17)

AM T

i+1

(cid:17)

AM T

i+1

+ ||yt−4||2

AT N T

i+1

(cid:16)

≤ ∆i+1

||xt−4||2
(cid:1)

t−2 + λ2
∞
t−2 + (cid:0)λ2
∞∆i+1
t−4
t−2 + ∆i+1
t−4

≤ ∆i+1
≤ ∆i+1

24

Now, we can apply this bound to the result of Lemma 2:

∆i

t − ∆i

t−1 = 4η2∆i+1
≤ 4η2∆i+1

t−1 − 5η2∆i+1
t−1 − 5η2∆i+1

t−2 − 2η3((cid:104)xt−2, Ayt−4(cid:105)AM T
t−2 + η3(∆i+1

t−2 + ∆i+1
t−4)

i+1

− (cid:104)yt−2, AT xt−4(cid:105)AT N T

)

i+1

Which is what we sought out to prove.

Proof of Lemma 5: Suppose j = i mod 2 and k = (i − j)/2. Notice the following identities:

Mi = Aj(AT A)k, Ni = (cid:0)AT (cid:1)j (cid:0)AAT (cid:1)k
Mi+1 = (AT )jA(AT A)k, Ni+1 = AjAT (cid:0)AAT (cid:1)k

Now:

∆i+1

t = ||Ni+1Ayt||2

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2
2

Ayt

2 + (cid:12)
(cid:12)
(cid:12)Mi+1AT xt
(cid:12)
(cid:12)
(cid:12)
(cid:12)
2
(cid:12)
+ (cid:12)
(cid:12)AjAT (cid:0)AAT (cid:1)k
(cid:12)(AT )jA(AT A)kAT xt
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
2
(cid:12)
(cid:12)
(cid:12)
(cid:12)(AT )j (cid:0)AAT (cid:1)k
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
||NiAyt||2
(cid:12)MiAT xt

(cid:12)
(cid:12)Aj(AT A)kAT xt

(cid:18)(cid:12)
(cid:12)
(cid:12)

+ (cid:12)
(cid:12)

Ayt

2
(cid:12)
(cid:12)

2 + (cid:12)
(cid:12)

(cid:17)

(cid:16)

2

(cid:12)
2
(cid:12)
2

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2

2

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2

2

(cid:19)

=

(cid:12)
(cid:12)
(cid:12)

≤ λ2
∞

≤ λ2
∞
≤ ∆i
t,

where for the last inequality we used that λ∞ ≤ 1.

Proof of Lemma 6: Given our initialization, x0 ∈ R(A). This implies xt ∈ R(A), ∀ t, due to the
update step of the dynamics. Recalling key properties of the matrix pseudoinverse, this implies:
xt ≡ AA+xt = AAT (AAT )+xt, for all t. Similarly, given our initialization, yt ∈ R(AT ), for
all t, which implies yt ≡ AT (AT )+yt = AT A(AT A)+yt, for all t. Letting Q = (AAT )+ and
P = (AT A)+, we get the following (where j = i mod 2 and k = (i − j)/2):

∆i

2

2

(cid:12)
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

(cid:12)
(cid:12)

2
2

2 + (cid:12)
(cid:12)

t = (cid:12)
(cid:12)
2 + ||NiAyt||2
(cid:12)MiAT xt
(cid:12)
2
= (cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)MiAT AAT Qxt
(cid:12)NiAAT AP yt
(cid:12)
(cid:12)
(cid:12)
= (cid:12)
(cid:12)
(cid:12)
(cid:12)
2
2 + ||Ni+2AP yt||2
(cid:12)Mi+2AT Qxt
(cid:12)
(cid:12)
(cid:12)
= (cid:12)
(cid:12)
2 + (cid:12)
(cid:12)
(cid:12)
(cid:12)Aj(AT A)k+1AT (AAT )+xt
(cid:12)
(cid:12)
(cid:12)
(cid:12)
= (cid:12)
(cid:12)
2 + (cid:12)
(cid:12)
(cid:12)
(cid:12)Aj(AT A)+AT (AAT )k+1xt
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:40)(cid:12)
2 + (cid:12)
(cid:12)
(cid:12)(AAT )+Ni+2Ayt
(cid:12)
(cid:12)
(cid:12)
2 + (cid:12)
(cid:12)
(cid:12)(AT A)+Ni+2Ayt
(cid:12)
(cid:12)
,

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
≤ max (||Q||, ||P ||)2 · ∆i+2

(cid:12)
(cid:12)(AT A)+Mi+2AT xt
(cid:12)
(cid:12)(AAT )+Mi+2AT xt

=

2

2

2

2

2

t

(cid:12)
(cid:12)(AT )j(AAT )k+1A(AT A)+yt
(cid:12)
(cid:12)(AT )j(AAT )+A(AT A)k+1yt
(cid:12)
(cid:12)
2
(cid:12)
(cid:12)
2
(cid:12)
(cid:12)
2
(cid:12)
(cid:12)
2

if j = 0

if j = 1

(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)
(cid:12)

2

2
2

2

where for the fourth and ﬁfth equality we used the following key property of pseudo-inverses: A+ =
(AT A)+AT = AT (AAT )+.

25

E DNA-GENERATION WGAN ARCHITECTURE

Operation

Kernel

Output Shape BatchNorm? Nonlinearity

Length of DNA sequence: L = 6
Gradient penalty: λ = 1e−4
Batch size: 512
G(z) :
z
Fully connected
Fully connected
Reshape
Upsampling by 2
Convolution
D(x) :
x
Convolution
Fully connected
Fully connected

-
-
-
-
-
[1 × 3] × 4

50
128
16 × L
2
16 × 1 × L
2
16 × 1 × L
4 × 1 × L

-
[1 × 3] × 16
-
-

4 × 1 × L
16 × 1 × L
32
1

-
no
yes
-
-
no

-
no
no
no

-
tanh
tanh
-
-
tanh

-
tanh
tanh
linear

F CIFAR10 WGAN ARCHITECTURE

Operation

Kernel

Output Shape BatchNorm? Nonlinearity

Gradient penalty: λ = 10
Batch size: 64
G(z) :
z
Fully connected
Fully connected
Reshape
TransposedConv
Convolution
TransposedConv
Convolution
D(x) :
x
Convolution
Convolution
Convolution
Fully connected
Fully connected

-
-
-
-
[5 × 5] × 128
[5 × 5] × 64
[5 × 5] × 64
[5 × 5] × 3

-
[5 × 5] × 64
[5 × 5] × 128
[5 × 5] × 128
-
-

100
1024
8192
128 × 8 × 8
128 × 16 × 16
64 × 16 × 16
64 × 32 × 32
3 × 32 × 32

3 × 32 × 32
64 × 32 × 32
128 × 14 × 14
128 × 7 × 7
1024
1

-
no
yes
-
yes
yes
yes
no

-
no
no
no
no
no

-
LeakyReLU
LeakyReLU
-
LeakyReLU
LeakyReLU
LeakyReLU
tanh

-
LeakyReLU
LeakyReLU
LeakyReLU
LeakyReLU
linear

26

G CIFAR10 GENERATOR IMAGE SAMPLES

(a) Sample of images from Generator of Epoch 94, which had the highest inception score.

Figure 10: Samples of images from Generator trained via Optimistic Adam on CIFAR10.

G.1 COMPARISON OF EARLY EPOCH IMAGES OF OPTIMISTIC ADAM VS ADAM

Below we give samples of images from an early epoch 19 Generator trained via Optimistic Adam
with 1:1 training ratio, Adam with 1:1 and Adam with 5:1 ratio on CIFAR10. We see that Optimistic
Adam has already achieved visually appealing results unlike the latter two vanilla Adam based
versions.

27

Figure 11: Sample of images from Generator of Epoch 19 trained via Optimistic Adam and 1:1 training ratio.

Figure 12: Sample of images from Generator of Epoch 19 trained via Adam and 1:1 training ratio.

28

Figure 13: Sample of images from Generator of Epoch 19 trained via Adam and 5:1 training ratio.

29

H CIFAR10 ADAM VS. OPTIMISTIC ADAM COMPARISON

Figure 14: The inception scores across epochs for GANs trained with Optimistic Adam (ratio 1) and Adam (ra-
tio 5) on CIFAR10 (the two top-performing optimizers found in Section 6, with 10%-90% conﬁdence intervals.
The GANs were trained for 30 epochs and results gathered across 35 runs.

30

