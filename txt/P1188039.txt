Geometrically Principled Connections in Graph Neural Networks

Shunwang Gong1∗

Mehdi Bahri1∗
1Imperial College London

Michael M. Bronstein1,2,3
2Twitter
{shunwang.gong16, m.bahri, m.bronstein, s.zafeiriou}@imperial.ac.uk

3USI Lugano

4FaceSoft.io

Stefanos Zafeiriou1,4

0
2
0
2
 
r
p
A
 
6
 
 
]

V
C
.
s
c
[
 
 
1
v
8
5
6
2
0
.
4
0
0
2
:
v
i
X
r
a

Abstract

Graph convolution operators bring the advantages of
deep learning to a variety of graph and mesh processing
tasks previously deemed out of reach. With their continued
success comes the desire to design more powerful architec-
tures, often by adapting existing deep learning techniques
to non-Euclidean data. In this paper, we argue geometry
should remain the primary driving force behind innovation
in the emerging ﬁeld of geometric deep learning. We relate
graph neural networks to widely successful computer graph-
ics and data approximation models: radial basis functions
(RBFs). We conjecture that, like RBFs, graph convolution
layers would beneﬁt from the addition of simple functions to
the powerful convolution kernels. We introduce afﬁne skip
connections, a novel building block formed by combining
a fully connected layer with any graph convolution opera-
tor. We experimentally demonstrate the effectiveness of our
technique, and show the improved performance is the con-
sequence of more than the increased number of parameters.
Operators equipped with the afﬁne skip connection markedly
outperform their base performance on every task we evalu-
ated, i.e., shape reconstruction, dense shape correspondence,
and graph classiﬁcation. We hope our simple and effective
approach will serve as a solid baseline and help ease future
research in graph neural networks.

1. Introduction

The graph formalism has established itself as the lingua
franca of non-Euclidean deep learning, as graphs provide
a powerful abstraction for very general systems of interac-
tions. In the same way that classical deep learning developed
around the Convolutional Neural Networks (CNNs) and their
ability to capture patterns on grids by exploiting local corre-
lation and to build hierarchical representations by stacking
multiple convolutional layers, most of the work on graph
neural networks (GNNs) has focused on the formulation of
convolution-like local operators on graphs.

∗Authors contributed equally.

Figure 1: The comparison made in this paper between
learned graph convolution kernels and RBF interpolation sug-
gests augmenting graph convolution operators with additive
afﬁne transformations, implemented as parametric connec-
tions between layers. Our afﬁne skip connections improve
the network’s ability to represent certain transformations,
and enable better use of the vertex features.

In computer vision and graphics, early attempts at apply-
ing deep learning to 3D shapes were based on dense voxel
representations [44] or multiple planar views [50]. These
methods suffer from three main drawbacks, stemming from
their extrinsic nature: high computational cost of 3D convolu-
tional ﬁlters, lack of invariance to rigid motions or non-rigid
deformations, and loss of detail due to rasterisation.

A more efﬁcient way of representing 3D shapes is model-
ing them as surfaces (two-dimensional manifolds). In com-
puter graphics and geometry processing, a popular type of
efﬁcient and accurate discretisation of surfaces are meshes
or simplicial complexes (see, e.g., [8, 10, 26, 7, 39, 22, 14]),
which can be considered as graphs with additional structure
(faces). Geometric deep learning [9] seeks to formulate in-
trinsic analogies of convolutions on meshes accounting for
these structures.

As a range of effective graph and mesh convolution op-
erators are now available, the attention of the community is
turning to improving the basic GNN architectures used in

1

graph and mesh processing to match those used in computer
vision. Borrowing from the existing literature, extensions of
successful techniques such as residual connections [23] and
dilated convolutions [54] have been proposed [40, 41, 53],
some with major impact in accuracy [31]. We argue, how-
ever, that due to the particularities of meshes and to their
non-Euclidean nature, geometry should be the foundation
for architectural innovations in geometric deep learning.

Contributions In this work, we provide a new perspective
on the problem of deep learning on meshes by relating graph
neural networks to Radial Basis Function (RBF) networks.
Motivated by fundamental results in approximation, we intro-
duce geometrically principled connections for graph neural
networks, coined as afﬁne skip connections, and inspired
by thin plate splines. The resulting block learns the sum of
any existing graph convolution operator and an afﬁne func-
tion, allowing the network to learn certain transformations
more efﬁciently. Through extensive experiments, we show
our technique is widely applicable and highly effective. We
verify afﬁne skip connections improve performance on shape
reconstruction, vertex classiﬁcation, and graph classiﬁcation
tasks. In doing so, we achieve best in class performance
on all three benchmarks. We also show the improvement in
performance is signiﬁcantly higher than that provided by
residual connections, and verify the connections improve
representation power beyond a mere increase in trainable
parameters. Visualizing what afﬁne skip connections learn
further bolsters our theoretical motivation.

Notations Throughout the paper, matrices and vectors are
denoted by upper and lowercase bold letters (e.g., X and
(x), respectively. I denotes the identity matrix of compatible
dimensions. The ith column of X is denoted as xi. The
sets of real numbers is denoted by R. A graph G = (V, E)
consists of vertices V = {1, . . . , n} and edges E ⊆ V × V.
The graph structure can be encoded in the adjacency matrix
A, where aij = 1 if (i, j) ∈ E (in which case i and j are
said to be adjacent) and zero otherwise. The degree matrix
D is a diagonal matrix with elements dii = (cid:80)n
j=1 aij. The
neighborhood of vertex i, denoted by N (i) = {j : (i, j) ∈
E}, is the set of vertices adjacent to i.

2. Related work

Graph and mesh convolutions The ﬁrst work on deep
learning on meshes mapped local surface patches to pre-
computed geodesic polar coordinates; convolution was per-
formed by multiplying the geodesic patches by learnable
ﬁlters [35, 5]. The key advantage of such an architecture is
that it is intrinsic by construction, affording it invariance to
isometric mesh deformations, a signiﬁcant advantage when
dealing with deformable shapes. MoNet [37] generalized
the approach using a local system of pseudo-coordinates
uij to represent the neighborhood N (i) and a family of

learnable weighting functions w.r.t. u, e.g., Gaussian kernels
wm(u) = exp (cid:0)− 1
k (u − µm)(cid:1) with learn-
2 (u − µm)TΣ−1
able mean µm and covariance Σm. The convolution is

x(k)
i =

M
(cid:88)

θm

(cid:88)

m=1

j∈N (i)

wm(uij)x(k−1)

j

(1)

i

i

and x(k)

where x(k−1)
denotes the input and output features
at vertex i, respectively, and θ is the vector of learnable ﬁlter
weights. MoNet can be seen as a Gaussian Mixture Model
(GMM), and as a more general form of the Graph Attention
(GAT) model [47]. Local coordinates were re-used in the
Spline Convolutional Network [18], which represents the
ﬁlters in a basis of smooth spline functions. Another popular
attention-based operator is FeaStNet [48], that learns a soft
mapping from vertices to ﬁlter weights, and has been applied
to discriminative [48] and generative models [34]:

x(k)
i = b+

1
|N (i)|

M
(cid:88)

(cid:88)

m=1

j∈N (i)

qm(x(k−1)
i

, x(k−1)
j

)Wmx(k−1)
j

(2)
where Wm a matrix of learnable ﬁlters weights for the m-th
ﬁlter, qm is a learned soft-assignment of neighbors to ﬁlter
weights, and b the learned bias of the layer.1

ChebNet [15] accelerates spectral convolutions by ex-
panding the ﬁlters on the powers of the graph Laplacian
using Chebychev polynomials. Throughout this paper, we
will refer to the n-order expansion as ChebNet-n. in particu-
lar the ﬁrst order expansion ChebNet-1 reads

X(k) = −D− 1

2 AD− 1

2 X(k−1)Θ1 + X(k−1)Θ0

(3)

2 AD− 1

with L = −D− 1
2 the normalised symmetric graph
Laplacian, A is the graph adjacency matrix, and D is the
degree matrix. In computer graphics applications, ChebNet
has seen some success in mesh reconstruction and generation
[42]. However, due to the fact that spectral ﬁlter coefﬁcients
are basis dependent, the spectral construction is limited to a
single domain. We therefore do not evaluate the performance
of ChebNet on correspondence tasks. We refer to [30, 16] for
constructing compatible orthogonal bases across different
domains. The Graph Convolutional Network (GCN) model
[29] further simpliﬁes (3) by considering ﬁrst-order polyno-
mials with dependent coefﬁcients, resulting in

X(k) = ˜LX(k−1)Θ,

(4)

2 ˜A ˜D− 1

2 = I + D− 1

where ˜L = ˜D− 1
2 . By virtue
of this construction, GCN introduces self-loops. GCN is
perhaps the simplest graph neural network model combining
vertex-wise feature transformation (right-side multiplication
by Θ) and graph propagation (left-side multiplication by ˜L).

2 AD− 1

1It is tacitly assumed here that i ∈ N (i).

For this reason, it is often a popular baseline choice in the
literature, but it has never applied successfully on meshes.

Recently, models based on the simple consistent enu-
meration of a vertex’s neighbors have emerged. SpiralNet
[33] enumerates the neighbors around a vertex in a spiral
order and learns ﬁlters on the resulting sequence with a neu-
ral network (MLP or LSTM). The recent SpiralNet++ [21]
improves on the original model by enforcing a ﬁxed order
to exploit prior information about the meshes in the com-
mon case of datasets of meshes that have the same topology,
e.g., [3, 4, 42]. The SpiralNet++ [21] operator is written
i = γ(k) (cid:16)
x(k)
with γ(k) an MLP, || the
concatenation, and S(i, M ) the spiral sequence of neighbors
of i of length (i.e. kernel size) M .

||j∈S(i,M ) x(k−1)

(cid:17)

j

Finally, we include the recently proposed Graph Isomor-

phism Network (GIN) [52] with the update formula

x(k)
i = γ(k)


(1 + (cid:15)(k)) · x(k−1)

i

+



x(k−1)
j

 . (5)

(cid:88)

j∈N (i)

This model is designed for graph classiﬁcation and was
shown [52] to be as powerful as the Weisfeiler-Lehman graph
isomorphism test.

Skip connections and GNNs Highway Networks [45, 46]
present shortcut connections with data-dependant gating
functions, which are amongst the ﬁrst architectures that pro-
vided a means to effectively train deep networks. However,
highway networks have not demonstrated improved perfor-
mance due to the fact that the layers in highway networks act
as non-residual functions when a gated shortcut is ”closed”.
Concurrent with this work, pure identity mapping [23] made
possible the training of very deep neural networks, and en-
abled breakthrough performance on many challenging image
recognition, localization, and detection tasks. They improve
gradient ﬂow and alleviate the vanishing gradient problem.
DenseNets [25] can be seen as a generalization of [23] and
connect all layers together. Early forms of skip connections
in GNNs actually predate the deep learning explosion and
can be traced back to the Neural Network for Graphs (NN4G)
model [36], where the input of any layer is the output of the
previous layer plus a function of the vertex features [51,
section V.B]. 2 In [31], the authors propose direct graph
equivalents for residual connections and dense connections,
provide an extensive study of their methods, and show major
improvements in the performance of the DGCNN architec-
ture [49] with very deep models.

3. Motivation: Radial Basis Interpolation

The main motivation of this paper comes from the ﬁeld
of data interpolation. Interpolation problems appear in many

2We refer to [31, section 2.1] for a summary of subsequent approaches.

machine learning and computer vision tasks. In the general
setting of scattered data interpolation, we seek a function
ˆf whose outputs ˆf (xi) on a set of scattered data points xi
equals matching observations yi, i.e., ∀i, f (xi) = yi. In the
presence of noise, one typically solves an approximation
problem potentially involving regularization, i.e.

min
f

(cid:88)

i

d( ˆf (xi), yi) + λL( ˆf ),

(6)

where d measures the adequation of the model ˆf to the ob-
servations, λ is a regularization weight, and L encourages
some chosen properties of the model. For the sake of the dis-
cussion, we take d(x, y) = ||x − y||. In computer graphics,
surface reconstruction and deformation (e.g. for registration
[13]) can be phrased as interpolation problems.

In this section, we draw connections between graph con-
volutional networks and a classical popular choice of inter-
polants: Radial Basis Functions (RBFs).

Radial basis functions An RBF is a function of the form
x (cid:55)→ φ(||x − ci||), with ||.|| a norm, and ci some pre-deﬁned
centers. By construction, the value of an RBF only depends
on the distance from the centers. While an RBF function’s
input is scalar, the function can be vector-valued.

In interpolation problems, the centers are chosen to be
the data points (ci = xi) and the interpolant is deﬁned as a
weighted sum of radial basis functions centered at each xi:

ˆf (x) =

wiφ(||x − xi||).

(7)

N
(cid:88)

i=1

Interpolation assumes equality, so the problem boils down to
solving the linear system Φwi = bj, with Φj,i = φ(||xi −
xj||) the matrix of the RBF kernel (note that the diagonal
is φ(0) ∀i). The kernel matrix encodes the relationships
between the points, as measured by the kernel.

Relaxing the equality constraints can be necessary, in
which case we solve the system in the least squares sense
with additional regularization. We will develop this point
further to introduce our proposed afﬁne skip connections.

Relations to GNNs An RBF function can be seen as a sim-
ple kind of one layer neural network with RBF activations
centered around every points (i.e. an RBF network [11, 38]).
The connection to graph neural networks is very clear: while
the RBF matrix encodes the relationships and deﬁnes a
point’s neighborhood radially around the point, graph neural
networks rely on the graph connectivity to hard-code spatial
relationships. In the case of meshes, this encoding is all-the-
more relevant, as a notion of distance is provided either by
the ambient space (the graph is embedded) or directly on the
Riemannian manifold. The latter relates to the RBFs with
geodesic distance of [43].

Most GNNs used on meshes fall into the message passing

framework [19]:

x(k)
i =
(cid:18)

γ(k)

x(k−1)
i

, (cid:3)
j∈N (i)

φ(k) (cid:16)

x(k−1)
i

, x(k−1)
j

, e(k−1)
ij

(cid:17)(cid:19)

,

(8)

where (cid:3) denotes a differentiable permutation-invariant func-
tion, (e.g. max or (cid:80)), φ a differentiable kernel function,
γ is an MLP, and xi and eij are features associated with
vertex i and edge (i, j), respectively. This equation deﬁnes
a compactly supported, and possibly non-linear, function
around the vertex. For the MoNet equation (1) the connection
to RBFs is direct. Contrary to RBFs, the ﬁlters of modern
GNNs do not have to be radial. In fact, anisotropic ﬁlters
[5, 6] have been shown to perform better than isotropic ones
[35, 42]. The other major differences are:

1. The ﬁlters are learned functions, not pre-deﬁned; this
allows for better inductive learning and task-speciﬁcity

2. The ﬁlters apply to any vertex and edge features

3. Some operators support self-loops, but diag(Φ) =

φ(0) irrespective of the features xi

We note that the compact support of (8) is a design de-
cision: early GNNs built on the graph Fourier transform
lacked compactly-supported ﬁlters [24]. In RBF interpola-
tion, global support is sometimes desired as it is a necessary
condition for maximal fairness of the interpolated surfaces
(i.e. maximally smooth), but also induces computational
complexity and numerical challenges as the dense kernel ma-
trices grow and become ill-conditioned [1]. This motivated
the development of fast methods to ﬁt locally supported
RBFs [2]. In [24] the authors argue compactly-supported
kernels are desirable in graph neural networks for computa-
tional efﬁciency, and to promote learning local patterns. This
especially justiﬁed for meshes, for which the graph structure
is very sparse. Additionally, stacking convolutional layers
is known to increase the receptive ﬁeld, including in graph
neural networks [51]. The composition of locally supported
ﬁlters can therefore yield globally supported mappings.

RBFs and polynomials A common practice with RBFs is
to add low-order polynomial terms to the interpolant:

ˆf (x) =

N
(cid:88)

i=1

wiφ(||x − xi||) + P (x).

(9)

The practical motivation is to ensure polynomial map-
pings of some order can be represented exactly and to avoid
unwanted oscillations when approximating ﬂat functions,
e.g. afﬁne transformations of an image should be exactly

afﬁne. One can show [1] this is equivalent to ensuring the
RBF weights lie in the null space of the polynomial basis,
also known as the vanishing moments condition.

However, polynomials appear organically when the RBF
kernel is derived to be optimal for a chosen roughness mea-
sure, typically expressed in terms of the integral of a squared
differential operator D (below in one dimension):

(cid:90)

||Df ||2 =

|Df (x)|2dx,

(10)

e.g., D = d2
dx2 . In other words, when the kernel is sought to
be optimal for a given regularization functional. Differential
operators are very naturally expressed on meshes in terms
of ﬁnite difference approximations. In this case, we identify
D with its corresponding stencil matrix. The interpolation
problem becomes the minimization of (10) subject to the
interpolation constraints.

It can be shown [1] that for such problems the RBF kernel
is the Green’s function of the squared differential operator,
and that for an operator of order m, polynomials of order
m − 1 span the null space. Therefore, the complete solution
space is the direct sum3 of the space of polynomials of order
m − 1 (the null space of the operator) and the space spanned
by the RBF kernel basis4.

Thin Plate Splines (TPS) An important special case is
the RBF interpolant for a surface z(x), x = [x y]T that
minimizes the bending energy (cid:82) (cid:82) ∂2f
∂y2 dxdy =
||∆2f ||. The solution is the well-known biharmonic spline,
or thin plate spline, φ(r) = r2 log r,
r = ||x − xi||, with
a polynomial of degree 1 (i.e. an afﬁne function)

∂x∂y + ∂2f

∂x2 + ∂2f

ˆf (x) =

(cid:88)

i

wiφ(||x − xi||) + Ax + b.

(11)

Generalizations to higher dimensions yield polyharmonic
splines. These splines maximize the surface fairness. From
(11) it is also clear the polynomial doesn’t depend on the
structure of the point set and is common for all points.

4. Geometrically Principled Connections

In Section 3, we highlighted key similarities and differ-
ences between continuous RBFs and discrete graph con-
volution kernels. We then exposed how adding low-order
polynomials to RBFs kernels is both beneﬁcial to enable
efﬁcient ﬁtting of ﬂat functions, and deeply connected to
regularization of the learned functions, and noted the poly-
nomial component does not depend on spatial relationships.
Based on these observations, we conjecture that graph con-
volution operators could, too, beneﬁt from the addition of

3Hence the vanishing moment condition.
4This result comes from phrasing the problem as regularization in a
Reproducing Kernel Hilbert Space. To keep the discussion short in this
manuscript, we refer the reader to relevant resources such as [1, Section 7].

Figure 2: Our block learns the sum of one graph convolution
and a shortcut equipped with an afﬁne transformation.

a low-order polynomial to ensure they can represent ﬂat
functions exactly, and learn functions of a vertex’s features
independently from its neighbours. We introduce a simple
block that achieves both goals.

Inspired by equation (11), we propose to augment a
generic graph convolution operator with afﬁne skip connec-
tions, i.e., inter-layer connections with an afﬁne transforma-
tion implemented as a fully connected layer. The output of
the block is the sum of the two paths, as shown in Figure 2.
Our block is designed to allow the fully connected layer to
learn an afﬁne transformation of the current feature map, and
let the convolution learn a residue from a vertex’s neighbors.
For message passing, we obtain:

x(k)
i =
(cid:18)

γ(k)

x(k−1)
i

, (cid:3)
j∈N (i)

φ(k)(x(k−1)
i

, x(k−1)
j

, e(k−1)
i,j

)

(12)

(cid:19)

+ A(k)x(k−1)

+ b(k).

i

The fully connected layer could be replaced by an MLP
to obtain polynomial connections, however, we argue the
stacking of several layers creates sufﬁciently complex map-
pings by composition to not require deeper sub-networks in
each block: a balance must be found between expressive-
ness and model complexity. Additionally, the analogy with
TPS appears well-motivated for signals deﬁned on surfaces.
As a matter of notation, we refer to our block based on
operator Conv with afﬁne skip connections as Aff -Conv.

In equations (9), (11) and (12), the polynomial part does
not depend on a vertex’s neighbors, but solely on the feature
at that vertex. This is similar to PointNet [12] that learns
a shared MLP on all points with no structural prior. In our
block, the geometric information is readily encoded in the
graph, while the linear layer is applied to all vertices in-
dependently, thus learning indirectly from the other points
regardless of their proximity.

Residual blocks with projections
In [23, Eq. (2)], the
authors introduced a variation of residual blocks with a pro-
jection implemented as a linear layer. Their motivation is to
handle different input and output sizes. We acknowledge the
contribution of residual connections and will demonstrate
our block provides the same beneﬁts and more for GNNs.

5. Experimental evaluation

Our experiments are designed to highlight different prop-
erties of afﬁne skip connections when combined. We present
the individual experiments, then draw conclusions based on
their entirety. All implementation details (model architecture,
optimizers, losses, etc.), and details about the datasets (num-
ber of samples, training/test split) are provided in Appendix
A of the supplementary material.

5.1. Experimental design

Mesh reconstruction The task is to reconstruct meshes
with an auto-encoder architecture, and relates the most to
interpolation. To validate the proposed approach, we ﬁrstly
show the performance of attention-based models, MoNet
and FeaStNet, on shape reconstruction on CoMA[42] for dif-
ferent values of M . For a kernel size of M , we compare the
vanilla operators (MoNet, FeaStNet), the blocks with resid-
ual skip connections (Res-MoNet, Res-FeaStNet), the blocks
with afﬁne skip connections (Aff -MoNet, Aff -FeaStNet), and
the vanilla operators with kernel size M +1 (MoNet+, FeaSt-
Net+)5. We evaluated kernel sizes 4, 9, and 14. We report the
mean Euclidean vertex error and its standard deviation, and
the median Euclidean error. Results with SplineCNN [17]
are shown in Appendix B of the supplementary material.

Mesh correspondence The experimental setting is mesh
correspondence, i.e., registration formulated as classiﬁcation.
We compare MoNet, FeaStNet and their respective blocks
on the FAUST [3] dataset. We purposefully do not include
SpiralNet++ and ChebNet on this problem: the connectivity
of FAUST is ﬁxed and vertices are in correspondence already.
These methods assume a ﬁxed topology and therefore have
an unfair advantage. We report the percentage of correct
correspondences as a function of the geodesic error.

Mesh correspondence with GCN The GCN [29] model
is arguably the most popular graph convolution operator,
and has been widely applied to problems on generic graphs
thanks to its simplicity. However, its performance degrades
quickly on meshes, which makes the entry bar higher for
prototyping graph-based approaches in 3D vision. We in-
vestigate whether afﬁne skip connections can improve the
performance of GCN, and by how much. We choose the 3D
shape correspondence task, in order to allow for comparison
with the other models already included in this study. As de-
tailed in the supplementary material, the network used in this
experiment is relatively deep, with three convolution layers.
In [29, Appendix B] the authors add residual connections to
GCNs deeper than two layers to alleviate vanishing gradients.
In order to prove afﬁne skip connections have a geometric
meaning, we must eliminate the possibility that better per-

5Increasing the kernel size by 1, and adding an afﬁne skip connection

lead to the same number of weight matrices.

method
ChebNet†
ChebNet
Res-ChebNet
SpiralNet++†
SpiralNet++
Res-SpiralNet++
FeaStNet
FeaStNet+
Res-FeaStNet
Aff -FeaStNet
MoNet
MoNet+
Res-MoNet
Aff -MoNet

M=4

M=9

M=14

mean error
0.659 ± 0.783
0.520 ± 0.655
0.531 ± 0.668
0.554 ± 0.674
0.578 ± 0.705
0.575 ± 0.703
0.599 ± 0.730
0.587 ± 0.723
0.565 ± 0.701
0.543 ± 0.676
0.671 ± 0.760
0.627 ± 0.693
0.540 ± 0.612
0.499 ± 0.579

median # param
92.5k
0.391
0.294
92.5k
92.5k
0.299
0.320
92.5k
92.5k
0.333
92.5k
0.331
93.8k
0.342
106.6k
0.333
93.8k
0.314
0.303
106.3k
92.7k
0.450
105.2k
0.429
92.7k
0.335
0.298
105.2k

mean error
4.329 ± 3.591
0.438 ± 0.562
0.444 ± 0.570
0.430 ± 0.542
0.426 ± 0.538
0.432 ± 0.541
0.524 ± 0.646
0.517 ± 0.635
0.483 ± 0.602
0.470 ± 0.585
0.528 ± 0.604
0.528 ± 0.587
0.426 ± 0.479
0.406 ± 0.455

median # param
154.9k
3.453
0.244
154.9k
154.9k
0.275
154.9k
0.239
0.238
154.9k
154.9k
0.243
157.9k
0.297
170.7k
0.292
157.9k
0.266
0.261
170.4k
155.4k
0.354
167.9k
0.366
155.4k
0.271
0.251
167.9k

mean error
4.348 ± 3.587
0.407 ± 0.523
0.412 ± 0.530
0.385 ± 0.491
0.383 ± 0.489
0.395 ± 0.496
0.488 ± 0.599
0.477 ± 0.594
0.441 ± 0.554
0.431 ± 0.543
0.480 ± 0.551
0.480 ± 0.540
0.374 ± 0.417
0.347 ± 0.386

median # param
217.3k
3.469
0.227
217.3k
217.3k
0.229
217.3k
0.214
0.212
217.3k
217.3k
0.223
221.9k
0.279
234.8k
0.268
221.9k
0.279
0.237
234.4k
218.1k
0.321
230.6k
0.329
218.1k
0.238
0.218
230.5k

Table 1: 3D shape reconstruction experiments results in the CoMA [42] dataset. Errors are in millimeters. All the experiments
were ran with the same network architecture. We show the results of each operator for different kernel sizes (i.e., # of weight
matrices). Aff- denotes the operators equipped with the proposed afﬁne skip connections, Res- denotes the operators with
standard residual connections, and † indicates we remove the separate weight for the center vertex.

(a) Addition (MoNet, FeaStNet)

(b) Ablation (ChebNet, SpiralNet++)

Figure 3: Sample reconstructions: addition of afﬁne skip
connections and ablation of the center vertex weights.

formance comes solely from improved gradient ﬂow. We
include in this study a GCN block with vanilla residual con-
nections (Res-GCN), in order to isolate the gradient ﬂow
improvements from the geometric improvements. Overall,
we compare vanilla GCN, Res-GCN, and our Aff -GCN.

Graph classiﬁcation We compare MoNet, FeaStNet, and
their respective residual and afﬁne skip connection blocks
on graph classiﬁcation on Superpixel MNIST [37, 18]. The
Superpixel MNIST dataset used in [37] and [18] represents
the MNIST images as graphs. We use 75 vertices per image.
All models use a kernel size of 25. We include GIN (built
with a 2-layer MLP) for the similarity of its update rule
with our block, in the GIN-0 ((cid:15) = 0) variant for its superior
performance as observed in [52]. We compare GIN with
GCN, Res-GCN, and Aff -GCN. Here, graph connectivity is
not ﬁxed. We report the classiﬁcation accuracy.

Ablation: separate weights for the centre vertex
To
show the inclusion of the center vertex is necessary, we
perform an ablation study of ChebNet, and SpiralNet++ on
shape reconstruction on CoMA. From equation (3), we see
the zero order term XΘ0 is an afﬁne function of the vertex

Figure 4: Example reconstructed faces obtained by passing
samples (top) through a trained autoencoder built on the
Aff -MoNet block. The middle row shows reconstructions
produced by the full autoencoder. The bottom row shows
the result of passing through the afﬁne skip connections only
in the decoder at inference. The connections learn a smooth
component common to the samples - across identities and
expressions, as expected from the motivation.

features. We remove it from the expansion of ChebNet-(M +
1) to obtain ChebNet-M †: X(k) = L(M +1)X(k−1)ΘM +1 +
. . . + LX(k−1)Θ1. Both models have identical numbers of
weight matrices, but ChebNet-M learns from the vertices
alone at order 0. For SpiralNet++, the center vertex is the ﬁrst
in the sequence {vertex||neighbors}. We rotate the ﬁlter
(i.e. move it one step down the spiral) to remove the weight
on the center vertex while keeping the same sequence length.
We obtain SpiralNet++†. The number of weight matrices is
constant. All models have kernel size 9.

Ablation: self-loops vs. afﬁne skip connections We also
compare FeaStNet with and without self-loops (FeaStNet†),

Figure 5: Shape correspondence experiments on the FAUST humans dataset. Per-vertex heatmap of the geodesic error for
three variants of the GCN operator. Geodesic error is measured according to [27].

(a) MoNet & FeaStNet

(b) GCN

Figure 6: Shape correspondence accuracy: the x axis dis-
plays the geodesic error in % of the mesh diameter, and the y
axis shows the percentage of correspondences that lie within
a given radius around the correct vertex. All experiments
were ran with the same architecture. Aff -GCN only has 1%
more parameters than GCN.

and the matching blocks, on all experiments.

5.2. Results and discussion

Based on the evidence collected, we draw conclusions

about speciﬁc properties of our afﬁne skip connections.

Parameter speciﬁcity The results of varying the kernel
size on shape reconstruction can be found in Table 1 along
with the corresponding number of parameters for control.
Increasing the kernel size by 1 (MoNet+, FeaStNet+) pro-
vides only a minor increase in performance, e.g., for M = 9
and M = 14, MoNet and MoNet+ have the same mean
Euclidean error and the median error of MoNet with M = 9
actually increases by 3.4%. In contrast, the afﬁne skip con-
nections always drastically reduce the reconstruction error,
for the same number of additional parameters. In particular,
the mean Euclidean error of MoNet decreased by 25.6% for
M = 4, and by 23.1% for M = 9. We conclude our afﬁne
skip connections have a speciﬁc different role and augment
the representational power of the networks beyond simply
increasing the number of parameters. Our block with MoNet
achieves the new state of the art performance on this task.

What do afﬁne skip connections learn? In Figure 4, we
observe the linear layers in the connections learned infor-
mation common to all shapes. This result strengthens our

Method

Acc. (%)

Kernel Size

# Param

57.75
31.21
42.32
58.96
11.35
58.09
59.50

GIN-0
GCN
Res-GCN
Aff -GCN
FeaStNet
Res-FeaStNet
Aff -FeaStNet
Pseudo-Coord. Degree
53.10
MoNet
Res-MoNet
53.75
Aff -MoNet
72.00

Position
96.57
96.82
97.14

-
-
-
-
25
25
25
-
25
25
25

25k
15.9k
15.9k
22.1k
166k
166k
172k
-
164k
164k
170k

Table 2: Classiﬁcation accuracy of different operators and
blocks on the Superpixel MNIST dataset with 75 superpixels.
For MoNet, we report performance using pseudo-coordinates
computed from the vertex positions, or from the connectivity
only (vertex degrees).

analogy with the polynomial terms in RBF interpolation:
the coefﬁcients of the polynomial function are learned from
all data points and shared among them. In one dimension,
this can be pictured as learning the trend of a curve. Our
visualizations are consistent with this interpretation.

Vertex-level representations We report the mesh corre-
spondence accuracy as a function of the geodesic error for
FeaStNet, MoNet, and the blocks in Figure 6a. We observe
consistent performance improvements for both operators.
The performance difference is remarkable for MoNet: for a
geodesic error of 0, the accuracy improved from 86.61% to
94.69%. Aff -MoNet is the new state of the art performance
on this problem6. We conclude afﬁne skip connections im-
prove vertex-level representations.

Laplacian smoothing and comparison to residuals We
show the performance of GCN and its residual and afﬁne
blocks in Figure 6b. The accuracy of vanilla GCN is only
around 20%. We can hypothesize this is due to the equiva-
lence of GCN with Laplacian smoothing [32] - blurring the

6Excluding methods that learn on a ﬁxed topology.

method

FeaStNet
Aff -FeaStNet
FeaStNet†
Aff -FeaStNet†

mean error
0.524 ± 0.646
0.470 ± 0.585
0.519 ± 0.634
0.463 ± 0.577

median # param
157.9k
0.297
170.4k
0.261
157.9k
0.297
170.4k
0.256

M
9
9
9
9

acc. (%)
93.14
94.29
93.72
94.36

# param.
1.91M
1.92M
1.91M
1.92M

M
10
10
10
10

acc. (%) # param. M
25
25
25
25

11.35
59.50
11.35
60.07

166k
172k
166k
172k

(a) Shape Reconstruction:

(b) Correspondence

(c) Classiﬁcation

Table 3: Ablations: afﬁne skip connection vs. self-loop. We show the performances of FeaStNet under the settings of with
and without self-loop (denoted with †) and with and without afﬁne skip connections regarding the tasks of shape reconstruction
on CoMA, shape correspondence on FAUST, and classiﬁcation on MNIST with 75 superpixels. M denotes the kernel size (i.e.
# weight matrices). For correspondence, test accuracy is the ratio of the correct correspondence prediction at geodesic error 0.

features of neighboring vertices and losing speciﬁcity - or
to the vanishing gradient problem. Our block outperforms
vanilla residuals by a large margin: the classiﬁcation rate
of Aff -GCN is nearly 79% while Res-GCN only reaches
61.27%. Visually (Figure 5), Res-GCN provides marked im-
provements over GCN, and Aff -GCN offers another major
step-up. A similar trend is seen in Table 1 and Table 2. In [23]
the authors observed a minor performance increase between
vanilla residuals and residual connections with projection,
that they attributed to the higher number of parameters. The
differences we observe are not consistent with such marginal
improvements. This shows not only our approach provides
all the beneﬁts of residuals in solving the vanishing gradient
problem, it achieves more on geometric data, and that the im-
provements are not solely due to more trainable parameters
or improved gradient ﬂow. In particular, with afﬁne skip con-
nections, Eq. 4 of [32] becomes σ(˜LH(l)Θ(l) + H(l)W(l)),
with ˜L the augmented symmetric Laplacian, and W(l) the
parameters of the afﬁne skip connection. Thus, the Aff -GCN
block is no longer equivalent to Laplacian smoothing.

Discriminative power Our results on Superpixel MNIST
are presented in Table 2. Our afﬁne skip connections improve
the classiﬁcation rate across the board. GCN with afﬁne skip
connections outperform GIN-0 by over 1 percentage point,
with 12% fewer trainable parameters. This result shows Aff -
GCN offers competitive performance with a smaller model,
and suggests the augmented operator is signiﬁcantly more
discriminative than GCN. Assuming the terminology of [52],
FeaStNet employs a mean aggregation function, a choice
known [52] to signiﬁcantly limit the discriminative power
of GNNs and which could explain its very low accuracy in
spite of its large (166k) number of parameters. In contrast,
Aff -FeaStNet is competitive with Aff -GCN and outperforms
GIN-0. As GIN is designed to be as powerful of the WL test,
these observations suggest afﬁne skip connections improve
the discriminative power of graph convolution operators. As
a result, Aff -MoNet outperformed the current state of the art,
for coordinate-based and degree-based pseudo-coordinates.

Role of the center vertex As seen in the ﬁrst six rows
of Table 1, the performance of the models is higher with
weights for the center vertex, especially for ChebNet. Note

the comparison is at identical numbers of parameters. Fig-
ure 3 provides sample ablation and addition results. This
shows convolution operators need to learn from the center
vertices. We found that removing self-loops in FeaStNet ac-
tually increased the performance for both the vanilla and the
block operators. Table 3 shows results on all experiments.
The afﬁne skip connection consistently improved the perfor-
mance of models regardless of the self-loops. We conclude
graph convolution operators should be able to learn specif-
ically from the center vertex of a neighborhood, indepen-
dently from its neighbors. A similar observation was made
in [52] where independent parameters for the center vertex
are shown to be required for graph convolution operators to
be as discriminative as the WL test.

6. Conclusion

By relating graph neural networks to the theory of ra-
dial basis functions, we introduce geometrically principled
connections that are both easily implemented, applicable
to a broad range of convolution operators and graph or
mesh learning problems, and highly effective. We show our
method extends beyond surface reconstruction and registra-
tion, and can dramatically improve performance on graph
classiﬁcation with arbitrary connectivity. Our MoNet block
achieves state of the art performance and is more robust
to topological variations than sequence (SpiralNet++) or
spectrum-based (ChebNet) operators. We further demon-
strate our blocks improve on vanilla residual connections for
graph neural networks. We believe our approach is therefore
interesting to the broader community. Future work should
study whether afﬁne skip connections have regularization
effects on the smoothness of the learned convolution kernels.

Acknowledgements S.G. and M.M.B. were supported by
ERC Consolidator grant No. 724228 (LEMAN). M.B. was
supported by a PhD Scholarship from Imperial College Lon-
don, a Qualcomm Innovation Fellowship, and acknowledges
the support of Amazon through the AWS Cloud Credits
for Research program. S.Z. was partially funded by the EP-
SRC Fellowship DEFORM: Large Scale Shape Analysis
of Deformable Models of Humans (EP/S010203/1) and an
Amazon AWS Machine Learning Research Award.

References

[1] Ken Anjyo, J P Lewis, and Fr´ed´eric Pighin. Scattered Data
Interpolation for Computer Graphics. In ACM SIGGRAPH
2014 Courses, SIGGRAPH ’14, pages 27:1—-27:69, New
York, NY, USA, 2014. ACM. 4

[2] R. K. Beatson, J. B. Cherrie, and C. T. Mouat. Fast ﬁtting
of radial basis functions: Methods based on preconditioned
GMRES iteration. Advances in Computational Mathematics,
1999. 4

[3] Federica Bogo, Javier Romero, Matthew Loper, and Michael J
Black. FAUST: Dataset and evaluation for 3D mesh regis-
tration. In Proceedings IEEE Conf. on Computer Vision and
Pattern Recognition (CVPR), Piscataway, NJ, USA, jun 2014.
IEEE. 3, 5, 11, 14, 15

[4] Federica Bogo, Javier Romero, Gerard Pons-Moll, and
Michael J. Black. Dynamic FAUST: Registering human bod-
ies in motion. In Proceedings - 30th IEEE Conference on
Computer Vision and Pattern Recognition, CVPR 2017, vol-
ume 2017-Janua, pages 5573–5582, jul 2017. 3

[5] Davide Boscaini, Jonathan Masci, Emanuele Rodol`a, and
Michael Bronstein. Learning shape correspondence with
anisotropic convolutional neural networks. Advances in Neu-
ral Information Processing Systems, pages 3197–3205, 2016.
2, 4

[6] Giorgos Bouritsas, Sergiy Bokhnyak, Stylianos Ploumpis,
Michael Bronstein, and Stefanos Zafeiriou. Neural 3D Mor-
phable Models: Spiral Convolutional Networks for 3D Shape
Representation Learning and Generation. In The IEEE In-
ternational Conference on Computer Vision (ICCV), 2019.
4

[7] Alexander M Bronstein, Michael M Bronstein, Leonidas J
Guibas, and Maks Ovsjanikov. Shape google: Geometric
words and expressions for invariant shape retrieval. ACM
Transactions on Graphics (TOG), 30(1):1–20, 2011. 1

[8] Alexander M Bronstein, Michael M Bronstein, and Ron Kim-
mel. Generalized multidimensional scaling: a framework for
isometry-invariant partial surface matching. Proceedings of
the National Academy of Sciences, 103(5):1168–1172, 2006.
1

[9] Michael M Bronstein, Joan Bruna, Yann Lecun, Arthur Szlam,
and Pierre Vandergheynst. Geometric Deep Learning: Going
beyond Euclidean data. IEEE Signal Processing Magazine,
34(4):18–42, 2017. 1

[10] Michael M Bronstein and Iasonas Kokkinos. Scale-invariant
heat kernel signatures for non-rigid shape recognition. In 2010
IEEE Computer Society Conference on Computer Vision and
Pattern Recognition, pages 1704–1711. IEEE, 2010. 1

[11] Dave Broomhead and David Lowe. Multivariable functional
interpolation and adaptive networks. Complex Systems, 2:321–
355, 1988. 3

[12] R. Qi Charles, Hao Su, Mo Kaichun, and Leonidas J Guibas.
PointNet: Deep Learning on Point Sets for 3D Classiﬁcation
and Segmentation. In 2017 IEEE Conference on Computer
Vision and Pattern Recognition (CVPR), pages 77–85. IEEE,
jul 2017. 5

[13] Yucong Chen, Junli Zhao, Qingqiong Deng, and Fuqing Duan.
3D craniofacial registration using thin-plate spline transform
and cylindrical surface projection. PLoS ONE, 2017. 3
[14] Yoni Choukroun, Gautam Pai, and Ron Kimmel. Sparse
approximation of 3d meshes using the spectral geometry of
the hamiltonian operator. Journal of Mathematical Imaging
and Vision, 60(6):941–952, 2018. 1

[15] Micha¨el Defferrard, Xavier Bresson, and Pierre Van-
dergheynst. Convolutional neural networks on graphs with
fast localized spectral ﬁltering. Advances in Neural Informa-
tion Processing Systems, (Nips):3844–3852, 2016. 2, 13
[16] Davide Eynard, Artiom Kovnatsky, Michael M Bronstein,
Klaus Glashoff, and Alexander M Bronstein. Multimodal
manifold analysis by simultaneous diagonalization of lapla-
cians. IEEE transactions on pattern analysis and machine
intelligence, 37(12):2505–2517, 2015. 2

[17] Matthias Fey, Jan Eric Lenssen, Frank Weichert, and Heinrich
M¨uller. Splinecnn: Fast geometric deep learning with continu-
ous b-spline kernels. In Proceedings of the IEEE Conference
on Computer Vision and Pattern Recognition, pages 869–877,
2018. 5, 11, 12

[18] Matthias Fey, Jan Eric Lenssen, Frank Weichert, and Heinrich
Muller. SplineCNN: Fast Geometric Deep Learning with
Continuous B-Spline Kernels. Proceedings of the IEEE Com-
puter Society Conference on Computer Vision and Pattern
Recognition, pages 869–877, 2018. 2, 6

[19] Justin Gilmer, Samuel S. Schoenholz, Patrick F. Riley, Oriol
Vinyals, and George E. Dahl. Neural message passing for
In 34th International Conference on
quantum chemistry.
Machine Learning, ICML 2017, volume 3, pages 2053–2070,
2017. 4

[20] Xavier Glorot and Yoshua Bengio. Understanding the dif-
In
ﬁculty of training deep feedforward neural networks.
Journal of Machine Learning Research, 2010. 11

[21] Shunwang Gong, Lei Chen, Michael Bronstein, and Stefanos
Zafeiriou. SpiralNet++: A Fast and Highly Efﬁcient Mesh
Convolution Operator. In The IEEE International Conference
on Computer Vision (ICCV) Workshops, oct 2019. 3, 11, 13
[22] Oshri Halimi, Or Litany, Emanuele Rodola, Alex M Bronstein,
and Ron Kimmel. Unsupervised learning of dense shape
correspondence. In Proceedings of the IEEE Conference on
Computer Vision and Pattern Recognition, pages 4370–4379,
2019. 1

[23] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun.
Deep residual learning for image recognition. In Proceedings
of the IEEE Computer Society Conference on Computer Vi-
sion and Pattern Recognition, volume 2016-Decem, pages
770–778. IEEE, jun 2016. 2, 3, 5, 8

[24] Mikael Henaff, Joan Bruna, and Yann LeCun. Deep Convolu-
tional Networks on Graph-Structured Data. pages 1–10, 2015.
4

[25] Gao Huang, Zhuang Liu, Laurens Van Der Maaten, and Kil-
ian Q. Weinberger. Densely connected convolutional net-
works. In Proceedings - 30th IEEE Conference on Computer
Vision and Pattern Recognition, CVPR 2017, 2017. 3
[26] Vladimir G Kim, Yaron Lipman, and Thomas Funkhouser.
Blended intrinsic maps. In ACM Transactions on Graphics
(TOG), volume 30, page 79. ACM, 2011. 1, 11

[27] Vladimir G. Kim, Yaron Lipman, and Thomas Funkhouser.
Blended intrinsic maps. ACM Transactions on Graphics,
30(4):1, jul 2011. 7

[28] Diederik P Kingma and Jimmy Ba. Adam: A method for
stochastic optimization. arXiv preprint arXiv:1412.6980,
2014. 11

[29] Thomas N Kipf and Max Welling. Semi-Supervised Classiﬁ-
cation with Graph Convolutional Neural Networks. In ICLR
2017, pages 1–14, 2017. 2, 5, 15

[30] Artiom Kovnatsky, Michael M Bronstein, Alexander M Bron-
stein, Klaus Glashoff, and Ron Kimmel. Coupled quasi-
harmonic bases. In Computer Graphics Forum, volume 32,
pages 439–448. Wiley Online Library, 2013. 2

[31] Guohao Li, Matthias Muller, Ali Thabet, and Bernard
Ghanem. DeepGCNs: Can GCNs Go As Deep As CNNs?
In The IEEE International Conference on Computer Vision
(ICCV), 2019. 2, 3

[32] Qimai Li, Zhichao Han, and Xiao Ming Wu. Deeper insights
into graph convolutional networks for semi-supervised learn-
ing. In 32nd AAAI Conference on Artiﬁcial Intelligence, AAAI
2018, 2018. 8

[33] Isaak Lim, Alexander Dielen, Marcel Campen, and Leif
Kobbelt. A Simple Approach to Intrinsic Correspondence
Learning on Unstructured 3D Meshes. In Computer Vision -
ECCV 2018 Workshops - Munich, Germany, September 8-14,
2018, Proceedings, Part III, pages 349–362, 2018. 3
[34] Or Litany, Alex Bronstein, Michael Bronstein, and Ameesh
Makadia. Deformable Shape Completion with Graph Convo-
lutional Autoencoders. Proceedings of the IEEE Computer
Society Conference on Computer Vision and Pattern Recogni-
tion, (128):1886–1895, 2018. 2

[35] Jonathan Masci, Davide Boscaini, Michael M. Bronstein,
and Pierre Vandergheynst. Geodesic Convolutional Neural
Networks on Riemannian Manifolds. Proceedings of the
IEEE International Conference on Computer Vision, 2015-
Febru:832–840, 2015. 2, 4

[36] Alessio Micheli. Neural network for graphs: A contextual con-
structive approach. IEEE Transactions on Neural Networks,
2009. 3

[37] Federico Monti, Davide Boscaini, Jonathan Masci, Emanuele
Rodol`a, Jan Svoboda, and Michael M. Bronstein. Geometric
deep learning on graphs and manifolds using mixture model
CNNs. Proceedings - 30th IEEE Conference on Computer Vi-
sion and Pattern Recognition, CVPR 2017, 2017-Janua:5425–
5434, 2017. 2, 6, 11, 12, 14

[38] John Moody and Christian J. Darken. Fast Learning in Net-
works of Locally-Tuned Processing Units. Neural Computa-
tion, 1989. 3

[39] Maks Ovsjanikov, Mirela Ben-Chen, Justin Solomon, Adrian
Butscher, and Leonidas Guibas. Functional maps: a ﬂexible
representation of maps between shapes. ACM Transactions
on Graphics (TOG), 31(4):1–11, 2012. 1

[40] Trang Pham, Truyen Tran, Dinh Phung, and Svetha Venkatesh.
Column networks for collective classiﬁcation. In 31st AAAI
Conference on Artiﬁcial Intelligence, AAAI 2017, 2017. 2
[41] Afshin Rahimi, Trevor Cohn, and Timothy Baldwin. Semi-
supervised user geolocation via graph convolutional networks.

In ACL 2018 - 56th Annual Meeting of the Association for
Computational Linguistics, Proceedings of the Conference
(Long Papers), 2018. 2

[42] Anurag Ranjan, Timo Bolkart, Soubhik Sanyal, and Michael J
Black. Generating 3D Faces using Convolutional Mesh Au-
toencoders. In The European Conference on Computer Vision
(ECCV), sep 2018. 2, 3, 4, 5, 6, 11, 12, 13

[43] Taehyun Rhee, Youngkyoo Hwang, James Dokyoon Kim, and
Changyeong Kim. Real-time facial animation from live video
tracking. In Proceedings - SCA 2011: ACM SIGGRAPH /
Eurographics Symposium on Computer Animation, 2011. 3
[44] Song, S., A Khosla, Xiao, and J. 3D ShapeNets: A deep
representation for volumetric shapes. In The IEEE Conference
on Computer Vision and Pattern Recognition (CVPR), pages
1912–1920, jun 2015. 1

[45] Rupesh Kumar Srivastava, Klaus Greff, and J¨urgen Schmid-
huber. Highway networks. arXiv preprint arXiv:1505.00387,
2015. 3

[46] Rupesh K Srivastava, Klaus Greff, and J¨urgen Schmidhuber.
Training very deep networks. In Advances in neural informa-
tion processing systems, pages 2377–2385, 2015. 3

[47] Petar Veliˇckovi´c, Guillem Cucurull, Arantxa Casanova, Adri-
ana Romero, Pietro Li`o, and Yoshua Bengio. Graph Attention
Networks. ICLR, oct 2018. 2

[48] Nitika Verma, Edmond Boyer, and Jakob Verbeek. FeaStNet:
Feature-Steered Graph Convolutions for 3D Shape Analysis.
In Proceedings of the IEEE Computer Society Conference on
Computer Vision and Pattern Recognition, jun 2018. 2, 11,
12, 14

[49] Yue Wang, Yongbin Sun, Ziwei Liu, Sanjay E Sarma,
Michael M Bronstein, and Justin M Solomon. Dynamic Graph
CNN for Learning on Point Clouds. ACM Trans. Graph.,
38(5):146:1—-146:12, oct 2019. 3

[50] Lingyu Wei, Qixing Huang, Duygu Ceylan, Etienne Vouga,
and Hao Li. Dense human body correspondences using convo-
lutional networks. Proceedings of the IEEE Computer Society
Conference on Computer Vision and Pattern Recognition,
2016-Decem:1544–1553, nov 2016. 1

[51] Zonghan Wu, Shirui Pan, Fengwen Chen, Guodong Long,
Chengqi Zhang, and Philip S. Yu. A Comprehensive Survey
on Graph Neural Networks. jan 2019. 3, 4

[52] Keyulu Xu, Weihua Hu, Jure Leskovec, and Stefanie Jegelka.
How Powerful are Graph Neural Networks? Int. Conf. on
Learning Representations, oct 2018. 3, 6, 8, 11

[53] Keyulu Xu, Chengtao Li, Yonglong Tian, Tomohiro Sonobe,
Ken Ichi Kawarabayashi, and Stefanie Jegelka. Representa-
tion learning on graphs with jumping knowledge networks. In
35th International Conference on Machine Learning, ICML
2018, 2018. 2

[54] Fisher Yu and Vladen Koltun. Multi-Scale Context Aggrega-

tion by Dilated Convolutions. ICLR, jun 2016. 2

Supplementary Material

This supplementary material provides further details that
is not be included in the main text: Section A provides imple-
mentation details on the experiments used in Section 5 of the
paper, and Section B further describes the results obtained by
SplineCNN [17] with and without the proposed afﬁne skip
connections on the task of shape reconstruction. Figures 7
and 9 show the faces reconstructed by autoencoders built
with each convolution operator presented in Table 1 of the
paper, at kernel size 14. Figures 10 and 11 show the visual-
ization of shapes colored by the pointwise geodesic error of
different methods on the FAUST [3] humans dataset.

A. Implementation Details

For all experiments we initialize all trainable weight pa-
rameters with Glorot initialization [20] and biases with con-
stant value 0. The only exception is FeaStNet [48], for which
weight parameters (e.g. W, µ, c) are drawn from N (0, 0.1).
The vertex features fed to the models are the raw 3D Carte-
sian coordinates (for the CoMA [42] and FAUST datasets)
or the 1D superpixel intensity (for the Superpixel MNIST
dataset [37]). The pseudo-coordinates used in MoNet [37]
and SplineCNN [17] are the pre-computed relative Carte-
sian coordinates of connected nodes. Note that in Superpixel
MNIST classiﬁcation experiments, we compared the perfor-
mance of MoNet using pseudo-coordinates computed from
relative Cartesian coordinates which considering vertex po-
sitions as well as globally normalized degree of target nodes
for the sake of the fairness. All experiments are ran on a
single NVIDIA RTX 2080 Ti.

Shape reconstruction We perform experiments on the
CoMA dataset [42]. We follow the interpolation experimen-
tal setting in [42], the dataset is split in training and test
sets with a ratio of 9 : 1. We normalize the input data by
subtracting the mean and dividing by the standard deviation
obtained on the training set and we de-normalize the out-
put before visualization. We quantitatively evaluate models
with the pointwise Euclidean error (we report the mean, stan-
dard deviation, and median values) and the visualizations for
qualitative evaluation.

The experimental setting is identical to [21]. The network
architecture is 3 × {Conv(32)→ Pool(4)} → {Conv(64) →
Pool(4)} → FC(16) for the encoder, and a symmetrical de-
coder with one additional Conv(3) output to reconstruct 3D
coordinates, with ELU activations after each convolutional
layer except on the output layer that has no activate. We
used the same downsampling and upsampling approach in-
troduced in [42]. Models are trained with Adam [28] for 300
epochs with an initial learning rate of 0.001 and a learning
rate decay of 0.99 per epoch, minimizing the (cid:96)1 vertex-wise
loss. The batch size is 32.

Mesh correspondence We perform experiments on the
FAUST dataset [3], containing 10 scanned human shapes in
10 different poses, resulting in a total of 100 non-watertight
meshes with 6,890 nodes each. The ﬁrst 80 subjects in
FAUST were used for training and the remaining 20 sub-
jects for testing, following [37]. Correspondence quality is
measured according to the Princeton benchmark protocol
[26], counting the percentage of derived correspondences
that lie within a geodesic radius r around the correct node.

We use the single scale architecture of [48] with
layer. We obtain the architecture

an added dropout
Lin(16)→Conv(32)→Conv(64)→Conv(128)→Lin(256)
→Dropout(0.5)→Lin(6890), where Lin(o) denotes a 1 × 1
convolution layer that produces o output features per node.
We use ELU non-linear activation functions after each Conv
layer, and after the ﬁrst Lin layer. We use a softmax activa-
tion for the last layer. Models are trained with the standard
cross-entropy loss for 1000 epochs. We use the Adam opti-
mizer with an initial learning rate of 0.001 for MoNet (with
and without afﬁne skip connections) and GCN (vanilla, Res
and Aff ), and an initial learning rate of 0.01 for FeaStNet
(with and without afﬁne skip connections). We decay the
learning rate by a factor of 0.99 every epoch for MoNet (with
and without afﬁne skip connections) and GCN (vanilla, Res
and Aff ), and a factor of 0.5 every 100 epochs for FeaStNet
(with and without afﬁne skip connections). We use a batch
size of 1. Note that for Res-GCN, we use zero-padding
shortcuts for mismatched dimensions.

Superpixel MNIST classiﬁcation Experiments are con-
ducted on the Superpixel MNIST dataset introduced in [37],
where MNIST images are represented as graphs with differ-
ent connectivity, each containing 75 vertices. The dataset is
split into training and testing sets of 60k and 10k samples
respectively.

Our architecture is similar to the one introduced
layers, and reads

in [37] with three convolutional
Conv(32)→Pool(4)→Conv(64)→Pool(4)→Conv(64)→AvgP
→FC(128)→Dropout(0.5)→FC(10). Pool(4) is based on
the Graclus graph coarsening approach, downsampling
graphs by approximately a factor of 4. AvgP denotes a
readout layer that averages features in the node dimension.
As for the nonlinearity, ELU activation functions are used
after each layer except for the last layer that uses softmax.
We train networks using the Adam optimizer for 500
epochs, with an initial learning rate of 0.001 and learning
rate decay of 0.5 after every 30 epochs. We minimize the
cross-entropy loss. The batch size is 64 and we use (cid:96)2
regularization with a weight of 0.0001. For each GIN-0 [52]
layer, we use a 2-layer MLP with ReLU activations, and
batch normalization right after each GIN layer.

Figure 7: Pointwise error (Euclidean distance from groundtruth) of the reconstructions by FeaStNet [48] and MoNet [37]
(both with and without afﬁne skip connections) on the CoMA [42] test dataset. The reported errors (bottom-right corner of
each row) represent the per-point mean error and its standard deviation. For visualization clarity, the error values are saturated
at 5 millimeters. Hot colors represent large errors.

B. Further Results with SplineCNN

For the sake of completeness, We show additional re-
sults with the SplineCNN [17] operator to validate the pro-
posed block. We report the performance on the shape recon-
struction benchmark. SplineCNN is conceptually similar by
deﬁnition to MoNet [37], with a kernel function gΘ(ui,j)
represented on the tensor product of weighted B-Spline func-
tions, that takes as input relative pseudo-coordinates ui,j.
SplineCNN and MoNet both leverage the advantages of at-
tention mechanisms to learn intrinsic features. To follow
the deﬁnitions in Section 2 in the paper, we formulate the
SplineCNN convolution as

x(k)
i =

1
|N (i)|

(cid:88)

j∈N (i)

x(k−1)
j

· gΘ(ui,j).

(13)

Figure 8: The pointwise mean euclidean error of SplineCNN
and Aff -SplineCNN for shape reconstruction experiments on
the CoMA [42] dataset.

Figure 9: Pointwise error (Euclidean distance from groundtruth) of the reconstructions by ChebNet [15] and SpiralNet++ [21]
(ablation study) on the CoMA [42] test dataset. We reformulated ChebNet and SpiralNet++ to remove the separate weight
of the center vertex while keeping the same number of weight matrices, denoted as †. The detailed formulas are explained
in Section 5.1 of the paper. The reported errors (bottom-right corner of each row) represent the per-point mean error and its
standard deviation. For visualization clarity, the error values are saturated at 5 millimeters. Hot colors represent large errors.

Let m = (m1, . . . , md) the d-dimensional kernel size.
For 3D data, the number of trainable weight matrices is
M = (cid:81)d
i=1 mi = m3, with equal kernel size in each three
dimension.

We show the results (Figure 8) obtained with SplineCNN
and kernel sizes m = 1, . . . , 5. We ﬁx the B-Spline degree
to 1, for both with and without afﬁne skip connections7.
The rest of the experimental setup and hyperparameters is
identical to Section A. Clearly, as shown in Figure 8, the
performance of Aff -SplineCNN is consistently better than

7It should be noted that the implementation of SplineCNN provided by
the author already uses a separate weight for the center vertex. To allow for
a fair assessment of the afﬁne skip connections, we tacitly assumed here
that the propagation of SplineCNN is only based on Eq. 13

that of SplineCNN, achieving the smallest error of all models
at 0.241 with kernel size 5 in each dimension (i.e. 125 in
total as the growth rate is cubical). Interestingly, SplineCNN
(Aff -SplineCNN) does not outperform MoNet (Aff -MoNet)
when the number of weight matrices is the same. For in-
stance, for M = 8, the mean Euclidean errors of MoNet and
Aff -MoNet are 0.531 and 0.397 respectively, whereas the
mean Euclidean errors of SplineCNN and Aff -SplineCNN
are 0.605 and 0.501.

Figure 10: Pointwise error (geodesic distance from groundtruth) of FeaStNet [48] and MoNet [37] (both with and without
afﬁne skip connections) on the FAUST [3] humans dataset. The reported accuracy values (bottom-right corner of each row)
represent the percentage of correct correspondence at geodesic error 0. For visualization clarity, the error values are saturated
at 10% of the geodesic diameter. Darker colors represent large errors.

Figure 11: Pointwise error (geodesic distance from groundtruth) of vanilla GCN [29], Res-GCN and Aff -GCN on the FAUST
[3] humans dataset. Aff -GCN replaces the residual connections of Res-GCN to the proposed afﬁne skip connections. The rest
are the same. The reported accuracy values (bottom-right corner of each row) represent the percentage of correspondence
at geodesic error 0. For visualization clarity, the error values are saturated at 10% of the geodesic diameter. Darker colors
represent large errors.

