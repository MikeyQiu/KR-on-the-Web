Variational Adaptive-Newton Method for Explorative Learning

Mohammad Emtiyaz Khan

Wu Lin

Voot Tangkaratt

Zuozhu Liu

Didrik Nielsen

Center for Advanced Intelligence Project (AIP), RIKEN, Tokyo, Japan

7
1
0
2
 
v
o
N
 
5
1
 
 
]
L
M

.
t
a
t
s
[
 
 
1
v
0
6
5
5
0
.
1
1
7
1
:
v
i
X
r
a

Abstract

We present
the Variational Adaptive Newton
(VAN) method which is a black-box optimiza-
tion method especially suitable for explorative-
learning tasks such as active learning and rein-
forcement learning. Similar to Bayesian meth-
ods, VAN estimates a distribution that can be
used for exploration, but requires computations
that are similar to continuous optimization meth-
ods. Our theoretical contribution reveals that
VAN is a second-order method that uniﬁes exist-
ing methods in distinct ﬁelds of continuous op-
timization, variational inference, and evolution
strategies. Our experimental results show that
VAN performs well on a wide-variety of learn-
ing tasks. This work presents a general-purpose
explorative-learning method that has the poten-
tial to improve learning in areas such as active
learning and reinforcement learning.

1

Introduction

Throughout our life, we continue to learn about the world
by sequentially exploring it. We acquire new experiences
using old ones, and use the new ones to learn even more.
How can we design methods that can perform such “explo-
rative” learning to obtain good generalizations? This is an
open question in artiﬁcial intelligence and machine learn-
ing.

One such approach is based on Bayesian methods. This
approach has not only been used as a theoretical model
of human cognitive development (Perfors et al., 2011) but
also been applied to a wide variety of practical explorative-
learning tasks, e.g., in active learning and Bayesian op-
timization to select informative data examples (Houlsby
et al., 2011; Gal et al., 2017; Brochu et al., 2010; Fishel
and Loeb, 2012), and in reinforcement learning to learn

through interactions (Wyatt, 1998; Strens, 2000). Unfortu-
nately, Bayesian methods are computationally demanding
because computation of the posterior distribution is a difﬁ-
cult task, especially for large-scale problems. In contrast,
non-Bayesian methods, such as those based on continuous
optimization methods, are generally computationally much
cheaper, but they cannot directly exploit the mechanisms of
Bayesian exploration because they do not estimate the pos-
terior distribution. This raises the following question: how
can we design explorative-learning methods that compute
a distribution just like Bayesian methods, but cost similar
to optimization methods?

In this paper, we propose such a method. Our method
can be used to solve generic unconstrained function-
minimization problems1 that take the following form:

θ∗ = argmin

f (θ), where θ ∈ RD.

(1)

θ

A wide variety of problems in supervised, unsupervised,
and reinforcement learning can be formulated in this way.
Instead of directly solving the above problem, our method
solves it indirectly by ﬁrst taking the expectation of f (θ)
with respect to an unknown probability distribution q(θ|η),
and then solving the following minimization problem:

min
η

Eq(θ|η) [f (θ)] := L(η).

(2)

where minimization is done with respect to the parame-
ter η of the distribution q. This approach is referred to
as the Variational Optimization (VO) approach by Staines
and Barber (2012) and can lead us to the minimum θ∗ be-
cause L(η) is an upper bound on the minimum value of
f , i.e., minθ f (θ) ≤ Eq(θ|η) [f (θ)]. Therefore minimizing
L(η) minimizes f (θ), and when the distribution q puts all
its mass on θ∗, we recover the minimum value. This type
of function minimization is commonly used in many areas
of stochastic search such as evolution strategies (Hansen
and Ostermeier, 2001; Wierstra et al., 2008). In our prob-
lem context, this formulation is advantageous because it
enables learning via exploration, where exploration is fa-
cilitated through the distribution q(θ|η).

1This is a black-box optimization problem in the sense that we
may not have access to an analytical form of the function or its
derivatives, but we might be able to approximate them at a point.

Variational Adaptive-Newton Method

Our main contribution is a new method to solve (2) by us-
ing a mirror-descent algorithm. We show that our algo-
rithm is a second-order method which solves the original
problem (1), even though it is designed to solve the prob-
lem (2). Due to its similarity to Newton’s method, we refer
to our method as the Variational Adaptive Newton (VAN)
method. Figure 1 shows an example of our method for a
one-dimensional non-convex function.

We establish connections of our method to many existing
methods in continuous optimization, variational inference,
and evolution strategies, and use these connections to de-
rive new algorithms for explorative learning. Below, we
summarize the contributions made in the rest of the paper:

• In Section 3, we derive VAN and establish it as
a second-order method.
In Section 4, we derive
computationally-efﬁcient versions of VAN and dis-
cuss their relations to adaptive-gradient methods.

• In Section 5 and 6, we show connections to varia-
tional inference methods and natural evolution strat-
egy (Wierstra et al., 2008).

• In Section 7, we apply our method to supervised lean-
ing, unsupervised learning, active learning, and rein-
forcement learning. In Section 8, we discuss relevance
and limitations of our approach.

This work presents a general-purpose explorative-learning
method that has the potential to improve learning in areas
such as active learning and reinforcement learning.

2 Variational Optimization

We will focus on solving the problem (2) since it enables
estimation of a distribution that can be used for exploration.
In this paper, we will use the Gaussian distribution q(θ).
The problem (2) can then be rewritten as follows,

EN (θ|µ,Σ) [f (θ)] := L(µ, Σ)

(3)

min
µ,Σ

where q is the Gaussian distribution q(θ|η) := N (θ|µ, Σ)
with µ being the mean and Σ being the covariance, and
η = {µ, Σ}. The function L is differentiable under mild
conditions even when f is not differentiable, as discussed
in Staines and Barber (2012). This makes it possible to
apply gradient-based optimization methods to optimize it.

A straightforward approach to minimize L is to use
Stochastic Gradient Descent (SGD) as shown below,

V-SGD : µt+1 = µt − ρt

Σt+1 = Σt − ρt

(cid:104)

(cid:105)

(cid:105)

(cid:98)∇µLt
(cid:104)
(cid:98)∇ΣLt

(4)

(5)

where ρt > 0 is a step size at iteration t, (cid:98)∇ denotes an un-
biased stochastic-gradient estimate, and Lt = L(µt, Σt).

Illustrative application of VAN on an exam-
Figure 1:
ple by Huszar (2017). The top ﬁgure shows the function
f (θ) = sinc(θ) with a blue curve. The global minima
is at θ∗ = 1 although there are many local minima and
maxima as well. The second plot shows the VO objec-
tive L(µ, σ) = Eq[f (θ)] for the Gaussian q = N (θ|µ, σ2).
The red points and arrows show the iterations of our VAN
method initialized at µ = −3.2 and σ = 1.5. The θ val-
ues corresponding to the value of µ are marked in the top
ﬁgures where we see that these iterations converge to the
global minima of f and avoids other local optima. When
we use a Newton’s method initialized at the same point,
i.e., θ0 = −3.2, it converges to the local minima at -3.5.
VAN can avoid such local minima because it optimizes in
the space of µ and σ2. The progression of the distribution
q is shown in the bottom ﬁgure, where darker curves indi-
cate higher iterations. We see that the distribution q is ﬂat
in the beginning which enables more exploration which in
turn helps the method to avoid local minima. As desired,
the distribution peaks around θ∗ as iterations increase.

We refer to this approach as Variational SGD or simply V-
SGD to differentiate it from the standard SGD that opti-
mizes f (θ) in the θ space.

The V-SGD approach is simple and can also work well
when used with adaptive-gradient methods to adapt the
step-size, e.g., AdaGrad and RMSprop. However, as
pointed by Wierstra et al. (2008), it has issues, especially
when REINFORCE (Williams, 1992) is used to estimate

Khan, Lin, Tangkaratt, Liu, and Nielsen

the gradients of f (θ). Wierstra et al. (2008) argue that
the V-SGD update becomes increasingly unstable when the
covariance is small, while becoming very small when the
covariance is large. To ﬁx these problems, Wierstra et al.
(2008) proposed a natural-gradient method. Our method is
also a natural-gradient method, but, as we show in the next
section, its updates are much simpler and they lead to a
second-order method which is similar to Newton’s method.

3 Variational Adaptive-Newton Method

VAN is a natural-gradient method derived using a mirror-
descent algorithm. Due to this, the updates of VAN are
fundamentally different from V-SGD. We will show that
VAN adapts the step-sizes in a very similar spirit to the
adaptive-gradient methods. This property will be crucial in
establishing connections to Newton’s method.

VAN can be derived by making two minor modiﬁcations to
the V-SGD objective. Note that the V-SGD update in (4)
and (5) are solutions of following optimization problem:

ηt+1 = argmin

η, (cid:98)∇ηLt

+

(cid:68)

(cid:69)

η

1
2ρt

(cid:107)η − ηt(cid:107)2.

(6)

The equivalence to the update (4) and (5) can be shown by
simply taking the derivative with respect to η of (6) and
setting it to zero:

(cid:98)∇ηLt +

(ηt+1 − ηt) = 0,

(7)

1
ρt

which results in the update (4) and (5). A simple inter-
pretation of this optimization problem is that, in V-SGD,
we choose the next point η along the gradient but contain
it within a scaled (cid:96)2-ball centered at the current point ηt.
This interpretation enables us to obtain VAN by making
two minor modiﬁcations to V-SGD.

The ﬁrst modiﬁcation is to replace the Euclidean distance
(cid:107) · (cid:107)2 by a Bregman divergence which results in the mirror-
descent method. Note that, for exponential-family distribu-
tions, the Kullback-Leibler (KL) divergence corresponds to
the Bregman divergence (Raskutti and Mukherjee, 2015).
Using the KL divergence results in natural-gradient updates
which results in better steps when optimizing the parameter
of a probability distribution (Amari, 1998).

The second modiﬁcation is to optimize the VO objective
with respect to the mean parameterization of the Gaus-
sian distribution m := {µ, µµT + Σ} instead of the pa-
rameter η := {µ, Σ}. We emphasize that this modiﬁca-
tion does not change the solution of the optimization prob-
lem since the Gaussian distribution is a minimal exponen-
tial family and the relationship between η and m is one-
to-one (see Section 3.2 and 3.4.1 of Wainwright and Jor-
dan (2008) on the basics of exponential family and mean-
parameterization respectively).

The two modiﬁcations give us the following problem:

mt+1 = argmin

m, (cid:98)∇mLt

+

(cid:68)

(cid:69)

D

KL[q (cid:107) qt],

(8)

1
βt

m

where q := q(θ|m), qt := q(θ|mt), and D
KL[q (cid:107) qt] =
Eq[log(q/qt)] denotes the KL divergence. The conver-
gence of this procedure is guaranteed under mild conditions
(Ghadimi et al., 2014).

As shown in Appendix A, a solution to this optimization
problem is given by

(cid:104)

(cid:105)

µt+1 = µt − βt Σt+1
(cid:104)

Σ−1

t+1 = Σ−1

t + 2βt

(cid:98)∇µLt
(cid:105)

(cid:98)∇ΣLt

(9)

(10)

The above update differs from those of V-SGD in two ways.
First, here we update the precision matrix Σ−1 while in V-
SGD we update the covariance matrix Σ. However, both
updates use the gradient with respect to Σ. Second, the
step-size for µt+1 are adaptive in the above update since
βt is scaled by the covariance Σt+1.

The above updates corresponds to a second-order method
which is very similar to Newton’s method. We can show
this using the following identities (Opper and Archambeau,
2009):

(11)

(12)

(13)

(14)

∇µEq [f (θ)] = Eq [∇θf (θ)] ,
∇ΣEq [f (θ)] = 1
2

(cid:2)∇2

θθf (θ)(cid:3) .

Eq

By substituting these into (9) and (10), we get the following
updates which we call the VAN method:

VAN: µt+1 = µt − βt P−1
Eqt
t+1
(cid:104)
(cid:98)∇2

Pt+1 = Pt + βt Eqt

(cid:105)
(cid:104)
(cid:98)∇θf (θ)
(cid:105)
θθf (θ)

:= Σ−1

t

is the precision matrix and qt

where Pt
:=
N (θ|µt, Σt). The precision matrix Pt contains a running-
sum of the past averaged Hessians, and the search-
direction for the mean is obtained by scaling the averaged
gradients by the inverse of Pt. If we compare Eq. 9 to the
following update of Newton’s method,

θt+1 = θt − ρt

(cid:2)∇2

θθf (θt)(cid:3)−1

[∇θf (θt)] ,

(15)

we can see that the Hessian matrix is replaced by the Pre-
cision matrix in the VAN update. Due to this connection to
Newton’s method and the use of an adaptive scaling matrix
Pt, we call our method the Variational Adaptive-Newton
(VAN) method.

The averaged gradient and running sum of averaged Hes-
sian allow VAN to avoid some types of local optima. Fig-
ure 1 shows such a result when minimizing2 f (θ) =

2This example is discussed in a blog by Huszar (2017)

Variational Adaptive-Newton Method

sinc(θ) with initial solution at θ = −3.2. Clearly, both
the gradient and Hessian at θ0 suggest updating θ towards
a local optimum at θ = −3.5. However, VAN computes
an averaged gradient over samples from q(θ) which yields
steeper descent directions pointing towards the global op-
timum. The adaptive scaling of the steps further ensures a
smooth convergence.

The averaging property of VAN is strikingly different from
other second-order optimization methods. We expect VAN
to be more robust due to averaging of gradients and Hes-
sians. Averaging is particularly useful for optimization
of stochastic objectives. For such objectives, applica-
tion of Newton’s method is difﬁcult because reliably se-
lecting a step-size is difﬁcult. Several variants of New-
ton’s method have been proposed to solve this difﬁculty,
e.g., based on quasi-Newton methods (Byrd et al., 2016)
or incremental approaches (G¨urb¨uzbalaban et al., 2015),
or by simply adapting mini-batch size (Mokhtari et al.,
2016). VAN is most similar to the incremental approach
of (G¨urb¨uzbalaban et al., 2015) where a running sum of
past Hessians is used instead of just a single Hessian. In
VAN however the Hessian is replaced by the average of
Hessians with respect to q. For stochastic objectives, VAN
differs substantially from existing approaches and it has the
potential to be a viable alternative to them.

An issue with using the Hessian is that it is not always
positive semi-deﬁnite, for example, for non-convex prob-
lems. For such cases, we can use a Gauss-Newton vari-
ant shown below Bertsekas (1999) which we call the Vari-
ational Adaptive Gauss-Newton (VAG) Method:

VAG: Pt+1 = Pt + βtEqt

(cid:104)

[∇θf (θ)] [∇θf (θ)]T (cid:105)

. (16)

4 VAN for Large-Scale Problems

Applying VAN to problems with large number of param-
eters is not feasible because we cannot compute the exact
Hessian matrix. In this section, we describe several vari-
ants of VAN that scale to large problems. Our variants
are similar to existing adaptive-gradient methods such as
AdaGrad Duchi et al. (2011) and AROW (Crammer et al.,
2009). We derive these variants by using a mean-ﬁeld ap-
proximation for q. Our derivation opens up the possibility
of a new framework for designing computationally efﬁcient
second-order methods by using structured distributions q.

One of the most common way to obtain scalability is to use
a diagonal approximation of the Hessian. In our case, this
approximation corresponds to a distribution q with diago-
nal covariance, i.e., q(θ|η) = (cid:81)D
d), where
σ2
d is the variance. This is a common approximation in
variational inference methods and is called the mean-ﬁeld
approximation (Bishop, 2006). Let us denote the precision
parameters by sd = 1/σ2
d, and a vector containing them by
s. Using this Gaussian distribution in the update (13) and

d=1 N (θd|µd, σ2

(14), we get the following diagonal version of VAN, which
we call VAN-D:

VAN-D: µt+1 = µt − βt diag(st+1)−1Eqt [∇θf (θ)]

st+1 = st + βt Eqt [h(θ)]

(17)

where diag(s) is a diagonal matrix containing the vector
s as its diagonal and h(θ) is the diagonal of the Hessian
∇2

θθf (θ).

The VAN-D update requires computation of the expecta-
tion of the diagonal of the Hessian, which could still be
difﬁcult to compute. Fortunately, we can compute its ap-
proximation easily by using the reparameterization trick
(Kingma and Ba, 2014). This is possible in our framework
because we can express the expectation of the Hessian as
gradients of an expectation, as shown below:

Eq

(cid:2)∇2

θdθd

d

f (θ)(cid:3) = 2∇σ2
= 2∇σ2
= 2EN ((cid:15)|0,1)

[Eq[f (θ)]] ,
EN ((cid:15)|0,1) [f (µd + σd(cid:15))] ,
(cid:105)
f (µd + σd(cid:15))

∇σ2

(cid:104)

d

d

(18)

(19)

, (20)

where the ﬁrst step is obtained using (11). In general, we
can use the stochastic approximation by simultaneous per-
turbation (SPSS) method (Bhatnagar, 2007; Spall, 2000)
to compute derivatives. A recent paper by Salimans et al.
(2017) showed that this type of computation can also be
parallelized which is extremely useful for large-scale learn-
ing. Note that these tricks cannot be applied directly to
standard continuous-optimization methods. The presence
of expectation with respect to q in VO enables us to lever-
age such stochastic approximation methods for large-scale
learning.

Finally, when f (θ) corresponds to a supervised or unsu-
pervised learning problem with large data, we could com-
pute its gradients by using stochastic methods. We use this
version of VAN in our large-scale experiments and call it
sVAN, which is an abbreviation for stochastic-VAN.

4.1 Relationship with Adaptive-Gradient Methods

The VAN-D update given in (17) is closely-related to an
adaptive-gradient method called AdaGrad (Duchi et al.,
2011) which uses the following updates:

AdaGrad: θt+1 = θt − ρtdiag(st+1)−1/2g(θt)

st+1 = st + [g(θt) (cid:12) g(θt)]

(21)

(22)

Comparing these updates to (17), we can see that both Ada-
Grad and VAN-D compute the scaling vector st using a
moving average. However, there are some major differ-
ences between their updates: 1. VAN-D uses average gra-
dients instead of a gradient at a point, 2. VAN-D does not
raise the scaling matrix to the power of 1/2, 3. The update
of st in VAN-D uses the diagonal of the Hessian instead of

Khan, Lin, Tangkaratt, Liu, and Nielsen

Table 1: Variants of VAN used in our experiments.

Method
VAN
sVAN
sVAN-Exact
sVAN-D
sVAN-Active
sVAG
sVAG-D

Description
Variational Adaptive-Newton Method using (13) and (14).
Stochastic VAN (gradient estimated using mini-batches).
Stochastic VAN with no MC sampling.
Stochastic VAN with diagonal covariance Σ.
Stochastic VAN using active learning.
Stochastic Variational Adaptive Gauss-Newton Method.
Stochastic VAG with diagonal covariance Σ.

the squared gradient values used in AdaGrad. It is possi-
ble to use the squared gradient in VAN-D but since we can
compute the Hessian using the reparameterization trick, we
do not have to make further approximations.

VAN can be seen as a generalization of an adaptive method
called AROW (Crammer et al., 2009). AROW uses a mir-
ror descent algorithm that is very similar to ours, but has
been applied only to problems which use the Hinge Loss.
Our approach not only generalizes AROW but also brings
new insights connecting ideas from many different ﬁelds.

5 VAN for Variational Inference

Variational inference (VI) enables a scalable computation
of the Bayesian posterior and therefore can also be used for
explorative learning. In fact, VI is closely related to VO.
In VI, we compute the posterior approximation q(θ|η) for
a model p(y, θ) with data y by minimizing the following
objective:

(cid:20)

Eq(θ|η)

− log

min
η

(cid:21)

p(y, θ)
q(θ|η)

:= LV I (η)

(23)

We can perform VI by using VO type of method on the
function inside the square bracket. A small difference here
is that the function to be optimized also depends on param-
eters η of q. Conjugate-computation variational inference
(CVI) is a recent approach for VI by Khan and Lin (2017).
We note that by applying VAN to the variational objective,
one recovers CVI. VAN however is more general than CVI
since it applies to many other problems other than VI. A
direct consequence of our connection is that CVI, just like
VAN, is also a second-order method to optimize fV I (θ),
and is related to adaptive-gradient methods as well. There-
fore, using CVI should give better results than standard
methods that use update similar to V-SGD, e.g., black-box
VI method of Ranganath et al. (2014).

6 VAN for Evolution Strategies

VAN performs natural-gradient update in the parameter-
space of the distribution q (as discussed earlier in Section
3). The connection to natural-gradients is based on a recent
result by Raskutti and Mukherjee (2015) that shows that
the mirror descent using a KL divergence for exponential-

family distributions is equivalent to a natural-gradient de-
scent. The natural-gradient corresponds to the one ob-
tained using the Fisher information of the exponential fam-
ily distribution. In our case, the mirror-descent algorithm
(8) uses the Bregman divergence that corresponds to the
KL divergence between two Gaussians. Since the Gaus-
sian is an exponential-family distribution, mirror descent
(8) is equivalent to natural-gradient descent in the dual Rie-
mannian manifold of a Gaussian. Therefore, VAN takes a
natural-gradient step by using a mirror-descent step.

Natural Evolution Strategies (NES) (Wierstra et al., 2008)
is also a natural-gradient algorithm to solve the VO prob-
lem in the context of evolution strategies. NES directly
applies natural-gradient descent to optimize for µ and Σ
and this yields an infeasible algorithm since the Fisher in-
formation matrix has O(D4) parameters. To overcome this
issue, Wierstra et al. (2008) proposed a sophisticated re-
parameterization that reduces the number of parameters to
O(D2). VAN, like NES, also has O(D2) parameters, but
with much simpler updates rules due to the use of mirror
descent in the mean-parameter space.

7 Applications and Experimental Results

In this section, we apply VAN to a variety of learning
tasks to establish it as a general-purpose learning tool,
and also to show that it performs comparable to continu-
ous optimization algorithm while extending the scope of
their application. Our ﬁrst application is supervised learn-
ing with Lasso regression. Standard second-order meth-
ods such as Newton’s method cannot directly be applied to
such problems because of discontinuity. For this problem,
we show that VAN enables stochastic second-order opti-
mization which is faster than existing second-order meth-
ods such as iterative-Ridge regression. We also apply VAN
to supervised learning with logistic regression and unsu-
pervised learning with Variational Auto-Encoder, and show
that stochastic VAN gives comparable results to existing
methods such as AdaGrad. Finally, we show two applica-
tion of VAN for explorative learning, namely active learn-
ing for logistic regression and parameter-space exploration
for deep reinforcement learning.

Table 1 summarizes various versions of VAN compared
in our experiments. The ﬁrst method is the VAN method
which implements the update shown in (13) and (14).
Stochastic VAN implies that the gradients in the updates are
estimated by using minibatches of data. The sufﬁx ‘Exact’
indicates that the expectations with respect to q are com-
puted exactly, i.e., without resorting to Monte Carlo (MC)
sampling. This is possible for the Lasso objective as shown
in Staines and Barber (2012) and also for logistic regression
as shown in Marlin et al. (2011). The sufﬁx ‘D’ indicates
that a diagonal covariance with the update (17) is used. The
sufﬁx ‘Active’ indicates that minibatches are selected using

Variational Adaptive-Newton Method

an active learning method. Final, VAG corresponds to the
Gauss-Newton type update shown in (16). For all methods,
except ‘sVAN-Exact’, we use MC sampling to approximate
the expectation with respect to q. In our plot, we indicate
the number of samples by adding it as a sufﬁx, e.g., sVAN-
10 is the stochastic VAN method with 10 MC samples.

7.1 Supervised Learning: Lasso Regression

i=1 with xi ∈ RD, in lasso
Given N example pairs {yi, xi}N
regression, we minimize the following loss that contains an
(cid:96)1-regularization:

f (θ) =

(yi − θT xi)2 + λ

|θd|,

(24)

N
(cid:88)

i=1

D
(cid:88)

d=1

Because the function is non-differentiable, we cannot di-
rectly apply gradient-based methods to solve the problem.
For the same reason, it is also not possible to use second-
order methods such as Newton’s method. VAN can be ap-
plied to this method since expectation of |θd| is twice dif-
ferentiable. We use the gradient and Hessian expression
given in Staines and Barber (2012).

We compare VAN and sVAN with the iterative-ridge
method (iRidge), which is also a second-order method. We
compare on two datasets: Bank32nh (N = 8192, D =
256, Ntrain = 7290, λ = 104.81) and YearPredictionMSD
(N = 515345, D = 90, Ntrain = 448350, λ = 5994.84).
We set λ values using a validation set where we picked the
value that gives minimum error over multiple values of λ on
a grid. The iRidge implementation is based on minFunc
implementation by Mark Schmidt. For sVAN, the size of
the mini-batch used to train Bank32nh and YearPrediction-
MSD are M = 30 and M = 122 respectively. We report
the absolute difference of parameters, θ −θ∗ where θ is the
parameters estimated by a method and θ∗ is the parameters
optimal value (found by iRidge). For VAN the estimated
value is equal to the mean µ of the distribution. Results
are shown in Figure 2 (a) and (b), where we observe that
VAN and iRidge perform comparably, but sVAN is more
data-efﬁcient than them in the ﬁrst few passes. Results on
multiple runs show very similar trends.

In conclusion, VAN enables application of a stochas-
tic second-order method to a non-differentiable problem
where existing second-order method and their stochastic
versions cannot be applied directly.

7.2 Supervised Learning: Logistic Regression

In logistic regression, we minimize the following:

f (θ) =

(cid:104)
log(1 + eyi(θ(cid:62)xi))

(cid:105)

+ λ

N
(cid:88)

i=1

D
(cid:88)

d=1

θ2
d,

(25)

where yi ∈ {−1, +1} is the label.

We compare VAN to Newton’s method and AdaGrad
both of which standard algorithms for batch and stochas-
tic learning, respectively, on convex problems. We use
VAN, its stochastic version sVAN, and the diagonal ver-
sion sVAN-D. We use three real-world datasets from the
libSVM database (Chang and Lin, 2011): ‘breast-cancer-
scale’ (N = 683, D = 10, Ntrain = 341, λ = 1.88),
‘USPS’ (N = 1, 540, D = 256, Ntrain = 770, λ = 6.21),
and ‘a1a’ (N = 32, 561, D = 123, Ntrain = 1, 605, λ =
67.23). We compare the log-loss on the test set computed
as follows: (cid:80)
xi))/Ntest where ˆθ is the
parameter estimate and Ntest is the number of examples in
the test set. For sVAN and sVAN-D, we use a mini-batch
size of 10 for ‘breast-cancer-scale’ dataset and a mini-batch
of size 100 for the rest of the datasets.

i log(1+exp(yi(ˆθ

T

Results are shown in Figure 2 (d)-(j). The ﬁrst row, with
plots (d)-(f), shows comparison of Batch methods, where
we see that VAN converges at a comparable rate to New-
ton’s method. The second row, with plots (h)-(j), shows the
performance of the stochastic learning. Since sVAN uses
the full Hessian, it converges faster than sVAN-D and Ada-
Grad which use a diagonal approximation. sVAN-D shows
overall similar performance to AdaGrad. The main advan-
tage of sVAN over AdaGrad is that sVAN maintains a dis-
tribution q(θ) which can be used to evaluate the uncertainty
of the learned solution, as shown in the next subsection on
active learning.

In conclusion, VAN and sVAN give comparable results to
Newton’s method while sVAN-D gives comparable results
to AdaGrad.

7.3 Active Learning for using VAN

An important difference between active and stochastic
learning is that an active learning agent can query for its
training data examples in each iteration. In active learning
for classiﬁcation, examples in a pool of input data {xi}N
i=1
are ranked using an acquisition score which measures how
informative an example is for learning. We pick the top
M data examples as the mini-batch. Active learning is ex-
pected to be more data efﬁcient than stochastic learning
since the learning agent focuses on the most informative
data samples.

In our experiments, we use the entropy score (Schein and
Ungar, 2007) as the acquisition score to select data example
for binary logistic regression:

H(x) = −

(cid:88)

c∈{−1,1}

(cid:98)p(y = c|x) log (cid:98)p(y = c|x),

(26)

where (cid:98)p(y = c|x) is the estimated probability that the label
for input x takes a value y = c. Within our VAN frame-
work, we estimate these probabilities using distributions
q(θ) = N (θ|µt, Σt) at iteration t. We use the following

Khan, Lin, Tangkaratt, Liu, and Nielsen

Figure 2: Experimental results on different learning tasks. (a-b): Lasso regression. (c): VAE. (d-f): Logistic regression
with VAN and Newton’s method. (h-j): Logistic regression with sVAN, sVAN-D and AdaGrad. Datasets are speciﬁed in
the title. M refers to the mini-batch size for stochastic methods.

approximation that computes the probability using samples
from q:

Auto-Encoder

7.4 Unsupervised Learning with Variational

(cid:98)pt(y = c|x) ≈

p(y = c|x, θ)q(θ|µt, Σt)dθ

(27)

p(y = c|x, θ(s)

t ),

(28)

(cid:90)

≈

1
S

S
(cid:88)

s=1

where S is the number of MC samples, θ(s)
from q, and p(y|x, θ) is the logistic likelihood.

t

are sample

Figure 3 compares the performance on on the USPS dataset
with active learning by VAN for mini-batch of 10 exam-
ples. The result clearly shows that VAN with active learn-
ing is much more data efﬁcient and stable than VAN with
stochastic learning.

We apply VAN to optimize the parameters of variational
auto-encoder (VAE) (Kingma and Welling, 2013). Given
observations {yi}N
i=1 ∼ p(y), VAE models the data points
using a neural-network decoder p(yi|zi, θd) with input zi
and parameters θd. The input zi are probabilistic and
follow a prior p(zi). The encoder is also parameterized
with a neural-network but follows a different distribution
q(zi|yi, θe) with parameters θe. The goal is to learn
θ := {θd, θe} by minimizing the following,

f (θ) = −

Eq(zi|yi,θe) [log p(yi|zi, θd)]

N
(cid:88)

i=1

+D

KL[q(zi|yi, θe) (cid:107) p(zi)]]

(29)

where zi is the latent vector, and θ = {θ1, θ2} are param-
eters to be learned. Similar to previous work, we assume
p(zi) to be a standard Gaussian, and use a Gaussian en-

Variational Adaptive-Newton Method

Figure 3: Active learning on logistic regression where we
see that sVAN with active learning gives good results with
fewer number of passes through the data.

Figure 4: Parameter-based exploration for DDPG where we
see than VAN based methods perform better than explo-
ration using V-SGD or plain SGD with no exploration.

coder and a Bernoulli decoder, both parameterized by neu-
tral networks.

problem in RL.

We train the model for the binary MNIST dataset (N =
70, 000, D = 256, Ntrain = 60, 000) with mini-batches
of size M = 100 and set the dimensionality of the latent
variable to K = 3. and measure the learning performance
by the imputed log-loss of the test set using a procedure
similar to Rezende and Mohamed (2015).

We compare our methods to adaptive-gradient methods,
namely AdaGrad (Duchi et al., 2011) and RMSprop (Tiele-
man and Hinton, 2012). For all the methods, we tune the
step-size using a validation set and report the test log-loss
after convergence. Figure 2 (c) shows the results of 5 runs
of all methods. We see that all methods perform similar to
each other. RMSprop has high variance among all meth-
ods. sVAN-D-1 is slightly worse than sVAG-D-1, which is
expected since for nonconvex problems Gauss-Newton is a
better approximation than using the Hessian.

7.5 Parameter Based Exploration in Deep

Reinforcement Learning

Exploration is extremely useful in reinforcement learning
(RL), especially in environment where obtaining informa-
tive feedback is rare. Unlike most learning tasks where a
training dataset is readily available, RL agents needs to ex-
plore the state-action space to collect data. An explorative
agent that always chooses random actions might never ob-
tain good data for learning the optimal policy. On the other
hand, an exploitative agent that always chooses the current
optimal action(s) may never try suboptimal actions that can
lead to learning a better policy. Thus, striking a balance be-
tween exploration and exploitation is a must for an effec-
tive learning. However, ﬁnding such a balance is an open

In this section, we apply VAN to enable efﬁcient explo-
ration by using the parameter-based exploration (R¨uckstieß
et al., 2010). In standard RL setup, we wish to learn a pa-
rameter θ of a parametric policy π for action a = π(s; θ)
given state s. We seek an optimal θ such that a state-action
sequence (s1, a1, s2 . . . ) maximizes the expected returns
where st and at are state and action at time t, respectively.
To facilitate exploration, a common approach is to perturb
the action by a random noise (cid:15), e.g., we can simply add it
to the action a = π(s; θ) + (cid:15). In contrast, in parameter-
based exploration, exploration is facilitated in the param-
eter space as the name suggest, i.e., we sample the pol-
icy parameter θ from a distribution N (θ|µ, Σ). Our goal
therefore is to learn the distribution parameters µ and Σ.

The parameter-based exploration is better than the action-
space exploration because in the former a small pertur-
bation of a parameter result in signiﬁcant explorative be-
haviour in the action space. However, to get a similar be-
haviour through an action-space exploration, the extent of
the noise needs to be very large which leads to instability
(R¨uckstieß et al., 2010).

The existing methods for parameter-based exploration in-
dependently learn µ and Σ (similar to V-SGD) (R¨uckstieß
et al., 2010; Plappert et al., 2017; Fortunato et al., 2017).
However,
this method can be increasingly unstable as
learning progresses (as discussed in Section 2). Since VAN
exploits the geometry of the Gaussian distribution to jointly
learn µ and Σ, we expect it to perform better than the ex-
isting methods that use V-SGD.

the deep deterministic policy gradient
We consider
(DDPG) method (Silver et al., 2014; Lillicrap et al., 2015),

Khan, Lin, Tangkaratt, Liu, and Nielsen

where a local optimal θ is obtained by minimizing

f (θ) = −Ep(s)

(cid:98)Q(s, π(s, θ))

,

(30)

(cid:104)

(cid:105)

where (cid:98)Q(s, a) is an estimated of the expected return and
p(s) a state distribution. Both π and (cid:98)Q are neural networks.
We compare the performance of sVAN and sVAG against
two baseline methods denoted by SGD and V-SGD. SGD
refers to DPG where there are no exploration at all, and V-
SGD refers to an extension of DPG where the mean and
covariance of the parameter distribution are learned using
the update (4) and (5). Due to the large number of neural
networks parameters, we use diagonal approximation to the
Hessian for all methods. More details of experiments are
given in Appendix B.

The result in Figure 4 shows the performance on Half-
Cheetah from OpenAI Gym (Brockman et al., 2016) for
5 runs, where we see that VAN based methods signiﬁcantly
outperform existing methods. sVAN-D-1 and sVAG-D-1
both perform equally well. This suggests that both Hes-
sian approximations obtained by using the reparameteriza-
tion trick shown in (20) and the Gauss-Newton approxima-
tion shown in (16), respectively, are equally accurate for
this problem. We can also see that sVAN-D-10 has bet-
ter data efﬁciency than sVAN-D-1 especially in the early
stages of learning. V-SGD is able to ﬁnd a good policy
during learning but has unstable performance that degener-
ates over time, as mentioned previously. On the other hand,
SGD performs very poorly and learns a suboptimal solu-
tion. This strongly suggests that good exploration strategy
is crucial to learn good policies of Half-Cheetah.

We also tried these comparisons on the ‘pendulum’ prob-
lem in OpenAI Gym where we did not observe signiﬁcant
advantages from explorations. We believe that this is be-
cause this problem does not beneﬁt from using exploration
and pure-exploitative methods are good enough for these
problems. More extensive experiments are required to val-
idate the results presented in this section.

8 Discussion and Conlcusions

We proposed a general-purpose
explorative-learning
method called VAN. VAN is derived within the variational-
optimization problem by using a mirror-descent algorithm.
We showed that VAN is a second-order method and is re-
lated to existing methods in continuous optimization, vari-
ational inference, and evolution strategies. We proposed
computationally-efﬁcient versions of VAN for large-scale
learning. Our experimental results showed that VAN works
reasonably well on a wide-variety of learning problems.

develop versions of VAN that can deal with issue without
making a diagonal approximation.

It is straightforward to extend VAN to non-Gaussian dis-
tributions. Our initial work, not discussed in this paper,
suggests that student-t distribution and Cauchy distribution
could be useful candidate. However, it is always possible
to use other types of distributions, for example, to mini-
mize discrete optimization problem within a stochastic re-
laxation framework (Geman and Geman, 1984).

Another venue is to evaluate the impact of exploration on
ﬁelds such as active learning and reinforcement learning.
In this paper, we have provided some initial results. An
extensive application of the methods developed in this pa-
per to real-world problems is required to further understand
their advantages and disadvantages compared to existing
methods.

The main strength of VAN lies in exploration, using which
it can potentially accelerate and robustify optimization.
Compared to Bayesian methods, VAN offers a computa-
tionally cheap alternative to perform explorative learning.
Using such cheap explorations, VAN has the potential to
solve difﬁcult learning problems such as deep reinforce-
ment learning, active learning, and life-long learning.

References

Amari, S.-I. (1998). Natural gradient works efﬁciently in

learning. Neural computation, 10(2):251–276.

Bertsekas, D. P. (1999). Nonlinear programming. Athena

Scientiﬁc.

Bhatnagar, S. (2007). Adaptive Newton-based multivari-
ate smoothed functional algorithms for simulation op-
timization. ACM Transactions on Modeling and Com-
puter Simulation (TOMACS), 18(1):2.

Bishop, C. M. (2006). Pattern recognition. Machine Learn-

ing, 128:1–58.

Brochu, E., Cora, V. M., and De Freitas, N. (2010).
A tutorial on Bayesian optimization of expensive cost
functions, with application to active user modeling and
arXiv preprint
hierarchical reinforcement
arXiv:1012.2599.

learning.

Brockman, G., Cheung, V., Pettersson, L., Schneider, J.,
Schulman, J., Tang, J., and Zaremba, W. (2016). Openai
gym.

Byrd, R. H., Hansen, S. L., Nocedal, J., and Singer, Y.
(2016). A stochastic quasi-Newton method for large-
SIAM Journal on Optimization,
scale optimization.
26(2):1008–1031.

For problems with high-dimensional parameters θ, com-
puting and inverting the full Hessian matrix is computa-
tionally infeasible. One line of possible future work is to

Chang, C.-C. and Lin, C.-J. (2011). LIBSVM: A li-
ACM Transac-
brary for support vector machines.
tions on Intelligent Systems and Technology, 2:27:1–

Variational Adaptive-Newton Method

27:27. Software available at http://www.csie.
ntu.edu.tw/˜cjlin/libsvm.

Crammer, K., Kulesza, A., and Dredze, M. (2009). Adap-
tive regularization of weight vectors. In Advances in neu-
ral information processing systems, pages 414–422.
Duchi, J., Hazan, E., and Singer, Y. (2011). Adaptive sub-
gradient methods for online learning and stochastic op-
timization. The Journal of Machine Learning Research,
12:2121–2159.

Marlin, B., Khan, M., and Murphy, K. (2011). Piecewise
bounds for estimating Bernoulli-logistic latent Gaussian
models. In International Conference on Machine Learn-
ing.

Mokhtari, A., Daneshmand, H., Lucchi, A., Hofmann,
T., and Ribeiro, A. (2016). Adaptive Newton method
for empirical risk minimization to statistical accuracy.
In Advances in Neural Information Processing Systems,
pages 4062–4070.

Fishel, J. A. and Loeb, G. E. (2012). Bayesian exploration
for intelligent identiﬁcation of textures. Frontiers in neu-
rorobotics, 6.

Opper, M. and Archambeau, C. (2009). The Variational
Gaussian Approximation Revisited. Neural Computa-
tion, 21(3):786–792.

Fortunato, M., Azar, M. G., Piot, B., Menick, J., Osband, I.,
Graves, A., Mnih, V., Munos, R., Hassabis, D., Pietquin,
O., et al. (2017). Noisy networks for exploration. arXiv
preprint arXiv:1706.10295.

Gal, Y., Islam, R., and Ghahramani, Z. (2017). Deep
Bayesian Active Learning with Image Data. ArXiv e-
prints.

Geman, S. and Geman, D. (1984). Stochastic relaxation,
Gibbs distributions, and the Bayesian restoration of im-
IEEE Transactions on pattern analysis and ma-
ages.
chine intelligence, 1(6):721–741.

Ghadimi, S., Lan, G., and Zhang, H. (2014). Mini-
batch stochastic approximation methods for nonconvex
stochastic composite optimization. Mathematical Pro-
gramming, pages 1–39.

G¨urb¨uzbalaban, M., Ozdaglar, A., and Parrilo, P. (2015). A
globally convergent incremental Newton method. Math-
ematical Programming, 151(1):283–313.

Hansen, N. and Ostermeier, A. (2001). Completely deran-
domized self-adaptation in evolution strategies. Evolu-
tionary computation, 9(2):159–195.

Houlsby, N., Husz´ar, F., Ghahramani, Z., and Lengyel, M.
(2011). Bayesian Active Learning for Classiﬁcation and
Preference Learning. ArXiv e-prints.

Huszar, F. (2017).

Optimisation and Natural ES.
evolution-strategies-variational-optimisation-and-natural-es-2/.

Evolution Strategies, Variational
http://www.inference.vc/

Khan, M. E. and Lin, W. (2017). Conjugate-computation
variational inference: Converting variational inference in
non-conjugate models to inferences in conjugate models.
arXiv preprint arXiv:1703.04265.

Kingma, D. and Ba, J. (2014).
optimization.

stochastic

for
arXiv:1412.6980.

Adam: A method
preprint

arXiv

Perfors, A., Tenenbaum, J. B., Grifﬁths, T. L., and Xu, F.
(2011). A tutorial introduction to Bayesian models of
cognitive development. Cognition, 120(3):302–321.

Plappert, M., Houthooft, R., Dhariwal, P., Sidor, S., Chen,
R. Y., Chen, X., Asfour, T., Abbeel, P., and Andrychow-
icz, M. (2017). Parameter space noise for exploration.
arXiv preprint arXiv:1706.01905.

Ranganath, R., Gerrish, S., and Blei, D. M. (2014). Black
box variational inference. In International conference on
Artiﬁcial Intelligence and Statistics, pages 814–822.

Raskutti, G. and Mukherjee, S. (2015). The information
geometry of mirror descent. IEEE Transactions on In-
formation Theory, 61(3):1451–1457.

Rezende, D. J. and Mohamed, S. (2015). Variational
arXiv preprint

inference with normalizing ﬂows.
arXiv:1505.05770.

R¨uckstieß, T., Sehnke, F., Schaul, T., Wierstra, D., Sun, Y.,
and Schmidhuber, J. (2010). Exploring parameter space
in reinforcement learning. Paladyn, 1(1):14–24.

Salimans, T., Ho, J., Chen, X., Sidor, S., and Sutskever, I.
(2017). Evolution Strategies as a Scalable Alternative to
Reinforcement Learning. ArXiv e-prints.

Schein, A. I. and Ungar, L. H. (2007). Active learning for
logistic regression: an evaluation. Machine Learning,
68(3):235–265.

Silver, D., Lever, G., Heess, N., Degris, T., Wierstra, D.,
and Riedmiller, M. A. (2014). Deterministic policy gra-
In Proceedings of the 31th Interna-
dient algorithms.
tional Conference on Machine Learning, ICML 2014,
Beijing, China, 21-26 June 2014, pages 387–395.

Spall, J. C. (2000). Adaptive stochastic approximation by
IEEE transac-

the simultaneous perturbation method.
tions on automatic control, 45(10):1839–1853.

Kingma, D. P. and Welling, M. (2013). Auto-encoding vari-

Staines, J. and Barber, D. (2012). Variational Optimization.

ational Bayes. arXiv preprint arXiv:1312.6114.

ArXiv e-prints.

Lillicrap, T. P., Hunt, J. J., Pritzel, A., Heess, N., Erez, T.,
Tassa, Y., Silver, D., and Wierstra, D. (2015). Contin-
uous control with deep reinforcement learning. CoRR,
abs/1509.02971.

Strens, M. (2000). A Bayesian framework for reinforce-
In In Proceedings of the Seventeenth
ment learning.
International Conference on Machine Learning, pages
943–950. ICML.

Khan, Lin, Tangkaratt, Liu, and Nielsen

Tieleman, T. and Hinton, G. (2012). Lecture 6.5-RMSprop:
Divide the gradient by a running average of its recent
magnitude. COURSERA: Neural Networks for Machine
Learning 4.

Wainwright, M. J. and Jordan, M. I. (2008). Graphical
models, exponential families, and variational inference.
Foundations and Trends in Machine Learning, 1–2:1–
305.

Wierstra, D., Schaul, T., Peters, J., and Schmidhuber, J.
In Evolutionary
(2008). Natural evolution strategies.
Computation, 2008. CEC 2008.(IEEE World Congress
on Computational Intelligence). IEEE Congress on,
pages 3381–3387. IEEE.

Williams, R. J. (1992).

Simple statistical gradient-
following algorithms for connectionist reinforcement
learning. Machine learning, 8(3-4):229–256.

Wyatt, J. (1998). Exploration and inference in learning
from reinforcement. PhD thesis, University of Edin-
burgh. College of Science and Engineering. School of
Informatics.

A Derivation of VAN

Variational Adaptive-Newton Method

Denote the mean parameters of qt(θ) by mt which is equal to the expected value of the sufﬁcient statistics φ(θ), i.e.,
mt := Eqt[φ(θ)]. The mirror descent update at iteration t is given by the solution to

mt+1 = argmin

m, (cid:98)∇mLt

+

(cid:68)

(cid:69)

D

KL[q (cid:107) qt]

1
βt

(cid:69)

= argmin

Eq

φ(θ), (cid:98)∇mLt

+ log

(q/qt)1/βt

(cid:17)(cid:105)

m

m

m

m

m

m

= argmin

Eq

log





= argmin

Eq

log



(cid:104)(cid:68)



(cid:16)

(cid:69)

q

(cid:68)

exp

φ(θ), (cid:98)∇mLt
q1/βt
t

q1/βt





q1/βt
t




q1/βt
(cid:68)

exp

φ(θ), − (cid:98)∇mLt









(cid:69)

(cid:68)

qt exp

φ(θ), −βt (cid:98)∇mLt
(cid:69)

φ(θ), −βt (cid:98)∇mLt









(cid:69)

(cid:105)

/Zt

.

= argmin

Eq

log



= argmin

DKL

(cid:104)
q(cid:107)qt exp

(cid:68)

1
βt

1
βt

where Z is the normalizing constant of the distribution in the denominator which is a function of the gradient and step size.

Minimizing this KL divergence gives the update

qt+1(θ) ∝ qt(θ) exp

φ(θ), −βt (cid:98)∇mLt

(cid:68)

(cid:69)

.

By rewriting this, we see that we get an update in the natural parameters λt of qt(θ), i.e.

Recalling that the mean parameters of a Gaussian q(θ) = N (θ|µ, Σ) are m(1) = µ and M(2) = Σ + µµT and using the
chain rule, we can express the gradient (cid:98)∇mLt in terms of µ and Σ,

λt+1 = λt − βt (cid:98)∇mLt.

(cid:98)∇m(1)L = (cid:98)∇µL − 2

(cid:98)∇ΣL

µ

(cid:104)

(cid:105)

(cid:98)∇M (2)L = (cid:98)∇ΣL.

Finally, recalling that the natural parameters of a Gaussian q(θ) = N (θ|µ, Σ) are λ(1) = Σ−1µ and λ(2) = − 1
can rewrite the VAN updates in terms of µ and Σ,

2 Σ−1, we

(cid:104)

(cid:98)∇ΣLt

(cid:105)

Σ−1

t+1 = Σ−1

µt+1 = Σt+1

t + 2βt
(cid:104)
Σ−1
(cid:16)

Σ−1

= Σt+1

= µt − βtΣt+1

(cid:16)

(cid:98)∇µLt − 2
(cid:105)(cid:17)

t µt − βt
(cid:104)

t + 2βt
(cid:104)
(cid:98)∇µLt

(cid:98)∇ΣLt
(cid:105)

.

(cid:104)

(cid:98)∇ΣLt

(cid:105)

(cid:17)(cid:105)

µt
(cid:104)

µt − βtΣt+1

(cid:98)∇µLt

(cid:105)

B Details on the RL experiment

In this section, we give details of the parameter-based exploration task in reinforcement learning (RL). An important open
question in reinforcement learning is how to efﬁciently explore the state and action space. An agent always acting greedily
according to the policy results in a pure exploitation. Exploration is necessary to visit inferior state and actions once in
while to see if they might really be better. Traditionally, exploration is performed in the action space by, e.g., injecting

(31)

(32)

(33)

(34)

(35)

(36)

(37)

(38)

(39)

(40)

(41)

(42)

(43)

(44)

Khan, Lin, Tangkaratt, Liu, and Nielsen

noise to the policy output. However, injecting noise to the action space may not be sufﬁcient in problems where the reward
is sparse, i.e., the agent rarely observes the reward of their actions. In such problems, the agent requires a rich explorative
behaviour in which noises in the action space cannot provide. An alternative approach is to perform exploration in the
parameter space (R¨uckstieß et al., 2010). In this section, we demonstrate that variational distribution q(θ) obtained using
VAN can be straightforwardly used for such exploration in parameter space, θ.

B.1 Background

First, we give a brief background on reinforcement learning (RL). RL aims to solve the sequential decision making problem
where at each discrete time step t an agent observes a state st and selects an action at using a policy π, i.e., at ∼ π(a|st).
The agent then receives an immediate reward rt = r(st, at) and observes a next state st ∼ p(s(cid:48)|st, at). The goal in RL is
(cid:3) where γ is the discounted factor and
to learn the optimal policy π∗ which maximizes the expected returns E (cid:2)(cid:80)∞
the expectation is taken over a sequence of densities π(a|st) and p(s(cid:48)|st, at).
A central component of RL algorithms is the state-action value function or the Q-function Qπ(s, a) gives the expected
return after executing an action a in a state s and following the policy π afterwards. Formally, it is deﬁned as follows:

t γt−1rt

Qπ(s, a) = E

(cid:34) ∞
(cid:88)

(cid:35)
γt−1rt|s1 = s, a1 = a

.

t=1

The Q-function also satisﬁes a recursive relation also known as the Bellman equation:

Qπ(s, a) = r(s, a) + γEp(s(cid:48)|s,a),π(a(cid:48)|s(cid:48)) [Qπ(s(cid:48), a(cid:48))] .

Using the Q-function, the goal of reinforcement learning can be simply stated as ﬁnding a policy which maximizes the
expected Q-function, i.e.,

π∗ = argmax

p(s)π(a|s)Qπ(s, a)dsda.

(cid:90) (cid:90)

π

In practice, the policy is represented by a parameterized function such as neural networks with policy parameter θ and the
goal is to instead ﬁnd the optimal parameters θ(cid:63).

B.1.1 Deterministic Policy Gradients

Our parameter-based exploration via VAN can be applied to any reinforcement learning algorithms which rely on gradient
ascent to optimize the policy parameter θ. For demonstration, we focus on a simple yet efﬁcient algorithm called the
deterministic policy gradients algorithm (DPG) (Silver et al., 2014). Simply speaking, DPG aims to ﬁnd a deterministic
policy that maximizes the action-value function by gradient ascent. Since in practice the action-value function is unknown,
DPG learns a function approximator Qv(s, a) with a parameter v such that Qv(s, a) ≈ Qπθ (s, a). Then, DPG ﬁnds θ∗
which locally minimize an objective f (θ) = −Ep(s) [Qv(s, πθ(s))] by gradient ascent where the gradient is given by

∇θf (θ) = −∇θ

p(s)Qv(s, πθ(s))ds

= −

p(s)∇θQv(s, πθ(s))ds

(cid:90)

(cid:90)

(cid:90)

= −

p(s)∇aQv(s, a)|a=πθ (s)∇θπθ(s)ds.

The parameter v of Qv(s, a) may be learned by any policy evaluation methods. Here, we adopted the approach proposed
by (Lillicrap et al., 2015) which minimizes the squared Bellman residual to the slowly moving target action-value function.
More precisely, v is updated by

(cid:20)(cid:16)

E

min
v

Qv(s, a) − r(s, a) − γ ˜Q˜v(s(cid:48), ˜π˜θ(s(cid:48)))

(cid:17)2(cid:21)

,

where the expectation is taken over p(s) and p(s(cid:48)|s, a). The ˜Q˜v and ˜π˜θ denote target networks which are separate function
approximators that slowly tracks Qv and πθ, respectively. The target networks help at stabilizing the learning proce-
dure (Lillicrap et al., 2015).

(45)

(46)

(47)

(48)

(49)

Variational Adaptive-Newton Method

Algorithm 1 Parameter-based exploration DPG via VAN
1: while Not converged do
2:
3:
4:
5:
6:

Drawn N minibatch samples {(si, ai, ri, s(cid:48)
Update Qv(s, a) by gradient descent:

t) to a replay buffer D.

i)}N

i=1 from D.

Observe state st, sample parameter θ ∼ N (θ|µ, Σ), take action at = πθ(st), observe reward rt and next state s(cid:48)
t.
Add (st, at, rt, s(cid:48)
for i = 1, . . . , K do

v ← v + αv∇v

(cid:104)

(Qv(si, ai) − yi)2(cid:105)

,

1
N

N
(cid:88)

i=1

where yi = r(si, ai) + γ ˜Q˜v(s(cid:48)
Update parameter of q(θ) by sVAN in Eq.(17) with

i, π ˜µ(s(cid:48)

i)).

7:

(cid:98)∇σL(µt, σ2

t ) = −

∇σπθj (si)∇aQv(si, a)|a=πθj (si)

(cid:98)∇µL(µt, σ2

t ) = −

∇µπθj (si)∇aQv(si, a)|a=πθj (si)

1
N M

1
N M

N
(cid:88)

M
(cid:88)

(cid:104)

i=1

j=1

N
(cid:88)

M
(cid:88)

(cid:104)

i=1

j=1

(cid:105)

,

(cid:105)

,

(51)

(52)

where {θj}M
Update target network parameters ˜v and ˜µ by moving average with, e.g., step size τ = 0.001:

j=1 ∼ q(θ).

8:

˜v ← (1 − τ )˜v + τ v,
˜µ ← (1 − τ ) ˜µ + τ µ.

end for
9:
10: end while

Overall, DPG is an actor-critic algorithm that iteratively update the critic (action-value function) by taking gradient of
Eq.(49) and update the actor (policy) by the gradient Eq.(48). However, the crucial issue of DPG is that it uses a determin-
istic policy and does not perform exploration by itself. In practice, exploration is done for DPG by injecting a noise to the
policy output, i.e., a = πθ(s) + (cid:15) where (cid:15) is a noise from some random process such as Gaussian noise. However, as dis-
cussed about, action-space noise may be insufﬁcient in some problems. Next, we show that VAN can be straightforwardly
applied to DPG to obtain parameter-based exploration DPG.

B.1.2 Parameter-based Exploration DDPG

To perform parameter-based exploration, we can relax the policy-gradient objective f (θ) by assuming that the parameter
θ is sampled from a distribution q(θ) := N (θ|µ, Σ), and solve the following optimization problem:

min
µ,Σ

EN (θ|µ,Σ)[f (θ)]

(50)

This is exactly the VO problem of (2). The stochasticity of θ through q(θ) allows the agent to explore the state and action
space by varying its policy parameters. This exploration strategy is advantageous since the agent can now exhibits much
more richer explorative behaviours when compared with exploration by action noise injection.

Algorithm 1 outlines parameter-based exploration DPG via VAN.

